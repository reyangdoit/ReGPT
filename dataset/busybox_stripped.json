{
    "sub_804CC42": [
        "0x804cc42",
        "void sub_804CC42()\n{\n  ;\n}\n"
    ],
    "sub_804CC46": [
        "0x804cc46",
        "void *sub_804CC46()\n{\n  return &unk_80DB564;\n}\n"
    ],
    "sub_804CCA4": [
        "0x804cca4",
        "int sub_804CCA4()\n{\n  int result; // eax\n\n  if ( !byte_80DB62C )\n  {\n    while ( dword_80DB630 < (unsigned int)(&dword_80DAF4C - dword_80DAF48 - 1) )\n      ((void (*)(void))dword_80DAF48[++dword_80DB630])();\n    sub_804CC46();\n    result = 0;\n    byte_80DB62C = 1;\n  }\n  return result;\n}\n"
    ],
    "sub_804CD07": [
        "0x804cd07",
        "__int64 sub_804CD07()\n{\n  return 0LL;\n}\n"
    ],
    "sub_804CD3D": [
        "0x804cd3d",
        "int __usercall sub_804CD3D@<eax>(_DWORD *a1@<eax>)\n{\n  _DWORD *i; // edx\n\n  for ( i = a1; *i; ++i )\n    ;\n  return i - a1;\n}\n"
    ],
    "sub_804CD51": [
        "0x804cd51",
        "unsigned int __usercall sub_804CD51@<eax>(const char *a1@<eax>)\n{\n  unsigned __int16 *v2; // ebp\n  unsigned int v3; // esi\n  const char *v4; // ebx\n  int v5; // eax\n  unsigned int v6; // edx\n  unsigned int v7; // esi\n  unsigned int result; // eax\n  const char *i; // ecx\n  char v10; // dl\n\n  v2 = (unsigned __int16 *)&unk_80B8510;\n  v3 = 2136;\n  while ( 1 )\n  {\n    v4 = (const char *)(v2[6] + 135033847);\n    v5 = strcmp(a1, v4);\n    v6 = v3 - 267;\n    if ( v5 >= 0 )\n      break;\n    --v2;\n    v3 -= 267;\n    if ( v6 == 267 )\n    {\n      v4 = s;\n      v6 = 0;\n      break;\n    }\n  }\n  v7 = v3 >> 3;\n  for ( result = v6 >> 3; result < v7; ++result )\n  {\n    for ( i = a1; ; ++i )\n    {\n      v10 = *v4;\n      if ( *i != *v4 )\n        break;\n      if ( !v10 )\n        return result;\n      ++v4;\n    }\n    while ( 1 )\n    {\n      ++v4;\n      if ( !v10 )\n        break;\n      v10 = *v4;\n    }\n  }\n  return -1;\n}\n"
    ],
    "sub_804CDC2": [
        "0x804cdc2",
        "void __cdecl __noreturn sub_804CDC2()\n{\n  signed int v0; // eax\n  const char *v1; // ebx\n  const char *v2; // eax\n\n  v0 = sub_804CD51(ident);\n  if ( v0 >= 0 )\n  {\n    v1 = (const char *)&asc_80B891C[1];\n    while ( v0 )\n    {\n      do\n        ++v1;\n      while ( *(v1 - 1) );\n      --v0;\n    }\n    sub_804D85F(\"BusyBox v1.29.2 (2024-11-01 02:03:16 UTC)\");\n    sub_804D85F(\" multi-call binary.\\n\");\n    v2 = \"\\nNo help available.\\n\\n\";\n    if ( *v1 != 8 )\n    {\n      sub_804D85F(\"\\nUsage: \");\n      sub_804D85F(ident);\n      sub_804D85F(\" \");\n      sub_804D85F(v1);\n      v2 = \"\\n\";\n    }\n    sub_804D85F(v2);\n  }\n  sub_804D604();\n}\n"
    ],
    "sub_804CE38": [
        "0x804ce38",
        "char *__cdecl sub_804CE38(char *a1)\n{\n  char *result; // eax\n\n  dword_80DBB7C = (int)__errno_location();\n  result = a1;\n  ident = a1;\n  return result;\n}\n"
    ],
    "sub_804CE4C": [
        "0x804ce4c",
        "void __usercall __noreturn sub_804CE4C(char **argv@<ecx>, int a2@<eax>, char *a3@<edx>)\n{\n  int v7; // ecx\n  int v8; // ebp\n  __uid_t v9; // edi\n  int v10; // eax\n  __gid_t v11; // [esp+0h] [ebp-14h]\n\n  v8 = sub_804CD3D(argv);\n  ident = a3;\n  if ( a2 != 54 && a2 != 231 && a2 != 224 && v8 == 2 && !strcmp(*(const char **)(v7 + 4), \"--help\") )\n  {\n    byte_80DB560 = 0;\n    sub_804CDC2();\n  }\n  v9 = uid;\n  if ( uid )\n  {\n    v11 = getgid();\n    v10 = ((int)(unsigned __int8)byte_80C73B4[a2 / 4] >> (2 * (a2 % 4))) & 3;\n    if ( v10 == 2 )\n    {\n      if ( geteuid() )\n        sub_804D5E0(\"must be suid to work properly\", v11);\n    }\n    else if ( !v10 )\n    {\n      setgid(v11);\n      setuid(v9);\n    }\n  }\n  byte_80DB560 = ((int (__cdecl *)(int, int))funcs_804CF01[a2])(v8, (int)argv);\n  sub_804D604();\n}\n"
    ],
    "sub_804CF12": [
        "0x804cf12",
        "void __usercall __noreturn sub_804CF12(char *a1@<eax>, char **a2@<edx>, int a4@<ebp>)\n{\n  int v6; // edx\n  char *v7; // eax\n  int v8; // ebx\n  int v9; // esi\n  const char *i; // ebx\n  size_t v11; // edi\n  const char *v12; // esi\n  unsigned int v13; // edi\n  int v14; // edx\n  const char *v15; // esi\n  int v16; // edi\n  int v17; // ecx\n  char *v18; // esi\n  const char *v19; // eax\n  bool v20; // zf\n  char *v21; // edi\n  unsigned int j; // ebx\n  __int16 *v23; // eax\n  int v24; // edx\n  char *v25; // ebp\n  int v26; // eax\n  const char *v27; // eax\n  int v28; // ecx\n  int v29; // eax\n  int v30; // [esp-8h] [ebp-20h]\n  int v31; // [esp+0h] [ebp-18h]\n  const char *v32; // [esp+0h] [ebp-18h]\n  int (*v33)(const char *, const char *); // [esp+4h] [ebp-14h]\n\n  if ( !sub_804D210(a1, \"busybox\") )\n  {\n    v29 = sub_804CD51(a1);\n    if ( v29 >= 0 )\n      sub_804CE4C(a2, v29, a1);\n    sub_804D85F(ident);\n    sub_804D85F(\": applet not found\\n\");\n    exit(127);\n  }\n  v7 = a2[1];\n  if ( !v7 )\n    goto LABEL_3;\n  if ( sub_804D210(v7, MEMORY[0x80B88C4]) )\n  {\n    dup2(1, 2);\n    v12 = s;\n    v13 = 0;\n    while ( *v12 )\n    {\n      if ( a2[1][6] )\n      {\n        v14 = byte_80C732E[v13 >> 1] & 0xF;\n        if ( (v13 & 1) != 0 )\n          v14 = (unsigned __int8)byte_80C732E[v13 >> 1] >> 4;\n        sub_804D85F((const char *)(&off_80B75B0)[v14] + 1);\n      }\n      sub_804D85F(v12);\n      sub_804D85F(\"\\n\");\n      ++v13;\n      do\n        ++v12;\n      while ( *(v12 - 1) );\n    }\n  }\n  else\n  {\n    v15 = a2[1];\n    v16 = strcmp(v15, \"--install\");\n    if ( v16 )\n    {\n      v26 = strcmp(v15, \"--help\");\n      v6 = v30;\n      if ( v26 )\n      {\n        ++a2;\n      }\n      else\n      {\n        v27 = a2[2];\n        if ( !v27 )\n        {\nLABEL_3:\n          v8 = sub_804D986(2, v6);\n          dup2(1, 2);\n          sub_804D85F(\"BusyBox v1.29.2 (2024-11-01 02:03:16 UTC)\");\n          sub_804D85F(\" multi-call binary.\\n\");\n          sub_804D85F(\n            \"BusyBox is copyrighted by many authors between 1998-2015.\\n\"\n            \"Licensed under GPLv2. See source distribution for detailed\\n\"\n            \"copyright notices.\\n\"\n            \"\\n\"\n            \"Usage: busybox [function [arguments]...]\\n\"\n            \"   or: busybox --list[-full]\\n\"\n            \"   or: busybox --install [-s] [DIR]\\n\"\n            \"   or: function [arguments]...\\n\"\n            \"\\n\"\n            \"\\tBusyBox is a multi-call binary that combines many common Unix\\n\"\n            \"\\tutilities into a single executable.  Most people will create a\\n\"\n            \"\\tlink to busybox for each function they wish to use and BusyBox\\n\"\n            \"\\twill act like whatever it was invoked as.\\n\"\n            \"\\n\"\n            \"Currently defined functions:\\n\");\n          v31 = v8 - 1;\n          v9 = 0;\n          for ( i = s; ; i += v11 + 1 )\n          {\n            if ( !*i )\n            {\n              sub_804D85F(\"\\n\");\n              goto LABEL_48;\n            }\n            v11 = strlen(i);\n            if ( (int)(v31 - (v11 + 2)) <= v9 )\n              break;\n            if ( !v9 )\n              goto LABEL_8;\n            sub_804D85F(\", \");\nLABEL_10:\n            sub_804D85F(i);\n            v9 += v11 + 2;\n          }\n          sub_804D85F(\",\\n\");\nLABEL_8:\n          sub_804D85F(\"\\t\");\n          v9 = 6;\n          goto LABEL_10;\n        }\n        *a2 = (char *)v27;\n        a2[2] = 0;\n      }\n      ident = sub_804D32D(*a2);\n      sub_804CF12(ident, (const char **)a2, v28, a4);\n    }\n    v18 = (char *)sub_804E190(\"/proc/self/exe\");\n    if ( !v18 )\n    {\n      v18 = *a2;\n      if ( **a2 != 47 )\n        sub_804D5E0(\"'%s' is not an absolute path\", *a2);\n    }\n    v19 = a2[2];\n    if ( v19 && !strcmp(v19, \"-s\") )\n    {\n      v20 = ++a2 == 0;\n      v16 = !v20;\n    }\n    v32 = a2[2];\n    v33 = symlink;\n    if ( !v16 )\n      v33 = link;\n    v21 = (char *)s;\n    for ( j = 0; j != 267; ++j )\n    {\n      v23 = (__int16 *)v32;\n      if ( !v32 )\n      {\n        v24 = byte_80C732E[j >> 1] & 0xF;\n        if ( (j & 1) != 0 )\n          v24 = (unsigned __int8)byte_80C732E[j >> 1] >> 4;\n        v23 = (&off_80B75B0)[v24];\n      }\n      v25 = (char *)sub_804D2D1((int)v23, v21, v17);\n      if ( v33(v18, v25) && *(_DWORD *)dword_80DBB7C != 17 )\n        sub_804D3F1(v25);\n      free(v25);\n      do\n        ++v21;\n      while ( *(v21 - 1) );\n    }\n  }\nLABEL_48:\n  exit(0);\n}\n"
    ],
    "sub_804D210": [
        "0x804d210",
        "_BYTE *__usercall sub_804D210@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>)\n{\n  while ( *a2 )\n  {\n    if ( *result != *a2 )\n      return 0;\n    ++a2;\n    ++result;\n  }\n  return result;\n}\n"
    ],
    "sub_804D222": [
        "0x804d222",
        "int __usercall sub_804D222@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // esi\n\n  v4 = 0;\n  while ( *a1 )\n  {\n    if ( !strcmp(a1, a2) )\n      return v4;\n    a1 += strlen(a1) + 1;\n    ++v4;\n  }\n  return -1;\n}\n"
    ],
    "sub_804D254": [
        "0x804d254",
        "int __usercall sub_804D254@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  size_t v4; // eax\n  size_t v5; // edi\n  int v6; // ebx\n  int v8; // [esp+0h] [ebp-14h]\n\n  v4 = strlen(a2);\n  if ( !v4 )\n    return -1;\n  v5 = v4;\n  v8 = 0;\n  v6 = -1;\n  while ( *a1 )\n  {\n    if ( !strncmp(a1, a2, v5) )\n    {\n      if ( !a1[v5] )\n        return v8;\n      if ( v6 != -1 )\n        return -1;\n      v6 = v8;\n    }\n    a1 += strlen(a1) + 1;\n    ++v8;\n  }\n  return v6;\n}\n"
    ],
    "sub_804D2B4": [
        "0x804d2b4",
        "const char *__usercall sub_804D2B4@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  while ( a2 )\n  {\n    --a2;\n    a1 += strlen(a1) + 1;\n  }\n  return a1;\n}\n"
    ],
    "sub_804D2D1": [
        "0x804d2d1",
        "int __usercall sub_804D2D1@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  const char *v4; // ebx\n\n  v4 = &data;\n  if ( a1 )\n    LOBYTE(v4) = a1;\n  sub_804D378(a3, 47);\n  while ( *a2 == 47 )\n    ++a2;\n  return sub_804DDBF(\"%s%s%s\", (char)v4);\n}\n"
    ],
    "sub_804D315": [
        "0x804d315",
        "char *__usercall sub_804D315@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  char *v2; // eax\n\n  v1 = a1;\n  v2 = strrchr(a1, 47);\n  if ( v2 )\n    return v2 + 1;\n  return (char *)v1;\n}\n"
    ],
    "sub_804D32D": [
        "0x804d32d",
        "char *__usercall sub_804D32D@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  char *v2; // eax\n\n  v1 = a1;\n  v2 = strrchr(a1, 47);\n  if ( v2 && (v1 != v2 || v1[1]) )\n    return v2 + 1;\n  return (char *)v1;\n}\n"
    ],
    "sub_804D34F": [
        "0x804d34f",
        "char *__usercall sub_804D34F@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // eax\n\n  v3 = (const char *)sub_804D378(a2, 47);\n  if ( v3 )\n  {\n    while ( *v3 == 47 && v3 != a1 )\n      *v3-- = 0;\n  }\n  return sub_804D32D(a1);\n}\n"
    ],
    "sub_804D378": [
        "0x804d378",
        "const char *__usercall sub_804D378@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *result; // eax\n\n  if ( !a1 )\n    return 0;\n  result = 0;\n  if ( *a1 )\n  {\n    result = &a1[strlen(a1) - 1];\n    if ( *(unsigned __int8 *)result != a2 )\n      return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_804D3A5": [
        "0x804d3a5",
        "int sub_804D3A5(int a1, ...)\n{\n  char *v1; // eax\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v1 = 0;\n  if ( *(_DWORD *)dword_80DBB7C )\n    v1 = strerror(*(_DWORD *)dword_80DBB7C);\n  return sub_804D40A(v1, (char *)va);\n}\n"
    ],
    "sub_804D3C9": [
        "0x804d3c9",
        "void __noreturn sub_804D3C9(int a1, ...)\n{\n  char *v1; // eax\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v1 = 0;\n  if ( *(_DWORD *)dword_80DBB7C )\n    v1 = strerror(*(_DWORD *)dword_80DBB7C);\n  sub_804D40A(v1, (char *)va);\n  sub_804D604();\n}\n"
    ],
    "sub_804D3F1": [
        "0x804d3f1",
        "__int64 __usercall sub_804D3F1@<edx:eax>(const char *a1@<eax>)\n{\n  __int64 v2; // [esp-8h] [ebp-8h]\n\n  sub_804D3A5((int)\"%s\", a1);\n  return v2;\n}\n"
    ],
    "sub_804D3FF": [
        "0x804d3ff",
        "void __usercall __noreturn sub_804D3FF(const char *a1@<eax>)\n{\n  sub_804D3C9((int)\"%s\", a1);\n}\n"
    ],
    "sub_804D40A": [
        "0x804d40a",
        "char *__usercall sub_804D40A@<eax>(char *result@<eax>, va_list a2@<edx>, const char *a3@<ecx>)\n{\n  const char *v3; // edi\n  size_t v5; // esi\n  signed int v6; // ebx\n  size_t v7; // ebp\n  char *v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  size_t v11; // ebx\n  int v12; // eax\n  int v13; // [esp-8h] [ebp-80h]\n  int v14; // [esp-8h] [ebp-80h]\n  int v15; // [esp-4h] [ebp-7Ch]\n  int v16; // [esp-4h] [ebp-7Ch]\n  int v17; // [esp-4h] [ebp-7Ch]\n  size_t v18; // [esp+0h] [ebp-78h]\n  size_t v20; // [esp+8h] [ebp-70h]\n  size_t v21; // [esp+Ch] [ebp-6Ch]\n  size_t v22; // [esp+10h] [ebp-68h]\n  char *dest; // [esp+14h] [ebp-64h] BYREF\n  char v24[96]; // [esp+18h] [ebp-60h] BYREF\n\n  if ( !byte_80DB561 )\n    return result;\n  v3 = result;\n  if ( !result )\n    v3 = &data;\n  v20 = strlen(ident);\n  v5 = v20 + 2;\n  v22 = v20 + 2;\n  v18 = 0;\n  if ( a3 )\n    v18 = strlen(a3);\n  v21 = strlen(off_80DB54C);\n  if ( (int)(80 - v5) > 0 )\n  {\n    dest = v24;\n    v6 = v5 + vsnprintf(&v24[v5], 80 - v5, v3, a2);\n    if ( (int)(77 - v21 - v18) > v6 )\n      goto LABEL_12;\n  }\n  result = (char *)vasprintf(&dest, v3, a2);\n  v7 = (size_t)result;\n  if ( (int)result < 0 )\n    return result;\n  v6 = (signed int)&result[v5];\n  v8 = (char *)realloc(dest, (size_t)&result[v5 + 3 + v18 + v21]);\n  v9 = v13;\n  v10 = v15;\n  if ( v8 )\n  {\n    dest = v8;\n    memmove(&v8[v5], v8, v7);\nLABEL_12:\n    strcpy(dest, ident);\n    dest[v20] = 58;\n    dest[v20 + 1] = 32;\n    if ( a3 )\n    {\n      if ( *v3 )\n      {\n        v12 = v6 + 1;\n        dest[v6] = 58;\n        v6 += 2;\n        dest[v12] = 32;\n      }\n      strcpy(&dest[v6], a3);\n      v6 += v18;\n    }\n    strcpy(&dest[v6], off_80DB54C);\n    v11 = v21 + v6;\n    v9 = v14;\n    v10 = v16;\n    goto LABEL_17;\n  }\n  v11 = v7 + 1;\n  dest[v7] = 10;\n  v22 = 0;\nLABEL_17:\n  if ( (byte_80DB561 & 1) != 0 )\n  {\n    sub_804DD8F(v10, v9);\n    sub_804E586(v11, dest);\n  }\n  if ( (byte_80DB561 & 2) != 0 )\n    syslog(byte_80DB562, \"%s\", &dest[v22]);\n  result = dest;\n  if ( dest != v24 )\n  {\n    free(dest);\n    return (char *)v17;\n  }\n  return result;\n}\n"
    ],
    "sub_804D5E0": [
        "0x804d5e0",
        "void __noreturn sub_804D5E0(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  sub_804D40A(a1, va, 0);\n  sub_804D604();\n}\n"
    ],
    "sub_804D5F4": [
        "0x804d5f4",
        "char *sub_804D5F4(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_804D40A(a1, va, 0);\n}\n"
    ],
    "sub_804D604": [
        "0x804d604",
        "void __noreturn sub_804D604()\n{\n  if ( dword_80DBB84 )\n    dword_80DBB84();\n  exit((unsigned __int8)byte_80DB560);\n}\n"
    ],
    "sub_804D61C": [
        "0x804d61c",
        "int sub_804D61C()\n{\n  int v0; // ebx\n\n  v0 = fcntl64();\n  if ( (v0 & 0x800) == 0 )\n    fcntl64();\n  return v0;\n}\n"
    ],
    "sub_804D646": [
        "0x804d646",
        "int sub_804D646()\n{\n  int v0; // ebx\n\n  v0 = fcntl64();\n  if ( (v0 & 0x800) != 0 )\n    fcntl64();\n  return v0;\n}\n"
    ],
    "sub_804D670": [
        "0x804d670",
        "int sub_804D670()\n{\n  return fcntl64();\n}\n"
    ],
    "sub_804D67E": [
        "0x804d67e",
        "char *__usercall sub_804D67E@<eax>(char *a1@<eax>, const char *a2@<edx>)\n{\n  return strncpy(a1, a2, 0x10u);\n}\n"
    ],
    "sub_804D68B": [
        "0x804d68b",
        "_BYTE *__usercall sub_804D68B@<eax>(unsigned int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  int v4; // ebp\n  int v5; // edi\n  unsigned int v6; // ebx\n  int v7; // eax\n\n  if ( a3 )\n  {\n    v4 = 10;\n    v5 = 0;\n    v6 = 1000000000;\n    do\n    {\n      v7 = a1 / v6;\n      a1 %= v6;\n      if ( v5 | v7 || v6 == 1 )\n      {\n        if ( !--a3 )\n          return a2;\n        ++v5;\n        *a2++ = v7 + 48;\n      }\n      else\n      {\n        v5 = 0;\n      }\n      v6 /= 0xAu;\n      --v4;\n    }\n    while ( v4 );\n  }\n  return a2;\n}\n"
    ],
    "sub_804D6E0": [
        "0x804d6e0",
        "_BYTE *__usercall sub_804D6E0@<eax>(signed int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  if ( !a3 )\n    return a2;\n  if ( a1 < 0 )\n  {\n    a1 = -a1;\n    *a2 = 45;\n    --a3;\n    ++a2;\n  }\n  return sub_804D68B(a1, a2, a3);\n}\n"
    ],
    "sub_804D6F7": [
        "0x804d6f7",
        "_BYTE *__usercall sub_804D6F7@<eax>(unsigned int a1@<eax>)\n{\n  *sub_804D68B(a1, byte_80DB650, 11) = 0;\n  return byte_80DB650;\n}\n"
    ],
    "sub_804D70F": [
        "0x804d70f",
        "_BYTE *__usercall sub_804D70F@<eax>(signed int a1@<eax>)\n{\n  *sub_804D6E0(a1, byte_80DB650, 11) = 0;\n  return byte_80DB650;\n}\n"
    ],
    "sub_804D727": [
        "0x804d727",
        "int __usercall sub_804D727@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int i; // ebx\n  unsigned __int8 v5; // dl\n\n  for ( i = 0; i != a3; ++i )\n  {\n    v5 = *(_BYTE *)(a2 + i);\n    *(_BYTE *)(a1 + 2 * i) = byte_80C7B1E[v5 >> 4] | 0x20;\n    *(_BYTE *)(a1 + 2 * i + 1) = byte_80C7B1E[v5 & 0xF] | 0x20;\n  }\n  return 2 * i + a1;\n}\n"
    ],
    "sub_804D76F": [
        "0x804d76f",
        "_BYTE *__usercall sub_804D76F@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // esi\n  int v4; // ecx\n  int v5; // esi\n  int v6; // edi\n  int v7; // edx\n  _BYTE *v8; // [esp+0h] [ebp-18h]\n  _BYTE *v9; // [esp+4h] [ebp-14h]\n\n  *(_DWORD *)dword_80DBB7C = 22;\n  v9 = &result[a3];\n  while ( 1 )\n  {\n    LOBYTE(a3) = *a2;\n    if ( !*a2 )\n    {\n      v7 = 0;\n      goto LABEL_21;\n    }\n    if ( result == v9 )\n    {\n      v7 = 34;\nLABEL_21:\n      *(_DWORD *)dword_80DBB7C = v7;\n      return result;\n    }\n    v8 = a2 + 1;\n    v3 = a3 - 48;\n    if ( (unsigned __int8)(a3 - 48) > 9u )\n    {\n      v4 = a3 | 0x20;\n      if ( (unsigned __int8)(v4 - 97) > 5u )\n        return 0;\n      v3 = v4 - 87;\n    }\n    a3 = 16 * v3;\n    v5 = (unsigned __int8)a2[1];\n    v6 = v5 - 48;\n    if ( (unsigned __int8)(v5 - 48) <= 9u )\n      goto LABEL_10;\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\nLABEL_10:\n      a3 |= v6;\n      goto LABEL_14;\n    }\n    if ( (_BYTE)v5 && (_BYTE)v5 != 58 )\n      return 0;\n    LOBYTE(a3) = (unsigned __int8)a3 >> 4;\nLABEL_14:\n    *result++ = a3;\n    if ( (_BYTE)v5 )\n      v8 = a2 + 2;\n    if ( *v8 == 58 )\n      ++v8;\n    a2 = v8;\n  }\n}\n"
    ],
    "sub_804D830": [
        "0x804d830",
        "ssize_t __usercall sub_804D830@<eax>(char a1@<al>, int a2@<edx>)\n{\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  v3 = a2;\n  LOBYTE(v3) = a1;\n  return write(2, &v3, 1u);\n}\n"
    ],
    "sub_804D846": [
        "0x804d846",
        "int __usercall sub_804D846@<eax>(const char *a1@<eax>)\n{\n  size_t v2; // eax\n\n  v2 = strlen(a1);\n  return sub_804E586(v2, a1);\n}\n"
    ],
    "sub_804D85F": [
        "0x804d85f",
        "int __usercall sub_804D85F@<eax>(const char *a1@<eax>)\n{\n  size_t v2; // eax\n\n  v2 = strlen(a1);\n  return sub_804E586(v2, a1);\n}\n"
    ],
    "sub_804D878": [
        "0x804d878",
        "_BOOL4 __usercall sub_804D878@<eax>(int a1@<eax>, int *a2@<edx>, int *a3@<ecx>)\n{\n  int v3; // esi\n  int v6; // ebx\n  int v7; // eax\n  _BOOL4 v8; // ebx\n  char *v9; // eax\n  int v10; // edx\n  int v11; // ebp\n  char *v12; // eax\n  int v14; // [esp+0h] [ebp-1Ch]\n  int v15; // [esp+4h] [ebp-18h] BYREF\n\n  v3 = a1;\n  if ( a1 == -1 )\n  {\n    v6 = 1;\n    if ( !isatty(1) )\n    {\n      v6 = isatty(2);\n      if ( v6 )\n      {\n        v6 = 2;\n      }\n      else if ( !isatty(0) )\n      {\n        v6 = open64();\n        v3 = v6;\n      }\n    }\n  }\n  else\n  {\n    v6 = a1;\n    v3 = -1;\n  }\n  v15 = 0;\n  v7 = ioctl(v6, 0x5413u, &v15);\n  v8 = 1;\n  if ( !v7 )\n    v8 = (_WORD)v15 == 0;\n  if ( a3 )\n  {\n    v14 = (unsigned __int16)v15;\n    v9 = getenv(\"LINES\");\n    v10 = v14;\n    if ( v9 )\n    {\n      v10 = atoi(v9);\n      v8 = 0;\n    }\n    if ( (unsigned int)(v10 - 2) > 0x752D )\n      v10 = 24;\n    *a3 = v10;\n  }\n  if ( a2 )\n  {\n    v11 = HIWORD(v15);\n    v12 = getenv(\"COLUMNS\");\n    if ( v12 )\n    {\n      v11 = atoi(v12);\n      v8 = 0;\n    }\n    if ( (unsigned int)(v11 - 2) > 0x752D )\n      v11 = 80;\n    *a2 = v11;\n  }\n  if ( v3 >= 0 )\n    close(v3);\n  return v8;\n}\n"
    ],
    "sub_804D986": [
        "0x804d986",
        "int __usercall sub_804D986@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  v3 = a2;\n  sub_804D878(a1, &v3, 0);\n  return v3;\n}\n"
    ],
    "sub_804D995": [
        "0x804d995",
        "int __usercall sub_804D995@<eax>(const struct termios *a1@<eax>)\n{\n  return tcsetattr(0, 0, a1);\n}\n"
    ],
    "sub_804D9A3": [
        "0x804d9a3",
        "int __userpurge sub_804D9A3@<eax>(struct termios *termios_p@<ecx>, int a2@<eax>, struct termios *a3@<edx>, char a4)\n{\n  int result; // eax\n  tcflag_t c_lflag; // edx\n\n  memset(termios_p, 0, sizeof(struct termios));\n  result = tcgetattr(a2, termios_p);\n  qmemcpy(a3, termios_p, sizeof(struct termios));\n  c_lflag = a3->c_lflag;\n  a3->c_lflag = c_lflag & 0xFFFFFFB5;\n  if ( (a4 & 1) != 0 )\n    a3->c_lflag = c_lflag & 0xFFFFFFB4;\n  *(_WORD *)&a3->c_cc[5] = 256;\n  if ( (a4 & 2) != 0 )\n    a3->c_iflag &= 0xFFFFFAFF;\n  if ( (a4 & 4) != 0 )\n    a3->c_oflag &= ~4u;\n  if ( (a4 & 8) != 0 )\n    a3->c_iflag &= 0xFFFFC0BD;\n  return result;\n}\n"
    ],
    "sub_804DA14": [
        "0x804da14",
        "int __usercall sub_804DA14@<eax>(char a1@<cl>, struct termios *termios_p@<edx>, int a3@<eax>)\n{\n  struct termios v5; // [esp+0h] [ebp-40h] BYREF\n\n  sub_804D9A3(termios_p, a3, &v5, a1);\n  return tcsetattr(a3, 0, &v5);\n}\n"
    ],
    "sub_804DA34": [
        "0x804da34",
        "__pid_t __usercall sub_804DA34@<eax>(int options@<ecx>, int *stat_loc@<edx>, __pid_t a3@<eax>)\n{\n  __pid_t result; // eax\n\n  do\n    result = waitpid(a3, stat_loc, options);\n  while ( result == -1 && *(_DWORD *)dword_80DBB7C == 4 );\n  return result;\n}\n"
    ],
    "sub_804DA5C": [
        "0x804da5c",
        "__pid_t __usercall sub_804DA5C@<eax>(int *a1@<eax>)\n{\n  return sub_804DA34(1, a1, -1);\n}\n"
    ],
    "sub_804DA6B": [
        "0x804da6b",
        "int __usercall sub_804DA6B@<eax>(__pid_t a1@<eax>, int a2@<ecx>)\n{\n  int result; // eax\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  if ( a1 <= 0 )\n    return -1;\n  v3 = a2;\n  if ( sub_804DA34(0, &v3, a1) == -1 )\n    return -1;\n  if ( (v3 & 0x7F) == 0 )\n    return BYTE1(v3);\n  result = 0;\n  if ( (unsigned int)(unsigned __int16)v3 - 1 <= 0xFE )\n    return (v3 & 0x7F) + 384;\n  return result;\n}\n"
    ],
    "sub_804DAAC": [
        "0x804daac",
        "int __usercall sub_804DAAC@<eax>(__pid_t a1@<eax>, int a2@<ecx>)\n{\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  v3 = a2;\n  if ( sub_804DA34(0, &v3, a1) < 0 )\n    sub_804D3C9((int)\"waitpid\");\n  return v3;\n}\n"
    ],
    "sub_804DAC9": [
        "0x804dac9",
        "void __noreturn sub_804DAC9()\n{\n  sub_804D5E0(\"out of memory\");\n}\n"
    ],
    "sub_804DAD3": [
        "0x804dad3",
        "void *__usercall sub_804DAD3@<eax>(size_t a1@<eax>)\n{\n  void *result; // eax\n\n  result = malloc(a1);\n  if ( a1 )\n  {\n    if ( !result )\n    {\n      sub_804D5F4(\"out of memory\");\n      return 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_804DAFA": [
        "0x804dafa",
        "void *__usercall sub_804DAFA@<eax>(size_t a1@<eax>)\n{\n  void *result; // eax\n\n  result = malloc(a1);\n  if ( !result )\n  {\n    if ( a1 )\n      sub_804DAC9();\n  }\n  return result;\n}\n"
    ],
    "sub_804DB13": [
        "0x804db13",
        "void *__usercall sub_804DB13@<eax>(void *a1@<eax>, size_t a2@<edx>)\n{\n  void *result; // eax\n  int v4; // [esp-8h] [ebp-Ch]\n  int v5; // [esp-4h] [ebp-8h]\n\n  result = realloc(a1, a2);\n  if ( !result )\n  {\n    if ( a2 )\n      sub_804DAC9(v5, v4);\n  }\n  return result;\n}\n"
    ],
    "sub_804DB2E": [
        "0x804db2e",
        "void *__usercall sub_804DB2E@<eax>(size_t a1@<eax>)\n{\n  void *v2; // edx\n\n  v2 = sub_804DAFA(a1);\n  memset(v2, 0, a1);\n  return v2;\n}\n"
    ],
    "sub_804DB46": [
        "0x804db46",
        "char *__usercall sub_804DB46@<eax>(const char *a1@<eax>)\n{\n  char *result; // eax\n  int v2; // ecx\n  int v3; // [esp-4h] [ebp-4h]\n\n  if ( !a1 )\n    return 0;\n  result = strdup(a1);\n  if ( !result )\n    sub_804DAC9(v2, v3);\n  return result;\n}\n"
    ],
    "sub_804DB5D": [
        "0x804db5d",
        "_BYTE *__usercall sub_804DB5D@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  _BYTE *v3; // ecx\n  int i; // eax\n  unsigned int v5; // ebx\n  _BYTE *result; // eax\n\n  v3 = a1;\n  for ( i = a2; i && *v3; --i )\n    ++v3;\n  v5 = a2 - i;\n  result = sub_804DAFA(a2 - i + 1);\n  result[v5] = 0;\n  qmemcpy(result, a1, v5);\n  return result;\n}\n"
    ],
    "sub_804DB8D": [
        "0x804db8d",
        "void *__usercall sub_804DB8D@<eax>(const void *a1@<eax>, size_t a2@<edx>)\n{\n  void *result; // eax\n\n  result = sub_804DAFA(a2);\n  qmemcpy(result, a1, a2);\n  return result;\n}\n"
    ],
    "sub_804DBA5": [
        "0x804dba5",
        "int __usercall sub_804DBA5@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = fopen64();\n  if ( !result )\n    sub_804D3C9((int)\"can't open '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804DBC2": [
        "0x804dbc2",
        "int __usercall sub_804DBC2@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = open64();\n  if ( result < 0 )\n    sub_804D3C9((int)\"can't open '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804DBE1": [
        "0x804dbe1",
        "int __usercall sub_804DBE1@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBC2(a1);\n}\n"
    ],
    "sub_804DBEB": [
        "0x804dbeb",
        "int __usercall sub_804DBEB@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n  int v3; // [esp+0h] [ebp-8h]\n\n  result = open64();\n  if ( result < 0 )\n  {\n    v3 = result;\n    sub_804D3A5((int)\"can't open '%s'\", a1);\n    return v3;\n  }\n  return result;\n}\n"
    ],
    "sub_804DC14": [
        "0x804dc14",
        "int __usercall sub_804DC14@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBEB(a1);\n}\n"
    ],
    "sub_804DC1E": [
        "0x804dc1e",
        "int __usercall sub_804DC1E@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBE1(a1);\n}\n"
    ],
    "sub_804DC28": [
        "0x804dc28",
        "int __usercall sub_804DC28@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = unlink(a1);\n  if ( result )\n    sub_804D3C9((int)\"can't remove file '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804DC43": [
        "0x804dc43",
        "int __usercall sub_804DC43@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n\n  result = rename(a1, a2);\n  if ( result )\n    sub_804D3C9((int)\"can't move '%s' to '%s'\", a1, a2);\n  return result;\n}\n"
    ],
    "sub_804DC65": [
        "0x804dc65",
        "int __usercall sub_804DC65@<eax>(int *a1@<eax>)\n{\n  int result; // eax\n\n  result = pipe(a1);\n  if ( result )\n    sub_804D3C9((int)\"can't create pipe\");\n  return result;\n}\n"
    ],
    "sub_804DC7B": [
        "0x804dc7b",
        "int __usercall sub_804DC7B@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = dup2(a1, a2);\n  if ( result != a2 )\n    sub_804D3C9((int)\"can't duplicate file descriptor\");\n  return result;\n}\n"
    ],
    "sub_804DC97": [
        "0x804dc97",
        "int __usercall sub_804DC97@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  int v3; // [esp-8h] [ebp-8h]\n\n  if ( result != a2 )\n  {\n    v2 = result;\n    sub_804DC7B(result, a2);\n    close(v2);\n    return v3;\n  }\n  return result;\n}\n"
    ],
    "sub_804DCAD": [
        "0x804dcad",
        "void __fastcall sub_804DCAD(int a1, int a2)\n{\n  int v3; // eax\n  const char *v4; // edx\n\n  if ( a1 )\n  {\n    v3 = sub_804E586(a1, a2);\n    if ( v3 != a1 )\n    {\n      v4 = \"short write\";\n      if ( v3 < 0 )\n        v4 = \"write error\";\n      sub_804D3C9((int)v4);\n    }\n  }\n}\n"
    ],
    "sub_804DCD4": [
        "0x804dcd4",
        "void __fastcall sub_804DCD4(int a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  sub_804DCAD(v2, (int)a2);\n}\n"
    ],
    "sub_804DCF3": [
        "0x804dcf3",
        "int __usercall sub_804DCF3@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = close(a1);\n  if ( result )\n    sub_804D3C9((int)\"close failed\");\n  return result;\n}\n"
    ],
    "sub_804DD09": [
        "0x804dd09",
        "int __fastcall sub_804DD09(unsigned int a1, unsigned int a2, int a3)\n{\n  int result; // eax\n  int v6; // edx\n\n  result = lseek64();\n  if ( v6 == -1 && result == -1 )\n  {\n    if ( !a3 )\n      sub_804D3C9((int)\"lseek(%llu)\", __PAIR64__(a1, a2));\n    sub_804D3C9((int)\"lseek\");\n  }\n  return result;\n}\n"
    ],
    "sub_804DD54": [
        "0x804dd54",
        "int __usercall sub_804DD54@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = mkstemp64();\n  if ( result < 0 )\n    sub_804D3C9((int)\"can't create temp file '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804DD6F": [
        "0x804dd6f",
        "_BYTE *__usercall sub_804DD6F@<eax>(_BYTE *result@<eax>, const char *a2@<edx>)\n{\n  if ( (*result & 8) != 0 )\n    sub_804D5E0(\"%s: I/O error\", a2);\n  return result;\n}\n"
    ],
    "sub_804DD80": [
        "0x804dd80",
        "_BYTE *sub_804DD80()\n{\n  return sub_804DD6F(stdout, \"standard output\");\n}\n"
    ],
    "sub_804DD8F": [
        "0x804dd8f",
        "int sub_804DD8F()\n{\n  return fflush(0);\n}\n"
    ],
    "sub_804DD98": [
        "0x804dd98",
        "int __usercall sub_804DD98@<eax>(int result@<eax>)\n{\n  _BYTE *v1; // ecx\n\n  v1 = *(_BYTE **)(_stdout + 16);\n  if ( (unsigned int)v1 >= *(_DWORD *)(_stdout + 28) )\n    return __fputc_unlocked();\n  *(_DWORD *)(_stdout + 16) = v1 + 1;\n  *v1 = result;\n  return (unsigned __int8)result;\n}\n"
    ],
    "sub_804DDBF": [
        "0x804ddbf",
        "char *sub_804DDBF(char *a1, ...)\n{\n  int v1; // edx\n  int v2; // ecx\n  char *v4; // [esp+0h] [ebp-4h] BYREF\n  va_list va; // [esp+Ch] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  if ( vasprintf(&v4, a1, va) < 0 )\n    sub_804DAC9(v2, v1);\n  return v4;\n}\n"
    ],
    "sub_804DDE4": [
        "0x804dde4",
        "int __usercall sub_804DDE4@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n  int v3; // edx\n  int v4; // ecx\n\n  result = setenv(a1, a2, 1);\n  if ( result )\n    sub_804DAC9(v4, v3);\n  return result;\n}\n"
    ],
    "sub_804DDFA": [
        "0x804ddfa",
        "void __usercall sub_804DDFA(const char *a1@<eax>)\n{\n  char *v1; // ebx\n  char *v2; // eax\n  char *v3; // esi\n  char v4; // [esp+0h] [ebp-78h] BYREF\n\n  v1 = (char *)a1;\n  v2 = strchr(a1, 61);\n  v3 = v2;\n  if ( v2 )\n  {\n    if ( (unsigned int)(v2 - v1) > 0x6F )\n    {\n      v1 = sub_804DB5D(v1, v2 - v1);\n      v3 = v1;\n    }\n    else\n    {\n      v1 = &v4;\n      *(_BYTE *)mempcpy() = 0;\n      v3 = 0;\n    }\n  }\n  unsetenv(v1);\n  free(v3);\n}\n"
    ],
    "sub_804DE4D": [
        "0x804de4d",
        "int __usercall sub_804DE4D@<eax>(char *a1@<eax>)\n{\n  int v3; // [esp-4h] [ebp-8h]\n\n  sub_804DDFA(a1);\n  free(a1);\n  return v3;\n}\n"
    ],
    "sub_804DE5E": [
        "0x804de5e",
        "int __usercall sub_804DE5E@<eax>(__gid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = setgid(a1);\n  if ( result )\n    sub_804D3C9((int)\"setgid\");\n  return result;\n}\n"
    ],
    "sub_804DE74": [
        "0x804de74",
        "int __usercall sub_804DE74@<eax>(__uid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = setuid(a1);\n  if ( result )\n    sub_804D3C9((int)\"setuid\");\n  return result;\n}\n"
    ],
    "sub_804DE8A": [
        "0x804de8a",
        "int __usercall sub_804DE8A@<eax>(__gid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = setegid(a1);\n  if ( result )\n    sub_804D3C9((int)\"setegid\");\n  return result;\n}\n"
    ],
    "sub_804DEA0": [
        "0x804dea0",
        "int __usercall sub_804DEA0@<eax>(__uid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = seteuid(a1);\n  if ( result )\n    sub_804D3C9((int)\"seteuid\");\n  return result;\n}\n"
    ],
    "sub_804DEB6": [
        "0x804deb6",
        "int __userpurge sub_804DEB6@<eax>(const char *a1@<eax>, __uid_t a2@<ecx>, __gid_t a3)\n{\n  __uid_t v5; // edi\n  __gid_t v6; // esi\n  int v7; // ebx\n\n  v5 = geteuid();\n  v6 = getegid();\n  sub_804DE8A(a3);\n  sub_804DEA0(a2);\n  v7 = sub_804DBE1(a1);\n  sub_804DEA0(v5);\n  sub_804DE8A(v6);\n  return v7;\n}\n"
    ],
    "sub_804DF04": [
        "0x804df04",
        "int __usercall sub_804DF04@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = chdir(a1);\n  if ( result )\n    sub_804D3C9((int)\"can't change directory to '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804DF1F": [
        "0x804df1f",
        "int __usercall sub_804DF1F@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = fchdir(a1);\n  if ( result )\n    sub_804D3C9((int)\"fchdir\");\n  return result;\n}\n"
    ],
    "sub_804DF35": [
        "0x804df35",
        "int __usercall sub_804DF35@<eax>(const char *a1@<eax>)\n{\n  if ( chroot(a1) )\n    sub_804D3C9((int)\"can't change root directory to '%s'\", a1);\n  return sub_804DF04(\"/\");\n}\n"
    ],
    "sub_804DF59": [
        "0x804df59",
        "DIR *__usercall sub_804DF59@<eax>(const char *a1@<eax>)\n{\n  DIR *result; // eax\n\n  result = opendir(a1);\n  if ( !result )\n  {\n    sub_804D3A5((int)\"can't open '%s'\", a1);\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_804DF7E": [
        "0x804df7e",
        "DIR *__usercall sub_804DF7E@<eax>(const char *a1@<eax>)\n{\n  DIR *result; // eax\n\n  result = opendir(a1);\n  if ( !result )\n    sub_804D3C9((int)\"can't open '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804DF99": [
        "0x804df99",
        "int __usercall sub_804DF99@<eax>(int protocol@<ecx>, int type@<edx>, int a3@<eax>)\n{\n  int result; // eax\n\n  result = socket(a3, type, protocol);\n  if ( result < 0 )\n    sub_804D3C9((int)\"socket\");\n  return result;\n}\n"
    ],
    "sub_804DFB3": [
        "0x804dfb3",
        "int __usercall sub_804DFB3@<eax>(socklen_t len@<ecx>, struct sockaddr *addr@<edx>, int a3@<eax>)\n{\n  int result; // eax\n\n  result = bind(a3, addr, len);\n  if ( result )\n    sub_804D3C9((int)\"bind\");\n  return result;\n}\n"
    ],
    "sub_804DFCD": [
        "0x804dfcd",
        "ssize_t __userpurge sub_804DFCD@<eax>(\n        size_t n@<ecx>,\n        void *buf@<edx>,\n        int a3@<eax>,\n        struct sockaddr *addr,\n        socklen_t addr_len)\n{\n  ssize_t result; // eax\n\n  result = sendto(a3, buf, n, 0, addr, addr_len);\n  if ( result < 0 )\n    sub_804D3C9((int)\"sendto\");\n  return result;\n}\n"
    ],
    "sub_804DFF3": [
        "0x804dff3",
        "int __usercall sub_804DFF3@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = stat64();\n  if ( result )\n    sub_804D3C9((int)\"can't stat '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804E010": [
        "0x804e010",
        "int __fastcall sub_804E010(const char *a1)\n{\n  int result; // eax\n\n  result = fstat64();\n  if ( result )\n    sub_804D3FF(a1);\n  return result;\n}\n"
    ],
    "sub_804E029": [
        "0x804e029",
        "int sub_804E029(int fd, unsigned int request, int a3, char *a4, ...)\n{\n  int result; // eax\n  char *v5; // eax\n  va_list va; // [esp+14h] [ebp+14h] BYREF\n\n  va_start(va, a4);\n  result = ioctl(fd, request, a3);\n  if ( result < 0 )\n  {\n    v5 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D40A(a4, va, v5);\n    sub_804D604();\n  }\n  return result;\n}\n"
    ],
    "sub_804E062": [
        "0x804e062",
        "int sub_804E062(int fd, unsigned int request, int a3, char *a4, ...)\n{\n  int v4; // ebx\n  char *v5; // eax\n  va_list va; // [esp+18h] [ebp+14h] BYREF\n\n  va_start(va, a4);\n  v4 = ioctl(fd, request, a3);\n  if ( v4 < 0 )\n  {\n    v5 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D40A(a4, va, v5);\n  }\n  return v4;\n}\n"
    ],
    "sub_804E09D": [
        "0x804e09d",
        "int __userpurge sub_804E09D@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  int v4; // ebx\n\n  v4 = ioctl(a1, a2, a3);\n  if ( v4 < 0 )\n    sub_804D3F1(a4);\n  return v4;\n}\n"
    ],
    "sub_804E0BE": [
        "0x804e0be",
        "int __userpurge sub_804E0BE@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  int result; // eax\n\n  result = ioctl(a1, a2, a3);\n  if ( result < 0 )\n    sub_804D3FF(a4);\n  return result;\n}\n"
    ],
    "sub_804E0D9": [
        "0x804e0d9",
        "char *__usercall sub_804E0D9@<eax>(int a1@<eax>)\n{\n  char buf[132]; // [esp+0h] [ebp-84h] BYREF\n\n  if ( ttyname_r(a1, buf, 0x7Fu) )\n    return 0;\n  else\n    return sub_804DB46(buf);\n}\n"
    ],
    "sub_804E101": [
        "0x804e101",
        "unsigned int __usercall sub_804E101@<eax>(_BYTE *a1@<eax>)\n{\n  int v2; // eax\n  const char *v3; // edx\n  int v4; // ecx\n  int v5; // esi\n  unsigned int v6; // eax\n  unsigned int i; // edi\n  int j; // esi\n  unsigned int result; // eax\n\n  v2 = open64();\n  v3 = \"/dev/urandom\";\n  v4 = 0;\n  if ( v2 >= 0 )\n  {\n    v5 = v2;\n    read(v2, a1, 0x10u);\n    close(v5);\n  }\n  v6 = sub_804EBDE(v4, v3);\n  srand(v6);\n  for ( i = getpid(); ; i = 0 )\n  {\n    for ( j = 0; j != 16; ++j )\n      a1[j] ^= rand() >> 5;\n    if ( !i )\n      break;\n    srand(i);\n  }\n  a1[6] = a1[6] & 0xF | 0x40;\n  result = a1[8] & 0x3F | 0xFFFFFF80;\n  a1[8] = result;\n  return result;\n}\n"
    ],
    "sub_804E17C": [
        "0x804e17c",
        "__pid_t sub_804E17C()\n{\n  __pid_t result; // eax\n\n  result = fork();\n  if ( result < 0 )\n    sub_804D3C9((int)\"fork\");\n  return result;\n}\n"
    ],
    "sub_804E190": [
        "0x804e190",
        "void *__usercall sub_804E190@<eax>(const char *a1@<eax>)\n{\n  signed int v2; // esi\n  void *v3; // ebx\n  ssize_t v4; // eax\n\n  v2 = 0;\n  v3 = 0;\n  do\n  {\n    v2 += 80;\n    v3 = sub_804DB13(v3, v2);\n    v4 = readlink(a1, (char *)v3, v2);\n    if ( v4 == -1 )\n    {\n      free(v3);\n      return 0;\n    }\n  }\n  while ( v2 <= v4 );\n  *((_BYTE *)v3 + v4) = 0;\n  return v3;\n}\n"
    ],
    "sub_804E1D0": [
        "0x804e1d0",
        "char *__usercall sub_804E1D0@<eax>(const char *a1@<eax>)\n{\n  char *v1; // ebx\n  int v2; // ebp\n  size_t v3; // edi\n  char *v4; // eax\n  char *v5; // esi\n  int v6; // ecx\n  char *v7; // eax\n\n  v1 = sub_804DB46(a1);\n  v2 = 21;\nLABEL_2:\n  v3 = strlen(v1) + 1;\n  while ( 1 )\n  {\n    v4 = (char *)sub_804E190(v1);\n    v5 = v4;\n    if ( !v4 )\n      break;\n    if ( !--v2 )\n    {\n      free(v4);\nLABEL_9:\n      free(v1);\n      return 0;\n    }\n    if ( *v4 == 47 )\n    {\n      free(v1);\n      v1 = v5;\n      goto LABEL_2;\n    }\n    v3 += strlen(v4);\n    v1 = (char *)sub_804DB13(v1, v3);\n    v7 = sub_804D34F(v1, v6);\n    strcpy(v7, v5);\n    free(v5);\n  }\n  if ( *(_DWORD *)dword_80DBB7C != 2 && *(_DWORD *)dword_80DBB7C != 22 )\n    goto LABEL_9;\n  return v1;\n}\n"
    ],
    "sub_804E261": [
        "0x804e261",
        "void *__usercall sub_804E261@<eax>(const char *a1@<eax>)\n{\n  void *v2; // ebx\n  char *v3; // eax\n\n  v2 = sub_804E190(a1);\n  if ( !v2 )\n  {\n    v3 = \"not a symlink\";\n    if ( *(_DWORD *)dword_80DBB7C != 22 )\n      v3 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D5F4(\"%s: cannot read link: %s\", a1, v3);\n  }\n  return v2;\n}\n"
    ],
    "sub_804E29C": [
        "0x804e29c",
        "char *__usercall sub_804E29C@<eax>(const char *a1@<eax>)\n{\n  return realpath(a1, 0);\n}\n"
    ],
    "sub_804E2A7": [
        "0x804e2a7",
        "_BYTE *__usercall sub_804E2A7@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v2; // edi\n  _BYTE *v3; // ebx\n  char *v4; // eax\n  const char *v5; // ebp\n  char *v6; // eax\n  char *v7; // edi\n  size_t v8; // esi\n  size_t v9; // eax\n\n  v2 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v3 = sub_804E29C(a1);\n  if ( !v3 && *v2 == 2 )\n  {\n    v4 = strrchr(a1, 47);\n    if ( v4 )\n    {\n      v5 = v4 + 1;\n      *v4 = 0;\n      v6 = sub_804E29C(a1);\n      v7 = v6;\n      if ( v6 )\n      {\n        v8 = strlen(v6);\n        v9 = strlen(v5);\n        v3 = sub_804DB13(v7, v9 + v8 + 2);\n        v3[v8] = 47;\n        strcpy(&v3[v8 + 1], v5);\n      }\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_804E320": [
        "0x804e320",
        "__int64 __usercall sub_804E320@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  unsigned __int64 v3; // rdi\n  int v4; // ecx\n  size_t v5; // ecx\n  int v6; // eax\n  int v7; // ebx\n  int v8; // eax\n  int v10; // [esp+0h] [ebp-1028h]\n  char v11; // [esp+7h] [ebp-1021h]\n  int v12; // [esp+8h] [ebp-1020h]\n  __int64 v14; // [esp+14h] [ebp-1014h]\n  char buf[4108]; // [esp+1Ch] [ebp-100Ch] BYREF\n\n  v3 = __PAIR64__(a3, HIDWORD(a3));\n  if ( a3 < 0 )\n  {\n    HIDWORD(v3) = -(int)a3;\n    LODWORD(v3) = (unsigned __int64)-a3 >> 32;\n    v14 = -1LL;\n    if ( a1 < 0 )\n      return v14;\n    v11 = 1;\n    goto LABEL_7;\n  }\n  v14 = -1LL;\n  if ( a1 < 0 )\n    return v14;\n  v11 = 0;\n  if ( a3 )\n  {\nLABEL_7:\n    v12 = -1;\n    goto LABEL_8;\n  }\n  v12 = 1;\n  v3 = 0x100000000000000LL;\nLABEL_8:\n  v4 = 0x1000000;\n  v14 = 0LL;\n  while ( 1 )\n  {\n    if ( v4 )\n    {\n      v10 = v4;\n      v8 = sendfile64();\n      v7 = v8;\n      v4 = v10;\n      if ( v8 >= 0 )\n      {\n        if ( !v8 )\n          return v14;\n        goto LABEL_26;\n      }\n    }\n    v5 = HIDWORD(v3);\n    if ( (v3 & 0x80000000) == 0LL && ((int)v3 > 0 || HIDWORD(v3) > 0x1000) )\n      v5 = 4096;\n    v6 = sub_804E5BC(v5, buf);\n    v7 = v6;\n    if ( v6 < 0 )\n    {\n      sub_804D3A5((int)\"read error\");\n      return -1LL;\n    }\n    if ( !v6 )\n      return v14;\n    if ( a2 < 0 || v6 <= sub_804E586(v6, buf) )\n    {\n      v4 = 0;\n      goto LABEL_26;\n    }\n    if ( !v11 )\n      break;\n    v4 = 0;\n    a2 = -1;\nLABEL_26:\n    v14 += v7;\n    if ( v12 == -1 )\n    {\n      LODWORD(v3) = (__PAIR64__(v3, HIDWORD(v3)) - v7) >> 32;\n      HIDWORD(v3) -= v7;\n      if ( !v3 )\n        return v14;\n    }\n  }\n  sub_804D3A5((int)\"write error\");\n  return -1LL;\n}\n"
    ],
    "sub_804E4ED": [
        "0x804e4ed",
        "__int64 __userpurge sub_804E4ED@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  __int64 result; // rax\n\n  result = a3;\n  if ( a3 )\n    return sub_804E320(a1, a2, a3);\n  return result;\n}\n"
    ],
    "sub_804E51A": [
        "0x804e51a",
        "__int64 __userpurge sub_804E51A@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  __int64 result; // rax\n\n  result = sub_804E4ED(a1, a2, a3);\n  if ( abs64(a3) != result )\n  {\n    if ( result == -1 )\n      sub_804D604();\n    sub_804D5E0(\"short read\");\n  }\n  return result;\n}\n"
    ],
    "sub_804E572": [
        "0x804e572",
        "__int64 __usercall sub_804E572@<edx:eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_804E320(a1, a2, 0LL);\n}\n"
    ],
    "sub_804E586": [
        "0x804e586",
        "int __fastcall sub_804E586(size_t a1, char *a2)\n{\n  int v4; // ebx\n  int v5; // eax\n\n  v4 = 0;\n  while ( a1 )\n  {\n    v5 = sub_804E65D(a1, a2);\n    if ( v5 < 0 )\n    {\n      if ( !v4 )\n        return v5;\n      return v4;\n    }\n    v4 += v5;\n    a2 += v5;\n    a1 -= v5;\n  }\n  return v4;\n}\n"
    ],
    "sub_804E5BC": [
        "0x804e5bc",
        "ssize_t __usercall sub_804E5BC@<eax>(size_t nbytes@<ecx>, void *buf@<edx>, int a3@<eax>)\n{\n  ssize_t result; // eax\n\n  do\n    result = read(a3, buf, nbytes);\n  while ( result < 0 && *(_DWORD *)dword_80DBB7C == 4 );\n  return result;\n}\n"
    ],
    "sub_804E5E3": [
        "0x804e5e3",
        "ssize_t __usercall sub_804E5E3@<eax>(int a1@<eax>, char *a2@<edx>, size_t a3@<ecx>)\n{\n  int v6; // ebx\n  ssize_t v7; // eax\n\n  v6 = 0;\n  while ( a3 )\n  {\n    v7 = sub_804E5BC(a3, a2, a1);\n    if ( v7 < 0 )\n    {\n      if ( !v6 )\n        return v7;\n      return v6;\n    }\n    if ( !v7 )\n      return v6;\n    a2 += v7;\n    v6 += v7;\n    a3 -= v7;\n  }\n  return v6;\n}\n"
    ],
    "sub_804E632": [
        "0x804e632",
        "int __fastcall sub_804E632(size_t a1, char *a2)\n{\n  int v2; // ebx\n  ssize_t v3; // esi\n  int result; // eax\n\n  result = open64();\n  if ( result >= 0 )\n  {\n    v2 = result;\n    v3 = sub_804E5E3(result, a2, a1);\n    close(v2);\n    return v3;\n  }\n  return result;\n}\n"
    ],
    "sub_804E65D": [
        "0x804e65d",
        "ssize_t __usercall sub_804E65D@<eax>(size_t n@<ecx>, void *buf@<edx>, int a3@<eax>)\n{\n  ssize_t result; // eax\n\n  while ( 1 )\n  {\n    result = write(a3, buf, n);\n    if ( result >= 0 || *(_DWORD *)dword_80DBB7C != 4 )\n      break;\n    *(_DWORD *)dword_80DBB7C = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_804E68E": [
        "0x804e68e",
        "void __cdecl sub_804E68E(char a1)\n{\n  byte_80DBBA4 = a1;\n}\n"
    ],
    "sub_804E698": [
        "0x804e698",
        "int __usercall sub_804E698@<eax>(int a1@<eax>, const struct sigaction *a2@<edx>)\n{\n  return sigaction(a1, a2, 0);\n}\n"
    ],
    "sub_804E6A5": [
        "0x804e6a5",
        "int __usercall sub_804E6A5@<eax>(int a1@<eax>)\n{\n  int v2[2]; // [esp+0h] [ebp-8h] BYREF\n\n  v2[0] = -1;\n  v2[1] = -1;\n  return sigprocmask(a1, (const sigset_t *)v2, 0);\n}\n"
    ],
    "sub_804E6C8": [
        "0x804e6c8",
        "int __usercall sub_804E6C8@<eax>(int result@<eax>, void (*a2)(int)@<edx>)\n{\n  int v2; // esi\n  int v4; // ebx\n  int v5; // edi\n  int v6; // [esp-8h] [ebp-18h]\n\n  v2 = result;\n  v4 = 1;\n  v5 = 0;\n  while ( v2 )\n  {\n    if ( (v4 & v2) != 0 )\n    {\n      v2 -= v4;\n      signal(v5, a2);\n      result = v6;\n    }\n    ++v5;\n    v4 *= 2;\n  }\n  return result;\n}\n"
    ],
    "sub_804E6F4": [
        "0x804e6f4",
        "int __usercall sub_804E6F4@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  int v4; // ebx\n  int v5; // edi\n  int v6[8]; // [esp+0h] [ebp-20h] BYREF\n\n  result = 0;\n  memset(&v6[1], 0, 0x10u);\n  v6[0] = a2;\n  v4 = 1;\n  v5 = 0;\n  while ( a1 )\n  {\n    if ( (v4 & a1) != 0 )\n    {\n      a1 -= v4;\n      result = sub_804E698(v5, (const struct sigaction *)v6);\n    }\n    ++v5;\n    v4 *= 2;\n  }\n  return result;\n}\n"
    ],
    "sub_804E734": [
        "0x804e734",
        "int __usercall sub_804E734@<eax>(int a1@<eax>)\n{\n  int v2[3]; // [esp+0h] [ebp-Ch] BYREF\n\n  v2[0] = 0;\n  v2[1] = 0;\n  sigaddset((sigset_t *)v2, a1);\n  return sigprocmask(1, (const sigset_t *)v2, 0);\n}\n"
    ],
    "sub_804E761": [
        "0x804e761",
        "void __usercall __noreturn sub_804E761(int a1@<eax>)\n{\n  int v1; // ebx\n\n  v1 = a1;\n  signal(a1, 0);\n  sub_804E734(v1);\n  raise(v1);\n  LOBYTE(v1) = v1 | 0x80;\n  _exit(v1);\n}\n"
    ],
    "sub_804E782": [
        "0x804e782",
        "int __usercall sub_804E782@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3[8]; // [esp+0h] [ebp-20h] BYREF\n\n  memset(&v3[2], 0, 0xCu);\n  v3[1] = 0x10000000;\n  v3[0] = a2;\n  return sub_804E698(a1, (const struct sigaction *)v3);\n}\n"
    ],
    "sub_804E7B4": [
        "0x804e7b4",
        "int __usercall sub_804E7B4@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3[8]; // [esp+0h] [ebp-20h] BYREF\n\n  memset(&v3[1], 0, 0x10u);\n  v3[0] = a2;\n  return sub_804E698(a1, (const struct sigaction *)v3);\n}\n"
    ],
    "sub_804E7DE": [
        "0x804e7de",
        "int __usercall sub_804E7DE@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = syscall(265, 1, a1);\n  if ( result )\n    sub_804D5E0(\"clock_gettime(MONOTONIC) failed\");\n  return result;\n}\n"
    ],
    "sub_804E7FD": [
        "0x804e7fd",
        "int __usercall sub_804E7FD@<eax>(const char *a1@<eax>, struct tm *a2@<edx>)\n{\n  int v4; // eax\n  int result; // eax\n  bool v6; // zf\n  int v7; // eax\n  struct tm *v8; // esi\n  int v9; // eax\n  int v10; // eax\n  bool v11; // of\n  char v12; // cc\n  unsigned int v13; // eax\n  unsigned int v14; // edx\n  char *v15; // eax\n  int v16; // [esp-4h] [ebp-30h]\n  int *p_tm_hour; // [esp+0h] [ebp-2Ch]\n  int tm_year; // [esp+0h] [ebp-2Ch]\n  int *p_tm_mon; // [esp+4h] [ebp-28h]\n  char *v20; // [esp+8h] [ebp-24h]\n  char v21; // [esp+17h] [ebp-15h] BYREF\n  time_t timer; // [esp+18h] [ebp-14h] BYREF\n\n  v21 = 0;\n  v20 = strrchr(a1, 58);\n  if ( !v20 )\n  {\n    if ( strchr(a1, 45) )\n    {\n      result = sscanf(a1, \"%u-%u-%u %u%c\", &a2->tm_year, &a2->tm_mon, &a2->tm_mday, &a2->tm_hour, &v21);\n      if ( result > 3 || (result = sscanf(a1, \"%u-%u-%u%c\", &a2->tm_year, &a2->tm_mon, &a2->tm_mday, &v21), result > 2) )\n      {\n        a2->tm_year -= 1900;\n        --a2->tm_mon;\n        goto LABEL_50;\n      }\n    }\n    if ( *a1 == 64 )\n    {\n      timer = sub_804EDC5(10);\n      result = dword_80DBB7C;\n      if ( !*(_DWORD *)dword_80DBB7C )\n      {\n        v8 = localtime(&timer);\n        result = v16;\n        if ( v8 )\n        {\n          qmemcpy(a2, v8, sizeof(struct tm));\n          return result;\n        }\n      }\n      v21 = 49;\n      goto LABEL_50;\n    }\n    tm_year = a2->tm_year;\n    v9 = strchrnul() - (_DWORD)a1;\n    if ( v9 == 2 )\n    {\n      result = sscanf(a1, \"%2u%c\", &a2->tm_min, &v21);\n      if ( result <= 0 )\n        goto LABEL_11;\nLABEL_48:\n      a2->tm_sec = 0;\n      if ( v21 == 46 )\n      {\n        v15 = strchr(a1, 46);\n        v7 = sscanf(v15 + 1, \"%u%c\", a2, &v21);\nLABEL_14:\n        result = v7 - 1;\n        if ( !result )\n          v21 = 0;\n      }\nLABEL_50:\n      v6 = v21 == 0;\n      goto LABEL_10;\n    }\n    if ( v9 == 4 )\n    {\n      v10 = sscanf(a1, \"%2u%2u%c\", &a2->tm_hour, &a2->tm_min, &v21);\n      v11 = __OFSUB__(v10, 1);\n      result = v10 - 1;\n      v12 = (result < 0) ^ v11 | (result == 0);\n    }\n    else\n    {\n      if ( v9 != 6 )\n      {\n        if ( v9 == 8 )\n        {\n          result = sscanf(a1, \"%2u%2u%2u%2u%c\", &a2->tm_mon, &a2->tm_mday, &a2->tm_hour, &a2->tm_min, &v21);\n          if ( result <= 3 )\n            goto LABEL_11;\n        }\n        else\n        {\n          if ( v9 == 10 )\n          {\n            result = sscanf(\n                       a1,\n                       \"%2u%2u%2u%2u%2u%c\",\n                       &a2->tm_year,\n                       &a2->tm_mon,\n                       &a2->tm_mday,\n                       &a2->tm_hour,\n                       &a2->tm_min,\n                       &v21);\n            if ( result <= 4 )\n              goto LABEL_11;\n            --a2->tm_mon;\n            if ( tm_year > 49 )\n            {\n              v13 = a2->tm_year + 100 * (tm_year / 0x64u);\n              a2->tm_year = v13;\n              if ( v13 < tm_year - 50 )\n                a2->tm_year = v13 + 100;\n              v14 = a2->tm_year;\n              result = tm_year + 50;\n              if ( v14 > tm_year + 50 )\n                a2->tm_year = v14 - 100;\n            }\n            goto LABEL_48;\n          }\n          if ( v9 != 12\n            || (result = sscanf(\n                           a1,\n                           \"%4u%2u%2u%2u%2u%c\",\n                           &a2->tm_year,\n                           &a2->tm_mon,\n                           &a2->tm_mday,\n                           &a2->tm_hour,\n                           &a2->tm_min,\n                           &v21),\n                result <= 4) )\n          {\nLABEL_11:\n            sub_804D5E0(\"invalid date '%s'\", a1);\n          }\n          a2->tm_year -= 1900;\n        }\n        --a2->tm_mon;\n        goto LABEL_48;\n      }\n      result = sscanf(a1, \"%2u%2u%2u%c\", &a2->tm_mday, &a2->tm_hour, &a2->tm_min, &v21);\n      v12 = result <= 2;\n    }\n    if ( !v12 )\n      goto LABEL_48;\n    goto LABEL_11;\n  }\n  p_tm_hour = &a2->tm_hour;\n  v4 = sscanf(a1, \"%u:%u%c\", &a2->tm_hour, &a2->tm_min, &v21);\n  v12 = v4 <= 1;\n  result = v4 - 1;\n  if ( !v12 )\n    goto LABEL_12;\n  p_tm_mon = &a2->tm_mon;\n  result = sscanf(a1, \"%u.%u-%u:%u%c\", &a2->tm_mon, &a2->tm_mday, p_tm_hour, &a2->tm_min, &v21);\n  if ( result > 3 )\n  {\nLABEL_6:\n    --a2->tm_mon;\nLABEL_12:\n    if ( v21 == 58 )\n    {\n      v7 = sscanf(v20 + 1, \"%u%c\", a2, &v21);\n      goto LABEL_14;\n    }\n    goto LABEL_50;\n  }\n  result = sscanf(a1, \"%u.%u.%u-%u:%u%c\", &a2->tm_year, p_tm_mon, &a2->tm_mday, p_tm_hour, &a2->tm_min, &v21);\n  if ( result > 4\n    || (result = sscanf(a1, \"%u-%u-%u %u:%u%c\", &a2->tm_year, p_tm_mon, &a2->tm_mday, p_tm_hour, &a2->tm_min, &v21),\n        result > 4) )\n  {\n    a2->tm_year -= 1900;\n    goto LABEL_6;\n  }\n  result = strptime();\n  if ( !result )\n    goto LABEL_11;\n  v6 = *(_BYTE *)result == 0;\nLABEL_10:\n  if ( !v6 )\n    goto LABEL_11;\n  return result;\n}\n"
    ],
    "sub_804EB64": [
        "0x804eb64",
        "time_t __usercall sub_804EB64@<eax>(const char *a1@<eax>, struct tm *a2@<edx>)\n{\n  time_t result; // eax\n\n  result = mktime(a2);\n  if ( result == -1 )\n    sub_804D5E0(\"invalid date '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_804EB80": [
        "0x804eb80",
        "char *__usercall sub_804EB80@<eax>(time_t *timer@<ecx>, size_t maxsize@<edx>, char *a3@<eax>, time_t a4@<ebx>)\n{\n  struct tm *v6; // eax\n  time_t v8; // [esp-4h] [ebp-Ch] BYREF\n\n  v8 = a4;\n  if ( !timer )\n  {\n    time(&v8);\n    timer = &v8;\n  }\n  v6 = localtime(timer);\n  return &a3[strftime(a3, maxsize, \"%H:%M:%S\", v6)];\n}\n"
    ],
    "sub_804EBAF": [
        "0x804ebaf",
        "char *__usercall sub_804EBAF@<eax>(time_t *timer@<ecx>, size_t maxsize@<edx>, char *a3@<eax>, time_t a4@<ebx>)\n{\n  struct tm *v6; // eax\n  time_t v8; // [esp-4h] [ebp-Ch] BYREF\n\n  v8 = a4;\n  if ( !timer )\n  {\n    time(&v8);\n    timer = &v8;\n  }\n  v6 = localtime(timer);\n  return &a3[strftime(a3, maxsize, \"%Y-%m-%d %H:%M:%S\", v6)];\n}\n"
    ],
    "sub_804EBDE": [
        "0x804ebde",
        "__int64 sub_804EBDE()\n{\n  int v1[5]; // [esp+0h] [ebp-14h] BYREF\n\n  sub_804E7DE((int)v1);\n  return 1000000LL * v1[0] + v1[1] / 1000;\n}\n"
    ],
    "sub_804EC14": [
        "0x804ec14",
        "__int64 sub_804EC14()\n{\n  int v1[5]; // [esp+0h] [ebp-14h] BYREF\n\n  sub_804E7DE((int)v1);\n  return 1000LL * v1[0] + v1[1] / 1000000;\n}\n"
    ],
    "sub_804EC4A": [
        "0x804ec4a",
        "int sub_804EC4A()\n{\n  int v1; // [esp+0h] [ebp-8h] BYREF\n\n  sub_804E7DE((int)&v1);\n  return v1;\n}\n"
    ],
    "sub_804EC5B": [
        "0x804ec5b",
        "__int64 __fastcall sub_804EC5B(char **a1)\n{\n  char v1; // cl\n  __int64 result; // rax\n\n  v1 = **a1;\n  if ( v1 )\n  {\n    if ( (unsigned __int8)(v1 - 48) <= 9u || (unsigned __int8)((v1 | 0x20) - 97) <= 0x19u || *(_DWORD *)dword_80DBB7C )\n    {\n      *(_DWORD *)dword_80DBB7C = 34;\n      return -1LL;\n    }\n    else\n    {\n      *(_DWORD *)dword_80DBB7C = 22;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_804EC9E": [
        "0x804ec9e",
        "__int64 __usercall sub_804EC9E@<edx:eax>(const char *a1@<eax>, char **a2@<edx>, int a3@<ecx>)\n{\n  char **p_endptr; // ebx\n  char *endptr; // [esp+4h] [ebp-10h] BYREF\n\n  p_endptr = &endptr;\n  if ( a2 )\n    p_endptr = a2;\n  *p_endptr = (char *)a1;\n  if ( (unsigned __int8)(*a1 - 48) <= 9u || (unsigned __int8)((*a1 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtoull(a1, p_endptr, a3);\n    return sub_804EC5B(p_endptr);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1LL;\n  }\n}\n"
    ],
    "sub_804ED01": [
        "0x804ed01",
        "__int64 __usercall sub_804ED01@<edx:eax>(char *a1@<eax>, char **a2@<edx>, int a3@<ecx>)\n{\n  char **p_endptr; // ebx\n  char v4; // dl\n  char *endptr; // [esp+4h] [ebp-10h] BYREF\n\n  p_endptr = &endptr;\n  if ( a2 )\n    p_endptr = a2;\n  *p_endptr = a1;\n  v4 = *a1;\n  if ( *a1 == 45 )\n    v4 = a1[1];\n  if ( (unsigned __int8)(v4 - 48) <= 9u || (unsigned __int8)((v4 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtoll(a1, p_endptr, a3);\n    return sub_804EC5B(p_endptr);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1LL;\n  }\n}\n"
    ],
    "sub_804ED6C": [
        "0x804ed6c",
        "int __usercall sub_804ED6C@<eax>(int base@<ecx>, const char *a2@<eax>, char **a3@<edx>, int a4@<ebx>)\n{\n  char **v4; // esi\n  int v6; // [esp-4h] [ebp-14h] BYREF\n\n  v6 = a4;\n  v4 = (char **)&v6;\n  if ( a3 )\n    v4 = a3;\n  *v4 = (char *)a2;\n  if ( (unsigned __int8)(*a2 - 48) <= 9u || (unsigned __int8)((*a2 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtoul(a2, v4, base);\n    return sub_804EC5B(v4);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1;\n  }\n}\n"
    ],
    "sub_804EDC5": [
        "0x804edc5",
        "int __usercall sub_804EDC5@<eax>(int base@<ecx>, char *a2@<eax>, char **a3@<edx>, int a4@<ebx>)\n{\n  char **v4; // esi\n  char v5; // bl\n  int v7; // [esp-4h] [ebp-14h] BYREF\n\n  v7 = a4;\n  v4 = (char **)&v7;\n  if ( a3 )\n    v4 = a3;\n  *v4 = a2;\n  v5 = *a2;\n  if ( *a2 == 45 )\n    v5 = a2[1];\n  if ( (unsigned __int8)(v5 - 48) <= 9u || (unsigned __int8)((v5 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtol(a2, v4, base);\n    return sub_804EC5B(v4);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1;\n  }\n}\n"
    ],
    "sub_804EE25": [
        "0x804ee25",
        "int __cdecl sub_804EE25(int a1, int a2)\n{\n  const char **v2; // esi\n  int v3; // ebx\n  const char *v4; // edi\n  int v5; // esi\n  const char *v7; // [esp-4h] [ebp-14h]\n  char *v8; // [esp+0h] [ebp-10h] BYREF\n\n  v8 = \"0\";\n  if ( geteuid() )\n    sub_804D5E0(\"permission denied (are you root?)\");\n  sub_80ABEC2(a2, \"^g:S\", \"gid\", (char)&v8);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = sub_80B40CC(60000, 0);\n  v4 = *v2;\n  if ( getgrnam(*v2) )\n    sub_804D5E0(\"%s '%s' in use\", \"group\", v4);\n  v5 = 60000;\n  if ( (dword_80DBB9C & 1) == 0 )\n  {\n    v3 = (dword_80DBB9C & 2) == 0 ? 1000 : 100;\n    v5 = (dword_80DBB9C & 2) == 0 ? 60000 : 999;\n  }\n  while ( getgrgid(v3) )\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n    {\n      v7 = sub_804D70F(v3);\n      sub_804D5E0(\"%s '%s' in use\", \"gid\", v7);\n    }\n    if ( v3 == v5 )\n      sub_804D5E0(\"no %cids left\", 103);\n    ++v3;\n  }\n  sub_804DDBF(\"x:%u:\", v3);\n  if ( ((int (*)(void))sub_80B33A5)() < 0 )\n    exit(1);\n  sub_80B33A5(\"!::\", v4);\n  return 0;\n}\n"
    ],
    "sub_804EF35": [
        "0x804ef35",
        "int __usercall sub_804EF35@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  const char *v4; // [esp+0h] [ebp-1Ch]\n  const char *v5; // [esp+4h] [ebp-18h]\n  _BYTE *v6; // [esp+8h] [ebp-14h]\n  const char *v7; // [esp+Ch] [ebp-10h]\n  _BYTE *v8; // [esp+10h] [ebp-Ch]\n  int v9; // [esp+14h] [ebp-8h]\n\n  v4 = \"addgroup\";\n  if ( a2 )\n  {\n    v5 = \"--\";\n    v6 = *(_BYTE **)a1;\n    v7 = a2;\n    v8 = 0;\n  }\n  else\n  {\n    v5 = \"--gid\";\n    v6 = sub_804D6F7(*(_DWORD *)(a1 + 12));\n    v7 = \"--\";\n    v8 = *(_BYTE **)a1;\n    v9 = 0;\n  }\n  return sub_80B3C03(v4, v5, v6, v7, v8, v9);\n}\n"
    ],
    "sub_804EF98": [
        "0x804ef98",
        "int __cdecl sub_804EF98(int a1, int a2)\n{\n  int v2; // ebx\n  const char **v3; // edx\n  const char *v4; // eax\n  const char *v5; // edx\n  __gid_t v7; // edx\n  int v8; // esi\n  char *v9; // eax\n  unsigned int v10; // eax\n  char *v11; // eax\n  const char *v12; // [esp-4h] [ebp-48h]\n  const char *v13; // [esp+0h] [ebp-44h] BYREF\n  int v14; // [esp+4h] [ebp-40h] BYREF\n  const char *v15; // [esp+8h] [ebp-3Ch] BYREF\n  int v16[5]; // [esp+Ch] [ebp-38h] BYREF\n  char *name[2]; // [esp+20h] [ebp-24h] BYREF\n  __uid_t uid; // [esp+28h] [ebp-1Ch]\n  __gid_t group; // [esp+2Ch] [ebp-18h]\n  const char *v20; // [esp+30h] [ebp-14h] BYREF\n  char *path; // [esp+34h] [ebp-10h] BYREF\n  const char *v22; // [esp+38h] [ebp-Ch] BYREF\n\n  v13 = 0;\n  v15 = \"/etc/skel\";\n  if ( geteuid() )\n    sub_804D5E0(\"permission denied (are you root?)\");\n  v20 = \"Linux User,,,\";\n  v22 = (const char *)sub_80AB879();\n  path = 0;\n  v2 = sub_80ABEC2(a2, \"^h:g:s:G:DSHu:k:\", \"home\", &path, &v20, &v22, &v13, &v14, &v15);\n  if ( (v2 & 0x80u) != 0 )\n    uid = sub_80B40CC(60000, 0);\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = *v3;\n  name[0] = (char *)*v3;\n  if ( !v2 )\n  {\n    v5 = v3[1];\n    if ( v5 )\n      return sub_804EF35((int)name, v5);\n  }\n  if ( !path )\n    path = sub_804DDBF(\"/home/%s\", v4);\n  name[1] = \"x\";\n  if ( (v2 & 0x20) != 0 )\n  {\n    if ( !v13 )\n      v13 = \"nogroup\";\n    if ( (v2 & 4) == 0 )\n      v22 = (const char *)&MEMORY[0x80C7F07];\n  }\n  v7 = -1;\n  if ( v13 )\n    v7 = sub_80A9A4C();\n  group = v7;\n  if ( getpwnam(name[0]) )\n    sub_804D5E0(\"%s '%s' in use\", \"user\", name[0]);\n  v8 = 60000;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    if ( (dword_80DBB9C & 0x20) != 0 )\n    {\n      uid = 100;\n      v8 = 999;\n    }\n    else\n    {\n      uid = 1000;\n    }\n  }\n  while ( getpwuid(uid) || group == -1 && getgrgid(uid) )\n  {\n    if ( (dword_80DBB9C & 0x80u) != 0 )\n    {\n      v12 = sub_804D70F(uid);\n      sub_804D5E0(\"%s '%s' in use\", \"uid\", v12);\n    }\n    if ( v8 == uid )\n      sub_804D5E0(\"no %cids left\", 117);\n    ++uid;\n  }\n  if ( group == -1 )\n  {\n    group = uid;\n    if ( getgrnam(name[0]) )\n      sub_804D5E0(\"%s '%s' in use\", \"group\", name[0]);\n  }\n  v9 = sub_804DDBF(\"x:%u:%u:%s:%s:%s\", uid, group, v20, path, v22);\n  if ( sub_80B33A5(v9, name[0]) < 0 )\n    return 1;\n  v10 = time(0);\n  v11 = sub_804DDBF(\"!:%u:0:99999:7:::\", v10 / 0x15180);\n  sub_80B33A5(v11, name[0]);\n  sub_804EF35((int)name, v13);\n  umask(0);\n  if ( (v2 & 0x40) == 0 )\n  {\n    if ( mkdir(path, 0x1EDu) )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 17 )\n      {\nLABEL_43:\n        sub_804D3F1(path);\n        goto LABEL_45;\n      }\n    }\n    else\n    {\n      v16[0] = (int)\"chown\";\n      v16[1] = (int)\"-R\";\n      v16[2] = (int)sub_804DDBF(\"%u:%u\", uid, group);\n      v16[3] = (int)path;\n      v16[4] = 0;\n      if ( (v2 & 0x100) == 0 )\n        byte_80DB561 = 0;\n      sub_80A9C77(4);\n      byte_80DB561 = 1;\n      sub_80900EA(4, v16);\n    }\n    if ( !chown(path, uid, group) && !chmod(path, 0x5EDu) )\n      goto LABEL_45;\n    goto LABEL_43;\n  }\nLABEL_45:\n  if ( (v2 & 0x10) == 0 )\n  {\n    execlp(\"passwd\", \"passwd\", \"--\", name[0], 0);\n    sub_804D5E0(\"can't execute passwd, you must set password manually\");\n  }\n  return 0;\n}\n"
    ],
    "sub_804F2F0": [
        "0x804f2f0",
        "int __cdecl sub_804F2F0(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  int v3; // eax\n  const char *v4; // eax\n  void *v6; // [esp+0h] [ebp-38h] BYREF\n  int v7; // [esp+4h] [ebp-34h] BYREF\n  int v8; // [esp+8h] [ebp-30h] BYREF\n  char v9[42]; // [esp+Eh] [ebp-2Ah] BYREF\n\n  v8 = 0;\n  v6 = &unk_80C8018;\n  v7 = 0;\n  sub_80ABEC2(a2, \"^sP:+S:m:a:\", \"stdin\", &v8, &v7, &v6, &v6);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( *v2 && !v7 )\n    v7 = v2[1];\n  sub_80B1D29();\n  if ( v7 )\n    sub_80B2C4E(35, v7);\n  sub_804DC97(v8, 0);\n  if ( *v2 || (*ident != 109 || !isatty(0) ? (v3 = sub_80AB85A()) : (v3 = sub_80A9888()), v3) )\n  {\n    v4 = (const char *)sub_80B1D56(1, v9);\n    puts(v4);\n  }\n  return 0;\n}\n"
    ],
    "sub_804F3C6": [
        "0x804f3c6",
        "int __usercall sub_804F3C6@<eax>(int a1@<ebx>, int a2, int a3)\n{\n  int v3; // ebp\n  int v4; // esi\n  char v5; // bl\n  int v6; // edi\n  const char *v7; // esi\n  struct group *v8; // edx\n  int v9; // edi\n  struct passwd *v10; // eax\n  const char *v11; // ebp\n  struct group *v14; // [esp+0h] [ebp-14h]\n\n  v3 = a2;\n  v4 = a3;\n  v5 = ident[3];\n  v6 = 0;\n  if ( v5 == 117 )\n  {\n    v6 = sub_80ABEC2(a3, &data, \"remove-home\");\n    v4 = a3 + 4 * v6;\n    v3 = a2 - v6;\n  }\n  if ( geteuid() )\n    sub_804D5E0(\"permission denied (are you root?)\");\n  v7 = *(const char **)(v4 + 4);\n  if ( v3 != 2 )\n    sub_804CDC2(a1);\n  if ( v5 != 117 )\n  {\n    v8 = (struct group *)sub_80A99B7();\n    v9 = 0;\n    goto LABEL_13;\n  }\n  sub_80A999C();\n  if ( v6 )\n    sub_80B2709();\n  v9 = 1;\n  v11 = \"/etc/shadow\";\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      if ( sub_80B33A5(0, v7) == -1 )\n        return 1;\n      if ( !v11 )\n        break;\n      v11 = 0;\n    }\n    if ( v9 != 1 )\n      return 0;\n    if ( sub_80B33A5(0, 0) == -1 )\n      return 1;\n    v8 = getgrnam(v7);\n    v9 = -1;\n    if ( !v8 )\n      break;\nLABEL_13:\n    while ( 1 )\n    {\n      v14 = v8;\n      v10 = getpwent();\n      v11 = \"/etc/gshadow\";\n      v8 = v14;\n      if ( !v10 )\n        break;\n      if ( v10->pw_gid == v14->gr_gid )\n        sub_804D5E0(\"'%s' still has '%s' as their primary group!\", v10->pw_name, v7);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_804F4D6": [
        "0x804f4d6",
        "int sub_804F4D6()\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  sleep(0xAu);\n  return v1;\n}\n"
    ],
    "sub_804F4DF": [
        "0x804f4df",
        "int __usercall sub_804F4DF@<eax>(const char *a1@<eax>, int a2@<ebx>)\n{\n  int result; // eax\n\n  result = sub_804ED6C(10, a1, 0, a2);\n  if ( result >= 0 )\n    return sub_80B2EFA();\n  return result;\n}\n"
    ],
    "sub_804F4F5": [
        "0x804f4f5",
        "int sub_804F4F5()\n{\n  int result; // eax\n\n  result = sub_804D995((const struct termios *)(dword_80DBB80 + 72));\n  if ( result < 0 )\n    sub_804D3C9((int)\"tcsetattr\");\n  return result;\n}\n"
    ],
    "sub_804F511": [
        "0x804f511",
        "int sub_804F511()\n{\n  int v0; // eax\n  int v1; // edx\n  int v2; // ecx\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 72);\n  v2 = v1;\n  BYTE1(v2) = BYTE1(v1) | 0x14;\n  *(_DWORD *)(dword_80DBB80 + 72) = v2;\n  if ( *(_BYTE *)(v0 + 68) == 13 )\n  {\n    BYTE1(v1) |= 0x15u;\n    *(_DWORD *)(v0 + 72) = v1;\n  }\n  *(_DWORD *)(v0 + 84) |= 0xA3Bu;\n  *(_WORD *)(v0 + 89) = 7171;\n  *(_BYTE *)(v0 + 100) = 10;\n  *(_BYTE *)(v0 + 96) = 0;\n  *(_WORD *)(v0 + 92) = 1045;\n  sub_804F4F5();\n  return sub_804E586(1u, (char *)\"\\n\");\n}\n"
    ],
    "handler": [
        "0x804f561",
        "void __cdecl __noreturn handler(int a1)\n{\n  sub_804F511();\n  _exit(0);\n}\n"
    ],
    "sub_804F56D": [
        "0x804f56d",
        "void __cdecl __noreturn sub_804F56D(int a1, int a2)\n{\n  char *v2; // ebx\n  int v3; // esi\n  char *v4; // edx\n  char *v5; // eax\n  char *v6; // edi\n  int v7; // ebp\n  int v8; // eax\n  int v9; // eax\n  const char *v10; // edx\n  int v11; // esi\n  __pid_t v12; // ebp\n  int v13; // ebp\n  int v14; // ebp\n  int v15; // eax\n  char v16; // al\n  char *v17; // eax\n  const char *v18; // eax\n  int v19; // eax\n  speed_t v20; // esi\n  int v21; // eax\n  char v22; // dl\n  const char *v23; // esi\n  ssize_t v24; // eax\n  const char *v25; // eax\n  int v26; // eax\n  bool i; // zf\n  char *v28; // esi\n  int v29; // ecx\n  __sighandler_t v30; // [esp+8h] [ebp-20h]\n  int v31; // [esp+8h] [ebp-20h]\n  __sighandler_t handler; // [esp+10h] [ebp-18h] BYREF\n  char *v33; // [esp+14h] [ebp-14h] BYREF\n\n  v2 = (char *)sub_804DB2E(0x104u);\n  dword_80DBB80 = (int)v2;\n  *((_DWORD *)v2 + 1) = \"/bin/login\";\n  *((_DWORD *)v2 + 5) = \"/etc/issue\";\n  v2[68] = 13;\n  if ( (sub_80ABEAC(a2, \"^I:LH:f:hil:mt:+wn\", v2 + 16, v2 + 8, v2 + 20, v2 + 4, v2) & 1) != 0 )\n  {\n    *((_DWORD *)v2 + 4) = sub_804DB46(*((const char **)v2 + 4));\n    sub_80B0D53();\n  }\n  v3 = a2 + 4 * optind;\n  v4 = *(char **)v3;\n  *((_DWORD *)v2 + 3) = *(_DWORD *)v3;\n  v5 = *(char **)(v3 + 4);\n  if ( (unsigned __int8)(*v4 - 48) <= 9u )\n  {\n    *((_DWORD *)v2 + 3) = v5;\n    v5 = v4;\n  }\n  v33 = v5;\n  while ( 1 )\n  {\n    v6 = strsep(&v33, \",\");\n    if ( !v6 )\n      break;\n    v7 = *((_DWORD *)v2 + 6);\n    *(_DWORD *)&v2[4 * v7 + 28] = sub_804F4DF(v6, (int)v2);\n    v8 = *((_DWORD *)v2 + 6);\n    if ( *(int *)&v2[4 * v8 + 28] < 0 )\n      sub_804D5E0(\"bad speed: %s\", v6);\n    v9 = v8 + 1;\n    *((_DWORD *)v2 + 6) = v9;\n    if ( v9 > 10 )\n      sub_804D5E0(\"too many alternate speeds\");\n  }\n  v10 = *(const char **)(v3 + 8);\n  if ( v10 )\n    sub_804DDE4(\"TERM\", v10);\n  v11 = setsid();\n  if ( v11 < 0 )\n  {\n    v12 = getpid();\n    v11 = getsid();\n    if ( v11 != v12 )\n      sub_804D3C9((int)\"setsid\");\n    v13 = open64();\n    if ( v13 >= 0 )\n    {\n      v30 = signal(1, (__sighandler_t)1);\n      ioctl(v13, 0x5422u);\n      close(v13);\n      signal(1, v30);\n    }\n  }\n  v14 = sub_804DBE1(\"/dev/null\");\n  sub_804DC7B(v14, 1);\n  sub_804DC7B(v14, 2);\n  while ( v14 > 2 )\n  {\n    v30 = (__sighandler_t)(v14 - 1);\n    close(v14--);\n  }\n  dword_80DBB84 = sub_804F4D6;\n  off_80DB54C = (char *)\"\\r\\n\";\n  openlog(ident, 1, 32);\n  byte_80DB561 = 3;\n  v15 = *((_DWORD *)v2 + 3);\n  if ( *(_BYTE *)v15 == 45 )\n  {\n    if ( !*(_BYTE *)(v15 + 1) )\n    {\n      v16 = fcntl64();\n      if ( (v16 & 3) != 2 )\n        sub_804D5E0(\"stdin is not open for read/write\", v30);\n      v17 = sub_804E0D9(0);\n      if ( v17 )\n        *((_DWORD *)v2 + 3) = v17;\n      goto LABEL_31;\n    }\n  }\n  else if ( *(_BYTE *)v15 == 47 )\n  {\nLABEL_26:\n    close(0);\n    sub_804DBE1(*((const char **)v2 + 3));\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\nLABEL_31:\n    v18 = (const char *)sub_80B2EB2();\n    ident = sub_804DDBF(\"getty: %s\", v18);\n    sub_804D646();\n    sub_804DC7B(0, 1);\n    sub_804DC7B(0, 2);\n    v19 = tcgetsid();\n    if ( (v11 != v19 || v19 < 0) && ioctl(0, 0x540Eu, 1) < 0 )\n      sub_804D3C9((int)\"TIOCSCTTY\", v30);\n    if ( tcsetpgrp(0, v11) < 0 )\n      sub_804D3C9((int)\"tcsetpgrp\", v30);\n    if ( tcgetattr(0, (struct termios *)(v2 + 72)) < 0 )\n      sub_804D3C9((int)\"tcgetattr\", v30);\n    sub_80B3832(\"LOGIN\", *((_DWORD *)v2 + 2));\n    v20 = *((_DWORD *)v2 + 7);\n    sub_804E7B4(14, (int)sub_804E68E);\n    alarm(5u);\n    tcdrain(0);\n    alarm(0);\n    tcflush(0, 2);\n    if ( v20 )\n      cfsetspeed((struct termios *)(v2 + 72), v20);\n    v21 = *((_DWORD *)v2 + 20) & 0x500F134F;\n    *((_DWORD *)v2 + 20) = v21 | 0x4B0;\n    v22 = dword_80DBB9C;\n    if ( (dword_80DBB9C & 2) != 0 )\n      *((_DWORD *)v2 + 20) = v21 | 0xCB0;\n    if ( (v22 & 0x10) != 0 )\n      *((_DWORD *)v2 + 20) |= 0x80000000;\n    *((_DWORD *)v2 + 18) = 0;\n    *((_DWORD *)v2 + 21) = 0;\n    *((_DWORD *)v2 + 19) = 5;\n    *((_WORD *)v2 + 47) = 256;\n    v2[88] = 0;\n    sub_804F4F5();\n    if ( (dword_80DBB9C & 1) != 0 )\n      sub_804D846(*((const char **)v2 + 4));\n    if ( (dword_80DBB9C & 0x80u) != 0 )\n    {\n      v2[95] = 0;\n      sub_804F4F5();\n      sleep(1u);\n      v23 = v2 + 132;\n      v24 = sub_804E5BC(0x7Fu, v2 + 132, 0);\n      if ( v24 > 0 )\n      {\n        v2[v24 + 132] = 0;\n        v25 = &v23[v24];\n        while ( 1 )\n        {\n          if ( v23 >= v25 )\n            goto LABEL_55;\n          if ( (unsigned __int8)(*v23 - 48) <= 9u )\n            break;\n          ++v23;\n        }\n        v26 = sub_804F4DF(v23, (int)v2);\n        if ( v26 > 0 )\n          cfsetspeed((struct termios *)(v2 + 72), v26);\n      }\nLABEL_55:\n      v2[95] = 1;\n      sub_804F4F5();\n    }\n    signal(14, (__sighandler_t)::handler);\n    alarm(*(_DWORD *)v2);\n    for ( i = (dword_80DBB9C & 0x200) == 0;\n          !i && sub_804E5BC(1u, (char *)&handler + 3, 0) == 1 && HIBYTE(handler) != 10;\n          i = HIBYTE(handler) == 13 )\n    {\n      ;\n    }\n    if ( (dword_80DBB9C & 0x400) != 0 )\n    {\nLABEL_94:\n      alarm(0);\n      sub_804F511();\n      execlp(*((const char **)v2 + 1), *((const char **)v2 + 1), \"--\", v6, 0);\n      sub_804D5E0(\"can't execute '%s'\", *((const char **)v2 + 1));\n    }\n    v31 = 0;\nLABEL_63:\n    usleep(0x186A0u);\n    tcflush(0, 0);\nLABEL_64:\n    if ( (dword_80DBB9C & 0x20) == 0 )\n      sub_80AFB8C();\n    sub_80AFD20();\n    v6 = v2 + 132;\n    v28 = v2 + 132;\n    while ( 1 )\n    {\n      *(_DWORD *)dword_80DBB7C = 4;\n      if ( read(0, (char *)&handler + 3, 1u) <= 0 )\n      {\n        sub_804F511();\n        if ( (unsigned int)(*(_DWORD *)dword_80DBB7C - 4) > 1 )\n          sub_804D3C9((int)\"read error\", v31);\nLABEL_88:\n        exit(0);\n      }\n      if ( HIBYTE(handler) == 8 )\n        goto LABEL_84;\n      if ( HIBYTE(handler) > 8u )\n      {\n        if ( HIBYTE(handler) == 13 )\n          goto LABEL_82;\n        if ( HIBYTE(handler) <= 0xDu )\n        {\n          if ( HIBYTE(handler) == 10 )\n          {\nLABEL_82:\n            *v28 = 0;\n            v2[68] = HIBYTE(handler);\n            if ( v2[132] )\n              goto LABEL_94;\n            goto LABEL_64;\n          }\n          goto LABEL_91;\n        }\n        if ( HIBYTE(handler) == 21 )\n        {\n          while ( v6 < v28 )\n          {\n            sub_804E586(3u, \"\\b \\b\");\n            --v28;\n          }\n        }\n        else\n        {\n          if ( HIBYTE(handler) != 127 )\n            goto LABEL_91;\nLABEL_84:\n          v2[91] = HIBYTE(handler);\n          if ( v6 < v28 )\n          {\n            sub_804E586(3u, \"\\b \\b\");\n            --v28;\n          }\n        }\n      }\n      else if ( HIBYTE(handler) )\n      {\n        if ( (unsigned __int8)(HIBYTE(handler) - 3) <= 1u )\n        {\n          sub_804F511();\n          goto LABEL_88;\n        }\nLABEL_91:\n        if ( HIBYTE(handler) > 0x1Fu && (unsigned int)(v28 - v6) <= 0x7E )\n        {\n          sub_804E586(1u, (char *)&handler + 3);\n          *v28++ = HIBYTE(handler);\n        }\n      }\n      else\n      {\n        v29 = *((_DWORD *)v2 + 6);\n        if ( v29 > 1 )\n        {\n          v31 = (v31 + 1) % v29;\n          cfsetspeed((struct termios *)(v2 + 72), *(_DWORD *)&v2[4 * v31 + 28]);\n          sub_804F4F5();\n          goto LABEL_63;\n        }\n      }\n    }\n  }\n  *((_DWORD *)v2 + 3) = sub_804DDBF(\"/dev/%s\", (const char *)v15);\n  goto LABEL_26;\n}\n"
    ],
    "sub_804FB6E": [
        "0x804fb6e",
        "void __cdecl __noreturn sub_804FB6E(int a1)\n{\n  sub_804D61C();\n  sub_804D995((const struct termios *)&qword_80DB778);\n  printf(\"\\r\\nLogin timed out after %u seconds\\r\\n\", 60);\n  sub_804DD8F();\n  sub_804D646();\n  _exit(0);\n}\n"
    ],
    "sub_804FBA4": [
        "0x804fba4",
        "int __cdecl sub_804FBA4(int a1, int a2)\n{\n  int v2; // edx\n  const char *v3; // edi\n  int v4; // esi\n  int v5; // ebx\n  unsigned __int8 *v6; // edx\n  int v7; // eax\n  char *v8; // ebx\n  struct passwd *v9; // eax\n  struct passwd *v10; // ebx\n  char v11; // al\n  FILE *v12; // esi\n  int i; // edi\n  char *IO_write_base; // eax\n  int v15; // ebx\n  const char *v16; // esi\n  int v17; // esi\n  int v19; // [esp+0h] [ebp-6Ch]\n  int v20; // [esp+4h] [ebp-68h]\n  char v21; // [esp+8h] [ebp-64h]\n  char *v22; // [esp+Ch] [ebp-60h]\n  int v23; // [esp+10h] [ebp-5Ch]\n  const char *v24; // [esp+14h] [ebp-58h] BYREF\n  int v25; // [esp+18h] [ebp-54h] BYREF\n  char dest[4]; // [esp+1Ch] [ebp-50h] BYREF\n\n  v24 = 0;\n  v23 = sub_80AFD54();\n  sub_80B3C0D();\n  dest[0] = 0;\n  v21 = sub_80ABEAC(a2, \"f:h:p\", &v25, &v24);\n  if ( (v21 & 1) != 0 )\n  {\n    if ( v23 )\n      sub_804D5E0(\"-f is for root only\");\n    sub_80B2C4E(64, v25);\n  }\n  v2 = *(_DWORD *)(a2 + 4 * optind);\n  if ( v2 )\n    sub_80B2C4E(64, v2);\n  if ( tcgetattr(0, (struct termios *)&qword_80DB778) >= 0 && isatty(1) )\n  {\n    signal(14, (__sighandler_t)sub_804FB6E);\n    alarm(0x3Cu);\n    if ( !sub_804E0D9(0) )\n      sub_804DB46(\"UNKNOWN\");\n    v3 = (const char *)sub_80B2EB2();\n    if ( v24 )\n      v22 = sub_804DDBF(\" on '%s' from '%s'\", v3, v24);\n    else\n      v22 = sub_804DDBF(\" on '%s'\", v3);\n    openlog(ident, 3, 32);\n    v4 = 3;\n    while ( 1 )\n    {\n      tcflush(0, 0);\n      if ( dest[0] )\n        goto LABEL_32;\n      v5 = 10;\n      while ( 1 )\n      {\n        sub_80AFD20();\nLABEL_18:\n        v6 = *(unsigned __int8 **)(_stdin + 16);\n        if ( (unsigned int)v6 >= *(_DWORD *)(_stdin + 24) )\n        {\n          v7 = __fgetc_unlocked();\n          if ( v7 == -1 )\n            goto LABEL_21;\n        }\n        else\n        {\n          *(_DWORD *)(_stdin + 16) = v6 + 1;\n          v7 = *v6;\n        }\n        if ( v7 != 10 )\n          break;\n        if ( !--v5 )\n          goto LABEL_21;\n      }\n      if ( (unsigned __int8)(v7 - 9) <= 4u || (_BYTE)v7 == 32 )\n        goto LABEL_18;\n      dest[0] = v7;\n      v8 = &dest[1];\n      if ( !fgets_unlocked() || !strchr(&dest[1], 10) )\nLABEL_21:\n        exit(1);\n      while ( (unsigned __int8)*v8 > 0x20u )\n        ++v8;\n      *v8 = 0;\nLABEL_32:\n      v9 = getpwnam(dest);\n      v10 = v9;\n      if ( !v9 )\n      {\n        strcpy(dest, \"UNKNOWN\");\n        goto LABEL_44;\n      }\n      v11 = *v9->pw_passwd;\n      if ( v11 != 33 && v11 != 42 )\n      {\n        if ( (v21 & 1) == 0 )\n        {\n          if ( !v10->pw_uid && !sub_80B2C7E() )\n            goto LABEL_36;\n          if ( *v10->pw_passwd )\n          {\nLABEL_44:\n            if ( sub_80AA371() <= 0 )\n              goto LABEL_36;\n          }\n        }\n        alarm(0);\n        if ( v10->pw_uid )\n        {\n          v12 = (FILE *)sub_80B3D37();\n          if ( v12 )\n          {\n            for ( i = 1; ; i = 0 )\n            {\n              IO_write_base = v12->_IO_write_base;\n              if ( IO_write_base >= v12->_IO_write_end )\n              {\n                v15 = __fgetc_unlocked();\n                if ( v15 == -1 )\n                {\n                  if ( i )\n                    puts(\"\\r\\nSystem closed for routine maintenance\\r\");\n                  fclose(v12);\n                  sub_804DD8F();\n                  tcdrain(1);\n                  exit(1);\n                }\n              }\n              else\n              {\n                v12->_IO_write_base = IO_write_base + 1;\n                v15 = (unsigned __int8)*IO_write_base;\n              }\n              if ( v15 == 10 )\n                sub_804DD98(13);\n              sub_804DD98(v15);\n            }\n          }\n        }\n        fchown(0, v10->pw_uid, v10->pw_gid);\n        fchmod(0, 0x180u);\n        v16 = 0;\n        if ( !v23 )\n          v16 = v24;\n        getpid();\n        sub_80B3832(dest, v16);\n        sub_80A9B93();\n        sub_80B2CE1(v10, (v21 & 4) == 0 ? 3 : 1);\n        if ( access(\".hushlogin\", 0) )\n        {\n          v17 = open64();\n          if ( v17 >= 0 )\n          {\n            sub_804DD8F();\n            sub_804E572(v17, 1);\n            close(v17);\n          }\n        }\n        if ( !v10->pw_uid )\n          syslog(6, \"root login%s\", v22);\n        signal(2, 0);\n        sub_80B2B50(0, 1, v19, v20);\n      }\nLABEL_36:\n      v21 &= ~1u;\n      sub_80A98F4();\n      puts(\"Login incorrect\");\n      if ( !--v4 )\n      {\n        syslog(4, \"invalid password for '%s'%s\", dest, v22);\n        return 1;\n      }\n      dest[0] = 0;\n    }\n  }\n  return 1;\n}\n"
    ],
    "sub_804FF5D": [
        "0x804ff5d",
        "int __cdecl sub_804FF5D(int a1, int a2)\n{\n  const char **v2; // ebx\n  __uid_t v3; // edi\n  const char *v4; // eax\n  char *v5; // eax\n  const char *v6; // esi\n  int v7; // eax\n  const char **v8; // ebx\n  struct spwd *v9; // ebp\n  const char *v10; // eax\n  const char *v11; // eax\n  int v12; // eax\n  const char *v13; // ebp\n  const char *v14; // eax\n  char *v15; // ebx\n  const char *v16; // eax\n  int v17; // eax\n  const char *v18; // eax\n  int v20; // [esp-4h] [ebp-164h]\n  char v21; // [esp+4h] [ebp-15Ch]\n  const char *v22; // [esp+8h] [ebp-158h]\n  void *v23; // [esp+10h] [ebp-150h]\n  void *v24; // [esp+14h] [ebp-14Ch] BYREF\n  struct spwd *result[5]; // [esp+18h] [ebp-148h] BYREF\n  struct spwd result_buf; // [esp+2Ch] [ebp-134h] BYREF\n  char buffer[272]; // [esp+50h] [ebp-110h] BYREF\n\n  v24 = &unk_80C8018;\n  byte_80DB561 = 3;\n  openlog(ident, 0, 32);\n  v21 = sub_80ABEAC(a2, \"a:lud\", &v24);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = getuid();\n  if ( (v21 & 0xE) != 0 && (v3 || !*v2) )\n    sub_804CDC2(v21 & 0xE);\n  v4 = (const char *)sub_80A99ED();\n  v5 = sub_804DB46(v4);\n  v22 = v5;\n  v6 = *v2;\n  if ( !*v2 )\n    v6 = v5;\n  v7 = sub_80A999C();\n  v8 = (const char **)v7;\n  if ( v3 && *(_DWORD *)(v7 + 8) != v3 )\n    sub_804D5E0(\"%s can't change password for %s\", v22, v6);\n  result[0] = 0;\n  *(_DWORD *)dword_80DBB7C = 0;\n  if ( !getspnam_r(*(const char **)v7, &result_buf, buffer, 0x100u, result)\n    && (v9 = result[0]) != 0\n    && !strcmp(result[0]->sp_namp, *v8) )\n  {\n    v8[1] = v9->sp_pwdp;\n  }\n  else if ( *(_DWORD *)dword_80DBB7C != 2 )\n  {\n    sub_804D3A5((int)\"no record of %s in %s, using %s\", v6, \"/etc/shadow\", \"/etc/passwd\");\n  }\n  v10 = v8[1];\n  if ( (v21 & 0xE) == 0 )\n  {\n    if ( *v10 == 33 && v3 )\n      sub_804D5E0(\"can't change locked password for %s\", v6);\n    printf(\"Changing password for %s\\n\", v6);\n    v23 = v24;\n    if ( v3 && *v8[1] )\n    {\n      if ( !sub_80A9888() )\n      {\nLABEL_32:\n        v15 = 0;\nLABEL_34:\n        sub_80B030A();\n        sub_80B030A();\n        sub_80B030A();\n        if ( !v15 )\n        {\n          byte_80DB561 = 1;\n          sub_804D5E0(\"password for %s is unchanged\", v6);\n        }\n        goto LABEL_46;\n      }\n      v11 = (const char *)sub_80B1D56(1, v8[1]);\n      if ( strcmp(v11, v8[1]) )\n      {\n        syslog(4, \"incorrect password for %s\", *v8);\n        sub_80A98F4();\n        puts(\"Incorrect password\");\n        goto LABEL_32;\n      }\n    }\n    v12 = sub_80A9888();\n    v13 = (const char *)v12;\n    if ( !v12 || sub_80B03AD(v8, v12) && v3 )\n    {\n      v15 = 0;\n    }\n    else\n    {\n      v14 = (const char *)sub_80A9888();\n      v15 = 0;\n      if ( v14 )\n      {\n        if ( !strcmp(v14, v13) )\n        {\n          sub_80B1D29(v20, v23);\n          v15 = (char *)sub_80B1D56(1, result);\n        }\n        else\n        {\n          puts(\"Passwords don't match\");\n        }\n      }\n    }\n    goto LABEL_34;\n  }\n  if ( (v21 & 2) != 0 )\n  {\n    if ( *v10 == 33 )\n      goto LABEL_38;\n    v15 = sub_804DDBF(\"!%s\", v10);\n  }\n  else if ( (v21 & 4) != 0 )\n  {\n    if ( *v10 != 33 )\n      goto LABEL_38;\n    v15 = sub_804DB46(v10 + 1);\n  }\n  else\n  {\n    v15 = 0;\n    if ( (v21 & 8) != 0 )\n      v15 = (char *)&data;\n  }\nLABEL_46:\n  result[2] = (struct spwd *)15360000;\n  result[3] = 0;\n  result[0] = (struct spwd *)15360000;\n  result[1] = 0;\n  setrlimit64();\n  sub_804E6C8(14, (void (*)(int))1);\n  umask(0x3Fu);\n  sub_804DE74(0);\n  v17 = sub_80B33A5(v15, v6);\n  if ( v17 > 0 )\n  {\n    v15 = \"x\";\n  }\n  else if ( v17 )\n  {\n    v18 = \"/etc/shadow\";\nLABEL_53:\n    sub_804D5E0(\"can't update password file %s\", v18);\n  }\n  if ( sub_80B33A5(v15, v6) < 0 )\n  {\n    v18 = \"/etc/passwd\";\n    goto LABEL_53;\n  }\n  sub_804D5F4(\"password for %s changed by %s\", v6, v22);\n  if ( !v15 )\n  {\nLABEL_38:\n    v16 = \"un\";\n    if ( (v21 & 4) == 0 )\n      v16 = &data;\n    sub_804D5E0(\"password for %s is already %slocked\", v6, v16);\n  }\n  return 0;\n}\n"
    ],
    "sub_80502F4": [
        "0x80502f4",
        "void __cdecl __noreturn sub_80502F4(int a1, int a2)\n{\n  __uid_t v2; // ebp\n  const char **v3; // ebx\n  const char *v4; // eax\n  const char *v5; // edi\n  int v6; // eax\n  char *v7; // edx\n  struct passwd *v8; // eax\n  int v9; // esi\n  const char *v10; // edx\n  int v11; // eax\n  const char *v12; // ebp\n  bool i; // zf\n  char *v14; // eax\n  int v15; // [esp+0h] [ebp-64h]\n  const char *v16; // [esp+4h] [ebp-60h]\n  const char *v17; // [esp+8h] [ebp-5Ch]\n  char *v18; // [esp+Ch] [ebp-58h] BYREF\n  const char *v19; // [esp+10h] [ebp-54h] BYREF\n  char name[80]; // [esp+14h] [ebp-50h] BYREF\n\n  v18 = 0;\n  v19 = 0;\n  v2 = getuid();\n  v15 = sub_80ABEAC(a2, \"mplc:s:\", &v19, &v18);\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = *v3;\n  if ( *v3 && *v4 == 45 && !v4[1] )\n  {\n    v15 |= 4u;\n    ++v3;\n  }\n  v5 = *v3;\n  if ( *v3 )\n    ++v3;\n  else\n    v5 = \"root\";\n  sub_804E0D9(0);\n  v16 = (const char *)sub_80B2EB2();\n  v6 = getlogin_r(name, 0x40u);\n  v7 = name;\n  if ( v6 )\n  {\n    v8 = getpwuid(v2);\n    v7 = (char *)&data;\n    if ( v8 )\n      v7 = sub_804DB46(v8->pw_name);\n  }\n  v17 = v7;\n  openlog(ident, 0, 32);\n  v9 = sub_80A999C();\n  v10 = v17;\n  if ( v2 )\n  {\n    v11 = sub_80AA371();\n    v10 = v17;\n    if ( v11 <= 0 )\n    {\n      syslog(5, \"%c %s %s:%s\", 45, v16, v17, v5);\n      sub_80A98F4();\n      sub_804D5E0(\"incorrect password\");\n    }\n  }\n  syslog(5, \"%c %s %s:%s\", 43, v16, v10, v5);\n  if ( !v18 && (v15 & 3) != 0 )\n    v18 = getenv(\"SHELL\");\n  if ( v18 && v2 )\n  {\n    v12 = *(const char **)(v9 + 24);\n    for ( i = v12 == 0; ; i = strcmp(v14, v12) == 0 )\n    {\n      if ( i )\n        goto LABEL_25;\n      v14 = getusershell();\n      if ( !v14 )\n        break;\n    }\n    sub_804D5F4(\"using restricted shell\");\n    v18 = 0;\n  }\nLABEL_25:\n  if ( !v18 )\n    v18 = *(char **)(v9 + 24);\n  sub_80A9B93();\n  sub_80B2CE1(v9, ((v15 & 4) == 0 ? 0x10 : 0) + ((v15 & 3) == 0) + 2 * ((unsigned __int8)(v15 & 4) >> 2));\n  if ( v19 )\n  {\n    *(v3 - 1) = v19;\n    *(v3 - 2) = \"-c\";\n    v3 -= 2;\n  }\n  sub_80B2B50(v3, v15 & 4, v15, v16);\n}\n"
    ],
    "sub_80504E3": [
        "0x80504e3",
        "int __cdecl sub_80504E3(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // eax\n  int v4; // eax\n  int v6[2]; // [esp+4h] [ebp-8h] BYREF\n\n  v6[0] = 0;\n  byte_80DB561 = 3;\n  openlog(ident, 0, 32);\n  sub_80ABEAC(a2, \"t:+\", v6);\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( *v2 )\n  {\n    close(0);\n    close(1);\n    v3 = sub_804DBE1(*v2);\n    dup(v3);\n    close(2);\n    dup(0);\n  }\n  if ( !getpwuid(0) )\n    sub_804D5E0(\"no password entry for root\");\n  while ( 1 )\n  {\n    v4 = sub_80AA319(\"Give root password for system maintenance\\n(or type Control-D for normal startup):\", v6[0]);\n    if ( v4 < 0 )\n      break;\n    if ( v4 )\n    {\n      sub_804D5F4(\"starting shell for system maintenance\");\n      if ( !getenv(\"SUSHELL\") )\n        getenv(\"sushell\");\n      sub_80B2B50(0, 1, v6[0], v6[1]);\n    }\n    sub_80A98F4();\n    sub_804D5F4(\"Login incorrect\");\n  }\n  sub_804D5F4(\"normal startup\");\n  return 0;\n}\n"
    ],
    "sub_80505E4": [
        "0x80505e4",
        "int sub_80505E4()\n{\n  return ioctl(0, 0x5605u, 2);\n}\n"
    ],
    "sub_80505F6": [
        "0x80505f6",
        "int sub_80505F6()\n{\n  return ioctl(0, 0x5605u, dword_80DBB9C == 0);\n}\n"
    ],
    "sub_8050613": [
        "0x8050613",
        "void __cdecl __noreturn sub_8050613(int a1, int a2)\n{\n  const char **v2; // ebp\n  int v3; // eax\n  const char *v4; // eax\n  __int64 v5; // [esp+0h] [ebp-98h] BYREF\n  __int64 v6; // [esp+8h] [ebp-90h] BYREF\n  struct termios v7; // [esp+10h] [ebp-88h] BYREF\n  struct termios termios_p; // [esp+4Ch] [ebp-4Ch] BYREF\n\n  getuid();\n  v2 = (const char **)sub_80A99D2();\n  sub_80ABEAC(a2, \"^a\");\n  sub_804E6C8(7471118, (void (*)(int))1);\n  sub_804E782(10, (int)sub_80505F6);\n  sub_804E782(12, (int)sub_80505E4);\n  sub_804E734(10);\n  sub_804E734(12);\n  v3 = sub_804DBE1(\"/dev/tty\");\n  sub_804DC97(v3, 0);\n  sub_804DC7B(0, 1);\n  sub_804E0BE(0, 0x5601u, (int)&v5, \"VT_GETMODE\");\n  v6 = v5;\n  LOBYTE(v5) = 1;\n  *(_DWORD *)((char *)&v5 + 2) = 786442;\n  ioctl(0, 0x5602u, &v5);\n  tcgetattr(0, &termios_p);\n  qmemcpy(&v7, &termios_p, sizeof(v7));\n  v7.c_iflag = v7.c_iflag & 0xFFFFFFFC | 1;\n  v7.c_lflag &= 0xFFFFFDF6;\n  sub_804D995(&v7);\n  while ( 1 )\n  {\n    v4 = \"\";\n    if ( dword_80DBB9C )\n      v4 = \"s\";\n    printf(\"Virtual console%s locked by %s.\\n\", v4, *v2);\n    if ( sub_80AA371() > 0 )\n    {\n      ioctl(0, 0x5602u, &v6);\n      sub_804D995(&termios_p);\n      sub_80AB247();\n    }\n    sub_80A98F4();\n    puts(\"Incorrect password\");\n  }\n}\n"
    ],
    "sub_805077F": [
        "0x805077f",
        "char *__usercall sub_805077F@<eax>(char *result@<eax>, char *a2@<edx>, va_list a3@<ecx>)\n{\n  if ( qword_80DB778 <= (unsigned int)result )\n  {\n    byte_80DB562 = 6;\n    result = sub_804D40A(a2, a3, 0);\n    byte_80DB562 = 3;\n  }\n  return result;\n}\n"
    ],
    "sub_80507A6": [
        "0x80507a6",
        "char *sub_80507A6(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_805077F((char *)8, a1, va);\n}\n"
    ],
    "sub_80507B9": [
        "0x80507b9",
        "char *sub_80507B9(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_805077F((char *)4, a1, va);\n}\n"
    ],
    "sub_80507CC": [
        "0x80507cc",
        "int sub_80507CC()\n{\n  int result; // eax\n\n  result = unk_80DB780;\n  if ( unk_80DB780 )\n  {\n    result = sub_804DC14((const char *)unk_80DB780);\n    if ( result >= 0 )\n      return sub_804DC97(result, 2);\n  }\n  return result;\n}\n"
    ],
    "sub_80507EE": [
        "0x80507ee",
        "int **__usercall sub_80507EE@<eax>(const char *a1@<eax>, int **a2@<ebx>)\n{\n  char **v3; // edi\n  char *v4; // ebx\n  int **v5; // eax\n  int *v6; // esi\n\n  v3 = &MEMORY[0x80DB788];\n  while ( 1 )\n  {\n    v4 = *v3;\n    if ( !*v3 )\n      return a2;\n    if ( strcmp(a1, *((const char **)v4 + 2)) )\n      goto LABEL_11;\n    v5 = (int **)(v4 + 4);\n    *(_WORD *)(v4 + 13) = 256;\n    while ( 1 )\n    {\n      v6 = *v5;\n      if ( !*v5 )\n        break;\n      if ( v6[2] <= 0 )\n      {\n        *v5 = (int *)*v6;\n        a2 = v5;\n        free((void *)v6[1]);\n        free(v6);\n        v5 = a2;\n      }\n      else\n      {\n        v4[13] = 1;\n        v5 = (int **)v6;\n      }\n    }\n    if ( v4[13] )\n    {\nLABEL_11:\n      v3 = (char **)v4;\n    }\n    else\n    {\n      *v3 = *(char **)v4;\n      free(*((void **)v4 + 2));\n      free(v4);\n    }\n  }\n}\n"
    ],
    "sub_805086E": [
        "0x805086e",
        "unsigned __int8 __usercall sub_805086E@<al>(\n        const char *a1@<eax>,\n        unsigned __int8 *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        char *s2,\n        char *nptr)\n{\n  char *v6; // ebp\n  int v7; // edi\n  int v8; // ebx\n  int v9; // esi\n  char *v10; // ecx\n  char *v11; // esi\n  int v12; // eax\n  unsigned __int8 result; // al\n  int v14; // ebp\n  int v15; // eax\n  int v16; // ebx\n  int v17; // edi\n  int v18; // edx\n  unsigned __int8 *v19; // ebx\n  int v20; // edx\n  int v23; // [esp+8h] [ebp-1Ch]\n  char *endptr[5]; // [esp+10h] [ebp-14h] BYREF\n\n  v6 = nptr;\n  v7 = -1;\n  v8 = -1;\n  while ( 1 )\n  {\n    if ( *v6 == 42 )\n    {\n      v9 = a3 - 1;\n      v10 = v6 + 1;\n      v8 = 0;\n      goto LABEL_17;\n    }\n    if ( (unsigned __int8)(*v6 - 48) > 9u )\n      break;\n    if ( v8 >= 0 )\n      v7 = a4 + strtol(v6, endptr, 10);\n    else\n      v8 = a4 + strtol(v6, endptr, 10);\n    v10 = endptr[0];\nLABEL_16:\n    v9 = v7;\nLABEL_17:\n    if ( *v10 != 45 )\n    {\n      if ( v9 < 0 )\n        v9 = v8;\n      v14 = 1;\n      if ( *v10 == 47 )\n      {\n        v14 = strtol(v10 + 1, endptr, 10);\n        v10 = endptr[0];\n      }\nLABEL_25:\n      v15 = v8 - 1;\n      v16 = 1024;\n      v17 = 1;\n      while ( 1 )\n      {\n        v18 = (v15 + 1) % a3;\n        v15 = v18;\n        if ( !--v17 )\n        {\n          a2[v18] = 1;\n          v17 = v14;\n        }\n        if ( !--v16 )\n          return (unsigned __int8)sub_804D5F4(\"user %s: parse error at %s\", a1, nptr);\n        if ( v9 == v18 )\n        {\n          result = *v10;\n          if ( *v10 == 44 )\n          {\n            v6 = v10 + 1;\n            v9 = -1;\n            v8 = -1;\n            goto LABEL_19;\n          }\n          if ( !result )\n          {\n            if ( (unsigned int)qword_80DB778 <= 5 && byte_80DB561 != 2 )\n            {\n              v19 = a2;\n              do\n                fprintf(stderr, \"%d\", *v19++);\n              while ( &a2[a3] != v19 );\n              return sub_804D830(10, v20);\n            }\n            return result;\n          }\n          return (unsigned __int8)sub_804D5F4(\"user %s: parse error at %s\", a1, nptr);\n        }\n      }\n    }\n    v6 = v10 + 1;\n    if ( v9 >= 0 )\n    {\n      v14 = 1;\n      goto LABEL_25;\n    }\nLABEL_19:\n    v7 = v9;\n  }\n  if ( s2 )\n  {\n    v11 = s2;\n    while ( 1 )\n    {\n      v23 = v11 - s2;\n      if ( !*v11 )\n        break;\n      v12 = strncasecmp(v6, v11, 3u);\n      v11 += 3;\n      if ( !v12 )\n      {\n        v10 = v6 + 3;\n        v9 = v23 / 3;\n        if ( v8 >= 0 )\n          goto LABEL_17;\n        v8 = v23 / 3;\n        goto LABEL_16;\n      }\n    }\n  }\n  return (unsigned __int8)sub_804D5F4(\"user %s: parse error at %s\", a1, nptr);\n}\n"
    ],
    "sub_8050A0A": [
        "0x8050a0a",
        "int __usercall sub_8050A0A@<eax>(char **a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  char *v6; // eax\n  char *v7; // eax\n\n  v6 = *a1;\n  if ( v6 )\n    sub_804DE4D(v6);\n  v7 = sub_804DDBF(\"%s=%s\", a2, a3);\n  *a1 = v7;\n  return putenv(v7);\n}\n"
    ],
    "sub_8050A39": [
        "0x8050a39",
        "__pid_t __usercall sub_8050A39@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>)\n{\n  __pid_t result; // eax\n  char *path; // [esp+0h] [ebp-10h]\n  struct passwd *v4; // [esp+4h] [ebp-Ch]\n\n  v4 = getpwnam(a1);\n  if ( !v4 )\n  {\n    sub_804D5F4(\"can't get uid for %s\", a1);\nLABEL_3:\n    result = 0;\n    goto LABEL_12;\n  }\n  path = (char *)a2[3];\n  if ( !path )\n    path = unk_80DB78C;\n  sub_8050A0A((char **)&stream, \"LOGNAME\", v4->pw_name);\n  sub_8050A0A((char **)&unk_80DB790, \"USER\", v4->pw_name);\n  sub_8050A0A((char **)&unk_80DB794, \"HOME\", v4->pw_dir);\n  sub_8050A0A(&dword_80DB798, \"SHELL\", path);\n  result = vfork();\n  if ( !result )\n  {\n    sub_80A9B93();\n    if ( chdir(v4->pw_dir) < 0 )\n    {\n      sub_804D5F4(\"can't change directory to '%s'\", v4->pw_dir);\n      sub_804DF04(\"/var/spool/cron\");\n    }\n    sub_80507B9(\"child running %s\", path);\n    setpgrp();\n    execl(path, path, \"-c\", a2[1], 0);\n    sub_804D5E0(\"can't execute '%s' for user %s\", path, a1);\n  }\n  if ( result < 0 )\n  {\n    sub_804D3A5((int)&unk_80C7DA0);\n    goto LABEL_3;\n  }\nLABEL_12:\n  a2[2] = result;\n  return result;\n}\n"
    ],
    "sub_8050B75": [
        "0x8050b75",
        "char *__usercall sub_8050B75@<eax>(char *result@<eax>)\n{\n  char *v1; // ebp\n  char *i; // ebx\n  int **j; // esi\n  __pid_t v4; // edi\n\n  v1 = result;\n  for ( i = MEMORY[0x80DB788]; i; i = *(char **)i )\n  {\n    if ( i[12] )\n    {\n      i[12] = 0;\n      for ( j = (int **)*((_DWORD *)i + 1); j; j = (int **)*j )\n      {\n        if ( j[2] == (int *)v1 )\n        {\n          v4 = sub_8050A39(*((const char **)i + 2), j);\n          result = sub_80507A6(\"USER %s pid %3d cmd %s\", *((const char **)i + 2), v4, (const char *)j[1]);\n          if ( v4 >= 0 )\n          {\n            if ( v4 )\n              i[13] = 1;\n          }\n          else\n          {\n            i[12] = 1;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8050BD8": [
        "0x8050bd8",
        "char *sub_8050BD8(int a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_805077F((char *)7, \"ignoring file '%s' (no such user)\", va);\n}\n"
    ],
    "sub_8050BEC": [
        "0x8050bec",
        "char *__usercall sub_8050BEC@<eax>(const char *a1@<eax>, int **a2@<ebx>)\n{\n  char *result; // eax\n  char *v4; // esi\n  _DWORD *v5; // edi\n  int v6; // ebx\n  char **i; // ebx\n  int v8; // edx\n  int v9; // ecx\n  unsigned __int8 *v10; // eax\n  unsigned __int8 *v11; // ebx\n  int v12; // eax\n  int v13; // edx\n  int v14; // eax\n  int v15; // eax\n  int v16; // [esp-4h] [ebp-A0h]\n  int v17; // [esp+0h] [ebp-9Ch]\n  int v18; // [esp+0h] [ebp-9Ch]\n  char *v19; // [esp+4h] [ebp-98h]\n  char *v20; // [esp+8h] [ebp-94h]\n  char *ptr; // [esp+Ch] [ebp-90h]\n  char *s2; // [esp+14h] [ebp-88h]\n  char *nptr; // [esp+18h] [ebp-84h]\n  char *v24; // [esp+1Ch] [ebp-80h]\n  char *v25; // [esp+20h] [ebp-7Ch]\n  char *v26; // [esp+24h] [ebp-78h]\n  char *v27; // [esp+28h] [ebp-74h]\n  int v28; // [esp+44h] [ebp-58h]\n\n  sub_80507EE(a1, a2);\n  if ( !getpwnam(a1) )\n    return sub_8050BD8((int)\"ignoring file '%s' (no such user)\", a1);\n  result = (char *)sub_80B052C();\n  v19 = result;\n  if ( result )\n  {\n    ptr = (char *)(strcmp(a1, \"root\") == 0 ? 0xFFFF : 256);\n    fileno_unlocked(*(FILE **)v19);\n    v20 = 0;\n    if ( fstat64() || v28 )\n      goto LABEL_40;\n    v4 = (char *)sub_804DB2E(0x10u);\n    *((_DWORD *)v4 + 2) = sub_804DB46(a1);\n    v5 = v4 + 4;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          do\n          {\nLABEL_7:\n            if ( !--ptr )\n            {\n              sub_804D5F4(\"user %s: too many lines\", a1);\nLABEL_39:\n              *v5 = 0;\n              *(_DWORD *)v4 = MEMORY[0x80DB788];\n              MEMORY[0x80DB788] = v4;\nLABEL_40:\n              sub_80B0536();\n              free(v20);\n              return (char *)v18;\n            }\n            v6 = sub_80B0560(\"# \\t\");\n            if ( !v6 )\n              goto LABEL_39;\n            sub_80507B9(\"user:%s entry:%s\", a1, *((const char **)v19 + 1));\n          }\n          while ( sub_804D210(s2, \"MAILTO=\") );\n          if ( !sub_804D210(s2, \"SHELL=\") )\n            break;\n          free(v20);\n          v20 = sub_804DB46(s2 + 6);\n        }\n        if ( *s2 == 64 )\n          break;\n        if ( v6 > 5 )\n          goto LABEL_22;\n      }\n      if ( v6 > 1 )\n      {\n        for ( i = &off_80B5360; strcmp(*i, s2 + 1); i += 3 )\n        {\n          if ( !*((_BYTE *)i + 4) )\n            goto LABEL_7;\n        }\n        sub_80B2E8C(v17, v16);\n        sub_80B2E9F();\n        v27 = (char *)sub_80B2E8C(v9, v8);\n        if ( *((_BYTE *)i + 4) )\n        {\n          s2 = \"0\";\n          nptr = (char *)(i + 1);\n          v24 = (char *)i + 6;\n          v25 = (char *)(i + 2);\n          v26 = (char *)i + 10;\n        }\nLABEL_22:\n        v10 = (unsigned __int8 *)sub_804DB2E(0x98u);\n        v11 = v10;\n        *v5 = v10;\n        if ( *s2 == 64 )\n        {\n          v4[12] = 1;\n          *((_DWORD *)v10 + 2) = -2;\n        }\n        else\n        {\n          sub_805086E(*((const char **)v4 + 2), v10 + 91, 60, 0, 0, s2);\n          sub_805086E(*((const char **)v4 + 2), v11 + 35, 24, 0, 0, nptr);\n          sub_805086E(*((const char **)v4 + 2), v11 + 59, 32, 0, 0, v24);\n          sub_805086E(*((const char **)v4 + 2), v11 + 23, 12, -1, \"janfebmaraprmayjunjulaugsepoctnovdec\", v25);\n          sub_805086E(*((const char **)v4 + 2), v11 + 16, 7, 0, \"sunmontuewedthufrisat\", v26);\n          v12 = 0;\n          while ( v11[v12 + 16] )\n          {\n            if ( ++v12 == 7 )\n            {\n              v13 = 0;\n              goto LABEL_29;\n            }\n          }\n          v13 = 1;\nLABEL_29:\n          v14 = 0;\n          while ( v11[v14 + 59] )\n          {\n            if ( ++v14 == 32 )\n            {\n              v15 = 0;\n              goto LABEL_34;\n            }\n          }\n          v15 = 1;\nLABEL_34:\n          if ( v13 != v15 )\n          {\n            if ( v13 )\n              memset(v11 + 59, 0, 0x20u);\n            else\n              memset(v11 + 16, 0, 7u);\n          }\n        }\n        *((_DWORD *)v11 + 3) = sub_804DB46(v20);\n        *((_DWORD *)v11 + 1) = sub_804DB46(v27);\n        v5 = v11;\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8050F08": [
        "0x8050f08",
        "int __usercall sub_8050F08@<eax>(int **a1@<ebx>)\n{\n  char *i; // eax\n  DIR *v2; // esi\n  char *v3; // ebx\n  int v4; // eax\n  int v6; // [esp-4h] [ebp-Ch]\n\nLABEL_1:\n  for ( i = MEMORY[0x80DB788]; i; i = *(char **)i )\n  {\n    if ( !i[14] )\n    {\n      sub_80507EE(*((const char **)i + 2), a1);\n      goto LABEL_1;\n    }\n  }\n  unlink(\"cron.update\");\n  sub_804DF04((const char *)*(&unk_80DB780 + 1));\n  v2 = opendir(\".\");\n  if ( !v2 )\n    sub_804D5E0(\"can't open '%s'\", (const char *)*(&unk_80DB780 + 1));\n  while ( 1 )\n  {\n    v4 = readdir64();\n    if ( !v4 )\n      break;\n    v3 = (char *)(v4 + 19);\n    if ( !strchr((const char *)(v4 + 19), 46) )\n      sub_8050BEC(v3, (int **)v3);\n  }\n  closedir(v2);\n  return v6;\n}\n"
    ],
    "sub_8050F8A": [
        "0x8050f8a",
        "void __usercall __noreturn sub_8050F8A(int **a1@<ebx>, int a2, int a3)\n{\n  const char *v3; // eax\n  int v4; // eax\n  unsigned int v5; // ebx\n  int v6; // edi\n  unsigned int v7; // eax\n  int v8; // esi\n  FILE *v9; // ebp\n  struct tm *v10; // ebp\n  char *i; // esi\n  int *j; // ebx\n  char *v13; // ebx\n  int v14; // ebp\n  _DWORD *k; // esi\n  __pid_t v16; // eax\n  __pid_t v17; // eax\n  time_t v18; // [esp+0h] [ebp-178h]\n  time_t v19; // [esp+4h] [ebp-174h]\n  size_t v20; // [esp+50h] [ebp-128h]\n  time_t timer[68]; // [esp+68h] [ebp-110h] BYREF\n\n  qword_80DB778 = 8;\n  *(&unk_80DB780 + 1) = (time_t)\"/var/spool/cron/crontabs\";\n  if ( (sub_80ABEAC(a3, \"^l:L:fbSc:\", &qword_80DB778, &unk_80DB780, 135116676) & 4) == 0 )\n    sub_80B3C0D();\n  if ( !unk_80DB780 )\n  {\n    openlog(ident, 3, 72);\n    byte_80DB561 = 2;\n  }\n  sub_80507CC();\n  sub_804DF04((const char *)*(&unk_80DB780 + 1));\n  v3 = (const char *)sub_80AB879();\n  unk_80DB78C = sub_804DB46(v3);\n  sub_80507A6(\"crond (busybox 1.29.2) started, log level %d\", qword_80DB778);\n  sub_8050F08(a1);\n  v4 = open64();\n  if ( v4 >= 0 )\n  {\n    close(v4);\n    sub_8050B75((char *)0xFFFFFFFE);\n  }\n  v18 = time(0);\n  v5 = 60;\n  v6 = 60;\n  while ( 1 )\n  {\n    v7 = time(0);\n    sleep(v5 - v7 % v5);\n    v19 = time(0);\n    v8 = v19 - v18;\n    sub_80507CC();\n    if ( stat64() )\n      v20 = 0;\n    if ( MEMORY[0x80DB77C] != v20 )\n    {\n      MEMORY[0x80DB77C] = v20;\n      v6 = 1;\n    }\n    if ( !--v6 )\n    {\n      sub_8050F08((int **)v5);\n      v6 = 60;\n    }\n    v9 = (FILE *)sub_80B3D37();\n    if ( v9 )\n    {\n      unlink(\"cron.update\");\n      while ( fgets_unlocked() )\n      {\n        *(_BYTE *)sub_80B2E9F() = 0;\n        sub_8050BEC((const char *)timer, (int **)v5);\n      }\n      fclose(v9);\n    }\n    sub_80507B9(\"wakeup dt=%ld\", v8);\n    if ( (unsigned int)(v8 + 3600) <= 0x1C20 )\n    {\n      if ( v8 > 0 )\n      {\n        for ( timer[0] = v18 - v18 % 60; v19 >= timer[0]; timer[0] += 60 )\n        {\n          if ( v18 < timer[0] )\n          {\n            v10 = localtime(timer);\n            for ( i = MEMORY[0x80DB788]; i; i = *(char **)i )\n            {\n              sub_80507B9(\"file %s:\", *((const char **)i + 2));\n              if ( !i[14] )\n              {\n                for ( j = (int *)*((_DWORD *)i + 1); j; j = (int *)*j )\n                {\n                  sub_80507B9(\" line %s\", (const char *)j[1]);\n                  if ( *((_BYTE *)j + v10->tm_min + 91)\n                    && *((_BYTE *)j + v10->tm_hour + 35)\n                    && (*((_BYTE *)j + v10->tm_mday + 59) || *((_BYTE *)j + v10->tm_wday + 16)) )\n                  {\n                    if ( *((_BYTE *)j + v10->tm_mon + 23) )\n                    {\n                      sub_80507B9(\" job: %d %s\", j[2], (const char *)j[1]);\n                      if ( j[2] <= 0 )\n                      {\n                        if ( !j[2] )\n                        {\n                          j[2] = -1;\n                          i[12] = 1;\n                        }\n                      }\n                      else\n                      {\n                        sub_80507A6(\"user %s: process already running: %s\", *((const char **)i + 2), (const char *)j[1]);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        sub_8050B75((char *)0xFFFFFFFF);\n        v13 = MEMORY[0x80DB788];\n        v14 = 0;\n        while ( v13 )\n        {\n          if ( v13[13] )\n          {\n            v13[13] = 0;\n            for ( k = (_DWORD *)*((_DWORD *)v13 + 1); k; k = (_DWORD *)*k )\n            {\n              v16 = k[2];\n              if ( v16 > 0 )\n              {\n                v17 = waitpid(v16, 0, 1);\n                if ( v17 < 0 || v17 == k[2] )\n                  k[2] = 0;\n                else\n                  v13[13] = 1;\n              }\n            }\n            v14 += v13[13];\n          }\n          v13 = *(char **)v13;\n        }\n        v5 = v14 <= 0 ? 60 : 10;\n      }\n    }\n    else\n    {\n      sub_804D5F4(\"time disparity of %ld minutes detected\", v8 / 60);\n    }\n    v18 = v19;\n  }\n}\n"
    ],
    "sub_80512C7": [
        "0x80512c7",
        "int __usercall sub_80512C7@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // eax\n  int v3; // ecx\n  char *v5; // ebx\n\n  v2 = vfork();\n  if ( v2 < 0 )\n    sub_804D3C9((int)&unk_80C7DA0);\n  if ( !v2 )\n  {\n    sub_80A9B93();\n    sub_80B2CE1(a1, 5);\n    v5 = getenv(\"VISUAL\");\n    if ( !v5 )\n    {\n      v5 = getenv(\"EDITOR\");\n      if ( !v5 )\n        v5 = \"vi\";\n    }\n    execlp(v5, v5, a2, 0);\n    sub_804D3C9((int)\"can't execute '%s'\", v5);\n  }\n  return sub_804DA6B(v2, v3);\n}\n"
    ],
    "sub_805134B": [
        "0x805134b",
        "int __cdecl sub_805134B(int a1, int a2)\n{\n  char v2; // di\n  int *v3; // esi\n  int v4; // eax\n  const char **v5; // ebx\n  int v6; // edi\n  int v7; // eax\n  int v8; // esi\n  __pid_t v9; // eax\n  char *v10; // edi\n  int v11; // eax\n  int v12; // ebp\n  char *v13; // ebp\n  int v14; // eax\n  int v15; // esi\n  int v17; // [esp+0h] [ebp-80h]\n  int fd; // [esp+4h] [ebp-7Ch]\n  char v19[4]; // [esp+8h] [ebp-78h] BYREF\n  int v20[29]; // [esp+Ch] [ebp-74h] BYREF\n\n  *(_DWORD *)v19 = \"/var/spool/cron/crontabs\";\n  v2 = sub_80ABEAC(a2, \"^u:c:lerd\", v20, v19);\n  v3 = (int *)(a2 + 4 * optind);\n  if ( sub_80AFD54() && (v2 & 3) != 0 )\n    sub_804D5E0(\"you must be root\");\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = sub_80A999C();\n  }\n  else\n  {\n    getuid();\n    v4 = sub_80A99D2();\n  }\n  v5 = (const char **)v4;\n  v6 = v2 & 0x1C;\n  v17 = v6 & (v6 - 1);\n  if ( v17 )\nLABEL_8:\n    sub_804CDC2(v17);\n  if ( v6 )\n  {\n    v8 = 0;\n  }\n  else\n  {\n    v7 = *v3;\n    if ( !*v3 )\n      goto LABEL_8;\n    if ( *(_BYTE *)v7 != 45 || (v8 = 0, *(_BYTE *)(v7 + 1)) )\n      v8 = sub_804DEB6((const char *)v7, (__uid_t)v5[2], (__gid_t)v5[3]);\n  }\n  sub_804DF04(*(const char **)v19);\n  if ( v6 == 4 )\n  {\n    v20[1] = (int)*v5;\n    v20[2] = 0;\n    return sub_80A98A4();\n  }\n  else\n  {\n    if ( v6 == 8 )\n    {\n      v9 = getpid();\n      v10 = sub_804DDBF(\"%s.%u\", *(const char **)v19, v9);\n      v8 = sub_804DBC2(v10);\n      fchown(v8, (__uid_t)v5[2], (__gid_t)v5[3]);\n      v11 = open64();\n      v12 = v11;\n      if ( v11 >= 0 )\n      {\n        sub_804E572(v11, v8);\n        close(v12);\n        sub_804DD09(0, 0, 0);\n      }\n      sub_804D670();\n      sub_80512C7((int)v5, (int)v10);\n    }\n    else\n    {\n      if ( v6 )\n      {\n        unlink(*v5);\n        goto LABEL_29;\n      }\n      v10 = 0;\n    }\n    v13 = sub_804DDBF(\"%s.new\", *v5);\n    v14 = open64();\n    if ( v14 < 0 )\n    {\n      sub_804D5F4(\"can't create %s/%s\", *(const char **)v19, v13);\n    }\n    else\n    {\n      fd = v14;\n      sub_804E572(v8, v14);\n      close(fd);\n      sub_804DC43(v13, *v5);\n    }\n    if ( v10 )\n      unlink(v10);\nLABEL_29:\n    while ( 1 )\n    {\n      v15 = open64();\n      if ( v15 < 0 )\n        break;\n      dprintf();\n      if ( fstat64() || v20[6] )\n        return v17;\n      close(v15);\n    }\n    sub_804D5F4(\"can't append to %s/%s\", *(const char **)v19, \"cron.update\");\n  }\n  return v17;\n}\n"
    ],
    "sub_805157F": [
        "0x805157f",
        "long double __usercall sub_805157F@<st0>(int a1@<ebp>, int a2@<edi>, char a3)\n{\n  void *retaddr; // [esp+0h] [ebp+0h]\n\n  if ( !qword_80DB778 )\n    sub_804D5E0(\"stack underflow\", qword_80DB778, &a3, a1, retaddr, a2);\n  --qword_80DB778;\n  return *((double *)&unk_80DB780 + qword_80DB778);\n}\n"
    ],
    "sub_80515B0": [
        "0x80515b0",
        "int __cdecl sub_80515B0(int a1, double a2)\n{\n  int result; // eax\n\n  result = qword_80DB778;\n  if ( (unsigned int)qword_80DB778 > 0x7E )\n    sub_804D5E0(\"stack overflow\");\n  ++qword_80DB778;\n  *((double *)&unk_80DB780 + result) = a2;\n  return result;\n}\n"
    ],
    "sub_8051B40": [
        "0x8051b40",
        "_BYTE *__usercall sub_8051B40@<eax>(const char *a1@<eax>)\n{\n  int v1; // edx\n  int v2; // ecx\n  long double v3; // fst7\n  char *v4; // esi\n  _BYTE *result; // eax\n  _BYTE *v6; // edi\n  void (**v7)(void); // ebx\n  long double v8; // [esp+0h] [ebp-20h]\n  char *v9; // [esp+Ch] [ebp-14h] BYREF\n\n  while ( 1 )\n  {\n    HIDWORD(v8) = a1;\n    v3 = strtod(a1, &v9);\n    v4 = v9;\n    if ( v9 != (char *)HIDWORD(v8) )\n    {\n      *(double *)&v8 = v3;\n      sub_80515B0(COERCE_UNSIGNED_INT64(v3), *(double *)((char *)&v8 + 4));\n      goto LABEL_3;\n    }\n    result = (_BYTE *)sub_80B2E8C(v2, v1);\n    v6 = result;\n    if ( !*result )\n      return result;\n    v7 = (void (**)(void))&unk_80B53C0;\n    while ( 1 )\n    {\n      v4 = sub_804D210(v6, v7);\n      if ( v4 )\n        break;\n      v7 += 2;\n      if ( v7 == (void (**)(void))&unk_80B5450 )\n        sub_804D5E0(\"syntax error at '%s'\", v6);\n    }\n    v7[1]();\nLABEL_3:\n    a1 = v4;\n  }\n}\n"
    ],
    "sub_8051C33": [
        "0x8051c33",
        "int __cdecl sub_8051C33(int a1, double a2)\n{\n  long double v2; // fst6\n  unsigned int v3; // edi\n  unsigned int v4; // esi\n  unsigned __int64 v6; // rax\n  int v7; // [esp+8h] [ebp-30h]\n  unsigned __int64 v8; // [esp+Ch] [ebp-2Ch]\n\n  v2 = a2;\n  if ( a2 >= 9.223372e18 )\n  {\n    v4 = (__int64)(v2 - 9.223372e18);\n    v3 = ((unsigned __int64)(__int64)(v2 - 9.223372e18) >> 32) + 0x80000000;\n  }\n  else\n  {\n    v3 = (unsigned __int64)(__int64)v2 >> 32;\n    v4 = (__int64)v2;\n  }\n  switch ( MEMORY[0x80DB77C] )\n  {\n    case 0xAu:\n      if ( (double)__PAIR64__(v3, v4) == a2 )\n        return printf(\"%llu\\n\", __PAIR64__(v3, v4));\n      else\n        return printf(\"%g\\n\", a2);\n    case 8u:\n      return printf(\"%llo\\n\", __PAIR64__(v3, v4));\n    case 0x10u:\n      return printf(\"%llx\\n\", __PAIR64__(v3, v4));\n    default:\n      v7 = 63;\n      v6 = 0x8000000000000000LL;\n      while ( 1 )\n      {\n        v8 = v6 >> 1;\n        if ( v4 & (unsigned int)v6 | v3 & HIDWORD(v6) )\n          break;\n        v6 >>= 1;\n        if ( !--v7 )\n          goto LABEL_17;\n      }\n      v8 = v6;\n      do\n      {\nLABEL_17:\n        sub_804DD98(49 - ((v4 & (unsigned int)v8 | v3 & HIDWORD(v8)) == 0));\n        v8 >>= 1;\n      }\n      while ( v8 );\n      return sub_804DD98(10);\n  }\n}\n"
    ],
    "sub_8051E16": [
        "0x8051e16",
        "int __cdecl sub_8051E16(int a1, int a2)\n{\n  const char **v2; // ebx\n  const char *v3; // eax\n  char *v4; // ebx\n\n  MEMORY[0x80DB77C] = 10;\n  v2 = (const char **)(a2 + 4);\n  if ( *(_DWORD *)(a2 + 4) )\n  {\n    do\n      sub_8051B40(*v2++);\n    while ( *v2 );\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v3 = (const char *)sub_80AB85A();\n      v4 = (char *)v3;\n      if ( !v3 )\n        break;\n      sub_8051B40(v3);\n      free(v4);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8051E61": [
        "0x8051e61",
        "int __cdecl sub_8051E61(int a1, _DWORD *a2)\n{\n  _DWORD *v2; // esi\n  const char *v3; // eax\n  _DWORD *v4; // edi\n  _BYTE *v5; // eax\n  unsigned int v6; // ebx\n  const char *v7; // eax\n  int v8; // eax\n  _WORD *v9; // edi\n  __int64 v10; // rax\n  __int64 v12; // [esp+0h] [ebp-28h]\n  int v13; // [esp+8h] [ebp-20h]\n  int v14; // [esp+Ch] [ebp-1Ch]\n\n  v2 = a2;\n  v3 = (const char *)a2[1];\n  if ( !v3 )\n    goto LABEL_2;\n  v4 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v14 = sub_804EC9E(v3, 0, 0);\n  v5 = (_BYTE *)a2[2];\n  if ( v5 )\n  {\n    if ( (unsigned __int8)(*v5 - 48) <= 9u || v5[1] )\n      v6 = sub_80B40EC();\n    else\n      v6 = (unsigned __int8)byte_80C8834[strchrnul() - (_DWORD)\"bhwl\"];\n    v7 = (const char *)a2[3];\n    if ( v7 )\n      v12 = sub_804EC9E(v7, 0, 0);\n  }\n  else\n  {\n    v2 = a2 - 1;\n    v6 = 32;\n  }\n  if ( *v4 )\nLABEL_2:\n    sub_804CDC2(v12);\n  sub_804DBE1(\"/dev/mem\");\n  v13 = (getpagesize() - 1) & v14;\n  v8 = mmap64();\n  if ( v8 == -1 )\n    sub_804D3C9((int)\"mmap\");\n  v9 = (_WORD *)(v8 + v13);\n  if ( v2[3] )\n  {\n    if ( v6 == 16 )\n    {\n      *v9 = v12;\n      return 0;\n    }\n    if ( v6 > 0x10 )\n    {\n      if ( v6 == 32 )\n      {\n        *(_DWORD *)v9 = v12;\n        return 0;\n      }\n      if ( v6 == 64 )\n      {\n        *(_QWORD *)v9 = v12;\n        return 0;\n      }\n    }\n    else if ( v6 == 8 )\n    {\n      *(_BYTE *)v9 = v12;\n      return 0;\n    }\n    goto LABEL_25;\n  }\n  if ( v6 == 16 )\n  {\n    LODWORD(v10) = (unsigned __int16)*v9;\n    goto LABEL_24;\n  }\n  if ( v6 <= 0x10 )\n  {\n    if ( v6 == 8 )\n    {\n      LODWORD(v10) = *(unsigned __int8 *)v9;\nLABEL_24:\n      HIDWORD(v10) = 0;\n      goto LABEL_26;\n    }\nLABEL_25:\n    sub_804D5E0(\"bad width\");\n  }\n  if ( v6 == 32 )\n  {\n    LODWORD(v10) = *(_DWORD *)v9;\n    goto LABEL_24;\n  }\n  if ( v6 != 64 )\n    goto LABEL_25;\n  v10 = *(_QWORD *)v9;\nLABEL_26:\n  printf(\"0x%0*llX\\n\", v6 >> 2, v10);\n  return 0;\n}\n"
    ],
    "sub_805200B": [
        "0x805200b",
        "int __usercall sub_805200B@<eax>(_DWORD *a1@<eax>)\n{\n  if ( !optarg )\n    return 1;\n  *a1 = sub_80B4160();\n  return 2;\n}\n"
    ],
    "sub_805202C": [
        "0x805202c",
        "int __usercall sub_805202C@<eax>(_DWORD *a1@<eax>)\n{\n  return sub_805200B(a1);\n}\n"
    ],
    "sub_8052038": [
        "0x8052038",
        "int __usercall sub_8052038@<eax>(_DWORD *a1@<eax>)\n{\n  return sub_805200B(a1);\n}\n"
    ],
    "sub_8052044": [
        "0x8052044",
        "int __usercall sub_8052044@<eax>(char *a1@<eax>)\n{\n  int i; // ebx\n  int result; // eax\n\n  for ( i = 0; i != 32; ++i )\n  {\n    if ( !strncmp(a1, (const char *)(5 * i + 135043390), 5u) && strlen(a1) <= 5 )\n      return (unsigned __int8)byte_80C99DE[i];\n  }\n  result = sub_804EDC5(10, a1, 0, 32);\n  if ( *(_DWORD *)dword_80DBB7C )\n    return -1;\n  return result;\n}\n"
    ],
    "sub_805209C": [
        "0x805209c",
        "int __usercall sub_805209C@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  sub_80B24F6(0x100000, a1);\n  for ( result = 0; result != 0x100000; result += 512 )\n    *(_BYTE *)(a1 + result) &= 1u;\n  return result;\n}\n"
    ],
    "sub_80520C4": [
        "0x80520c4",
        "int __usercall sub_80520C4@<eax>(int result@<eax>, int a2@<edx>, const char *a3@<ecx>, int a4)\n{\n  _WORD *v4; // edi\n  int v5; // ecx\n  int v6; // esi\n  _WORD *v7; // eax\n  char *v8; // edi\n  char *v9; // ebx\n  int v10; // eax\n\n  v4 = (_WORD *)(result + 2 * a2);\n  if ( *v4 )\n  {\n    printf(\"\\t%-20s\", a3);\n    v5 = 2 * a4;\n    v6 = 1;\n    v7 = &v4[a4];\n    while ( 1 )\n    {\n      v8 = (char *)v7 - v5;\n      if ( *((_BYTE *)v7 + v6 - v5) == 32 )\n        break;\n      v6 = -v6;\n      if ( !--v5 )\n        return sub_804DD98(10);\n    }\n    v9 = (char *)v7;\n    while ( v9 != v8 )\n    {\n      v10 = (unsigned __int8)v8[v6];\n      if ( !(_BYTE)v10 )\n        break;\n      sub_804DD98(v10);\n      ++v8;\n      v6 = -v6;\n    }\n    return sub_804DD98(10);\n  }\n  return result;\n}\n"
    ],
    "sub_8052127": [
        "0x8052127",
        "int __usercall sub_8052127@<eax>(unsigned __int16 a1@<ax>, unsigned __int16 a2@<dx>, int a3@<ecx>, _BYTE *a4)\n{\n  int v6; // ebp\n  int v7; // edi\n  int v9; // [esp+0h] [ebp-14h]\n  int v10; // [esp+0h] [ebp-14h]\n\n  v6 = 0;\n  v7 = 0;\n  do\n  {\n    if ( (a2 & 1) != 0 )\n    {\n      v9 = a3;\n      printf(\"*%cdma%u \", a3, v6);\n      a3 = v9;\n      if ( *a4 )\n        v7 = 1;\n      *a4 = 1;\n    }\n    else if ( (a1 & 1) != 0 )\n    {\n      v10 = a3;\n      printf(\"%cdma%u \", a3, v6);\n      a3 = v10;\n    }\n    a1 >>= 1;\n    a2 >>= 1;\n    ++v6;\n  }\n  while ( v6 != 8 );\n  return v7;\n}\n"
    ],
    "sub_8052198": [
        "0x8052198",
        "int __usercall sub_8052198@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  int v5; // [esp-4h] [ebp-8h]\n\n  printf(\" %s\\t= %2lu\", a1, a2);\n  v3 = \" (off)\";\n  if ( a2 )\n    v3 = \" (on)\";\n  puts(v3);\n  return v5;\n}\n"
    ],
    "sub_80521C1": [
        "0x80521c1",
        "void __usercall __noreturn sub_80521C1(int a1@<eax>)\n{\n  unsigned __int16 v2; // ax\n  unsigned __int16 v3; // si\n  const char *v4; // eax\n  const char *v5; // eax\n  __int16 v6; // ax\n  __int16 v7; // ax\n  int v8; // edx\n  unsigned __int16 v9; // bx\n  const char *v10; // eax\n  __int16 v11; // ax\n  int v12; // ecx\n  __int16 v13; // ax\n  __int16 v14; // ax\n  __int16 v15; // ax\n  __int16 v16; // ax\n  __int16 v17; // ax\n  __int16 v18; // dx\n  unsigned __int16 v19; // bx\n  int i; // esi\n  const char *v21; // eax\n  __int16 v22; // ax\n  unsigned __int16 v23; // bx\n  int j; // esi\n  const char *v25; // eax\n  const char *v26; // edx\n  __int16 v27; // ax\n  const char *v28; // edx\n  unsigned __int16 v29; // si\n  unsigned int v30; // esi\n  int v31; // ecx\n  __int16 v32; // bx\n  int v33; // edx\n  int v34; // eax\n  int v35; // edx\n  unsigned __int64 v36; // rcx\n  int v37; // esi\n  int v38; // ebx\n  __int64 v39; // rax\n  __int16 v40; // cx\n  const char *v41; // edx\n  const char *v42; // eax\n  int v43; // eax\n  const char *v44; // ecx\n  const char *v45; // edx\n  int v46; // eax\n  const char *v47; // eax\n  __int16 v48; // ax\n  __int16 v49; // ax\n  __int16 v50; // dx\n  __int16 v51; // cx\n  __int16 v52; // ax\n  __int16 v53; // ax\n  unsigned __int16 v54; // ax\n  int v55; // ebx\n  unsigned __int16 v56; // ax\n  unsigned __int16 v57; // ax\n  __int16 v58; // bx\n  unsigned __int16 v59; // bx\n  int k; // esi\n  int m; // ebx\n  __int16 v62; // si\n  int v63; // ecx\n  unsigned __int16 n; // bx\n  const char *v65; // eax\n  int v66; // ecx\n  const char *v67; // edx\n  int v68; // eax\n  const char *v69; // eax\n  int v70; // eax\n  unsigned __int16 v71; // si\n  int ii; // ebx\n  const char *v73; // eax\n  const char *v74; // edx\n  __int16 v75; // dx\n  const char *v76; // eax\n  __int16 v77; // ax\n  unsigned __int16 v78; // si\n  __int16 v79; // dx\n  unsigned __int16 v80; // bx\n  int v81; // eax\n  int v82; // eax\n  unsigned __int16 v83; // ax\n  __int16 v84; // dx\n  __int16 v85; // dx\n  const char *v86; // ecx\n  const char *v87; // ebx\n  __int16 v88; // ax\n  const char *v89; // ecx\n  const char *v90; // edx\n  unsigned __int16 v91; // ax\n  unsigned __int16 v92; // [esp+Ch] [ebp-34h]\n  __int64 v93; // [esp+Ch] [ebp-34h]\n  int v94; // [esp+14h] [ebp-2Ch]\n  __int16 v95; // [esp+18h] [ebp-28h]\n  unsigned int v96; // [esp+18h] [ebp-28h]\n  unsigned __int64 v97; // [esp+18h] [ebp-28h]\n  unsigned __int64 v98; // [esp+18h] [ebp-28h]\n  __int16 v99; // [esp+22h] [ebp-1Eh]\n  unsigned __int16 v100; // [esp+24h] [ebp-1Ch]\n  int v101; // [esp+24h] [ebp-1Ch]\n  unsigned __int16 v102; // [esp+28h] [ebp-18h]\n  unsigned __int16 v103; // [esp+2Ah] [ebp-16h]\n  unsigned __int16 v104; // [esp+2Ah] [ebp-16h]\n  char var11[21]; // [esp+2Fh] [ebp-11h] BYREF\n\n  var11[0] = 0;\n  sub_804DD98(10);\n  v2 = *(_WORD *)a1;\n  if ( *(__int16 *)a1 < 0 )\n  {\n    if ( v2 == 0x848A )\n    {\n      printf(\"CompactFlash ATA device, with \");\n      v102 = -1;\n      v99 = 0;\n      v3 = 4;\n    }\n    else\n    {\n      if ( (v2 & 0x4000) != 0 )\n        sub_804D5E0(\"unknown device type\");\n      v102 = ((int)v2 >> 8) & 0x1F;\n      v4 = \"unknown\";\n      if ( v102 <= 0xFu )\n        v4 = sub_804D2B4(\"Direct-access device\", v102);\n      printf(\"ATAPI %s, with \", v4);\n      v99 = 1;\n      v3 = 3;\n    }\n  }\n  else\n  {\n    printf(\"ATA device, with \");\n    v102 = -1;\n    v99 = 0;\n    v3 = 1;\n  }\n  v5 = &data;\n  if ( *(char *)a1 >= 0 )\n    v5 = \"non-\";\n  printf(\"%sremovable media\\n\", v5);\n  v6 = *(_WORD *)(a1 + 4);\n  if ( v6 == 14280 )\n    goto LABEL_16;\n  if ( v6 != 29580 && v6 != -29581 && v6 != -14281 )\n    goto LABEL_21;\n  if ( v6 == 29580 )\nLABEL_16:\n    puts(\"powers-up in standby; SET FEATURES subcmd spins-up.\");\n  v7 = *(_WORD *)(a1 + 4);\n  if ( v7 == 14280 || (v3 = 5, v7 == -29581) )\n  {\n    v3 = 5;\n    if ( (*(_BYTE *)a1 & 4) != 0 )\n      puts(\"\\n\\tWARNING: ID response incomplete.\\n\\tFollowing data may be incorrect.\\n\");\n  }\nLABEL_21:\n  sub_80520C4(a1, 27, \"Model Number:\", 20);\n  sub_80520C4(a1, 10, \"Serial Number:\", 10);\n  sub_80520C4(a1, 23, \"Firmware Revision:\", 4);\n  sub_80520C4(a1, 176, \"Media Serial Num:\", 20);\n  sub_80520C4(a1, 196, \"Media Manufacturer:\", 10);\n  printf(\"Standards:\");\n  if ( v102 != 5 )\n  {\n    v8 = *(unsigned __int16 *)(a1 + 162);\n    v9 = 0;\n    if ( (unsigned __int16)(v8 - 1) <= 0x21u )\n    {\n      if ( v3 < 3u )\n        v3 = 3;\n      v9 = (unsigned __int8)byte_80C9E53[v8];\n      if ( byte_80C9E53[v8] )\n      {\n        v10 = sub_804D2B4(\"Unspecified\", v8);\n        printf(\"\\n\\tUsed: %s \", v10);\n      }\n    }\n    v100 = -1;\n    if ( (unsigned __int16)(*(_WORD *)(a1 + 160) - 1) <= 0xFFFDu )\n    {\n      printf(\"\\n\\tSupported: \");\n      v95 = 2 * *(_WORD *)(a1 + 160);\n      v11 = v3;\n      if ( v3 < 4u )\n        v11 = 4;\n      v103 = v11 - 4;\n      v12 = 14;\n      v100 = -1;\n      do\n      {\n        if ( (unsigned __int16)v12 <= v103 )\n          break;\n        if ( v95 < 0 )\n        {\n          v92 = v12;\n          v94 = v12;\n          printf(\"%u \", v12);\n          v12 = v94;\n          if ( v92 > v3 )\n          {\n            v13 = v94;\n            if ( v92 < 4u )\n              v13 = 4;\n            v103 = v13 - 4;\n            v3 = v92;\n          }\n          if ( v100 > v92 )\n            v100 = v92;\n        }\n        v95 *= 2;\n        --v12;\n      }\n      while ( v12 );\n      if ( v3 < 3u )\n        v3 = 3;\n    }\n    v104 = v3;\n    if ( v3 < v9 )\n      v104 = v9;\n    if ( v9 == 5 || !v9 && v104 <= 5u )\n    {\n      if ( (v14 = *(_WORD *)(a1 + 166), (v14 & 0xC000) == 0x4000) && (v14 & 0x3FFFu) > 0xFF\n        || (v15 = *(_WORD *)(a1 + 168), (v15 & 0xC000) == 0x4000) && (v15 & 0x2F) != 0 )\n      {\n        v104 = 6;\n        goto LABEL_84;\n      }\n    }\n    if ( v9 != 4 && (v9 || v104 > 4u) )\n    {\n      if ( v9 == 3 )\n      {\nLABEL_62:\n        v17 = *(_WORD *)(a1 + 166);\n        if ( (v17 & 0xC000) == 0x4000 && ((v17 & 0x3FFF) != 0 || (*(_WORD *)(a1 + 164) & 0x77FFu) > 0xF)\n          || (*(_WORD *)(a1 + 100) & 0xC000) == 0x4000\n          || (*(_BYTE *)(a1 + 106) & 4) != 0 && *(_WORD *)(a1 + 176)\n          || (*(_WORD *)(a1 + 254) & 3) == 1 )\n        {\n          v104 = 4;\n          goto LABEL_84;\n        }\nLABEL_69:\n        if ( (v9 == 2 || !v9 && v104 <= 2u) && (*(_WORD *)(a1 + 166) & 0xC000) == 0x4000 )\n        {\n          v104 = 3;\n        }\n        else if ( (v9 == 1 || !v9 && v104 == 1)\n               && ((*(_WORD *)(a1 + 98) & 0xC00) != 0 || (*(_BYTE *)(a1 + 106) & 2) != 0) )\n        {\n          v104 = 2;\n        }\nLABEL_84:\n        if ( v9 )\n        {\n          if ( v104 <= v9 )\n            sub_804DD98(10);\n          else\n            printf(\"& some of %u\\n\", v104);\n        }\n        else\n        {\n          printf(\"\\n\\tLikely used: %u\\n\", v104);\n        }\n        if ( v100 != 0xFFFF )\n          goto LABEL_104;\n        goto LABEL_101;\n      }\n    }\n    else if ( *(_BYTE *)(a1 + 510) == 0xA5\n           || (*(_WORD *)(a1 + 186) & 0xC000) == 0x4000\n           || (v16 = *(_WORD *)(a1 + 166), (v16 & 0xC000) == 0x4000) && (v16 & 0x3FFFu) > 0x1F )\n    {\n      v104 = 5;\n      goto LABEL_84;\n    }\n    if ( v104 > 3u || v9 )\n      goto LABEL_69;\n    goto LABEL_62;\n  }\n  v18 = 0;\n  if ( *(_WORD *)(a1 + 148) == 9 )\n  {\n    printf(\"\\n\\tUsed: ATAPI for CD-ROMs, SFF-8020i, r2.5\");\n    v18 = 1;\n  }\n  if ( (unsigned __int16)(*(_WORD *)(a1 + 146) - 1) > 0xFFFDu )\n  {\n    if ( !v18 )\n    {\n      v21 = \"\\n\\tLikely used CD-ROM ATAPI-1\";\n      goto LABEL_99;\n    }\n  }\n  else\n  {\n    printf(\"\\n\\tSupported: CD-ROM ATAPI\");\n    v19 = *(_WORD *)(a1 + 146) >> 1;\n    for ( i = 1; i != 15; ++i )\n    {\n      if ( (v19 & 1) != 0 )\n        printf(\"-%u \", i);\n      v19 >>= 1;\n    }\n  }\n  v21 = &data;\nLABEL_99:\n  puts(v21);\n  v104 = 2;\nLABEL_101:\n  v22 = v104;\n  if ( v104 < 4u )\n    v22 = 4;\n  v100 = v22 - 3;\nLABEL_104:\n  puts(\"Configuration:\");\n  if ( v104 == 1 && v102 != 5 )\n  {\n    v23 = *(_WORD *)a1 >> 1;\n    for ( j = 1; j != 15; ++j )\n    {\n      if ( (v23 & 1) != 0 )\n      {\n        v25 = sub_804D2B4(\"reserved\", j);\n        printf(\"\\t%s\\n\", v25);\n      }\n      v23 >>= 1;\n    }\n  }\n  if ( v99 == 1 )\n  {\n    v26 = \"3ms\";\n    v27 = *(_WORD *)a1 & 0x60;\n    if ( v27 )\n    {\n      v26 = \"<=10ms with INTRQ\";\n      if ( v27 != 32 )\n      {\n        v26 = \"unknown\";\n        if ( v27 == 64 )\n          v26 = \"50us\";\n      }\n    }\n    printf(\"\\tDRQ response: %s\\n\\tPacket size: \", v26);\n    v28 = \"12 bytes\";\n    if ( (*(_WORD *)a1 & 3) != 0 )\n    {\n      v28 = \"unknown\";\n      if ( (*(_WORD *)a1 & 3) == 1 )\n        v28 = \"16 bytes\";\n    }\n    puts(v28);\n  }\n  else\n  {\n    v96 = *(_DWORD *)(a1 + 120);\n    v29 = *(_WORD *)(a1 + 2);\n    if ( v96 <= 0xFBFC10 || v29 )\n    {\n      v31 = 0;\n      v32 = *(_WORD *)(a1 + 106) & 1;\n      if ( v32 )\n        v31 = *(unsigned __int16 *)(a1 + 112);\n      v33 = 0;\n      if ( v32 )\n        v33 = *(unsigned __int16 *)(a1 + 110);\n      v34 = 0;\n      if ( v32 )\n        v34 = *(unsigned __int16 *)(a1 + 108);\n      printf(\n        \"\\tLogical\\t\\tmax\\tcurrent\\n\\tcylinders\\t%u\\t%u\\n\\theads\\t\\t%u\\t%u\\n\\tsectors/track\\t%u\\t%u\\n\\t--\\n\",\n        v29,\n        v34,\n        *(unsigned __int16 *)(a1 + 6),\n        v33,\n        *(unsigned __int16 *)(a1 + 12),\n        v31);\n      if ( v100 == 1 && *(_DWORD *)(a1 + 8) )\n        printf(\"\\tbytes/track: %u\\tbytes/sector: %u\\n\", *(unsigned __int16 *)(a1 + 8), *(unsigned __int16 *)(a1 + 10));\n      v30 = 0;\n      if ( v32 )\n      {\n        v30 = *(_DWORD *)(a1 + 114);\n        if ( v104 <= 2u )\n        {\n          v35 = *(unsigned __int16 *)(a1 + 112) * *(unsigned __int16 *)(a1 + 108) * *(unsigned __int16 *)(a1 + 110);\n          if ( (int)abs32(v30 - v35) > (int)abs32(\n                                              (*(unsigned __int16 *)(a1 + 116) | (*(unsigned __int16 *)(a1 + 114) << 16))\n                                            - v35) )\n            v30 = *(unsigned __int16 *)(a1 + 116) | (*(unsigned __int16 *)(a1 + 114) << 16);\n        }\n        printf(\"\\tCHS current addressable sectors:%11u\\n\", v30);\n      }\n    }\n    else\n    {\n      puts(\"\\tCHS addressing not supported\");\n      v30 = 0;\n    }\n    printf(\"\\tLBA    user addressable sectors:%11u\\n\", v96);\n    if ( (*(_WORD *)(a1 + 166) & 0xC400) != 17408\n      || (v93 = *(_QWORD *)(a1 + 200), printf(\"\\tLBA48  user addressable sectors:%11llu\\n\", v93), (v36 = v93) == 0) )\n    {\n      if ( v30 < v96 )\n        v30 = v96;\n      v36 = v30;\n    }\n    v97 = v36;\n    printf(\"\\tdevice size with M = 1024*1024: %11llu MBytes\\n\", v36 >> 11);\n    v37 = v97 >> 23;\n    v38 = (_DWORD)v97 << 9;\n    v98 = sub_80B4B88((_DWORD)v97 << 9, v37, 1000000, 0);\n    printf(\"\\tdevice size with M = 1000*1000: %11llu MBytes \", v98);\n    if ( v98 <= 0x3E8 )\n    {\n      sub_804DD98(10);\n    }\n    else\n    {\n      v39 = sub_80B4B88(v38, v37, 1000000000, 0);\n      printf(\"(%llu GB)\\n\", v39);\n    }\n  }\n  printf(\"Capabilities:\\n\\t\");\n  if ( v99 == 1 )\n  {\n    if ( v102 != 5 && (*(_WORD *)(a1 + 98) & 0x4000) != 0 )\n      printf(\"Cmd queuing, \");\n    if ( (*(_BYTE *)(a1 + 99) & 0x20) != 0 )\n      printf(\"Cmd overlap, \");\n  }\n  if ( (*(_BYTE *)(a1 + 99) & 2) != 0 )\n    printf(\"LBA, \");\n  if ( v104 != 1 )\n  {\n    v40 = *(_WORD *)(a1 + 98);\n    v41 = \"not\";\n    if ( (v40 & 0x400) != 0 )\n      v41 = &data;\n    v42 = &data;\n    if ( (v40 & 0x800) == 0 )\n      v42 = \"(may be)\";\n    printf(\"IORDY%s(can%s be disabled)\\n\", v42, v41);\nLABEL_165:\n    if ( v100 == 1 )\n    {\n      v46 = *(unsigned __int16 *)(a1 + 42);\n      if ( (unsigned __int16)(v46 - 1) <= 0xFFFDu )\n        printf(\"\\tBuffer size: %.1fkB\\n\", (double)(0.5 * (long double)v46));\n    }\n    else if ( v100 > 3u )\n    {\n      goto LABEL_171;\n    }\n    if ( *(_WORD *)(a1 + 44) )\n      printf(\"\\tbytes avail on r/w long: %u\\n\", *(unsigned __int16 *)(a1 + 44));\nLABEL_171:\n    if ( v102 == 5 )\n    {\n      if ( v99 )\n      {\nLABEL_200:\n        if ( *(_WORD *)(a1 + 142) || *(_WORD *)(a1 + 144) )\n        {\n          printf(\"\\tOverlap support:\");\n          if ( *(_WORD *)(a1 + 142) )\n            printf(\" %uus to release bus.\", *(unsigned __int16 *)(a1 + 142));\n          if ( *(_WORD *)(a1 + 144) )\n            printf(\" %uus to clear BSY after SERVICE cmd.\", *(unsigned __int16 *)(a1 + 144));\n          sub_804DD98(10);\n        }\n        goto LABEL_207;\n      }\n    }\n    else\n    {\n      if ( v104 > 3u )\n      {\n        printf(\"\\tQueue depth: %u\\n\", (*(_WORD *)(a1 + 150) & 0x1F) + 1);\n        if ( v99 )\n        {\nLABEL_198:\n          if ( (*(_BYTE *)(a1 + 99) & 0x10) != 0 )\n            puts(\"\\tATA sw reset required\");\n          goto LABEL_200;\n        }\n        goto LABEL_177;\n      }\n      if ( v99 )\n        goto LABEL_198;\n    }\n    if ( v104 == 1 )\n    {\n      printf(\"\\tCan%s perform double-word IO\\n\");\nLABEL_183:\n      printf(\"\\tR/W multiple sector transfer: \");\n      v48 = *(_WORD *)(a1 + 94);\n      if ( v104 > 2u || (_BYTE)v48 )\n      {\n        printf(\"Max = %u\\tCurrent = \", (unsigned __int8)v48);\n        v49 = *(_WORD *)(a1 + 118);\n        if ( (v49 & 0x100) != 0 )\n          printf(\"%u\\n\", (unsigned __int8)v49);\n        else\n          puts(\"?\");\n        if ( v104 > 3u )\n        {\n          if ( (*(_BYTE *)(a1 + 166) & 8) != 0 )\n          {\n            printf(\"\\tAdvancedPM level: \");\n            v50 = *(_WORD *)(a1 + 182);\n            HIBYTE(v51) = HIBYTE(v50);\n            LOBYTE(v51) = 0;\n            if ( v51 == 0x4000 )\n              printf(\"%u (0x%x)\\n\", (unsigned __int8)v50, (unsigned __int8)v50);\n            else\n              printf(\"unknown setting (0x%04x)\\n\", *(unsigned __int16 *)(a1 + 182));\n          }\n          if ( v104 > 5u )\n          {\n            v52 = *(_WORD *)(a1 + 188);\n            if ( v52 )\n              printf(\n                \"\\tRecommended acoustic management value: %u, current value: %u\\n\",\n                HIBYTE(v52),\n                (unsigned __int8)v52);\n          }\n        }\n      }\n      else\n      {\n        puts(\"not supported\");\n      }\nLABEL_207:\n      printf(\"\\tDMA: \");\n      if ( (*(_BYTE *)(a1 + 99) & 1) != 0 )\n      {\n        v53 = *(_WORD *)(a1 + 104);\n        if ( v53 && !*(_WORD *)(a1 + 124) && !*(_WORD *)(a1 + 126) )\n          printf(\" sdma%u\\n\", HIBYTE(v53));\n        v54 = *(_WORD *)(a1 + 124);\n        v55 = 0;\n        if ( v54 )\n          LOBYTE(v55) = sub_8052127(v54, HIBYTE(v54), 115, var11);\n        v56 = *(_WORD *)(a1 + 126);\n        if ( v56 )\n          v55 += sub_8052127(v56, HIBYTE(v56), 109, var11);\n        if ( (*(_BYTE *)(a1 + 106) & 4) != 0 )\n        {\n          v57 = *(_WORD *)(a1 + 176);\n          if ( v57 )\n            v55 += sub_8052127(v57, HIBYTE(v57), 117, var11);\n        }\n        if ( (_BYTE)v55 || !var11[0] )\n          printf(\"(?)\");\n        sub_804DD98(10);\n        if ( v99 && v102 != 5 && *(__int16 *)(a1 + 98) < 0 )\n          puts(\"\\t\\tInterleaved DMA support\");\n        if ( (*(_BYTE *)(a1 + 106) & 2) != 0 && (*(_WORD *)(a1 + 130) || *(_WORD *)(a1 + 132)) )\n        {\n          printf(\"\\t\\tCycle time:\");\n          if ( *(_WORD *)(a1 + 130) )\n            printf(\" min=%uns\", *(unsigned __int16 *)(a1 + 130));\n          if ( *(_WORD *)(a1 + 132) )\n            printf(\" recommended=%uns\", *(unsigned __int16 *)(a1 + 132));\n          sub_804DD98(10);\n        }\n      }\n      else\n      {\n        puts(\"not supported\");\n      }\n      printf(\"\\tPIO: \");\n      if ( (*(_BYTE *)(a1 + 106) & 2) != 0 && (v58 = *(_WORD *)(a1 + 128), (_BYTE)v58) )\n      {\n        v59 = (8 * v58) & 0x7F8 | 7;\n        for ( k = 0; k != 9; ++k )\n        {\n          if ( (v59 & 1) != 0 )\n            printf(\"pio%d \", k);\n          v59 >>= 1;\n        }\n      }\n      else\n      {\n        if ( v102 != 5 && v100 > 4u || (*(_WORD *)(a1 + 102) & 0xFF00) == 0 )\n        {\n          puts(\"unknown\");\n          goto LABEL_249;\n        }\n        for ( m = 0; *(unsigned __int8 *)(a1 + 103) >= (unsigned __int16)m; ++m )\n          printf(\"pio%d \", m);\n      }\n      sub_804DD98(10);\nLABEL_249:\n      if ( (*(_BYTE *)(a1 + 106) & 2) != 0 && (*(_WORD *)(a1 + 134) || *(_WORD *)(a1 + 136)) )\n      {\n        printf(\"\\t\\tCycle time:\");\n        if ( *(_WORD *)(a1 + 134) )\n          printf(\" no flow control=%uns\", *(unsigned __int16 *)(a1 + 134));\n        if ( *(_WORD *)(a1 + 136) )\n          printf(\"  IORDY flow control=%uns\", *(unsigned __int16 *)(a1 + 136));\n        sub_804DD98(10);\n      }\n      if ( (*(_WORD *)(a1 + 166) & 0xC000) == 0x4000 )\n      {\n        puts(\"Commands/features:\\n\\tEnabled\\tSupported:\");\n        v62 = *(_WORD *)(a1 + 164);\n        LOWORD(v63) = *(_WORD *)(a1 + 170);\n        for ( n = 0; n != 48; ++n )\n        {\n          v101 = v63;\n          v65 = sub_804D2B4(byte_80C9B07, n);\n          v66 = v101;\n          if ( v62 < 0 && *v65 )\n          {\n            v67 = &data;\n            if ( (v101 & 0x8000u) != 0 )\n              v67 = \"   *\";\n            printf(\"\\t%s\\t%s\\n\", v67, v65);\n            v66 = v101;\n          }\n          v62 *= 2;\n          v63 = 2 * v66;\n          if ( (n & 0xF) == 15 )\n          {\n            v68 = 2 * ((n >> 4) + 83);\n            v62 = *(_WORD *)(a1 + v68);\n            LOWORD(v63) = *(_WORD *)(a1 + v68 + 6);\n          }\n          if ( n == 31 && (*(_WORD *)(a1 + 168) & 0xC000) != 0x4000 )\n            n = 47;\n        }\n      }\n      if ( (*(_WORD *)(a1 + 254) & 3) == 1 )\n      {\n        v69 = sub_804D2B4(byte_80C9B07, 27);\n        printf(\"\\t%s supported\\n\", v69);\n      }\n      if ( v104 > 3u && v102 != 5 && (*(_WORD *)(a1 + 256) || *(_WORD *)(a1 + 178) || *(_WORD *)(a1 + 180)) )\n      {\n        puts(\"Security:\");\n        v70 = *(unsigned __int16 *)(a1 + 184);\n        if ( (unsigned __int16)(v70 - 1) <= 0xFFFDu )\n          printf(\"\\tMaster password revision code = %u\\n\", v70);\n        v71 = *(_WORD *)(a1 + 256);\n        if ( v71 )\n        {\n          for ( ii = 0; ii != 6; ++ii )\n          {\n            v73 = sub_804D2B4(\"supported\", ii);\n            v74 = &data;\n            if ( (v71 & 1) == 0 )\n              v74 = \"not\";\n            printf(\"\\t%s\\t%s\\n\", v74, v73);\n            v71 >>= 1;\n          }\n          v75 = *(_WORD *)(a1 + 256);\n          if ( (v75 & 2) != 0 )\n          {\n            v76 = \"high\";\n            if ( (v75 & 0x10) != 0 )\n              v76 = \"maximum\";\n            printf(\"\\tSecurity level %s\\n\", v76);\n          }\n        }\n        v77 = *(_WORD *)(a1 + 178);\n        v78 = (unsigned __int8)v77;\n        v79 = *(_WORD *)(a1 + 180);\n        v80 = (unsigned __int8)v79;\n        if ( (unsigned __int8)v79 | (unsigned __int8)v77 )\n        {\n          sub_804DD98(9);\n          if ( v78 )\n          {\n            v81 = 508;\n            if ( v78 != 255 )\n              v81 = 2 * v78;\n            printf(\"%umin for %sSECURITY ERASE UNIT. \", v81, &data);\n          }\n          if ( v80 )\n          {\n            v82 = 508;\n            if ( v80 != 255 )\n              v82 = 2 * v80;\n            printf(\"%umin for %sSECURITY ERASE UNIT. \", v82, \"ENHANCED \");\n          }\n          sub_804DD98(10);\n        }\n      }\n      v83 = *(_WORD *)(a1 + 186);\n      if ( (v83 & 0xC000) == 0x4000 )\n      {\n        LOBYTE(v84) = *(_WORD *)(a1 + 186);\n        if ( (v83 & 1) == 0 )\n          v84 = HIBYTE(v83);\n        v85 = v84 & 6;\n        v86 = \" determined by the jumper\";\n        if ( v85 != 2 )\n        {\n          v86 = &data;\n          if ( v85 == 4 )\n            v86 = \" determined by CSEL\";\n        }\n        v87 = \"below\";\n        if ( (v83 & 0x2000) != 0 )\n          v87 = \"above\";\n        printf(\"HW reset results:\\n\\tCBLID- %s Vih\\n\\tDevice num = %i%s\\n\", v87, (v83 & 1) == 0, v86);\n      }\n      if ( v104 > 4u && v102 != 5 )\n      {\n        v88 = *(_WORD *)(a1 + 320);\n        if ( v88 < 0 )\n        {\n          v89 = &data;\n          if ( (v88 & 0x2000) != 0 )\n            v89 = \" and required by some commands\";\n          v90 = \"enabled\";\n          if ( (v88 & 0x1000) != 0 )\n            v90 = \"disabled\";\n          printf(\"CFA power mode 1:\\n\\t%s%s\\n\", v90, v89);\n          v91 = *(_WORD *)(a1 + 320) & 0xFFF;\n          if ( v91 )\n            printf(\"\\tMaximum current = %uma\\n\", v91);\n        }\n        if ( *(_BYTE *)(a1 + 510) == 0xA5 )\n          printf(\"Checksum: %scorrect\\n\", &data);\n      }\n      exit(0);\n    }\nLABEL_177:\n    v47 = \"vendor\";\n    if ( (*(_BYTE *)(a1 + 99) & 0x20) != 0 )\n      v47 = \"standard\";\n    printf(\"\\tStandby timer values: spec'd by %s\", v47);\n    if ( v104 > 3u && (*(_WORD *)(a1 + 100) & 0xC000) == 0x4000 )\n      printf(\", %s device specific minimum\\n\");\n    else\n      sub_804DD98(10);\n    goto LABEL_183;\n  }\n  puts(\"no IORDY\");\n  v43 = *(unsigned __int16 *)(a1 + 40);\n  if ( !(_WORD)v43 )\n    goto LABEL_165;\n  if ( (unsigned __int16)v43 > 2u )\n  {\n    v44 = \" with read caching ability\";\n  }\n  else\n  {\n    v44 = &data;\n    v45 = \"single port, single-sector\";\n    if ( (_WORD)v43 == 1 )\n    {\nLABEL_164:\n      printf(\"\\tBuffer type: %04x: %s%s\\n\", v43, v45, v44);\n      goto LABEL_165;\n    }\n  }\n  v45 = \"dual port, multi-sector\";\n  goto LABEL_164;\n}\n"
    ],
    "sub_8053222": [
        "0x8053222",
        "void __noreturn sub_8053222()\n{\n  int v0; // ecx\n  char *v1; // eax\n  char *v2; // edi\n  unsigned __int8 v3; // si\n  __int16 v4; // dx\n  __int16 v5[256]; // [esp+4h] [ebp-710h] BYREF\n  char v6[1296]; // [esp+204h] [ebp-510h] BYREF\n\n  sub_80B24F6(1280, v6);\n  v0 = 0;\n  v1 = v6;\n  while ( 1 )\n  {\n    v2 = v1 + 4;\n    do\n    {\n      v3 = *v1++;\n      if ( (unsigned __int8)(v3 - 48) > 9u )\n      {\n        if ( (unsigned __int8)(v3 - 97) > 5u )\n          sub_804D5E0(\"bad char: '%c' 0x%02x\", v3, (unsigned __int8)*(v1 - 1));\n        v4 = v3 - 87;\n      }\n      else\n      {\n        v4 = v3 - 48;\n      }\n      v5[v0] = 16 * v5[v0] + v4;\n    }\n    while ( v2 != v1 );\n    if ( ++v0 == 256 )\n      sub_80521C1((int)v5);\n  }\n}\n"
    ],
    "sub_80532AE": [
        "0x80532ae",
        "int __usercall sub_80532AE@<eax>(unsigned __int16 *a1@<eax>)\n{\n  unsigned int i; // esi\n  int v3; // eax\n  const char *v4; // eax\n  int v5; // edi\n  int v6; // esi\n  int v7; // edx\n  const char *v8; // eax\n  const char *v9; // eax\n  char v10; // dl\n  const char *v11; // eax\n  unsigned __int16 v12; // ax\n  unsigned __int16 v13; // ax\n  const char *v14; // eax\n  unsigned __int16 v15; // ax\n  __int16 v16; // dx\n  const char *v17; // eax\n  int v18; // edx\n  const char *v19; // eax\n  unsigned int j; // esi\n  int v21; // eax\n  int v23; // [esp-4h] [ebp-10h]\n\n  printf(\n    \"\\n Model=%.40s, FwRev=%.8s, SerialNo=%.20s\\n Config={\",\n    (const char *)a1 + 54,\n    (const char *)a1 + 46,\n    (const char *)a1 + 20);\n  for ( i = 0; i != 16; ++i )\n  {\n    v3 = *a1;\n    if ( _bittest(&v3, i) )\n    {\n      v4 = sub_804D2B4(byte_80C9A23, i);\n      printf(\" %s\", v4);\n    }\n  }\n  v5 = *((unsigned __int8 *)a1 + 94);\n  v6 = a1[21] >> 1;\n  v7 = a1[20];\n  if ( (unsigned __int16)v7 > 3u )\n    v7 = 0;\n  v8 = sub_804D2B4(\"unknown\", v7);\n  printf(\n    \" }\\n RawCHS=%u/%u/%u, TrkSize=%u, SectSize=%u, ECCbytes=%u\\n BuffType=(%u) %s, BuffSize=%ukB, MaxMultSect=%u\",\n    a1[1],\n    a1[3],\n    a1[6],\n    a1[4],\n    a1[5],\n    a1[22],\n    a1[20],\n    v8,\n    v6,\n    v5);\n  if ( *((_BYTE *)a1 + 94) )\n  {\n    printf(\", MultSect=\");\n    if ( (*((_BYTE *)a1 + 119) & 1) != 0 )\n    {\n      if ( *((_BYTE *)a1 + 118) )\n        printf(\"%u\", *((unsigned __int8 *)a1 + 118));\n      else\n        printf(\"off\");\n    }\n    else\n    {\n      printf(\"?%u?\", *((unsigned __int8 *)a1 + 118));\n    }\n  }\n  sub_804DD98(10);\n  if ( (a1[53] & 1) == 0 )\n    printf(\" (maybe):\");\n  v9 = \"yes\";\n  if ( (*((_BYTE *)a1 + 99) & 2) == 0 )\n    v9 = \"no\";\n  printf(\" CurCHS=%u/%u/%u, CurSects=%lu, LBA=%s\", a1[54], a1[55], a1[56], *(_DWORD *)(a1 + 57), v9);\n  if ( (*((_BYTE *)a1 + 99) & 2) != 0 )\n    printf(\", LBAsects=%u\", *((_DWORD *)a1 + 30));\n  v10 = *((_BYTE *)a1 + 99);\n  v11 = \"no\";\n  if ( (v10 & 8) != 0 )\n  {\n    v11 = \"yes\";\n    if ( (v10 & 4) != 0 )\n      v11 = \"on/off\";\n  }\n  printf(\"\\n IORDY=%s\", v11);\n  v12 = a1[53];\n  if ( ((*((_BYTE *)a1 + 99) & 8) != 0 || (v12 & 2) != 0) && (v12 & 2) != 0 )\n    printf(\", tPIO={min:%u,w/IORDY:%u}\", a1[67], a1[68]);\n  if ( (*((_BYTE *)a1 + 99) & 1) != 0 && (a1[53] & 2) != 0 )\n    printf(\", tDMA={min:%u,rec:%u}\", a1[65], a1[66]);\n  printf(\"\\n PIO modes:  \");\n  if ( *((_BYTE *)a1 + 103) <= 5u )\n  {\n    printf(\"pio0 \");\n    if ( *((_BYTE *)a1 + 103) )\n      printf(\"pio1 \");\n    if ( *((_BYTE *)a1 + 103) > 1u )\n      printf(\"pio2 \");\n  }\n  if ( (a1[53] & 2) != 0 )\n    sub_80B0B09();\n  if ( (*((_BYTE *)a1 + 99) & 1) != 0 && *((_DWORD *)a1 + 31) )\n  {\n    printf(\"\\n DMA modes:  \");\n    sub_80B0AB7(a1[62], \"*\", 0);\n    sub_80B0AB7(a1[63], \"*\", 0);\n  }\n  v13 = a1[53];\n  if ( ((*((_BYTE *)a1 + 99) & 8) != 0 || (v13 & 2) != 0) && (v13 & 4) != 0 )\n  {\n    printf(\"\\n UDMA modes: \");\n    sub_80B0B09();\n    if ( (*((_BYTE *)a1 + 187) & 0x20) != 0 )\n      sub_80B0B09();\n  }\n  v14 = \"yes\";\n  if ( (a1[83] & 8) == 0 )\n    v14 = \"no\";\n  printf(\"\\n AdvancedPM=%s\", v14);\n  if ( (a1[83] & 8) != 0 )\n  {\n    if ( (a1[86] & 8) != 0 )\n    {\n      v15 = a1[91];\n      HIBYTE(v16) = HIBYTE(v15);\n      LOBYTE(v16) = 0;\n      if ( v16 == 0x4000 )\n        printf(\": mode=0x%02X (%u)\", (unsigned __int8)v15, (unsigned __int8)v15);\n      else\n        printf(\": unknown setting\");\n    }\n    else\n    {\n      printf(\": disabled (255)\");\n    }\n  }\n  if ( (a1[82] & 0x20) != 0 )\n  {\n    v17 = \"disabled\";\n    if ( (a1[85] & 0x20) != 0 )\n      v17 = \"enabled\";\n    printf(\" WriteCache=%s\", v17);\n  }\n  v18 = a1[81];\n  if ( (unsigned __int16)(v18 - 1) <= 0x1Eu || a1[80] && (unsigned __int16)v18 <= 0x1Fu )\n  {\n    v19 = sub_804D2B4(\"Unspecified\", v18);\n    printf(\"\\n Drive conforms to: %s: \", v19);\n    if ( (unsigned __int16)(a1[80] - 1) <= 0xFFFDu )\n    {\n      for ( j = 0; j != 16; ++j )\n      {\n        v21 = a1[80];\n        if ( _bittest(&v21, j) )\n          printf(\" ATA/ATAPI-%u\", j);\n      }\n    }\n  }\n  puts(\"\\n\\n * current active mode\\n\");\n  return v23;\n}\n"
    ],
    "sub_8053656": [
        "0x8053656",
        "int sub_8053656()\n{\n  return sub_804DD09(0, 0, 0);\n}\n"
    ],
    "sub_8053667": [
        "0x8053667",
        "int sub_8053667()\n{\n  int result; // eax\n  int v1; // [esp-4h] [ebp-4h]\n\n  fsync(3);\n  sub_804E09D(3, 0x1261u, 0, \"BLKFLSBUF\");\n  sleep(1u);\n  result = ioctl(3, 0x31Fu, 0);\n  if ( result )\n  {\n    result = dword_80DBB7C;\n    if ( *(_DWORD *)dword_80DBB7C != 22 )\n    {\n      sub_804D3A5((int)\"HDIO_DRIVE_CMD\");\n      return v1;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80536B6": [
        "0x80536b6",
        "void __usercall sub_80536B6(int a1@<eax>)\n{\n  void *v2; // ebp\n  unsigned int v3; // edi\n  unsigned int v4; // ebx\n  unsigned int v5; // eax\n  int v6; // esi\n  unsigned int v7; // edi\n  int v8; // eax\n  int v9; // eax\n  unsigned int v10; // [esp+0h] [ebp-24h]\n  unsigned int v11; // [esp+4h] [ebp-20h]\n  int v12; // [esp+8h] [ebp-1Ch]\n  __int64 v13[3]; // [esp+Ch] [ebp-18h] BYREF\n\n  v2 = sub_804DAFA(0x100000u);\n  if ( mlock(v2, 0x100000u) )\n    sub_804D3C9((int)\"mlock\");\n  sync();\n  sleep(1u);\n  if ( a1 )\n  {\n    sub_8053656();\n    sub_805209C((int)v2);\n    printf(\"Timing buffer-cache reads: \");\n  }\n  else\n  {\n    printf(\"Timing buffered disk reads:\");\n  }\n  sub_804DD8F();\n  if ( a1 )\n  {\n    v11 = 510000;\n    v3 = -1;\n  }\n  else\n  {\n    if ( ioctl(3, 0x80041272, v13) )\n    {\n      sub_804E0BE(3, 0x1260u, (int)v13, \"BLKGETSIZE\");\n      v13[0] = LODWORD(v13[0]) >> 11;\n    }\n    else\n    {\n      v13[0] = (unsigned __int64)v13[0] >> 20;\n    }\n    v3 = v13[0];\n    if ( HIDWORD(v13[0]) )\n      v3 = -1;\n    v11 = 3000000;\n  }\n  v12 = sub_804EBDE();\n  v4 = 0;\n  do\n  {\n    if ( a1 )\n      sub_8053656();\n    sub_805209C((int)v2);\n    v5 = sub_804EBDE() - v12;\n    v10 = v5;\n    ++v4;\n  }\n  while ( v3 > v4 && v11 > v5 );\n  if ( a1 )\n  {\n    v6 = sub_804EBDE();\n    v7 = v4;\n    do\n    {\n      sub_8053656();\n      v8 = sub_804EBDE();\n      --v7;\n    }\n    while ( v7 );\n    v10 -= v8 - v6;\n    v4 *= 2;\n    sub_8053667();\n  }\n  v9 = sub_80B4B88(1024000000 * v4, (1024000000 * (unsigned __int64)v4) >> 32, v10 | 1, 0);\n  printf(\"%5u MB in %u.%02u seconds = %u kB/s\\n\", v4, v10 / 0xF4240, v10 % 0xF4240 / 0x2710, v9);\n  munlock(v2, 0x100000u);\n  free(v2);\n}\n"
    ],
    "sub_8053851": [
        "0x8053851",
        "int __usercall sub_8053851@<eax>(_BYTE *a1@<eax>, char a2@<dl>)\n{\n  int result; // eax\n\n  result = ioctl(3, 0x31Fu, a1);\n  if ( result )\n  {\n    *a1 = a2;\n    return sub_804E09D(3, 0x31Fu, (int)a1, \"HDIO_DRIVE_CMD\");\n  }\n  return result;\n}\n"
    ],
    "sub_805388A": [
        "0x805388a",
        "int __usercall sub_805388A@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  int v5; // [esp-4h] [ebp-8h]\n\n  printf(\" setting %s to %lu\", a1, a2);\n  v3 = \" (off)\";\n  if ( a2 )\n    v3 = \" (on)\";\n  puts(v3);\n  return v5;\n}\n"
    ],
    "sub_80538B3": [
        "0x80538b3",
        "int __usercall sub_80538B3@<eax>(const char *a1@<eax>)\n{\n  int v2; // eax\n  size_t v3; // ebx\n  unsigned int v4; // ebx\n  const char *v5; // eax\n  unsigned __int8 buffer; // bl\n  int buffer_low; // esi\n  const char *v8; // eax\n  const char *v9; // eax\n  char v10; // al\n  int v12; // [esp+0h] [ebp-21Ch] BYREF\n  int v13; // [esp+4h] [ebp-218h] BYREF\n  int v14; // [esp+8h] [ebp-214h] BYREF\n  int v15[132]; // [esp+Ch] [ebp-210h] BYREF\n\n  v14 = 239;\n  v2 = sub_804DC1E(a1);\n  sub_804DC97(v2, 3);\n  printf(\"\\n%s:\\n\", a1);\n  if ( (_BYTE)unk_80DB780 == 2 )\n  {\n    printf(\" setting %s to %lu\\n\", \"fs readahead\", unk_80DB78C);\n    sub_804E09D(3, 0x1262u, (int)unk_80DB78C, \"BLKRASET\");\n  }\n  if ( BYTE2(MEMORY[0x80DB77C]) )\n  {\n    if ( HIBYTE(MEMORY[0x80DB77C]) )\n    {\n      printf(\" attempting to \");\n      if ( MEMORY[0x80DB788] == (char *)255 )\n      {\n        puts(\"auto-tune PIO mode\");\n      }\n      else if ( (int)MEMORY[0x80DB788] > 99 )\n      {\n        if ( (int)MEMORY[0x80DB788] > 199 )\n          printf(\"set UDMA mode to %d\\n\");\n        else\n          printf(\"set MDMA mode to %d\\n\");\n      }\n      else\n      {\n        printf(\"set PIO mode to %d\\n\");\n      }\n    }\n    sub_804E09D(3, 0x327u, (int)MEMORY[0x80DB788], \"HDIO_SET_PIO_MODE\");\n  }\n  if ( *((_BYTE *)&unk_80DB780 + 7) == 2 )\n  {\n    printf(\" setting %s to %lu\\n\", \"32-bit IO_support flag\", qword_80DB7A8);\n    sub_804E09D(3, 0x324u, (int)qword_80DB7A8, \"HDIO_SET_32BIT\");\n  }\n  if ( HIBYTE(unk_80DB780) == 2 )\n  {\n    printf(\" setting %s to %lu\\n\", \"multcount\", dword_80DB798);\n    sub_804E09D(3, 0x321u, (int)dword_80DB798, \"HDIO_SET_MULTCOUNT\");\n  }\n  if ( BYTE1(unk_80DB780) == 2 )\n  {\n    sub_805388A(\"readonly\", unk_80DB790);\n    sub_804E09D(3, 0x125Du, (int)&unk_80DB790, \"BLKROSET\");\n  }\n  if ( BYTE2(unk_80DB780) == 2 )\n  {\n    sub_805388A(\"unmaskirq\", unk_80DB794);\n    sub_804E09D(3, 0x322u, unk_80DB794, \"HDIO_SET_UNMASKINTR\");\n  }\n  if ( *((_BYTE *)&unk_80DB780 + 4) == 2 )\n  {\n    sub_805388A(\"DMA queue_depth\", (int)stream);\n    sub_804E09D(3, 0x32Eu, (int)stream, \"HDIO_SET_QDMA\");\n  }\n  if ( *((_BYTE *)&unk_80DB780 + 5) == 2 )\n  {\n    sub_805388A(\"nowerr\", pmatch[0].rm_so);\n    sub_804E09D(3, 0x325u, pmatch[0].rm_so, \"HDIO_SET_NOWERR\");\n  }\n  if ( *((_BYTE *)&unk_80DB780 + 6) == 2 )\n  {\n    sub_805388A(\"keep_settings\", dword_80DB7A4);\n    sub_804E09D(3, 0x323u, dword_80DB7A4, \"HDIO_SET_KEEPSETTINGS\");\n  }\n  if ( (_BYTE)dword_80DB7B4 == 2 )\n  {\n    LOBYTE(v14) = (dword_80DB7D8 == 0) - 34;\n    BYTE2(v14) = 0;\n    sub_805388A(\"drive doorlock\", dword_80DB7D8);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    LOBYTE(v14) = -17;\n  }\n  if ( BYTE2(MEMORY[0x80DB7AC]) == 2 )\n  {\n    sub_805388A(\"drive keep features\", (int)dword_80DB7C0);\n    BYTE2(v14) = dword_80DB7C0 == 0 ? -52 : 102;\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( BYTE2(dword_80DB7B0) == 2 )\n  {\n    BYTE2(v14) = *(_DWORD *)&dword_80DB7D0.sa_family == 0 ? -124 : 4;\n    printf(\" setting %s to %lu\\n\", \"drive defect-mgmt\", *(_DWORD *)&dword_80DB7D0.sa_family);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( BYTE1(dword_80DB7B0) == 2 )\n  {\n    BYTE1(v14) = dword_80DB7CC;\n    BYTE2(v14) = -85;\n    printf(\" setting %s to %lu\\n\", \"drive prefetch\", dword_80DB7CC);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( (_BYTE)MEMORY[0x80DB7AC] )\n  {\n    BYTE1(v14) = n;\n    BYTE2(v14) = 3;\n    printf(\" setting %s to %lu\\n\", \"xfermode\", n);\n    v3 = n;\n    printf(\" (\");\n    if ( v3 )\n    {\n      if ( v3 == 1 )\n      {\n        printf(\"default PIO mode, disable IORDY\");\n      }\n      else if ( v3 - 8 > 7 )\n      {\n        if ( v3 - 16 > 7 )\n        {\n          if ( v3 - 32 > 7 )\n          {\n            v4 = v3 - 64;\n            if ( v4 > 7 )\n              printf(\"unknown\");\n            else\n              printf(\"UltraDMA mode%u\", v4);\n          }\n          else\n          {\n            printf(\"multiword DMA mode%u\", v3 - 32);\n          }\n        }\n        else\n        {\n          printf(\"singleword DMA mode%u\", v3 - 16);\n        }\n      }\n      else\n      {\n        printf(\"PIO flow control mode%u\", v3 - 8);\n      }\n    }\n    else\n    {\n      printf(\"default PIO mode\");\n    }\n    puts(\")\");\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( (_BYTE)dword_80DB7B0 == 2 )\n  {\n    BYTE2(v14) = dword_80DB7C8 == 0 ? 85 : -86;\n    sub_805388A(\"drive read-lookahead\", dword_80DB7C8);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( BYTE1(MEMORY[0x80DB7B8]) == 2 )\n  {\n    BYTE2(v14) = dword_80DB7DC != 255 ? 5 : -123;\n    BYTE1(v14) = dword_80DB7DC;\n    v5 = &data;\n    if ( dword_80DB7DC == 255 )\n      v5 = \"disabled\";\n    printf(\" setting APM level to %s 0x%02lX (%ld)\\n\", v5, dword_80DB7DC, dword_80DB7DC);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( HIBYTE(dword_80DB7B0) == 2 )\n  {\n    BYTE2(v14) = dword_80DB7D4 == 0 ? -126 : 2;\n    sub_805388A(\"drive write-caching\", dword_80DB7D4);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  BYTE2(v14) = 0;\n  if ( BYTE2(dword_80DB7B4) )\n  {\n    puts(\" issuing standby command\");\n    LOBYTE(v14) = -32;\n    sub_8053851(&v14, 148);\n  }\n  if ( HIBYTE(dword_80DB7B4) )\n  {\n    puts(\" issuing sleep command\");\n    LOBYTE(v14) = -26;\n    sub_8053851(&v14, 153);\n  }\n  if ( BYTE1(dword_80DB7B4) )\n  {\n    LOBYTE(v14) = -5;\n    puts(\" disabling Seagate auto powersaving mode\");\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( HIBYTE(MEMORY[0x80DB7AC]) == 2 )\n  {\n    LOBYTE(v14) = -29;\n    BYTE1(v14) = preg.buffer;\n    printf(\" setting %s to %lu\\n\", \"standby\", preg.buffer);\n    buffer = (unsigned __int8)preg.buffer;\n    buffer_low = LOBYTE(preg.buffer);\n    printf(\" (\");\n    if ( buffer )\n    {\n      if ( buffer == 0xFC || buffer <= 0xF0u || buffer == 0xFF )\n      {\n        printf(\"%u minutes %u seconds\", 5 * buffer_low / 0x3Cu, 5 * buffer_low % 0x3Cu);\n      }\n      else if ( buffer <= 0xFBu )\n      {\n        printf(\"%u.%c hours\", (unsigned int)(buffer_low - 240) >> 1, (((_BYTE)buffer_low + 16) & 1) == 0 ? 48 : 53);\n      }\n      if ( buffer == 0xFD )\n      {\n        printf(\"vendor-specific\");\n      }\n      else if ( buffer == 0xFE )\n      {\n        printf(\"reserved\");\n      }\n    }\n    else\n    {\n      printf(\"off\");\n    }\n    puts(\")\");\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( HIBYTE(unk_80DB780) || (_BYTE)qword_80DB778 )\n  {\n    v13 = -1;\n    if ( ioctl(3, 0x304u, &v13) )\n    {\n      if ( HIBYTE(unk_80DB780) )\n        sub_804D3A5((int)\"HDIO_GET_MULTCOUNT\");\n      else\n        sub_804D3A5((int)\"ioctl %#x failed\", 772);\n    }\n    else if ( HIBYTE(unk_80DB780) )\n    {\n      printf(\" %s\\t= %2ld\", \"multcount\", v13);\n      v8 = \" (off)\";\n      if ( v13 )\n        v8 = \" (on)\";\n      puts(v8);\n    }\n  }\n  if ( *((_BYTE *)&unk_80DB780 + 7) && !sub_804E09D(3, 0x309u, (int)&v12, \"HDIO_GET_32BIT\") )\n  {\n    printf(\" IO_support\\t=%3ld (\", v12);\n    if ( v12 )\n    {\n      switch ( v12 )\n      {\n        case 2:\n          puts(\"16-bit)\");\n          break;\n        case 1:\n          puts(\"32-bit)\");\n          break;\n        case 3:\n          puts(\"32-bit w/sync)\");\n          break;\n        case 8:\n          puts(\"Request-Queue-Bypass)\");\n          break;\n        default:\n          puts(\"???)\");\n          break;\n      }\n    }\n    else\n    {\n      puts(\"default 16-bit)\");\n    }\n  }\n  if ( BYTE2(unk_80DB780) && !sub_804E09D(3, 0x302u, (int)&v12, \"HDIO_GET_UNMASKINTR\") )\n    sub_8052198(\"unmaskirq\", v12);\n  if ( *((_BYTE *)&unk_80DB780 + 4) && !sub_804E09D(3, 0x305u, (int)&v12, \"HDIO_GET_QDMA\") )\n    sub_8052198(\"queue_depth\", v12);\n  if ( *((_BYTE *)&unk_80DB780 + 6) && !sub_804E09D(3, 0x308u, (int)&v12, \"HDIO_GET_KEEPSETTINGS\") )\n    sub_8052198(\"keepsettings\", v12);\n  if ( *((_BYTE *)&unk_80DB780 + 5) && !sub_804E09D(3, 0x30Au, (int)&v12, \"HDIO_GET_NOWERR\") )\n    sub_8052198(\"nowerr\", v12);\n  if ( BYTE1(unk_80DB780) && !sub_804E09D(3, 0x125Eu, (int)&v12, \"BLKROGET\") )\n    sub_8052198(\"readonly\", v12);\n  if ( (_BYTE)unk_80DB780 && !sub_804E09D(3, 0x1263u, (int)&v12, \"BLKRAGET\") )\n    sub_8052198(\"readahead\", v12);\n  if ( BYTE1(qword_80DB778)\n    && !sub_804E09D(3, 0x1260u, (int)&v12, \"BLKGETSIZE\")\n    && !sub_804E09D(3, 0x301u, (int)v15, \"HDIO_GETGEO\") )\n  {\n    printf(\n      \" geometry\\t= %u/%u/%u, sectors = %ld, start = %ld\\n\",\n      HIWORD(v15[0]),\n      LOBYTE(v15[0]),\n      BYTE1(v15[0]),\n      v12,\n      v15[1]);\n  }\n  if ( (_BYTE)MEMORY[0x80DB7B8] )\n  {\n    LOBYTE(v14) = -27;\n    if ( sub_8053851(&v14, 152) )\n    {\n      v9 = \"unknown\";\n      if ( *(_DWORD *)dword_80DBB7C == 5 && !(_BYTE)v14 )\n      {\n        v9 = \"sleeping\";\n        if ( BYTE1(v14) )\n          v9 = \"unknown\";\n      }\n    }\n    else\n    {\n      v9 = \"standby\";\n      if ( BYTE2(v14) == 0xFF )\n        v9 = \"active/idle\";\n    }\n    *(_WORD *)((char *)&v14 + 1) = 0;\n    printf(\" drive state is:  %s\\n\", v9);\n  }\n  if ( (_BYTE)qword_80DB778 )\n  {\n    if ( ioctl(3, 0x30Du, v15) )\n    {\n      if ( *(_DWORD *)dword_80DBB7C == -42 )\n        puts(\" no identification info available\");\n      else\n        sub_804D3A5((int)\"HDIO_GET_IDENTITY\");\n    }\n    else\n    {\n      if ( v13 == -1 )\n      {\n        v10 = HIBYTE(v15[29]) & 0xFE;\n      }\n      else\n      {\n        BYTE2(v15[29]) = v13;\n        v10 = HIBYTE(v15[29]) | 1;\n      }\n      HIBYTE(v15[29]) = v10;\n      sub_80532AE((unsigned __int16 *)v15);\n    }\n  }\n  if ( byte_80DB7E0 )\n  {\n    memset(v15, 0, 0x204u);\n    LOBYTE(v15[0]) = -20;\n    HIBYTE(v15[0]) = 1;\n    if ( !sub_8053851(v15, 161) )\n      sub_80521C1((int)&v15[1]);\n  }\n  if ( BYTE1(MEMORY[0x80DB77C]) )\n    sub_804E09D(3, 0x125Fu, 0, \"BLKRRPART\");\n  if ( HIBYTE(qword_80DB778) )\n    sub_80536B6(1);\n  if ( (_BYTE)MEMORY[0x80DB77C] )\n    sub_80536B6(0);\n  if ( BYTE2(qword_80DB778) )\n    sub_8053667();\n  return close(3);\n}\n"
    ],
    "sub_805436B": [
        "0x805436b",
        "int __cdecl sub_805436B(int argc, char **argv)\n{\n  int v2; // esi\n  int v3; // eax\n  int v4; // ebx\n  char **v5; // ebx\n\n  v2 = 0;\n  while ( 1 )\n  {\n    v3 = getopt(argc, argv, \"gfu::n::p:r::m::c::k::a::B:tTiIS:D:P:X:K:A:L:W:CyYzZQ:\");\n    v4 = v3;\n    if ( v3 < 0 )\n      break;\n    ++v2;\n    byte_80DB7E0 |= v3 == 73;\n    LOBYTE(qword_80DB778) = (v3 == 105) | qword_80DB778;\n    BYTE1(qword_80DB778) |= v3 == 103;\n    BYTE2(qword_80DB778) |= v3 == 102;\n    switch ( v3 )\n    {\n      case 'u':\n        BYTE2(unk_80DB780) = sub_805202C(&unk_80DB794);\n        break;\n      case 'n':\n        *((_BYTE *)&unk_80DB780 + 5) = sub_805202C(pmatch);\n        break;\n      case 'p':\n        HIBYTE(MEMORY[0x80DB77C]) = 1;\n        if ( optarg )\n        {\n          MEMORY[0x80DB788] = (char *)sub_8052044(optarg);\n          BYTE2(MEMORY[0x80DB77C]) = (int)MEMORY[0x80DB788] >= 0;\n        }\n        break;\n      case 'r':\n        BYTE1(unk_80DB780) = sub_805202C(&unk_80DB790);\n        break;\n      case 'm':\n        HIBYTE(unk_80DB780) = sub_8052038(&dword_80DB798);\n        break;\n      case 'c':\n        *((_BYTE *)&unk_80DB780 + 7) = sub_8052038(&qword_80DB7A8);\n        break;\n      case 'k':\n        *((_BYTE *)&unk_80DB780 + 6) = sub_805202C(&dword_80DB7A4);\n        break;\n      case 'a':\n        LOBYTE(unk_80DB780) = sub_8052038(&unk_80DB78C);\n        break;\n      case 'B':\n        BYTE1(MEMORY[0x80DB7B8]) = sub_805200B(&dword_80DB7DC);\n        break;\n    }\n    LOBYTE(MEMORY[0x80DB77C]) = MEMORY[0x80DB77C] | (v4 == 116);\n    HIBYTE(qword_80DB778) |= v4 == 84;\n    BYTE2(qword_80DB778) |= HIBYTE(qword_80DB778) | (unsigned __int8)MEMORY[0x80DB77C];\n    switch ( v4 )\n    {\n      case 'S':\n        HIBYTE(MEMORY[0x80DB7AC]) = sub_805200B(&preg);\n        break;\n      case 'D':\n        BYTE2(dword_80DB7B0) = sub_8052038(&dword_80DB7D0);\n        break;\n      case 'P':\n        BYTE1(dword_80DB7B0) = sub_8052038(&dword_80DB7CC);\n        break;\n      case 'X':\n        BYTE1(MEMORY[0x80DB7AC]) = 1;\n        if ( optarg )\n        {\n          n = sub_8052044(optarg);\n          LOBYTE(MEMORY[0x80DB7AC]) = (n & 0x80000000) == 0;\n        }\n        break;\n      case 'K':\n        BYTE2(MEMORY[0x80DB7AC]) = sub_805202C(&dword_80DB7CC);\n        break;\n      case 'A':\n        LOBYTE(dword_80DB7B0) = sub_805202C(&dword_80DB7C8);\n        break;\n      case 'L':\n        LOBYTE(dword_80DB7B4) = sub_805202C(&dword_80DB7D8);\n        break;\n      case 'W':\n        HIBYTE(dword_80DB7B0) = sub_805202C(&dword_80DB7D4);\n        break;\n    }\n    LOBYTE(MEMORY[0x80DB7B8]) = (v4 == 67) | (unsigned __int8)MEMORY[0x80DB7B8];\n    BYTE2(dword_80DB7B4) |= v4 == 121;\n    HIBYTE(dword_80DB7B4) |= v4 == 89;\n    BYTE1(MEMORY[0x80DB77C]) |= v4 == 122;\n    BYTE1(dword_80DB7B4) |= v4 == 90;\n    if ( v4 == 81 )\n      *((_BYTE *)&unk_80DB780 + 4) = sub_8052038(&stream);\n  }\n  if ( !v2 )\n  {\n    BYTE1(qword_80DB778) = 1;\n    *((_WORD *)&unk_80DB780 + 3) = 257;\n    unk_80DB780 = 16843009;\n  }\n  v5 = &argv[optind];\n  if ( !*v5 )\n  {\n    if ( !isatty(0) )\n      sub_8053222();\n    sub_804CDC2();\n  }\n  do\n    sub_80538B3(*v5++);\n  while ( *v5 );\n  return 0;\n}\n"
    ],
    "sub_8054678": [
        "0x8054678",
        "int __usercall sub_8054678@<eax>(char *a1@<eax>, unsigned __int8 *a2@<edx>, __int64 a3)\n{\n  char *v5; // ecx\n  unsigned __int8 *v6; // esi\n  unsigned int v7; // edi\n  unsigned int v8; // ebp\n  __int64 v9; // rax\n  unsigned __int8 *v10; // edi\n  unsigned __int8 v11; // dl\n  int v13; // [esp+0h] [ebp-18h]\n  unsigned __int8 *v14; // [esp+4h] [ebp-14h]\n\n  v13 = sprintf(a1, \"%08llx \", a3);\n  v5 = &a1[v13];\n  v6 = (unsigned __int8 *)&a1[v13 + 48];\n  v14 = a2 + 15;\n  v7 = *(_DWORD *)(dword_80DBB80 + 32);\n  v8 = *(_DWORD *)(dword_80DBB80 + 36);\n  v9 = __PAIR64__(v8, v7) - a3;\n  if ( (int)((__PAIR64__(v8, v7) - a3) >> 32) > 0 )\n    goto LABEL_6;\n  if ( (((__PAIR64__(v8, v7) - a3) >> 32) & 0x80000000) != 0LL || !(_DWORD)v9 )\n    goto LABEL_11;\n  if ( v9 > 15 )\nLABEL_6:\n    v10 = a2 + 15;\n  else\n    v10 = &a2[v7 - 1 - a3];\n  while ( a2 <= v10 )\n  {\n    v11 = *a2++;\n    *v5 = byte_80C7B1E[v11 >> 4];\n    v5[1] = byte_80C7B1E[v11 & 0xF];\n    v5 += 3;\n    *(v5 - 1) = 32;\n    if ( (unsigned __int8)(v11 - 32) > 0x5Eu )\n      v11 = 46;\n    *v6++ = v11;\n  }\nLABEL_11:\n  while ( a2 <= v14 )\n  {\n    *v5 = 32;\n    v5[1] = 32;\n    v5 += 3;\n    *(v5 - 1) = 32;\n    *v6++ = 32;\n    ++a2;\n  }\n  *v6 = 0;\n  return v13;\n}\n"
    ],
    "sub_8054751": [
        "0x8054751",
        "int sub_8054751()\n{\n  int v0; // ebx\n  unsigned __int8 *v1; // ecx\n  int v2; // ebx\n  int v3; // eax\n  char v5[100]; // [esp+0h] [ebp-64h] BYREF\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 24) & 0xF;\n  v1 = (unsigned __int8 *)(*(_DWORD *)(dword_80DBB80 + 24) - v0);\n  v2 = *(char *)dword_80DBB80 + 3 * v0;\n  v3 = sub_8054678(v5, v1, (__int64)&v1[*(_QWORD *)(dword_80DBB80 + 40) - *(_DWORD *)(dword_80DBB80 + 20)]);\n  return printf(\"%s\\r%.*s\", &v5[v3 + v2], v3 + v2, v5);\n}\n"
    ],
    "sub_80547A0": [
        "0x80547a0",
        "int __usercall sub_80547A0@<eax>(unsigned int a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // eax\n  int v4; // eax\n  unsigned int v5; // edi\n  int v6; // esi\n  int v7; // edx\n  unsigned int i; // ebp\n  int v9; // edx\n  const char *v10; // eax\n  unsigned __int8 *v12; // [esp+0h] [ebp-74h]\n  unsigned int v13; // [esp+4h] [ebp-70h]\n  int v14; // [esp+8h] [ebp-6Ch]\n  char v15[104]; // [esp+Ch] [ebp-68h] BYREF\n\n  printf(\"\\x1B[H\\x1B[J\");\n  v2 = dword_80DBB80;\n  v3 = (a1 >> 4) + 1 - *(_DWORD *)(dword_80DBB80 + 8);\n  if ( v3 < 0 )\n    v3 = 0;\n  v4 = 16 * v3;\n  v12 = (unsigned __int8 *)(v4 + *(_DWORD *)(dword_80DBB80 + 20));\n  v5 = (*(_QWORD *)(dword_80DBB80 + 40) + (unsigned __int64)(unsigned int)v4) >> 32;\n  v6 = *(_DWORD *)(dword_80DBB80 + 40) + v4;\n  v13 = a1 - v4;\n  v7 = 0;\n  for ( i = 0; *(_DWORD *)(v2 + 8) > i; ++i )\n  {\n    v9 = sub_8054678(v15, v12, __SPAIR64__(v5, v6));\n    v10 = \"%s\";\n    if ( i )\n      v10 = \"\\r\\n%s\";\n    v14 = v9;\n    printf(v10, v15);\n    v12 += 16;\n    v5 = (__PAIR64__(v5, v6) + 16) >> 32;\n    v6 += 16;\n    v7 = v14;\n  }\n  *(_DWORD *)(v2 + 12) = v13 >> 4;\n  return printf(\"\\x1B[%u;%uH\", (v13 >> 4) + 1, v7 + 3 * (v13 & 0xF) + 1);\n}\n"
    ],
    "sub_8054863": [
        "0x8054863",
        "int sub_8054863()\n{\n  sub_804D995((const struct termios *)(dword_80DBB80 + 64));\n  printf(\"\\x1B[?1049l\");\n  return sub_804DD8F();\n}\n"
    ],
    "sub_8054880": [
        "0x8054880",
        "int __usercall sub_8054880@<eax>(int a1@<edx>, int a2)\n{\n  if ( *(_BYTE *)(dword_80DBB80 + 1) )\n  {\n    sub_8054863();\n    sub_804E761(a2);\n  }\n  byte_80DBBA4 = a2;\n  return a1;\n}\n"
    ],
    "sub_80548A8": [
        "0x80548a8",
        "int __usercall sub_80548A8@<eax>(int a1@<eax>)\n{\n  void *v2; // eax\n  int v3; // ebp\n  int v4; // edx\n  unsigned int v5; // esi\n  unsigned int v6; // edi\n  __int64 v7; // rax\n\n  v2 = *(void **)(dword_80DBB80 + 20);\n  if ( v2 )\n    munmap(v2, 0x10000u);\n  v3 = mmap64();\n  *(_DWORD *)(dword_80DBB80 + 20) = v3;\n  if ( v3 == -1 )\n  {\n    sub_8054863();\n    sub_804D3C9((int)\"mmap\");\n  }\n  *(_DWORD *)(dword_80DBB80 + 24) = v3 + a1;\n  v4 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 28) = v3 + 0x10000;\n  v5 = *(_DWORD *)(v4 + 32);\n  v6 = *(_DWORD *)(v4 + 36);\n  v7 = *(_QWORD *)(v4 + 40);\n  if ( (__int64)(__PAIR64__(v6, v5) - v7) <= 0xFFFF )\n    *(_DWORD *)(dword_80DBB80 + 28) = v3 + v5 - v7;\n  return 1;\n}\n"
    ],
    "sub_805495A": [
        "0x805495a",
        "int sub_805495A()\n{\n  int v0; // esi\n  __int64 v1; // rcx\n  unsigned int v2; // eax\n\n  v0 = dword_80DBB80;\n  v1 = *(_QWORD *)(dword_80DBB80 + 40);\n  if ( *(_QWORD *)(dword_80DBB80 + 32) - v1 <= 0xFFFF )\n    return 0;\n  v2 = *(_DWORD *)(dword_80DBB80 + 24) - *(_DWORD *)(dword_80DBB80 + 20);\n  if ( v2 <= 0xFFF )\n    return 0;\n  do\n  {\n    v1 += 4096LL;\n    if ( !v1 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 40) = -4096;\n      *(_DWORD *)(v0 + 44) = -1;\n      return sub_80548A8(v2);\n    }\n    v2 -= 4096;\n  }\n  while ( v2 > 0xFFF );\n  *(_DWORD *)(dword_80DBB80 + 40) = v1;\n  *(_DWORD *)(v0 + 44) = HIDWORD(v1);\n  return sub_80548A8(v2);\n}\n"
    ],
    "sub_80549CA": [
        "0x80549ca",
        "int sub_80549CA()\n{\n  int v0; // edx\n  unsigned int v2; // eax\n  __int64 v3; // rcx\n\n  v0 = dword_80DBB80;\n  if ( !*(_QWORD *)(dword_80DBB80 + 40) )\n    return 0;\n  v2 = *(_DWORD *)(dword_80DBB80 + 24) - *(_DWORD *)(dword_80DBB80 + 20) + 4096;\n  if ( v2 > 0xFFFF )\n    return sub_80548A8(*(_DWORD *)(dword_80DBB80 + 24) - *(_DWORD *)(dword_80DBB80 + 20));\n  do\n  {\n    v2 += 4096;\n    v3 = *(_QWORD *)(v0 + 40) - 4096LL;\n    *(_QWORD *)(v0 + 40) = v3;\n  }\n  while ( v3 && v2 <= 0xFFFF );\n  return sub_80548A8(v2 - 4096);\n}\n"
    ],
    "sub_8054A29": [
        "0x8054a29",
        "int __usercall sub_8054A29@<eax>(int a1@<esi>, int a2, int a3)\n{\n  char *v3; // ebx\n  size_t v4; // edi\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ebx\n  int v8; // edi\n  __int64 v9; // rax\n  _BYTE *v10; // edx\n  char v11; // al\n  unsigned __int8 *v12; // edx\n  unsigned __int8 *v13; // ecx\n  unsigned __int8 v14; // al\n  char *v15; // ecx\n  char v16; // al\n  unsigned __int8 *v17; // edx\n  int v18; // edi\n  char *v19; // ecx\n  char v20; // al\n  _BYTE *v21; // edx\n  unsigned int v22; // eax\n  unsigned int v23; // eax\n  unsigned int v24; // eax\n  _BYTE *v25; // edx\n  int v26; // eax\n  int v27; // eax\n  int v28; // eax\n  __int64 v29; // rax\n  unsigned int v30; // edi\n  unsigned int v31; // ebp\n  unsigned int v32; // edi\n  __int64 v33; // rax\n  unsigned int v35; // [esp+0h] [ebp-34h]\n  int v36; // [esp+4h] [ebp-30h]\n  char v37[44]; // [esp+8h] [ebp-2Ch] BYREF\n\n  v3 = (char *)sub_804DB2E(0x7Cu);\n  dword_80DBB80 = (int)v3;\n  sub_804D878(-1, 0, (int *)v3 + 2);\n  v4 = 88 * (*((_DWORD *)v3 + 2) | 0xF);\n  v5 = (char *)sub_804DAFA(v4);\n  setvbuf(stdout, v5, 0, v4);\n  sub_80ABEAC(a3, \"^\");\n  *((_DWORD *)v3 + 1) = sub_804DBE1(*(const char **)(a3 + 4 * optind));\n  *((_DWORD *)v3 + 8) = sub_804DD09(0, 0, 2);\n  *((_DWORD *)v3 + 9) = v6;\n  printf(\"\\x1B[?1049h\");\n  sub_804DA14(6, (struct termios *)(v3 + 64), 0);\n  sub_804E6C8(117503054, (void (*)(int))sub_8054880);\n  sub_80548A8(0);\n  sub_80547A0(0);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\nLABEL_2:\n      sub_804DD8F();\n      v7 = dword_80DBB80;\n      *(_BYTE *)(dword_80DBB80 + 1) = 1;\n      if ( !byte_80DBBA4 )\n        a1 = sub_80B20CC(-1, v7 + 48, v35, v36);\n      *(_BYTE *)(v7 + 1) = 0;\n      if ( byte_80DBBA4 )\n        a1 = 24;\n      if ( (unsigned int)(a1 - 65) <= 0x19 )\n        a1 |= 0x20u;\n      if ( a1 == 10 )\n        break;\n      if ( a1 > 10 )\n      {\n        if ( a1 > 57 )\n        {\n          if ( (unsigned int)(a1 - 97) <= 5 )\n          {\n            a1 -= 39;\n            goto LABEL_26;\n          }\n        }\n        else if ( a1 >= 48 )\n        {\nLABEL_26:\n          if ( *(_DWORD *)(v7 + 24) != *(_DWORD *)(v7 + 28) || sub_805495A() )\n            goto LABEL_32;\n          v9 = *(_QWORD *)(v7 + 32) + 1LL;\n          *(_QWORD *)(v7 + 32) = v9;\n          if ( v9 <= 0 || ftruncate64() )\n          {\n            --*(_QWORD *)(v7 + 32);\n          }\n          else\n          {\n            ++*(_DWORD *)(v7 + 28);\nLABEL_32:\n            a1 -= 48;\n            v10 = *(_BYTE **)(v7 + 24);\n            v11 = *v10 & 0xF0;\n            if ( !*(_BYTE *)v7 )\n            {\n              v11 = *v10 & 0xF;\n              a1 *= 16;\n            }\n            *v10 = a1 + v11;\n            sub_8054751();\nLABEL_35:\n            v12 = *(unsigned __int8 **)(v7 + 24);\n            v13 = *(unsigned __int8 **)(v7 + 28);\n            if ( v12 != v13 )\n            {\n              v14 = *v12;\n              if ( *(_BYTE *)v7 )\n              {\n                *(_BYTE *)v7 = 0;\n                v17 = v12 + 1;\n                *(_DWORD *)(v7 + 24) = v17;\n                if ( ((unsigned __int8)v17 & 0xF) != 0 )\n                {\n                  v19 = *(char **)(_stdout + 16);\n                  v20 = byte_80C7B1E[v14 & 0xF];\n                  if ( (unsigned int)v19 >= *(_DWORD *)(_stdout + 28) )\n                  {\n                    __fputc_unlocked();\n                  }\n                  else\n                  {\n                    *(_DWORD *)(_stdout + 16) = v19 + 1;\n                    *v19 = v20;\n                  }\n                  v21 = *(_BYTE **)(_stdout + 16);\n                  if ( (unsigned int)v21 >= *(_DWORD *)(_stdout + 28) )\n                  {\nLABEL_49:\n                    __fputc_unlocked();\n                  }\n                  else\n                  {\n                    *(_DWORD *)(_stdout + 16) = v21 + 1;\n                    *v21 = 32;\n                  }\n                }\n                else\n                {\n                  if ( v13 == v17 )\n                    sub_805495A();\n                  printf(\"\\x1B[46D\");\n                  v18 = 1;\n                  while ( 1 )\n                  {\n                    v25 = *(_BYTE **)(_stdout + 16);\n                    if ( (unsigned int)v25 >= *(_DWORD *)(_stdout + 28) )\n                    {\n                      __fputc_unlocked();\n                    }\n                    else\n                    {\n                      *(_DWORD *)(_stdout + 16) = v25 + 1;\n                      *v25 = 10;\n                    }\n                    v26 = *(_DWORD *)(v7 + 12);\n                    *(_DWORD *)(v7 + 12) = v26 + 1;\n                    if ( (unsigned int)(v26 + 1) >= *(_DWORD *)(v7 + 8) )\n                    {\n                      *(_DWORD *)(v7 + 12) = v26;\n                      sub_8054751();\n                    }\n                    if ( !--v18 )\n                      break;\nLABEL_52:\n                    v22 = *(_DWORD *)(v7 + 24) + 16;\n                    *(_DWORD *)(v7 + 24) = v22;\n                    if ( v22 >= *(_DWORD *)(v7 + 28) )\n                    {\n                      sub_805495A();\n                      v23 = *(_DWORD *)(v7 + 24);\n                      if ( v23 > *(_DWORD *)(v7 + 28) )\n                      {\n                        v24 = v23 - 16;\n                        *(_DWORD *)(v7 + 24) = v24;\n                        if ( v24 < *(_DWORD *)(v7 + 20) )\n                          sub_80549CA();\n                        goto LABEL_2;\n                      }\n                    }\n                  }\n                }\n              }\n              else\n              {\n                *(_BYTE *)v7 = 1;\n                v15 = *(char **)(_stdout + 16);\n                v16 = byte_80C7B1E[v14 >> 4];\n                if ( (unsigned int)v15 >= *(_DWORD *)(_stdout + 28) )\n                  goto LABEL_49;\n                *(_DWORD *)(_stdout + 16) = v15 + 1;\n                *v15 = v16;\n              }\n            }\n          }\n        }\n        else\n        {\n          if ( a1 == 13 )\n            break;\n          if ( a1 == 24 )\n            goto LABEL_88;\n        }\n      }\n      else if ( a1 == -5 )\n      {\n        if ( *(_BYTE *)v7 )\n        {\n          *(_BYTE *)v7 = 0;\n          printf(\"\\x1B[D\");\n        }\n        else\n        {\n          v27 = *(_DWORD *)(v7 + 24);\n          if ( (v27 & 0xF) != 0 )\n          {\n            *(_BYTE *)v7 = 1;\n            *(_DWORD *)(v7 + 24) = v27 - 1;\n            printf(\"\\x1B[2D\");\n          }\n          else if ( v27 != *(_DWORD *)(v7 + 20) || sub_80549CA() )\n          {\n            *(_BYTE *)v7 = 1;\n            --*(_DWORD *)(v7 + 24);\n            printf(\"\\x1B[46C\");\n            v8 = 1;\n            while ( 1 )\n            {\n              v28 = *(_DWORD *)(v7 + 12);\n              if ( v28 )\n              {\n                *(_DWORD *)(v7 + 12) = v28 - 1;\n                printf(\"\\x1B[A\");\n              }\n              else\n              {\n                printf(\"\\x1BM\");\n                sub_8054751();\n              }\n              if ( !--v8 )\n                break;\nLABEL_76:\n              if ( *(_DWORD *)(v7 + 24) - *(_DWORD *)(v7 + 20) <= 15 && !sub_80549CA() )\n                goto LABEL_2;\n              *(_DWORD *)(v7 + 24) -= 16;\n            }\n          }\n        }\n      }\n      else if ( a1 > -5 )\n      {\n        if ( a1 == -3 )\n        {\n          v18 = 1;\n          goto LABEL_52;\n        }\n        if ( a1 < -3 )\n          goto LABEL_35;\n        if ( a1 == -2 )\n        {\n          v8 = 1;\n          goto LABEL_76;\n        }\n      }\n      else\n      {\n        if ( a1 == -11 )\n        {\n          v18 = *(_DWORD *)(v7 + 8);\n          goto LABEL_52;\n        }\n        if ( a1 == -10 )\n        {\n          v8 = *(_DWORD *)(v7 + 8);\n          goto LABEL_76;\n        }\n      }\n    }\n    printf(\"\\x1B[999;1H\\x1B[K\");\n    if ( (int)sub_80AED5C(28) <= 0 )\n      break;\n    v29 = sub_804EC9E(v37, 0, 0);\n    v30 = *(_DWORD *)(v7 + 32);\n    v31 = *(_DWORD *)(v7 + 36);\n    if ( __SPAIR64__(v31, v30) <= v29 )\n      v29 = __PAIR64__(v31, v30) - 1;\n    v32 = v29 & 0xFFF;\n    v35 = v32;\n    v36 = 0;\n    v33 = v29 - (v29 & 0xFFF);\n    if ( v33 < 0 )\n    {\n      v32 = 0;\n      v33 = 0LL;\n    }\n    else if ( v33 && v32 <= 0x1FE )\n    {\n      v33 -= 4096LL;\n      v32 += 4096;\n    }\n    *(_QWORD *)(v7 + 40) = v33;\n    sub_80548A8(v32);\n    sub_80547A0(v32);\n  }\nLABEL_88:\n  sub_8054863();\n  return 0;\n}\n"
    ],
    "sub_8054EAD": [
        "0x8054ead",
        "int sub_8054EAD()\n{\n  return sub_80B4093(0xFFFFF);\n}\n"
    ],
    "sub_8054EBF": [
        "0x8054ebf",
        "int __usercall sub_8054EBF@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  char s[28]; // [esp+0h] [ebp-1Ch] BYREF\n\n  sprintf(s, \"/dev/i2c-%d\", a1);\n  result = open64();\n  if ( result < 0 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n      sub_804D3C9((int)\"can't open '%s'\", s);\n    s[8] = 47;\n    return sub_804DBE1(s);\n  }\n  return result;\n}\n"
    ],
    "sub_8054F0F": [
        "0x8054f0f",
        "int __usercall sub_8054F0F@<eax>(int result@<eax>, int a2@<edx>, const char *a3@<ecx>)\n{\n  int v4; // [esp-4h] [ebp-8h]\n\n  if ( a2 && (result & 9) == 0 )\n  {\n    sub_804D5F4(\"warning: adapter does not support PEC\");\n    result = v4;\n  }\n  if ( a3 )\n    sub_804D5E0(\"adapter has no %s capability\", a3);\n  return result;\n}\n"
    ],
    "sub_8054F36": [
        "0x8054f36",
        "int __usercall sub_8054F36@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5)\n{\n  const char *v7; // ecx\n  int v9; // [esp+0h] [ebp-Ch] BYREF\n\n  v9 = a4;\n  sub_804E029(a1, 0x705u, (int)&v9, \"can't get adapter functionality matrix\");\n  switch ( a2 )\n  {\n    case 1:\n      v7 = \"SMBus receive byte\";\n      if ( (v9 & 0x20000) != 0 )\n      {\n        v7 = 0;\n        if ( a3 >= 0 && (v9 & 0x40000) == 0 )\n          v7 = \"SMBus send byte\";\n      }\n      break;\n    case 2:\n      v7 = 0;\n      if ( (v9 & 0x80000) == 0 )\n        v7 = \"SMBus read byte\";\n      break;\n    case 3:\n      v7 = 0;\n      if ( (v9 & 0x200000) == 0 )\n        v7 = \"SMBus read word\";\n      break;\n    case 5:\n      v7 = 0;\n      if ( (v9 & 0x1000000) == 0 )\n        v7 = \"SMBus block read\";\n      break;\n    case 8:\n      v7 = 0;\n      if ( (v9 & 0x4000000) == 0 )\n        v7 = \"I2C block read\";\n      break;\n    default:\n      sub_804D5E0(\"internal error\");\n  }\n  sub_8054F0F(v9, a5, v7);\n  return v9;\n}\n"
    ],
    "sub_8054FDF": [
        "0x8054fdf",
        "int __usercall sub_8054FDF@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  return sub_804E029(a1, a3 == 0 ? 1795 : 1798, a2, \"can't set address to 0x%02x\", a2);\n}\n"
    ],
    "sub_8054FFF": [
        "0x8054fff",
        "int sub_8054FFF()\n{\n  int result; // eax\n\n  fputs(\"Continue? [y/N] \", stderr);\n  result = sub_80A96FD();\n  if ( !result )\n    sub_804D5E0(\"aborting\");\n  return result;\n}\n"
    ],
    "sub_8055025": [
        "0x8055025",
        "int __usercall sub_8055025@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)\n{\n  sub_804D5F4(\"WARNING! This program can confuse your I2C bus\");\n  if ( (unsigned int)(a1 - 80) > 7 )\n  {\n    if ( a2 == 1 && a3 >= 0 )\n    {\n      if ( !a4 )\n        return sub_8054FFF();\n      sub_804D5F4(\"WARNING! May interpret a write byte command with PEC as a write byte data command\");\n    }\n    else if ( !a4 )\n    {\n      return sub_8054FFF();\n    }\n    sub_804D5F4(\"PEC checking enabled\");\n    return sub_8054FFF();\n  }\n  if ( a4 )\n    sub_804D5E0(\"this is I2C not smbus - using PEC on I2C devices may result in data loss, aborting\");\n  return sub_8054FFF();\n}\n"
    ],
    "sub_8055084": [
        "0x8055084",
        "int __usercall sub_8055084@<eax>(int a1@<eax>, char a2@<dl>, char a3@<cl>, int a4, int a5)\n{\n  char v6[4]; // [esp+0h] [ebp-Ch] BYREF\n  int v7; // [esp+4h] [ebp-8h]\n  int v8; // [esp+8h] [ebp-4h]\n\n  v6[0] = a2;\n  v6[1] = a3;\n  v7 = a4;\n  v8 = a5;\n  return ioctl(a1, 0x720u, v6);\n}\n"
    ],
    "sub_80550AE": [
        "0x80550ae",
        "int __usercall sub_80550AE@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  char v2[34]; // [esp+2h] [ebp-22h] BYREF\n\n  result = sub_8055084(a1, 1, 0, 1, (int)v2);\n  if ( result >= 0 )\n    return (unsigned __int8)v2[0];\n  return result;\n}\n"
    ],
    "sub_80550D3": [
        "0x80550d3",
        "int __usercall sub_80550D3@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int result; // eax\n  unsigned __int16 v3[17]; // [esp+2h] [ebp-22h] BYREF\n\n  result = sub_8055084(a1, 1, a2, 3, (int)v3);\n  if ( result >= 0 )\n    return v3[0];\n  return result;\n}\n"
    ],
    "sub_80550F9": [
        "0x80550f9",
        "int __usercall sub_80550F9@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int result; // eax\n  char v3[34]; // [esp+2h] [ebp-22h] BYREF\n\n  result = sub_8055084(a1, 1, a2, 2, (int)v3);\n  if ( result >= 0 )\n    return (unsigned __int8)v3[0];\n  return result;\n}\n"
    ],
    "sub_805511F": [
        "0x805511f",
        "void __noreturn sub_805511F()\n{\n  int v0; // eax\n  const char *v1; // ebx\n  int v2; // edx\n  int v3; // eax\n  int v4; // edi\n  char *v5; // eax\n  int v6; // ebx\n  int v7; // edi\n  FILE *stream; // [esp+0h] [ebp-19Ch]\n  FILE *streama; // [esp+0h] [ebp-19Ch]\n  int v10; // [esp+4h] [ebp-198h] BYREF\n  int v11; // [esp+8h] [ebp-194h] BYREF\n  char v12[128]; // [esp+Dh] [ebp-18Fh] BYREF\n  char s[271]; // [esp+8Dh] [ebp-10Fh] BYREF\n\n  sub_804DF7E(\"/sys/class/i2c-dev\");\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      do\n      {\nLABEL_2:\n        v0 = readdir64();\n        if ( !v0 )\n          exit(0);\n      }\n      while ( *(_BYTE *)(v0 + 19) == 46 );\n      v1 = (const char *)(v0 + 19);\n      snprintf(s, 0xFFu, \"%s/%s/name\", \"/sys/class/i2c-dev\", (const char *)(v0 + 19));\n      v2 = fopen64();\n      if ( v2 )\n        break;\n      snprintf(s, 0xFFu, \"%s/%s/device/name\", \"/sys/class/i2c-dev\", v1);\n      v2 = fopen64();\n      if ( v2 )\n        break;\n      snprintf(s, 0xFFu, \"%s/%s/device/name\", \"/sys/class/i2c-dev\", v1);\n      if ( opendir(s) )\n      {\n        while ( 1 )\n        {\n          v3 = readdir64();\n          if ( !v3 )\n            goto LABEL_2;\n          if ( *(_BYTE *)(v3 + 19) != 46 )\n          {\n            stream = (FILE *)(v3 + 19);\n            if ( sub_804D210((_BYTE *)(v3 + 19), \"i2c-\") )\n              break;\n          }\n        }\n        snprintf(s, 0xFFu, \"%s/%s/device/%s/name\", \"/sys/class/i2c-dev\", v1, (const char *)stream);\n        v2 = fopen64();\n        if ( v2 )\n          break;\n      }\n    }\n    memset(v12, 0, sizeof(v12));\n    streama = (FILE *)v2;\n    v4 = fgets_unlocked();\n    fclose(streama);\n    if ( v4 )\n    {\n      v5 = strchr(v12, 10);\n      if ( v5 )\n        *v5 = 0;\n      if ( sscanf(v1, \"i2c-%d\", &v10) == 1 )\n      {\n        v6 = 1;\n        if ( !sub_804D210(v12, \"ISA\") )\n        {\n          v7 = sub_8054EBF(v10);\n          sub_804E029(v7, 0x705u, (int)&v11, \"can't get adapter functionality matrix\");\n          v6 = 2;\n          if ( (v11 & 1) == 0 )\n            v6 = (v11 & 0x7E0000) != 0 ? 3 : 0;\n          close(v7);\n        }\n        printf(\"i2c-%d\\t%-10s\\t%-32s\\t%s\\n\", v10, off_80B5500[2 * v6], v12, off_80B5504[2 * v6]);\n      }\n    }\n  }\n}\n"
    ],
    "sub_805531E": [
        "0x805531e",
        "int __cdecl sub_805531E(int a1, int a2)\n{\n  int v2; // esi\n  int v3; // edi\n  int v4; // ebx\n  char *v5; // eax\n  char v6; // dl\n  int v7; // esi\n  int v8; // ebp\n  int v9; // edi\n  int v10; // eax\n  int v11; // ebx\n  char v13; // [esp+8h] [ebp-18h]\n  int v14; // [esp+Ch] [ebp-14h]\n\n  v13 = sub_80ABEAC(a2, \"^fy\");\n  v2 = a2 + 4 * optind;\n  v3 = sub_8054EAD();\n  v14 = sub_80B4093(119);\n  if ( *(_DWORD *)(v2 + 8) )\n  {\n    v4 = sub_80B4093(255);\n    v5 = *(char **)(v2 + 12);\n    if ( v5 )\n    {\n      v6 = *v5;\n      if ( *v5 == 99 )\n      {\n        v7 = 1;\n      }\n      else if ( v6 == 119 )\n      {\n        v7 = 3;\n      }\n      else\n      {\n        if ( v6 != 98 )\n        {\n          sub_804D5F4(\"invalid mode\");\n          sub_804CDC2();\n        }\n        v7 = 2;\n      }\n      v8 = v5[1] == 112;\n    }\n    else\n    {\n      v8 = 0;\n      v7 = 2;\n    }\n  }\n  else\n  {\n    v8 = 0;\n    v7 = 1;\n    v4 = -1;\n  }\n  v9 = sub_8054EBF(v3);\n  sub_8054F36(v9, v7, v4, v4, v8);\n  sub_8054FDF(v9, v14, v13 & 1);\n  if ( (v13 & 2) == 0 )\n    sub_8055025(v14, v7, v4, v8);\n  if ( v8 )\n    sub_804E029(v9, 0x708u, 1, \"can't set PEC\");\n  if ( v7 == 1 )\n  {\n    if ( v4 >= 0 && sub_8055084(v9, 0, v4, 1, 0) < 0 )\n      sub_804D5F4(\"warning - write failed\");\n    v10 = sub_80550AE(v9);\n  }\n  else if ( v7 == 3 )\n  {\n    v10 = sub_80550D3(v9, v4);\n  }\n  else\n  {\n    v10 = sub_80550F9(v9, v4);\n  }\n  v11 = v10;\n  close(v9);\n  if ( v11 < 0 )\n    sub_804D3C9((int)\"read failed\");\n  printf(\"0x%0*x\\n\", 2 * (v7 == 3) + 2, v11);\n  return 0;\n}\n"
    ],
    "sub_80554B0": [
        "0x80554b0",
        "int __cdecl sub_80554B0(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // edi\n  _BYTE *v4; // eax\n  char *v5; // ecx\n  char v6; // dl\n  int v7; // ebp\n  int v8; // ebx\n  int i; // esi\n  int v10; // edi\n  const char *v11; // ecx\n  int v12; // eax\n  int v13; // eax\n  int v14; // eax\n  int v16; // [esp+8h] [ebp-74h]\n  int v17; // [esp+8h] [ebp-74h]\n  unsigned int v18; // [esp+Ch] [ebp-70h]\n  _BOOL4 fd; // [esp+10h] [ebp-6Ch]\n  int v20; // [esp+14h] [ebp-68h]\n  char v21; // [esp+18h] [ebp-64h]\n  int v22; // [esp+1Ch] [ebp-60h]\n  int v23; // [esp+24h] [ebp-58h] BYREF\n  int v24[8]; // [esp+28h] [ebp-54h] BYREF\n  int v25[2]; // [esp+48h] [ebp-34h] BYREF\n\n  v23 = 0;\n  v21 = sub_80ABEAC(a2, \"^fym:r\", &v23);\n  v2 = a2 + 4 * optind;\n  v3 = a1 - optind - 1;\n  v16 = sub_8054EAD();\n  v22 = sub_80B4093(119);\n  v20 = sub_80B4093(255);\n  v4 = *(_BYTE **)(v2 + 12);\n  if ( v4 )\n  {\n    if ( *(_DWORD *)(v2 + 16) || *v4 == 99 )\n    {\n      v5 = *(char **)(v2 + 4 * v3);\n      v6 = *v5;\n      if ( *v5 == 105 )\n      {\n        v7 = 8;\n      }\n      else if ( (unsigned __int8)*v5 > 0x69u )\n      {\n        if ( v6 == 115 )\n        {\n          v7 = 5;\n        }\n        else\n        {\n          v7 = 3;\n          if ( v6 != 119 )\n          {\nLABEL_14:\n            sub_804D5F4(\"invalid mode\", v16);\n            sub_804CDC2();\n          }\n        }\n      }\n      else if ( v6 == 98 )\n      {\n        v7 = 2;\n      }\n      else\n      {\n        if ( v6 != 99 )\n          goto LABEL_14;\n        v7 = 1;\n      }\n      fd = v5[1] == 112;\n      switch ( v7 )\n      {\n        case 5:\n          goto LABEL_23;\n        case 8:\n          if ( v5[1] == 112 )\n            sub_804D5E0(\"PEC not supported for I2C block writes\", v16);\nLABEL_23:\n          if ( (v21 & 4) != 0 )\n            sub_804D5E0(\"mask not supported for block writes\", v16);\n          for ( i = 3; ; ++i )\n          {\n            v18 = i - 3;\n            if ( i >= v3 )\n              break;\n            *((_BYTE *)&v23 + i + 1) = sub_80B4093(255);\n          }\n          goto LABEL_37;\n        case 3:\n          v8 = sub_80B4093(0xFFFF);\n          v7 = 3;\n          goto LABEL_32;\n      }\n      if ( v7 != 2 )\n        goto LABEL_36;\n    }\n    else\n    {\n      fd = 0;\n    }\n    v8 = sub_80B4093(255);\n    v7 = 2;\nLABEL_32:\n    v18 = 0;\n    goto LABEL_38;\n  }\n  fd = 0;\n  v7 = 1;\nLABEL_36:\n  v18 = 0;\nLABEL_37:\n  v8 = -1;\nLABEL_38:\n  v10 = 0;\n  if ( (v21 & 4) != 0 )\n    v10 = sub_80B4093((unsigned int)(v7 - 1) < 2 ? 255 : 0xFFFF);\n  v17 = sub_8054EBF(v16);\n  sub_804E029(v17, 0x705u, (int)v25, \"can't get adapter functionality matrix\");\n  v11 = 0;\n  switch ( v7 )\n  {\n    case 1:\n      if ( (v25[0] & 0x40000) == 0 )\n        v11 = \"SMBus send byte\";\n      break;\n    case 2:\n      if ( (v25[0] & 0x100000) == 0 )\n        v11 = \"SMBus write byte\";\n      break;\n    case 3:\n      if ( (v25[0] & 0x400000) == 0 )\n        v11 = \"SMBus write word\";\n      break;\n    case 5:\n      if ( (v25[0] & 0x2000000) == 0 )\n        v11 = \"SMBus block write\";\n      break;\n    case 8:\n      if ( (v25[0] & 0x8000000) == 0 )\n        v11 = \"I2C block write\";\n      break;\n    default:\n      break;\n  }\n  sub_8054F0F(v25[0], fd, v11);\n  sub_8054FDF(v17, v22, v21 & 1);\n  if ( (v21 & 2) == 0 )\n    sub_8055025(v22, v7, v20, fd);\n  if ( (v21 & 4) != 0 )\n  {\n    if ( v7 == 1 )\n    {\n      v12 = sub_80550AE(v17);\n    }\n    else if ( v7 == 3 )\n    {\n      v12 = sub_80550D3(v17, v20);\n    }\n    else\n    {\n      v12 = sub_80550F9(v17, v20);\n    }\n    if ( v12 < 0 )\n      sub_804D3C9((int)\"can't read old value\");\n    v8 = v12 ^ v10 & (v12 ^ v8);\n    if ( (v21 & 2) == 0 )\n    {\n      sub_804D5F4(\n        \"old value 0x%0*x, write mask 0x%0*x, will write 0x%0*x to register 0x%02x\",\n        2 * (v7 == 3) + 2,\n        v12,\n        2 * (v7 == 3) + 2,\n        v10,\n        2 * (v7 == 3) + 2,\n        v8,\n        v20);\n      sub_8054FFF();\n    }\n  }\n  if ( fd )\n    sub_804E029(v17, 0x708u, 1, \"can't set PEC\");\n  if ( v7 == 3 )\n  {\n    LOWORD(v25[0]) = v8;\n    v13 = sub_8055084(v17, 0, v20, 3, (int)v25);\n  }\n  else if ( v7 > 3 )\n  {\n    qmemcpy((char *)v25 + 1, v24, v18);\n    LOBYTE(v25[0]) = v18;\n    if ( v7 == 5 )\n      v13 = sub_8055084(v17, 0, v20, 5, (int)v25);\n    else\n      v13 = sub_8055084(v17, 0, v20, 6, (int)v25);\n  }\n  else if ( v7 == 1 )\n  {\n    v13 = sub_8055084(v17, 0, v20, 1, 0);\n  }\n  else\n  {\n    LOBYTE(v25[0]) = v8;\n    v13 = sub_8055084(v17, 0, v20, 2, (int)v25);\n  }\n  if ( v13 < 0 )\n    sub_804D3C9(135047154);\n  if ( fd )\n    sub_804E029(v17, 0x708u, 0, \"can't set PEC\");\n  if ( (v21 & 8) != 0 )\n  {\n    if ( v7 == 1 )\n    {\n      v14 = sub_80550AE(v17);\n      v8 = v20;\n    }\n    else if ( v7 == 3 )\n    {\n      v14 = sub_80550D3(v17, v20);\n    }\n    else\n    {\n      v14 = sub_80550F9(v17, v20);\n    }\n    if ( v14 >= 0 )\n    {\n      if ( v8 == v14 )\n        printf(\"Value 0x%0*x written, readback matched\\n\", 2 * (v7 == 3) + 2, v8);\n      else\n        printf(\n          \"Warning - data mismatch - wrote 0x%0*x, read back 0x%0*x\\n\",\n          2 * (v7 == 3) + 2,\n          v8,\n          2 * (v7 == 3) + 2,\n          v14);\n    }\n    else\n    {\n      puts(\"Warning - readback failed\");\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_805595A": [
        "0x805595a",
        "int __cdecl sub_805595A(int a1, int a2)\n{\n  char v2; // di\n  int v3; // ebx\n  char *v4; // edx\n  char v5; // al\n  int v6; // ebx\n  int v7; // ebp\n  int v8; // esi\n  unsigned int v9; // eax\n  int v10; // ebx\n  int i; // eax\n  int j; // esi\n  int k; // eax\n  int m; // eax\n  int n; // edi\n  int ii; // esi\n  int v17; // eax\n  int v18; // eax\n  int v19; // eax\n  unsigned int v20; // esi\n  int v21; // eax\n  unsigned int v22; // esi\n  int v23; // eax\n  unsigned int v25; // [esp+8h] [ebp-560h]\n  int v26; // [esp+Ch] [ebp-55Ch]\n  int v27; // [esp+Ch] [ebp-55Ch]\n  unsigned int v28; // [esp+10h] [ebp-558h]\n  int fd; // [esp+14h] [ebp-554h]\n  int *fda; // [esp+14h] [ebp-554h]\n  int v31; // [esp+18h] [ebp-550h]\n  int *v32; // [esp+24h] [ebp-544h]\n  char *v33; // [esp+30h] [ebp-538h] BYREF\n  char *v34[2]; // [esp+34h] [ebp-534h] BYREF\n  int v35[260]; // [esp+158h] [ebp-410h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^fyr:\", &v33);\n  v3 = a2 + 4 * optind;\n  v26 = sub_8054EAD();\n  fd = sub_80B4093(119);\n  v4 = *(char **)(v3 + 8);\n  if ( !v4 )\n  {\n    v8 = 0;\n    v6 = 0;\n    v7 = 2;\n    goto LABEL_25;\n  }\n  v5 = *v4;\n  if ( *v4 == 99 )\n  {\n    v6 = 0;\n    v7 = 1;\n  }\n  else\n  {\n    if ( (unsigned __int8)*v4 <= 0x63u )\n    {\n      if ( v5 != 87 )\n      {\n        if ( v5 != 98 )\nLABEL_15:\n          sub_804D5E0(\"invalid mode\");\n        v6 = 0;\n        v7 = 2;\n        goto LABEL_18;\n      }\n      v6 = 1;\nLABEL_13:\n      v7 = 3;\n      goto LABEL_18;\n    }\n    if ( v5 != 115 )\n    {\n      if ( v5 != 119 )\n      {\n        if ( v5 != 105 )\n          goto LABEL_15;\n        v6 = 0;\n        v7 = 8;\n        goto LABEL_18;\n      }\n      v6 = 0;\n      goto LABEL_13;\n    }\n    v6 = 0;\n    v7 = 5;\n  }\nLABEL_18:\n  if ( v4[1] == 112 )\n  {\n    if ( v5 == 87 || v5 == 105 )\n      sub_804D5E0(\"pec not supported for -W and -i\");\n    v8 = 1;\n  }\n  else\n  {\n    v8 = 0;\n  }\nLABEL_25:\n  v25 = v2 & 4;\n  if ( (v2 & 4) != 0 )\n  {\n    v25 = strtol(v33, v34, 0);\n    if ( v34[0] == v33 || *v34[0] != 45 || v25 > 0xFF )\n      sub_804D5E0(\"invalid range\");\n    ++v34[0];\n    v9 = sub_80B4093(255);\n    v28 = v9;\n    if ( v7 > 2 && (v7 != 3 || v6 && ((v25 & 1) != 0 || (v9 & 1) == 0)) )\n      sub_804D5E0(\"range not compatible with selected mode\");\n  }\n  else\n  {\n    v28 = 255;\n  }\n  v27 = sub_8054EBF(v26);\n  sub_8054F36(v27, v7, -1, v6, v8);\n  sub_8054FDF(v27, fd, v2 & 1);\n  if ( v8 )\n    sub_804E029(v27, 0x708u, 1, \"can't set PEC\");\n  if ( (v2 & 2) == 0 )\n    sub_8055025(fd, v7, -1, v8);\n  switch ( v7 )\n  {\n    case 3:\n      if ( !v6 )\n      {\n        puts(\"     0,8  1,9  2,a  3,b  4,c  5,d  6,e  7,f\");\n        do\n        {\n          if ( v6 >> 3 >= v25 >> 3 )\n          {\n            if ( v6 >> 3 > v28 >> 3 )\n              return 0;\n            printf(\"%02x: \", v6);\n            v22 = v6;\n            do\n            {\n              if ( v25 <= v22 && v28 >= v22 )\n              {\n                v23 = sub_80550D3(v27, v22);\n                if ( v23 >= 0 )\n                  printf(\"%04x \", (unsigned __int16)v23);\n                else\n                  printf(\"XXXX \");\n              }\n              else\n              {\n                printf(\"     \");\n              }\n              ++v22;\n            }\n            while ( v6 + 8 != v22 );\n            sub_804DD98(10);\n          }\n          v6 += 8;\n        }\n        while ( v6 != 256 );\n        return 0;\n      }\n      break;\n    case 5:\n      v10 = sub_8055084(v27, 1, 0, 5, (int)v35);\n      if ( v10 < 0 )\n        goto LABEL_64;\n      v10 = LOBYTE(v35[0]);\n      for ( i = 1; i <= v10; ++i )\n        *((_BYTE *)v34 + i + 3) = *((_BYTE *)v35 + i);\n      if ( !v10 )\nLABEL_64:\n        sub_804D5E0(\"block read failed: %d\", v10);\n      goto LABEL_68;\n    case 8:\n      for ( j = 0; j <= 255; j += v10 )\n      {\n        LOBYTE(v35[0]) = 32;\n        v10 = sub_8055084(v27, 1, j, 6, (int)v35);\n        if ( v10 < 0 )\n          goto LABEL_64;\n        v10 = LOBYTE(v35[0]);\n        for ( k = 1; k <= v10; ++k )\n          *((_BYTE *)v34 + j + k + 3) = *((_BYTE *)v35 + k);\n        if ( !v10 )\n          goto LABEL_64;\n      }\n      for ( m = 0; m != 256; ++m )\n        v35[m] = *((unsigned __int8 *)&v34[1] + m);\n      break;\n    default:\n      v10 = 0;\n      if ( v7 == 1 && sub_8055084(v27, 0, v25, 1, 0) < 0 )\n        sub_804D3C9((int)\"write start address\");\n      goto LABEL_68;\n  }\n  v10 = 0;\nLABEL_68:\n  puts(\"     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef\");\n  for ( n = 0; n != 256; n += 16 )\n  {\n    if ( v10 <= n && v7 == 5 )\n      break;\n    if ( n >> 4 < v25 >> 4 )\n      continue;\n    if ( n >> 4 > v28 >> 4 )\n      break;\n    printf(\"%02x: \", n);\n    for ( ii = 0; ii <= 15; ++ii )\n    {\n      sub_804DD8F();\n      v17 = n + ii;\n      if ( v28 < n + ii || v25 > v17 )\n      {\n        printf(\"   \");\n        if ( v7 != 3 )\n          continue;\n        printf(\"   \");\nLABEL_96:\n        ++ii;\n        continue;\n      }\n      v31 = v17;\n      fda = &v35[v17];\n      switch ( v7 )\n      {\n        case 2:\n          v18 = sub_80550F9(v27, n + ii);\n          break;\n        case 3:\n          v19 = sub_80550D3(v27, n + ii);\n          v32 = &v35[v31 + 1];\n          if ( v19 < 0 )\n          {\n            *fda = v19;\n            *v32 = v19;\nLABEL_92:\n            printf(\"XX \");\n            if ( v7 != 3 )\n              continue;\n            printf(\"XX \");\n            goto LABEL_96;\n          }\n          *fda = (unsigned __int8)v19;\n          *v32 = v19 >> 8;\nLABEL_94:\n          printf(\"%02x \", *fda);\n          if ( v7 != 3 )\n            continue;\n          printf(\"%02x \", v35[v31 + 1]);\n          goto LABEL_96;\n        case 1:\n          v18 = sub_80550AE(v27);\n          break;\n        default:\n          if ( v17 >= v10 && v7 == 5 )\n          {\n            printf(\"   \");\n            continue;\n          }\n          if ( *fda < 0 )\n            goto LABEL_92;\n          goto LABEL_94;\n      }\n      *fda = v18;\n      if ( v18 >= 0 )\n        printf(\"%02x \", v18);\n      else\n        printf(\"XX \");\n    }\n    printf(\"   \");\n    v20 = n;\n    do\n    {\n      if ( v7 == 5 && v10 <= (int)v20 )\n        break;\n      if ( v28 >= v20 && v25 <= v20 )\n      {\n        v21 = v35[v20];\n        if ( v21 >= 0 )\n        {\n          if ( v21 && v21 != 255 )\n          {\n            if ( (unsigned int)(v21 - 32) > 0x5E )\n              v21 = 63;\n          }\n          else\n          {\n            v21 = 46;\n          }\n        }\n        else\n        {\n          v21 = 88;\n        }\n      }\n      else\n      {\n        v21 = 32;\n      }\n      sub_804DD98(v21);\n      ++v20;\n    }\n    while ( n + 16 != v20 );\n    sub_804DD98(10);\n  }\n  return 0;\n}\n"
    ],
    "sub_8055F40": [
        "0x8055f40",
        "int __cdecl sub_8055F40(int a1, int a2)\n{\n  unsigned int v2; // ebx\n  _DWORD *v3; // ebp\n  int v4; // esi\n  const char **i; // ebx\n  const char *v6; // edx\n  int v7; // esi\n  unsigned int v8; // edi\n  unsigned int j; // ebp\n  unsigned int v10; // ebx\n  int v11; // edx\n  bool v12; // cf\n  int v13; // eax\n  unsigned int v15; // [esp+8h] [ebp-24h]\n  int v16; // [esp+Ch] [ebp-20h]\n  int fd; // [esp+14h] [ebp-18h]\n  int v18; // [esp+18h] [ebp-14h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^yaqrFl\");\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v2 & 0x20) != 0 )\n    sub_805511F();\n  if ( !*v3 )\n    sub_804CDC2();\n  v4 = sub_8054EAD();\n  v16 = sub_8054EBF(v4);\n  sub_804E029(v16, 0x705u, (int)&v18, \"can't get adapter functionality matrix\");\n  v15 = v2 & 0x10;\n  if ( (v2 & 0x10) != 0 )\n  {\n    printf(\"Functionalities implemented by bus #%d\\n\", v4);\n    for ( i = (const char **)&unk_80B5480; *i; i += 2 )\n    {\n      v6 = \"no\";\n      if ( ((unsigned int)*i & v18) != 0 )\n        v6 = \"yes\";\n      printf(\"%-32s %s\\n\", i[1], v6);\n    }\n  }\n  else\n  {\n    v7 = 2;\n    if ( (v2 & 8) == 0 )\n      v7 = (v2 >> 2) & 1;\n    v8 = 127;\n    if ( (v2 & 2) == 0 )\n    {\n      v8 = 119;\n      v15 = 3;\n    }\n    if ( v3[1] )\n    {\n      v15 = sub_80B4093(v8);\n      if ( v3[2] )\n        v8 = sub_80B4093(v8);\n    }\n    if ( (v18 & 0x30000) == 0 )\n      sub_804D5E0(\"bus doesn't support %s\", \"detection commands\");\n    if ( v7 == 1 )\n    {\n      if ( (v18 & 0x10000) == 0 )\n        sub_804D5E0(\"bus doesn't support %s\", \"SMBus quick write\");\n    }\n    else if ( v7 == 2 )\n    {\n      if ( (v18 & 0x20000) == 0 )\n        sub_804D5E0(\"bus doesn't support %s\", \"SMBus receive byte\");\n    }\n    else\n    {\n      if ( (v18 & 0x10000) == 0 )\n        sub_804D5F4(\"warning: can't use %s command, will skip some addresses\", \"SMBus quick write\");\n      if ( (v18 & 0x20000) == 0 )\n        sub_804D5F4(\"warning: can't use %s command, will skip some addresses\", \"SMBus receive byte\");\n    }\n    if ( (v2 & 1) == 0 )\n    {\n      sub_804D5F4(\"WARNING! This program can confuse your I2C bus\");\n      sub_8054FFF();\n    }\n    puts(\"     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\");\n    for ( j = 0; j != 128; j += 16 )\n    {\n      printf(\"%02x: \", j);\n      v10 = j;\n      do\n      {\n        sub_804DD8F();\n        v11 = v7;\n        if ( !v7 )\n        {\n          v11 = 2;\n          if ( v10 - 48 > 7 )\n            v11 = 2 - (v10 - 80 >= 0x10);\n        }\n        if ( v8 >= v10 && v15 <= v10 && (v11 != 2 ? (v12 = (v18 & 0x10000) != 0) : (v12 = (v18 & 0x20000) != 0), v12) )\n        {\n          fd = v11;\n          if ( ioctl(v16, 0x703u, v10) >= 0 )\n          {\n            if ( fd == 2 )\n              v13 = sub_80550AE(v16);\n            else\n              v13 = sub_8055084(v16, 0, 0, 0, 0);\n            if ( v13 >= 0 )\n              printf(\"%02x \", v10);\n            else\n              printf(\"-- \");\n          }\n          else\n          {\n            if ( *(_DWORD *)dword_80DBB7C != 16 )\n              sub_804D3C9((int)\"can't set address to 0x%02x\", v10);\n            printf(\"UU \");\n          }\n        }\n        else\n        {\n          printf(\"   \");\n        }\n        ++v10;\n      }\n      while ( j + 16 != v10 );\n      sub_804DD98(10);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_80561E4": [
        "0x80561e4",
        "int sub_80561E4()\n{\n  unsigned int v0; // ebx\n  unsigned int v1; // ecx\n  int result; // eax\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 20);\n  v1 = *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    LOBYTE(result) = *(_DWORD *)(dword_80DBB80 + 28) + v1 >= v0;\n  }\n  else\n  {\n    result = 1;\n    if ( v0 < v1 )\n      return result;\n    LOBYTE(result) = *(_DWORD *)(dword_80DBB80 + 24) <= (unsigned int)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52)\n                                                                                             + 4 * v1)\n                                                                                 - 4)\n                                                                     + *(_DWORD *)(dword_80DBB80 + 28));\n  }\n  return (unsigned __int8)result;\n}\n"
    ],
    "sub_8056223": [
        "0x8056223",
        "int __usercall sub_8056223@<eax>(int a1@<eax>)\n{\n  unsigned int v1; // edx\n  int v2; // edx\n\n  v1 = *(_DWORD *)(dword_80DBB80 + 20);\n  if ( v1 <= a1 )\n    a1 = v1 - 1;\n  v2 = 0;\n  if ( a1 >= 0 )\n    return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * a1) - 4) + 1;\n  return v2;\n}\n"
    ],
    "sub_8056246": [
        "0x8056246",
        "int __usercall sub_8056246@<eax>(int result@<eax>)\n{\n  if ( (_BYTE)result == 91 )\n    goto LABEL_10;\n  if ( (unsigned __int8)result <= 0x5Bu )\n  {\n    if ( (_BYTE)result != 40 )\n    {\n      if ( (_BYTE)result != 41 )\n        return result;\nLABEL_13:\n      --result;\n      return result;\n    }\nLABEL_11:\n    ++result;\n    return result;\n  }\n  if ( (_BYTE)result == 123 )\n  {\nLABEL_10:\n    ++result;\n    goto LABEL_11;\n  }\n  if ( (_BYTE)result == 125 || (_BYTE)result == 93 )\n  {\n    --result;\n    goto LABEL_13;\n  }\n  return result;\n}\n"
    ],
    "sub_805626E": [
        "0x805626e",
        "int sub_805626E()\n{\n  sub_804DD8F();\n  return tcsetattr(*(_DWORD *)(dword_80DBB80 + 4), 0, (const struct termios *)(dword_80DBB80 + 132));\n}\n"
    ],
    "sub_805628D": [
        "0x805628d",
        "__int64 sub_805628D()\n{\n  __int64 v1; // [esp-8h] [ebp-8h]\n\n  printf(\"\\x1B[%u;0H\\x1B[K\", *(_DWORD *)(dword_80DBB80 + 28) + 2);\n  return v1;\n}\n"
    ],
    "sub_80562A6": [
        "0x80562a6",
        "void __usercall __noreturn sub_80562A6(int a1@<eax>)\n{\n  sub_805626E();\n  if ( (*(_BYTE *)(dword_80DBB80 + 9) & 8) == 0 )\n    sub_804D646();\n  sub_805628D();\n  if ( a1 < 0 )\n    sub_804E761(-a1);\n  exit(a1);\n}\n"
    ],
    "sub_80562D9": [
        "0x80562d9",
        "void __cdecl __noreturn sub_80562D9(int a1)\n{\n  sub_80562A6(-a1);\n}\n"
    ],
    "sub_80562E4": [
        "0x80562e4",
        "int __usercall sub_80562E4@<eax>(const char *a1@<eax>)\n{\n  sub_805628D();\n  return printf(\"\\x1B[7m%.*s\\x1B[m\", *(_DWORD *)(dword_80DBB80 + 32) - 1, a1);\n}\n"
    ],
    "sub_8056306": [
        "0x8056306",
        "int __usercall sub_8056306@<eax>(int result@<eax>)\n{\n  int v1; // ebx\n  unsigned int v2; // esi\n  int v3; // edi\n  int v4; // ecx\n  int v5; // edx\n\n  v1 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 128) )\n  {\n    v2 = result;\n    v3 = 4 * result;\n    while ( *(_DWORD *)(v1 + 20) >= v2 )\n    {\n      result = regexec((const regex_t *)(v1 + 96), *(const char **)(*(_DWORD *)(v1 + 52) + v3), 0, 0, 0);\n      if ( !result )\n      {\n        v4 = *(_DWORD *)(v1 + 92);\n        result = *(_DWORD *)(v1 + 80);\n        if ( !v4 || *(_DWORD *)(result + 4 * v4 - 4) != v2 )\n        {\n          result = sub_80B4733();\n          *(_DWORD *)(v1 + 80) = result;\n          v5 = *(_DWORD *)(v1 + 92);\n          *(_DWORD *)(v1 + 92) = v5 + 1;\n          *(_DWORD *)(result + 4 * v5) = v2;\n        }\n      }\n      ++v2;\n      v3 += 4;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8056375": [
        "0x8056375",
        "int sub_8056375()\n{\n  _DWORD *v0; // ebx\n  int result; // eax\n  char *v2; // eax\n  const char *v3; // ebp\n  _BYTE *v4; // esi\n  int v5; // ebx\n  _DWORD *v6; // edi\n  time_t v7; // eax\n  time_t v8; // edi\n  int v9; // eax\n  int v10; // edx\n  char v11; // cl\n  int v12; // eax\n  signed int v13; // edi\n  int v14; // ebx\n  size_t v15; // eax\n  _DWORD *v16; // eax\n  int v17; // [esp-4h] [ebp-2Ch]\n  int v18; // [esp+0h] [ebp-28h]\n  signed int v19; // [esp+4h] [ebp-24h]\n  char v20; // [esp+8h] [ebp-20h]\n  time_t v21; // [esp+8h] [ebp-20h]\n  int v22; // [esp+10h] [ebp-18h]\n\n  v0 = (_DWORD *)dword_80DBB80;\n  v19 = *(_DWORD *)(dword_80DBB80 + 32);\n  v18 = *(_DWORD *)(dword_80DBB80 + 20);\n  result = v18 + 1;\n  if ( (unsigned int)(v18 + 1) <= 0x98967F )\n  {\n    if ( (dword_80DBB9C & 8) != 0 )\n      v19 -= 8;\n    v20 = *(_BYTE *)(dword_80DBB80 + 129);\n    v2 = (char *)sub_804DAFA(v19 + 5);\n    v3 = v2 + 4;\n    if ( v20 )\n    {\n      ++v0[5];\n      v0[4] = 0;\n      v4 = v2 + 4;\n    }\n    else\n    {\n      v17 = *(_DWORD *)(v0[13] + 4 * v0[5]);\n      v4 = (_BYTE *)stpcpy();\n      free((void *)(v17 - 4));\n    }\n    v22 = 2;\n    v21 = 0;\n    while ( 1 )\n    {\n      *v4 = 0;\n      v5 = dword_80DBB80;\n      *(_BYTE *)(dword_80DBB80 + 129) = 0;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          if ( *(_DWORD *)(v5 + 40) >= *(_DWORD *)(v5 + 44) )\n          {\n            sub_804D61C();\n            while ( 1 )\n            {\n              v6 = (_DWORD *)dword_80DBB7C;\n              *(_DWORD *)dword_80DBB7C = 0;\n              *(_DWORD *)(v5 + 36) = sub_804E5BC(0x400u, &qword_80DB778, 0);\n              if ( *v6 != 11 )\n                break;\n              v7 = time(0);\n              v8 = v7;\n              if ( v21 != v7 && --v22 < 0 )\n              {\n                v21 = v7;\n                break;\n              }\n              sched_yield();\n              v21 = v8;\n            }\n            fcntl64();\n            *(_DWORD *)(v5 + 40) = 0;\n            v9 = *(_DWORD *)(v5 + 36);\n            *(_DWORD *)(v5 + 44) = v9;\n            if ( v9 <= 0 )\n              goto LABEL_33;\n            v22 = 1;\n          }\n          v10 = *(_DWORD *)(v5 + 40);\n          v11 = *((_BYTE *)&qword_80DB778 + v10);\n          v12 = *(_DWORD *)(v5 + 16);\n          if ( v11 != 8 || !v12 || *(v4 - 1) == 9 )\n            break;\n          *(_DWORD *)(v5 + 40) = v10 + 1;\n          *(_DWORD *)(v5 + 16) = v12 - 1;\n          *--v4 = 0;\n        }\n        v13 = v12 + 1;\n        if ( v11 == 9 )\n          v13 = (v12 + 8) & 0xFFFFFFF8;\n        if ( v13 > v19 )\n          goto LABEL_33;\n        *(_DWORD *)(v5 + 16) = v13;\n        *(_DWORD *)(v5 + 40) = v10 + 1;\n        if ( v11 == 10 )\n          break;\n        if ( !v11 )\n          v11 = 10;\n        *v4 = v11;\n        *++v4 = 0;\n      }\n      *(_BYTE *)(v5 + 129) = 1;\n      *(_DWORD *)(v5 + 16) = 0;\nLABEL_33:\n      v14 = dword_80DBB80;\n      *(_DWORD *)(v14 + 52) = sub_80B4733(*(_DWORD *)(dword_80DBB80 + 20), 1032);\n      v15 = strlen(v3);\n      v16 = sub_804DB13((void *)(v3 - 4), v15 + 5);\n      *(_DWORD *)(*(_DWORD *)(v14 + 52) + 4 * *(_DWORD *)(v14 + 20)) = v16 + 1;\n      *v16 = *(_DWORD *)(v14 + 24);\n      if ( *(_BYTE *)(v14 + 129) )\n        ++*(_DWORD *)(v14 + 24);\n      if ( *(_DWORD *)(v14 + 20) > 0x98967Eu )\n        break;\n      if ( !sub_80561E4() )\n      {\n        if ( *(_DWORD *)(v14 + 88) >= *(_DWORD *)(v14 + 92) )\n        {\n          sub_8056306(v18);\n          v18 = *(_DWORD *)(v14 + 20);\n        }\n        if ( *(_DWORD *)(v14 + 88) < *(_DWORD *)(v14 + 92) )\n          goto LABEL_40;\n      }\n      if ( *(int *)(v14 + 36) <= 0 )\n        goto LABEL_40;\n      ++*(_DWORD *)(v14 + 20);\n      v3 = (char *)sub_804DAFA(v19 + 5) + 4;\n      *(_DWORD *)(v14 + 16) = 0;\n      v4 = v3;\n    }\n    *(_DWORD *)(v14 + 36) = 0;\nLABEL_40:\n    if ( *(int *)(v14 + 36) >= 0 )\n    {\n      if ( !*(_DWORD *)(v14 + 36) )\n        *(_DWORD *)(v14 + 76) = *(_DWORD *)(v14 + 24);\n    }\n    else if ( *(_DWORD *)dword_80DBB7C == 11 )\n    {\n      *(_DWORD *)(v14 + 36) = 1;\n    }\n    else\n    {\n      sub_80562E4(\"read error\");\n    }\n    result = sub_8056306(v18);\n    *(_DWORD *)(v14 + 88) = -1;\n  }\n  return result;\n}\n"
    ],
    "sub_8056604": [
        "0x8056604",
        "int __usercall sub_8056604@<eax>(int result@<eax>)\n{\n  int *v1; // ebx\n  int v2; // esi\n  int v3; // edx\n\n  v1 = (int *)dword_80DBB80;\n  if ( result > 0 )\n  {\n    v2 = result;\n    v3 = *(_DWORD *)(dword_80DBB80 + 52);\n    if ( *(_DWORD *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)dword_80DBB80) - 4) >= (unsigned int)result )\n    {\n      while ( 1 )\n      {\n        result = *v1;\n        if ( *(_DWORD *)(*(_DWORD *)(v3 + 4 * *v1) - 4) == v2 || result <= 0 )\n          break;\n        *v1 = result - 1;\n      }\n    }\n    else\n    {\n      while ( 1 )\n      {\n        result = *v1;\n        if ( v2 == *(_DWORD *)(*(_DWORD *)(v1[13] + 4 * *v1) - 4) )\n          break;\n        if ( result >= (unsigned int)v1[5] )\n        {\n          if ( v1[9] <= 0 )\n            return result;\n          sub_8056375();\n        }\n        else\n        {\n          *v1 = result + 1;\n        }\n      }\n    }\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB80 = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_805665F": [
        "0x805665f",
        "unsigned int sub_805665F()\n{\n  int *v0; // edx\n  unsigned int v1; // ebx\n  int v2; // ecx\n  unsigned int v3; // eax\n  unsigned int result; // eax\n\n  v0 = (int *)dword_80DBB80;\n  v1 = *(_DWORD *)dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 28);\n  v3 = *(_DWORD *)(dword_80DBB80 + 20);\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    result = v3 + 1;\n    if ( v2 + v1 > result )\n    {\n      result -= v2;\n      *(_DWORD *)dword_80DBB80 = result;\n    }\n    if ( *v0 < 0 )\n      *v0 = 0;\n  }\n  else\n  {\n    if ( v1 > v3 )\n      *(_DWORD *)dword_80DBB80 = v3;\n    result = v0[6] + 1;\n    if ( v2 + *(_DWORD *)(*(_DWORD *)(v0[13] + 4 * *v0) - 4) > result )\n    {\n      sub_8056604(result - v2);\n      return sub_8056375();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80566B7": [
        "0x80566b7",
        "void sub_80566B7()\n{\n  int v0; // esi\n  int v1; // ebx\n  int v2; // edi\n  ssize_t v3; // eax\n  int v4; // edx\n  __int16 v5; // [esp+10h] [ebp-105Ch]\n  char buf[4108]; // [esp+60h] [ebp-100Ch] BYREF\n\n  v0 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 76) >= 0xFFFFFFFE )\n  {\n    v1 = open64();\n    if ( v1 >= 0 || *(_DWORD *)(v0 + 76) == -1 && (v1 = open64(), v1 >= 0) )\n    {\n      if ( !fstat64() && (v5 & 0xF000) == 0x8000 )\n      {\n        v2 = 0;\nLABEL_10:\n        v3 = sub_804E5BC(0x1000u, buf, v1);\n        if ( v3 > 0 )\n        {\n          v4 = 0;\n          while ( buf[v4] != 10 || ++v2 != 9999999 )\n          {\n            if ( v3 == ++v4 )\n              goto LABEL_10;\n          }\n        }\n        *(_DWORD *)(v0 + 76) = v2;\n      }\n      else\n      {\n        *(_DWORD *)(v0 + 76) = -3;\n      }\n      close(v1);\n    }\n    else\n    {\n      *(_DWORD *)(v0 + 76) = -3;\n    }\n  }\n}\n"
    ],
    "sub_805676E": [
        "0x805676e",
        "void sub_805676E()\n{\n  int v0; // esi\n  unsigned int v1; // eax\n  int v2; // ebx\n  int v3; // edi\n  int v4; // eax\n  unsigned int v5; // eax\n  unsigned int v6; // ebx\n  unsigned int v7; // edx\n  int v8; // eax\n  int v9; // ecx\n  unsigned int v10; // eax\n\n  v0 = dword_80DBB80;\n  if ( *(int *)(dword_80DBB80 + 12) >= 0 )\n    return;\n  sub_805628D();\n  printf(\"\\x1B[7m%s\", *(const char **)(v0 + 68));\n  v1 = *(_DWORD *)(v0 + 60);\n  if ( v1 > 1 )\n    printf(\" (file %i of %i)\", *(_DWORD *)(v0 + 64), v1);\n  v2 = *(_DWORD *)v0;\n  v3 = sub_8056223(*(_DWORD *)v0);\n  v4 = *(_DWORD *)(v0 + 28);\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    v5 = sub_8056223(v2 + v4);\nLABEL_8:\n    v6 = v5;\n    goto LABEL_9;\n  }\n  v5 = v3 + v4;\n  v6 = *(_DWORD *)(v0 + 24);\n  if ( v6 > v5 )\n    goto LABEL_8;\nLABEL_9:\n  printf(\" lines %i-%i\", v3, v6);\n  sub_80566B7();\n  if ( *(int *)(v0 + 76) >= 0 )\n    printf(\"/%i\", *(_DWORD *)(v0 + 76));\n  if ( sub_80561E4() )\n  {\n    printf(\" (END)\");\n    v7 = *(_DWORD *)(v0 + 60);\n    if ( v7 > 1 )\n    {\n      v8 = *(_DWORD *)(v0 + 64);\n      if ( v7 != v8 )\n        printf(\" - next: %s\", *(_DWORD *)(*(_DWORD *)(v0 + 72) + 4 * v8));\n    }\n  }\n  else\n  {\n    v9 = *(_DWORD *)(v0 + 76);\n    if ( v9 > 0 )\n    {\n      v10 = (int)((v9 >> 1) + 100 * v6) / v9;\n      if ( v10 > 0x64 )\n        v10 = 100;\n      printf(\" %i%%\", v10);\n    }\n  }\n  printf(\"\\x1B[m\");\n}\n"
    ],
    "sub_805686A": [
        "0x805686a",
        "void sub_805686A()\n{\n  _DWORD *v0; // ebx\n  const char *v1; // eax\n\n  v0 = (_DWORD *)dword_80DBB80;\n  if ( *(int *)(dword_80DBB80 + 12) < 0 )\n  {\n    if ( (dword_80DBB9C & 6) != 0 )\n    {\n      sub_805676E();\n      return;\n    }\n    sub_805628D();\n    if ( *v0 )\n    {\n      if ( !sub_80561E4() )\n      {\n        sub_804DD98(58);\n        return;\n      }\n      v1 = \" (END)\" + 1;\n    }\n    else\n    {\n      v1 = (const char *)v0[17];\n    }\n    if ( v0[15] <= 1u )\n      printf(\"\\x1B[7m%s\\x1B[m\", v1);\n    else\n      printf(\"\\x1B[7m%s (file %i of %i)\\x1B[m\", v1, v0[16], v0[15]);\n  }\n}\n"
    ],
    "sub_80568D9": [
        "0x80568d9",
        "void sub_80568D9()\n{\n  int v0; // ebx\n  unsigned int v1; // edx\n  int v2; // esi\n  int v3; // edx\n  const char *v4; // eax\n  int v5; // eax\n  void *v6; // esp\n  int **v7; // edi\n  char *j; // esi\n  unsigned int v9; // eax\n  unsigned int v10; // ecx\n  char *v11; // esi\n  int k; // edx\n  const char *v13; // edi\n  char *v14; // edi\n  const char *v15; // eax\n  void *v16; // esp\n  size_t v17; // eax\n  char *v18; // edi\n  size_t v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int v22; // ecx\n  int *v23; // [esp+0h] [ebp-28h] BYREF\n  int v24; // [esp+4h] [ebp-24h]\n  const char *v25; // [esp+8h] [ebp-20h]\n  unsigned int i; // [esp+Ch] [ebp-1Ch]\n  char *s; // [esp+10h] [ebp-18h]\n  regmatch_t v28; // [esp+14h] [ebp-14h] BYREF\n\n  printf(\"\\x1B[%u;%uH\", 0, 0);\n  for ( i = 0; ; ++i )\n  {\n    v0 = dword_80DBB80;\n    v1 = *(_DWORD *)(dword_80DBB80 + 28);\n    if ( v1 < i )\n      break;\n    printf(\"\\x1B[K\");\n    v2 = 4 * i;\n    if ( (dword_80DBB9C & 8) != 0 )\n    {\n      v3 = *(_DWORD *)(*(_DWORD *)(v0 + 48) + 4 * i);\n      v4 = \"        \";\n      if ( v3 != *(_DWORD *)(v0 + 56) )\n      {\n        v24 = *(_DWORD *)(v3 - 4) + 1;\n        v4 = \"%7u \";\n      }\n      printf(v4, v24, v23);\n    }\n    s = *(char **)(*(_DWORD *)(v0 + 48) + v2);\n    v5 = *(_DWORD *)(v0 + 32) + 4;\n    if ( *(_BYTE *)(v0 + 128) )\n    {\n      v23 = (int *)&v23;\n      v6 = alloca(v5 & 0xFFFFFFFC);\n      v25 = (const char *)&v23;\n      v7 = &v23;\n      for ( j = s; *j; j += v10 )\n      {\n        v9 = strcspn(j, &reject);\n        if ( v9 )\n        {\n          if ( !j[v9] )\n            break;\n          qmemcpy(v7, j, v9);\n          j += v9;\n          v7 = (int **)((char *)v7 + v9);\n        }\n        v10 = strspn(j, &reject);\n        memset(v7, 46, v10);\n        v7 = (int **)((char *)v7 + v10);\n      }\n      strcpy((char *)v7, j);\n      v11 = 0;\n      for ( k = 0; !regexec((const regex_t *)(v0 + 96), s, 1u, &v28, k) && v28.rm_so < v28.rm_eo; k = 1 )\n      {\n        v13 = &data;\n        if ( v11 )\n          v13 = v11;\n        v14 = sub_804DDBF(\"%s%.*s\\x1B[7m%.*s\\x1B[m\", v13, v28.rm_so, v25, v28.rm_eo - v28.rm_so, &v25[v28.rm_so], v23);\n        free(v11);\n        v25 += v28.rm_eo;\n        s += v28.rm_eo;\n        v11 = v14;\n      }\n      v15 = &data;\n      if ( v11 )\n        v15 = v11;\n      printf(\"%s%s\\n\", v15, v25);\n      free(v11);\n    }\n    else\n    {\n      v16 = alloca(*(_DWORD *)(v0 + 32) + 1);\n      while ( *s )\n      {\n        v17 = strcspn(s, &reject);\n        if ( v17 )\n        {\n          v18 = &s[v17];\n          if ( !s[v17] )\n            break;\n          printf(\"%.*s\", v17, s);\n          s = v18;\n        }\n        v19 = strspn(s, &reject);\n        v20 = 0;\n        do\n        {\n          v21 = (unsigned __int8)s[v20];\n          if ( (_BYTE)v21 == 127 )\n          {\n            *((_BYTE *)&v23 + v20) = 63;\n          }\n          else if ( (_BYTE)v21 == 0x9B )\n          {\n            *((_BYTE *)&v23 + v20) = 123;\n          }\n          else\n          {\n            *((_BYTE *)&v23 + v20) = byte_80CAD52[v21];\n          }\n          ++v20;\n        }\n        while ( v20 != v19 );\n        s += v20;\n        *((_BYTE *)&v23 + v20) = 0;\n        printf(\"\\x1B[7m%s\\x1B[m\", (const char *)&v23);\n      }\n      puts(s);\n    }\n  }\n  if ( (dword_80DBB9C & 0x41) != 0 && *(int *)(dword_80DBB80 + 36) <= 0 )\n  {\n    v22 = 0;\n    if ( (dword_80DBB9C & 0x40) == 0 )\n      v22 = *(_DWORD *)dword_80DBB80;\n    if ( v1 >= *(_DWORD *)(dword_80DBB80 + 20) - v22 )\n      sub_80562A6(0);\n  }\n  sub_805686A();\n}\n"
    ],
    "sub_8056B34": [
        "0x8056b34",
        "void sub_8056B34()\n{\n  _DWORD *v0; // ecx\n  unsigned int v1; // eax\n  int v2; // edx\n  unsigned int v3; // edx\n  int v4; // ebx\n  int v5; // esi\n  int v6; // ebx\n  int v7; // esi\n  _DWORD *v8; // edi\n  unsigned int v9; // ebx\n  int v10; // esi\n  int v11; // edx\n  int v12; // ebp\n  unsigned int v13; // [esp+0h] [ebp-1Ch]\n  unsigned int v14; // [esp+4h] [ebp-18h]\n  int v15; // [esp+8h] [ebp-14h]\n\n  v0 = (_DWORD *)dword_80DBB80;\n  v1 = *(_DWORD *)dword_80DBB80;\n  v15 = dword_80DBB9C & 0x80;\n  v2 = 4 * *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80) != 0 )\n  {\n    while ( v1 )\n    {\n      v4 = *(_DWORD *)(dword_80DBB80 + 52);\n      v5 = *(_DWORD *)(v4 + v2);\n      v6 = *(_DWORD *)(v4 + v2 - 4);\n      v2 -= 4;\n      if ( *(_DWORD *)(v5 - 4) != *(_DWORD *)(v6 - 4) )\n        break;\n      --v1;\n    }\n  }\n  v13 = *(_DWORD *)(dword_80DBB80 + 28);\n  v3 = 0;\n  while ( v13 >= v3 )\n  {\n    v14 = v0[5];\n    v7 = v0[12];\n    v8 = (_DWORD *)(v7 + 4 * v3);\n    v9 = v3 + 1;\n    if ( v14 < v1 )\n    {\n      do\n        *(_DWORD *)(v7 + 4 * v3++) = v0[14];\n      while ( v13 >= v3 );\n      break;\n    }\n    v10 = v0[13];\n    v11 = *(_DWORD *)(v10 + 4 * v1);\n    v12 = *(_DWORD *)(v11 - 4);\n    *v8 = v11;\n    do\n    {\n      ++v1;\n      v3 = v9;\n    }\n    while ( v15 && v14 >= v1 && v12 == *(_DWORD *)(*(_DWORD *)(v10 + 4 * v1) - 4) );\n  }\n  sub_80568D9();\n}\n"
    ],
    "sub_8056BDC": [
        "0x8056bdc",
        "void sub_8056BDC()\n{\n  int v0; // ebx\n  unsigned int i; // esi\n  const char *v2; // eax\n  int v3; // eax\n\n  v0 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 52) )\n  {\n    for ( i = 0; *(_DWORD *)(v0 + 20) >= i; ++i )\n      free((void *)(*(_DWORD *)(*(_DWORD *)(v0 + 52) + 4 * i) - 4));\n    free(*(void **)(v0 + 52));\n    *(_DWORD *)(v0 + 52) = 0;\n  }\n  *(_DWORD *)(v0 + 20) = -1;\n  *(_DWORD *)v0 = 0;\n  *(_DWORD *)(v0 + 24) = 0;\n  v2 = *(const char **)(v0 + 68);\n  if ( v2 )\n  {\n    v3 = sub_804DBE1(v2);\n    sub_804DC97(v3, 0);\n    *(_DWORD *)(v0 + 76) = -1;\n  }\n  else\n  {\n    *(_DWORD *)(v0 + 68) = sub_804DB46(\"standard input\");\n    *(_DWORD *)(v0 + 76) = -2;\n  }\n  *(_DWORD *)(v0 + 40) = 0;\n  *(_DWORD *)(v0 + 44) = 0;\n  *(_DWORD *)(v0 + 16) = 0;\n  *(_BYTE *)(v0 + 129) = 1;\n  sub_8056375();\n  sub_8056B34();\n}\n"
    ],
    "sub_8056C80": [
        "0x8056c80",
        "void __usercall sub_8056C80(int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // edx\n  int v3; // ecx\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 64);\n  if ( a1 == 1 )\n  {\n    if ( v2 == *(_DWORD *)(dword_80DBB80 + 60) )\n    {\n      sub_80562E4(\"No next file\");\n      return;\n    }\n    goto LABEL_6;\n  }\n  if ( v2 != 1 )\n  {\n    v3 = 1;\n    if ( !a1 )\n    {\nLABEL_7:\n      *(_DWORD *)(dword_80DBB80 + 64) = v3;\n      free(*(void **)(v1 + 68));\n      *(_DWORD *)(v1 + 68) = sub_804DB46(*(const char **)(*(_DWORD *)(v1 + 72) + 4 * *(_DWORD *)(v1 + 64) - 4));\n      sub_8056BDC();\n      return;\n    }\nLABEL_6:\n    v3 = a1 + v2;\n    goto LABEL_7;\n  }\n  sub_80562E4(\"No previous file\");\n}\n"
    ],
    "sub_8056CDB": [
        "0x8056cdb",
        "void __usercall sub_8056CDB(int a1@<eax>)\n{\n  int v1; // ecx\n\n  v1 = *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n    *(_DWORD *)dword_80DBB80 = v1 + a1;\n  else\n    sub_8056604(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * v1) - 4) + a1);\n  sub_8056375();\n  sub_805665F();\n  sub_8056B34();\n}\n"
    ],
    "sub_8056D0F": [
        "0x8056d0f",
        "void __usercall sub_8056D0F(int a1@<eax>)\n{\n  _DWORD *v1; // ecx\n  int v2; // edx\n  int v3; // edx\n\n  v1 = (_DWORD *)dword_80DBB80;\n  v2 = *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    v3 = v2 - a1;\n    *(_DWORD *)dword_80DBB80 = v3;\n    if ( v3 < 0 )\n      *v1 = 0;\n  }\n  else\n  {\n    sub_8056604(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * v2) - 4) - a1);\n  }\n  sub_8056375();\n  sub_8056B34();\n}\n"
    ],
    "sub_8056D4C": [
        "0x8056d4c",
        "void __usercall sub_8056D4C(int a1@<eax>, int a2@<edx>)\n{\n  if ( a1 > 0 )\n  {\n    if ( a2 )\n      sub_8056604(a1);\n    else\n      *(_DWORD *)dword_80DBB80 = a1;\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB80 = 0;\n  }\n  sub_8056375();\n  sub_805665F();\n  sub_8056B34();\n}\n"
    ],
    "sub_8056D7F": [
        "0x8056d7f",
        "void __usercall sub_8056D7F(int a1@<eax>)\n{\n  _DWORD *v1; // esi\n  int v2; // ebx\n  int v3; // eax\n\n  v1 = (_DWORD *)dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 128) )\n  {\n    v2 = a1;\n    if ( a1 < 0 )\n      v2 = 0;\n    if ( *(_DWORD *)(dword_80DBB80 + 92) <= v2 && *(int *)(dword_80DBB80 + 36) > 0 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 88) = v2;\n      sub_8056375();\n    }\n    v3 = v1[23];\n    if ( v3 )\n    {\n      if ( v3 <= v2 )\n      {\n        v2 = v3 - 1;\n        if ( v3 - 1 < 0 )\n          v2 = 0;\n      }\n      v1[21] = v2;\n      sub_8056D4C(*(_DWORD *)(v1[20] + 4 * v2), 0);\n    }\n    else\n    {\n      sub_80562E4(\"No matches found\");\n    }\n  }\n}\n"
    ],
    "sub_8056DDE": [
        "0x8056dde",
        "int sub_8056DDE()\n{\n  int v0; // ebx\n  _BOOL4 v1; // esi\n  int v2; // eax\n  int v3; // eax\n  int v5; // [esp+0h] [ebp-24h]\n  int v6; // [esp+4h] [ebp-20h]\n  int v7; // [esp+4h] [ebp-20h]\n\n  v0 = dword_80DBB80;\n  while ( 1 )\n  {\n    tcsetattr(*(_DWORD *)(v0 + 4), 0, (const struct termios *)(v0 + 192));\n    v1 = 1;\n    if ( sub_80561E4() )\n      v1 = *(_DWORD *)(v0 + 36) <= 0;\n    v2 = *(_DWORD *)(v0 + 12);\n    if ( v2 >= 0 )\n      printf(\"\\x1B[%u;%uH\", *(_DWORD *)(v0 + 28) + 2, v2 + 1);\n    sub_804DD8F();\n    if ( !*(_BYTE *)(v0 + 252) )\n      sub_80B2C0A(-1, 2 - v1);\n    v3 = sub_80B20CC(-2, v0 + 252, v5, v6);\n    if ( v3 != -1 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 11 )\n      sub_80562A6(0);\n    sub_8056375();\n    sub_8056B34();\n  }\n  v7 = v3;\n  sub_805626E();\n  return v7;\n}\n"
    ],
    "sub_8056EC2": [
        "0x8056ec2",
        "unsigned int __usercall sub_8056EC2@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n  unsigned int result; // eax\n\n  do\n  {\n    v2 = dword_80DBB80;\n    *(_DWORD *)(dword_80DBB80 + 12) = a1;\n    result = sub_8056DDE();\n    *(_DWORD *)(v2 + 12) = -1;\n  }\n  while ( result <= 0x1F && result != 13 && result != 8 );\n  return result;\n}\n"
    ],
    "sub_8056EF9": [
        "0x8056ef9",
        "_BYTE *__usercall sub_8056EF9@<eax>(int a1@<eax>)\n{\n  _BYTE *v2; // esi\n  unsigned int v3; // ebx\n  int v4; // ebp\n  int v5; // eax\n  char v7; // [esp+0h] [ebp-14h]\n\n  v2 = sub_804DB2E(1u);\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = dword_80DBB80;\n    *(_DWORD *)(dword_80DBB80 + 12) = a1 + v3;\n    v5 = sub_8056DDE();\n    if ( v5 == 13 )\n      break;\n    if ( v5 == 8 || v5 == 127 )\n    {\n      if ( v3 )\n      {\n        printf(\"\\b \\b\");\n        --v3;\n      }\n    }\n    else if ( v5 > 31 && *(_DWORD *)(v4 + 32) + ~a1 > v3 )\n    {\n      v7 = v5;\n      sub_804DD98(v5);\n      v2[v3] = v7;\n      v2 = sub_804DB13(v2, v3 + 2);\n      ++v3;\n    }\n  }\n  v2[v3] = 0;\n  *(_DWORD *)(v4 + 12) = -1;\n  return v2;\n}\n"
    ],
    "sub_8056F88": [
        "0x8056f88",
        "void sub_8056F88()\n{\n  const char *v0; // eax\n  char *v1; // esi\n  int v2; // ebx\n\n  sub_80562E4(\"Examine: \");\n  v0 = sub_8056EF9(9);\n  v1 = (char *)v0;\n  if ( !*v0 )\n  {\n    sub_805686A();\nLABEL_3:\n    free(v1);\n    return;\n  }\n  if ( access(v0, 4) )\n  {\n    sub_80562E4(\"Cannot read this file\");\n    goto LABEL_3;\n  }\n  v2 = dword_80DBB80;\n  free(*(void **)(dword_80DBB80 + 68));\n  *(_DWORD *)(v2 + 68) = v1;\n  **(_DWORD **)(v2 + 72) = v1;\n  *(_DWORD *)(v2 + 64) = 1;\n  *(_DWORD *)(v2 + 60) = 1;\n  sub_8056BDC();\n}\n"
    ],
    "sub_8056FFA": [
        "0x8056ffa",
        "void sub_8056FFA()\n{\n  int v0; // ebx\n  char *v1; // eax\n  char *v2; // esi\n  char *v3; // edi\n  int v4; // edx\n  int v5; // eax\n\n  v0 = dword_80DBB80;\n  free(*(void **)(dword_80DBB80 + 80));\n  *(_DWORD *)(v0 + 80) = 0;\n  *(_DWORD *)(v0 + 84) = 0;\n  *(_DWORD *)(v0 + 92) = 0;\n  if ( *(_BYTE *)(v0 + 128) )\n  {\n    regfree((regex_t *)(v0 + 96));\n    *(_BYTE *)(v0 + 128) = 0;\n  }\n  sub_805628D();\n  sub_804DD98((dword_80DBB9C & 0x8000) == 0 ? 47 : 63);\n  v1 = sub_8056EF9(1);\n  v2 = v1;\n  if ( *v1 )\n  {\n    v3 = (char *)sub_80B477A(((unsigned int)dword_80DBB9C >> 4) & 2, v1);\n    free(v2);\n    if ( v3 )\n    {\n      sub_80562E4(v3);\n      free(v3);\n    }\n    else\n    {\n      *(_BYTE *)(v0 + 128) = 1;\n      *(_DWORD *)(v0 + 84) = 0;\n      sub_8056306(0);\n      v4 = *(_DWORD *)(v0 + 92);\n      while ( 1 )\n      {\n        v5 = *(_DWORD *)(v0 + 84);\n        if ( v5 >= v4 || *(_DWORD *)(*(_DWORD *)(v0 + 80) + 4 * v5) > *(_DWORD *)v0 )\n          break;\n        *(_DWORD *)(v0 + 84) = v5 + 1;\n      }\n      if ( (dword_80DBB9C & 0x8000) != 0 )\n        *(_DWORD *)(v0 + 84) = v5 - 1;\n      sub_8056D7F(*(_DWORD *)(v0 + 84));\n    }\n  }\n  else\n  {\n    free(v1);\n    sub_80568D9();\n  }\n}\n"
    ],
    "sub_80570F8": [
        "0x80570f8",
        "int __cdecl sub_80570F8(int a1, int a2)\n{\n  void *v2; // ebx\n  int v3; // edi\n  char *v4; // ebx\n  int v5; // esi\n  int v6; // ebx\n  unsigned int v7; // eax\n  signed int v9; // eax\n  signed int v10; // ebx\n  bool v11; // zf\n  bool v12; // zf\n  bool v13; // zf\n  bool v14; // zf\n  int v15; // eax\n  int v16; // eax\n  int v17; // eax\n  int v18; // eax\n  int *v19; // esi\n  _BYTE *v20; // edi\n  const char *v21; // eax\n  FILE *v22; // ebp\n  unsigned int v23; // esi\n  int v24; // esi\n  int v25; // edi\n  int v26; // ebp\n  const char *v27; // eax\n  int v28; // ecx\n  char *v29; // eax\n  unsigned int v30; // eax\n  int v31; // esi\n  int v32; // edi\n  int v33; // ebp\n  _DWORD *v34; // esi\n  unsigned int v35; // eax\n  int v36; // edx\n  unsigned int j; // ecx\n  unsigned int v38; // eax\n  int v39; // edx\n  unsigned int i; // ecx\n  int v41; // eax\n  int v42; // esi\n  int v43; // edi\n  unsigned int v44; // eax\n  int v45; // ebx\n  int v46; // eax\n  bool v47; // zf\n  bool v48; // zf\n  int v49; // eax\n  int v50; // edx\n  unsigned int v51; // [esp+0h] [ebp-28h]\n  int v52; // [esp+0h] [ebp-28h]\n  int v53; // [esp+4h] [ebp-24h]\n  char v54[32]; // [esp+8h] [ebp-20h] BYREF\n\n  v2 = sub_804DB2E(0x10Cu);\n  dword_80DBB80 = (int)v2;\n  *((_DWORD *)v2 + 3) = -1;\n  *((_DWORD *)v2 + 14) = 135102604;\n  *((_DWORD *)v2 + 16) = 1;\n  *((_DWORD *)v2 + 9) = 1;\n  *((_BYTE *)v2 + 129) = 1;\n  *((_DWORD *)v2 + 22) = -1;\n  sub_80ABEAC(a2, \"EMmN~IFSs\");\n  v3 = a2 + 4 * optind;\n  *((_DWORD *)v2 + 15) = a1 - optind;\n  *((_DWORD *)v2 + 18) = v3;\n  if ( isatty(1) )\n  {\n    if ( *((_DWORD *)v2 + 15) )\n    {\n      *((_DWORD *)v2 + 17) = sub_804DB46(**((const char ***)v2 + 18));\n    }\n    else if ( isatty(0) )\n    {\n      sub_804CDC2();\n    }\n    if ( (dword_80DBB9C & 0x10) != 0 )\n      *((_DWORD *)v2 + 14) = &data;\n    v4 = sub_804E0D9(1);\n    if ( !v4 || (v5 = open64(), free(v4), v5 < 0) )\n    {\n      v5 = open64();\n      if ( v5 < 0 )\n        v5 = 1;\n    }\n    v6 = dword_80DBB80;\n    *(_DWORD *)(v6 + 8) = sub_804D61C();\n    *(_DWORD *)(v6 + 4) = v5;\n    sub_804D9A3((struct termios *)(v6 + 132), v5, (struct termios *)(v6 + 192), 2);\n    sub_804D878(v5, (int *)(v6 + 32), (int *)(v6 + 28));\n    if ( *(_DWORD *)(v6 + 32) > 0x13u )\n    {\n      v7 = *(_DWORD *)(v6 + 28);\n      if ( v7 > 2 )\n      {\n        *(_DWORD *)(v6 + 28) = v7 - 2;\n        sub_804E6C8(117503054, (void (*)(int))sub_80562D9);\n        *(_DWORD *)(v6 + 48) = sub_804DAFA(4 * *(_DWORD *)(v6 + 28) + 4);\n        sub_8056BDC();\n        while ( 1 )\n        {\n          v9 = sub_8056EC2(-1);\n          v10 = v9;\n          if ( v9 == 81 )\nLABEL_96:\n            sub_80562A6(0);\n          if ( v9 > 81 )\n          {\n            if ( v9 == 110 )\n            {\n              v15 = *(_DWORD *)(dword_80DBB80 + 84) + 1;\n              goto LABEL_108;\n            }\n            if ( v9 > 110 )\n            {\n              if ( v9 == 117 )\n              {\n                v16 = (unsigned int)(*(_DWORD *)(dword_80DBB80 + 28) + 1) >> 1;\n                goto LABEL_90;\n              }\n              if ( v9 <= 117 )\n              {\n                if ( v9 == 113 )\n                  goto LABEL_96;\n                if ( v9 > 113 )\n                {\n                  if ( v9 != 114 )\n                  {\n                    if ( v9 == 115 )\n                    {\n                      sub_80562E4(\"Log file: \");\n                      v20 = sub_8056EF9(10);\n                      v21 = &data;\n                      if ( *v20 )\n                      {\n                        v22 = (FILE *)sub_80B3D4F();\n                        v21 = \"Error opening log file\";\n                        v23 = 0;\n                        if ( v22 )\n                        {\n                          while ( v23 <= *(_DWORD *)(dword_80DBB80 + 20) )\n                            fprintf(v22, \"%s\\n\", *(const char **)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * v23++));\n                          fclose(v22);\n                          v21 = \"Done\";\n                        }\n                      }\n                      sub_80562E4(v21);\n                      free(v20);\n                    }\n                    goto LABEL_142;\n                  }\nLABEL_97:\n                  sub_80568D9();\n                  goto LABEL_142;\n                }\n                v12 = v9 == 112;\n                goto LABEL_32;\n              }\n              if ( v9 == 122 )\n                goto LABEL_87;\n              if ( v9 > 122 )\n              {\n                if ( v9 == 123 )\n                {\nLABEL_110:\n                  v24 = dword_80DBB80;\n                  v25 = *(_DWORD *)dword_80DBB80;\n                  v51 = *(_DWORD *)(dword_80DBB80 + 20);\n                  if ( *(_DWORD *)dword_80DBB80 >= v51\n                    || (v26 = *(_DWORD *)(dword_80DBB80 + 52),\n                        !strchr(*(const char **)(v26 + 4 * v25), (unsigned __int8)v9)) )\n                  {\n                    v27 = \"No bracket in top line\";\n                    goto LABEL_121;\n                  }\n                  v28 = (unsigned __int8)sub_8056246((unsigned __int8)v10);\n                  while ( 1 )\n                  {\n                    v53 = v28;\n                    v29 = strchr(*(const char **)(v26 + 4 * v25), v28);\n                    v28 = v53;\n                    if ( v29 )\n                      break;\n                    if ( v51 <= ++v25 )\n                    {\nLABEL_117:\n                      v27 = \"No matching bracket found\";\n                      goto LABEL_121;\n                    }\n                  }\n                  v18 = v25 - *(_DWORD *)(v24 + 28);\n                }\n                else\n                {\n                  v14 = v9 == 125;\nLABEL_84:\n                  if ( !v14 )\n                    goto LABEL_142;\nLABEL_118:\n                  v30 = *(_DWORD *)dword_80DBB80 + *(_DWORD *)(dword_80DBB80 + 28);\n                  v31 = v30;\n                  if ( v30 >= *(_DWORD *)(dword_80DBB80 + 20)\n                    || (v32 = *(_DWORD *)(dword_80DBB80 + 52),\n                        !strchr(*(const char **)(v32 + 4 * v30), (unsigned __int8)v10)) )\n                  {\n                    v27 = \"No bracket in bottom line\";\nLABEL_121:\n                    sub_80562E4(v27);\n                    goto LABEL_142;\n                  }\n                  v33 = (unsigned __int8)sub_8056246((unsigned __int8)v10);\n                  while ( 1 )\n                  {\n                    if ( v31 < 0 )\n                      goto LABEL_117;\n                    if ( strchr(*(const char **)(v32 + 4 * v31), v33) )\n                      break;\n                    --v31;\n                  }\n                  v18 = v31;\n                }\n                goto LABEL_95;\n              }\n              if ( v9 == 119 )\n                goto LABEL_89;\n              v13 = v9 == 121;\n            }\n            else\n            {\n              if ( v9 == 100 )\n              {\n                v17 = (unsigned int)(*(_DWORD *)(dword_80DBB80 + 28) + 1) >> 1;\n                goto LABEL_88;\n              }\n              if ( v9 <= 100 )\n              {\n                if ( v9 == 91 )\n                  goto LABEL_110;\n                if ( v9 <= 91 )\n                {\n                  if ( v9 != 82 )\n                    goto LABEL_142;\n                  goto LABEL_97;\n                }\n                if ( v9 == 93 )\n                  goto LABEL_118;\n                if ( v9 != 98 )\n                  goto LABEL_142;\nLABEL_89:\n                v16 = *(_DWORD *)(dword_80DBB80 + 28) + 1;\nLABEL_90:\n                sub_8056D0F(v16);\n                goto LABEL_142;\n              }\n              if ( v9 == 103 )\n                goto LABEL_93;\n              if ( v9 <= 103 )\n              {\n                if ( v9 != 101 )\n                {\n                  v11 = v9 == 102;\nLABEL_64:\n                  if ( !v11 )\n                    goto LABEL_142;\n                  goto LABEL_87;\n                }\nLABEL_86:\n                v17 = 1;\nLABEL_88:\n                sub_8056CDB(v17);\n                goto LABEL_142;\n              }\n              if ( v9 == 106 )\n                goto LABEL_86;\n              v13 = v9 == 107;\n            }\n          }\n          else\n          {\n            if ( v9 == 40 )\n              goto LABEL_110;\n            if ( v9 > 40 )\n            {\n              if ( v9 == 61 )\n              {\nLABEL_105:\n                sub_805676E();\n                goto LABEL_142;\n              }\n              if ( v9 <= 61 )\n              {\n                if ( v9 == 47 )\n                {\n                  dword_80DBB9C &= ~0x8000u;\n                  goto LABEL_109;\n                }\n                if ( v9 <= 47 )\n                {\n                  v14 = v9 == 41;\n                  goto LABEL_84;\n                }\n                if ( v9 == 58 )\n                {\n                  sub_80562E4(\" :\");\n                  switch ( sub_8056EC2(2) )\n                  {\n                    case 'd':\n                      v34 = (_DWORD *)dword_80DBB80;\n                      if ( *(_DWORD *)(dword_80DBB80 + 60) > 1u )\n                      {\n                        if ( *(_DWORD *)(dword_80DBB80 + 64) == 1 )\n                        {\n                          sub_8056C80(1);\n                          v38 = v34[15];\n                          v39 = 4;\n                          for ( i = 2; i <= v38; ++i )\n                          {\n                            *(_DWORD *)(v34[18] + v39 - 4) = *(_DWORD *)(v34[18] + v39);\n                            v39 += 4;\n                          }\n                          v34[15] = v38 - 1;\n                          --v34[16];\n                        }\n                        else\n                        {\n                          sub_8056C80(-1);\n                          v35 = v34[15];\n                          v36 = 8;\n                          for ( j = 3; j <= v35; ++j )\n                          {\n                            *(_DWORD *)(v34[18] + v36 - 4) = *(_DWORD *)(v34[18] + v36);\n                            v36 += 4;\n                          }\n                          v34[15] = v35 - 1;\n                        }\n                      }\n                      goto LABEL_142;\n                    case 'e':\n                      goto LABEL_104;\n                    case 'f':\n                      goto LABEL_105;\n                    case 'n':\n                      v41 = 1;\n                      goto LABEL_141;\n                    case 'p':\n                      v41 = -1;\n                      goto LABEL_141;\n                    case 'q':\n                      goto LABEL_96;\n                    case 'x':\n                      v41 = 0;\nLABEL_141:\n                      sub_8056C80(v41);\n                      break;\n                    default:\n                      goto LABEL_142;\n                  }\n                  goto LABEL_142;\n                }\n                v12 = v9 == 60;\nLABEL_32:\n                if ( !v12 )\n                  goto LABEL_142;\nLABEL_93:\n                v18 = 0;\nLABEL_95:\n                sub_8056D4C(v18, 0);\n                goto LABEL_142;\n              }\n              if ( v9 == 69 )\n              {\nLABEL_104:\n                sub_8056F88();\n                goto LABEL_142;\n              }\n              if ( v9 > 69 )\n              {\n                if ( v9 == 71 )\n                  goto LABEL_94;\n                if ( v9 == 78 )\n                {\n                  v15 = *(_DWORD *)(dword_80DBB80 + 84) - 1;\nLABEL_108:\n                  sub_8056D7F(v15);\n                  goto LABEL_142;\n                }\n              }\n              else\n              {\n                if ( v9 == 62 )\n                  goto LABEL_94;\n                if ( v9 == 63 )\n                {\n                  dword_80DBB9C |= 0x8000u;\nLABEL_109:\n                  sub_8056FFA();\n                  goto LABEL_142;\n                }\n              }\n              goto LABEL_142;\n            }\n            if ( v9 == -3 )\n              goto LABEL_86;\n            if ( v9 <= -3 )\n            {\n              if ( v9 == -10 )\n                goto LABEL_89;\n              if ( v9 > -10 )\n              {\n                if ( v9 != -7 )\n                {\n                  v12 = v9 == -6;\n                  goto LABEL_32;\n                }\nLABEL_94:\n                v19 = (int *)dword_80DBB80;\n                *(_DWORD *)dword_80DBB80 = 9999999;\n                sub_8056375();\n                v18 = *v19;\n                goto LABEL_95;\n              }\n              v11 = v9 == -11;\n              goto LABEL_64;\n            }\n            if ( v9 == 13 )\n              goto LABEL_86;\n            if ( v9 > 13 )\n            {\n              if ( v9 != 32 )\n              {\n                v12 = v9 == 37;\n                goto LABEL_32;\n              }\nLABEL_87:\n              v17 = *(_DWORD *)(dword_80DBB80 + 28) + 1;\n              goto LABEL_88;\n            }\n            v13 = v9 == -2;\n          }\n          if ( v13 )\n          {\n            v16 = 1;\n            goto LABEL_90;\n          }\nLABEL_142:\n          if ( (unsigned __int8)(v10 - 48) <= 9u )\n          {\n            v54[0] = v10;\n            sub_805628D();\n            printf(\":%c\", v10);\n            v42 = 1;\n            do\n            {\n              v43 = v42 + 1;\n              v44 = sub_8056EC2(v42 + 1);\n              v45 = v44;\n              if ( v44 > 0xFF )\n                break;\n              if ( (unsigned __int8)(v44 - 48) > 9u )\n                break;\n              v54[v42] = v44;\n              sub_804DD98(v44);\n              ++v42;\n            }\n            while ( v43 != 15 );\n            v54[v42] = 0;\n            v46 = sub_804ED6C(10, v54, 0, v45);\n            if ( (unsigned int)(v46 - 1) <= 0x98967E )\n            {\n              if ( v45 == 71 )\n                goto LABEL_183;\n              if ( v45 > 71 )\n              {\n                if ( v45 == 110 )\n                {\n                  sub_8056D7F(*(_DWORD *)(dword_80DBB80 + 84) + v46);\n                }\n                else if ( v45 > 110 )\n                {\n                  if ( v45 == 119 )\n                    goto LABEL_182;\n                  if ( v45 > 119 )\n                  {\n                    if ( v45 == 121 )\n                      goto LABEL_182;\n                    v47 = v45 == 122;\nLABEL_180:\n                    if ( v47 )\nLABEL_181:\n                      sub_8056CDB(v46);\n                  }\n                  else\n                  {\n                    if ( v45 == 112 )\n                      goto LABEL_184;\n                    v48 = v45 == 117;\nLABEL_176:\n                    if ( v48 )\n                      goto LABEL_182;\n                  }\n                }\n                else\n                {\n                  if ( v45 <= 101 )\n                  {\n                    if ( v45 >= 100 )\n                      goto LABEL_181;\n                    v48 = v45 == 98;\n                    goto LABEL_176;\n                  }\n                  if ( v45 == 103 )\n                  {\nLABEL_183:\n                    v49 = v46 - 1;\n                    goto LABEL_187;\n                  }\n                }\n              }\n              else if ( v45 == 37 )\n              {\nLABEL_184:\n                v52 = v46;\n                sub_80566B7();\n                v50 = *(_DWORD *)(dword_80DBB80 + 76);\n                if ( v50 <= 0 )\n                  v50 = *(_DWORD *)(dword_80DBB80 + 24);\n                v49 = v50 * v52 / 0x64u;\nLABEL_187:\n                sub_8056D4C(v49, 1);\n              }\n              else if ( v45 > 37 )\n              {\n                if ( v45 == 60 )\n                  goto LABEL_183;\n                if ( v45 > 60 )\n                {\n                  if ( v45 == 62 )\n                    goto LABEL_183;\n                  if ( v45 == 63 )\n                  {\n                    dword_80DBB9C |= 0x8000u;\nLABEL_189:\n                    sub_8056FFA();\n                  }\n                }\n                else if ( v45 == 47 )\n                {\n                  dword_80DBB9C &= ~0x8000u;\n                  goto LABEL_189;\n                }\n              }\n              else\n              {\n                if ( v45 != -2 )\n                {\n                  if ( v45 > -2 )\n                  {\n                    if ( v45 == 13 )\n                      goto LABEL_181;\n                    v47 = v45 == 32;\n                  }\n                  else\n                  {\n                    v47 = v45 == -3;\n                  }\n                  goto LABEL_180;\n                }\nLABEL_182:\n                sub_8056D0F(v46);\n              }\n            }\n            else\n            {\n              sub_80568D9();\n            }\n          }\n        }\n      }\n    }\n  }\n  return sub_80A98A4();\n}\n"
    ],
    "sub_805788C": [
        "0x805788c",
        "char *__fastcall sub_805788C(int *a1, char *a2)\n{\n  char *v2; // ebx\n  int v4; // esi\n  signed int v5; // ecx\n  int v6; // eax\n  int v7; // eax\n\n  v2 = a2;\n  v4 = *a1;\n  v5 = *a1 - 2;\n  if ( v5 > 0 )\n  {\n    v6 = sub_804E632(v5, a2);\n    if ( v6 < 0 )\n      v6 = 0;\n    v2[v6] = 0;\n    v7 = sub_80B2F61() - (_DWORD)v2 + 1;\n    v2 += v7;\n    *v2 = 0;\n    *a1 = v4 - v7;\n  }\n  return v2;\n}\n"
    ],
    "sub_80578C4": [
        "0x80578c4",
        "int sub_80578C4()\n{\n  int result; // eax\n  const char *v1; // ebx\n  char *v2; // esi\n  char *v3; // edi\n  char *v4; // ebp\n  unsigned int v5; // eax\n  int v6; // [esp+4h] [ebp-114h] BYREF\n  char v7[272]; // [esp+8h] [ebp-110h] BYREF\n\n  sub_804DF04(\"/sys/bus/scsi/devices\");\n  sub_804DF7E(\".\");\n  while ( 1 )\n  {\n    result = readdir64();\n    if ( !result )\n      break;\n    if ( (unsigned __int8)(*(_BYTE *)(result + 19) - 48) <= 9u )\n    {\n      v1 = (const char *)(result + 19);\n      if ( strchr((const char *)(result + 19), 58) )\n      {\n        if ( !chdir(v1) )\n        {\n          v6 = 256;\n          v2 = sub_805788C(&v6, v7);\n          v3 = sub_805788C(&v6, v2);\n          v4 = sub_805788C(&v6, v3);\n          sub_805788C(&v6, v4);\n          printf(\"[%s]\\t\", v1);\n          v5 = sub_804ED6C(10, v2, 0, (int)v1);\n          if ( *(_DWORD *)dword_80DBB7C || v5 > 0x1F || !*sub_804D2B4(\"disk\", v5) )\n            printf(\"(%s)\\t\");\n          else\n            printf(\"%s\\t\");\n          printf(\"%s\\t%s\\t%s\\n\", v7, v3, v4);\n          sub_804DF04(\"/sys/bus/scsi/devices\");\n        }\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80579ED": [
        "0x80579ed",
        "int __cdecl sub_80579ED(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // ebp\n  int v4; // esi\n  __gid_t v5; // eax\n  __uid_t v6; // eax\n  char *v7; // ebx\n  char *v8; // edx\n  char *v9; // edi\n  __dev_t v10; // rax\n  unsigned int v12; // [esp+4h] [ebp-F8h]\n  __gid_t v13; // [esp+8h] [ebp-F4h]\n  __gid_t group; // [esp+Ch] [ebp-F0h]\n  __uid_t owner; // [esp+10h] [ebp-ECh]\n  int v16; // [esp+14h] [ebp-E8h] BYREF\n  char *file; // [esp+18h] [ebp-E4h] BYREF\n  char *s; // [esp+1Ch] [ebp-E0h] BYREF\n  __mode_t mode; // [esp+20h] [ebp-DCh] BYREF\n  int v20; // [esp+24h] [ebp-D8h] BYREF\n  unsigned int v21; // [esp+28h] [ebp-D4h] BYREF\n  int v22; // [esp+2Ch] [ebp-D0h] BYREF\n  int v23; // [esp+30h] [ebp-CCh] BYREF\n  int v24; // [esp+34h] [ebp-C8h] BYREF\n  int v25; // [esp+38h] [ebp-C4h] BYREF\n  char v26; // [esp+63h] [ebp-99h] BYREF\n  int v27; // [esp+9Ch] [ebp-60h]\n\n  file = \"-\";\n  sub_80ABEAC(a2, \"^d:\", &file);\n  v2 = (const char **)(a2 + 4 * optind);\n  sub_804DF04(*v2);\n  umask(0);\n  printf(\"rootdir=%s\\ntable=\", *v2);\n  if ( *file == 45 && !file[1] )\n    puts(\"<stdin>\");\n  else\n    printf(\"'%s'\\n\", file);\n  owner = sub_80B052C();\n  v3 = 0;\nLABEL_6:\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    s = (char *)493;\n    mode = 0;\n    v20 = 0;\n    v21 = 0;\n    v22 = 0;\n    v23 = 0;\n    v4 = *(_DWORD *)(owner + 24);\n    if ( sscanf(\n           file,\n           \"%*s%n %c %o %40s %40s %u %u %u %u %u\",\n           &v24,\n           (char *)&v16 + 3,\n           &s,\n           (char *)&v25 + 2,\n           &v26,\n           &mode,\n           &v20,\n           &v23,\n           &v22,\n           &v21) <= 0\n      || (v22 | v21 | v23 | v20 | mode) > 0xFF )\n    {\n      sub_804D5F4(\"invalid line %d: '%s'\", v4, file);\n      goto LABEL_36;\n    }\n    if ( v26 )\n      v5 = sub_80A9A55();\n    else\n      v5 = getgid();\n    v13 = v5;\n    if ( BYTE2(v25) )\n      v6 = sub_80A9A55();\n    else\n      v6 = getuid();\n    group = v6;\n    file[v24] = 0;\n    v7 = file;\n    if ( *file == 47 )\n      v7 = file + 1;\n    if ( HIBYTE(v16) == 100 )\n    {\n      v8 = s;\n      BYTE1(v8) = BYTE1(s) | 0x40;\n      sub_80B00B9(4, v8);\n      if ( chown(v7, group, v13) == -1 )\n        goto LABEL_20;\nLABEL_25:\n      if ( chmod(v7, (__mode_t)s) < 0 )\n      {\n        sub_804D3A5((int)\"line %d: can't chmod %s\", v4, v7);\n        goto LABEL_36;\n      }\n    }\n    else\n    {\n      switch ( HIBYTE(v16) )\n      {\n        case 'f':\n          if ( stat64() >= 0 && (v27 & 0xF000) == 0x8000 )\n          {\n            if ( chown(v7, group, v13) < 0 )\n            {\nLABEL_20:\n              sub_804D3A5((int)\"line %d: can't chown %s\", v4, v7);\n              break;\n            }\n            goto LABEL_25;\n          }\n          sub_804D3A5((int)\"line %d: regular file '%s' does not exist\", v4, v7);\n          break;\n        case 'p':\n          s = (char *)((unsigned int)s | 0x1000);\n          goto LABEL_37;\n        case 'c':\n          s = (char *)((unsigned int)s | 0x2000);\n          goto LABEL_37;\n        case 'b':\n          s = (char *)((unsigned int)s | 0x6000);\nLABEL_37:\n          if ( v21 )\n            --v21;\n          v12 = 0;\n          while ( 2 )\n          {\n            if ( v21 < v12 )\n              goto LABEL_6;\n            v9 = v7;\n            if ( v21 )\n              v9 = sub_804DDBF(\"%s%u\", v7, v23 + v12);\n            v10 = sub_80B0220();\n            if ( mknod(v9, (__mode_t)s, v10) && *(_DWORD *)dword_80DBB7C != 17 )\n            {\n              sub_804D3A5((int)\"line %d: can't create node %s\", v4, v9);\n              goto LABEL_50;\n            }\n            if ( chown(v9, group, v13) < 0 )\n            {\n              sub_804D3A5((int)\"line %d: can't chown %s\", v4, v9);\n              goto LABEL_50;\n            }\n            if ( chmod(v9, (__mode_t)s) < 0 )\n            {\n              sub_804D3A5((int)\"line %d: can't chmod %s\", v4, v9);\nLABEL_50:\n              v3 = 1;\n            }\n            if ( v21 )\n              free(v9);\n            ++v12;\n            continue;\n          }\n        default:\n          sub_804D5F4(\"line %d: unsupported file type %c\", v4, HIBYTE(v16));\n          break;\n      }\nLABEL_36:\n      v3 = 1;\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_8057D52": [
        "0x8057d52",
        "int __cdecl sub_8057D52(int a1, int a2)\n{\n  const char **v2; // ebp\n  char *v3; // eax\n  char *v4; // esi\n  int v5; // eax\n  int v6; // ebx\n  int v7; // eax\n  int v8; // ebx\n  speed_t v9; // eax\n  const char *v10; // ebp\n  nfds_t v11; // edi\n  signed int v12; // eax\n  int v14; // [esp-Ch] [ebp-F4h]\n  char v15; // [esp+0h] [ebp-E8h]\n  char buf; // [esp+7h] [ebp-E1h] BYREF\n  int v17; // [esp+8h] [ebp-E0h] BYREF\n  int v18; // [esp+Ch] [ebp-DCh] BYREF\n  int timeout; // [esp+10h] [ebp-D8h] BYREF\n  struct pollfd fds; // [esp+14h] [ebp-D4h] BYREF\n  int v21; // [esp+1Ch] [ebp-CCh]\n  __int16 v22; // [esp+20h] [ebp-C8h]\n  __int16 v23; // [esp+22h] [ebp-C6h]\n  struct termios v24; // [esp+24h] [ebp-C4h] BYREF\n  struct termios v25; // [esp+60h] [ebp-88h] BYREF\n  struct termios termios_p; // [esp+9Ch] [ebp-4Ch] BYREF\n\n  v17 = 9600;\n  v18 = -1;\n  timeout = -1;\n  v15 = sub_80ABEAC(a2, \"^Xs:+d:+t:+\", &v17, &v18, &timeout);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = sub_804D315(*v2);\n  v4 = sub_804DDBF(\"/var/lock/LCK..%s\", v3);\n  v5 = open64();\n  if ( v5 >= 0 )\n  {\n    v6 = v5;\n    getpid();\n    dprintf();\n    close(v6);\n  }\n  else\n  {\n    if ( *(_DWORD *)dword_80DBB7C == 17 )\n      sub_804D3C9((int)\"can't create '%s'\", v4);\n    v4 = 0;\n  }\n  sub_804E6C8(40966, (void (*)(int))sub_804E68E);\n  byte_80DBBA4 = 1;\n  v7 = sub_804DC14(*v2);\n  v8 = v7;\n  if ( v7 >= 0 )\n  {\n    v14 = v7;\n    fcntl64();\n    sub_804D9A3(&v25, v8, &termios_p, 15);\n    v9 = sub_80B2EFA(v14, 4, 2);\n    cfsetspeed(&termios_p, v9);\n    v10 = *v2;\n    if ( tcsetattr(v8, 2, &termios_p) )\n    {\n      sub_804D3A5((int)\"can't tcsetattr for %s\", v10);\n      goto LABEL_15;\n    }\n    if ( isatty(0) )\n    {\n      sub_804D9A3(&v24, 0, &termios_p, 15);\n      if ( tcsetattr(0, 2, &termios_p) )\n      {\n        sub_804D3A5((int)\"can't tcsetattr for %s\", \"stdin\");\n        goto LABEL_15;\n      }\n    }\n    fds.fd = v8;\n    fds.events = 1;\n    v21 = 0;\n    v22 = 1;\n    byte_80DBBA4 = 0;\n    v11 = 2;\n    while ( 1 )\n    {\n      if ( byte_80DBBA4 || poll(&fds, v11, timeout) <= 0 )\n      {\nLABEL_13:\n        tcsetattr(v8, 2, &v25);\n        if ( isatty(0) )\n          tcsetattr(0, 2, &v24);\n        goto LABEL_15;\n      }\n      if ( v11 != 2 )\n        break;\n      if ( v23 )\n      {\n        if ( sub_804E5BC(1u, &buf, 0) <= 0 )\n          break;\n        if ( (v15 & 1) != 0 )\n          goto LABEL_26;\n        if ( buf )\n        {\n          if ( buf == 24 )\n            goto LABEL_13;\nLABEL_26:\n          write(v8, &buf, 1u);\n          if ( v18 >= 0 )\n            sub_80B2C0A(v18, 1u);\n          goto LABEL_29;\n        }\n        tcsendbreak(v8, 0);\n      }\nLABEL_29:\n      if ( fds.revents )\n      {\n        v12 = sub_804E5BC(0x400u, &qword_80DB778, v8);\n        if ( v12 <= 0 )\n        {\n          byte_80DBBA4 = 1;\n          goto LABEL_13;\n        }\n        sub_804E586(v12, (char *)&qword_80DB778);\n      }\n    }\n    v11 = 1;\n    goto LABEL_29;\n  }\nLABEL_15:\n  if ( v4 )\n    unlink(v4);\n  return byte_80DBBA4;\n}\n"
    ],
    "sub_8058004": [
        "0x8058004",
        "int __cdecl sub_8058004(int a1, _DWORD *a2)\n{\n  _DWORD *v2; // ebx\n  const char *v3; // eax\n  const char *v4; // esi\n  int v5; // eax\n  __int16 v6; // di\n  int v7; // eax\n  int v9; // [esp+0h] [ebp-18h] BYREF\n  int v10; // [esp+4h] [ebp-14h] BYREF\n  int v11; // [esp+8h] [ebp-10h]\n\n  v2 = a2;\n  v3 = (const char *)a2[1];\n  if ( !v3 )\nLABEL_2:\n    sub_804CDC2();\n  if ( !strcmp(v3, \"-f\") )\n  {\n    v4 = (const char *)a2[2];\n    if ( !v4 || !a2[3] )\n      goto LABEL_2;\n    v2 = a2 + 2;\n  }\n  else\n  {\n    v4 = \"/dev/tape\";\n  }\n  v5 = sub_804D222(\"bsf\", (const char *)v2[1]);\n  if ( v5 < 0 )\n    sub_804D5E0(\"unrecognized opcode %s\", (const char *)v2[1]);\n  v6 = word_80B5520[v5];\n  LOWORD(v10) = v6;\n  if ( v2[2] )\n    v11 = sub_80B4187();\n  else\n    v11 = 1;\n  v7 = sub_804DBE1(v4);\n  if ( v6 == 23 )\n  {\n    sub_804E029(v7, 0x80046D03, (int)&v9, \"%s\", v4);\n    printf(\"At block %d\\n\", v9);\n  }\n  else\n  {\n    sub_804E029(v7, 0x40086D01u, (int)&v10, \"%s\", v4);\n  }\n  return 0;\n}\n"
    ],
    "sub_80580FA": [
        "0x80580fa",
        "const char *__cdecl sub_80580FA(int a1, int a2)\n{\n  const char **i; // ebx\n  const char *result; // eax\n  int v4; // esi\n\n  sub_80ABEAC(a2, &data);\n  for ( i = (const char **)(a2 + 4 * optind); ; ++i )\n  {\n    result = *i;\n    if ( !*i )\n      break;\n    v4 = sub_804DBE1(result);\n    sub_804E029(v4, 0x125Fu, 0, \"%s\", *i);\n    close(v4);\n  }\n  return result;\n}\n"
    ],
    "sub_8058149": [
        "0x8058149",
        "int __cdecl sub_8058149(int a1, int a2)\n{\n  struct utmpx *v2; // eax\n  __pid_t ut_pid; // ecx\n  int v4; // ebx\n\n  if ( *(_DWORD *)(a2 + 4) )\n    utmpxname();\n  setutxent();\n  do\n  {\n    v2 = getutxent();\n    if ( !v2 )\n    {\n      puts(\"unknown\");\n      return 1;\n    }\n  }\n  while ( v2->ut_type != 1 );\n  ut_pid = v2->ut_pid;\n  v4 = (unsigned __int8)(ut_pid / 256);\n  if ( !(unsigned __int8)(ut_pid / 256) )\n    v4 = 78;\n  printf(\"%c %c\\n\", v4, ut_pid % 256);\n  return 0;\n}\n"
    ],
    "sub_80581BA": [
        "0x80581ba",
        "int __cdecl sub_80581BA(int a1, int a2)\n{\n  const char **v2; // ebx\n  int (*v3)(const char *, const char *, const void *, size_t, int); // esi\n  int (*v4)(const char *, const char *); // edi\n  const char *v5; // ebp\n  int v6; // eax\n  size_t v7; // eax\n  char v9; // [esp+4h] [ebp-28h]\n  int flags; // [esp+8h] [ebp-24h]\n  char *v11; // [esp+Ch] [ebp-20h]\n  char *v12; // [esp+10h] [ebp-1Ch]\n  void *value; // [esp+14h] [ebp-18h] BYREF\n  char *v14; // [esp+18h] [ebp-14h] BYREF\n\n  v14 = (char *)&data;\n  v9 = sub_80ABEAC(a2, \"^hx:n:v:\", &value, &value, &v14);\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( (v9 & 1) != 0 )\n  {\n    v3 = lsetxattr;\n    v4 = lremovexattr;\n  }\n  else\n  {\n    v3 = setxattr;\n    v4 = removexattr;\n  }\n  flags = 0;\n  do\n  {\n    v5 = *v2;\n    if ( (v9 & 2) != 0 )\n    {\n      v6 = v4(v5, (const char *)value);\n    }\n    else\n    {\n      v12 = (char *)value;\n      v11 = v14;\n      v7 = strlen(v14);\n      v6 = v3(v5, v12, v11, v7, 0);\n    }\n    if ( v6 )\n    {\n      sub_804D3F1(*v2);\n      flags = 1;\n    }\n    ++v2;\n  }\n  while ( *v2 );\n  return flags;\n}\n"
    ],
    "sub_805827B": [
        "0x805827b",
        "int __usercall sub_805827B@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // esi\n\n  v4 = 0;\n  while ( *a1 )\n  {\n    if ( !strcasecmp(a1, a2) )\n      return v4;\n    a1 += strlen(a1) + 1;\n    ++v4;\n  }\n  return -1;\n}\n"
    ],
    "sub_80582AD": [
        "0x80582ad",
        "int __usercall sub_80582AD@<eax>(char *a1@<eax>, int a2@<ebx>)\n{\n  return sub_804EDC5(0, a1, 0, a2);\n}\n"
    ],
    "sub_80582B6": [
        "0x80582b6",
        "int __usercall sub_80582B6@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>)\n{\n  int v6; // ebx\n  const char *v7; // eax\n\n  v6 = a2 & 1;\n  if ( (a2 & 1) != 0 && (v6 = ioctl(a1, 0x541Fu, a3), v6 < 0) )\n  {\n    v7 = \"can't set serial info\";\n  }\n  else if ( (a2 & 2) != 0 && (v6 = ioctl(a1, 0x5453u), v6 < 0) )\n  {\n    v7 = \"can't autoconfigure port\";\n  }\n  else\n  {\n    if ( (a2 & 4) == 0 )\n      goto LABEL_7;\n    v6 = ioctl(a1, 0x541Eu, a3);\n    if ( v6 >= 0 )\n      goto LABEL_7;\n    v7 = \"can't get serial info\";\n  }\n  sub_804D3F1(v7);\n  if ( (a2 & 0x10) == 0 )\n    exit(1);\nLABEL_7:\n  if ( (a2 & 8) != 0 )\n    close(a1);\n  return v6;\n}\n"
    ],
    "sub_8058350": [
        "0x8058350",
        "int __cdecl sub_8058350(int a1, int a2)\n{\n  int v2; // esi\n  const char *v3; // ebx\n  int v4; // eax\n  int v5; // ebp\n  char **i; // ecx\n  char **v7; // ebx\n  char *v8; // edi\n  bool j; // zf\n  const char *v10; // ebx\n  int v11; // eax\n  const char *v12; // eax\n  const char *v13; // edi\n  const char *v14; // ebx\n  int v15; // eax\n  int v16; // ecx\n  int v17; // edx\n  int k; // ebp\n  const char *v19; // edi\n  int v20; // eax\n  char *v21; // edi\n  int v22; // eax\n  char *v23; // edi\n  int v24; // edx\n  int v25; // eax\n  const char *v26; // eax\n  const char *v27; // eax\n  int v29; // [esp+0h] [ebp-5Ch]\n  char v30; // [esp+0h] [ebp-5Ch]\n  char v31; // [esp+4h] [ebp-58h]\n  unsigned __int16 v32; // [esp+8h] [ebp-54h]\n  char **v33; // [esp+8h] [ebp-54h]\n  const char *v34; // [esp+Ch] [ebp-50h]\n  int v35[2]; // [esp+10h] [ebp-4Ch] BYREF\n  int v36; // [esp+18h] [ebp-44h]\n  int v37; // [esp+1Ch] [ebp-40h]\n  int v38; // [esp+20h] [ebp-3Ch]\n  int v39; // [esp+28h] [ebp-34h]\n  int v40; // [esp+2Ch] [ebp-30h]\n  unsigned __int16 v41; // [esp+30h] [ebp-2Ch]\n  unsigned __int16 v42; // [esp+38h] [ebp-24h]\n\n  v31 = sub_80ABEAC(a2, \"^bGavzgq\");\n  v2 = a2 + 4 * optind;\n  if ( !*(_DWORD *)(v2 + 4) )\n    v31 |= 0x20u;\n  if ( (v31 & 0x20) == 0 )\n  {\n    v3 = *(const char **)v2;\n    v4 = sub_80AA444();\n    v5 = v4;\n    if ( v4 < 0 )\n    {\n      sub_804D3F1(v3);\n      exit(201);\n    }\n    sub_80582B6(v4, 4, (int)v35);\n    if ( (v31 & 0x10) != 0 )\n      v38 = 0;\n    for ( i = (char **)v2; ; i = v7 )\n    {\n      v7 = i + 1;\n      v8 = i[1];\n      if ( !v8 )\n        break;\n      v33 = i;\n      v30 = *v8;\n      v19 = &v8[*v8 == 94];\n      v20 = sub_805827B(\"spd_normal\", v19);\n      if ( v20 < 0 )\n        sub_804D5E0(\"invalid flag: %s\", v19);\n      if ( (unsigned int)(v20 - 16) <= 6 )\n      {\n        v7 = v33 + 2;\n        if ( !v33[2] )\n          sub_804D5E0(\"%s requires an argument\", v19);\n      }\n      if ( v30 == 94 )\n      {\n        if ( (unsigned int)(v20 - 6) > 9 )\n          sub_804D5E0(\"can't invert %s\", v19);\n        v38 &= ~(unsigned __int16)word_80B5580[v20];\n      }\n      else\n      {\n        switch ( v20 )\n        {\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n            v38 &= 0xFFFFEFCF;\n            goto LABEL_45;\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 11:\n          case 12:\n          case 13:\n          case 14:\n          case 15:\nLABEL_45:\n            v38 |= (unsigned __int16)word_80B5580[v20];\n            break;\n          case 16:\n            v36 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 17:\n            v37 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 18:\n            v39 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 19:\n            v21 = *v7;\n            v22 = sub_805827B(\"unknown\", *v7);\n            if ( v22 < 0 )\n              sub_804D5E0(\"illegal UART type: %s\", v21);\n            v35[0] = v22;\n            break;\n          case 20:\n            v40 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 21:\n            v41 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 22:\n            v23 = *v7;\n            v24 = strcasecmp(*v7, \"none\");\n            LOWORD(v25) = -1;\n            if ( v24 )\n            {\n              v25 = strcasecmp(v23, \"infinite\");\n              if ( v25 )\n                LOWORD(v25) = sub_80582AD(v23, (int)v7);\n            }\n            v42 = v25;\n            break;\n          case 23:\n            sub_80582B6(v5, 7, (int)v35);\n            break;\n          default:\n            continue;\n        }\n      }\n    }\n    sub_80582B6(v5, 9, (int)v35);\n    *(_DWORD *)(v2 + 4) = 0;\n  }\n  for ( j = (v31 & 0x28) == 0; !j; j = *(_DWORD *)v2 == 0 )\n  {\n    v29 = v31 & 7;\n    v10 = *(const char **)v2;\n    v11 = sub_80AA444();\n    if ( v11 < 0 )\n    {\n      if ( v29 != 1 )\n        sub_804D3F1(v10);\n      goto LABEL_33;\n    }\n    if ( sub_80582B6(v11, 28, (int)v35) < 0 )\n      goto LABEL_33;\n    v12 = \"undefined\";\n    if ( v35[0] <= 19 )\n      v12 = sub_804D2B4(\"unknown\", v35[0]);\n    if ( v29 == 1 )\n    {\n      if ( !v35[0] )\n        goto LABEL_33;\n      printf(\"%s at 0x%.4x (irq = %d) is a %s\", v10, v36, v37, v12);\n      v13 = \")\";\n      v14 = \" IO_support\\t=%3ld (\" + 17;\n    }\n    else\n    {\n      if ( (v31 & 7u) <= 1 )\n      {\n        printf(\"%s, UART: %s, Port: 0x%.4x, IRQ: %d\", v10, v12, v36, v37);\nLABEL_72:\n        v13 = &data;\n        v14 = \", Flags: \";\n        goto LABEL_22;\n      }\n      if ( v29 == 2 )\n      {\n        printf(\"%s uart %s port 0x%.4x irq %d baud_base %d\", v10, v12, v36, v37, v40);\n        v13 = &data;\n        v14 = \"        \" + 7;\n        goto LABEL_22;\n      }\n      if ( v29 != 4 )\n        goto LABEL_72;\n      printf(\"%s, Line %d, UART: %s, Port: 0x%.4x, IRQ: %d\\n\", v10, v35[1], v12, v36, v37);\n      printf(\"\\tBaud_base: %d, close_delay: %u, divisor: %d\\n\", v40, v41, v39);\n      printf(\"\\tclosing_wait: \");\n      if ( v42 )\n      {\n        if ( v42 == 0xFFFF )\n          puts(\"none\");\n        else\n          printf(\"%u\\n\", v42);\n      }\n      else\n      {\n        puts(\"infinite\");\n      }\n      v13 = \"\\n\";\n      v14 = \"\\tFlags: \";\n    }\nLABEL_22:\n    v32 = v38;\n    v15 = v38 & 0x1030;\n    if ( v15 == 48 )\n    {\n      v17 = 5;\n      goto LABEL_80;\n    }\n    if ( (v38 & 0x1030u) > 0x30 )\n    {\n      if ( v15 == 4096 )\n      {\n        v17 = 3;\n        goto LABEL_80;\n      }\n      if ( v15 == 4112 )\n      {\n        v17 = 4;\n        goto LABEL_80;\n      }\n    }\n    else\n    {\n      if ( v15 == 16 )\n      {\n        v17 = 1;\n        goto LABEL_80;\n      }\n      if ( v15 == 32 )\n      {\n        v17 = 2;\nLABEL_80:\n        v26 = sub_804D2B4(\"spd_normal\", v17);\n        v16 = (int)v14;\n        if ( v26 )\n        {\n          printf(\"%s%s\", v14, v26);\n          v16 = 135056574;\n        }\n        goto LABEL_27;\n      }\n    }\n    v16 = (int)v14;\n    v17 = 0;\n    if ( (v31 & 7u) > 1 )\n      goto LABEL_80;\nLABEL_27:\n    for ( k = 6; k != 16; ++k )\n    {\n      if ( ((unsigned __int16)word_80B5580[k] & v32) != 0 && ((v31 & 7u) > 1 || (unsigned int)(k - 9) > 5) )\n      {\n        v34 = (const char *)v16;\n        v27 = sub_804D2B4(\"spd_normal\", k);\n        printf(\"%s%s\", v34, v27);\n        v16 = 135056574;\n      }\n    }\n    if ( v14 == (const char *)v16 )\n      v13 = &data;\n    puts(v13);\nLABEL_33:\n    v2 += 4;\n  }\n  return 0;\n}\n"
    ],
    "sub_80587FA": [
        "0x80587fa",
        "void __cdecl __noreturn sub_80587FA(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  int v3; // esi\n  int v4; // eax\n  unsigned int v5; // eax\n  int v6; // ecx\n  int v7; // edi\n  unsigned int v8; // esi\n  unsigned __int8 *v9; // eax\n  int v10; // ebp\n  int v11; // [esp+0h] [ebp-3Ch]\n  _BYTE *v12; // [esp+8h] [ebp-34h]\n  char *format; // [esp+Ch] [ebp-30h]\n  __int64 v14; // [esp+10h] [ebp-2Ch]\n  const char *v15; // [esp+18h] [ebp-24h]\n  __int64 v16; // [esp+1Ch] [ebp-20h]\n  char *v17; // [esp+24h] [ebp-18h] BYREF\n  char v18[4]; // [esp+28h] [ebp-14h] BYREF\n\n  v17 = \"4\";\n  *(_DWORD *)v18 = \"o\";\n  sub_80ABEAC(a2, \"afon:t:\", &v17, v18);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  v3 = sub_80B40CC(0x7FFFFFFF, 1);\n  v12 = sub_804DB2E(v3 + 1);\n  v4 = v3 - 1;\n  v11 = v3 - 1;\n  LOBYTE(v4) = **(_BYTE **)v18;\n  v5 = v4 - 100;\n  if ( (unsigned __int8)v5 > 0x14u || (v6 = 1050625, !_bittest(&v6, v5)) || *(_BYTE *)(*(_DWORD *)v18 + 1) )\n    sub_804CDC2();\n  v15 = sub_804DDBF(\"%%7ll%s \", *(const char **)v18);\n  format = \"%s: \";\n  if ( !*v2 )\n  {\n    *--v2 = \"standard input\";\n    format = \"{%s}: \";\n  }\n  LODWORD(v16) = v3 - 1;\n  while ( 1 )\n  {\n    v7 = sub_80B3D76();\n    if ( v7 )\n    {\n      HIDWORD(v16) = v11 >> 31;\n      v14 = -v16;\n      v8 = 0;\n      do\n      {\n        v9 = *(unsigned __int8 **)(v7 + 16);\n        if ( (unsigned int)v9 >= *(_DWORD *)(v7 + 24) )\n        {\n          v10 = __fgetc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(v7 + 16) = v9 + 1;\n          v10 = *v9;\n        }\n        if ( (unsigned int)(v10 - 32) <= 0x5E || v10 == 9 )\n        {\n          if ( v8 <= v11 )\n          {\n            v12[v8] = v10;\n            if ( v8 == v11 )\n            {\n              if ( (dword_80DBB9C & 2) != 0 )\n                printf(format);\n              if ( (dword_80DBB9C & 0x14) != 0 )\n                printf(v15, v14);\n              fputs_unlocked();\n            }\n            ++v8;\n          }\n          else\n          {\n            sub_804DD98(v10);\n          }\n        }\n        else\n        {\n          if ( v8 > v11 )\n            sub_804DD98(10);\n          v8 = 0;\n        }\n        ++v14;\n      }\n      while ( v10 != -1 );\n      sub_80AB218();\n    }\n    if ( !*++v2 )\n      sub_80AB247();\n  }\n}\n"
    ],
    "sub_80589BE": [
        "0x80589be",
        "unsigned int __usercall sub_80589BE@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>)\n{\n  if ( 0x7FFFFFFF / a1 >= a2 )\n    return (a2 * a1) >> 10;\n  else\n    return a1 * (a2 >> 10);\n}\n"
    ],
    "sub_80589E4": [
        "0x80589e4",
        "__sighandler_t __fastcall sub_80589E4(int a1, int a2)\n{\n  __pid_t v2; // eax\n  __pid_t v3; // edi\n  void (*v4)(int); // esi\n  void (*v5)(int); // ebx\n  __pid_t v6; // eax\n\n  *(_DWORD *)(a2 + 76) = sub_804EC14();\n  v2 = vfork();\n  if ( v2 < 0 )\n    sub_804D3C9((int)&unk_80C7DA0);\n  if ( !v2 )\n    sub_80AB1EC();\n  v3 = v2;\n  v4 = signal(2, (__sighandler_t)1);\n  v5 = signal(3, (__sighandler_t)1);\n  while ( 1 )\n  {\n    v6 = wait3((void *)a2, 0, (struct rusage *)(a2 + 4));\n    if ( v3 == v6 )\n      break;\n    if ( v6 == -1 && *(_DWORD *)dword_80DBB7C != 4 )\n    {\n      sub_804D3A5((int)\"wait\");\n      goto LABEL_11;\n    }\n  }\n  *(_DWORD *)(a2 + 76) = sub_804EC14() - *(_DWORD *)(a2 + 76);\nLABEL_11:\n  signal(2, v4);\n  return signal(3, v5);\n}\n"
    ],
    "sub_8058A8D": [
        "0x8058a8d",
        "void __cdecl __noreturn sub_8058A8D(int a1, int a2)\n{\n  char *v2; // eax\n  char v3; // al\n  int v4; // ecx\n  int v5; // ebx\n  char *v6; // esi\n  int v7; // ebx\n  unsigned int v8; // ebp\n  size_t v9; // eax\n  size_t v10; // edi\n  _DWORD *v11; // esi\n  const char *v12; // eax\n  unsigned int v13; // esi\n  unsigned int v14; // edx\n  unsigned int v15; // esi\n  unsigned int v16; // eax\n  unsigned int v17; // eax\n  int v18; // ecx\n  int v19; // edi\n  int v20; // eax\n  unsigned int v21; // edx\n  unsigned int v22; // [esp-Ch] [ebp-84h]\n  unsigned int v23; // [esp-Ch] [ebp-84h]\n  unsigned int v24; // [esp-8h] [ebp-80h]\n  unsigned int v25; // [esp-8h] [ebp-80h]\n  unsigned int v26; // [esp-4h] [ebp-7Ch]\n  unsigned int v27; // [esp-4h] [ebp-7Ch]\n  int v28; // [esp-4h] [ebp-7Ch]\n  int v29; // [esp-4h] [ebp-7Ch]\n  char v30; // [esp+0h] [ebp-78h]\n  int v31; // [esp+0h] [ebp-78h]\n  _DWORD *v32; // [esp+4h] [ebp-74h]\n  char *v33; // [esp+8h] [ebp-70h]\n  unsigned int v34; // [esp+Ch] [ebp-6Ch]\n  char *s; // [esp+10h] [ebp-68h] BYREF\n  const char *v36; // [esp+14h] [ebp-64h] BYREF\n  int v37; // [esp+18h] [ebp-60h] BYREF\n  int v38; // [esp+1Ch] [ebp-5Ch]\n  int v39; // [esp+20h] [ebp-58h]\n  int v40; // [esp+24h] [ebp-54h]\n  int v41; // [esp+28h] [ebp-50h]\n  unsigned int v42; // [esp+2Ch] [ebp-4Ch]\n  unsigned int v43; // [esp+30h] [ebp-48h]\n  unsigned int v44; // [esp+34h] [ebp-44h]\n  unsigned int v45; // [esp+38h] [ebp-40h]\n  int v46; // [esp+3Ch] [ebp-3Ch]\n  int v47; // [esp+40h] [ebp-38h]\n  int v48; // [esp+44h] [ebp-34h]\n  int v49; // [esp+48h] [ebp-30h]\n  int v50; // [esp+4Ch] [ebp-2Ch]\n  int v51; // [esp+50h] [ebp-28h]\n  int v52; // [esp+54h] [ebp-24h]\n  int v53; // [esp+58h] [ebp-20h]\n  int v54; // [esp+5Ch] [ebp-1Ch]\n  int v55; // [esp+60h] [ebp-18h]\n  unsigned int v56; // [esp+64h] [ebp-14h]\n\n  v2 = getenv(\"TIME\");\n  if ( !v2 )\n    v2 = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n  s = v2;\n  v3 = sub_80ABEAC(a2, \"^+vpao:f:\", &v36, &s);\n  v32 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v3 & 1) != 0 )\n    s = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n        \"\\tUser time (seconds): %U\\n\"\n        \"\\tSystem time (seconds): %S\\n\"\n        \"\\tPercent of CPU this job got: %P\\n\"\n        \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n        \"\\tAverage shared text size (kbytes): %X\\n\"\n        \"\\tAverage unshared data size (kbytes): %D\\n\"\n        \"\\tAverage stack size (kbytes): %p\\n\"\n        \"\\tAverage total size (kbytes): %K\\n\"\n        \"\\tMaximum resident set size (kbytes): %M\\n\"\n        \"\\tAverage resident set size (kbytes): %t\\n\"\n        \"\\tMajor (requiring I/O) page faults: %F\\n\"\n        \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n        \"\\tVoluntary context switches: %w\\n\"\n        \"\\tInvoluntary context switches: %c\\n\"\n        \"\\tSwaps: %W\\n\"\n        \"\\tFile system inputs: %I\\n\"\n        \"\\tFile system outputs: %O\\n\"\n        \"\\tSocket messages sent: %s\\n\"\n        \"\\tSocket messages received: %r\\n\"\n        \"\\tSignals delivered: %k\\n\"\n        \"\\tPage size (bytes): %Z\\n\"\n        \"\\tExit status: %x\";\n  if ( (v3 & 2) != 0 )\n    s = \"real %e\\nuser %U\\nsys %S\";\n  v5 = 2;\n  if ( (v3 & 8) != 0 )\n    v5 = sub_804DBE1(v36);\n  sub_80589E4(v4, (int)&v37);\n  sub_804DC7B(v5, 1);\n  v6 = s;\n  v7 = getpagesize();\n  if ( (unsigned int)(unsigned __int16)v37 - 1 > 0xFE )\n  {\n    if ( (v37 & 0x7F) == 0 && BYTE1(v37) )\n      printf(\"Command exited with non-zero status %u\\n\", BYTE1(v37));\n  }\n  else\n  {\n    printf(\"Command terminated by signal %u\\n\", v37 & 0x7F);\n  }\n  v8 = (1000 * (v38 + v40) + (v39 + v41) / 1000) / 0xAu;\n  if ( !v8 )\n    v8 = 1;\n  v34 = 100 * (1000 * (v38 + v40) + (v39 + v41) / 1000);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      if ( !*v6 )\n      {\n        sub_804DD98(10);\n        sub_80AB247();\n      }\n      v30 = *v6;\n      v9 = strcspn(v6, \"%\\\\\");\n      v10 = v9;\n      if ( !v9 )\n        break;\n      printf(\"%.*s\", v9, v6);\n      v6 += v10;\n    }\n    v33 = v6 + 1;\n    if ( v30 == 37 )\n    {\n      switch ( v6[1] )\n      {\n        case 'C':\n          v11 = v32;\n          v12 = \"%s\";\n          do\n          {\n            printf(v12, *v11++);\n            v12 = \" %s\";\n          }\n          while ( *v11 );\n          goto LABEL_68;\n        case 'D':\n          v13 = sub_80589BE(v7, v44);\n          v14 = v45;\n          goto LABEL_34;\n        case 'E':\n          if ( v56 / 0x3E8 <= 0xE0F )\n          {\n            v27 = v56 / 0xA % 0x64;\n            v25 = v56 / 0x3E8 % 0x3C;\n            v23 = v56 / 0xEA60;\nLABEL_29:\n            printf(\"%um %u.%02us\", v23, v25, v27);\n            goto LABEL_68;\n          }\n          v26 = v56 / 0x3E8 % 0x3C;\n          v24 = v56 / 0x3E8 % 0xE10 / 0x3C;\n          v22 = v56 / 0x36EE80;\n          break;\n        case 'F':\n          v28 = v47;\n          goto LABEL_31;\n        case 'I':\n          v28 = v49;\n          goto LABEL_31;\n        case 'K':\n          v15 = sub_80589BE(v7, v44);\n          v13 = sub_80589BE(v7, v45) + v15;\n          v14 = v43;\nLABEL_34:\n          v16 = v13 + sub_80589BE(v7, v14);\n          goto LABEL_62;\n        case 'M':\n          v17 = sub_80589BE(v7, v42);\n          goto LABEL_63;\n        case 'O':\n          v28 = v50;\n          goto LABEL_31;\n        case 'P':\n          if ( v56 )\n            printf(\"%u%%\", v34 / v56);\n          else\n            printf(\"?%%\");\n          goto LABEL_68;\n        case 'R':\n          v28 = v46;\n          goto LABEL_31;\n        case 'S':\n          printf(\"%u.%02u\", v40, v41 / 10000);\n          goto LABEL_68;\n        case 'T':\n          v18 = v40;\n          v19 = v40 % 60;\n          v31 = v40 / 60;\n          if ( v40 > 3599 )\n            goto LABEL_46;\n          v20 = v41;\n          goto LABEL_49;\n        case 'U':\n          printf(\"%u.%02u\", v38, v39 / 10000);\n          goto LABEL_68;\n        case 'W':\n          v28 = v48;\n          goto LABEL_31;\n        case 'X':\n          v21 = v43;\n          goto LABEL_61;\n        case 'Z':\n          v29 = v7;\n          goto LABEL_66;\n        case 'c':\n          v28 = v55;\n          goto LABEL_31;\n        case 'e':\n          printf(\"%u.%02u\", v56 / 0x3E8, v56 / 0xA % 0x64);\n          goto LABEL_68;\n        case 'k':\n          v28 = v53;\n          goto LABEL_31;\n        case 'p':\n          v21 = v45;\n          goto LABEL_61;\n        case 'r':\n          v28 = v52;\n          goto LABEL_31;\n        case 's':\n          v28 = v51;\n          goto LABEL_31;\n        case 't':\n          v21 = v44;\nLABEL_61:\n          v16 = sub_80589BE(v7, v21);\nLABEL_62:\n          v17 = v16 / v8;\nLABEL_63:\n          v28 = v17;\n          goto LABEL_31;\n        case 'u':\n          v18 = v38;\n          v19 = v38 % 60;\n          v31 = v38 / 60;\n          if ( v38 <= 3599 )\n          {\n            v20 = v39;\nLABEL_49:\n            v27 = v20 / 10000;\n            v25 = v19;\n            v23 = v31;\n            goto LABEL_29;\n          }\nLABEL_46:\n          v26 = v19;\n          v24 = v18 % 3600 / 0x3Cu;\n          v22 = v18 / 3600;\n          break;\n        case 'w':\n          v28 = v54;\nLABEL_31:\n          printf(\"%lu\", v28);\n          goto LABEL_68;\n        case 'x':\n          v29 = BYTE1(v37);\nLABEL_66:\n          printf(\"%u\", v29);\n          goto LABEL_68;\n        default:\n          goto LABEL_68;\n      }\n      printf(\"%uh %um %02us\", v22, v24, v26);\n    }\n    else\n    {\n      v33 = v6;\n    }\nLABEL_68:\n    v6 = v33 + 1;\n  }\n}\n"
    ],
    "sub_8058ECC": [
        "0x8058ecc",
        "int __cdecl sub_8058ECC(int a1, int a2)\n{\n  _DWORD *v2; // edi\n  int v3; // esi\n  const char *v4; // ebp\n  _DWORD *v5; // ebx\n  char *v6; // esi\n  unsigned __int16 v7; // ax\n  int v8; // eax\n  char *src; // [esp+4h] [ebp-14h]\n\n  if ( (a1 & 1) != 0 || a1 >> 1 <= 1 )\n    sub_804CDC2();\n  v2 = sub_804DB2E(0x1110u);\n  v3 = (a1 >> 1) - 1;\n  *v2 = v3;\n  if ( v3 > 32 )\n    sub_804D5E0(\"too many renames requested\");\n  v4 = *(const char **)(a2 + 4);\n  sub_80B313B();\n  v5 = (_DWORD *)(a2 + 8);\n  v6 = (char *)(v2 + 6);\n  while ( *v5 )\n  {\n    *((_DWORD *)v6 - 2) = sub_80B3162();\n    src = (char *)v5[1];\n    v7 = strnlen();\n    *((_WORD *)v6 - 2) = v7;\n    if ( v7 > 0x7Fu )\n      sub_804D5E0(\"new name '%s' is too long\", src);\n    strcpy(v6, src);\n    v5 += 2;\n    v6 += 136;\n  }\n  v8 = sub_804DBE1(v4);\n  sub_804E0BE(v8, 0x51106F03u, (int)v2, \"UBI_IOCRNVOL\");\n  return 0;\n}\n"
    ],
    "sub_8058F94": [
        "0x8058f94",
        "int sub_8058F94()\n{\n  write(3, \"Vcan't insert '%s': %s\", 1u);\n  return close(3);\n}\n"
    ],
    "sub_8058FAD": [
        "0x8058fad",
        "void __noreturn sub_8058FAD()\n{\n  sub_8058F94();\n  _exit(0);\n}\n"
    ],
    "sub_8058FB9": [
        "0x8058fb9",
        "void __cdecl __noreturn sub_8058FB9(int a1, int a2)\n{\n  char v2; // si\n  unsigned int v3; // ebx\n  const char *v4; // esi\n  int v5; // eax\n  int v6; // eax\n  __useconds_t i; // ebx\n  unsigned int v8; // [esp+0h] [ebp-18h] BYREF\n  int v9; // [esp+4h] [ebp-14h] BYREF\n  int v10[4]; // [esp+8h] [ebp-10h] BYREF\n\n  v8 = 60000;\n  v2 = sub_80ABEAC(a2, \"^Ft:T:\", &v9, v10);\n  if ( (v2 & 1) == 0 )\n    sub_80B3C0D();\n  if ( (v2 & 4) != 0 )\n    v8 = sub_80B40DC();\n  v3 = v8 >> 1;\n  if ( (v2 & 2) != 0 )\n    v3 = sub_80B40DC();\n  sub_804E6C8(117503054, (void (*)(int))sub_8058FAD);\n  v4 = *(const char **)(a2 + 4 * optind);\n  v5 = sub_804DBE1(v4);\n  sub_804DC97(v5, 3);\n  sub_8058F94();\n  v6 = sub_804DBE1(v4);\n  sub_804DC97(v6, 3);\n  v8 /= 0x3E8u;\n  sub_804E09D(3, 0x80045704, (int)&unk_80B77F8, \"WDIOC_SETOPTIONS\");\n  sub_804E09D(3, 0xC0045706, (int)&v8, \"WDIOC_SETTIMEOUT\");\n  for ( i = 1000 * v3; ; usleep(i) )\n    write(3, &data, 1u);\n}\n"
    ],
    "sub_80590CD": [
        "0x80590cd",
        "int __cdecl sub_80590CD(int a1, int a2)\n{\n  int v2; // ecx\n  const char *v3; // esi\n  int v4; // ebx\n  const char *v5; // eax\n\n  v3 = *(const char **)(a2 + 4);\n  if ( !v3 )\n    sub_804CDC2();\n  sub_8059B9B(v2, 0);\n  v4 = sub_8059C33();\n  if ( v4 )\n  {\n    v5 = (const char *)sub_8059CFC();\n    sub_804D5F4(\"can't insert '%s': %s\", v3, v5);\n  }\n  return v4;\n}\n"
    ],
    "sub_8059111": [
        "0x8059111",
        "int sub_8059111()\n{\n  const char *v0; // eax\n  int v1; // eax\n  int result; // eax\n  const char *v3; // [esp+0h] [ebp-18h]\n  const char *v4; // [esp+4h] [ebp-14h]\n  const char *v5; // [esp+8h] [ebp-10h]\n  char *s; // [esp+Ch] [ebp-Ch]\n\n  sub_80B052C();\n  printf(\"%-24sSize  Used by\", \"Module\");\n  v0 = (const char *)sub_80B24C7();\n  if ( v0 && (v1 = atoi(v0)) != 0 )\n    printf(\"    Tainted: %c%c%c\\n\", (v1 & 1) == 0 ? 71 : 80, (v1 & 2) == 0 ? 32 : 70, (v1 & 4) == 0 ? 32 : 83);\n  else\n    puts(\"    Not tainted\");\n  while ( 1 )\n  {\n    result = sub_80B0560(\"# \\t\");\n    if ( !result )\n      break;\n    if ( *s )\n      s[strlen(s) - 1] = 0;\n    printf(\"%-19s %8s %2s %s\\n\", v3, v4, v5, s);\n  }\n  return result;\n}\n"
    ],
    "sub_80591EC": [
        "0x80591ec",
        "int sub_80591EC()\n{\n  return sub_80B2549(&sub_8059389, 33, 0, 0, 0);\n}\n"
    ],
    "sub_8059202": [
        "0x8059202",
        "char *__usercall sub_8059202@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  void *v2; // ebx\n  size_t v5; // esi\n  size_t v6; // eax\n\n  v2 = (void *)a1;\n  if ( a2 )\n  {\n    if ( !a1 )\n      return sub_804DB46(a2);\n    v5 = strlen(a1);\n    v6 = strlen(a2);\n    v2 = sub_804DB13(v2, v5 + v6 + 2);\n    sprintf((char *)v2 + v5, \" %s\", a2);\n  }\n  return (char *)v2;\n}\n"
    ],
    "sub_8059250": [
        "0x8059250",
        "int __fastcall sub_8059250(int a1)\n{\n  int v1; // esi\n  const char *v3; // eax\n  int v4; // eax\n  int v5; // edx\n  const char *v6; // [esp+4h] [ebp-14h]\n  int v7; // [esp+8h] [ebp-10h]\n\n  sub_80B0511(a1, sub_80B3D45);\n  while ( 1 )\n  {\n    v1 = dword_80DBB80;\n    if ( !*(_DWORD *)(dword_80DBB80 + 8) || !sub_80B0560(\"# \\t\") )\n      break;\n    v3 = sub_804D378(v6, 58);\n    if ( v3 )\n    {\n      *v3 = 0;\n      sub_804D32D(v6);\n      v4 = sub_8059B8A();\n      if ( v4 )\n      {\n        v5 = *(_DWORD *)(v4 + 20);\n        if ( (v5 & 1) == 0 || (dword_80DBB9C & 0x60) != 0 )\n        {\n          *(_DWORD *)(v4 + 20) = v5 | 4;\n          if ( (v5 & 2) != 0 && !*(_DWORD *)(v4 + 12) )\n          {\n            --*(_DWORD *)(v1 + 8);\n            sub_804DB46(v6);\n            sub_80AFAC3();\n            if ( v7 )\n              sub_8059A79((char *)\" \\t\");\n          }\n        }\n      }\n    }\n  }\n  return sub_80B0536();\n}\n"
    ],
    "sub_805932D": [
        "0x805932d",
        "const char **sub_805932D()\n{\n  int v0; // ebx\n  char *v1; // ecx\n  unsigned __int8 i; // al\n  char v3; // dl\n  const char ***v4; // edi\n  const char **j; // ebx\n  char v7[268]; // [esp-10Ch] [ebp-10Ch] BYREF\n\n  v0 = dword_80DBB80 + 404;\n  sub_8059AC2();\n  v1 = v7;\n  for ( i = 0; ; i += 32 * i + v3 )\n  {\n    v3 = *v1++;\n    if ( !v3 )\n      break;\n  }\n  v4 = (const char ***)(v0 + 4 * i);\n  for ( j = *v4; j; j = (const char **)*j )\n  {\n    if ( !strcmp(j[2], v7) )\n      return j;\n  }\n  j = (const char **)sub_804DB2E(0x20u);\n  j[2] = sub_804DB46(v7);\n  *j = (const char *)*v4;\n  *v4 = j;\n  return j;\n}\n"
    ],
    "sub_805933E": [
        "0x805933e",
        "_DWORD *__usercall sub_805933E@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n  _DWORD *v3; // ebx\n  int v4; // esi\n\n  result = sub_805932D();\n  v3 = result;\n  if ( (dword_80DBB9C & 0x60) != 0 || (result[5] & 0x11) == 0 )\n  {\n    result[6] = a1;\n    result[5] |= 2u;\n    v4 = dword_80DBB80;\n    sub_80AFADF();\n    ++*(_DWORD *)(v4 + 8);\n    result = sub_804D210((_BYTE *)v3[2], \"symbol:\");\n    if ( result )\n      *(_BYTE *)(v4 + 12) = 1;\n  }\n  return result;\n}\n"
    ],
    "sub_8059389": [
        "0x8059389",
        "int __userpurge sub_8059389@<eax>(const char *a1@<eax>, int a2)\n{\n  char *v2; // eax\n  int v3; // ecx\n  int v4; // ebx\n  char *v5; // eax\n  int v6; // ebx\n  _DWORD *i; // esi\n  int v8; // ebp\n  int v9; // ecx\n  int v10; // eax\n  const char **v11; // eax\n  unsigned int v12; // edx\n  const char **v13; // ebx\n  int v15; // [esp+0h] [ebp-124h]\n  char *v16; // [esp+8h] [ebp-11Ch]\n  const char *v17; // [esp+10h] [ebp-114h]\n  char v18[4]; // [esp+14h] [ebp-110h] BYREF\n\n  v2 = sub_804D315(a1);\n  if ( *v2 == 46 )\n    return 1;\n  v4 = 2;\n  if ( a2 <= 1 )\n  {\n    if ( !a2 || (v5 = strrchr(v2, 46), v4 = 1, v5) && !strcmp(v5 + 1, \"conf\") )\n    {\n      v4 = 0;\n      if ( sub_80B0511(v3, sub_80B3D37) )\n      {\n        while ( sub_80B0560(\"# \\t\") )\n        {\n          if ( !strcmp(v16, \"alias\") )\n          {\n            if ( v17 )\n            {\n              sub_8059AC2(v15, v18);\n              v6 = dword_80DBB80;\n              for ( i = *(_DWORD **)dword_80DBB80; i; i = (_DWORD *)*i )\n              {\n                v8 = i[1];\n                if ( !fnmatch(v18, *(const char **)(v8 + 8), 0) )\n                {\n                  sub_8059AC2(v9, 0);\n                  sub_80AFAC3();\n                  v10 = *(_DWORD *)(v8 + 20);\n                  if ( (v10 & 2) != 0 )\n                  {\n                    *(_DWORD *)(v8 + 20) = v10 & 0xFFFFFFFD;\n                    --*(_DWORD *)(v6 + 8);\n                  }\n                  v11 = sub_805932D();\n                  v12 = (unsigned int)v11[5];\n                  if ( (v12 & 2) == 0 )\n                  {\n                    v11[5] = (const char *)(v12 | 2);\n                    ++*(_DWORD *)(v6 + 8);\n                  }\n                }\n              }\n            }\n          }\n          else if ( !strcmp(v16, \"options\") )\n          {\n            if ( v17 )\n            {\n              v13 = sub_805932D();\n              v13[7] = sub_8059202(v13[7], v17);\n            }\n          }\n          else if ( !strcmp(v16, \"include\") )\n          {\n            sub_80591EC();\n          }\n        }\n        sub_80B0536();\n        return 1;\n      }\n    }\n  }\n  return v4;\n}\n"
    ],
    "sub_8059532": [
        "0x8059532",
        "int __usercall sub_8059532@<eax>(const char **a1@<eax>)\n{\n  const char *v2; // ecx\n  int v3; // ebp\n  const char *v4; // eax\n  char *v5; // edx\n  const char **v6; // eax\n  const char **v7; // ebx\n  const char *v8; // eax\n  char *v9; // esi\n  unsigned __int8 *v10; // ebp\n  unsigned __int8 *v11; // ecx\n  unsigned __int8 *i; // eax\n  unsigned __int8 v13; // dl\n  const char *v14; // edx\n  const char *v15; // eax\n  const char *v16; // edx\n  _BYTE *v17; // eax\n  unsigned __int8 *v19; // [esp-4h] [ebp-28h]\n  const char *v20; // [esp+0h] [ebp-24h]\n  int v21; // [esp+4h] [ebp-20h]\n  unsigned __int8 *v22; // [esp+8h] [ebp-1Ch]\n  unsigned __int8 *v23; // [esp+8h] [ebp-1Ch]\n  char *v24; // [esp+Ch] [ebp-18h]\n  const char *v25; // [esp+10h] [ebp-14h]\n\n  v2 = a1[5];\n  if ( ((unsigned __int8)v2 & 4) == 0 )\n  {\n    v3 = -2;\n    if ( (dword_80DBB9C & 2) == 0 )\n    {\n      v4 = a1[6];\n      if ( !v4 )\n        v4 = a1[2];\n      v5 = (char *)&unk_80CB88C;\n      if ( ((unsigned __int8)v2 & 0x10) != 0 )\n        v5 = \"module %s is builtin\";\n      sub_804D5F4(v5, v4);\n      return -2;\n    }\n    return v3;\n  }\n  if ( (dword_80DBB9C & 0x20) == 0 )\n    a1[3] = (const char *)sub_80AFB57();\n  v21 = 1;\nLABEL_11:\n  while ( 2 )\n  {\n    while ( 2 )\n    {\n      v3 = 0;\n      while ( 1 )\n      {\nLABEL_12:\n        if ( !a1[3] )\n          return v3;\n        v20 = (const char *)sub_80AFB01();\n        sub_804D32D(v20);\n        v6 = sub_805932D();\n        v7 = v6;\n        if ( (dword_80DBB9C & 0x20) == 0 )\n          break;\n        if ( ((_BYTE)v6[5] & 1) == 0 )\n        {\n          v21 = 0;\n          goto LABEL_11;\n        }\n        v3 = sub_8059CDC();\n        if ( v3 )\n        {\n          if ( v21 )\n          {\n            v8 = v7[6];\n            if ( !v8 )\n              v8 = v7[2];\n            sub_804D3A5((int)\"can't unload module '%s'\", v8);\n            return v3;\n          }\n        }\n        else\n        {\n          v7[5] = (const char *)((unsigned int)v7[5] & 0xFFFFFFFE);\n          v21 = 0;\n        }\n      }\n      v9 = (char *)v6[7];\n      v6[7] = 0;\n      v24 = (char *)v6[2];\n      v10 = (unsigned __int8 *)sub_80B24C7();\n      v11 = v10;\n      if ( !v10 )\n        goto LABEL_35;\n      while ( 2 )\n      {\n        for ( i = v11; ; ++i )\n        {\n          v13 = *i;\n          if ( *i > 0xAu )\n            break;\n          if ( v13 >= 9u || !v13 )\n            goto LABEL_31;\nLABEL_33:\n          ;\n        }\n        if ( v13 == 32 )\n          goto LABEL_31;\n        if ( v13 != 34 )\n          goto LABEL_33;\n        v22 = v11;\n        i = (unsigned __int8 *)strchrnul();\n        v11 = v22;\n        if ( *i )\n          ++i;\nLABEL_31:\n        v23 = 0;\n        if ( *i )\n        {\n          *i = 0;\n          v23 = i + 1;\n        }\n        v17 = sub_804D210(v11, v24);\n        if ( v17 )\n        {\n          if ( *v17 == 46 )\n          {\n            v25 = v17 + 1;\n            if ( strchr(v17 + 1, 61) )\n              v9 = sub_8059202(v9, v25);\n          }\n        }\n        if ( v23 )\n        {\n          v11 = v23;\n          continue;\n        }\n        break;\n      }\n      free(v10);\n      v11 = v19;\nLABEL_35:\n      if ( a1 == v7 )\n        v9 = sub_8059202(v9, *(const char **)(dword_80DBB80 + 4));\n      if ( (dword_80DBB9C & 0x40) != 0 )\n      {\n        v14 = \"insmod %s/%s/%s\\n\";\n        if ( v9 )\n          v14 = \"insmod %s/%s/%s %s\\n\";\n        printf(v14, \"/lib/modules\", dword_80DBB80 + 143, v20, v9);\n        free(v9);\n        continue;\n      }\n      break;\n    }\n    if ( ((_BYTE)v7[5] & 1) != 0 )\n    {\n      free(v9);\n      continue;\n    }\n    break;\n  }\n  v3 = sub_8059C33(v11, v9);\n  if ( v3 == 17 )\n    v3 = 0;\n  free(v9);\n  if ( !v3 )\n  {\n    v7[5] = (const char *)((unsigned int)v7[5] | 1);\n    goto LABEL_12;\n  }\n  v15 = (const char *)sub_8059CFC();\n  v16 = v7[6];\n  if ( !v16 )\n    v16 = v7[2];\n  sub_804D5F4(\"can't load module %s (%s): %s\", v16, v20, v15);\n  return v3;\n}\n"
    ],
    "sub_80597AE": [
        "0x80597ae",
        "int __cdecl sub_80597AE(int a1, int a2)\n{\n  char *v2; // ebx\n  char v3; // bp\n  int *v4; // edi\n  int v5; // ecx\n  int *v6; // ebx\n  const char *v7; // eax\n  int result; // eax\n  int v9; // ecx\n  const char **i; // ebx\n  const char **v11; // eax\n  int v12; // ecx\n  int v13; // esi\n  const char **v14; // eax\n  int v15; // ecx\n  int v16; // ecx\n  int v17; // ecx\n  int v18; // eax\n  int v19; // edi\n  const char **v20; // eax\n  const char *v21; // edx\n  void *v22; // [esp+8h] [ebp-11Ch]\n  char *v23; // [esp+Ch] [ebp-118h]\n  char s[8]; // [esp+14h] [ebp-110h] BYREF\n\n  v2 = (char *)sub_804DB2E(0x594u);\n  dword_80DBB80 = (int)v2;\n  v3 = sub_80ABEC2(a2, \"^vqsalrDb\", \"show-depends\");\n  v4 = (int *)(a2 + 4 * optind);\n  sub_804DF04(\"/lib/modules\");\n  uname((struct utsname *)(v2 + 13));\n  sub_804DF04(v2 + 143);\n  if ( (v3 & 0x10) != 0 )\n  {\n    sub_80B0511(v5, sub_80B3D45);\n    v6 = v4;\n    while ( *v6++ )\n      sub_8059A67(95, 45);\n    while ( 1 )\n    {\n      result = sub_80B0560(\"# \\t\");\n      if ( !result )\n        break;\n      v7 = sub_804D378(v23, 58);\n      if ( v7 )\n      {\n        *v7 = 0;\n        if ( *v4 )\n        {\n          sub_804D32D(v23);\n          sub_8059AC2(v9, s);\n          for ( i = (const char **)v4; *i; ++i )\n          {\n            if ( !fnmatch(*i, s, 0) )\n              puts(v23);\n          }\n        }\n        else\n        {\n          puts(v23);\n        }\n      }\n    }\n    return result;\n  }\n  if ( (v3 & 4) != 0 )\n    byte_80DB561 = 2;\n  if ( !*v4 )\n  {\n    if ( (v3 & 0x20) != 0 && sub_8059CDC() )\n      sub_80B0A23();\n    return 0;\n  }\n  sub_80B0511(v5, sub_80B3D37);\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    v11 = sub_805932D();\n    v11[5] = (const char *)((unsigned int)v11[5] | 1);\n  }\n  sub_80B0536();\n  sub_80B0511(v12, sub_80B3D37);\n  while ( 1 )\n  {\n    v13 = sub_80B0560(\"# \\t\");\n    if ( !v13 )\n      break;\n    v14 = sub_805932D();\n    v14[5] = (const char *)((unsigned int)v14[5] | 0x10);\n  }\n  sub_80B0536();\n  if ( (v3 & 0x28) != 0 )\n  {\n    do\n      sub_805933E(*v4++);\n    while ( *v4 );\n  }\n  else\n  {\n    sub_805933E(*v4);\n    *((_DWORD *)v2 + 1) = sub_8059B9B(v15, 1);\n  }\n  if ( !*(_DWORD *)v2 )\n    return 0;\n  sub_80591EC();\n  sub_80591EC();\n  if ( v2[12] )\n    sub_80591EC();\n  sub_8059250(v16);\n  if ( *((_DWORD *)v2 + 2) )\n  {\n    sub_80591EC();\n    sub_8059250(v17);\n  }\n  while ( 1 )\n  {\n    v18 = sub_80AFB01();\n    v19 = v18;\n    if ( !v18 )\n      break;\n    if ( *(_DWORD *)(v18 + 16) )\n    {\n      do\n      {\n        v22 = (void *)sub_80AFB01();\n        v20 = sub_805932D();\n        v21 = v20[5];\n        if ( ((unsigned __int8)v21 & 8) == 0 && (((unsigned __int8)v21 & 1) == 0 || (v3 & 0x60) != 0) )\n          v13 |= sub_8059532(v20);\n        free(v22);\n      }\n      while ( *(_DWORD *)(v19 + 16) );\n    }\n    else\n    {\n      v13 |= sub_8059532((const char **)v18);\n    }\n  }\n  return v13 != 0;\n}\n"
    ],
    "sub_8059A67": [
        "0x8059a67",
        "_BYTE *__usercall sub_8059A67@<eax>(_BYTE *result@<eax>, char a2@<dl>, char a3@<cl>)\n{\n  while ( *result )\n  {\n    if ( *result == a2 )\n      *result = a3;\n    ++result;\n  }\n  return result;\n}\n"
    ],
    "sub_8059A79": [
        "0x8059a79",
        "int __usercall sub_8059A79@<eax>(char *delim@<ecx>, char *a2@<eax>)\n{\n  int v3; // esi\n  char *v4; // ebx\n  char *v6; // [esp+0h] [ebp-14h] BYREF\n\n  v6 = a2;\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = strsep(&v6, delim);\n    if ( !v4 )\n      break;\n    if ( *v4 )\n    {\n      sub_804DB46(v4);\n      sub_80AFADF();\n      v3 += strlen(v4);\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_8059AC2": [
        "0x8059ac2",
        "char *__usercall sub_8059AC2@<eax>(int a1@<eax>, char *a2@<edx>)\n{\n  char *result; // eax\n  int i; // edx\n  char v5; // cl\n  _BYTE v6[260]; // [esp+0h] [ebp-104h] BYREF\n\n  result = 0;\n  if ( a1 )\n  {\n    result = a2;\n    if ( !a2 )\n      result = v6;\n    for ( i = 0; i != 255; ++i )\n    {\n      v5 = *(_BYTE *)(a1 + i);\n      if ( v5 == 46 || !v5 )\n        break;\n      if ( v5 == 45 )\n        v5 = 95;\n      result[i] = v5;\n    }\n    result[i] = 0;\n    if ( result == v6 )\n      return sub_804DB46(result);\n  }\n  return result;\n}\n"
    ],
    "sub_8059B8A": [
        "0x8059b8a",
        "int **__usercall sub_8059B8A@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  char *v3; // ecx\n  unsigned __int8 i; // al\n  char v5; // dl\n  int **j; // ebx\n  char v8[268]; // [esp-10Ch] [ebp-10Ch] BYREF\n\n  sub_8059AC2(a2, v8);\n  v3 = v8;\n  for ( i = 0; ; i += 32 * i + v5 )\n  {\n    v5 = *v3++;\n    if ( !v5 )\n      break;\n  }\n  for ( j = *(int ***)(a1 + 4 * i); j && strcmp((const char *)j[2], v8); j = (int **)*j )\n    ;\n  return j;\n}\n"
    ],
    "sub_8059B9B": [
        "0x8059b9b",
        "char *__usercall sub_8059B9B@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  char *v3; // esi\n  int i; // edi\n  const char *v5; // ebx\n  size_t v6; // eax\n  int v7; // eax\n  int v8; // edx\n  const char *v9; // ecx\n  char *v10; // eax\n  int v13; // [esp+4h] [ebp-18h]\n\n  v3 = (char *)sub_804DB2E(1u);\n  for ( i = 0; ; i += sprintf(&v3[i], v9, v8 - (_DWORD)v5, v5, v8) )\n  {\n    v5 = *++a1;\n    if ( !*a1 )\n      break;\n    v6 = strlen(*a1);\n    v3 = (char *)sub_804DB13(v3, v6 + i + 4);\n    v7 = strchrnul();\n    v8 = v7;\n    v9 = \"%.*s%s \";\n    if ( a2 && *(_BYTE *)v7 )\n    {\n      v13 = v7 + 1;\n      v10 = strchr((const char *)(v7 + 1), 32);\n      v8 = v13;\n      v9 = \"%.*s%s \";\n      if ( v10 )\n        v9 = \"%.*s\\\"%s\\\" \";\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_8059C33": [
        "0x8059c33",
        "int __fastcall sub_8059C33(int a1, const char *a2)\n{\n  const char *v2; // esi\n  int v3; // ebp\n  int *v4; // ebx\n  int v5; // eax\n  void *v6; // edi\n  int v7; // ebx\n  int v9; // [esp+0h] [ebp-18h]\n\n  v2 = &data;\n  if ( a2 )\n    v2 = a2;\n  v3 = open64();\n  if ( v3 < 0 || (v9 = syscall(350, v3, v2, 0), v7 = v9 != 0, close(v3), v9) )\n  {\n    v4 = (int *)dword_80DBB7C;\n    *(_DWORD *)dword_80DBB7C = 12;\n    v5 = sub_80B24C7();\n    v6 = (void *)v5;\n    if ( v5 )\n    {\n      *v4 = 0;\n      syscall(128, v5, 2147479552, v2);\n      v7 = *v4;\n      free(v6);\n    }\n    else\n    {\n      return -*v4;\n    }\n  }\n  return v7;\n}\n"
    ],
    "sub_8059CDC": [
        "0x8059cdc",
        "int __usercall sub_8059CDC@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n\n  v2 = dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  syscall(129, a1, a2);\n  return *(_DWORD *)v2;\n}\n"
    ],
    "sub_8059CFC": [
        "0x8059cfc",
        "char *__usercall sub_8059CFC@<eax>(int a1@<eax>)\n{\n  char *result; // eax\n  bool v3; // zf\n\n  if ( a1 == 3 )\n    return \"module has wrong symbol version\";\n  if ( a1 > 3 )\n  {\n    result = \"invalid module format\";\n    if ( a1 == 8 )\n      return result;\n    result = \"kernel does not support requested operation\";\n    v3 = a1 == 38;\n  }\n  else\n  {\n    result = \"no such module\";\n    if ( a1 == -1 )\n      return result;\n    result = \"unknown symbol in module, or unknown parameter\";\n    v3 = a1 == 2;\n  }\n  if ( !v3 )\n    return strerror(abs32(a1));\n  return result;\n}\n"
    ],
    "sub_8059D46": [
        "0x8059d46",
        "int __cdecl sub_8059D46(int a1, int a2)\n{\n  char v2; // al\n  const char **v3; // esi\n  int v4; // ebx\n  int v5; // eax\n  const char *v6; // eax\n  char *v7; // eax\n  char v9[264]; // [esp+0h] [ebp-108h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"wfas\");\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = (v2 & 1) == 0 ? 2176 : 128;\n  if ( (v2 & 2) != 0 )\n    BYTE1(v4) |= 2u;\n  if ( (v2 & 4) != 0 )\n  {\n    v5 = sub_8059CDC(0, v4);\n    if ( v5 && v5 != 14 )\n      sub_804D3C9((int)\"rmmod\");\n  }\n  else\n  {\n    if ( !*v3 )\n      sub_804CDC2();\n    while ( 1 )\n    {\n      v6 = *v3;\n      if ( !*v3 )\n        break;\n      ++v3;\n      v7 = sub_804D315(v6);\n      sub_8059AC2((int)v7, v9);\n      if ( sub_8059CDC((int)v9, v4) )\n        sub_804D3C9((int)\"can't unload module '%s'\", v9);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8059DE7": [
        "0x8059de7",
        "int __usercall sub_8059DE7@<eax>(const char *a1@<eax>)\n{\n  const char *v2; // eax\n  char *v3; // esi\n  int v4; // edx\n  int v5; // ecx\n  int v6; // eax\n  int v7; // eax\n  char *v8; // edi\n  int v9; // edx\n  int v10; // eax\n  int v11; // ebx\n  int v12; // edx\n  int v14; // [esp-8h] [ebp-2BCh]\n  int v15; // [esp-8h] [ebp-2BCh]\n  int v16; // [esp-4h] [ebp-2B8h]\n  int v17; // [esp-4h] [ebp-2B8h]\n  int v18; // [esp-4h] [ebp-2B8h]\n  int i; // [esp+0h] [ebp-2B4h]\n  int v20; // [esp+4h] [ebp-2B0h]\n  char *s; // [esp+8h] [ebp-2ACh]\n  int v22; // [esp+Ch] [ebp-2A8h] BYREF\n  int v23; // [esp+10h] [ebp-2A4h] BYREF\n  char v24[16]; // [esp+14h] [ebp-2A0h] BYREF\n  char s1[128]; // [esp+24h] [ebp-290h] BYREF\n  char v26[128]; // [esp+A4h] [ebp-210h] BYREF\n  __int16 v27[64]; // [esp+124h] [ebp-190h] BYREF\n  char v28[128]; // [esp+1A4h] [ebp-110h] BYREF\n  char v29[144]; // [esp+224h] [ebp-90h] BYREF\n\n  if ( a1 )\n  {\n    if ( (*(int (__fastcall **)(int, char *))(qword_80DB778 + 24))(qword_80DB778, v24) < 0 )\n      sub_80AD05E(\"%s\", a1);\n    v2 = (const char *)(*(int (__fastcall **)(int, int))(qword_80DB778 + 20))(qword_80DB778, 1);\n    v3 = sub_804DB46(v2);\n  }\n  else\n  {\n    v3 = 0;\n  }\n  sub_80B3D45();\n  fgets_unlocked();\n  v20 = 0;\n  for ( i = 0; fgets_unlocked(); ++i )\n  {\n    v27[0] = 45;\n    strcpy(v29, \"-\");\n    if ( sscanf(v28, \"%s 0x%x 0x%x %s %s %s\\n\", s1, &v22, &v23, v26, v27, v29) <= 3 )\n      break;\n    if ( *((_BYTE *)&unk_80DB780 + 4) )\n    {\n      v5 = v22;\n      if ( *(_DWORD *)(MEMORY[0x80DB77C] + 8) != v22 )\n        continue;\n    }\n    if ( v3 )\n    {\n      v6 = strcmp(s1, v3);\n      v5 = v14;\n      v4 = v16;\n      if ( v6 )\n        continue;\n    }\n    if ( *(_BYTE *)unk_80DB780 )\n    {\n      v7 = strcmp(v29, (const char *)unk_80DB780);\n      v4 = v17;\n      if ( v7 )\n        continue;\n    }\n    ++v20;\n    if ( (dword_80DBB9C & 0x80u) != 0 )\n      goto LABEL_21;\n    v8 = s1;\n    if ( (*(int (__fastcall **)(int, char *))(qword_80DB778 + 24))(qword_80DB778, v24) >= 0 )\n    {\n      v9 = dword_80DBB9C & 0x80;\n      BYTE1(v9) = 0x80;\n      v8 = (char *)(*(int (__fastcall **)(int, int))(qword_80DB778 + 20))(qword_80DB778, v9);\n    }\n    v10 = strcmp(v8, s1);\n    v4 = v15;\n    v5 = v18;\n    if ( !v10 )\nLABEL_21:\n      v8 = (_BYTE *)(\"~`!$^&*()=|\\\\{}[];\\\"'<>?\" + 21);\n    v11 = v23;\n    v12 = sub_805E7D4(v5, v4);\n    if ( !v12 )\n      v12 = sub_805E7AB();\n    s = (char *)v12;\n    printf(\"%s (%s) at \", v8, s1);\n    if ( (v11 & 2) != 0 )\n    {\n      printf(\"%s [%s] \", v26, *(const char **)s);\n    }\n    else if ( (v11 & 8) != 0 )\n    {\n      printf(\"* \");\n    }\n    else\n    {\n      printf(\"<incomplete> \");\n    }\n    if ( (v11 & 0x20) != 0 )\n      printf(\"netmask %s \", (const char *)v27);\n    sub_80B0AB7(v11, \"PERM\", 135056574);\n    printf(\" on %s\\n\", v29);\n  }\n  if ( !v20 && (*((_BYTE *)&unk_80DB780 + 4) || v3 || *(_BYTE *)unk_80DB780) )\n    printf(\"No match found in %u entries\\n\", i);\n  return 0;\n}\n"
    ],
    "sub_805A06B": [
        "0x805a06b",
        "int __cdecl sub_805A06B(int a1, int a2)\n{\n  int v2; // eax\n  __int16 v3; // di\n  const char **v4; // ebx\n  const char *v5; // ebp\n  const char *v6; // esi\n  const char **v7; // ebx\n  int v8; // ebp\n  const char *v9; // edi\n  const char **v10; // ebx\n  int v11; // eax\n  int v13; // [esp-8h] [ebp-D0h]\n  const char *v14; // [esp-4h] [ebp-CCh]\n  int v15; // [esp+0h] [ebp-C8h]\n  char *s1; // [esp+4h] [ebp-C4h]\n  int v17; // [esp+8h] [ebp-C0h] BYREF\n  int v18; // [esp+Ch] [ebp-BCh] BYREF\n  char v19[16]; // [esp+10h] [ebp-B8h] BYREF\n  char v20[16]; // [esp+20h] [ebp-A8h] BYREF\n  _DWORD v21[17]; // [esp+30h] [ebp-98h] BYREF\n  int v22[21]; // [esp+74h] [ebp-54h] BYREF\n\n  unk_80DB780 = (time_t)&data;\n  v2 = sub_804DF99(0, 2, 2);\n  sub_804DC97(v2, 3);\n  qword_80DB778 = sub_805E782();\n  MEMORY[0x80DB77C] = sub_805E7AB();\n  v3 = sub_80ABEAC(a2, \"A:p:H:t:i:adnDsv\", &v18, &v18, &v17, &v17, &unk_80DB780);\n  v4 = (const char **)(a2 + 4 * optind);\n  if ( (v3 & 3) != 0 )\n  {\n    qword_80DB778 = sub_805E782();\n    if ( !qword_80DB778 )\n    {\n      v14 = \"address family\";\n      v13 = v18;\n      goto LABEL_7;\n    }\n  }\n  if ( (v3 & 0xC) != 0 )\n  {\n    MEMORY[0x80DB77C] = sub_805E7AB();\n    if ( !MEMORY[0x80DB77C] )\n    {\n      v14 = \"hardware type\";\n      v13 = v17;\nLABEL_7:\n      sub_804D5E0(\"%s: unknown %s\", v13, v14);\n    }\n    *((_BYTE *)&unk_80DB780 + 4) = 1;\n  }\n  if ( *(_DWORD *)(qword_80DB778 + 8) != 2 )\n    sub_804D5E0(\"%s: kernel only supports 'inet'\", *(const char **)qword_80DB778);\n  if ( *(int *)(MEMORY[0x80DB77C] + 12) <= 0 )\n    sub_804D5E0(\"%s: %s without ARP support\", *(_DWORD *)MEMORY[0x80DB77C], \"hardware type\");\n  v5 = *v4;\n  if ( (v3 & 0x240) != 0 )\n  {\n    if ( !v5 )\n      sub_804D5E0(\"need host name\");\n    if ( (v3 & 0x200) != 0 )\n    {\n      memset(v21, 0, sizeof(v21));\n      if ( (*(int (**)(void))(qword_80DB778 + 24))() >= 0 )\n      {\n        qmemcpy(v21, v19, 0x10u);\n        v6 = v4[1];\n        if ( !v6 )\n          sub_804D5E0(\"need hardware address\");\n        v7 = v4 + 2;\n        if ( (dword_80DBB9C & 0x100) != 0 )\n        {\n          sub_804D67E((char *)v22, v6);\n          sub_804E029(3, 0x8927u, (int)v22, \"can't get HW-Address for '%s'\", v6);\n          if ( *((_BYTE *)&unk_80DB780 + 4) && LOWORD(v22[4]) != *(_DWORD *)(MEMORY[0x80DB77C] + 8) )\n            sub_804D5E0(\"protocol type mismatch\");\n          qmemcpy(&v21[4], &v22[4], 0x10u);\n        }\n        else if ( (*(int (__fastcall **)(size_t, _DWORD *))(MEMORY[0x80DB77C] + 20))(MEMORY[0x80DB77C], &v21[4]) < 0 )\n        {\n          sub_804D5E0(\"invalid hardware address\");\n        }\n        v8 = 6;\nLABEL_30:\n        while ( *v7 )\n        {\n          switch ( sub_804D222(\"pub\", *v7) )\n          {\n            case 0:\n              v8 |= 8u;\n              goto LABEL_29;\n            case 1:\n              v8 &= ~8u;\n              goto LABEL_29;\n            case 2:\n              v8 &= ~4u;\n              goto LABEL_29;\n            case 3:\n              v8 |= 0x10u;\nLABEL_29:\n              ++v7;\n              goto LABEL_30;\n            case 4:\n              sub_804D5F4(\"feature ATF_DONTPUB is not supported\");\n              goto LABEL_37;\n            case 5:\n              sub_804D5F4(\"feature ATF_MAGIC is not supported\");\nLABEL_37:\n              ++v7;\n              goto LABEL_30;\n            case 6:\n              if ( !v7[1] )\n                goto LABEL_52;\n              unk_80DB780 = (time_t)v7[1];\n              break;\n            case 7:\n              v9 = v7[1];\n              if ( !v9 )\n                goto LABEL_52;\n              if ( strcmp(v9, \"255.255.255.255\") )\n              {\n                if ( (*(int (__fastcall **)(int, char *))(qword_80DB778 + 24))(qword_80DB778, v19) < 0 )\n                  sub_80AD05E(\"%s\", v9);\n                qmemcpy(&v21[9], v19, 0x10u);\n                v8 |= 0x20u;\n              }\n              break;\n            default:\n              goto LABEL_52;\n          }\n          v7 += 2;\n        }\n        v21[8] = v8;\n        sub_804D67E((char *)&v21[13], (const char *)unk_80DB780);\n        sub_804E0BE(3, 0x8955u, (int)v21, \"SIOCSARP\");\n        return 0;\n      }\nLABEL_54:\n      sub_80AD05E(\"%s\", v5);\n    }\n    memset32(v22, v3 & 0x200, 0x11u);\n    if ( (*(int (**)(void))(qword_80DB778 + 24))() < 0 )\n      goto LABEL_54;\n    qmemcpy(v22, v20, 0x10u);\n    if ( *((_BYTE *)&unk_80DB780 + 4) )\n      LOWORD(v22[4]) = *(_DWORD *)(MEMORY[0x80DB77C] + 8);\n    v22[8] = 4;\n    v10 = v4 + 1;\n    v15 = 0;\nLABEL_50:\n    while ( *v10 )\n    {\n      switch ( sub_804D222(\"pub\", *v10) )\n      {\n        case 0:\n          v15 |= 1u;\n          goto LABEL_62;\n        case 1:\n          v15 |= 2u;\n          goto LABEL_62;\n        case 2:\n          v22[8] &= ~4u;\n          goto LABEL_62;\n        case 3:\n          v22[8] |= 0x10u;\nLABEL_62:\n          ++v10;\n          goto LABEL_50;\n        case 4:\n          sub_804D5F4(\"feature ATF_DONTPUB is not supported\");\n          goto LABEL_67;\n        case 5:\n          sub_804D5F4(\"feature ATF_MAGIC is not supported\");\nLABEL_67:\n          ++v10;\n          goto LABEL_50;\n        case 6:\n          if ( !v10[1] )\n            goto LABEL_52;\n          unk_80DB780 = (time_t)v10[1];\n          break;\n        case 7:\n          s1 = (char *)v10[1];\n          if ( !s1 )\n            goto LABEL_52;\n          if ( strcmp(s1, \"255.255.255.255\") )\n          {\n            if ( (*(int (__fastcall **)(int, char *))(qword_80DB778 + 24))(qword_80DB778, v20) < 0 )\n              sub_80AD05E(\"%s\", s1);\n            qmemcpy(&v22[9], v20, 0x10u);\n            v22[8] |= 0x20u;\n            v5 = s1;\n          }\n          break;\n        default:\nLABEL_52:\n          sub_804CDC2();\n      }\n      v10 += 2;\n    }\n    if ( !v15 )\n      LOBYTE(v15) = 3;\n    sub_804D67E((char *)&v22[13], (const char *)unk_80DB780);\n    if ( (v15 & 2) != 0 )\n    {\n      v11 = ioctl(3, 0x8953u, v22);\n      if ( v11 < 0 )\n      {\n        if ( *(_DWORD *)dword_80DBB7C != 6 )\n          sub_804D3C9((int)\"SIOCDARP(priv)\");\n        if ( (v15 & 1) == 0 )\n          goto LABEL_86;\n        goto LABEL_78;\n      }\n    }\n    else\n    {\n      v11 = -1;\n    }\n    if ( !v11 || (v15 & 1) == 0 )\n      return 0;\nLABEL_78:\n    v22[8] |= 8u;\n    if ( ioctl(3, 0x8953u, v22) >= 0 )\n      return 0;\n    if ( *(_DWORD *)dword_80DBB7C != 6 )\n      sub_804D3C9((int)\"SIOCDARP(pub)\");\nLABEL_86:\n    printf(\"No ARP entry for %s\\n\", v5);\n    return -1;\n  }\n  return sub_8059DE7(*v4);\n}\n"
    ],
    "sub_805A539": [
        "0x805a539",
        "void __noreturn sub_805A539()\n{\n  int v0; // ebx\n  bool v1; // al\n\n  v0 = dword_80DBB80;\n  if ( (dword_80DBB9C & 8) == 0 )\n    printf(\n      \"Sent %u probe(s) (%u broadcast(s))\\nReceived %u response(s) (%u request(s), %u broadcast(s))\\n\",\n      *(_DWORD *)(dword_80DBB80 + 64),\n      *(_DWORD *)(dword_80DBB80 + 68),\n      *(_DWORD *)(dword_80DBB80 + 72),\n      *(_DWORD *)(dword_80DBB80 + 80),\n      *(_DWORD *)(dword_80DBB80 + 76));\n  if ( (dword_80DBB9C & 2) != 0 )\n  {\n    v1 = *(_DWORD *)(v0 + 72) != 0;\n  }\n  else\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n      exit(0);\n    v1 = *(_DWORD *)(v0 + 72) == 0;\n  }\n  exit(v1);\n}\n"
    ],
    "sub_805A58F": [
        "0x805a58f",
        "unsigned int sub_805A58F()\n{\n  int v0; // eax\n  int v1; // ebx\n  int v2; // edx\n  unsigned int v3; // ecx\n  int v4; // edx\n  __int16 v5; // dx\n  _DWORD *v6; // eax\n  int v8; // [esp+0h] [ebp-110h] BYREF\n  char v9; // [esp+4h] [ebp-10Ch]\n  char v10; // [esp+5h] [ebp-10Bh]\n  __int16 v11; // [esp+6h] [ebp-10Ah]\n\n  v0 = sub_804EBDE();\n  v1 = dword_80DBB80;\n  if ( !*(_DWORD *)(dword_80DBB80 + 60) )\n    *(_DWORD *)(dword_80DBB80 + 60) = v0;\n  v2 = *(_DWORD *)(v1 + 48);\n  if ( !v2 )\n    goto LABEL_6;\n  v3 = *(_DWORD *)(v1 + 56);\n  if ( v3 )\n  {\n    if ( v3 < v0 - *(_DWORD *)(v1 + 60) )\n      goto LABEL_6;\n  }\n  if ( v2 > 0 )\n    *(_DWORD *)(v1 + 48) = v2 - 1;\n  v4 = *(_DWORD *)(v1 + 52);\n  if ( !v4 || (unsigned int)(v0 - v4) > 0x7A120 )\n  {\n    v8 = 524544;\n    v9 = *(_BYTE *)(v1 + 19);\n    v10 = 4;\n    v5 = 512;\n    if ( (dword_80DBB9C & 4) == 0 )\n      v5 = 256;\n    v11 = v5;\n    *(_DWORD *)mempcpy() = *(_DWORD *)v1;\n    v6 = (_DWORD *)mempcpy();\n    *v6 = *(_DWORD *)(v1 + 4);\n    if ( (char *)(v6 + 1) - (char *)&v8 == sendto(\n                                             3,\n                                             &v8,\n                                             (char *)(v6 + 1) - (char *)&v8,\n                                             0,\n                                             (const struct sockaddr *)(v1 + 28),\n                                             0x14u) )\n    {\n      *(_DWORD *)(v1 + 52) = sub_804EBDE();\n      ++*(_DWORD *)(v1 + 64);\n      if ( (dword_80DBB9C & 0x40) == 0 )\n        ++*(_DWORD *)(v1 + 68);\n    }\n    if ( !*(_DWORD *)(v1 + 48) && (dword_80DBB9C & 1) != 0 )\nLABEL_6:\n      sub_805A539(v8);\n  }\n  return alarm(1u);\n}\n"
    ],
    "sub_805A6A7": [
        "0x805a6a7",
        "int __cdecl sub_805A6A7(int a1, int a2)\n{\n  char *v2; // ebx\n  int v3; // eax\n  char *v4; // edi\n  int v5; // eax\n  char v6; // al\n  int v7; // esi\n  unsigned __int8 v8; // al\n  char *v10; // eax\n  const char *v11; // esi\n  char *v12; // eax\n  ssize_t v13; // ebp\n  char *v14; // esi\n  __int16 v15; // ax\n  __int16 v16; // cx\n  size_t v17; // eax\n  _DWORD *v18; // edi\n  struct in_addr v19; // ebp\n  bool v20; // zf\n  char *v21; // eax\n  const char *v22; // ebp\n  const char *v23; // edx\n  int v24; // edx\n  char *v25; // eax\n  unsigned __int8 *v26; // ebp\n  int v27; // eax\n  int v28; // ecx\n  int v29; // eax\n  sigset_t *set; // [esp+0h] [ebp-50h]\n  struct in_addr in; // [esp+4h] [ebp-4Ch]\n  struct in_addr ina; // [esp+4h] [ebp-4Ch]\n  char v33; // [esp+8h] [ebp-48h]\n  int v34; // [esp+8h] [ebp-48h]\n  int v35; // [esp+Ch] [ebp-44h]\n  int v36; // [esp+10h] [ebp-40h]\n  int v37; // [esp+14h] [ebp-3Ch]\n  int v38; // [esp+18h] [ebp-38h]\n  int v39; // [esp+1Ch] [ebp-34h]\n  char v40[4]; // [esp+20h] [ebp-30h] BYREF\n  char *cp; // [esp+24h] [ebp-2Ch] BYREF\n  socklen_t addr_len; // [esp+28h] [ebp-28h] BYREF\n  struct sockaddr addr; // [esp+2Ch] [ebp-24h] BYREF\n\n  *(_DWORD *)v40 = \"eth0\";\n  cp = 0;\n  v2 = (char *)sub_804DB2E(0x108Cu);\n  dword_80DBB80 = (int)v2;\n  *((_DWORD *)v2 + 12) = -1;\n  v3 = sub_804DF99(0, 2, 17);\n  sub_804DC97(v3, 3);\n  if ( (sub_80ABEAC(a2, \"^UDAqfbc:+w:I:s:\", v2 + 48, &addr, v40, &cp) & 0x80u) != 0 )\n    *((_DWORD *)v2 + 14) = 1000000 * sub_80B40CC(1073, 0) + 500000;\n  v4 = sub_804DDBF(\"interface %s %%s\", *(const char **)v40);\n  byte_80DB560 = 2;\n  sub_804D67E(v2 + 84, *(const char **)v40);\n  sub_804E029(3, 0x8933u, (int)(v2 + 84), v4, \"not found\");\n  *((_DWORD *)v2 + 3) = *((_DWORD *)v2 + 25);\n  sub_804E0BE(3, 0x8913u, (int)(v2 + 84), \"SIOCGIFFLAGS\");\n  v5 = *((_DWORD *)v2 + 25);\n  if ( (v5 & 1) == 0 )\n    sub_804D5E0(v4, \"is down\");\n  if ( (v5 & 0x88) == 0 )\n  {\n    *((_DWORD *)v2 + 1) = *(_DWORD *)(sub_80B45A6(2, 0) + 8);\n    if ( cp && !inet_aton(cp, (struct in_addr *)v2) )\n      sub_804D5E0(\"invalid source address %s\", cp);\n    v6 = dword_80DBB9C;\n    if ( (dword_80DBB9C & 3) == 1 && !*(_DWORD *)v2 )\n      *(_DWORD *)v2 = *((_DWORD *)v2 + 1);\n    if ( (v6 & 2) == 0 || *(_DWORD *)v2 )\n    {\n      v7 = sub_804DF99(0, 2, 2);\n      sub_80B4280();\n      *((_WORD *)v2 + 58) = 2;\n      if ( *(_DWORD *)v2 )\n      {\n        *((_DWORD *)v2 + 30) = *(_DWORD *)v2;\n        sub_804DFB3(0x10u, (struct sockaddr *)(v2 + 116), v7);\n      }\n      else\n      {\n        *((_WORD *)v2 + 59) = 260;\n        *((_DWORD *)v2 + 30) = *((_DWORD *)v2 + 1);\n        if ( sub_80B4258() )\n          sub_804D3A5((int)\"setsockopt(%s)\", \"SO_DONTROUTE\");\n        sub_80B42C3(0x10u, (struct sockaddr *)(v2 + 116));\n        sub_80A998A(16, v2 + 116);\n        if ( *((_WORD *)v2 + 58) != 2 )\n          sub_804D5E0(\"no IP address configured\");\n        *(_DWORD *)v2 = *((_DWORD *)v2 + 30);\n      }\n      close(v7);\n    }\n    *((_DWORD *)v2 + 2) = 101187601;\n    sub_804DFB3(0x14u, (struct sockaddr *)(v2 + 8), 3);\n    sub_80A998A(20, v2 + 8);\n    v8 = v2[19];\n    if ( v8 )\n    {\n      qmemcpy(v2 + 28, v2 + 8, 0x14u);\n      memset(v2 + 40, 255, v8);\n      if ( (dword_80DBB9C & 8) == 0 )\n      {\n        v10 = inet_ntoa(*(struct in_addr *)(v2 + 4));\n        printf(\"ARPING %s\", v10);\n        v11 = *(const char **)v40;\n        v12 = inet_ntoa(*(struct in_addr *)v2);\n        printf(\" from %s %s\\n\", v12, v11);\n      }\n      set = (sigset_t *)(v2 + 132);\n      sigaddset((sigset_t *)(v2 + 132), 14);\n      sigaddset((sigset_t *)(v2 + 132), 2);\n      sub_804E782(2, (int)sub_805A539);\n      sub_804E782(14, (int)sub_805A58F);\n      sub_805A58F();\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            while ( 1 )\n            {\n              addr_len = 20;\n              sigprocmask(1, set, 0);\n              v13 = recvfrom(3, v2 + 140, 0x1000u, 0, &addr, &addr_len);\n              sigprocmask(0, set, 0);\n              if ( v13 >= 0 )\n                break;\n              sub_804D3A5((int)\"recvfrom\");\n            }\n            v14 = v2 + 148;\n            if ( addr.sa_data[8] <= 2u && ((*((_WORD *)v2 + 73) - 256) & 0xFEFF) == 0 )\n            {\n              v15 = *((_WORD *)v2 + 70);\n              HIBYTE(v16) = addr.sa_data[6];\n              LOBYTE(v16) = addr.sa_data[7];\n              if ( (v15 == v16 || *(_WORD *)&addr.sa_data[6] == 774 && v15 == 256)\n                && *((_WORD *)v2 + 71) == 8\n                && v2[145] == 4 )\n              {\n                v17 = (unsigned __int8)v2[144];\n                v18 = (_DWORD *)dword_80DBB80;\n                if ( (_BYTE)v17 == *(_BYTE *)(dword_80DBB80 + 19) && (int)(2 * (v17 + 4) + 8) <= v13 )\n                {\n                  v19.s_addr = *(_DWORD *)&v2[v17 + 148];\n                  in.s_addr = *(_DWORD *)&v14[2 * v17 + 4];\n                  if ( v19.s_addr == *(_DWORD *)(dword_80DBB80 + 4) )\n                    break;\n                }\n              }\n            }\n          }\n          v33 = dword_80DBB9C;\n          if ( (dword_80DBB9C & 2) != 0 )\n            break;\n          if ( in.s_addr == *(_DWORD *)dword_80DBB80 )\n          {\n            v20 = memcmp(&v14[v17 + 4], (const void *)(dword_80DBB80 + 20), v17) == 0;\nLABEL_45:\n            if ( v20 )\n            {\nLABEL_46:\n              if ( (v33 & 8) == 0 )\n              {\n                v39 = (unsigned __int8)v2[153];\n                v34 = (unsigned __int8)v2[152];\n                v35 = (unsigned __int8)v2[151];\n                v36 = (unsigned __int8)v2[150];\n                v37 = (unsigned __int8)v2[149];\n                v38 = (unsigned __int8)v2[148];\n                v21 = inet_ntoa(v19);\n                v22 = \"quest\";\n                if ( *((_WORD *)v2 + 73) == 512 )\n                  v22 = \"ply\";\n                v23 = \"Broad\";\n                if ( !addr.sa_data[8] )\n                  v23 = \"Uni\";\n                printf(\n                  \"%scast re%s from %s [%02x:%02x:%02x:%02x:%02x:%02x]\",\n                  v23,\n                  v22,\n                  v21,\n                  v38,\n                  v37,\n                  v36,\n                  v35,\n                  v34,\n                  v39);\n                v24 = 0;\n                if ( in.s_addr != *v18 )\n                {\n                  v25 = inet_ntoa(in);\n                  printf(\"for %s\", v25);\n                  v24 = 1;\n                }\n                ina.s_addr = v24;\n                v26 = (unsigned __int8 *)&v14[(unsigned __int8)v2[144] + 4];\n                if ( memcmp(v26, v18 + 5, (unsigned __int8)v2[144]) )\n                {\n                  if ( !ina.s_addr )\n                    printf(\" for\");\n                  printf(\" [%02x:%02x:%02x:%02x:%02x:%02x]\", *v26, v26[1], v26[2], v26[3], v26[4], v26[5]);\n                }\n                if ( v18[13] )\n                {\n                  v27 = sub_804EBDE();\n                  printf(\" %u.%03ums\\n\", (v27 - v18[13]) / 0x3E8u, (v27 - v18[13]) % 0x3E8u);\n                }\n                else\n                {\n                  puts(\" UNSOLICITED?\");\n                }\n                sub_804DD8F();\n              }\n              v28 = dword_80DBB80;\n              ++*(_DWORD *)(dword_80DBB80 + 72);\n              if ( addr.sa_data[8] )\n                ++*(_DWORD *)(v28 + 76);\n              if ( *((_WORD *)v2 + 73) == 256 )\n                ++*(_DWORD *)(v28 + 80);\n              v29 = dword_80DBB9C;\n              if ( (dword_80DBB9C & 0x10) != 0 )\n                sub_805A539(set);\n              if ( (dword_80DBB9C & 0x20) == 0 )\n              {\n                qmemcpy((void *)(v28 + 40), v14, *(unsigned __int8 *)(v28 + 19));\n                dword_80DBB9C = v29 | 0x40;\n              }\n            }\n          }\n        }\n        if ( memcmp(v2 + 148, (const void *)(dword_80DBB80 + 20), v17) )\n        {\n          if ( !*v18 )\n            goto LABEL_46;\n          v20 = in.s_addr == *v18;\n          goto LABEL_45;\n        }\n      }\n    }\n  }\n  sub_804D5F4(v4);\n  return ~(_BYTE)dword_80DBB9C & 2;\n}\n"
    ],
    "sub_805AC91": [
        "0x805ac91",
        "int __usercall sub_805AC91@<eax>(int result@<eax>)\n{\n  int i; // edx\n  int v2; // edx\n  char v3; // cl\n\n  for ( i = 0; *(_BYTE *)(result + i); ++i )\n    ;\n  v2 = result + i;\n  v3 = 0;\n  while ( v2 != result )\n  {\n    if ( *(_BYTE *)(v2 - 1) == 46 )\n    {\n      *(_BYTE *)(v2 - 1) = v3;\n      v3 = 0;\n    }\n    else\n    {\n      ++v3;\n    }\n    --v2;\n  }\n  return result;\n}\n"
    ],
    "sub_805ACB6": [
        "0x805acb6",
        "void __cdecl __noreturn sub_805ACB6(int a1, int a2)\n{\n  int v2; // ecx\n  char v3; // bl\n  unsigned __int16 v4; // si\n  _DWORD *v5; // edi\n  int *v6; // ebx\n  size_t v7; // eax\n  void *v8; // eax\n  unsigned int s_addr; // eax\n  unsigned __int32 v10; // eax\n  _WORD *v11; // ebp\n  char *v12; // ebx\n  ssize_t v13; // ebx\n  char v14; // bl\n  size_t v15; // edi\n  char *v16; // eax\n  __int16 v17; // si\n  int i; // ebx\n  int v19; // eax\n  const char *v20; // ebx\n  unsigned __int16 v21; // ax\n  __int16 v22; // bx\n  const char *v23; // eax\n  unsigned int v24; // edx\n  const char *v25; // edx\n  char *v26; // edi\n  __int16 v27; // ax\n  char v28; // t0\n  char *v29; // edi\n  int v30; // [esp+14h] [ebp-254h]\n  char *v31; // [esp+18h] [ebp-250h]\n  size_t v32; // [esp+1Ch] [ebp-24Ch]\n  unsigned int v33; // [esp+28h] [ebp-240h]\n  void *v34; // [esp+2Ch] [ebp-23Ch]\n  char *v35; // [esp+30h] [ebp-238h]\n  int v36; // [esp+34h] [ebp-234h]\n  struct sockaddr *addr; // [esp+38h] [ebp-230h]\n  char *v38; // [esp+3Ch] [ebp-22Ch] BYREF\n  void *v39; // [esp+40h] [ebp-228h] BYREF\n  const char *v40; // [esp+44h] [ebp-224h] BYREF\n  const char *v41; // [esp+48h] [ebp-220h] BYREF\n  int v42; // [esp+4Ch] [ebp-21Ch] BYREF\n  struct in_addr v43; // [esp+50h] [ebp-218h] BYREF\n  char *src; // [esp+54h] [ebp-214h] BYREF\n  char *v45; // [esp+58h] [ebp-210h]\n  int v46; // [esp+5Ch] [ebp-20Ch]\n  char v47[4]; // [esp+60h] [ebp-208h] BYREF\n  char v48; // [esp+258h] [ebp-10h] BYREF\n\n  v38 = \"0.0.0.0\";\n  v39 = &unk_80CBEAB;\n  v3 = sub_80ABEAC(a2, \"vsi:c:t:p:d\", &v38, &v39, &v40, &v41);\n  v33 = 120;\n  if ( (v3 & 0x10) != 0 )\n    v33 = sub_80B40CC(v40, 1u, 0xFFFFFFFF);\n  v4 = 53;\n  if ( (v3 & 0x20) != 0 )\n    v4 = sub_80B40CC(v41, 1u, 0xFFFFu);\n  if ( (v3 & 0x40) != 0 )\n  {\n    sub_80B3C0D(4);\n    openlog(ident, 1, 24);\n    byte_80DB561 = 2;\n  }\n  v42 = 0;\n  v5 = sub_80B052C(v2);\n  v6 = &v42;\n  while ( sub_80B0560((int)v5, &src, 4653570, \"# \\t\") )\n  {\n    if ( inet_aton(v45, &v43) )\n    {\n      if ( (dword_80DBB9C & 1) != 0 )\n        sub_804D5F4(\"name:%s, ip:%s\", src, v45);\n      v7 = strlen(src);\n      v8 = sub_804DB2E(v7 + 29);\n      *v6 = (int)v8;\n      v6 = (int *)v8;\n      *((_BYTE *)v8 + 25) = 46;\n      strcpy((char *)v8 + 26, src);\n      sub_805AC91((int)v6 + 25);\n      s_addr = v43.s_addr;\n      v6[1] = v43.s_addr;\n      v10 = _byteswap_ulong(s_addr);\n      sprintf((char *)v6 + 8, \".%u.%u.%u.%u\", (unsigned __int8)v10, BYTE1(v10), BYTE2(v10), HIBYTE(v10));\n      sub_805AC91((int)(v6 + 2));\n    }\n    else\n    {\n      sub_804D5F4(\"error at line %u, skipping\", v5[6]);\n    }\n  }\n  sub_80B0536((int)v5);\n  v36 = v42;\n  v11 = sub_80B45C8(v38, v4);\n  v30 = sub_804DF99(0, 2, (unsigned __int16)v11[2]);\n  sub_804DFB3(*(_DWORD *)v11, (struct sockaddr *)(v11 + 2), v30);\n  sub_80B31E3();\n  v32 = *(_DWORD *)v11 + 4;\n  v35 = (char *)sub_804DB2E(v32);\n  v34 = sub_804DB2E(v32);\n  v12 = sub_80B46AC((const struct sockaddr *)(v11 + 2));\n  sub_804D5F4(\"accepting UDP packets on %s\", v12);\n  free(v12);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          qmemcpy(v34, v11, v32);\n          v13 = sub_80B32E8(v30, (int)&src, 513, 0, v35 + 4, (int)v34 + 4, *(_DWORD *)v11);\n          if ( (unsigned int)(v13 - 12) <= 0x1F4 )\n            break;\n          sub_804D5F4(\"packet size %d, ignored\", v13);\n        }\n        if ( (dword_80DBB9C & 1) != 0 )\n          sub_804D5F4(\"got UDP packet\");\n        *((_BYTE *)&src + v13) = 0;\n        if ( (_WORD)v45 )\n          break;\n        sub_804D5F4(\"packet has 0 queries, ignored\");\n      }\n      v14 = BYTE2(src);\n      if ( SBYTE2(src) >= 0 )\n        break;\n      sub_804D5F4(\"response packet, ignored\");\n    }\n    v15 = strlen(v47);\n    v16 = &v47[v15 + 1];\n    addr = (struct sockaddr *)(v15 + 5);\n    v31 = &v47[v15 + 5];\n    if ( (v14 & 0x78) != 0 )\n    {\n      v22 = 1152;\n      v23 = \"opcode != 0\";\n      goto LABEL_46;\n    }\n    if ( *(_WORD *)&v47[v15 + 3] != 256 )\n    {\n      v22 = 1152;\n      v23 = \"class != 1\";\n      goto LABEL_46;\n    }\n    v17 = *(_WORD *)v16;\n    if ( *(_WORD *)v16 != 256 && v17 != 3072 )\n    {\n      v22 = 1152;\n      v23 = \"type is !REQ_A and !REQ_PTR\";\n      goto LABEL_46;\n    }\n    for ( i = v36; ; i = *(_DWORD *)i )\n    {\n      if ( !i )\n        goto LABEL_45;\n      v19 = *(unsigned __int8 *)(i + 25);\n      if ( v17 != 256 )\n        break;\n      if ( v19 == 1 && *(_BYTE *)(i + 26) == 42 || !strcasecmp((const char *)(i + 25), v47) )\n      {\n        v20 = (const char *)(i + 4);\n        goto LABEL_38;\n      }\nLABEL_39:\n      ;\n    }\n    if ( v19 == 1 && *(_BYTE *)(i + 26) == 42 || !sub_804D210(v47, (_BYTE *)(i + 8)) )\n      goto LABEL_39;\n    v20 = (const char *)(i + 25);\n    if ( v17 == 3072 )\n      v21 = strlen(v20) + 1;\n    else\nLABEL_38:\n      v21 = 4;\n    v24 = v21;\n    if ( v21 + v31 - &v48 + v15 + 527 <= 0x200 )\n    {\n      qmemcpy(v31, v47, (unsigned int)addr);\n      v26 = (char *)addr + (_DWORD)v31;\n      *(_DWORD *)v26 = _byteswap_ulong(v33);\n      v28 = HIBYTE(v21);\n      HIBYTE(v27) = v21;\n      LOBYTE(v27) = v28;\n      *((_WORD *)v26 + 2) = v27;\n      v29 = &addr->sa_data[(_DWORD)v31 + 4];\n      qmemcpy(v29, v20, v24);\n      v31 = &v29[v24];\n      if ( (dword_80DBB9C & 1) != 0 )\n        sub_804D5F4(\"returning positive reply\");\n      HIWORD(v45) = 256;\n      v22 = 132;\n      v23 = 0;\n    }\n    else\n    {\nLABEL_45:\n      v22 = 900;\n      v23 = \"name is not found\";\n    }\nLABEL_46:\n    if ( (v22 & 0x700) != 0 )\n    {\n      if ( (dword_80DBB9C & 1) != 0 )\n      {\n        v25 = \"sending error reply\";\n        if ( (dword_80DBB9C & 2) != 0 )\n          v25 = \"dropping query\";\n        sub_804D5F4(\"%s, %s\", v23, v25);\n      }\n      if ( (dword_80DBB9C & 2) != 0 )\n        continue;\n    }\n    HIWORD(src) |= v22;\n    v46 = 0;\n    LOWORD(v45) = 256;\n    if ( v31 - (char *)&src > 0 )\n      sub_80B3204(v31 - (char *)&src, &src, v30, 0, (struct sockaddr *)(v35 + 4), (int)v34 + 4, *(_DWORD *)v11);\n  }\n}\n"
    ],
    "sub_805B147": [
        "0x805b147",
        "int __cdecl sub_805B147(int a1, int a2)\n{\n  int v2; // ebp\n  char *v3; // ebx\n  int i; // edx\n  const char *v5; // ebx\n  int v6; // edx\n  int j; // eax\n  char *v8; // ecx\n  size_t v9; // esi\n  char fd; // [esp+0h] [ebp-F0h]\n  int fda; // [esp+0h] [ebp-F0h]\n  int v13; // [esp+4h] [ebp-ECh]\n  char v14[4]; // [esp+Ch] [ebp-E4h] BYREF\n  char *s; // [esp+10h] [ebp-E0h] BYREF\n  char v16[6]; // [esp+14h] [ebp-DCh] BYREF\n  struct ether_addr addr; // [esp+1Ah] [ebp-D6h] BYREF\n  _DWORD v18[5]; // [esp+20h] [ebp-D0h] BYREF\n  char v19[16]; // [esp+34h] [ebp-BCh] BYREF\n  __int64 v20; // [esp+44h] [ebp-ACh]\n  struct ether_addr buf; // [esp+54h] [ebp-9Ch] BYREF\n  struct ether_addr v22; // [esp+5Ah] [ebp-96h] BYREF\n  __int16 v23; // [esp+60h] [ebp-90h] BYREF\n  int v24; // [esp+62h] [ebp-8Eh] BYREF\n  __int16 v25; // [esp+66h] [ebp-8Ah]\n  char v26[96]; // [esp+68h] [ebp-88h] BYREF\n  char v27[40]; // [esp+C8h] [ebp-28h] BYREF\n\n  *(_DWORD *)v14 = \"eth0\";\n  fd = sub_80ABEAC(a2, \"^bi:p:\", v14, &s);\n  v2 = 0;\n  if ( (fd & 4) != 0 )\n  {\n    v3 = s;\n    v2 = sscanf(\n           s,\n           \"%2x:%2x:%2x:%2x:%2x:%2x\",\n           &buf,\n           &buf.ether_addr_octet[4],\n           &v22.ether_addr_octet[2],\n           &v23,\n           (char *)&v24 + 2,\n           v26);\n    if ( v2 > 3\n      || (v2 = sscanf(v3, \"%u.%u.%u.%u\", &buf, &buf.ether_addr_octet[4], &v22.ether_addr_octet[2], &v23), v2 > 3) )\n    {\n      for ( i = 0; i < v2; ++i )\n        v16[i] = *(_DWORD *)&buf.ether_addr_octet[4 * i];\n    }\n    else\n    {\n      sub_804D5F4(\"can't read Wake-On-LAN pass\");\n      v2 = 0;\n    }\n  }\n  v13 = fd & 1;\n  fda = sub_804DF99(0, 3, 17);\n  v5 = *(const char **)(a2 + 4 * optind);\n  if ( !ether_aton_r(v5, &addr) && ether_hostton(v5, &addr) )\n    sub_804CDC2();\n  *(_DWORD *)buf.ether_addr_octet = -1;\n  *(_WORD *)&buf.ether_addr_octet[4] = -1;\n  v6 = *(_DWORD *)addr.ether_addr_octet;\n  if ( !v13 )\n    buf = addr;\n  v22 = addr;\n  v23 = 16904;\n  v24 = -1;\n  v25 = -1;\n  for ( j = 0; j != 96; j += 6 )\n  {\n    v8 = &v26[j];\n    *(_DWORD *)v8 = v6;\n    *((_WORD *)v8 + 2) = *(_WORD *)&addr.ether_addr_octet[4];\n  }\n  sub_804D67E(v19, *(const char **)v14);\n  sub_804E029(fda, 0x8927u, (int)v19, \"SIOCGIFHWADDR on %s failed\", *(const char **)v14);\n  v22 = *(struct ether_addr *)((char *)&v20 + 2);\n  v9 = 116;\n  if ( v2 )\n  {\n    qmemcpy(v27, v16, v2);\n    v9 = v2 + 116;\n  }\n  if ( v13 && sub_80B426C() )\n    sub_804D3A5((int)\"SO_BROADCAST\");\n  sub_804D67E(v19, *(const char **)v14);\n  sub_804E0BE(fda, 0x8933u, (int)v19, \"SIOCGIFINDEX\");\n  memset((char *)v18 + 2, 0, 0x12u);\n  LOWORD(v18[0]) = 17;\n  v18[1] = v20;\n  HIBYTE(v18[2]) = 6;\n  *(struct ether_addr *)&v18[3] = buf;\n  sub_804DFCD(v9, &buf, fda, (struct sockaddr *)v18, 0x14u);\n  return 0;\n}\n"
    ],
    "sub_805B3A0": [
        "0x805b3a0",
        "const char *__usercall sub_805B3A0@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  size_t v4; // eax\n\n  if ( a2 )\n  {\n    sub_80B0511(a3, sub_80B3D45);\n    while ( sub_80B0560(\"# \\t\") )\n      sub_805B3A0();\n  }\n  else\n  {\n    v4 = strlen(a1);\n    if ( sethostname(a1, v4) )\n      sub_804D3C9((int)\"sethostname\");\n  }\n  return a1;\n}\n"
    ],
    "sub_805B3FE": [
        "0x805b3fe",
        "int __usercall sub_805B3FE@<eax>(int a1@<ebx>, int a2, int a3)\n{\n  char v3; // bl\n  const char **v4; // edi\n  int v5; // ecx\n  const char *v6; // esi\n  int v7; // esi\n  const char *v8; // edi\n  int v9; // eax\n  int i; // ebx\n  char *v11; // eax\n  const char *v12; // edx\n  int v13; // edx\n  const char *v14; // eax\n  const char *v16; // [esp+0h] [ebp-10h] BYREF\n\n  v16 = (const char *)a1;\n  v3 = sub_80ABEAC(a3, \"dfisF:v\", &v16, \"domain\");\n  v4 = (const char **)(a3 + 4 * optind);\n  v6 = (const char *)sub_80B2BD8();\n  if ( *ident == 100 )\n    v3 = 1;\n  if ( (v3 & 7) == 0 )\n  {\n    if ( (v3 & 8) != 0 )\n    {\n      *(_BYTE *)strchrnul() = 0;\nLABEL_25:\n      puts(v6);\n      return 0;\n    }\n    if ( (v3 & 0x10) != 0 )\n    {\n      v13 = 1;\n      v14 = v16;\n    }\n    else\n    {\n      v14 = *v4;\n      if ( !*v4 )\n        goto LABEL_25;\n      v13 = 0;\n    }\n    sub_805B3A0(v14, v13, v5);\n    return 0;\n  }\n  v7 = sub_80B4718();\n  v8 = *(const char **)v7;\n  v9 = strchrnul();\n  if ( (v3 & 2) != 0 )\n  {\n    puts(v8);\n  }\n  else if ( (v3 & 8) != 0 )\n  {\n    *(_BYTE *)v9 = 0;\n    puts(*(const char **)v7);\n  }\n  else if ( (v3 & 1) != 0 )\n  {\n    if ( *(_BYTE *)v9 )\n      puts((const char *)(v9 + 1));\n  }\n  else if ( *(_DWORD *)(v7 + 12) == 4 )\n  {\n    for ( i = *(_DWORD *)(v7 + 16); *(_DWORD *)i; i += 4 )\n    {\n      v11 = inet_ntoa((struct in_addr)(*(struct in_addr **)i)->s_addr);\n      v12 = \"%s \";\n      if ( !*(_DWORD *)(i + 4) )\n        v12 = \"\\r\\n%s\" + 2;\n      printf(v12, v11);\n    }\n    sub_804DD98(10);\n  }\n  return 0;\n}\n"
    ],
    "sub_805B501": [
        "0x805b501",
        "int __cdecl sub_805B501(int a1, int a2)\n{\n  int v2; // ecx\n  int v3; // ebx\n  int v4; // edx\n  const char *v6; // edi\n  char v7; // si\n  char v8; // al\n  char v9; // si\n  const char **v10; // ebp\n  const char *v11; // ebx\n  char *v12; // eax\n  int v13; // ecx\n  char *v14; // edi\n  int v15; // eax\n  int v16; // esi\n  char v17; // al\n  int v18; // ebx\n  int v19; // eax\n  int *v20; // esi\n  unsigned int v21; // edi\n  char *v22; // esi\n  __int16 v23; // dx\n  int *j; // eax\n  __int16 v25; // ax\n  int v26; // ebx\n  int v27; // [esp-4h] [ebp-80h]\n  char **i; // [esp+0h] [ebp-7Ch]\n  int v29; // [esp+4h] [ebp-78h]\n  int fd; // [esp+8h] [ebp-74h]\n  char v31; // [esp+Eh] [ebp-6Eh]\n  unsigned __int8 v32; // [esp+Fh] [ebp-6Dh]\n  int v33; // [esp+10h] [ebp-6Ch]\n  int v34; // [esp+14h] [ebp-68h] BYREF\n  int v35; // [esp+18h] [ebp-64h]\n  char v36; // [esp+24h] [ebp-58h] BYREF\n  int v37[6]; // [esp+34h] [ebp-48h] BYREF\n  char v38[16]; // [esp+4Ch] [ebp-30h] BYREF\n  int v39; // [esp+5Ch] [ebp-20h]\n\n  v3 = a2 + 4;\n  v4 = *(_DWORD *)(a2 + 4);\n  if ( v4 )\n  {\n    if ( *(_BYTE *)v4 == 45 && *(_BYTE *)(v4 + 1) == 97 && !*(_BYTE *)(v4 + 2) )\n    {\n      v3 = a2 + 8;\n      v4 = 1;\n    }\n    else\n    {\n      v4 = 0;\n    }\n  }\n  if ( !*(_DWORD *)v3 || !*(_DWORD *)(v3 + 4) )\n    return sub_805ED04(v2, v4);\n  fd = sub_804DF99(0, 2, 2);\n  sub_804D67E(v38, *(const char **)v3);\n  v32 = 0;\n  while ( 1 )\n  {\n    v29 = v3 + 4;\n    v6 = *(const char **)(v3 + 4);\n    if ( !v6 )\n      return 0;\n    v7 = 21;\n    if ( *v6 == 45 )\n    {\n      ++v6;\n      v7 = 42;\n    }\n    for ( i = &off_80B55A0; ; i += 2 )\n    {\n      if ( !*i )\n      {\n        v31 = *((_BYTE *)i + 5);\n        v10 = (const char **)&off_80B56D8;\n        goto LABEL_28;\n      }\n      if ( !strcmp(v6, *i) )\n        break;\n    }\n    v8 = (_BYTE)i[1] & v7;\n    v9 = v8;\n    if ( !v8 )\n      sub_804D5E0(\"bad: '%s'\", v6 - 1);\n    if ( (v8 & 0x30) == 0 )\n      goto LABEL_63;\n    v31 = *((_BYTE *)i + 5);\n    if ( ((unsigned __int8)v31 & v32) != 0 )\n      goto LABEL_23;\n    v10 = (const char **)((char *)&off_80B5660 + (char *)i - (char *)&off_80B55A0);\n    if ( !*(_DWORD *)(v3 + 8) )\n    {\n      if ( (v31 & 0x10) == 0 )\n      {\n        v31 &= 0x40u;\n        goto LABEL_61;\n      }\nLABEL_23:\n      sub_804CDC2();\n    }\n    v29 = v3 + 8;\nLABEL_28:\n    v32 |= v31 & 0x20;\n    v11 = *(const char **)v29;\n    if ( (v31 & 2) != 0 )\n    {\n      if ( (v31 & 1) != 0 )\n      {\n        if ( !strcmp(v11, \"inet\") )\n          goto LABEL_67;\n        v34 = 2;\n        if ( strcmp(v11, \"default\") )\n        {\n          v12 = strchr(v11, 47);\n          v13 = v27;\n          v14 = v12;\n          v33 = 0;\n          if ( v12 )\n          {\n            v33 = sub_80B40CC(128, 0);\n            *v14 = 0;\n          }\n          while ( 1 )\n          {\n            v15 = sub_80B45BD(v13, 0);\n            v16 = v15;\n            if ( *(_WORD *)(v15 + 4) == 10 )\n              break;\n            if ( !v14 )\n            {\n              v35 = *(_DWORD *)(v15 + 8);\n              goto LABEL_70;\n            }\n            *v14 = 47;\n          }\n          v26 = sub_804DF99(0, 2, 10);\n          sub_804E0BE(v26, 0x8933u, (int)v38, \"SIOCGIFINDEX\");\n          v37[5] = v39;\n          v37[4] = v33;\n          qmemcpy(v37, (const void *)(v16 + 12), 0x10u);\n          sub_804E029(v26, *((unsigned __int16 *)v10 + 2), (int)v37, \"SIOC%s\", *v10);\n          goto LABEL_67;\n        }\n        v35 = 0;\nLABEL_70:\n        v20 = &v34;\n      }\n      else\n      {\n        v17 = sub_804D254(\"ether\", *(const char **)v29) + 1;\n        if ( !v17 )\n          goto LABEL_23;\n        v18 = *(_DWORD *)(v29 + 4);\n        if ( !v18 )\n          goto LABEL_23;\n        if ( v17 == 1 )\n          v19 = sub_80AD44F();\n        else\n          v19 = sub_805E767();\n        if ( v19 )\n          sub_804D5E0(\"invalid hw-addr %s\", v18);\n        v29 += 4;\n        v20 = (int *)&v36;\n      }\n      qmemcpy(&v38[*((unsigned __int16 *)v10 + 3)], v20, 0x10u);\n    }\n    else\n    {\n      v21 = strtoul(v11, 0, 0);\n      v22 = &v38[*((unsigned __int16 *)v10 + 3)];\n      if ( (v31 & 0xC) == 0 )\n        goto LABEL_52;\n      sub_804E0BE(fd, 0x8970u, (int)v38, \"SIOCGIFMAP\");\n      if ( (v31 & 0xC) == 12 )\n      {\n        *v22 = v21;\n      }\n      else\n      {\n        if ( (v31 & 8) == 0 )\n        {\nLABEL_52:\n          *(_DWORD *)v22 = v21;\n          goto LABEL_53;\n        }\n        *(_WORD *)v22 = v21;\n      }\n    }\nLABEL_53:\n    sub_804E029(fd, *((unsigned __int16 *)v10 + 2), (int)v38, \"SIOC%s\", *v10);\n    if ( v31 >= 0 )\n      goto LABEL_61;\n    v23 = 0;\n    for ( j = (int *)v38; *(_BYTE *)j; j = (int *)((char *)j + 1) )\n    {\n      if ( *(_BYTE *)j == 58 )\n        ++v23;\n    }\n    if ( !v23 || *((_BYTE *)j - 1) != 45 )\n    {\nLABEL_61:\n      if ( (v31 & 0x40) == 0 )\n        goto LABEL_67;\n      v9 = 4;\nLABEL_63:\n      sub_804E0BE(fd, 0x8913u, (int)v38, \"SIOCGIFFLAGS\");\n      v25 = *((_WORD *)i + 3);\n      if ( (v9 & 0xC) != 0 )\n        LOWORD(v39) = v25 | v39;\n      else\n        LOWORD(v39) = ~v25 & v39;\n      sub_804E0BE(fd, 0x8914u, (int)v38, \"SIOCSIFFLAGS\");\n    }\nLABEL_67:\n    v3 = v29;\n  }\n}\n"
    ],
    "sub_805B8C8": [
        "0x805b8c8",
        "_BOOL4 __usercall sub_805B8C8@<eax>(int a1@<eax>, char *s)\n{\n  int v2; // eax\n  int v4; // [esp+0h] [ebp-4h] BYREF\n\n  v4 = a1;\n  if ( (dword_80DBB9C & 6) != 0 )\n    puts(s);\n  if ( (dword_80DBB9C & 2) != 0 )\n    return 1;\n  sub_804DD8F();\n  v2 = vfork();\n  if ( v2 < 0 )\n    return 0;\n  if ( !v2 )\n  {\n    execle((const char *)unk_80DB780, (const char *)unk_80DB780, \"-c\", s, 0, qword_80DB778);\n    _exit(127);\n  }\n  sub_804DA34(0, &v4, v2);\n  return (v4 & 0x7F) == 0 && !BYTE1(v4);\n}\n"
    ],
    "sub_805B93D": [
        "0x805b93d",
        "_BOOL4 __usercall sub_805B93D@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int i; // ebx\n  int v5; // ebp\n  _BOOL4 result; // eax\n  char *v7; // eax\n\n  for ( i = 0; *(_DWORD *)(a1 + 12) > i; ++i )\n  {\n    v5 = *(_DWORD *)(a1 + 16) + 8 * i;\n    if ( !strcmp(*(const char **)v5, a2) )\n    {\n      result = sub_805B8C8(0, *(char **)(v5 + 4));\n      if ( !result )\n        return result;\n    }\n  }\n  v7 = sub_804DDBF(\"run-parts /etc/network/if-%s.d\", a2);\n  return sub_805B8C8((int)v7, v7);\n}\n"
    ],
    "sub_805B98C": [
        "0x805b98c",
        "char *__usercall sub_805B98C@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char *v3; // ebx\n  char *v4; // edx\n  char *v5; // edi\n  char v6; // cl\n\n  v3 = sub_804DDBF(a1, a2, a3);\n  v4 = v3;\n  v5 = v3;\n  while ( 1 )\n  {\n    v6 = *v4;\n    if ( !*v4 || v6 == 61 )\n      break;\n    if ( v6 == 45 )\n      v6 = 95;\n    if ( (unsigned __int8)(v6 - 97) <= 0x19u )\n      v6 -= 32;\n    if ( (unsigned __int8)(v6 - 48) <= 9u || (unsigned __int8)((v6 | 0x20) - 97) <= 0x19u || v6 == 95 )\n      *v5++ = v6;\n    ++v4;\n  }\n  sub_80B2C69();\n  return v3;\n}\n"
    ],
    "sub_805B9ED": [
        "0x805b9ed",
        "char *__usercall sub_805B9ED@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  void **v4; // ebx\n  char **v5; // ebx\n  int i; // edi\n  char *result; // eax\n\n  v4 = (void **)qword_80DB778;\n  if ( qword_80DB778 )\n  {\n    while ( *v4 )\n      free(*v4++);\n    free((void *)qword_80DB778);\n  }\n  v5 = (char **)sub_804DB2E(4 * *(_DWORD *)(a1 + 12) + 28);\n  qword_80DB778 = (int)v5;\n  for ( i = 0; *(_DWORD *)(a1 + 12) > i; ++i )\n  {\n    if ( sub_804D222(\"up\", *(const char **)(*(_DWORD *)(a1 + 16) + 8 * i)) < 0 )\n      *v5++ = sub_805B98C(\n                \"IF_%s=%s\",\n                *(_DWORD *)(8 * i + *(_DWORD *)(a1 + 16)),\n                *(_DWORD *)(8 * i + *(_DWORD *)(a1 + 16) + 4));\n  }\n  *v5 = sub_805B98C(\"%s=%s\", (int)\"IFACE\", *(_DWORD *)(a1 + 8));\n  v5[1] = sub_805B98C(\"%s=%s\", (int)\"ADDRFAM\", **(_DWORD **)a1);\n  v5[2] = sub_805B98C(\"%s=%s\", (int)\"METHOD\", **(_DWORD **)(a1 + 4));\n  v5[3] = sub_805B98C(\"%s=%s\", 135038156, a2);\n  result = sub_805B98C(\"%s=%s\", (int)\"PHASE\", a3);\n  v5[4] = result;\n  if ( MEMORY[0x80DB77C] )\n  {\n    result = sub_805B98C(\"%s=%s\", (int)\"PATH\", MEMORY[0x80DB77C]);\n    v5[5] = result;\n  }\n  return result;\n}\n"
    ],
    "sub_805BB0B": [
        "0x805bb0b",
        "_BOOL4 __cdecl sub_805BB0B(int a1)\n{\n  int v1; // eax\n  int v2; // edx\n\n  v1 = (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 8))();\n  v2 = -1;\n  if ( v1 )\n  {\n    sub_805B9ED(a1, (int)\"stop\", (int)\"pre-down\");\n    if ( sub_805B93D(a1, \"down\") && (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 8))() )\n    {\n      sub_805B9ED(a1, (int)\"stop\", (int)\"post-down\");\n      return sub_805B93D(a1, \"post-down\");\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_805BB82": [
        "0x805bb82",
        "_BOOL4 __cdecl sub_805BB82(int a1)\n{\n  int v1; // eax\n  int v2; // edx\n\n  v1 = (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 4))();\n  v2 = -1;\n  if ( v1 )\n  {\n    sub_805B9ED(a1, (int)\"start\", (int)\"pre-up\");\n    if ( sub_805B93D(a1, \"pre-up\") && (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 4))() )\n    {\n      sub_805B9ED(a1, (int)\"start\", (int)\"post-up\");\n      return sub_805B93D(a1, \"up\");\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_805BBF9": [
        "0x805bbf9",
        "const char *__usercall sub_805BBF9@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  const char *v4; // eax\n  const char *v5; // ebx\n  const char *v6; // edx\n  int v8; // [esp-4h] [ebp-Ch]\n\n  v4 = (const char *)sub_80B2E8C(a3, a2);\n  v5 = 0;\n  if ( *v4 )\n  {\n    v5 = v4;\n    v6 = &v4[strcspn(v4, \" \\t\\n\")];\n    if ( *v6 )\n      *v6 = 0;\n    *a1 = sub_80B2E8C(v8, v6);\n  }\n  return v5;\n}\n"
    ],
    "sub_805BC34": [
        "0x805bc34",
        "int **__usercall sub_805BC34@<eax>(int **a1@<eax>, _BYTE *a2@<edx>)\n{\n  _BYTE *v4; // eax\n\n  while ( a1 )\n  {\n    v4 = sub_804D210(a1[1], a2);\n    if ( v4 )\n    {\n      if ( *v4 == 61 )\n        break;\n    }\n    a1 = (int **)*a1;\n  }\n  return a1;\n}\n"
    ],
    "sub_805BC5A": [
        "0x805bc5a",
        "int __usercall sub_805BC5A@<eax>(size_t n@<ecx>, char *s2@<edx>, const char *a3@<eax>)\n{\n  int result; // eax\n\n  result = strncmp(a3, s2, n);\n  if ( !result )\n    return -(unsigned __int8)s2[n];\n  return result;\n}\n"
    ],
    "sub_805BC78": [
        "0x805bc78",
        "int __usercall sub_805BC78@<eax>(const char *a1@<eax>, size_t a2@<edx>, _DWORD *a3@<ecx>)\n{\n  int i; // ebx\n  int v7; // ebp\n  int v9; // [esp+4h] [ebp-14h]\n\n  if ( !sub_805BC5A(a2, \"iface\", a1) || !sub_805BC5A(a2, \"label\", a1) )\n    return a3[2];\n  v9 = a3[3];\n  for ( i = 0; v9 > i; ++i )\n  {\n    v7 = a3[4] + 8 * i;\n    if ( !sub_805BC5A(a2, *(char **)v7, a1) )\n      return *(_DWORD *)(v7 + 4);\n  }\n  return 0;\n}\n"
    ],
    "sub_805BCE6": [
        "0x805bce6",
        "int __usercall sub_805BCE6@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char *v5; // edi\n  size_t v6; // ebx\n  char *v7; // edi\n  int v9; // [esp+0h] [ebp-14h]\n  int v10; // [esp+0h] [ebp-14h]\n\n  v5 = *a1;\n  v6 = 0;\n  if ( *a1 )\n  {\n    v9 = a3;\n    v6 = strlen(v5);\n    a3 = v9;\n  }\n  v10 = a3 + 1;\n  v7 = (char *)sub_804DB13(v5, v6 + a3 + 1);\n  sub_80B2C4E(v10, a2);\n  *a1 = v7;\n  return v10;\n}\n"
    ],
    "sub_805BD2B": [
        "0x805bd2b",
        "_BOOL4 __usercall sub_805BD2B@<eax>(char *a1@<eax>, _DWORD *a2@<edx>, int (__cdecl *a3)(char *)@<ecx>)\n{\n  int v4; // esi\n  char v5; // al\n  char *v6; // edi\n  int v7; // ecx\n  int v8; // edx\n  size_t v9; // eax\n  char *v10; // ebx\n  char *v11; // eax\n  const char *v12; // ebp\n  int v13; // edx\n  int v14; // ecx\n  const char *v15; // eax\n  int v16; // eax\n  unsigned int v17; // ecx\n  unsigned __int32 v18; // edx\n  unsigned int v19; // eax\n  const char *v20; // edi\n  int v21; // eax\n  char *v22; // ebx\n  _BOOL4 result; // eax\n  char *s; // [esp+8h] [ebp-4Ch] BYREF\n  struct in_addr inp; // [esp+Ch] [ebp-48h] BYREF\n  char v29[10]; // [esp+12h] [ebp-42h] BYREF\n  int v30[14]; // [esp+1Ch] [ebp-38h] BYREF\n\n  memset(v30, 0, 0x28u);\n  memset(v29, 0, sizeof(v29));\n  v29[0] = 1;\n  s = 0;\n  v4 = 1;\n  while ( 1 )\n  {\n    v5 = *a1;\n    if ( !*a1 )\n      break;\n    if ( v5 == 91 )\n    {\n      if ( a1[1] != 91 || v4 > 9 )\n        goto LABEL_23;\n      v9 = 0;\n      if ( s )\n        v9 = strlen(s);\n      v30[v4] = v9;\n      v29[v4++] = 1;\nLABEL_22:\n      a1 += 2;\n    }\n    else if ( (unsigned __int8)v5 > 0x5Bu )\n    {\n      if ( v5 == 92 )\n      {\n        v6 = a1 + 1;\n        if ( !a1[1] )\n          v6 = a1;\n        v7 = 1;\n        v8 = (int)v6;\n        goto LABEL_29;\n      }\n      if ( v5 == 93 && a1[1] == 93 && v4 != 1 )\n      {\n        if ( !v29[--v4] )\n          s[v30[v4]] = 0;\n        goto LABEL_22;\n      }\nLABEL_23:\n      sub_805BCE6(&s, (int)a1++, 1);\n    }\n    else\n    {\n      if ( v5 != 37 )\n        goto LABEL_23;\n      v10 = a1 + 1;\n      v11 = strchr(v10, 37);\n      v6 = v11;\n      if ( !v11 )\n        goto LABEL_42;\n      v12 = (const char *)sub_805BC78(v10, v11 - v10, a2);\n      if ( v12 )\n      {\n        if ( sub_804D210(v10, \"hwaddress\") )\n        {\n          sub_80B2E9F();\n          v12 = (const char *)sub_80B2E8C(v14, v13);\n        }\n        v7 = strlen(v12);\n        v8 = (int)v12;\nLABEL_29:\n        sub_805BCE6(&s, v8, v7);\n        goto LABEL_40;\n      }\n      if ( !sub_804D210(v10, \"bnmask\") )\n        goto LABEL_39;\n      v15 = (const char *)sub_805BC78(\"netmask\", 7u, a2);\n      if ( !v15 )\n        goto LABEL_39;\n      v16 = inet_aton(v15, &inp);\n      v17 = -1;\n      if ( v16 )\n      {\n        v18 = _byteswap_ulong(inp.s_addr);\n        v19 = ~v18;\n        if ( (~v18 & -v18) == 0 )\n        {\n          v17 = 32;\n          while ( v19 )\n          {\n            v19 >>= 1;\n            --v17;\n          }\n        }\n      }\n      a1 = v6 + 1;\n      if ( v17 )\n      {\n        v20 = sub_804D6F7(v17);\n        v21 = strlen(v20);\n        sub_805BCE6(&s, (int)v20, v21);\n      }\n      else\n      {\nLABEL_39:\n        v29[v4 - 1] = 0;\nLABEL_40:\n        a1 = v6 + 1;\n      }\n    }\n  }\n  v22 = s;\n  if ( v4 != 1 || !v29[0] )\n  {\nLABEL_42:\n    free(s);\n    return 0;\n  }\n  result = 0;\n  if ( s )\n  {\n    if ( *s )\n      v4 = a3(s);\n    free(v22);\n    return v4 == 1;\n  }\n  return result;\n}\n"
    ],
    "sub_805C163": [
        "0x805c163",
        "int __usercall sub_805C163@<eax>(_DWORD *a1@<eax>, int (__cdecl *a2)(char *)@<edx>)\n{\n  _BOOL4 v5; // ebx\n\n  if ( !if_nametoindex() )\n    return 2;\n  v5 = sub_805BD2B(\"ip addr flush dev %iface%[[ label %label%]]\", a1, a2);\n  if ( sub_805BD2B(\"ip link set %iface% down\", a1, a2) + v5 == 2 )\n    return 2;\n  else\n    return 0;\n}\n"
    ],
    "sub_805C1E1": [
        "0x805c1e1",
        "__pid_t __usercall sub_805C1E1@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4)\n{\n  __pid_t v4; // eax\n  __pid_t v5; // ebx\n  int v9[2]; // [esp+8h] [ebp-20h] BYREF\n  int v10; // [esp+10h] [ebp-18h] BYREF\n  int v11; // [esp+14h] [ebp-14h]\n  int v12; // [esp+18h] [ebp-10h]\n  int v13; // [esp+1Ch] [ebp-Ch]\n  int v14; // [esp+20h] [ebp-8h]\n\n  v12 = a3;\n  v13 = a4;\n  v14 = 0;\n  sub_804DC65(v9);\n  sub_804DC65(&v10);\n  sub_804DD8F();\n  v4 = vfork();\n  if ( v4 < 0 )\n    sub_804D3C9((int)&unk_80C7DA0);\n  if ( !v4 )\n  {\n    close(v9[1]);\n    close(v10);\n    sub_804DC97(v9[0], 0);\n    sub_804DC97(v11, 1);\n    sub_80AB1EC();\n  }\n  v5 = v4;\n  close(v9[0]);\n  close(v11);\n  *a1 = sub_80B3D6E();\n  *a2 = sub_80B3D67();\n  return v5;\n}\n"
    ],
    "sub_805C29C": [
        "0x805c29c",
        "__int64 sub_805C29C()\n{\n  int v0; // eax\n  FILE *v1; // esi\n  const char *v2; // eax\n  const char *v3; // ebx\n  int v5; // [esp-4h] [ebp-10h]\n\n  v0 = sub_80B3D37();\n  if ( v0 )\n  {\n    v1 = (FILE *)v0;\n    while ( 1 )\n    {\n      v2 = (const char *)sub_80AB850();\n      v3 = v2;\n      if ( !v2 )\n        break;\n      v2[strcspn(v2, \" \\t\\n\")] = 0;\n      sub_80AFAC3(v5, v3);\n    }\n    fclose(v1);\n  }\n  return 0LL;\n}\n"
    ],
    "sub_805C2ED": [
        "0x805c2ed",
        "_DWORD *__usercall sub_805C2ED@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v2; // ebp\n  _DWORD *v3; // esi\n  _DWORD *v4; // ebx\n  const char *i; // eax\n  int v6; // edx\n  int v7; // ecx\n  void *v8; // eax\n  const char *v9; // eax\n  const char *v10; // edi\n  char *v11; // edi\n  int v12; // edx\n  int v13; // ecx\n  const char *v14; // edi\n  int v15; // eax\n  int v16; // edx\n  _DWORD *v17; // edx\n  _DWORD *j; // eax\n  int v19; // edx\n  int v20; // ecx\n  const char *v21; // ebp\n  int v22; // edx\n  int v23; // ecx\n  const char *v24; // edi\n  int v25; // edx\n  int v26; // ecx\n  int v27; // edx\n  int v28; // ecx\n  int v29; // ecx\n  char ***v30; // ebp\n  int v31; // eax\n  void *v32; // edx\n  int v33; // edi\n  const char **v34; // ebp\n  int v35; // eax\n  int v36; // eax\n  int v37; // edx\n  int v38; // ecx\n  const char *v39; // edi\n  char *v40; // ecx\n  FILE *k; // edx\n  int v42; // eax\n  int v43; // eax\n  int v44; // edi\n  const char *v45; // eax\n  int v46; // edx\n  int v47; // ecx\n  const char *v48; // eax\n  char **v49; // edi\n  int v51; // [esp-4h] [ebp-38h]\n  int v52; // [esp-4h] [ebp-38h]\n  int v53; // [esp-4h] [ebp-38h]\n  int v54; // [esp+0h] [ebp-34h]\n  int v55; // [esp+0h] [ebp-34h]\n  int v56; // [esp+0h] [ebp-34h]\n  int v57; // [esp+0h] [ebp-34h]\n  int v58; // [esp+0h] [ebp-34h]\n  char *v59; // [esp+4h] [ebp-30h]\n  _DWORD *v60; // [esp+8h] [ebp-2Ch]\n  int ptr; // [esp+Ch] [ebp-28h]\n  void *ptra; // [esp+Ch] [ebp-28h]\n  char **ptrb; // [esp+Ch] [ebp-28h]\n  FILE *v64; // [esp+10h] [ebp-24h]\n  const char *v65; // [esp+14h] [ebp-20h]\n  FILE *v66; // [esp+14h] [ebp-20h]\n  char *s2; // [esp+1Ch] [ebp-18h]\n  char *s2a; // [esp+1Ch] [ebp-18h]\n  char *s2b; // [esp+1Ch] [ebp-18h]\n  void *v71; // [esp+20h] [ebp-14h] BYREF\n\n  v60 = a2;\n  if ( !a2 )\n    v60 = sub_804DB2E(0xCu);\n  v64 = (FILE *)sub_80B3D45();\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v59 = (char *)sub_80AB85A();\n    if ( !v59 )\n      break;\n    for ( i = sub_804D378(v59, 92); i; i = sub_804D378(v11, 92) )\n    {\n      *i = 0;\n      v8 = (void *)sub_80AB85A();\n      v71 = v8;\n      if ( !v8 )\n        break;\n      v11 = sub_804DDBF(\"%s%s\", v59, (const char *)v8);\n      free(v59);\n      free(v71);\n      v59 = v11;\n    }\n    v71 = v59;\n    v9 = sub_805BBF9(&v71, v6, v7);\n    v10 = v9;\n    if ( v9 && *v9 != 35 )\n    {\n      if ( !strcmp(v9, \"mapping\") )\n      {\n        v4 = sub_804DB2E(0x1Cu);\n        while ( 1 )\n        {\n          v14 = sub_805BBF9(&v71, v12, v13);\n          if ( !v14 )\n            break;\n          v15 = sub_80B4733(v4[2], 1028);\n          v4[3] = v15;\n          v16 = v4[2];\n          v4[2] = v16 + 1;\n          *(_DWORD *)(v15 + 4 * v16) = sub_804DB46(v14);\n        }\n        v17 = v60 + 2;\n        for ( j = (_DWORD *)v60[2]; j; j = (_DWORD *)*j )\n          v17 = j;\n        *v17 = v4;\n        v2 = 2;\n      }\n      else\n      {\n        ptr = strcmp(v10, \"iface\");\n        if ( ptr )\n        {\n          v36 = strcmp(v10, \"auto\");\n          v37 = v51;\n          v38 = v56;\n          if ( v36 )\n          {\n            if ( !strcmp(v10, \"source\") )\n            {\n              sub_805BBF9(&v71, v52, v57);\n              sub_805C2ED();\n            }\n            else if ( v2 == 1 )\n            {\n              if ( !*(_BYTE *)v71 )\n                sub_804D5E0(\"option with empty value \\\"%s\\\"\", v59);\n              if ( !strcmp(v10, \"post-up\") )\n              {\n                v10 += 5;\n              }\n              else if ( !strcmp(v10, \"pre-down\") )\n              {\n                v10 += 4;\n              }\n              if ( sub_804D222(\"up\", v10) < 0 )\n              {\n                ptra = (void *)v3[3];\n                v40 = (char *)v3[4];\n                for ( k = 0; (int)ptra > (int)k; k = (FILE *)((char *)&v66->_flags + 1) )\n                {\n                  s2b = v40;\n                  v66 = k;\n                  v42 = strcmp(*(const char **)&v40[8 * (_DWORD)k], v10);\n                  v40 = s2b;\n                  if ( !v42 )\n                    sub_804D5E0(\"duplicate option \\\"%s\\\"\", v59);\n                }\n              }\n              v43 = sub_80B4733(v3[3], 2052);\n              v3[4] = v43;\n              ptrb = (char **)(v43 + 8 * v3[3]);\n              *ptrb = sub_804DB46(v10);\n              v44 = v3[4] + 8 * v3[3];\n              *(_DWORD *)(v44 + 4) = sub_804DB46((const char *)v71);\n              ++v3[3];\n            }\n            else\n            {\n              if ( v2 != 2 )\n                goto LABEL_70;\n              if ( !strcmp(v10, \"script\") )\n              {\n                if ( v4[4] )\n                  sub_804D5E0(\"duplicate script in mapping \\\"%s\\\"\", v59);\n                v45 = sub_805BBF9(&v71, v53, v58);\n                v4[4] = sub_804DB46(v45);\n              }\n              else\n              {\n                if ( strcmp(v10, \"map\") )\nLABEL_70:\n                  sub_804D5E0(\"misplaced option \\\"%s\\\"\", v59);\n                v4[6] = sub_80B4733(v4[5], 1026);\n                v48 = sub_805BBF9(&v71, v46, v47);\n                v49 = (char **)(v4[6] + 4 * v4[5]);\n                *v49 = sub_804DB46(v48);\n                ++v4[5];\n              }\n            }\n          }\n          else\n          {\n            while ( 1 )\n            {\n              v39 = sub_805BBF9(&v71, v37, v38);\n              if ( !v39 )\n                break;\n              if ( sub_80AFB6A() )\n                sub_804D3C9((int)\"interface declared auto twice \\\"%s\\\"\", v59);\n              sub_804DB46(v39);\n              ((void (*)(void))sub_80AFADF)();\n            }\n            v2 = 0;\n          }\n        }\n        else\n        {\n          v3 = sub_804DB2E(0x14u);\n          v21 = sub_805BBF9(&v71, v19, v20);\n          v24 = sub_805BBF9(&v71, v22, v23);\n          v65 = sub_805BBF9(&v71, v25, v26);\n          if ( !v65 )\n            sub_804D5E0(\"too few parameters for line \\\"%s\\\"\", v59);\n          v71 = (void *)sub_80B2E8C(v28, v27);\n          if ( *(_BYTE *)v71 )\n            sub_804D5E0(\"too many parameters \\\"%s\\\"\", v59);\n          v3[2] = sub_804DB46(v21);\n          if ( !v24 )\n          {\n            *v3 = 0;\nLABEL_32:\n            sub_804D5E0(\"unknown address type \\\"%s\\\"\", v24);\n          }\n          v30 = off_80B7860;\n          do\n          {\n            v32 = *v30;\n            if ( !*v30 )\n              break;\n            s2 = (char *)*v30;\n            v31 = strcmp(*(const char **)v32, v24);\n            v29 = v54;\n            ++v30;\n            v32 = s2;\n          }\n          while ( v31 );\n          *v3 = v32;\n          if ( !v32 )\n            goto LABEL_32;\n          v33 = *((_DWORD *)v32 + 1);\n          while ( ptr < v33 )\n          {\n            v34 = (const char **)(*((_DWORD *)v32 + 2) + 12 * ptr);\n            s2a = (char *)v32;\n            v35 = strcmp(*v34, v65);\n            v29 = v55;\n            v32 = s2a;\n            if ( !v35 )\n              goto LABEL_37;\n            ++ptr;\n          }\n          v34 = 0;\nLABEL_37:\n          v3[1] = v34;\n          if ( !v34 )\n            sub_804D5E0(\"unknown method \\\"%s\\\"\", v65);\n          sub_80AFADF(v29, v3);\n          v2 = 1;\n        }\n      }\n    }\n    free(v59);\n  }\n  if ( (v64->_flags & 8) != 0 )\n    sub_804D5E0(\"%s: I/O error\", a1);\n  fclose(v64);\n  return v60;\n}\n"
    ],
    "sub_805C779": [
        "0x805c779",
        "int __cdecl sub_805C779(int a1, int a2)\n{\n  const char *v2; // eax\n  _DWORD *v3; // ebx\n  _DWORD *v4; // eax\n  int v5; // ecx\n  char *v6; // ebp\n  char *v7; // eax\n  const char *v8; // eax\n  char *v9; // ebx\n  int **v10; // esi\n  int **v11; // eax\n  _DWORD *i; // esi\n  int j; // edx\n  int v14; // edi\n  const char *v15; // eax\n  char *v16; // edi\n  const char *k; // eax\n  _DWORD *v18; // esi\n  int v19; // edi\n  int v20; // eax\n  signed int v21; // esi\n  int v22; // edi\n  FILE *v23; // esi\n  int v24; // ecx\n  char *v25; // edi\n  void *v26; // eax\n  FILE *m; // edi\n  _BOOL4 (__cdecl *v29)(int); // [esp+0h] [ebp-38h]\n  int v30; // [esp+4h] [ebp-34h]\n  __pid_t v31; // [esp+4h] [ebp-34h]\n  char v32; // [esp+4h] [ebp-34h]\n  _DWORD *v33; // [esp+8h] [ebp-30h]\n  const char *v34; // [esp+Ch] [ebp-2Ch]\n  unsigned __int8 v35; // [esp+12h] [ebp-26h]\n  char v36; // [esp+13h] [ebp-25h]\n  int **v37; // [esp+14h] [ebp-24h]\n  const char *v38; // [esp+18h] [ebp-20h] BYREF\n  FILE *stream; // [esp+1Ch] [ebp-1Ch] BYREF\n  FILE *v40; // [esp+20h] [ebp-18h] BYREF\n  int stat_loc; // [esp+24h] [ebp-14h] BYREF\n\n  v37 = 0;\n  v38 = \"/etc/network/interfaces\";\n  MEMORY[0x80DB77C] = (size_t)getenv(\"PATH\");\n  v2 = (const char *)sub_80AB879();\n  unk_80DB780 = (time_t)sub_804DB46(v2);\n  v29 = sub_805BB0B;\n  if ( ident[2] == 117 )\n    v29 = sub_805BB82;\n  sub_80ABEAC(a2, \"anvfmi:\", &v38);\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( *v3 )\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n      goto LABEL_5;\n  }\n  else if ( (dword_80DBB9C & 1) == 0 )\n  {\nLABEL_5:\n    sub_804CDC2();\n  }\n  v4 = sub_805C2ED((int)v38, 0);\n  v33 = v4;\n  if ( (dword_80DBB9C & 1) != 0 )\n    v37 = (int **)*v4;\n  else\n    sub_80AFADF(v5, *v3);\n  v35 = 0;\nLABEL_11:\n  if ( v37 )\n  {\n    v6 = sub_804DB46((const char *)v37[1]);\n    v37 = (int **)*v37;\n    v7 = strchr(v6, 61);\n    if ( v7 )\n    {\n      *v7 = 0;\n      v8 = v7 + 1;\n    }\n    else\n    {\n      v8 = v6;\n    }\n    v9 = sub_804DB46(v8);\n    if ( (dword_80DBB9C & 8) == 0 )\n    {\n      v10 = (int **)sub_805C29C();\n      v11 = sub_805BC34(v10, v6);\n      if ( v29 == sub_805BB82 )\n      {\n        if ( v11 )\n        {\n          sub_804D5F4(\"interface %s already configured\", v6);\n          goto LABEL_81;\n        }\n      }\n      else if ( !v11 )\n      {\n        sub_804D5F4(\"interface %s not configured\", v6);\n        goto LABEL_81;\n      }\n      sub_80AFB36();\n    }\n    if ( v29 == sub_805BB82 && (dword_80DBB9C & 0x10) == 0 )\n    {\n      for ( i = (_DWORD *)v33[2]; i; i = (_DWORD *)*i )\n      {\n        for ( j = 0; i[2] > j; j = v30 + 1 )\n        {\n          v30 = j;\n          v14 = fnmatch(*(const char **)(i[3] + 4 * j), v9, 0);\n          if ( !v14 )\n          {\n            if ( (dword_80DBB9C & 4) != 0 )\n              printf(\"Running mapping script %s on %s\\n\", (const char *)i[4], v9);\n            v9 = sub_804DB46(v6);\n            v31 = sub_805C1E1(&stream, &v40, i[4], (int)v6);\n            while ( v14 < i[5] )\n              fprintf(stream, \"%s\\n\", *(const char **)(i[6] + 4 * v14++));\n            fclose(stream);\n            sub_804DA34(0, &stat_loc, v31);\n            if ( (stat_loc & 0x7F) == 0 && !BYTE1(stat_loc) )\n            {\n              v15 = (const char *)sub_80AB85A();\n              v16 = (char *)v15;\n              if ( v15 )\n              {\n                for ( k = &v15[strlen(v15) - 1];\n                      v16 <= k && (*k == 32 || (unsigned __int8)(*k - 9) <= 4u);\n                      *((_BYTE *)k + 1) = 0 )\n                {\n                  --k;\n                }\n                free(v9);\n                v9 = v16;\n              }\n            }\n            fclose(v40);\n            break;\n          }\n        }\n      }\n    }\n    v18 = (_DWORD *)v33[1];\n    v32 = 0;\n    v36 = 0;\n    while ( 1 )\n    {\n      if ( !v18 )\n      {\n        if ( (dword_80DBB9C & 4) != 0 )\n          sub_804DD98(10);\n        if ( v36 || (dword_80DBB9C & 8) != 0 )\n        {\n          if ( (dword_80DBB9C & 2) == 0 )\n          {\n            v21 = 0;\n            v22 = 193;\n            while ( open64() < 0 )\n            {\n              if ( *(_DWORD *)dword_80DBB7C != 17 || v22 == 577 )\n                sub_804D3C9((int)\"can't open '%s'\", \"/var/run/ifstate.new\");\n              if ( v21 <= 30000 )\n              {\n                usleep(v21);\n                v21 += 1000;\n              }\n              else\n              {\n                v22 = 577;\n              }\n            }\n            v23 = (FILE *)sub_80B3D6E();\n            v40 = (FILE *)sub_805C29C();\n            stat_loc = (int)sub_805BC34((int **)v40, v6);\n            if ( v29 != sub_805BB82 || v32 )\n            {\n              sub_80AFB1E();\n              v26 = (void *)sub_80AFB01();\n              free(v26);\n            }\n            else\n            {\n              v25 = sub_804DDBF(\"%s=%s\", v6, v9);\n              if ( stat_loc )\n              {\n                free(*(void **)(stat_loc + 4));\n                *(_DWORD *)(stat_loc + 4) = v25;\n              }\n              else\n              {\n                sub_80AFADF(v24, v25);\n              }\n            }\n            for ( m = v40; m; m = (FILE *)m->_flags )\n            {\n              if ( m->_IO_read_ptr )\n                fprintf(v23, \"%s\\n\", m->_IO_read_ptr);\n            }\n            fclose(v23);\n            sub_804DC43(\"/var/run/ifstate.new\", \"/var/run/ifstate\");\n            sub_80AFB36();\n          }\n        }\n        else\n        {\n          sub_804D5F4(\"ignoring unknown interface %s\", v9);\n          v35 = 1;\n        }\nLABEL_81:\n        free(v6);\n        free(v9);\n        goto LABEL_11;\n      }\n      v19 = v18[1];\n      v34 = *(const char **)(v19 + 8);\n      if ( !strcmp(v9, v34) )\n        break;\nLABEL_54:\n      v18 = (_DWORD *)*v18;\n    }\n    *(_DWORD *)(v19 + 8) = v6;\n    v20 = v29(v19);\n    if ( v20 == -1 )\n    {\n      sub_804D5F4(\"don't have all variables for %s/%s\", v9, **(const char ***)v19);\n    }\n    else if ( v20 )\n    {\nLABEL_53:\n      *(_DWORD *)(v19 + 8) = v34;\n      v36 = 1;\n      goto LABEL_54;\n    }\n    v32 = 1;\n    v35 = 1;\n    goto LABEL_53;\n  }\n  return v35;\n}\n"
    ],
    "sub_805CBCA": [
        "0x805cbca",
        "signed int __usercall sub_805CBCA@<eax>(signed int result@<eax>)\n{\n  unsigned int v1; // edx\n\n  if ( result >= 0 )\n  {\n    v1 = (unsigned int)result >> 5;\n    result &= 0x1Fu;\n    _bittestandreset(&dword_80DB840[v1], result);\n    dword_80DB798 = (char *)-1;\n  }\n  return result;\n}\n"
    ],
    "sub_805CBE9": [
        "0x805cbe9",
        "int sub_805CBE9()\n{\n  int result; // eax\n  _BYTE *v1; // edx\n\n  MEMORY[0x80DB7B8] = &dword_80DB7C0;\n  for ( result = 32; result != 127; ++result )\n  {\n    v1 = MEMORY[0x80DB7B8];\n    MEMORY[0x80DB7B8] = (char *)MEMORY[0x80DB7B8] + 1;\n    *v1 = result;\n  }\n  return result;\n}\n"
    ],
    "sub_805CC26": [
        "0x805cc26",
        "int __usercall sub_805CC26@<eax>(int result@<eax>)\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  if ( result >= 0 )\n  {\n    close(result);\n    return v1;\n  }\n  return result;\n}\n"
    ],
    "sub_805CC32": [
        "0x805cc32",
        "int __usercall sub_805CC32@<eax>(void **a1@<eax>)\n{\n  int i; // esi\n  int result; // eax\n  int v4; // [esp-4h] [ebp-Ch]\n\n  free(a1[1]);\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[9]);\n  free(a1[10]);\n  free(a1[13]);\n  free(a1[14]);\n  for ( i = 0; i != 20; ++i )\n  {\n    free(a1[i + 15]);\n    result = v4;\n  }\n  return result;\n}\n"
    ],
    "sub_805CC86": [
        "0x805cc86",
        "int sub_805CC86()\n{\n  unsigned __int64 v0; // rax\n  unsigned __int64 v1; // rax\n  int result; // eax\n  int v3; // [esp-4h] [ebp-18h]\n  int v4; // [esp-4h] [ebp-18h]\n  __int64 v5; // [esp+0h] [ebp-14h]\n  unsigned __int64 v6; // [esp+0h] [ebp-14h]\n  unsigned __int64 v7; // [esp+8h] [ebp-Ch]\n\n  getrlimit64();\n  v0 = v5 + 32;\n  if ( v5 + 32 > v7 )\n    v0 = v7;\n  v1 = v0 + 32;\n  if ( v1 > 0x400 )\n    v1 = 1024LL;\n  v6 = v1;\n  if ( v1 > qword_80DB778 )\n  {\n    if ( setrlimit64() >= 0 )\n    {\n      result = v6;\n      qword_80DB778 = v6;\n    }\n    else\n    {\n      sub_804D3A5((int)\"setrlimit\");\n      return v4;\n    }\n  }\n  else\n  {\n    sub_804D5F4(\"can't extend file limit, max = %d\", (_DWORD)v1);\n    return v3;\n  }\n  return result;\n}\n"
    ],
    "sub_805CD2C": [
        "0x805cd2c",
        "int __usercall sub_805CD2C@<eax>(int result@<eax>)\n{\n  if ( result >= 0 )\n  {\n    _bittestandset(&dword_80DB840[(unsigned int)result >> 5], result & 0x1F);\n    if ( (int)dword_80DB798 >= 0 && (int)dword_80DB798 < result )\n    {\n      dword_80DB798 = (char *)result;\n      stream = (FILE *)result;\n      if ( result > (unsigned __int64)(qword_80DB778 - 8LL) )\n        return sub_805CC86();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_805CD8B": [
        "0x805cd8b",
        "void __noreturn sub_805CD8B()\n{\n  int i; // ebx\n\n  for ( i = unk_80DB790; i; i = *(_DWORD *)(i + 48) )\n  {\n    if ( *(_DWORD *)i != -1 && *(_BYTE *)(i + 21) == 1 )\n      unlink(*(const char **)(i + 8));\n  }\n  exit(0);\n}\n"
    ],
    "sub_805CDB6": [
        "0x805cdb6",
        "int __fastcall sub_805CDB6(int a1, int a2)\n{\n  _DWORD *v2; // esi\n  int v3; // edi\n  __pid_t v4; // eax\n  int *i; // ebx\n  int v7; // [esp+0h] [ebp-10h] BYREF\n\n  v7 = a2;\n  v2 = (_DWORD *)dword_80DBB7C;\n  v3 = *(_DWORD *)dword_80DBB7C;\nLABEL_2:\n  while ( 1 )\n  {\n    v4 = sub_804DA5C(&v7);\n    if ( v4 <= 0 )\n      break;\n    for ( i = (int *)unk_80DB790; i; i = (int *)i[12] )\n    {\n      if ( i[4] == v4 )\n      {\n        if ( (v7 & 0x7F) != 0 || !BYTE1(v7) )\n        {\n          if ( (unsigned int)(unsigned __int16)v7 - 1 <= 0xFE )\n            sub_804D5F4(\"%s: exit signal %u\", i[14], v7 & 0x7F);\n        }\n        else\n        {\n          sub_804D5F4(\"%s: exit status %u\", i[14], BYTE1(v7));\n        }\n        i[4] = 1;\n        sub_805CD2C(*i);\n        goto LABEL_2;\n      }\n    }\n  }\n  *v2 = v3;\n  return v7;\n}\n"
    ],
    "sub_805D004": [
        "0x805d004",
        "_WORD *__usercall sub_805D004@<eax>(int a1@<eax>)\n{\n  __int16 v1; // si\n  int v2; // ebx\n  _WORD *result; // eax\n\n  v1 = a1;\n  v2 = 110;\n  if ( a1 != 1 )\n    v2 = a1 == 10 ? 28 : 16;\n  result = sub_804DB2E(v2 + 4);\n  *(_DWORD *)result = v2;\n  result[2] = v1;\n  return result;\n}\n"
    ],
    "sub_805D030": [
        "0x805d030",
        "int __usercall sub_805D030@<eax>(sigset_t *a1@<eax>)\n{\n  a1->__val[0] = 0;\n  a1->__val[1] = 0;\n  sigaddset(a1, 17);\n  sigaddset(a1, 1);\n  sigaddset(a1, 14);\n  return sigprocmask(0, a1, a1);\n}\n"
    ],
    "sub_805D066": [
        "0x805d066",
        "int __usercall sub_805D066@<eax>(const sigset_t *a1@<eax>)\n{\n  return sigprocmask(2, a1, 0);\n}\n"
    ],
    "sub_805D074": [
        "0x805d074",
        "int sub_805D074()\n{\n  int result; // eax\n  int v1; // [esp-4h] [ebp-4h]\n\n  if ( !dword_80DB7A4 )\n  {\n    dword_80DB7A4 = 1;\n    alarm(0x3Cu);\n    return v1;\n  }\n  return result;\n}\n"
    ],
    "sub_805D08D": [
        "0x805d08d",
        "int __usercall sub_805D08D@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // esi\n\n  v2 = socket(*(char *)(a1 + 21), *(char *)(a1 + 20), 0);\n  if ( v2 < 0 )\n    return sub_804D3A5((int)\"socket\");\n  v4 = v2;\n  sub_80B4262();\n  if ( *(_BYTE *)(a1 + 21) == 1 )\n    unlink((const char *)(*(_DWORD *)(a1 + 52) + 6));\n  if ( bind(v4, (const struct sockaddr *)(*(_DWORD *)(a1 + 52) + 4), **(_DWORD **)(a1 + 52)) >= 0 )\n  {\n    if ( *(_BYTE *)(a1 + 20) == 1 )\n      listen(v4, unk_80DB794);\n    result = sub_805CD2C(v4);\n    *(_DWORD *)a1 = v4;\n  }\n  else\n  {\n    sub_804D3A5((int)&unk_80CC99B, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));\n    close(v4);\n    return sub_805D074();\n  }\n  return result;\n}\n"
    ],
    "sub_805D126": [
        "0x805d126",
        "int sub_805D126()\n{\n  _DWORD *v0; // esi\n  int v1; // edi\n  _DWORD *i; // ebx\n  int result; // eax\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  dword_80DB7A4 = 0;\n  for ( i = (_DWORD *)unk_80DB790; i; i = (_DWORD *)i[12] )\n  {\n    if ( *i == -1 )\n      result = sub_805D08D((int)i);\n  }\n  *v0 = v1;\n  return result;\n}\n"
    ],
    "sub_805D2E3": [
        "0x805d2e3",
        "_DWORD *sub_805D2E3()\n{\n  _DWORD *v0; // ebx\n  int v1; // ebp\n  const char *v2; // esi\n  char *v3; // eax\n  char *v4; // edi\n  char *v5; // esi\n  const char *v6; // eax\n  char *v7; // edi\n  const char *v8; // esi\n  char *v9; // eax\n  char *v10; // esi\n  char *v11; // eax\n  char *v12; // eax\n  const char *v13; // edi\n  char v14; // dl\n  const char *v15; // esi\n  int v16; // eax\n  int v17; // esi\n  const char *v18; // eax\n  char v19; // al\n  bool v20; // zf\n  int i; // esi\n  const char **v22; // ebp\n  char v24; // [esp+4h] [ebp-7Ch]\n  char *v25; // [esp+4h] [ebp-7Ch]\n  char *v26; // [esp+8h] [ebp-78h]\n  char *s; // [esp+Ch] [ebp-74h]\n  const char *v28; // [esp+10h] [ebp-70h]\n  char *v29; // [esp+14h] [ebp-6Ch]\n  char *s1; // [esp+18h] [ebp-68h]\n  const char *v31; // [esp+1Ch] [ebp-64h]\n  int v32[24]; // [esp+20h] [ebp-60h]\n\n  while ( 1 )\n  {\n    v0 = sub_804DB2E(0x90u);\n    *v0 = -1;\n    while ( 1 )\n    {\n      v1 = sub_80B0560(\"# \\t\");\n      if ( !v1 )\n      {\n        free(v0);\n        return 0;\n      }\n      v2 = v26;\n      v3 = strrchr(v26, 58);\n      v4 = v3;\n      if ( !v3 )\n        break;\n      *v3 = 0;\n      v0[1] = sub_804DB46(v26);\n      if ( v4[1] || v1 != 1 )\n      {\n        v2 = v4 + 1;\n        goto LABEL_10;\n      }\n      free(dword_80DB7B4);\n      dword_80DB7B4 = (void *)v0[1];\n    }\n    v0[1] = sub_804DB46((const char *)dword_80DB7B4);\nLABEL_10:\n    v0[2] = sub_804DB46(v2);\n    if ( v1 <= 5 )\n      goto LABEL_11;\n    *((_BYTE *)v0 + 20) = byte_80CCB12[sub_804D222(\"stream\", s)];\n    v5 = sub_804DB46(v28);\n    v0[3] = v5;\n    if ( !strcmp(v5, \"unix\") )\n    {\n      *((_BYTE *)v0 + 21) = 1;\n      goto LABEL_25;\n    }\n    *((_BYTE *)v0 + 21) = 2;\n    v6 = sub_804D378(v5, 54);\n    v7 = (char *)v6;\n    if ( v6 )\n    {\n      *v6 = 0;\n      *((_BYTE *)v0 + 21) = 10;\n    }\n    if ( !sub_804D210(v5, \"rpc/\") )\n      break;\n    sub_804D5F4(\"no support for rpc services\");\nLABEL_11:\n    sub_804D5F4(\"parse error on line %u, line is ignored\", *(_DWORD *)(dword_80DB7B0 + 24));\n    sub_805CC32((void **)v0);\n    free(v0);\n  }\n  if ( !strcmp(v5, \"tcp\") )\n    *((_BYTE *)v0 + 22) = 6;\n  if ( !strcmp(v5, \"udp\") )\n  {\n    *((_BYTE *)v0 + 22) = 17;\n    if ( !v7 )\n      goto LABEL_25;\n    goto LABEL_22;\n  }\n  if ( v7 )\nLABEL_22:\n    *v7 = 54;\n  if ( !*((_BYTE *)v0 + 22) )\n    goto LABEL_11;\nLABEL_25:\n  v8 = v29;\n  v0[6] = pmatch[0].rm_so;\n  v9 = strchr(v29, 46);\n  if ( v9 )\n  {\n    *v9 = 0;\n    v0[6] = sub_804ED6C(10, v9 + 1, 0, (int)v0);\n    if ( *(_DWORD *)dword_80DBB7C )\n      goto LABEL_11;\n  }\n  if ( *v29 == 110 && v29[1] == 111 )\n  {\n    v0[4] = 0;\n    v8 = v29 + 2;\n  }\n  else\n  {\n    v0[4] = 1;\n  }\n  if ( strcmp(v8, \"wait\") )\n    goto LABEL_11;\n  v10 = sub_804DB46(s1);\n  v0[9] = v10;\n  v11 = strchr(v10, 46);\n  if ( v11 || (v11 = strchr(v10, 58)) != 0 )\n  {\n    *v11 = 0;\n    v0[10] = sub_804DB46(v11 + 1);\n  }\n  v12 = sub_804DB46(v31);\n  v0[14] = v12;\n  if ( !strcmp(v12, \"internal\") )\n  {\n    v13 = (const char *)v0[2];\n    if ( strlen(v13) <= 7 )\n    {\n      v14 = *((_BYTE *)v0 + 20);\n      if ( (unsigned __int8)(v14 - 1) <= 1u )\n      {\n        v15 = \"echo\";\n        while ( 1 )\n        {\n          v24 = v14;\n          v16 = strncmp(v15, v13, 7u);\n          v14 = v24;\n          if ( !v16 )\n            break;\n          v15 += 16;\n          if ( &unk_80B57D0 == (_UNKNOWN *)v15 )\n          {\n            sub_804D5F4(\"unknown internal service %s\", v13);\n            goto LABEL_11;\n          }\n        }\n        v0[11] = v15;\n        if ( v0[4] != (v24 == 2) )\n          goto LABEL_11;\n      }\n    }\n  }\n  v17 = 0;\n  while ( 1 )\n  {\n    v18 = (const char *)v32[v17];\n    if ( !v18 )\n      break;\n    v0[++v17 + 14] = sub_804DB46(v18);\n    if ( v17 == 20 )\n      goto LABEL_51;\n  }\n  if ( !v17 )\n    v0[15] = sub_804DB46((const char *)v0[14]);\nLABEL_51:\n  v19 = *((_BYTE *)v0 + 20);\n  if ( v19 == 1 )\n  {\n    v20 = *((_BYTE *)v0 + 22) == 17;\n  }\n  else\n  {\n    if ( v19 != 2 )\n      goto LABEL_59;\n    v20 = *((_BYTE *)v0 + 22) == 6;\n  }\n  if ( v20 )\n    goto LABEL_11;\nLABEL_59:\n  while ( 1 )\n  {\n    v25 = strrchr((const char *)v0[1], 44);\n    if ( !v25 )\n      break;\n    v22 = (const char **)sub_804DB2E(0x90u);\n    qmemcpy(v22, v0, 0x90u);\n    v22[2] = sub_804DB46(v22[2]);\n    v22[3] = sub_804DB46(v22[3]);\n    v22[9] = sub_804DB46(v22[9]);\n    v22[10] = sub_804DB46(v22[10]);\n    v22[14] = sub_804DB46(v22[14]);\n    for ( i = 0; i != 21; ++i )\n      v22[i + 15] = sub_804DB46(v22[i + 15]);\n    *v25 = 0;\n    v22[1] = sub_804DB46(v25 + 1);\n    v22[12] = (const char *)v0[12];\n    v0[12] = v22;\n  }\n  return v0;\n}\n"
    ],
    "sub_805D67B": [
        "0x805d67b",
        "int sub_805D67B()\n{\n  int i; // eax\n  unsigned int v1; // eax\n  int s_port; // edi\n  struct servent *v3; // eax\n  _DWORD *v4; // ebx\n  _DWORD *v5; // ebp\n  _DWORD *j; // ebx\n  int v7; // esi\n  int v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  _WORD *v12; // esi\n  _BYTE *v13; // eax\n  unsigned __int16 v14; // cx\n  _DWORD *v15; // eax\n  int *v16; // esi\n  int v17; // ebx\n  int result; // eax\n  int v19; // [esp+0h] [ebp-24h]\n  char v20[8]; // [esp+4h] [ebp-20h] BYREF\n  char proto[24]; // [esp+Ch] [ebp-18h] BYREF\n\n  v19 = *(_DWORD *)dword_80DBB7C;\n  free(dword_80DB7B4);\n  dword_80DB7B4 = sub_804DB46(\"*\");\n  if ( dword_80DB7B0 )\n    sub_80B0536();\n  dword_80DB7B0 = sub_80B052C();\n  if ( dword_80DB7B0 )\n  {\n    for ( i = unk_80DB790; i; i = *(_DWORD *)(i + 48) )\n      *(_BYTE *)(i + 23) = 0;\nLABEL_11:\n    v5 = sub_805D2E3();\n    if ( v5 )\n    {\n      while ( 1 )\n      {\n        for ( j = (_DWORD *)unk_80DB790; ; j = (_DWORD *)j[12] )\n        {\n          if ( !j )\n          {\n            j = sub_804DB2E(0x90u);\n            *j = -1;\n            qmemcpy(j, v5, 0x90u);\n            *j = -1;\n            sub_805D030((sigset_t *)proto);\n            j[12] = unk_80DB790;\n            unk_80DB790 = (int)j;\n            sub_805D066((const sigset_t *)proto);\n            goto LABEL_24;\n          }\n          if ( !strcmp((const char *)j[1], (const char *)v5[1]) && !strcmp((const char *)j[2], (const char *)v5[2]) )\n          {\n            v7 = strcmp((const char *)j[3], (const char *)v5[3]);\n            if ( !v7 )\n              break;\n          }\n        }\n        sub_805D030((sigset_t *)v20);\n        if ( !v5[4] )\n          sub_805CD2C(*j);\n        j[4] = v5[4];\n        j[6] = v5[6];\n        v8 = j[9];\n        j[9] = v5[9];\n        v5[9] = v8;\n        v9 = j[10];\n        j[10] = v5[10];\n        v5[10] = v9;\n        v10 = j[14];\n        j[14] = v5[14];\n        v5[14] = v10;\n        do\n        {\n          v11 = j[v7 + 15];\n          j[v7 + 15] = v5[v7 + 15];\n          v5[v7++ + 15] = v11;\n        }\n        while ( v7 != 20 );\n        sub_805D066((const sigset_t *)v20);\n        sub_805CC32((void **)v5);\nLABEL_24:\n        *((_BYTE *)j + 23) = 1;\n        if ( *((_BYTE *)j + 21) == 1 )\n        {\n          v12 = sub_805D004(1);\n          sub_80B2C4E(108, j[2]);\n          goto LABEL_34;\n        }\n        v1 = sub_804ED6C(10, (const char *)j[2], 0, (int)j);\n        LOWORD(s_port) = __ROL2__(v1, 8);\n        if ( *(_DWORD *)dword_80DBB7C || v1 > 0xFFFF )\n        {\n          sub_80B2C4E(4, j[3]);\n          v3 = getservbyname((const char *)j[2], proto);\n          if ( !v3 )\n          {\n            sub_804D5F4(\"%s/%s: unknown service\", (const char *)j[2], (const char *)j[3]);\n            goto LABEL_10;\n          }\n          s_port = v3->s_port;\n        }\n        v13 = (_BYTE *)j[1];\n        v14 = *((char *)j + 21);\n        if ( *v13 == 42 && !v13[1] )\n        {\n          v12 = sub_805D004((char)v14);\n          sub_80B435E();\nLABEL_34:\n          v15 = (_DWORD *)j[13];\n          if ( v15 && *(_DWORD *)v12 == *v15 && !memcmp(v12 + 2, v15 + 1, *(_DWORD *)v12) )\n          {\n            free(v12);\n          }\n          else\n          {\n            sub_805CBCA(*j);\n            sub_805CC26(*j);\n            free((void *)j[13]);\n            j[13] = v12;\n            *j = -1;\n          }\n          if ( *j == -1 )\n            sub_805D08D((int)j);\n          goto LABEL_10;\n        }\n        v12 = (_WORD *)sub_80B459A(v14, (unsigned __int16)__ROL2__(s_port, 8));\n        if ( v12 )\n          goto LABEL_34;\n        sub_804D5F4(\"%s/%s: unknown host '%s'\", (const char *)j[2], (const char *)j[3], (const char *)j[1]);\nLABEL_10:\n        v4 = (_DWORD *)v5[12];\n        free(v5);\n        v5 = v4;\n        if ( !v4 )\n          goto LABEL_11;\n      }\n    }\n    if ( dword_80DB7B0 )\n    {\n      sub_80B0536();\n      dword_80DB7B0 = 0;\n    }\n    sub_805D030((sigset_t *)v20);\n    v16 = &unk_80DB790;\n    while ( 1 )\n    {\n      v17 = *v16;\n      if ( !*v16 )\n        break;\n      if ( *(_BYTE *)(v17 + 23) )\n      {\n        v16 = (int *)(v17 + 48);\n      }\n      else\n      {\n        *v16 = *(_DWORD *)(v17 + 48);\n        sub_805CBCA(*(_DWORD *)v17);\n        sub_805CC26(*(_DWORD *)v17);\n        if ( *(_BYTE *)(v17 + 21) == 1 )\n          unlink(*(const char **)(v17 + 8));\n        sub_805CC32((void **)v17);\n        free((void *)v17);\n      }\n    }\n    sub_805D066((const sigset_t *)v20);\n  }\n  result = dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = v19;\n  return result;\n}\n"
    ],
    "sub_805D9C9": [
        "0x805d9c9",
        "void __cdecl __noreturn sub_805D9C9(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // eax\n  int v4; // ecx\n  unsigned int i; // eax\n  int v6; // ecx\n  unsigned int v7; // eax\n  int v8; // eax\n  int v9; // eax\n  int v10; // ebx\n  unsigned int v11; // edx\n  __pid_t v12; // eax\n  int v13; // ecx\n  struct passwd *v14; // ebx\n  _WORD *v15; // ebx\n  void *pw_uid; // ecx\n  int v17; // edx\n  int *j; // ebx\n  unsigned int v19; // [esp+4h] [ebp-D8h]\n  signed int seconds; // [esp+8h] [ebp-D4h]\n  int v21; // [esp+Ch] [ebp-D0h]\n  int fd; // [esp+10h] [ebp-CCh]\n  struct group *v23; // [esp+14h] [ebp-C8h]\n  int v24; // [esp+18h] [ebp-C4h]\n  int v25; // [esp+1Ch] [ebp-C0h]\n  int v26[2]; // [esp+20h] [ebp-BCh] BYREF\n  _BYTE v27[168]; // [esp+28h] [ebp-B4h] BYREF\n\n  qword_80DB778 = 64;\n  *(&qword_80DB778 + 1) = 0;\n  unk_80DB794 = 128;\n  MEMORY[0x80DB7AC] = (int)\"/etc/inetd.conf\";\n  qword_80DB7A8 = (void *)getuid();\n  if ( qword_80DB7A8 )\n    MEMORY[0x80DB7AC] = 0;\n  v2 = sub_80ABEAC(a2, \"R:+feq:+\", pmatch, &unk_80DB794);\n  if ( *(_DWORD *)(a2 + 4 * optind) )\n    MEMORY[0x80DB7AC] = *(_DWORD *)(a2 + 4 * optind);\n  if ( !MEMORY[0x80DB7AC] )\n    sub_804D5E0(\"non-root must specify config file\");\n  if ( (v2 & 2) != 0 )\n    sub_80B3CDB();\n  else\n    sub_80B3C0D();\n  if ( (v2 & 4) == 0 )\n  {\n    openlog(ident, 9, 24);\n    byte_80DB561 = 2;\n  }\n  if ( !qword_80DB7A8 )\n  {\n    *(_DWORD *)&v27[40] = getgid();\n    setgroups(1u, (const __gid_t *)&v27[40]);\n  }\n  getrlimit64();\n  qword_80DB778 = *(_QWORD *)&unk_80DB780;\n  if ( *(_QWORD *)&unk_80DB780 == -1LL )\n  {\n    qword_80DB778 = 64;\n    *(&qword_80DB778 + 1) = 0;\n  }\n  memset(v27, 0, 0x14u);\n  sigaddset((sigset_t *)&v27[12], 14);\n  sigaddset((sigset_t *)&v27[12], 17);\n  sigaddset((sigset_t *)&v27[12], 1);\n  *(_DWORD *)v27 = sub_805D126;\n  sub_804E698(14, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805D67B;\n  sub_804E698(1, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805CDB6;\n  sub_804E698(17, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805CD8B;\n  sub_804E698(15, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805CD8B;\n  sub_804E698(2, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = 1;\n  sigaction(13, (const struct sigaction *)v27, (struct sigaction *)&v27[20]);\n  sub_805D67B();\n  while ( 1 )\n  {\nLABEL_17:\n    if ( *((int *)&qword_80DB778 + 8) < 0 )\n    {\n      *((_DWORD *)&qword_80DB778 + 8) = 0;\n      v4 = *((_DWORD *)&qword_80DB778 + 9);\n      for ( i = 0; (int)i <= v4; ++i )\n      {\n        if ( _bittest((const signed __int32 *)&qword_80DB778 + (i >> 5) + 50, i & 0x1F) )\n          *((_DWORD *)&qword_80DB778 + 8) = i;\n      }\n      v6 = *((_DWORD *)&qword_80DB778 + 8);\n      *((_DWORD *)&qword_80DB778 + 9) = v6;\n      if ( v6 > (unsigned __int64)(qword_80DB778 - 8LL) )\n        sub_805CC86();\n    }\n    qmemcpy(&v27[40], dword_80DB840, 0x80u);\n    v3 = select(*((_DWORD *)&qword_80DB778 + 8) + 1, (fd_set *)&v27[40], 0, 0, 0);\n    if ( v3 >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 4 )\n    {\n      sub_804D3A5((int)\"select\");\n      sleep(1u);\n    }\n  }\n  v19 = unk_80DB790;\n  v24 = v3;\n  while ( 1 )\n  {\n    if ( !v19 || !v24 )\n      goto LABEL_17;\n    v7 = *(_DWORD *)v19;\n    if ( *(_DWORD *)v19 != -1 && _bittest((const signed __int32 *)&v27[4 * (v7 >> 5) + 40], *(_DWORD *)v19 & 0x1F) )\n    {\n      --v24;\n      v21 = *(_DWORD *)v19;\n      fd = -1;\n      seconds = -1;\n      if ( *(_DWORD *)(v19 + 16) )\n        goto LABEL_45;\n      if ( *(_BYTE *)(v19 + 20) != 1 || (fd = accept(v7, 0, 0), v21 = fd, fd >= 0) )\n      {\n        if ( *(_BYTE *)(v19 + 20) == 2 )\n        {\n          v8 = *(char *)(v19 + 21);\n          if ( (_BYTE)v8 != 1 )\n          {\n            seconds = socket(v8, 2, 0);\n            if ( seconds < 0 )\n              goto LABEL_42;\n            sub_80B4262();\n            if ( bind(seconds, (const struct sockaddr *)(*(_DWORD *)(v19 + 52) + 4), **(_DWORD **)(v19 + 52)) < 0 )\n            {\n              close(seconds);\nLABEL_42:\n              recv(*(_DWORD *)v19, &unk_80DB8C0, 0x2B8u, 64);\n              goto LABEL_108;\n            }\n          }\n        }\nLABEL_45:\n        sub_805D030((sigset_t *)v26);\n        v9 = *(_DWORD *)(v19 + 44);\n        if ( !v9 || (v10 = 0, *(_BYTE *)(v19 + 20) == 1) && *(_BYTE *)(v9 + 7) )\n        {\n          v11 = *(_DWORD *)(v19 + 24);\n          if ( !v11 )\n            goto LABEL_55;\n          v25 = *(_DWORD *)(v19 + 28);\n          *(_DWORD *)(v19 + 28) = v25 + 1;\n          if ( !v25 )\n          {\n            *(_DWORD *)(v19 + 32) = sub_804EC4A();\n            goto LABEL_55;\n          }\n          if ( v11 <= v25 + 1 )\n          {\n            if ( (unsigned int)(sub_804EC4A() - *(_DWORD *)(v19 + 32)) <= 0x3C )\n            {\n              sub_804D5F4(\"%s/%s: too many connections, pausing\", *(const char **)(v19 + 8), *(const char **)(v19 + 12));\n              sub_805CBCA(*(_DWORD *)v19);\n              close(*(_DWORD *)v19);\n              *(_DWORD *)v19 = -1;\n              *(_DWORD *)(v19 + 28) = 0;\n              sub_805D074();\n              goto LABEL_60;\n            }\n            *(_DWORD *)(v19 + 28) = 0;\n          }\nLABEL_55:\n          if ( *(_DWORD *)(v19 + 44) )\n            v12 = fork();\n          else\n            v12 = vfork();\n          if ( v12 < 0 )\n          {\n            sub_804D3A5((int)\"fork\");\n            sleep(1u);\nLABEL_60:\n            sub_805D066((const sigset_t *)v26);\n            sub_805CC26(seconds);\nLABEL_61:\n            sub_805CC26(fd);\n            goto LABEL_108;\n          }\n          v10 = -1;\n          if ( v12 )\n          {\n            if ( *(_DWORD *)(v19 + 16) )\n            {\n              *(_DWORD *)(v19 + 16) = v12;\n              sub_805CBCA(*(_DWORD *)v19);\n            }\n            if ( seconds >= 0 )\n              sub_804DC97(seconds, *(_DWORD *)v19);\n            sub_805D066((const sigset_t *)v26);\n            goto LABEL_61;\n          }\n        }\n        if ( !*(_DWORD *)(v19 + 44) )\n        {\n          setsid();\n          if ( seconds >= 0 )\n          {\n            close(seconds);\n            v15 = sub_805D004(*(char *)(v19 + 21));\n            if ( recvfrom(v21, 0, 0, 66, (struct sockaddr *)(v15 + 2), (socklen_t *)v15) >= 0 )\n            {\n              connect(v21, (const struct sockaddr *)(v15 + 2), *(_DWORD *)v15);\n              free(v15);\n              goto LABEL_77;\n            }\n          }\n          else\n          {\nLABEL_77:\n            v14 = getpwnam(*(const char **)(v19 + 36));\n            if ( v14 )\n            {\n              if ( !*(_DWORD *)(v19 + 40) || (v23 = getgrnam(*(const char **)(v19 + 40))) != 0 )\n              {\n                pw_uid = (void *)v14->pw_uid;\n                if ( !qword_80DB7A8 || qword_80DB7A8 == pw_uid )\n                {\n                  v17 = *(_DWORD *)(v19 + 40);\n                  if ( qword_80DB7A8 == pw_uid )\n                  {\n                    if ( v17 )\n                    {\n                      sub_804DE5E(v23->gr_gid);\n                      setgroups(1u, &v23->gr_gid);\n                    }\n                  }\n                  else\n                  {\n                    if ( v17 )\n                      v14->pw_gid = v23->gr_gid;\n                    sub_80A9B93();\n                  }\n                  if ( *(_QWORD *)&unk_80DB780 != qword_80DB778 && setrlimit64() < 0 )\n                    sub_804D3A5((int)\"setrlimit\");\n                  sub_804DC97(v21, 0);\n                  sub_804DC7B(0, 1);\n                  if ( !*(_DWORD *)(v19 + 16) )\n                    sub_804DC7B(0, 2);\n                  for ( j = (int *)unk_80DB790; j; j = (int *)j[12] )\n                  {\n                    if ( *j != v21 )\n                      sub_805CC26(*j);\n                  }\n                  sub_804E698(13, (const struct sigaction *)&v27[20]);\n                  sub_805D066((const sigset_t *)v26);\n                  execvp(*(const char **)(v19 + 56), (char *const *)(v19 + 60));\n                  sub_804D3A5((int)\"can't execute '%s'\", *(const char **)(v19 + 56));\n                }\n                else\n                {\n                  sub_804D5F4(\"non-root must run services as himself\");\n                }\n              }\n              else\n              {\n                sub_804D5F4(\"%s: no such %s\", *(const char **)(v19 + 40), \"group\");\n              }\n            }\n            else\n            {\n              sub_804D5F4(\"%s: no such %s\", *(const char **)(v19 + 36), \"user\");\n            }\n          }\n          if ( *(_BYTE *)(v19 + 20) != 1 )\n            recv(0, &unk_80DB8C0, 0x2B8u, 64);\nLABEL_81:\n          _exit(1);\n        }\n        if ( v10 )\n        {\n          close(*(_DWORD *)v19);\n          byte_80DB561 = 0;\n        }\n        sub_805D066((const sigset_t *)v26);\n        v13 = *(_DWORD *)(v19 + 44);\n        if ( *(_BYTE *)(v19 + 20) == 1 )\n          (*(void (__fastcall **)(int, unsigned int))(v13 + 8))(v13, v19);\n        else\n          (*(void (__fastcall **)(int, unsigned int))(v13 + 12))(v13, v19);\n        if ( v10 )\n          goto LABEL_81;\n        goto LABEL_61;\n      }\n      if ( *(_DWORD *)dword_80DBB7C != 4 )\n        sub_804D3A5((int)\"accept (for %s)\", *(const char **)(v19 + 8));\n    }\nLABEL_108:\n    v19 = *(_DWORD *)(v19 + 48);\n  }\n}\n"
    ],
    "sub_805E19A": [
        "0x805e19a",
        "const char *__usercall sub_805E19A@<eax>(_WORD *a1@<eax>)\n{\n  if ( (unsigned __int16)(*a1 - 1) > 0xFFFDu )\n    return \"[NONE SET]\";\n  sub_80AD6B6();\n  return (const char *)sub_80A9707();\n}\n"
    ],
    "sub_805E209": [
        "0x805e209",
        "char *__usercall sub_805E209@<eax>(char **a1@<eax>, const char *a2@<edx>)\n{\n  char *i; // ebx\n  int v5; // eax\n  char *v6; // esi\n  char **v7; // eax\n  char *v8; // edx\n\n  for ( i = a1[1]; i; i = (char *)*((_DWORD *)i + 1) )\n  {\n    v5 = strcmp(i + 8, a2);\n    if ( !v5 )\n      return i;\n    if ( v5 < 0 )\n      break;\n  }\n  v6 = (char *)sub_804DB2E(0x108u);\n  sub_804D67E(v6 + 8, a2);\n  v7 = a1;\n  if ( i )\n    v7 = (char **)i;\n  *((_DWORD *)v6 + 1) = i;\n  v8 = *v7;\n  *(_DWORD *)v6 = *v7;\n  if ( v8 )\n    *((_DWORD *)v8 + 1) = v6;\n  else\n    a1[1] = v6;\n  *v7 = v6;\n  return v6;\n}\n"
    ],
    "sub_805E26B": [
        "0x805e26b",
        "int __usercall sub_805E26B@<eax>(char **a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // ebx\n  unsigned int v4; // edx\n  char v5; // al\n  char *v6; // ebp\n  char *v7; // ebx\n  int v8; // edx\n  int v9; // ecx\n  char *v10; // esi\n  FILE *stream; // [esp+0h] [ebp-230h]\n  int v13; // [esp+4h] [ebp-22Ch]\n  char s2[16]; // [esp+10h] [ebp-220h] BYREF\n  char haystack[528]; // [esp+20h] [ebp-210h] BYREF\n\n  stream = (FILE *)sub_80B3D18(a3, \"r\");\n  v3 = 0;\n  if ( stream )\n  {\n    fgets_unlocked();\n    fgets_unlocked();\n    v13 = 2;\n    if ( !strstr(haystack, \"compressed\") )\n      v13 = strstr(haystack, \"bytes\") != 0;\n    while ( fgets_unlocked() )\n    {\n      v10 = (char *)sub_80B2E8C(v9, v8);\n      v6 = v10;\n      do\n      {\n        v4 = v6 - v10;\n        if ( v6 - v10 > 15 )\n          break;\n        v5 = *v6++;\n        if ( v5 == 58 )\n        {\n          qmemcpy(s2, v10, v4);\n          s2[v4] = 0;\n          goto LABEL_8;\n        }\n      }\n      while ( (unsigned __int8)*v6 > 0x20u );\n      s2[0] = 0;\n      v6 = haystack;\nLABEL_8:\n      v7 = sub_805E209(a1, s2);\n      memset(v7 + 156, 0, 0x6Cu);\n      sscanf(\n        v6,\n        (&off_80B78BC)[v13],\n        v7 + 172,\n        v7 + 156,\n        v7 + 188,\n        v7 + 196,\n        v7 + 236,\n        v7 + 232,\n        v7 + 208,\n        v7 + 204,\n        v7 + 180,\n        v7 + 164,\n        v7 + 192,\n        v7 + 200,\n        v7 + 252,\n        v7 + 216,\n        v7 + 248,\n        v7 + 212);\n      if ( v13 != 2 )\n      {\n        if ( !v13 )\n        {\n          *((_DWORD *)v7 + 43) = 0;\n          *((_DWORD *)v7 + 44) = 0;\n          *((_DWORD *)v7 + 45) = 0;\n          *((_DWORD *)v7 + 46) = 0;\n        }\n        *((_DWORD *)v7 + 51) = 0;\n        *((_DWORD *)v7 + 52) = 0;\n        *((_DWORD *)v7 + 53) = 0;\n      }\n      v7[153] = 1;\n      if ( a2 && !strcmp(a2, s2) )\n      {\n        v3 = 1;\n        goto LABEL_19;\n      }\n    }\n    v3 = 0;\nLABEL_19:\n    fclose(stream);\n  }\n  return v3;\n}\n"
    ],
    "sub_805E49D": [
        "0x805e49d",
        "int __usercall sub_805E49D@<eax>(int a1@<eax>)\n{\n  int v2; // ebp\n  char *v3; // eax\n  int v4; // edx\n  const char *v6; // [esp+0h] [ebp-34h]\n  char v7[16]; // [esp+4h] [ebp-30h] BYREF\n  int v8[4]; // [esp+14h] [ebp-20h] BYREF\n\n  v6 = (const char *)(a1 + 8);\n  v2 = sub_804DF99(0, 2, 2);\n  sub_804D67E(v7, (const char *)(a1 + 8));\n  if ( ioctl(v2, 0x8913u, v7) >= 0 )\n  {\n    *(_WORD *)(a1 + 26) = v8[0];\n    *(_DWORD *)(a1 + 28) = -1;\n    memset((void *)(a1 + 32), 0, 0x78u);\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x8927u, v7) >= 0 )\n    {\n      v4 = *(int *)((char *)&v8[1] + 2);\n      *(_DWORD *)(a1 + 120) = *(int *)((char *)v8 + 2);\n      *(_DWORD *)(a1 + 124) = v4;\n    }\n    *(_WORD *)(a1 + 24) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x891Du, v7) >= 0 )\n      *(_DWORD *)(a1 + 32) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x8921u, v7) >= 0 )\n      *(_DWORD *)(a1 + 36) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( !ioctl(v2, 0x8970u, v7) )\n      qmemcpy((void *)(a1 + 40), v8, 0x10u);\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x8942u, v7) >= 0 )\n      *(_DWORD *)(a1 + 28) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    LOWORD(v8[0]) = 2;\n    if ( !ioctl(v2, 0x8915u, v7) )\n    {\n      *(_BYTE *)(a1 + 152) = 1;\n      qmemcpy((void *)(a1 + 56), v8, 0x10u);\n      sub_804D67E(v7, (const char *)(a1 + 8));\n      if ( ioctl(v2, 0x8917u, v7) >= 0 )\n        qmemcpy((void *)(a1 + 72), v8, 0x10u);\n      sub_804D67E(v7, (const char *)(a1 + 8));\n      if ( ioctl(v2, 0x8919u, v7) >= 0 )\n        qmemcpy((void *)(a1 + 88), v8, 0x10u);\n      sub_804D67E(v7, (const char *)(a1 + 8));\n      if ( ioctl(v2, 0x891Bu, v7) >= 0 )\n        qmemcpy((void *)(a1 + 104), v8, 0x10u);\n    }\n    close(v2);\n    return 0;\n  }\n  else\n  {\n    close(v2);\n    v3 = \"Device not found\";\n    if ( *(_DWORD *)dword_80DBB7C != 19 )\n      v3 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D5F4(\"%s: error fetching interface information: %s\", v6, v3);\n    return -1;\n  }\n}\n"
    ],
    "sub_805E70D": [
        "0x805e70d",
        "int __usercall sub_805E70D@<eax>(__int64 a1@<edx:eax>, const char *a2@<ecx>)\n{\n  unsigned int v2; // edi\n  unsigned int v3; // esi\n  unsigned int v4; // ebx\n  const char *v5; // ebp\n  int v7; // [esp+0h] [ebp-14h]\n\n  v2 = HIDWORD(a1);\n  v3 = a1;\n  v7 = 4;\n  v4 = 0;\n  v5 = (const char *)&unk_80CCE7B;\n  do\n  {\n    if ( v2 || v3 > 0x3FF )\n    {\n      v4 = (10 * (v3 & 0x3FF)) >> 10;\n      v3 = __PAIR64__(v2, v3) >> 10;\n      v2 >>= 10;\n      v5 += 3;\n    }\n    --v7;\n  }\n  while ( v7 );\n  return printf(\"X bytes:%llu (%llu.%u %sB)%s\", a1, __PAIR64__(v2, v3), v4, v5, a2);\n}\n"
    ],
    "sub_805E767": [
        "0x805e767",
        "int __usercall sub_805E767@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  *(_WORD *)a2 = 32;\n  sub_804D76F((_BYTE *)(a2 + 2), a1, 20);\n  return 0;\n}\n"
    ],
    "sub_805E782": [
        "0x805e782",
        "const char **__usercall sub_805E782@<eax>(const char *a1@<eax>)\n{\n  const char ***i; // esi\n  const char **v3; // ebx\n\n  for ( i = (const char ***)off_80B78C8; ; ++i )\n  {\n    v3 = *i;\n    if ( !*i || !strcmp(*v3, a1) )\n      break;\n  }\n  return v3;\n}\n"
    ],
    "sub_805E7AB": [
        "0x805e7ab",
        "const char **__usercall sub_805E7AB@<eax>(const char *a1@<eax>)\n{\n  const char ***i; // esi\n  const char **v3; // ebx\n\n  for ( i = (const char ***)off_80B78A0; ; ++i )\n  {\n    v3 = *i;\n    if ( !*i || !strcmp(*v3, a1) )\n      break;\n  }\n  return v3;\n}\n"
    ],
    "sub_805E7D4": [
        "0x805e7d4",
        "char **__usercall sub_805E7D4@<eax>(char *a1@<eax>)\n{\n  char ***i; // ecx\n\n  for ( i = off_80B78A0; *i && (*i)[2] != a1; ++i )\n    ;\n  return *i;\n}\n"
    ],
    "sub_805E7EC": [
        "0x805e7ec",
        "int __usercall sub_805E7EC@<eax>(int a1@<eax>)\n{\n  char *v2; // edx\n  char ***i; // eax\n  char **v4; // esi\n  char ***j; // eax\n  char **v6; // edi\n  int (*v7)(void); // ecx\n  int k; // edx\n  const char *v9; // eax\n  const char *v10; // eax\n  const char *v11; // eax\n  int (*v12)(void); // ecx\n  const char *v13; // eax\n  const char *v14; // eax\n  int v15; // edi\n  const char *v16; // eax\n  unsigned int v17; // eax\n  const char *v18; // esi\n  unsigned __int16 *v19; // edi\n  int v20; // eax\n  int v21; // eax\n  int v22; // eax\n  FILE *stream; // [esp+0h] [ebp-B4h]\n  __int16 v25; // [esp+Ah] [ebp-AAh]\n  int v26; // [esp+10h] [ebp-A4h] BYREF\n  int v27; // [esp+14h] [ebp-A0h] BYREF\n  char v28; // [esp+18h] [ebp-9Ch] BYREF\n  char v29; // [esp+1Ch] [ebp-98h] BYREF\n  char v30[21]; // [esp+23h] [ebp-91h] BYREF\n  __int16 v31[14]; // [esp+38h] [ebp-7Ch] BYREF\n  char s[40]; // [esp+54h] [ebp-60h] BYREF\n  char v33[5]; // [esp+7Ch] [ebp-38h] BYREF\n  char v34[5]; // [esp+81h] [ebp-33h] BYREF\n  char v35[5]; // [esp+86h] [ebp-2Eh] BYREF\n  char v36[5]; // [esp+8Bh] [ebp-29h] BYREF\n  char v37[5]; // [esp+90h] [ebp-24h] BYREF\n  char v38[5]; // [esp+95h] [ebp-1Fh] BYREF\n  char v39[5]; // [esp+9Ah] [ebp-1Ah] BYREF\n  char v40[21]; // [esp+9Fh] [ebp-15h] BYREF\n\n  v2 = (char *)*(unsigned __int16 *)(a1 + 56);\n  for ( i = off_80B78C8; ; ++i )\n  {\n    v4 = *i;\n    if ( !*i )\n      break;\n    if ( v2 == v4[2] )\n      goto LABEL_9;\n  }\n  for ( j = off_80B78C8; ; ++j )\n  {\n    v4 = *j;\n    if ( !*j || !v4[2] )\n      break;\n  }\nLABEL_9:\n  v25 = *(_WORD *)(a1 + 24) & 0xFFFD;\n  v6 = sub_805E7D4((char *)*(__int16 *)(a1 + 24));\n  if ( !v6 )\n    v6 = sub_805E7D4((char *)0xFFFFFFFF);\n  printf(\"%-9s Link encap:%s  \", (const char *)(a1 + 8), v6[1]);\n  v7 = (int (*)(void))v6[4];\n  if ( v7 )\n  {\n    for ( k = 0; (int)v6[3] > k; ++k )\n    {\n      if ( *(_BYTE *)(a1 + 120 + k) )\n        goto LABEL_17;\n    }\n    if ( v6[7] )\n      goto LABEL_18;\nLABEL_17:\n    v9 = (const char *)v7();\n    printf(\"HWaddr %s  \", v9);\n  }\nLABEL_18:\n  if ( (*(_BYTE *)(a1 + 27) & 0x20) != 0 )\n  {\n    printf(\"Media:%s\", (&off_80B57E0)[*(unsigned __int8 *)(a1 + 52)]);\n    if ( (*(_BYTE *)(a1 + 27) & 0x40) != 0 )\n      printf(\"(auto)\");\n  }\n  sub_804DD98(10);\n  if ( *(_BYTE *)(a1 + 152) )\n  {\n    v10 = (const char *)((int (*)(void))v4[5])();\n    printf(\"          %s addr:%s \", *v4, v10);\n    if ( (*(_BYTE *)(a1 + 26) & 0x10) != 0 )\n    {\n      v11 = (const char *)((int (*)(void))v4[5])();\n      printf(\" P-t-P:%s \", v11);\n    }\n    v12 = (int (*)(void))v4[5];\n    if ( (*(_BYTE *)(a1 + 26) & 2) != 0 )\n    {\n      v13 = (const char *)v12();\n      printf(\" Bcast:%s \", v13);\n    }\n    v14 = (const char *)((int (__fastcall *)(int (*)(void), int))v4[5])(v12, 1);\n    printf(\" Mask:%s\\n\", v14);\n  }\n  stream = (FILE *)sub_80B3D37();\n  if ( stream )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          do\n          {\n            if ( fscanf(\n                   stream,\n                   \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                   v33,\n                   v34,\n                   v35,\n                   v36,\n                   v37,\n                   v38,\n                   v39,\n                   v40,\n                   &v29,\n                   &v26,\n                   &v27,\n                   &v28,\n                   v30) == -1 )\n            {\n              fclose(stream);\n              goto LABEL_43;\n            }\n          }\n          while ( strcmp(v30, (const char *)(a1 + 8)) );\n          sprintf(s, \"%s:%s:%s:%s:%s:%s:%s:%s\", v33, v34, v35, v36, v37, v38, v39, v40);\n          memset(v31, 0, sizeof(v31));\n          inet_pton(10, s, &v31[4]);\n          v31[0] = 10;\n          v15 = v26;\n          v16 = sub_805E19A(v31);\n          printf(\"          inet6 addr: %s/%d\", v16, v15);\n          printf(\" Scope:\");\n          v17 = v27 & 0xF0;\n          if ( v17 != 32 )\n            break;\n          puts(\"Link\");\n        }\n        if ( v17 <= 0x20 )\n          break;\n        if ( v17 == 64 )\n        {\n          puts(\"Site\");\n        }\n        else if ( v17 == 128 )\n        {\n          puts(\"Compat\");\n        }\n        else\n        {\nLABEL_41:\n          puts(\"Unknown\");\n        }\n      }\n      if ( (v27 & 0xF0) != 0 )\n      {\n        if ( v17 != 16 )\n          goto LABEL_41;\n        puts(\"Host\");\n      }\n      else\n      {\n        puts(\"Global\");\n      }\n    }\n  }\nLABEL_43:\n  printf(\"          \");\n  if ( *(_WORD *)(a1 + 26) )\n  {\n    v18 = \"UP\";\n    v19 = (unsigned __int16 *)&unk_80B851E;\n    do\n    {\n      if ( (*v19 & *(__int16 *)(a1 + 26)) != 0 )\n        printf(\"%s \", v18);\n      ++v19;\n      v18 += strlen(v18) + 1;\n    }\n    while ( *v18 );\n  }\n  else\n  {\n    printf(\"[NO FLAGS] \");\n  }\n  v20 = *(_DWORD *)(a1 + 32);\n  if ( !v20 )\n    v20 = 1;\n  printf(\" MTU:%d  Metric:%d\", *(_DWORD *)(a1 + 36), v20);\n  sub_804DD98(10);\n  if ( *(_BYTE *)(a1 + 153) )\n  {\n    printf(\"          \");\n    printf(\n      \"RX packets:%llu errors:%lu dropped:%lu overruns:%lu frame:%lu\\n\",\n      *(_QWORD *)(a1 + 156),\n      *(_DWORD *)(a1 + 188),\n      *(_DWORD *)(a1 + 196),\n      *(_DWORD *)(a1 + 236),\n      *(_DWORD *)(a1 + 232));\n    if ( v25 == 257 )\n      printf(\"             compressed:%lu\\n\", *(_DWORD *)(a1 + 208));\n    printf(\"          \");\n    printf(\n      \"TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\\n\",\n      *(_QWORD *)(a1 + 164),\n      *(_DWORD *)(a1 + 192),\n      *(_DWORD *)(a1 + 200),\n      *(_DWORD *)(a1 + 252),\n      *(_DWORD *)(a1 + 248));\n    printf(\"          collisions:%lu \", *(_DWORD *)(a1 + 216));\n    if ( v25 == 257 )\n      printf(\"compressed:%lu \", *(_DWORD *)(a1 + 212));\n    if ( *(_DWORD *)(a1 + 28) != -1 )\n      printf(\"txqueuelen:%d \", *(_DWORD *)(a1 + 28));\n    printf(\"\\n          R\");\n    sub_805E70D(*(_QWORD *)(a1 + 172), \"  T\");\n    sub_805E70D(*(_QWORD *)(a1 + 180), \"\\n\");\n  }\n  if ( *(_BYTE *)(a1 + 50) || *(_DWORD *)(a1 + 40) || (*(_DWORD *)(a1 + 48) & 0xFF00FFFF) != 0 )\n  {\n    printf(\"          \");\n    v21 = *(unsigned __int8 *)(a1 + 50);\n    if ( (_BYTE)v21 )\n      printf(\"Interrupt:%d \", v21);\n    if ( *(_WORD *)(a1 + 48) > 0xFFu )\n      printf(\"Base address:0x%lx \", *(unsigned __int16 *)(a1 + 48));\n    v22 = *(_DWORD *)(a1 + 40);\n    if ( v22 )\n      printf(\"Memory:%lx-%lx \", v22, *(_DWORD *)(a1 + 44));\n    if ( *(_BYTE *)(a1 + 51) )\n      printf(\"DMA chan:%x \", *(unsigned __int8 *)(a1 + 51));\n    sub_804DD98(10);\n  }\n  return sub_804DD98(10);\n}\n"
    ],
    "sub_805ED04": [
        "0x805ed04",
        "unsigned int __usercall sub_805ED04@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // edx\n  int v4; // esi\n  int v5; // ebp\n  size_t v6; // edi\n  const char *v7; // edi\n  char *i; // edi\n  int v9; // esi\n  char *v11; // ebx\n  size_t v12; // [esp+0h] [ebp-24h]\n  char *v13[2]; // [esp+4h] [ebp-20h] BYREF\n  int v14; // [esp+Ch] [ebp-18h] BYREF\n  void *ptr; // [esp+10h] [ebp-14h]\n\n  v13[0] = 0;\n  v13[1] = 0;\n  v3 = 0;\n  if ( a1 != (const char *)1 )\n    v3 = a1;\n  v4 = sub_805E26B(v13, v3, a2);\n  if ( !v4 )\n  {\n    ptr = 0;\n    v5 = sub_804DF99(0, 2, 2);\n    v6 = 960;\n    do\n    {\n      v12 = v6;\n      v14 = v6;\n      ptr = sub_804DB13(ptr, v6);\n      sub_804E0BE(v5, 0x8912u, (int)&v14, \"SIOCGIFCONF\");\n      v6 += 320;\n    }\n    while ( v12 == v14 );\n    v7 = (const char *)ptr;\n    while ( v4 < v14 )\n    {\n      sub_805E209(v13, &v7[v4]);\n      v4 += 32;\n    }\n    close(v5);\n    free(ptr);\n  }\n  if ( (unsigned int)a1 > 1 )\n  {\n    v11 = sub_805E209(v13, a1);\n    v9 = sub_805E49D((int)v11);\n    if ( v9 >= 0 )\n      sub_805E7EC((int)v11);\n    return (unsigned int)v9 >> 31;\n  }\n  else\n  {\n    for ( i = v13[0]; i; i = *(char **)i )\n    {\n      v9 = sub_805E49D((int)i);\n      if ( v9 < 0 )\n        return (unsigned int)v9 >> 31;\n      if ( (i[26] & 1) != 0 || a1 )\n        sub_805E7EC((int)i);\n    }\n    return 0;\n  }\n}\n"
    ],
    "sub_805EE37": [
        "0x805ee37",
        "int __cdecl sub_805EE37(int a1, int a2)\n{\n  sub_8064315();\n  return sub_80653F1();\n}\n"
    ],
    "sub_805EE45": [
        "0x805ee45",
        "int __cdecl sub_805EE45(int a1, int a2)\n{\n  sub_8064315();\n  return sub_80659A2();\n}\n"
    ],
    "sub_805EE53": [
        "0x805ee53",
        "int __cdecl sub_805EE53(int a1, int a2)\n{\n  sub_8064315();\n  return sub_806780A();\n}\n"
    ],
    "sub_805EE61": [
        "0x805ee61",
        "int __cdecl sub_805EE61(int a1, int a2)\n{\n  sub_8064315();\n  return sub_8067E6D();\n}\n"
    ],
    "sub_805EE6F": [
        "0x805ee6f",
        "int __cdecl sub_805EE6F(int a1, int a2)\n{\n  sub_8064315();\n  return sub_8068949();\n}\n"
    ],
    "sub_805EE7D": [
        "0x805ee7d",
        "int __cdecl sub_805EE7D(int a1, int a2)\n{\n  sub_8064315();\n  return sub_80664E9();\n}\n"
    ],
    "sub_805EE8B": [
        "0x805ee8b",
        "int __cdecl sub_805EE8B(int a1, int a2)\n{\n  const char *v2; // edx\n  int v3; // eax\n\n  v2 = *(const char **)sub_8064315();\n  v3 = -1;\n  if ( v2 )\n    v3 = sub_804D254(\"address\", v2);\n  return funcs_805EEBA[v3]();\n}\n"
    ],
    "sub_805EEBC": [
        "0x805eebc",
        "int __usercall sub_805EEBC@<eax>(int *a1@<eax>, const char *a2@<edx>)\n{\n  _DWORD *v4; // edi\n  int v5; // edx\n  int v6; // ecx\n  _BYTE *v7; // ebx\n  struct ether_addr *v8; // ebp\n  _BYTE *v9; // eax\n  struct ether_addr *v10; // eax\n  int result; // eax\n\n  if ( strlen(a2) > 0xF )\n    sub_804D5E0(\"interface name '%s' too long\", a2);\n  v4 = sub_804DB2E(0x10u);\n  v4[2] = sub_804DB46(a2);\n  v7 = (_BYTE *)sub_80B2E8C(v6, v5);\n  v8 = (struct ether_addr *)sub_804DAFA(6u);\n  v9 = sub_804D210(v7, \"mac=\");\n  v10 = ether_aton_r(&v7[v9 != 0 ? 4 : 0], v8);\n  v4[3] = v10;\n  if ( !v10 )\n    sub_804D5E0(\"can't parse %s\", v7);\n  result = *a1;\n  *v4 = *a1;\n  if ( result )\n    *(_DWORD *)(result + 4) = v4;\n  *a1 = (int)v4;\n  return result;\n}\n"
    ],
    "sub_805EF4A": [
        "0x805ef4a",
        "int __cdecl sub_805EF4A(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // ebp\n  int v4; // ecx\n  int v5; // esi\n  _DWORD *v6; // edi\n  char *v7; // edx\n  const void *v8; // eax\n  int v9; // eax\n  _DWORD *v10; // eax\n  char *v12; // [esp+8h] [ebp-44h]\n  char *v13; // [esp+8h] [ebp-44h]\n  _DWORD *v14; // [esp+Ch] [ebp-40h] BYREF\n  char *src; // [esp+10h] [ebp-3Ch] BYREF\n  const char *v16; // [esp+14h] [ebp-38h]\n  char v17[48]; // [esp+1Ch] [ebp-30h] BYREF\n\n  v14 = 0;\n  src = \"/etc/mactab\";\n  if ( (sub_80ABEAC(a2, \"sc:\", &src) & 1) != 0 )\n  {\n    openlog(ident, 0, 128);\n    byte_80DB561 |= 2u;\n  }\n  v2 = a2 + 4 * optind;\n  if ( *(_DWORD *)v2 )\n  {\n    do\n    {\n      if ( !*(_DWORD *)(v2 + 4) )\n        sub_804CDC2();\n      sub_805EEBC((int *)&v14, *(const char **)v2);\n      v2 += 8;\n    }\n    while ( *(_DWORD *)v2 );\n  }\n  else\n  {\n    sub_80B052C();\n    while ( sub_80B0560(\"# \\t\") )\n      sub_805EEBC((int *)&v14, v16);\n    sub_80B0536();\n  }\n  v3 = sub_804DF99(0, 2, 2);\n  v5 = sub_80B0511(v4, sub_80B3D45);\nLABEL_13:\n  while ( v14 && sub_80B0560((char *)&unk_80CD033) )\n  {\n    if ( *(int *)(v5 + 24) > 2 )\n    {\n      memset(v17, 0, 0x20u);\n      sub_804D67E(v17, v16);\n      ioctl(v3, 0x8927u, v17);\n      v6 = v14;\n      v7 = &v17[18];\n      while ( v6 )\n      {\n        v8 = (const void *)v6[3];\n        if ( !v8 || (v12 = v7, v9 = memcmp(v8, v7, 6u), v7 = v12, !v9) )\n        {\n          v13 = (char *)v6[2];\n          if ( strcmp(v17, v13) )\n          {\n            strcpy(&v17[16], v13);\n            sub_804E029(v3, 0x8923u, (int)v17, \"can't change ifname %s to %s\", v17, (const char *)v6[2]);\n          }\n          v10 = (_DWORD *)v6[1];\n          if ( v10 )\n            *v10 = *v6;\n          else\n            v14 = (_DWORD *)*v6;\n          if ( *v6 )\n            *(_DWORD *)(*v6 + 4) = v10;\n          goto LABEL_13;\n        }\n        v6 = (_DWORD *)*v6;\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_805F114": [
        "0x805f114",
        "int __usercall sub_805F114@<eax>(const char *a1@<eax>)\n{\n  int v1; // eax\n  int v2; // edx\n  char v3; // al\n  bool v4; // zf\n  const char *v5; // ebp\n  int v6; // edi\n  const char *v7; // ebx\n  const char *v8; // ebx\n  const char *v10; // [esp+0h] [ebp-58h]\n  int v12; // [esp+8h] [ebp-50h]\n  int v13; // [esp+Ch] [ebp-4Ch] BYREF\n  int v14; // [esp+10h] [ebp-48h] BYREF\n  int v15; // [esp+14h] [ebp-44h] BYREF\n  int v16; // [esp+18h] [ebp-40h] BYREF\n  int v17; // [esp+1Ch] [ebp-3Ch] BYREF\n  int v18; // [esp+20h] [ebp-38h] BYREF\n  int v19; // [esp+24h] [ebp-34h] BYREF\n  char v20[48]; // [esp+28h] [ebp-30h] BYREF\n\n  if ( !*a1 )\n    return 0;\n  v19 = 0;\n  v1 = sscanf(a1, \"%*p: %lX %lX %lX %X %X %lu %n\", &v13, &v14, &v15, &v17, &v18, &v16, &v19);\n  v2 = 1;\n  if ( v1 > 5 )\n  {\n    v3 = *(_BYTE *)dword_80DBB80;\n    if ( (*(_BYTE *)dword_80DBB80 & 3) == 3\n      || (v18 != 1 || (v15 & 0x10000) == 0 ? (v4 = (v3 & 1) == 0) : (v4 = (v3 & 2) == 0), !v4) )\n    {\n      v10 = \"unix\";\n      if ( v14 )\n        v10 = \"??\";\n      v5 = \"UNKNOWN\";\n      if ( (unsigned int)(v17 - 1) <= 4 )\n        v5 = off_80B78EC[v17 - 1];\n      v6 = v15;\n      v7 = \"UNKNOWN\";\n      switch ( v18 )\n      {\n        case 0:\n          v7 = \"FREE\";\n          break;\n        case 1:\n          v7 = \"LISTENING\";\n          if ( (v15 & 0x10000) == 0 )\n            v7 = &data;\n          break;\n        case 2:\n          v7 = \"DISCONNECTING\" + 3;\n          break;\n        case 3:\n          v7 = \"CONNECTED\";\n          break;\n        case 4:\n          v7 = \"DISCONNECTING\";\n          break;\n        default:\n          break;\n      }\n      v12 = v15 & 0x10000;\n      strcpy(v20, \"[ \");\n      if ( v12 )\n        strcat(v20, \"ACC \");\n      if ( (v6 & 0x20000) != 0 )\n        strcat(v20, \"W \");\n      if ( (v6 & 0x40000) != 0 )\n        strcat(v20, \"N \");\n      strcat(v20, \"]\");\n      printf(\"%-5s %-6lu %-11s %-10s %-13s %6lu \", v10, v13, v20, v5, v7, v16);\n      v8 = &a1[v19];\n      sub_80A9BE3();\n      while ( *v8 )\n      {\n        ++v8;\n        sub_80B0B92();\n      }\n      sub_804DD98(10);\n    }\n    return 0;\n  }\n  return v2;\n}\n"
    ],
    "sub_805F2C7": [
        "0x805f2c7",
        "int __usercall sub_805F2C7@<eax>(const char *a1@<eax>, _WORD *a2@<edx>)\n{\n  int result; // eax\n  char v4[18]; // [esp+0h] [ebp-4Ch] BYREF\n  char buf[58]; // [esp+12h] [ebp-3Ah] BYREF\n\n  sscanf(a1, \"%08X%08X%08X%08X\", v4, &v4[4], &v4[8], &v4[12]);\n  inet_ntop(10, v4, buf, 0x2Eu);\n  result = inet_pton(10, buf, a2 + 4);\n  *a2 = 10;\n  return result;\n}\n"
    ],
    "sub_805F316": [
        "0x805f316",
        "char *__usercall sub_805F316@<eax>(char *proto@<ecx>, unsigned __int16 a2@<dx>, int a3@<ebx>, int a4)\n{\n  char *v6; // ebx\n  unsigned __int16 v7; // dx\n  const char *s_name; // eax\n  struct servent *v9; // eax\n  char *v11; // [esp+0h] [ebp-14h]\n\n  if ( a4 || (v6 = (char *)sub_80B46A2(a3)) == 0 )\n    v6 = (char *)sub_80B46B6();\n  LOBYTE(v7) = HIBYTE(a2);\n  HIBYTE(v7) = a2;\n  s_name = \"   *\" + 3;\n  if ( v7 )\n  {\n    if ( a4 || (v9 = getservbyport(v7, proto)) == 0 )\n      s_name = sub_804D70F(a2);\n    else\n      s_name = v9->s_name;\n  }\n  v11 = sub_804DDBF((char *)\"%s:%s\", v6, s_name);\n  free(v6);\n  return v11;\n}\n"
    ],
    "sub_805F391": [
        "0x805f391",
        "void __usercall sub_805F391(char *proto@<ecx>, _DWORD *a2@<eax>, const char *a3@<edx>, void *ptr)\n{\n  char v4; // bp\n  bool v5; // zf\n  char *v9; // ebp\n  char *v10; // [esp+0h] [ebp-14h]\n\n  v4 = *(_BYTE *)dword_80DBB80;\n  if ( ptr )\n    v5 = (v4 & 1) == 0;\n  else\n    v5 = (v4 & 2) == 0;\n  if ( !v5 )\n  {\n    v9 = sub_805F316(proto, *a2, (int)a2, v4 & 4);\n    v10 = sub_805F316(proto, a2[1], (int)a2, *(_BYTE *)dword_80DBB80 & 4);\n    printf(\"%s   %6lu %6lu %-23s %-23s %-12s\", proto, a2[18], a2[19], v9, v10, a3);\n    sub_804DD98(10);\n    free(v9);\n    free(v10);\n  }\n}\n"
    ],
    "sub_805F434": [
        "0x805f434",
        "int __fastcall sub_805F434(int a1, int a2)\n{\n  int v3; // [esp+0h] [ebp-14h]\n\n  if ( sub_80B3D76(a2) )\n    sub_80AB345();\n  return v3;\n}\n"
    ],
    "sub_805F493": [
        "0x805f493",
        "int __usercall sub_805F493@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  char s[33]; // [esp+2h] [ebp-4Eh] BYREF\n  char v5[45]; // [esp+23h] [ebp-2Dh] BYREF\n\n  if ( sscanf(\n         a2,\n         \"%*d: %32[0-9A-Fa-f]:%X %32[0-9A-Fa-f]:%X %X %lX:%lX %*X:%*X %*X %d %*d %lu \",\n         s,\n         a1,\n         v5,\n         a1 + 4,\n         a1 + 8,\n         a1 + 76,\n         a1 + 72,\n         a1 + 12,\n         a1 + 80) <= 8 )\n    return 1;\n  if ( strlen(s) <= 8 )\n  {\n    sscanf(s, \"%X\", a1 + 20);\n    *(_WORD *)(a1 + 16) = 2;\n    sscanf(v5, \"%X\", a1 + 48);\n    *(_WORD *)(a1 + 44) = 2;\n  }\n  else\n  {\n    sub_805F2C7(s, (_WORD *)(a1 + 16));\n    sub_805F2C7(v5, (_WORD *)(a1 + 44));\n  }\n  return 0;\n}\n"
    ],
    "sub_805F530": [
        "0x805f530",
        "int __usercall sub_805F530@<eax>(const char *a1@<eax>)\n{\n  int v1; // ebx\n  bool v2; // zf\n  _BOOL4 v3; // ecx\n  const char *v4; // eax\n  void *ptr; // [esp+0h] [ebp-5Ch]\n  _DWORD v7[11]; // [esp+4h] [ebp-58h] BYREF\n  int v8; // [esp+30h] [ebp-2Ch]\n  int v9; // [esp+34h] [ebp-28h]\n  int v10; // [esp+38h] [ebp-24h]\n  int v11; // [esp+3Ch] [ebp-20h]\n  int v12; // [esp+40h] [ebp-1Ch]\n  int v13; // [esp+44h] [ebp-18h]\n\n  v1 = 1;\n  if ( !sub_805F493((int)v7, a1) )\n  {\n    v1 = 0;\n    if ( (_WORD)v8 == 10 )\n    {\n      v2 = (v13 | v12 | v11 | v10) == 0;\n    }\n    else\n    {\n      v3 = 0;\n      if ( (_WORD)v8 != 2 )\n      {\nLABEL_7:\n        ptr = (void *)v3;\n        v4 = sub_804D70F(v7[2]);\n        sub_805F391(\"raw\", v7, v4, ptr);\n        return v1;\n      }\n      v2 = v9 == 0;\n    }\n    v3 = !v2;\n    goto LABEL_7;\n  }\n  return v1;\n}\n"
    ],
    "sub_805F5A1": [
        "0x805f5a1",
        "int __usercall sub_805F5A1@<eax>(const char *a1@<eax>)\n{\n  int v1; // esi\n  const char *v2; // edx\n  bool v3; // zf\n  _BOOL4 v4; // eax\n  int v6[24]; // [esp+0h] [ebp-60h] BYREF\n\n  memset(v6, 0, 0x54u);\n  v1 = 1;\n  if ( !sub_805F493((int)v6, a1) )\n  {\n    v1 = 0;\n    v2 = \"ESTABLISHED\";\n    if ( v6[2] != 1 )\n    {\n      v2 = &data;\n      if ( v6[2] != 7 )\n        v2 = \"UNKNOWN\";\n    }\n    if ( LOWORD(v6[11]) == 10 )\n    {\n      v3 = (v6[16] | v6[15] | v6[14] | v6[13]) == 0;\n    }\n    else\n    {\n      v4 = 0;\n      if ( LOWORD(v6[11]) != 2 )\n      {\nLABEL_10:\n        sub_805F391(\"udp\", v6, v2, (void *)v4);\n        return v1;\n      }\n      v3 = v6[12] == 0;\n    }\n    v4 = !v3;\n    goto LABEL_10;\n  }\n  return v1;\n}\n"
    ],
    "sub_805F62B": [
        "0x805f62b",
        "int __usercall sub_805F62B@<eax>(const char *a1@<eax>)\n{\n  int v1; // esi\n  int v3[24]; // [esp+0h] [ebp-60h] BYREF\n\n  memset(v3, 0, 0x54u);\n  v1 = 1;\n  if ( !sub_805F493((int)v3, a1) )\n  {\n    v1 = 0;\n    sub_805F391(\"tcp\", v3, (const char *)*(&off_80B59C0 + v3[2]), (void *)v3[1]);\n  }\n  return v1;\n}\n"
    ],
    "sub_805F677": [
        "0x805f677",
        "int __cdecl sub_805F677(int a1, int a2)\n{\n  _BYTE *v2; // ebx\n  __int16 v3; // ax\n  int v4; // ecx\n  int v5; // eax\n  int v6; // ecx\n  int v7; // ecx\n  int v8; // ecx\n  int v9; // ecx\n  int v11; // [esp-4h] [ebp-8h]\n\n  v2 = sub_804DB2E(1u);\n  dword_80DBB80 = (int)v2;\n  *v2 = -15;\n  v3 = sub_80ABEAC(a2, \"laentuwxr\");\n  v4 = v11;\n  if ( (v3 & 1) != 0 )\n    *v2 = *v2 & 0xFC | 2;\n  if ( (v3 & 2) != 0 )\n    *v2 |= 3u;\n  if ( (v3 & 8) != 0 )\n    *v2 |= 4u;\n  LOBYTE(v4) = *v2;\n  if ( (v3 & 0x100) != 0 )\n  {\n    sub_8061007();\n  }\n  else\n  {\n    v5 = v3 & 0xF0;\n    if ( v5 )\n    {\n      v4 &= 0xFu;\n      *v2 = v4 | v5;\n    }\n    if ( (*v2 & 0x70) != 0 )\n    {\n      printf(\"Active Internet connections \");\n      if ( (*v2 & 3) == 3 )\n      {\n        printf(\"(servers and established)\");\n      }\n      else if ( (*v2 & 2) != 0 )\n      {\n        printf(\"(only servers)\");\n      }\n      else\n      {\n        printf(\"(w/o servers)\");\n      }\n      printf(\"\\nProto Recv-Q Send-Q %-23s %-23s State       %s\\n\", \"Local Address\", \"Foreign Address\", &data);\n    }\n    if ( (*v2 & 0x10) != 0 )\n    {\n      sub_805F434(v4, (int)sub_805F62B);\n      sub_805F434(v6, (int)sub_805F62B);\n    }\n    if ( (*v2 & 0x20) != 0 )\n    {\n      sub_805F434(v4, (int)sub_805F5A1);\n      sub_805F434(v7, (int)sub_805F5A1);\n    }\n    if ( (*v2 & 0x40) != 0 )\n    {\n      sub_805F434(v4, (int)sub_805F530);\n      sub_805F434(v8, (int)sub_805F530);\n    }\n    if ( (char)*v2 < 0 )\n    {\n      printf(\"Active UNIX domain sockets \");\n      if ( (*v2 & 3) == 3 )\n      {\n        printf(\"(servers and established)\");\n      }\n      else if ( (*v2 & 2) != 0 )\n      {\n        printf(\"(only servers)\");\n      }\n      else\n      {\n        printf(\"(w/o servers)\");\n      }\n      printf(\"\\nProto RefCnt Flags       Type       State         I-Node %sPath\\n\", &data);\n      sub_805F434(v9, (int)sub_805F114);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_805F80C": [
        "0x805f80c",
        "int __usercall sub_805F80C@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  time_t v4; // ebx\n  int v5; // ebx\n  int result; // eax\n\n  v4 = (*(&unk_80DB780 + 1))++;\n  unk_80DB790 = sub_80B4733(v4, 133121);\n  v5 = unk_80DB790 + 520 * v4;\n  *(_DWORD *)v5 = a2;\n  result = __res_mkquery(0, a2, 1, a1, 0, 0, 0, (u_char *)(v5 + 8), 512);\n  *(_DWORD *)(v5 + 4) = result;\n  return result;\n}\n"
    ],
    "sub_805F865": [
        "0x805f865",
        "int __usercall sub_805F865@<eax>(int a1@<eax>)\n{\n  char *v2; // ebx\n  char *v3; // ebx\n  int v4; // ecx\n  int result; // eax\n\n  v2 = MEMORY[0x80DB788]++;\n  unk_80DB78C = (char *)sub_80B4733(v2, 4099);\n  v3 = &unk_80DB78C[16 * (_DWORD)v2];\n  *(_DWORD *)v3 = a1;\n  result = sub_80B45BD(v4, qword_80DB778);\n  *((_DWORD *)v3 + 1) = result;\n  return result;\n}\n"
    ],
    "sub_805F8A7": [
        "0x805f8a7",
        "int __usercall sub_805F8A7@<eax>(const char **a1@<eax>)\n{\n  unsigned int i; // ebx\n  int v3; // eax\n  int v4; // esi\n  const char *v5; // eax\n  const char *v6; // eax\n  char *v7; // ebx\n  unsigned int v8; // edi\n  u_char *v9; // edx\n  int v10; // eax\n  unsigned __int8 v11; // bl\n  int v12; // eax\n  ns_rr *v13; // ebx\n  ns_rr *v14; // eax\n  u_int v15; // edi\n  u_char v16; // dl\n  const u_char *rdata; // ebx\n  int v18; // edi\n  const u_char *v19; // ebx\n  int v20; // edi\n  const u_char *v21; // ebx\n  u_long v22; // eax\n  u_long v23; // eax\n  u_long v24; // eax\n  u_long v25; // eax\n  u_long v26; // eax\n  int v28; // [esp+0h] [ebp-ABCh]\n  u_char *v29; // [esp+0h] [ebp-ABCh]\n  const char *v30; // [esp+4h] [ebp-AB8h]\n  int v31; // [esp+8h] [ebp-AB4h]\n  int v32; // [esp+Ch] [ebp-AB0h]\n  int v33; // [esp+10h] [ebp-AACh]\n  int v34; // [esp+14h] [ebp-AA8h]\n  int v35; // [esp+18h] [ebp-AA4h]\n  int v36; // [esp+1Ch] [ebp-AA0h]\n  unsigned int v37; // [esp+20h] [ebp-A9Ch]\n  unsigned int v38; // [esp+24h] [ebp-A98h]\n  char *ptr; // [esp+28h] [ebp-A94h]\n  struct pollfd fd; // [esp+2Ch] [ebp-A90h] BYREF\n  char v41[46]; // [esp+36h] [ebp-A86h] BYREF\n  ns_msg v42; // [esp+64h] [ebp-A58h] BYREF\n  u_char buf[3]; // [esp+97h] [ebp-A25h] BYREF\n  char v44; // [esp+9Ah] [ebp-A22h]\n  char v45[1025]; // [esp+297h] [ebp-825h] BYREF\n  ns_rr v46; // [esp+698h] [ebp-424h] BYREF\n\n  v37 = 1000 * unk_80DB780;\n  fd.events = 1;\n  fd.fd = sub_80B45D3(2);\n  sub_804DFB3(*(_DWORD *)ptr, (struct sockaddr *)(ptr + 4), fd.fd);\n  free(ptr);\n  sub_80B42C3(*(_DWORD *)a1[1], (struct sockaddr *)(a1[1] + 4));\n  sub_804D61C();\n  v38 = v37 / *(&qword_80DB778 + 1);\n  v34 = sub_804EC14();\n  v31 = v34;\n  v33 = 0;\nLABEL_2:\n  for ( i = 0; ; ++i )\n  {\n    if ( *(&unk_80DB780 + 1) <= i )\n    {\n      v36 = 2 * *(&unk_80DB780 + 1);\n      v28 = v31;\n      while ( 1 )\n      {\n        if ( poll(&fd, 1u, v38 + v31 - v28) > 0 )\n        {\n          v4 = read(fd.fd, buf, 0x200u);\n          if ( v4 >= 0 )\n          {\n            v5 = a1[3];\n            a1[3] = v5 + 1;\n            if ( !v5 )\n            {\n              printf(\"Server:\\t\\t%s\\n\", *a1);\n              sub_80B46AC();\n              v6 = (const char *)sub_80A9707();\n              printf(\"Address:\\t%s\\n\\n\", v6);\n            }\n            if ( v4 > 3 )\n            {\n              v7 = (char *)(unk_80DB790 + 8);\n              v8 = 0;\n              v9 = buf;\n              while ( 1 )\n              {\n                v35 = 520 * v8;\n                v29 = v9;\n                v10 = memcmp(v9, v7, 2u);\n                v9 = v29;\n                if ( !v10 )\n                  break;\n                ++v8;\n                v7 += 520;\n                if ( v8 >= *(&unk_80DB780 + 1) )\n                  goto LABEL_12;\n              }\n              if ( *((_DWORD *)v7 - 1) )\n              {\n                v11 = v44 & 0xF;\n                if ( (v44 & 0xF) != 2 || (++a1[2], !v36) )\n                {\n                  *(_DWORD *)(unk_80DB790 + 520 * v8 + 4) = 0;\n                  v12 = sub_804EC14();\n                  v28 = v12;\n                  if ( (dword_80DBB9C & 1) != 0 )\n                    printf(\"Query #%d completed in %ums:\\n\", v8, v12 - v34);\n                  if ( v11 )\n                  {\n                    printf(\"** server can't find %s: %s\\n\", *(const char **)(unk_80DB790 + 520 * v8), off_80B5A00[v11]);\n                    goto LABEL_84;\n                  }\n                  if ( (buf[2] & 4) == 0 )\n                    printf(\"Non-authoritative answer:\\n\");\n                  v32 = __ns_initparse(buf, v4, &v42);\n                  if ( v32 )\n                  {\nLABEL_83:\n                    printf(\"*** Can't find %s: Parse error\\n\", *(const char **)(unk_80DB790 + v35));\nLABEL_84:\n                    sub_804DD98(10);\n                    if ( *(&unk_80DB780 + 1) <= (unsigned int)++v33 )\n                      goto LABEL_88;\n                    goto LABEL_85;\n                  }\n                  v30 = 0;\n                  while ( 2 )\n                  {\n                    if ( v32 >= v42._counts[1] )\n                      goto LABEL_84;\n                    v13 = &v46;\n                    if ( __ns_parserr(&v42, ns_s_an, v32, &v46) )\n                      goto LABEL_83;\n                    if ( v46.type == 6 )\n                    {\n                      if ( v46.rdlength <= 0x13u )\n                        goto LABEL_83;\n                      if ( !v46.name[0] )\n                        v13 = (ns_rr *)(\"<<...\" + 4);\n                      printf(\"%s\\n\", v13->name);\n                      rdata = v46.rdata;\n                      v18 = __ns_name_uncompress(v42._msg, v42._eom, v46.rdata, v45, 0x401u);\n                      if ( v18 < 0 )\n                        goto LABEL_83;\n                      printf(\"\\torigin = %s\\n\", v45);\n                      v19 = &rdata[v18];\n                      v20 = __ns_name_uncompress(v42._msg, v42._eom, v19, v45, 0x401u);\n                      if ( v20 < 0 )\n                        goto LABEL_83;\n                      printf(\"\\tmail addr = %s\\n\", v45);\n                      v21 = &v19[v20];\n                      v22 = __ns_get32(v21);\n                      printf(\"\\tserial = %lu\\n\", v22);\n                      v23 = __ns_get32(v21 + 4);\n                      printf(\"\\trefresh = %lu\\n\", v23);\n                      v24 = __ns_get32(v21 + 8);\n                      printf(\"\\tretry = %lu\\n\", v24);\n                      v25 = __ns_get32(v21 + 12);\n                      printf(\"\\texpire = %lu\\n\", v25);\n                      v26 = __ns_get32(v21 + 16);\n                      printf(\"\\tminimum = %lu\\n\", v26);\n                      goto LABEL_82;\n                    }\n                    if ( v46.type > 6u )\n                    {\n                      if ( v46.type == 15 )\n                      {\n                        if ( v46.rdlength <= 1u )\n                        {\n                          printf(\"MX record too short\\n\");\n                          goto LABEL_83;\n                        }\n                        v15 = __ns_get16(v46.rdata);\n                        if ( __ns_name_uncompress(v42._msg, v42._eom, v46.rdata + 2, v45, 0x401u) < 0 )\n                          goto LABEL_83;\n                        if ( !v46.name[0] )\n                          v13 = (ns_rr *)(\"<<...\" + 4);\n                        printf(\"%s\\tmail exchanger = %d %s\\n\", v13->name, v15, v45);\n                        goto LABEL_82;\n                      }\n                      if ( v46.type > 0xFu )\n                      {\n                        if ( v46.type == 16 )\n                        {\n                          if ( !v46.rdlength )\n                            goto LABEL_83;\n                          v16 = *v46.rdata;\n                          if ( *v46.rdata )\n                          {\n                            memset(v45, 0, sizeof(v45));\n                            qmemcpy(v45, v46.rdata + 1, v16);\n                            if ( !v46.name[0] )\n                              v13 = (ns_rr *)(\"<<...\" + 4);\n                            printf(\"%s\\ttext = \\\"%s\\\"\\n\", v13, v45);\n                          }\n                          goto LABEL_82;\n                        }\n                        if ( v46.type != 28 )\n                        {\nLABEL_82:\n                          ++v32;\n                          continue;\n                        }\n                        if ( v46.rdlength != 16 )\n                          goto LABEL_83;\n                        inet_ntop(10, v46.rdata, v41, 0x2Eu);\nLABEL_51:\n                        if ( !v46.name[0] )\n                          v13 = (ns_rr *)(\"<<...\" + 4);\n                        printf(\"Name:\\t%s\\nAddress: %s\\n\", v13, v41);\n                        goto LABEL_82;\n                      }\n                      if ( v46.type != 12 )\n                        goto LABEL_82;\n                      if ( !v30 )\n                        v30 = \"%s\\tname = %s\\n\";\n                    }\n                    else\n                    {\n                      switch ( v46.type )\n                      {\n                        case 2u:\n                          if ( !v30 )\n                            v30 = \"%s\\tnameserver = %s\\n\";\n                          break;\n                        case 5u:\n                          if ( !v30 )\n                            v30 = \"%s\\tcanonical name = %s\\n\";\n                          break;\n                        case 1u:\n                          if ( v46.rdlength != 4 )\n                            goto LABEL_83;\n                          inet_ntop(2, v46.rdata, v41, 0x2Eu);\n                          goto LABEL_51;\n                        default:\n                          goto LABEL_82;\n                      }\n                    }\n                    break;\n                  }\n                  if ( __ns_name_uncompress(v42._msg, v42._eom, v46.rdata, v45, 0x401u) < 0 )\n                    goto LABEL_83;\n                  v14 = &v46;\n                  if ( !v46.name[0] )\n                    v14 = (ns_rr *)(\"<<...\" + 4);\n                  printf(v30, v14, v45);\n                  goto LABEL_82;\n                }\n                --v36;\n                write(fd.fd, (const void *)(unk_80DB790 + v35 + 8), *(_DWORD *)(unk_80DB790 + v35 + 4));\n              }\n            }\n          }\n          else\n          {\n            sub_804D3A5(135046626);\n          }\n        }\nLABEL_12:\n        v28 = sub_804EC14();\nLABEL_85:\n        if ( v28 - v34 >= v37 )\n          goto LABEL_88;\n        if ( v28 - v31 >= v38 )\n        {\n          v31 = v28;\n          goto LABEL_2;\n        }\n      }\n    }\n    v3 = unk_80DB790 + 520 * i;\n    if ( *(_DWORD *)(v3 + 4) )\n    {\n      if ( write(fd.fd, (const void *)(v3 + 8), *(_DWORD *)(v3 + 4)) < 0 )\n        break;\n    }\n  }\n  sub_804D3A5((int)\"write to '%s'\", *a1);\n  v33 = -1;\nLABEL_88:\n  close(fd.fd);\n  return v33;\n}\n"
    ],
    "sub_805FF20": [
        "0x805ff20",
        "int __cdecl sub_805FF20(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // edi\n  const char *v4; // ebp\n  const char *v5; // ebp\n  const char *v6; // eax\n  const char *v7; // esi\n  int v8; // eax\n  int v9; // ebp\n  int v10; // ecx\n  char *v11; // eax\n  unsigned __int8 v12; // bp\n  char *v13; // eax\n  const char *v14; // edx\n  int v15; // eax\n  unsigned int i; // esi\n  const char *v17; // eax\n  FILE *v18; // ebx\n  char *v19; // eax\n  char *v20; // eax\n  char *v21; // eax\n  unsigned int v22; // ebx\n  int result; // eax\n  unsigned int j; // ebx\n  int v25; // edx\n  char *v26; // [esp-2h] [ebp-A4h]\n  char v27[16]; // [esp+2h] [ebp-A0h] BYREF\n  char v28[2]; // [esp+12h] [ebp-90h] BYREF\n  char v29[2]; // [esp+52h] [ebp-50h] BYREF\n\n  qword_80DB778 = 53;\n  *(&qword_80DB778 + 1) = 2;\n  unk_80DB780 = 5;\n  v2 = a2 + 4;\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = *(const char **)v2;\n    if ( !*(_DWORD *)v2 )\n      goto LABEL_3;\n    if ( *v4 != 45 )\n      break;\n    v2 += 4;\n    v5 = v4 + 1;\n    HIBYTE(v26) = 0;\n    v6 = (const char *)strchrnul();\n    v7 = v6;\n    if ( *v6 )\n    {\n      *v6 = 0;\n      v7 = v6 + 1;\n    }\n    v8 = sub_804D254(\"type\", v5);\n    if ( v8 < 0 )\n      goto LABEL_3;\n    if ( v8 > 1 )\n    {\n      switch ( v8 )\n      {\n        case 2:\n          qword_80DB778 = sub_80B40CC(0xFFFF, 1);\n          break;\n        case 3:\n          *(&qword_80DB778 + 1) = sub_80B40CC(0x7FFFFFFF, 1);\n          break;\n        case 4:\n          dword_80DBB9C |= 1u;\n          break;\n        default:\n          unk_80DB780 = sub_80B40CC(2147483, 1);\n          break;\n      }\n    }\n    else\n    {\n      v9 = 0;\n      while ( strcasecmp(&MEMORY[0x80B5A41][8 * v9], v7) )\n      {\n        if ( ++v9 == 9 )\n          sub_804D5E0(\"invalid query type \\\"%s\\\"\", v7);\n      }\n      v3 |= 1 << v9;\n    }\n  }\n  if ( !v3 )\n  {\n    if ( inet_pton(10, v4, v27) )\n    {\n      if ( !memcmp(v27, &unk_80B7900, 0xCu) )\n      {\n        v13 = sub_804DDBF(\n                \"%u.%u.%u.%u.in-addr.arpa\",\n                (unsigned __int8)v27[15],\n                (unsigned __int8)v27[14],\n                (unsigned __int8)v27[13],\n                (unsigned __int8)v27[12]);\n      }\n      else\n      {\n        v10 = 16;\n        v11 = v28;\n        do\n        {\n          v12 = v27[v10 - 1];\n          *v11 = byte_80C7B1E[v12 & 0xF] | 0x20;\n          v11[1] = 46;\n          v11[2] = byte_80C7B1E[v12 >> 4] | 0x20;\n          v11 += 4;\n          *(v11 - 1) = 46;\n          --v10;\n        }\n        while ( v10 );\n        strcpy(v29, \"ip6.arpa\");\n        v13 = sub_804DB46(v28);\n      }\n    }\n    else\n    {\n      if ( !inet_pton(2, v4, v27) )\n        goto LABEL_32;\n      v13 = sub_804DDBF(\n              \"%u.%u.%u.%u.in-addr.arpa\",\n              (unsigned __int8)v27[3],\n              (unsigned __int8)v27[2],\n              (unsigned __int8)v27[1],\n              (unsigned __int8)v27[0]);\n    }\n    if ( v13 )\n    {\n      v14 = v13;\n      v15 = 12;\nLABEL_33:\n      sub_805F80C(v15, v14);\n      goto LABEL_38;\n    }\nLABEL_32:\n    sub_805F80C(1, *(const char **)v2);\n    v14 = *(const char **)v2;\n    v15 = 28;\n    goto LABEL_33;\n  }\n  for ( i = 0; i != 9; ++i )\n  {\n    if ( _bittest(&v3, i) )\n      sub_805F80C((unsigned __int8)byte_80B5A40[8 * i], *(const char **)v2);\n  }\nLABEL_38:\n  v17 = *(const char **)(v2 + 4);\n  if ( v17 )\n  {\n    if ( *(_DWORD *)(v2 + 8) )\nLABEL_3:\n      sub_804CDC2();\n  }\n  else\n  {\n    v26 = \"r\";\n    v18 = (FILE *)fopen64();\n    if ( v18 )\n    {\n      while ( 1 )\n      {\n        HIBYTE(v26) = HIBYTE(v18);\n        if ( !fgets_unlocked() )\n          break;\n        v19 = strtok(v28, \" \\t\\n\");\n        if ( v19 )\n        {\n          if ( !strcmp(v19, \"nameserver\") )\n          {\n            v20 = strtok(0, \" \\t\\n\");\n            if ( v20 )\n            {\n              v21 = sub_804DB46(v20);\n              sub_805F865((int)v21);\n            }\n          }\n        }\n      }\n      fclose(v18);\n    }\n    if ( MEMORY[0x80DB788] )\n      goto LABEL_51;\n    v17 = \"127.0.0.1\";\n  }\n  sub_805F865((int)v17);\nLABEL_51:\n  v22 = 0;\n  while ( (unsigned int)MEMORY[0x80DB788] > v22 && sub_805F8A7((const char **)&unk_80DB78C[16 * v22]) <= 0 )\n  {\n    if ( (unsigned int)MEMORY[0x80DB788] <= ++v22 )\n    {\n      printf(\";; connection timed out; no servers could be reached\\n\\n\");\n      return 1;\n    }\n  }\n  result = 0;\n  for ( j = 0; *(&unk_80DB780 + 1) > j; ++j )\n  {\n    v25 = unk_80DB790 + 520 * j;\n    if ( *(_DWORD *)(v25 + 4) )\n    {\n      printf(\"*** Can't find %s: No answer\\n\", *(const char **)v25);\n      result = 1;\n    }\n  }\n  if ( result )\n  {\n    sub_804DD98(10);\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_806027F": [
        "0x806027f",
        "void __cdecl __noreturn sub_806027F(int a1)\n{\n  unsigned int v1; // ebx\n  unsigned int v2; // ecx\n  unsigned int rm_so; // esi\n  unsigned int v4; // edi\n  int v5; // eax\n\n  signal(2, (__sighandler_t)1);\n  v1 = unk_80DB794;\n  printf(\n    \"\\n--- %s ping statistics ---\\n%lu packets transmitted, %lu packets received, \",\n    (const char *)dword_80DB7C8,\n    unk_80DB790,\n    unk_80DB794);\n  if ( dword_80DB798 )\n    printf(\"%lu duplicates, \", dword_80DB798);\n  v2 = unk_80DB790;\n  if ( unk_80DB790 )\n    v2 = 100 * (unk_80DB790 - v1) / unk_80DB790;\n  printf(\"%lu%% packet loss\\n\", v2);\n  rm_so = pmatch[0].rm_so;\n  if ( pmatch[0].rm_so != -1 )\n  {\n    v4 = sub_80B4B88(qword_80DB7A8, MEMORY[0x80DB7AC], &dword_80DB798[v1], 0);\n    printf(\n      \"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\",\n      rm_so / 0x3E8,\n      rm_so % 0x3E8,\n      v4 / 0x3E8,\n      v4 % 0x3E8,\n      dword_80DB7A4 / 0x3E8u,\n      dword_80DB7A4 % 0x3E8u);\n  }\n  v5 = 1;\n  if ( v1 )\n  {\n    v5 = 0;\n    if ( dword_80DB7B4 )\n      v5 = (unsigned int)MEMORY[0x80DB788] > v1;\n  }\n  exit(v5);\n}\n"
    ],
    "sub_8060363": [
        "0x8060363",
        "void sub_8060363()\n{\n  unsigned __int8 *buffer; // ebx\n  __int16 v1; // ax\n  int v2; // eax\n  int v3; // ebx\n  int v4; // ebx\n  unsigned int secondsa; // [esp+Ch] [ebp+4h]\n\n  buffer = preg.buffer;\n  memset(preg.buffer, SBYTE2(stream), *(&unk_80DB780 + 1) + 12);\n  *buffer = 8;\n  *((_WORD *)buffer + 1) = 0;\n  LOBYTE(v1) = BYTE1(unk_80DB790);\n  HIBYTE(v1) = unk_80DB790;\n  *((_WORD *)buffer + 3) = v1;\n  *((_WORD *)buffer + 2) = (_WORD)stream;\n  dword_80DB7B0 = sub_804EBDE();\n  *((_DWORD *)buffer + 2) = dword_80DB7B0;\n  *((_WORD *)buffer + 1) = sub_80AD4D4();\n  v2 = unk_80DB790;\n  byte_80DB7E0[((unsigned __int16)unk_80DB790 >> 3) & 0x7F] &= ~(1 << (unk_80DB790 & 7));\n  unk_80DB790 = v2 + 1;\n  if ( dword_80DB7B4 && dword_80DB7B0 - (int)dword_80DB7B4 >= 0 )\n    sub_806027F(0);\n  v3 = *(&unk_80DB780 + 1) + 8;\n  if ( v3 != sub_804DFCD(*(&unk_80DB780 + 1) + 8, preg.buffer, 0, &dword_80DB7D0, 0x10u) )\n    sub_804D5E0(\"write error\");\n  if ( MEMORY[0x80DB788] && (unsigned int)MEMORY[0x80DB788] <= unk_80DB790 )\n  {\n    v4 = (int)MEMORY[0x80DB7B8];\n    if ( unk_80DB794 )\n    {\n      v4 = dword_80DB7A4 >> 19;\n      if ( !(dword_80DB7A4 >> 19) )\n        v4 = 1;\n    }\n    signal(14, (__sighandler_t)sub_806027F);\n    secondsa = v4;\n  }\n  else\n  {\n    signal(14, sub_8060363);\n    secondsa = 1;\n  }\n  alarm(secondsa);\n}\n"
    ],
    "sub_8060488": [
        "0x8060488",
        "void __usercall __noreturn sub_8060488(unsigned int a1@<ebx>, int a2, int a3)\n{\n  __int16 v3; // si\n  void *v4; // esi\n  int v5; // eax\n  int v6; // edx\n  int v7; // eax\n  const void *v8; // esi\n  const char *v9; // eax\n  int v10; // eax\n  ssize_t v11; // eax\n  int v12; // ecx\n  int v13; // edx\n  unsigned __int8 *v14; // eax\n  unsigned int v15; // edx\n  unsigned __int16 v16; // si\n  _DWORD *v17; // edi\n  int v18; // ebp\n  int v19; // eax\n  int v20; // edx\n  unsigned __int8 v21; // cl\n  const char *v22; // esi\n  const char *v23; // eax\n  unsigned int v24; // [esp+Ch] [ebp-38h]\n  int v25; // [esp+10h] [ebp-34h]\n  char *v26; // [esp+14h] [ebp-30h]\n  int v27; // [esp+18h] [ebp-2Ch] BYREF\n  int v28; // [esp+1Ch] [ebp-28h] BYREF\n  socklen_t addr_len; // [esp+20h] [ebp-24h] BYREF\n  struct sockaddr addr; // [esp+24h] [ebp-20h] BYREF\n\n  *(&unk_80DB780 + 1) = 56;\n  MEMORY[0x80DB7B8] = (void *)10;\n  pmatch[0].rm_so = -1;\n  v3 = sub_80ABEAC(\n         a3,\n         \"^qvAc:+s:t:+w:+W:+I:np:4\",\n         &MEMORY[0x80DB788],\n         &v27,\n         &unk_80DB78C,\n         &dword_80DB7B4,\n         &MEMORY[0x80DB7B8],\n         (char *)&qword_80DB778 + 4,\n         &v28);\n  if ( (v3 & 0x10) != 0 )\n    *(&unk_80DB780 + 1) = (unsigned __int16)sub_80B4193();\n  if ( (v3 & 0x100) != 0 )\n  {\n    qword_80DB778 = if_nametoindex();\n    if ( !qword_80DB778 )\n    {\n      unk_80DB780 = sub_80B45C8();\n      *(&qword_80DB778 + 1) = 0;\n    }\n  }\n  if ( (v3 & 0x400) != 0 )\n    BYTE2(stream) = sub_80B4093(255);\n  v4 = dword_80DB7B4;\n  if ( dword_80DB7B4 )\n  {\n    v5 = sub_804EBDE();\n    v6 = (int)v4;\n    if ( (unsigned int)v4 > 0x863 )\n      v6 = 2147;\n    dword_80DB7B4 = (void *)((1000000 * v6 + v5) | 1);\n  }\n  LOWORD(stream) = getpid();\n  dword_80DB7C8 = *(_DWORD *)(a3 + 4 * optind);\n  v7 = sub_80B45A6(2, 0);\n  if ( unk_80DB780 && *(_WORD *)(unk_80DB780 + 4) != (unsigned __int16)*(_DWORD *)(v7 + 4) )\n    unk_80DB780 = 0;\n  v8 = (const void *)(v7 + 4);\n  dword_80DB7CC = sub_80B46B6();\n  printf(\"PING %s (%s)\", (const char *)dword_80DB7C8, (const char *)dword_80DB7CC);\n  if ( unk_80DB780 )\n  {\n    v9 = (const char *)sub_80B46B6();\n    printf(\" from %s\", v9);\n  }\n  printf(\": %d data bytes\\n\", *(&unk_80DB780 + 1));\n  v10 = socket(2, 3, 1);\n  if ( v10 < 0 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C == 1 )\n      sub_804D5E0(\"permission denied (are you root?)\");\n    sub_804D3C9((int)\"can't create raw socket\");\n  }\n  sub_804DC97(v10, 0);\n  if ( *(&qword_80DB778 + 1) )\n    sub_80B4280();\n  n = *(&unk_80DB780 + 1) + 136;\n  dword_80DB7C0 = sub_804DB2E(*(&unk_80DB780 + 1) + 136);\n  preg.buffer = (unsigned __int8 *)sub_804DB2E(*(&unk_80DB780 + 1) + 12);\n  qmemcpy(&dword_80DB7D0, v8, sizeof(dword_80DB7D0));\n  if ( unk_80DB780 )\n  {\n    if ( setsockopt(0, 0, 32, (const void *)(unk_80DB780 + 4), *(_DWORD *)unk_80DB780) )\n      sub_804D5E0(\"can't set multicast source interface\");\n    sub_804DFB3(*(_DWORD *)unk_80DB780, (struct sockaddr *)(unk_80DB780 + 4), 0);\n  }\n  sub_80B426C();\n  sub_80B424A(2 * *((_BYTE *)&unk_80DB780 + 4), 8);\n  if ( unk_80DB78C )\n  {\n    sub_80B422B(2, 0, (char)unk_80DB78C);\n    sub_80B422B(33, 0, (char)unk_80DB78C);\n  }\n  signal(2, (__sighandler_t)sub_806027F);\n  while ( 1 )\n  {\n    sub_8060363();\n    do\n    {\n      while ( 1 )\n      {\n        addr_len = 16;\n        v11 = recvfrom(0, dword_80DB7C0, n, 0, &addr, &addr_len);\n        if ( v11 >= 0 )\n          break;\n        if ( *(_DWORD *)dword_80DBB7C != 4 )\n          sub_804D3A5((int)\"recvfrom\");\n      }\n      v12 = 0;\n      if ( *(&unk_80DB780 + 1) + 8 <= (unsigned int)v11 )\n      {\n        v13 = 4 * (*(_BYTE *)dword_80DB7C0 & 0xF);\n        v24 = v11 - v13;\n        v14 = (unsigned __int8 *)dword_80DB7C0 + v13;\n        if ( *(_WORD *)((char *)dword_80DB7C0 + v13 + 4) == (_WORD)stream )\n        {\n          v15 = *v14;\n          if ( (_BYTE)v15 )\n          {\n            if ( (_BYTE)v15 != 8 )\n            {\n              v23 = (const char *)&unk_80CD6CB;\n              if ( v15 <= 0x12 )\n                v23 = (&off_80B5AA0)[v15];\n              sub_804D5F4(\"warning: got ICMP %d (%s)\", v15, v23);\n              v12 = 0;\n            }\n          }\n          else\n          {\n            v16 = __ROL2__(*((_WORD *)v14 + 3), 8);\n            v17 = 0;\n            if ( v24 > 0xB )\n              v17 = v14 + 8;\n            v18 = *((unsigned __int8 *)dword_80DB7C0 + 8);\n            v25 = v16;\n            v26 = inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);\n            if ( v17 )\n            {\n              a1 = sub_804EBDE() - *v17;\n              *(_QWORD *)&qword_80DB7A8 += a1;\n              if ( a1 < pmatch[0].rm_so )\n                pmatch[0].rm_so = a1;\n              if ( a1 > dword_80DB7A4 )\n                dword_80DB7A4 = a1;\n            }\n            v19 = ((v16 >> 3) & 0x7F) + 104;\n            v20 = 1 << (v16 & 7);\n            v21 = *((_BYTE *)&qword_80DB778 + v19);\n            if ( ((unsigned __int8)v20 & v21) != 0 )\n            {\n              ++dword_80DB798;\n              v22 = \" (DUP!)\";\n            }\n            else\n            {\n              *((_BYTE *)&qword_80DB778 + v19) = v20 | v21;\n              ++unk_80DB794;\n              v22 = \" (DUP!)\" + 7;\n            }\n            v12 = 1;\n            if ( (dword_80DBB9C & 1) == 0 )\n            {\n              printf(\"%d bytes from %s: seq=%u ttl=%d\", v24, v26, v25, v18);\n              if ( v17 )\n                printf(\" time=%u.%03u ms\", a1 / 0x3E8, a1 % 0x3E8);\n              puts(v22);\n              sub_804DD8F();\n              v12 = 1;\n            }\n          }\n        }\n      }\n      if ( MEMORY[0x80DB788] && (unsigned int)MEMORY[0x80DB788] <= unk_80DB794 )\n        sub_806027F(0);\n    }\n    while ( !v12 || (dword_80DBB9C & 4) == 0 );\n  }\n}\n"
    ],
    "sub_8060910": [
        "0x8060910",
        "char *__usercall sub_8060910@<eax>(char *result@<eax>, int a2@<edx>)\n{\n  int i; // ecx\n  char v3; // bl\n\n  for ( i = 0; ; ++i )\n  {\n    v3 = byte_80CDACC[i];\n    *result = v3;\n    if ( !v3 )\n      break;\n    result += (a2 & dword_80B5B00[i]) != 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8060932": [
        "0x8060932",
        "int __usercall sub_8060932@<eax>(const char *a1@<eax>, const char ***a2@<edx>)\n{\n  const char **v2; // esi\n  const char *v3; // edi\n\n  v2 = *a2;\n  v3 = **a2;\n  if ( !v3 )\n    return 0;\n  while ( strcmp(a1 + 2, v3) )\n  {\n    a1 += *(unsigned __int8 *)a1;\n    if ( !*a1 )\n      return 0;\n  }\n  *a2 = v2 + 1;\n  if ( (a1[1] & 0x10) != 0 )\n  {\n    if ( !v2[1] )\n      sub_804CDC2();\n    *a2 = v2 + 2;\n  }\n  return *((unsigned __int8 *)a1 + 1);\n}\n"
    ],
    "sub_8060986": [
        "0x8060986",
        "int sub_8060986()\n{\n  FILE *v0; // esi\n  int v1; // eax\n  char *v2; // ebp\n  int i; // ecx\n  int v5; // ebx\n  char v6; // al\n  char *v7; // ebx\n  char *ptr; // [esp+4h] [ebp-138h]\n  int v9; // [esp+8h] [ebp-134h] BYREF\n  int v10; // [esp+Ch] [ebp-130h] BYREF\n  int v11; // [esp+10h] [ebp-12Ch] BYREF\n  int v12; // [esp+14h] [ebp-128h] BYREF\n  int v13; // [esp+18h] [ebp-124h] BYREF\n  char v14; // [esp+1Ch] [ebp-120h] BYREF\n  char v15[16]; // [esp+20h] [ebp-11Ch] BYREF\n  char v16[16]; // [esp+30h] [ebp-10Ch] BYREF\n  __int16 v17; // [esp+40h] [ebp-FCh]\n  char buf[20]; // [esp+48h] [ebp-F4h] BYREF\n  char cp[15]; // [esp+5Ch] [ebp-E0h] BYREF\n  char v20[25]; // [esp+6Bh] [ebp-D1h] BYREF\n  char v21[40]; // [esp+84h] [ebp-B8h] BYREF\n  char s[144]; // [esp+ACh] [ebp-90h] BYREF\n\n  v0 = (FILE *)sub_80B3D45();\n  printf(\"Kernel IPv6 routing table\\n%-44s%-40sFlags Metric Ref    Use Iface\\n\", \"Destination\", \"Next Hop\");\nLABEL_2:\n  v1 = fscanf(v0, \"%32s%x%*s%x%32s%x%x%x%x%s\\n\", &cp[14], &v13, &v14, &v21[7], &v10, &v11, &v12, &v9, v15);\n  if ( v1 == 9 )\n  {\n    v2 = v20;\n    for ( i = 0; ; i = v5 )\n    {\n      v6 = *(v2 - 1);\n      if ( v6 )\n      {\n        v5 = i + 1;\n        cp[i] = v6;\n        if ( !((i + 2) % 5) )\n        {\n          cp[v5] = 58;\n          v5 = i + 2;\n        }\n        if ( v5 > 74 )\n        {\n          sub_8060910(v16, v9 & 0x1250207);\n          inet_pton(10, cp, buf);\n          v17 = 10;\n          ptr = (char *)sub_80AD6B6();\n          snprintf(s, 0x80u, \"%s/%d\", ptr, v13);\n          free(ptr);\n          inet_pton(10, v21, buf);\n          v17 = 10;\n          v7 = (char *)sub_80AD6B6();\n          printf(\"%-43s %-39s %-5s %-6d %-2d %7d %-8s\\n\", s, v7, v16, v10, v11, v12, v15);\n          free(v7);\n          goto LABEL_2;\n        }\n      }\n      else\n      {\n        if ( i != 40 )\n          goto LABEL_5;\n        v20[24] = 0;\n        v5 = 40;\n      }\n      ++v2;\n    }\n  }\n  if ( v1 >= 0 || (v0->_flags & 4) == 0 )\nLABEL_5:\n    sub_804D3C9((int)\"read error\");\n  return fclose(v0);\n}\n"
    ],
    "sub_8060B27": [
        "0x8060b27",
        "int __usercall sub_8060B27@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  const char *v2; // esi\n  int v3; // ebx\n  char *v4; // eax\n  int v5; // ecx\n  const char *v6; // ebx\n  int v7; // eax\n  const char **v8; // edx\n  int v9; // esi\n  int v11; // [esp+4h] [ebp-A0h]\n  const char **v13; // [esp+Ch] [ebp-98h] BYREF\n  int v14[7]; // [esp+10h] [ebp-94h] BYREF\n  char v15[16]; // [esp+2Ch] [ebp-78h] BYREF\n  int v16; // [esp+3Ch] [ebp-68h]\n  _DWORD v17[22]; // [esp+4Ch] [ebp-58h] BYREF\n\n  v13 = a2 + 1;\n  v2 = *a2;\n  if ( !strcmp(*a2, \"default\") )\n  {\n    v3 = 0;\n    memset(v14, 0, sizeof(v14));\n  }\n  else\n  {\n    v4 = strchr(v2, 47);\n    v5 = v11;\n    v3 = 128;\n    if ( v4 )\n    {\n      *v4 = 0;\n      v3 = sub_80B40CC(128, 0);\n    }\n    if ( sub_80AD640(v5, v14) < 0 )\nLABEL_7:\n      sub_804D5E0(\"resolving %s\", v2);\n  }\n  memset(&v17[4], 0, 0x38u);\n  qmemcpy(v17, &v14[2], 0x10u);\n  LOWORD(v17[13]) = v3;\n  v17[16] = 4 * (v3 == 128) + 1;\n  v17[14] = 1;\n  v6 = 0;\n  while ( *v13 )\n  {\n    v7 = sub_8060932(asc_80CDAD8, &v13);\n    v8 = v13;\n    v2 = *(v13 - 1);\n    if ( (unsigned int)(v7 - 33) > 1 )\n    {\n      if ( v7 == 16 )\n      {\n        v17[14] = sub_80B40EC();\n      }\n      else if ( v7 == 18 )\n      {\n        if ( (v17[16] & 2) != 0 )\n          goto LABEL_16;\n        if ( sub_80AD640(v7 - 33, v14) < 0 )\n          goto LABEL_7;\n        qmemcpy(&v17[8], &v14[2], 0x10u);\n        v17[16] |= 2u;\n      }\n      else\n      {\n        if ( v6 || v7 != 22 && (v7 || (++v13, v8[1])) )\nLABEL_16:\n          sub_804CDC2();\n        v6 = *(v13 - 1);\n      }\n    }\n    else\n    {\n      v17[16] |= (unsigned __int16)word_80B790C[v7 & 3];\n    }\n  }\n  v9 = sub_804DF99(0, 2, 10);\n  v17[17] = 0;\n  if ( v6 )\n  {\n    sub_804D67E(v15, v6);\n    sub_804E0BE(v9, 0x8933u, (int)v15, \"SIOCGIFINDEX\");\n    v17[17] = v16;\n  }\n  if ( a1 == 1 )\n    return sub_804E0BE(v9, 0x890Bu, (int)v17, \"SIOCADDRT\");\n  else\n    return sub_804E0BE(v9, 0x890Cu, (int)v17, \"SIOCDELRT\");\n}\n"
    ],
    "sub_8060D11": [
        "0x8060d11",
        "int __usercall sub_8060D11@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  int v2; // eax\n  const char **v3; // edx\n  int v4; // ebp\n  const char *v5; // edi\n  char *v6; // ebx\n  const char *v7; // esi\n  int v8; // eax\n  __int16 v9; // dx\n  int v10; // eax\n  const char **v11; // edx\n  const char *v12; // ebx\n  int v13; // eax\n  unsigned __int32 v14; // edx\n  int v15; // ebx\n  int v16; // eax\n  const char *v18; // [esp+4h] [ebp-80h]\n  const char **v20; // [esp+Ch] [ebp-78h] BYREF\n  char v21[16]; // [esp+10h] [ebp-74h] BYREF\n  int v22[25]; // [esp+20h] [ebp-64h] BYREF\n\n  v20 = a2;\n  v2 = sub_8060932(asc_80CDB40, &v20);\n  v3 = v20;\n  if ( !*v20 )\nLABEL_2:\n    sub_804CDC2();\n  v4 = v2;\n  memset(v22, 0, 0x54u);\n  ++v20;\n  v5 = *v3;\n  v6 = strchr(*v3, 47);\n  v7 = \"default\";\n  if ( v6 )\n  {\n    v22[10] = _byteswap_ulong(~(0xFFFFFFFF >> sub_80B40CC(32, 0)));\n    *v6 = 0;\n    LOWORD(v22[9]) = 2;\n    v7 = 0;\n  }\n  v8 = sub_80AD506(v4 & 2, &v22[1]);\n  if ( v8 < 0 )\n  {\n    v18 = v5;\n    goto LABEL_18;\n  }\n  if ( v6 )\n    *v6 = 47;\n  if ( v4 )\n    v8 = v4 & 1;\n  v9 = 1;\n  if ( !v8 )\n    v9 = 5;\n  LOWORD(v22[13]) = v9;\n  while ( *v20 )\n  {\n    v10 = sub_8060932(asc_80CDAD8, &v20);\n    v11 = v20;\n    v12 = *(v20 - 1);\n    if ( (v10 & 0x20) != 0 )\n    {\n      LOWORD(v22[13]) |= word_80B790C[v10 & 3];\n    }\n    else\n    {\n      switch ( v10 )\n      {\n        case 16:\n          LOWORD(v22[16]) = sub_80B40EC() + 1;\n          break;\n        case 17:\n          if ( v22[10] )\n            goto LABEL_2;\n          if ( sub_80AD506(0, v21) < 0 )\n            goto LABEL_17;\n          qmemcpy(&v22[9], v21, 0x10u);\n          v7 = v12;\n          break;\n        case 18:\n          if ( (v22[13] & 2) != 0 )\n            goto LABEL_2;\n          v13 = sub_80AD506(1, &v22[5]);\n          LOWORD(v22[13]) |= 2u;\n          if ( v13 )\n          {\n            if ( v13 >= 0 )\n              sub_804D5E0(\"gateway %s is a NETWORK\", v12);\nLABEL_17:\n            v18 = v12;\nLABEL_18:\n            sub_804D5E0(\"resolving %s\", v18);\n          }\n          break;\n        case 19:\n          LOWORD(v22[13]) |= 0x40u;\n          v22[18] = sub_80B40CC(0x8000, 64);\n          break;\n        case 20:\n          LOWORD(v22[13]) |= 0x80u;\n          v22[19] = sub_80B40CC(0x7FFFFFFF, 128);\n          break;\n        case 21:\n          LOWORD(v22[13]) |= 0x100u;\n          LOWORD(v22[20]) = sub_80B40EC();\n          LOWORD(v22[20]) *= (unsigned __int16)(sub_80B2F58() / 0x64u);\n          break;\n        default:\n          if ( v22[17] )\n            goto LABEL_2;\n          if ( v10 != 22 )\n          {\n            if ( v10 )\n              goto LABEL_2;\n            ++v20;\n            if ( v11[1] )\n              goto LABEL_2;\n          }\n          v22[17] = (int)*(v20 - 1);\n          break;\n      }\n    }\n  }\n  if ( (v22[13] & 0x200) != 0 && !v22[17] )\n    v22[17] = (int)\"lo\";\n  if ( v22[10] )\n  {\n    v14 = _byteswap_ulong(v22[10]);\n    v15 = ~v14;\n    if ( (v22[13] & 4) != 0 && v15 != -1 )\n      sub_804D5E0(\"netmask %.8x and host route conflict\", ~v14);\n    if ( (v15 & -v14) != 0 )\n      sub_804D5E0(\"bogus netmask %s\", v7);\n    if ( (~v22[10] & v22[2]) != 0 )\n      sub_804D5E0(\"netmask and route address conflict\");\n  }\n  if ( a1 == 1 && (v22[13] & 4) != 0 )\n    v22[10] = -1;\n  v16 = sub_804DF99(0, 2, 2);\n  if ( a1 == 1 )\n    return sub_804E0BE(v16, 0x890Bu, (int)v22, \"SIOCADDRT\");\n  else\n    return sub_804E0BE(v16, 0x890Cu, (int)v22, \"SIOCDELRT\");\n}\n"
    ],
    "sub_8061007": [
        "0x8061007",
        "int __usercall sub_8061007@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  FILE *v3; // ebx\n  const char *v4; // eax\n  int v5; // eax\n  int v6; // edx\n  char *v7; // ebp\n  int v8; // edx\n  char *v9; // edi\n  char *v10; // eax\n  int v13; // [esp+4h] [ebp-98h] BYREF\n  int v14; // [esp+8h] [ebp-94h] BYREF\n  struct in_addr in; // [esp+Ch] [ebp-90h] BYREF\n  char v16; // [esp+10h] [ebp-8Ch] BYREF\n  char v17; // [esp+11h] [ebp-8Bh]\n  int v18; // [esp+14h] [ebp-88h] BYREF\n  int v19; // [esp+18h] [ebp-84h] BYREF\n  int v20; // [esp+1Ch] [ebp-80h] BYREF\n  int v21; // [esp+20h] [ebp-7Ch] BYREF\n  int v22; // [esp+24h] [ebp-78h] BYREF\n  int v23; // [esp+28h] [ebp-74h] BYREF\n  __int16 v24; // [esp+2Ch] [ebp-70h]\n  _WORD v25[7]; // [esp+2Eh] [ebp-6Eh] BYREF\n  char v26[16]; // [esp+3Ch] [ebp-60h] BYREF\n  char v27[80]; // [esp+4Ch] [ebp-50h] BYREF\n\n  v3 = (FILE *)sub_80B3D45();\n  v4 = \"Metric Ref    Use\";\n  if ( a2 )\n    v4 = \"  MSS Window  irtt\";\n  printf(\"Kernel IP routing table\\nDestination     Gateway         Genmask         Flags %s Iface\\n\", v4);\n  if ( fscanf(v3, \"%*[^\\n]\\n\") >= 0 )\n  {\n    while ( 1 )\n    {\n      v5 = fscanf(v3, \"%63s%lx%lx%X%d%d%d%lx%d%d%d\\n\", v27, &v13, &v14, &v16, &v18, &v19, &v20, &in, &v21, &v22, &v23);\n      if ( v5 != 11 )\n        break;\n      if ( (v16 & 1) != 0 )\n      {\n        sub_8060910(v26, v16 & 0x3F);\n        if ( (v17 & 2) != 0 )\n          v26[0] = 33;\n        memset(v25, 0, sizeof(v25));\n        v24 = 2;\n        *(_DWORD *)&v25[1] = v13;\n        v6 = a1;\n        BYTE1(v6) = BYTE1(a1) | 0x80;\n        v7 = (char *)sub_80AD56A(in.s_addr, v6);\n        *(_DWORD *)&v25[1] = v14;\n        v8 = a1;\n        BYTE1(v8) = BYTE1(a1) | 0x40;\n        v9 = (char *)sub_80AD56A(in.s_addr, v8);\n        v10 = inet_ntoa(in);\n        printf(\"%-15.15s %-15.15s %-16s%-6s\", v7, v9, v10, v26);\n        free(v7);\n        free(v9);\n        if ( a2 )\n          printf(\"%5d %-5d %6d %s\\n\", v21, v22, v23, v27);\n        else\n          printf(\"%-6d %-2d %7d %s\\n\", v20, v18, v19, v27);\n      }\n    }\n    if ( v5 >= 0 )\n      goto LABEL_9;\n  }\n  if ( (v3->_flags & 4) == 0 )\nLABEL_9:\n    sub_804D3C9((int)\"read error\");\n  return fclose(v3);\n}\n"
    ],
    "sub_8061197": [
        "0x8061197",
        "int __usercall sub_8061197@<eax>(const char *a1@<ebx>, int a2, char **a3)\n{\n  char **v3; // esi\n  char *v4; // ebx\n  int v5; // ebx\n  const char *v6; // esi\n  int v7; // eax\n  const char *v9; // [esp+0h] [ebp-Ch] BYREF\n\n  v9 = a1;\n  v3 = a3;\n  while ( 1 )\n  {\n    v4 = *++v3;\n    if ( !*v3 )\n      break;\n    if ( !strcmp(v4, \"-net\") || !strcmp(v4, \"-host\") )\n      *v4 = 35;\n  }\n  v5 = sub_80ABEAC(a3, \"A:ne\", &v9);\n  if ( (v5 & 1) != 0 )\n  {\n    v6 = v9;\n    if ( strcmp(v9, \"inet\") )\n    {\n      v5 |= 8u;\n      if ( strcmp(v6, \"inet6\") )\n        goto LABEL_9;\n    }\n  }\n  a3 += optind;\n  if ( !*a3 )\n  {\n    if ( (v5 & 8) != 0 )\n      sub_8060986();\n    else\n      sub_8061007((v5 << 30 >> 31) & 0xFFF, v5 & 4);\n    sub_80AB247();\n  }\n  v7 = sub_8060932(byte_80CDAB7, (const char ***)&a3);\n  if ( !v7 || !*a3 )\nLABEL_9:\n    sub_804CDC2();\n  if ( (v5 & 8) != 0 )\n    sub_8060B27(v7, (const char **)a3);\n  else\n    sub_8060D11(v7, (const char **)a3);\n  return 0;\n}\n"
    ],
    "sub_8061285": [
        "0x8061285",
        "int sub_8061285()\n{\n  return 0;\n}\n"
    ],
    "sub_8061288": [
        "0x8061288",
        "char *__usercall sub_8061288@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v2; // edx\n\n  if ( !a1 )\n    return sub_804DDBF(\"none\");\n  if ( (a1 & 0xFFFF0000) == 0 )\n    return sub_804DDBF((char *)\":%x\", a1);\n  v2 = HIWORD(a1);\n  if ( (_WORD)a1 )\n    return sub_804DDBF(\"%x:%x\", v2, (unsigned __int16)a1);\n  else\n    return sub_804DDBF(\"%x:\", v2);\n}\n"
    ],
    "sub_80612D1": [
        "0x80612d1",
        "int __usercall sub_80612D1@<eax>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<ebp>, int a4@<esi>, char a5)\n{\n  unsigned __int16 *v5; // edi\n  unsigned __int16 *v6; // ebx\n  unsigned __int16 *v7; // esi\n  unsigned int v8; // eax\n  long double v9; // fst7\n  char v10; // al\n  unsigned __int16 *v12; // [esp+1Ch] [ebp-78h]\n  unsigned __int16 *v13; // [esp+20h] [ebp-74h]\n  unsigned __int16 *v14; // [esp+24h] [ebp-70h]\n  unsigned __int16 *v15; // [esp+28h] [ebp-6Ch]\n  unsigned __int16 *v16; // [esp+2Ch] [ebp-68h]\n  char v17[68]; // [esp+38h] [ebp-5Ch] BYREF\n  int v18; // [esp+7Ch] [ebp-18h]\n  int v19; // [esp+80h] [ebp-14h]\n  char *v20; // [esp+84h] [ebp-10h]\n  int v21; // [esp+88h] [ebp-Ch]\n  int v22; // [esp+8Ch] [ebp-8h]\n  int anonymous6; // [esp+94h] [ebp+0h]\n\n  if ( !a1 )\n    return 0;\n  v22 = anonymous6;\n  v21 = a3;\n  v20 = &a5;\n  v19 = a4;\n  v18 = a2;\n  sub_806901E(*a1 - 4);\n  v5 = 0;\n  if ( v16 )\n  {\n    v5 = v16 + 2;\n    if ( (unsigned int)*v16 - 4 <= 0xB )\n    {\n      sub_804D5F4(\"CBQ: too short %s opt\", \"rate\");\n      v5 = 0;\n    }\n  }\n  v6 = 0;\n  if ( v12 )\n  {\n    v6 = v12 + 2;\n    if ( (unsigned int)*v12 - 4 <= 0x13 )\n    {\n      sub_804D5F4(\"CBQ: too short %s opt\", \"lss\");\n      v6 = 0;\n    }\n  }\n  v7 = 0;\n  if ( v13 )\n  {\n    v7 = v13 + 2;\n    if ( (unsigned int)*v13 - 4 <= 0xB )\n    {\n      sub_804D5F4(\"CBQ: too short %s opt\", \"wrr\");\n      v7 = 0;\n    }\n  }\n  if ( v14 && (unsigned int)*v14 - 4 <= 0xB )\n    sub_804D5F4(\"CBQ: too short %s opt\", \"fopt\");\n  if ( v15 )\n  {\n    v8 = *v15 - 4;\n    if ( v8 <= 7 )\n      sub_804D5F4(\"CBQ: too short overlimit strategy %u/%u\", v8, 8);\n  }\n  if ( v5 )\n  {\n    v9 = (long double)*((unsigned int *)v5 + 2) * 8.0;\n    if ( v9 < 1000000000.0 )\n    {\n      if ( v9 < 1000000.0 )\n        snprintf(v17, 0x40u, \"%.0fbit\", (double)v9);\n      else\n        snprintf(v17, 0x40u, \"%.0fKbit\", (double)(v9 / 1000.0));\n    }\n    else\n    {\n      snprintf(v17, 0x40u, \"%.0fMbit\", (double)(v9 / 1000000.0));\n    }\n    printf(\"rate %s \", v17);\n  }\n  if ( v6 && *((_BYTE *)v6 + 1) )\n  {\n    sub_804DD98(40);\n    v10 = 0;\n    if ( (*((_BYTE *)v6 + 1) & 1) != 0 )\n    {\n      printf(\"bounded\");\n      v10 = 1;\n    }\n    if ( (*((_BYTE *)v6 + 1) & 2) != 0 )\n    {\n      if ( v10 )\n        sub_804DD98(44);\n      printf(\"isolated\");\n    }\n    printf(\") \");\n  }\n  if ( v7 )\n  {\n    if ( *((_BYTE *)v7 + 1) == 8 )\n      printf(\"prio no-transmit\");\n    else\n      printf(\"prio %u\", *((unsigned __int8 *)v7 + 1));\n  }\n  return 0;\n}\n"
    ],
    "sub_80614D0": [
        "0x80614d0",
        "int __fastcall sub_80614D0(int a1, int a2)\n{\n  int result; // eax\n  int v3; // esi\n  int *v5; // ebp\n  const char *v6; // esi\n  const char *v7; // eax\n  unsigned int v8; // eax\n  char *v9; // eax\n  int v10; // eax\n  int v11; // ebx\n  int v12; // eax\n  _DWORD *v13; // esi\n  const char *v14; // eax\n  int *v15; // [esp-4h] [ebp-58h]\n  int v16[2]; // [esp+0h] [ebp-54h] BYREF\n  int v17[19]; // [esp+8h] [ebp-4Ch] BYREF\n\n  result = 0;\n  if ( (unsigned __int16)(*(_WORD *)(a2 + 4) - 36) <= 1u )\n  {\n    v3 = *(_DWORD *)a2 - 36;\n    if ( v3 < 0 )\n      return -1;\n    if ( !qword_80DB778 || qword_80DB778 == *(_DWORD *)(a2 + 20) )\n    {\n      v5 = v17;\n      memset(v17, 0, 0x3Cu);\n      sub_806901E(v3);\n      if ( !v17[1] )\n        return -1;\n      if ( *(_WORD *)(a2 + 4) == 37 )\n        printf(\"deleted \");\n      v6 = (const char *)(v17[1] + 4);\n      printf(\"qdisc %s %x: \", (const char *)(v17[1] + 4), *(unsigned __int16 *)(a2 + 26));\n      if ( !qword_80DB778 )\n      {\n        v7 = (const char *)sub_80692E5();\n        printf(\"dev %s \", v7);\n      }\n      v8 = *(_DWORD *)(a2 + 28);\n      if ( v8 == -1 )\n      {\n        printf(\"root \");\n        v5 = v15;\n      }\n      else if ( v8 )\n      {\n        v9 = sub_8061288(v8);\n        printf(\"parent %s \", v9);\n      }\n      if ( *(_DWORD *)(a2 + 32) != 1 )\n        printf(\"refcnt %d \", *(_DWORD *)(a2 + 32));\n      if ( v17[2] )\n      {\n        v10 = sub_804D222(\"pfifo_fast\", v6);\n        v11 = v10;\n        if ( v10 )\n        {\n          if ( v10 == 1 )\n            sub_80612D1((unsigned __int16 *)v17[2], 0, (int)v5, (int)v6, v16[0]);\n          else\n            sub_804D5F4(\"unknown %s\", v6);\n        }\n        else if ( v17[2] )\n        {\n          v12 = *(unsigned __int16 *)v17[2];\n          v13 = 0;\n          if ( (unsigned int)(v12 - 4) > 0x13 )\n            v13 = (_DWORD *)(v17[2] + 4);\n          if ( (unsigned __int16)(v12 - 4) <= 0x17u )\n            memset(v16, 0, sizeof(v16));\n          else\n            sub_806901E(*(unsigned __int16 *)(v17[2] + 24) - 4);\n          printf(\"bands %u priomap \", *v13);\n          do\n            printf(\" %d\", *((unsigned __int8 *)v13 + v11++ + 4));\n          while ( v11 != 16 );\n          if ( v16[1] )\n          {\n            v14 = \"n\";\n            if ( !*(_BYTE *)(v16[1] + 4) )\n              v14 = \"can't access tty; job control turned off\" + 38;\n            printf(\" multiqueue: o%s \", v14);\n          }\n        }\n      }\n      sub_804DD98(10);\n      return 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80616A5": [
        "0x80616a5",
        "int __fastcall sub_80616A5(int a1, int a2)\n{\n  int result; // eax\n  int v3; // esi\n  int v4; // ebx\n  int *v5; // ebp\n  const char *v6; // esi\n  char *v7; // eax\n  unsigned int v8; // eax\n  const char *v9; // eax\n  unsigned int v10; // eax\n  char *v11; // eax\n  unsigned int v12; // eax\n  int v13; // eax\n  int *v14; // [esp-4h] [ebp-50h]\n  int v15; // [esp-4h] [ebp-50h]\n  int v16[19]; // [esp+0h] [ebp-4Ch] BYREF\n\n  result = 0;\n  if ( (unsigned __int16)(*(_WORD *)(a2 + 4) - 40) <= 1u )\n  {\n    v3 = *(_DWORD *)a2 - 36;\n    if ( v3 < 0 )\n      return -1;\n    if ( !*(&qword_80DB778 + 1) || ((*(_DWORD *)(a2 + 24) ^ *(&qword_80DB778 + 1)) & 0xFFFF0000) == 0 )\n    {\n      v4 = a2;\n      v5 = v16;\n      memset(v16, 0, 0x3Cu);\n      sub_806901E(v3);\n      if ( !v16[1] )\n        return -1;\n      if ( *(_WORD *)(v4 + 4) == 41 )\n        printf(\"deleted \");\n      v6 = (const char *)(v16[1] + 4);\n      v7 = 0;\n      if ( *(_DWORD *)(v4 + 24) )\n      {\n        v8 = *(_DWORD *)(v4 + 28);\n        if ( *(&qword_80DB778 + 1) )\n          v8 = (unsigned __int16)v8;\n        v7 = sub_8061288(v8);\n      }\n      printf(\"class %s %s\", v6, v7);\n      if ( !qword_80DB778 )\n      {\n        v9 = (const char *)sub_80692E5();\n        printf(\"dev %s \", v9);\n      }\n      v10 = *(_DWORD *)(v4 + 28);\n      if ( v10 == -1 )\n      {\n        printf(\"root \");\n      }\n      else if ( v10 )\n      {\n        if ( *(&qword_80DB778 + 1) )\n          v10 = (unsigned __int16)v10;\n        v11 = sub_8061288(v10);\n        printf(\"parent %s \", v11);\n        v5 = v14;\n      }\n      v12 = *(_DWORD *)(v4 + 32);\n      if ( v12 )\n      {\n        printf(\"leaf %x \", HIWORD(v12));\n        v4 = v15;\n      }\n      if ( v16[2] )\n      {\n        v13 = sub_804D222(\"pfifo_fast\", v6);\n        if ( v13 )\n        {\n          if ( v13 == 1 )\n            sub_80612D1((unsigned __int16 *)v16[2], v4, (int)v5, (int)v6, v16[0]);\n          else\n            sub_804D5F4(\"unknown %s\", v6);\n        }\n      }\n      sub_804DD98(10);\n      return 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8061802": [
        "0x8061802",
        "int __cdecl sub_8061802(int a1, const char **a2)\n{\n  const char **v2; // ebx\n  int v3; // esi\n  const char *v4; // edx\n  int v5; // eax\n  int v6; // edi\n  const char *v7; // ebp\n  unsigned int v8; // eax\n  int *v9; // eax\n  char *v10; // eax\n  unsigned int v11; // eax\n  const char **v12; // eax\n  const char *v13; // ebp\n  unsigned int v14; // eax\n  unsigned int v15; // edi\n  unsigned int v16; // eax\n  void *v17; // edx\n  int v19; // [esp+0h] [ebp-54h]\n  int v20; // [esp+4h] [ebp-50h]\n  char *endptr[6]; // [esp+8h] [ebp-4Ch] BYREF\n\n  if ( !a2[1] || (sub_8068A5B(), v2 = a2 + 2, v3 = sub_804D254(\"qdisc\", a2[1]), v3 < 0) )\n    sub_804CDC2();\n  v4 = a2[2];\n  if ( v4 )\n  {\n    v19 = sub_804D254(\"add\", v4);\n    if ( v19 < 0 )\nLABEL_18:\n      sub_8069C50();\n    v2 = a2 + 3;\n  }\n  else\n  {\n    v19 = 5;\n  }\n  memset(&endptr[1], 0, 0x14u);\n  sub_8069345();\n  v20 = 0;\n  while ( *v2 )\n  {\n    v5 = sub_804D254(\"dev\", *v2);\n    v6 = v5;\n    if ( v5 )\n    {\n      if ( v5 == 3 )\n      {\n        if ( v3 != 1 || v19 <= 4 )\n        {\n          if ( !v3 )\n            goto LABEL_18;\nLABEL_34:\n          if ( v3 != 2 || v5 <= 5 )\n            goto LABEL_18;\n          goto LABEL_37;\n        }\n        goto LABEL_16;\n      }\n      if ( v5 == 4 )\n      {\n        if ( !v3 )\n        {\n          if ( v19 != 2 )\n            goto LABEL_18;\nLABEL_16:\n          v7 = *(const char **)sub_8069C3A();\n          if ( !strcmp(v7, \"none\") )\n          {\n            v11 = 0;\n          }\n          else\n          {\n            v8 = strtoul(v7, endptr, 16);\n            if ( v7 == endptr[0] )\n              goto LABEL_18;\n            v11 = v8 << 16;\n            if ( *endptr[0] != 58 )\n            {\n              if ( *endptr[0] )\n                goto LABEL_18;\n            }\n          }\n          *(&qword_80DB778 + 1) = v11;\n          goto LABEL_37;\n        }\n      }\n      else if ( !v3 )\n      {\n        goto LABEL_18;\n      }\n      if ( (unsigned int)(v5 - 1) > 1 )\n        goto LABEL_34;\n    }\n    else\n    {\n      v9 = (int *)sub_8069C3A();\n      if ( v20 )\n        sub_8069CE0();\n      v20 = *v9;\n      v10 = (char *)sub_806932A();\n      endptr[2] = v10;\n      if ( v19 > 4 )\n        qword_80DB778 = v10;\n    }\nLABEL_37:\n    v12 = (const char **)sub_8069C3A();\n    v2 = v12;\n    if ( v6 == 1 )\n    {\n      if ( endptr[4] )\n        goto LABEL_69;\n      endptr[4] = (char *)-1;\n      if ( v3 == 2 )\n        unk_80DB780 = -1;\n    }\n    else\n    {\n      v13 = *v12;\n      if ( v6 == 2 )\n      {\n        if ( endptr[4] )\n          goto LABEL_69;\n        if ( !strcmp(v13, \"root\") )\n        {\n          v14 = -1;\n        }\n        else if ( !strcmp(v13, \"none\") )\n        {\n          v14 = 0;\n        }\n        else\n        {\n          v14 = strtoul(v13, endptr, 16);\n          if ( endptr[0] == v13 )\n          {\n            if ( *endptr[0] != 58 )\n              goto LABEL_18;\n            v14 = 0;\n          }\n          if ( *endptr[0] == 58 )\n          {\n            if ( v14 > 0xFFFF )\n              goto LABEL_18;\n            v15 = v14 << 16;\n            v16 = strtoul(endptr[0] + 1, endptr, 16);\n            if ( *endptr[0] || v16 > 0xFFFF )\n              goto LABEL_18;\n            v14 = v15 | v16;\n          }\n          else if ( *endptr[0] )\n          {\n            goto LABEL_18;\n          }\n        }\n        endptr[4] = (char *)v14;\n        if ( v3 == 2 )\n          unk_80DB780 = v14;\n      }\n      else if ( v6 == 4 )\n      {\n        if ( endptr[3] )\n          goto LABEL_69;\n        endptr[3] = (char *)sub_8069C92();\n      }\n      else if ( v3 != 1 || v19 != 2 || v6 != 5 )\n      {\n        if ( (unsigned int)(v6 - 6) > 1 )\n        {\n          if ( v6 == 8 )\n          {\n            if ( MEMORY[0x80DB788] )\nLABEL_69:\n              sub_8069CD4();\n            if ( sub_8069366() )\n              goto LABEL_18;\n            MEMORY[0x80DB788] = (char *)LOWORD(endptr[0]);\n          }\n        }\n        else\n        {\n          if ( *(&unk_80DB780 + 1) )\n            goto LABEL_69;\n          *(&unk_80DB780 + 1) = sub_8069C92();\n        }\n      }\n    }\n  }\n  if ( v19 > 4 )\n  {\n    if ( v3 == 2 )\n      endptr[5] = (char *)((unsigned __int16)MEMORY[0x80DB788] | (*(&unk_80DB780 + 1) << 16));\n    if ( (int)sub_8068B22(20) < 0 )\n      sub_804D3FF(\"can't send dump request\");\n    v17 = sub_80614D0;\n    if ( v3 )\n    {\n      v17 = sub_8061285;\n      if ( v3 == 1 )\n        v17 = sub_80616A5;\n    }\n    sub_8068BB1(0, v17);\n  }\n  return 0;\n}\n"
    ],
    "sub_8061BCB": [
        "0x8061bcb",
        "char __usercall sub_8061BCB@<al>(char result@<al>)\n{\n  int v1; // edx\n\n  v1 = qword_80DB778++;\n  byte_80DB814[v1] = result;\n  return result;\n}\n"
    ],
    "sub_8061BE1": [
        "0x8061be1",
        "int sub_8061BE1()\n{\n  int result; // eax\n\n  result = sub_804E586(qword_80DB778, byte_80DB814);\n  qword_80DB778 = 0;\n  return result;\n}\n"
    ],
    "sub_8061C01": [
        "0x8061c01",
        "char __usercall sub_8061C01@<al>(__int16 a1@<ax>)\n{\n  if ( qword_80DB778 > 125 )\n    sub_8061BE1();\n  sub_8061BCB(255);\n  sub_8061BCB(SHIBYTE(a1));\n  return sub_8061BCB(a1);\n}\n"
    ],
    "sub_8061C2F": [
        "0x8061c2f",
        "int sub_8061C2F()\n{\n  int result; // eax\n\n  if ( (_BYTE)unk_80DB780 )\n    return tcsetattr(0, 1, &termios_p);\n  return result;\n}\n"
    ],
    "sub_8061C4A": [
        "0x8061c4a",
        "int sub_8061C4A()\n{\n  int result; // eax\n\n  if ( (_BYTE)unk_80DB780 )\n    return tcsetattr(0, 1, &unk_80DB894);\n  return result;\n}\n"
    ],
    "sub_8061C65": [
        "0x8061c65",
        "char sub_8061C65()\n{\n  char result; // al\n\n  result = *(&qword_80DB778 + 6);\n  if ( (*(&qword_80DB778 + 7) & 1) != 0 )\n  {\n    if ( !*(&qword_80DB778 + 6) )\n    {\n      *(&qword_80DB778 + 6) = 1;\n      printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"character\", 93);\n      return sub_8061C2F();\n    }\n  }\n  else if ( *(&qword_80DB778 + 6) != 2 )\n  {\n    *(&qword_80DB778 + 6) = 2;\n    printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"line\", 67);\n    return sub_8061C4A();\n  }\n  return result;\n}\n"
    ],
    "sub_8061CBC": [
        "0x8061cbc",
        "void __spoils<edx,ecx> sub_8061CBC()\n{\n  __int16 v0; // ax\n  unsigned __int8 v1; // [esp+1h] [ebp-1h] BYREF\n\n  if ( byte_80DBBA4 )\n    sub_8061C2F();\n  sub_804D846(\n    \"\\r\\n\"\n    \"Console escape. Commands are:\\r\\n\"\n    \"\\n\"\n    \" l\\tgo to line mode\\r\\n\"\n    \" c\\tgo to character mode\\r\\n\"\n    \" z\\tsuspend telnet\\r\\n\"\n    \" e\\texit telnet\\r\\n\");\n  if ( read(0, &v1, 1u) <= 0 )\n  {\n    sub_8061C4A();\n    exit(1);\n  }\n  if ( v1 == 101 )\n  {\n    sub_8061C4A();\n    exit(0);\n  }\n  if ( v1 > 0x65u )\n  {\n    if ( v1 == 108 )\n    {\n      if ( !byte_80DBBA4 )\n      {\n        *(&qword_80DB778 + 6) = 0;\n        *(&qword_80DB778 + 7) &= 0xFCu;\n        sub_8061C65();\n        sub_8061C01(65025);\n        v0 = -509;\nLABEL_16:\n        sub_8061C01(v0);\n        sub_8061BE1();\n        goto LABEL_20;\n      }\n    }\n    else if ( v1 == 122 )\n    {\n      sub_8061C4A();\n      kill(0, 20);\n      sub_8061C2F();\n    }\n  }\n  else if ( v1 == 99 && byte_80DBBA4 )\n  {\n    *(&qword_80DB778 + 6) = 0;\n    *(&qword_80DB778 + 7) |= 3u;\n    sub_8061C65();\n    sub_8061C01(64769);\n    v0 = -765;\n    goto LABEL_16;\n  }\n  sub_804D846(\"continuing...\\r\\n\");\n  if ( byte_80DBBA4 )\n    sub_8061C4A();\nLABEL_20:\n  byte_80DBBA4 = 0;\n}\n"
    ],
    "sub_8061DC1": [
        "0x8061dc1",
        "unsigned int __usercall sub_8061DC1@<eax>(int a1@<eax>)\n{\n  unsigned int result; // eax\n  size_t *v2; // esi\n  char *v3; // ecx\n  char v4; // bl\n  char *v5; // edi\n  char v6[268]; // [esp+0h] [ebp-10Ch] BYREF\n\n  result = a1 + 135116692;\n  v2 = &unk_80DB794;\n  v3 = v6;\n  while ( (unsigned int)v2 < result )\n  {\n    v2 = (size_t *)((char *)v2 + 1);\n    v4 = *((_BYTE *)v2 - 1);\n    if ( v4 == 29 )\n    {\n      sub_8061CBC();\n      return result;\n    }\n    *v3 = v4;\n    v5 = v3 + 1;\n    if ( v4 == -1 )\n    {\n      v3[1] = -1;\n    }\n    else if ( v4 == 10 || v4 == 13 )\n    {\n      *(_WORD *)v3 = 2573;\n    }\n    else\n    {\n      v5 = v3;\n    }\n    v3 = v5 + 1;\n  }\n  if ( v6 != v3 )\n    return sub_804E586(v3 - v6, v6);\n  return result;\n}\n"
    ],
    "sub_8061E2E": [
        "0x8061e2e",
        "void __cdecl __noreturn sub_8061E2E(int a1, int a2)\n{\n  _DWORD *v2; // ecx\n  _DWORD *v3; // esi\n  int v4; // eax\n  int v5; // eax\n  ssize_t v6; // esi\n  size_t v7; // ebx\n  size_t v8; // eax\n  unsigned __int8 v9; // dl\n  __int16 v10; // ax\n  __int16 v12; // ax\n  char v13; // al\n  bool v14; // zf\n  __int16 v15; // di\n  __int16 v16; // bp\n  char *v17; // edi\n  size_t v18; // eax\n  char v19; // al\n  size_t v20; // eax\n  char *i; // edi\n  char v22; // al\n  char *j; // edi\n  char v24; // al\n  size_t v25; // [esp+0h] [ebp-24h]\n  struct pollfd fds; // [esp+4h] [ebp-20h] BYREF\n  int v27; // [esp+Ch] [ebp-18h]\n  __int16 v28; // [esp+10h] [ebp-14h]\n  __int16 v29; // [esp+12h] [ebp-12h]\n\n  *(&unk_80DB780 + 1) = (time_t)getenv(\"TERM\");\n  if ( tcgetattr(0, &unk_80DB894) >= 0 )\n  {\n    LOBYTE(unk_80DB780) = 1;\n    qmemcpy(&termios_p, &unk_80DB894, sizeof(termios_p));\n    cfmakeraw(&termios_p);\n  }\n  if ( sub_80ABEAC(a2, \"al:\", &MEMORY[0x80DB788]) == 1 )\n    MEMORY[0x80DB788] = getenv(\"USER\");\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v2 )\n    goto LABEL_6;\n  v3 = v2 + 1;\n  if ( v2[1] )\n  {\n    v3 = v2 + 2;\n    sub_80B42FF(23, 135057932);\n  }\n  if ( *v3 )\nLABEL_6:\n    sub_804CDC2();\n  v4 = sub_80B4645();\n  sub_804DC97(v4, 3);\n  sub_80B4276();\n  sub_804D878(0, (int *)&unk_80DB78C, &unk_80DB790);\n  signal(2, (__sighandler_t)sub_804E68E);\n  fds.fd = 0;\n  fds.events = 1;\n  v27 = 3;\n  v28 = 1;\n  while ( 1 )\n  {\n    do\n    {\n      while ( poll(&fds, 2u, -1) < 0 )\n      {\n        if ( byte_80DBBA4 )\n          sub_8061CBC();\n        else\n          sleep(1u);\n      }\n      if ( fds.revents )\n      {\n        v5 = sub_804E5BC(0x80u, &unk_80DB794, 0);\n        if ( v5 <= 0 )\n        {\n          sub_8061C4A();\n          exit(0);\n        }\n        sub_8061DC1(v5);\n      }\n    }\n    while ( !v29 );\n    v6 = sub_804E5BC(0x80u, &unk_80DB794, 3);\n    if ( v6 <= 0 )\n    {\n      sub_804D846(\"Connection closed by foreign host\\r\\n\");\n      sub_8061C4A();\n      exit(1);\n    }\n    v7 = 0;\n    v8 = 0;\n    do\n    {\n      v9 = *((_BYTE *)&unk_80DB794 + v8);\n      v25 = v8 + 1;\n      if ( *(&qword_80DB778 + 4) )\n      {\n        switch ( *(&qword_80DB778 + 4) )\n        {\n          case 1:\n            goto LABEL_30;\n          case 2:\n            if ( v9 == 0xFF )\n            {\n              *((_BYTE *)&unk_80DB794 + v7) = -1;\n              *(&qword_80DB778 + 4) = 1;\n              ++v7;\n              goto LABEL_101;\n            }\n            if ( v9 == 0xFA )\n              goto LABEL_100;\n            if ( v9 < 0xFAu )\n              goto LABEL_99;\n            *(&qword_80DB778 + 5) = *((_BYTE *)&unk_80DB794 + v8);\n            *(&qword_80DB778 + 4) = 3;\n            goto LABEL_101;\n          case 3:\n            if ( v9 == 24 )\n            {\n              v10 = -1256;\n              if ( !*(&unk_80DB780 + 1) )\n                v10 = -1000;\n              goto LABEL_76;\n            }\n            if ( v9 > 0x18u )\n            {\n              if ( v9 == 31 )\n              {\n                sub_8061C01(64287);\n                v15 = unk_80DB790;\n                v16 = (__int16)unk_80DB78C;\n                if ( qword_80DB778 > 119 )\n                  sub_8061BE1();\n                sub_8061BCB(255);\n                sub_8061BCB(250);\n                sub_8061BCB(31);\n                sub_8061BCB(SHIBYTE(v16));\n                sub_8061BCB(v16);\n                sub_8061BCB(SHIBYTE(v15));\n                sub_8061BCB(v15);\n                sub_8061BCB(255);\n                sub_8061BCB(240);\n                goto LABEL_99;\n              }\n              if ( v9 == 39 )\n              {\n                v10 = -1241;\n                if ( !MEMORY[0x80DB788] )\n                  v10 = -985;\n                goto LABEL_76;\n              }\n            }\n            else\n            {\n              if ( v9 == 1 )\n              {\n                v10 = -1023;\n                if ( *(&qword_80DB778 + 5) != 0xFD )\n                {\n                  if ( *(&qword_80DB778 + 5) != 0xFE\n                    && !((*(&qword_80DB778 + 7) & 1) != 0 ? *(&qword_80DB778 + 5) == 0xFB : *(&qword_80DB778 + 5) == 0xFC) )\n                  {\n                    if ( *(&qword_80DB778 + 6) != 2 )\n                      *(&qword_80DB778 + 7) ^= 1u;\n                    v12 = -767;\n                    if ( (*(&qword_80DB778 + 7) & 1) == 0 )\n                      v12 = -511;\n                    sub_8061C01(v12);\n                    sub_8061C65();\n                    sub_804D846(\"\\r\\n\");\n                  }\n                  goto LABEL_99;\n                }\n                goto LABEL_76;\n              }\n              if ( v9 == 3 )\n              {\n                v13 = *(&qword_80DB778 + 7);\n                if ( (*(&qword_80DB778 + 7) & 2) != 0 )\n                  v14 = *(&qword_80DB778 + 5) == 0xFB;\n                else\n                  v14 = *(&qword_80DB778 + 5) == 0xFC;\n                if ( v14 )\n                  goto LABEL_99;\n                *(&qword_80DB778 + 7) ^= 2u;\n                if ( (v13 & 2) != 0 )\n                  v10 = -509;\n                else\n                  v10 = -765;\n                goto LABEL_76;\n              }\n            }\n            if ( *(&qword_80DB778 + 5) == 0xFB )\n            {\n              v10 = v9 - 512;\n            }\n            else\n            {\n              if ( *(&qword_80DB778 + 5) != 0xFD )\n              {\nLABEL_99:\n                *(&qword_80DB778 + 4) = 1;\n                goto LABEL_101;\n              }\n              v10 = v9 - 1024;\n            }\nLABEL_76:\n            sub_8061C01(v10);\n            goto LABEL_99;\n          case 4:\n          case 5:\n            if ( *(&qword_80DB778 + 4) == 5 )\n            {\n              if ( v9 == 0xF0 )\n                goto LABEL_99;\nLABEL_100:\n              *(&qword_80DB778 + 4) = 4;\n            }\n            else\n            {\n              if ( v9 == 0xFF )\n              {\n                *(&qword_80DB778 + 4) = 5;\n                goto LABEL_101;\n              }\n              if ( v9 == 24 )\n              {\n                v17 = (char *)*(&unk_80DB780 + 1);\n                if ( !*(&unk_80DB780 + 1) )\n                  goto LABEL_101;\n                v18 = strlen((const char *)*(&unk_80DB780 + 1));\n                if ( !(((int)(v18 + qword_80DB778 - 122) < 0) ^ __OFADD__(-128, v18 + qword_80DB778 + 6) | (v18 + qword_80DB778 == 122)) )\n                  sub_8061BE1();\n                sub_8061BCB(255);\n                sub_8061BCB(250);\n                sub_8061BCB(24);\n                v19 = 0;\n                while ( 1 )\n                {\n                  sub_8061BCB(v19);\n                  v19 = *v17;\n                  if ( !*v17 )\n                    break;\n                  ++v17;\n                }\n                goto LABEL_97;\n              }\n              if ( v9 == 39 && MEMORY[0x80DB788] )\n              {\n                v20 = strlen(MEMORY[0x80DB788]);\n                if ( !(((int)(v20 + qword_80DB778 - 122) < 0) ^ __OFADD__(-128, v20 + qword_80DB778 + 6) | (v20 + qword_80DB778 == 122)) )\n                  sub_8061BE1();\n                sub_8061BCB(255);\n                sub_8061BCB(250);\n                sub_8061BCB(39);\n                sub_8061BCB(0);\n                sub_8061BCB(0);\n                for ( i = \"USER\"; ; ++i )\n                {\n                  v22 = *i;\n                  if ( !*i )\n                    break;\n                  sub_8061BCB(v22);\n                }\n                sub_8061BCB(1);\n                for ( j = MEMORY[0x80DB788]; ; ++j )\n                {\n                  v24 = *j;\n                  if ( !*j )\n                    break;\n                  sub_8061BCB(v24);\n                }\nLABEL_97:\n                sub_8061BCB(255);\n                sub_8061BCB(240);\n                goto LABEL_101;\n              }\n            }\n            goto LABEL_101;\n          case 6:\n            *(&qword_80DB778 + 4) = 1;\n            if ( v9 )\n            {\nLABEL_30:\n              if ( v9 == 0xFF )\n              {\n                *(&qword_80DB778 + 4) = 2;\n              }\n              else\n              {\n                *((_BYTE *)&unk_80DB794 + v7++) = v9;\n                if ( v9 == 13 )\n                  *(&qword_80DB778 + 4) = 6;\n              }\n            }\n            goto LABEL_101;\n          default:\n            goto LABEL_101;\n        }\n      }\n      if ( v9 == 0xFF )\n      {\n        *(&qword_80DB778 + 4) = 2;\n        v7 = v8;\n      }\n      else if ( v9 == 13 )\n      {\n        *(&qword_80DB778 + 4) = 6;\n        v7 = v8 + 1;\n      }\nLABEL_101:\n      v8 = v25;\n    }\n    while ( v6 != v25 );\n    if ( !*(&qword_80DB778 + 4) )\n    {\n      v7 = v6;\n      goto LABEL_110;\n    }\n    if ( qword_80DB778 )\n      sub_8061BE1();\n    if ( *(&qword_80DB778 + 4) == 1 )\n      *(&qword_80DB778 + 4) = 0;\n    if ( v7 )\nLABEL_110:\n      sub_804E586(v7, (char *)&unk_80DB794);\n  }\n}\n"
    ],
    "sub_80623EC": [
        "0x80623ec",
        "unsigned int __usercall sub_80623EC@<eax>(const char *a1@<eax>, unsigned int a2@<edx>)\n{\n  unsigned int result; // eax\n\n  result = sub_804ED6C(10, a1, 0, (int)a1);\n  if ( *(_DWORD *)dword_80DBB7C || result <= 0x17 || a2 < result )\n  {\n    sub_804D5F4(\"bad blocksize '%s'\", a1);\n    return -1;\n  }\n  return result;\n}\n"
    ],
    "sub_8062425": [
        "0x8062425",
        "int __cdecl sub_8062425(int a1, int a2)\n{\n  _DWORD *v2; // esi\n  int v3; // ebx\n  char *v4; // ebx\n  char *v5; // eax\n  int v6; // eax\n  int v7; // ecx\n  char *v8; // edi\n  char *v9; // esi\n  char *v10; // ebp\n  char *v11; // ebx\n  __int16 v12; // si\n  size_t v13; // eax\n  char *v14; // ebx\n  char *v15; // edi\n  int v16; // ebx\n  __int16 v17; // ax\n  int v18; // edi\n  ssize_t v19; // ebx\n  unsigned __int16 v20; // dx\n  int v21; // eax\n  bool v22; // zf\n  int v23; // ebx\n  const char *v24; // eax\n  int v25; // ebx\n  const char *v26; // edi\n  int v27; // edx\n  int v28; // ecx\n  int v29; // esi\n  int v30; // eax\n  int v31; // esi\n  __int16 v32; // ax\n  ssize_t v33; // eax\n  size_t v34; // ebx\n  size_t v35; // eax\n  int nbytes; // [esp+0h] [ebp-BCh]\n  unsigned int n; // [esp+4h] [ebp-B8h]\n  char *buf; // [esp+8h] [ebp-B4h]\n  socklen_t *addr_len; // [esp+Ch] [ebp-B0h]\n  size_t v41; // [esp+10h] [ebp-ACh]\n  __int16 v42; // [esp+10h] [ebp-ACh]\n  char v43; // [esp+17h] [ebp-A5h]\n  int v44; // [esp+18h] [ebp-A4h]\n  struct sockaddr *addr; // [esp+1Ch] [ebp-A0h]\n  char v46; // [esp+20h] [ebp-9Ch]\n  unsigned __int16 v47; // [esp+20h] [ebp-9Ch]\n  int v48; // [esp+24h] [ebp-98h]\n  int v49; // [esp+28h] [ebp-94h]\n  char v50; // [esp+2Ch] [ebp-90h]\n  int v51; // [esp+30h] [ebp-8Ch]\n  size_t v52; // [esp+34h] [ebp-88h]\n  char *name; // [esp+38h] [ebp-84h] BYREF\n  char *s; // [esp+3Ch] [ebp-80h] BYREF\n  const char *v55; // [esp+40h] [ebp-7Ch] BYREF\n  int fd; // [esp+44h] [ebp-78h]\n  __int16 v57; // [esp+48h] [ebp-74h]\n  __int64 v58; // [esp+78h] [ebp-44h]\n\n  name = 0;\n  s = 0;\n  v55 = \"512\";\n  v50 = sub_80ABEAC(a2, \"^gpl:r:b:\", &name, &s, &v55);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  nbytes = sub_80623EC(v55, 0x1001Cu);\n  if ( nbytes < 0 )\n    return 1;\n  v4 = s;\n  if ( s )\n  {\n    if ( !name )\n    {\n      v5 = strrchr(s, 47);\n      if ( v5 )\n        v4 = v5 + 1;\n      name = v4;\n    }\n  }\n  else\n  {\n    s = name;\n  }\n  if ( !s || !*v2 )\n    sub_804CDC2();\n  v6 = sub_80B42FF(69, 135057961);\n  addr_len = (socklen_t *)sub_80B45BD(v7, v6);\n  v8 = s;\n  v9 = name;\n  n = nbytes + 4;\n  buf = (char *)sub_804DAFA(nbytes + 4);\n  v10 = (char *)sub_804DAFA(nbytes + 4);\n  fd = sub_804DF99(0, 2, *((unsigned __int16 *)addr_len + 2));\n  sub_80B4262();\n  v11 = buf + 2;\n  v44 = dword_80DBB9C & 1;\n  if ( *v9 != 45 || v9[1] )\n    v44 = sub_804DBE1(v9);\n  v12 = 1;\n  if ( (dword_80DBB9C & 1) == 0 )\n    v12 = 2;\n  v13 = strlen(v8);\n  v41 = v13 + 1;\n  if ( n <= v13 + 9\n    || (strcpy(v11, v8),\n        v14 = &v11[v41],\n        strcpy(v14, \"octet\"),\n        v15 = v14 + 6,\n        (unsigned int)(&buf[n - 1] - (v14 + 6)) <= 0x2C) )\n  {\n    sub_804D5F4(\"remote filename is too long\");\n    goto LABEL_92;\n  }\n  if ( nbytes != 512 )\n  {\n    strcpy(v14 + 6, \"blksize\");\n    v15 = &v14[snprintf(v14 + 14, 6u, \"%d\", nbytes) + 15];\n  }\n  strcpy(v15, \"tsize\");\n  v58 = 0LL;\n  fstat64();\n  v16 = (int)&v15[sprintf(v15 + 6, \"%llu\", v58) + 7];\n  v42 = 1;\n  v43 = 0;\n  v46 = 1;\n  v49 = 0;\n  while ( 2 )\n  {\n    LOBYTE(v17) = HIBYTE(v12);\n    HIBYTE(v17) = v12;\n    *(_WORD *)buf = v17;\n    v52 = v16 - (_DWORD)buf;\n    v51 = 12;\n    v18 = 100;\nLABEL_24:\n    addr = (struct sockaddr *)(addr_len + 1);\n    sub_804DFCD(v52, buf, fd, (struct sockaddr *)(addr_len + 1), *addr_len);\n    if ( v12 == 4 && (v43 & 1) != 0 )\n      return 0;\n    while ( 1 )\n    {\n      do\n      {\n        v57 = 1;\n        v21 = sub_80B2C0A(v18, 1u);\n        if ( !v21 )\n        {\n          if ( !--v51 )\n          {\n            sub_804D5F4(\"timeout\");\n            goto LABEL_86;\n          }\n          v18 += v18 >> 1;\n          if ( v18 > 2000 )\n            v18 = 2000;\n          goto LABEL_24;\n        }\n        if ( v21 != 1 )\n          goto LABEL_86;\n        if ( v49 )\n        {\n          v19 = sub_804E5BC(n, v10, fd);\n          if ( v19 < 0 )\n            goto LABEL_88;\n        }\n        else\n        {\n          v19 = recvfrom(fd, v10, n, 0, addr, addr_len);\n          if ( v19 < 0 )\n            goto LABEL_88;\n          sub_80B42C3(*addr_len, addr);\n          v49 = -1;\n        }\n      }\n      while ( v19 <= 3 );\n      v12 = __ROL2__(*(_WORD *)v10, 8);\n      HIBYTE(v20) = *((_WORD *)v10 + 1);\n      LOBYTE(v20) = HIBYTE(*((_WORD *)v10 + 1));\n      if ( v12 == 5 )\n      {\n        v22 = v19 == 4;\n        v23 = v20;\n        if ( v22 || !v10[4] )\n        {\n          v24 = &data;\n          if ( v20 <= 8u )\n            v24 = sub_804D2B4(byte_80CDE9D, v20);\n        }\n        else\n        {\n          v24 = v10 + 4;\n          v10[n - 1] = 0;\n        }\n        sub_804D5F4(\"server error: (%u) %s\", v23, v24);\nLABEL_86:\n        if ( v43 != 1 )\n          goto LABEL_92;\n        return 0;\n      }\n      if ( v46 )\n      {\n        if ( v12 != 6 )\n        {\n          n = 516;\n          if ( nbytes != 512 )\n          {\n            v47 = v20;\n            sub_804D5F4(\"falling back to blocksize 512\");\n            nbytes = 512;\n            v20 = v47;\n          }\n          goto LABEL_34;\n        }\n        v25 = v19 - 2;\n        v26 = v10 + 2;\n        v27 = 0;\n        v28 = 0;\n        while ( 2 )\n        {\n          v29 = 0;\n          while ( v26[v29] )\n          {\n            if ( ++v29 >= v25 )\n              goto LABEL_68;\n          }\n          if ( !v28 )\n          {\n            v48 = v27;\n            v30 = strcasecmp(v26, \"blksize\");\n            v28 = 0;\n            v27 = v48;\n            if ( !v30 )\n              v27 = 1;\n            goto LABEL_63;\n          }\n          if ( v27 )\n          {\n            nbytes = sub_80623EC(v26, nbytes);\n            if ( nbytes < 0 )\n            {\n              *(&qword_80DB778 + 3) = 8;\n              goto LABEL_89;\n            }\n            n = nbytes + 4;\n          }\n          else\n          {\nLABEL_63:\n            v31 = v29 + 1;\n            v26 += v31;\n            v25 -= v31;\n            v28 ^= 1u;\n            if ( v25 > 0 )\n              continue;\n          }\n          break;\n        }\nLABEL_68:\n        if ( (dword_80DBB9C & 1) != 0 )\n          v42 = 0;\n        goto LABEL_72;\n      }\nLABEL_34:\n      if ( ((unsigned __int8)dword_80DBB9C & (v12 == 3)) != 0 && v20 == v42 )\n        break;\n      if ( (dword_80DBB9C & 2) != 0 && v12 == 4 )\n      {\n        if ( v20 == v42 - 1 )\n        {\n          if ( (v43 & 1) == 0 )\n          {\n            v43 = 0;\n            goto LABEL_72;\n          }\n          return 0;\n        }\n        v12 = 4;\n      }\n      v46 = 0;\n    }\n    v34 = v19 - 4;\n    if ( v34 != sub_804E586(v34, v10 + 4) )\n    {\n      strcpy((char *)&qword_80DB778 + 4, \"write error\");\n      *(&qword_80DB778 + 3) = 3;\n      goto LABEL_89;\n    }\n    if ( v34 != nbytes )\n      v43 = 1;\nLABEL_72:\n    LOBYTE(v32) = HIBYTE(v42);\n    HIBYTE(v32) = v42;\n    *((_WORD *)buf + 1) = v32;\n    v16 = (int)(buf + 4);\n    ++v42;\n    if ( (dword_80DBB9C & 2) == 0 )\n    {\n      v12 = 4;\nLABEL_78:\n      v46 = 0;\n      continue;\n    }\n    break;\n  }\n  v33 = sub_804E5E3(v44, buf + 4, nbytes);\n  if ( v33 >= 0 )\n  {\n    if ( nbytes != v33 )\n      v43 = 1;\n    v16 += v33;\n    v12 = 3;\n    goto LABEL_78;\n  }\nLABEL_88:\n  strcpy((char *)&qword_80DB778 + 4, \"read error\");\nLABEL_89:\n  if ( *(&qword_80DB778 + 4) )\n    sub_804D5F4(\"%s\", (const char *)&qword_80DB778 + 4);\n  *(&qword_80DB778 + 1) = 5;\n  v35 = strlen((const char *)&qword_80DB778 + 4);\n  sub_804DFCD(v35 + 5, &qword_80DB778, fd, addr, *addr_len);\nLABEL_92:\n  if ( *name != 45 || name[1] )\n  {\n    v3 = v50 & 1;\n    if ( (v50 & 1) != 0 )\n    {\n      unlink(name);\n      return v3;\n    }\n  }\n  return 1;\n}\n"
    ],
    "sub_8062A4D": [
        "0x8062a4d",
        "int __cdecl sub_8062A4D(int a1, int a2)\n{\n  unsigned __int16 *v2; // ebp\n  int v3; // ecx\n  int v4; // ebx\n  int v5; // esi\n  int v6; // eax\n  int v7; // eax\n  int v8; // esi\n  __gid_t v9; // eax\n  __uid_t v10; // eax\n  const char *v11; // eax\n  int v12; // ebx\n  int v13; // esi\n  size_t v14; // edi\n  ssize_t v15; // eax\n  int i; // edi\n  int v17; // edx\n  int v18; // edx\n  char v19; // cl\n  bool v20; // zf\n  int v21; // edi\n  int v22; // eax\n  int v23; // edx\n  char v24; // t1\n  const char *v25; // eax\n  char *v26; // ebx\n  char *v27; // esi\n  int v29; // [esp+14h] [ebp-90h]\n  int v30; // [esp+18h] [ebp-8Ch]\n  _DWORD *v31; // [esp+1Ch] [ebp-88h]\n  int v32; // [esp+20h] [ebp-84h]\n  char *v33; // [esp+24h] [ebp-80h]\n  _BYTE *v34; // [esp+28h] [ebp-7Ch]\n  void *v35; // [esp+28h] [ebp-7Ch]\n  int v36; // [esp+2Ch] [ebp-78h]\n  int v37; // [esp+30h] [ebp-74h]\n  int optval; // [esp+34h] [ebp-70h]\n  int v39; // [esp+38h] [ebp-6Ch]\n  char *s2; // [esp+3Ch] [ebp-68h]\n  unsigned __int8 v41; // [esp+40h] [ebp-64h]\n  int v42; // [esp+44h] [ebp-60h]\n  int v43; // [esp+48h] [ebp-5Ch]\n  int v44; // [esp+48h] [ebp-5Ch]\n  void *v45; // [esp+4Ch] [ebp-58h]\n  int v46; // [esp+50h] [ebp-54h]\n  void *v47; // [esp+54h] [ebp-50h]\n  char *s1; // [esp+60h] [ebp-44h]\n  char *s1a; // [esp+60h] [ebp-44h]\n  const char *v50; // [esp+68h] [ebp-3Ch] BYREF\n  __useconds_t useconds; // [esp+6Ch] [ebp-38h] BYREF\n  int v52; // [esp+70h] [ebp-34h] BYREF\n  int v53; // [esp+74h] [ebp-30h] BYREF\n  int v54; // [esp+78h] [ebp-2Ch] BYREF\n  int v55; // [esp+7Ch] [ebp-28h] BYREF\n  int v56; // [esp+80h] [ebp-24h] BYREF\n  int v57; // [esp+84h] [ebp-20h] BYREF\n  int v58[2]; // [esp+88h] [ebp-1Ch] BYREF\n  int v59; // [esp+90h] [ebp-14h]\n\n  v2 = (unsigned __int16 *)sub_804DB2E(0x220u);\n  dword_80DBB80 = (int)v2;\n  v2[12] = -32102;\n  *((_DWORD *)v2 + 7) = 5;\n  v30 = sub_80ABEAC(a2, \"^FIlnrdvxt:i:m:p:q:s:w:z:f:4\", &v52, &useconds, &v53, &v54, &v55, &v50, &v56, &v57, v58);\n  v4 = a2 + 4 * optind;\n  if ( (v30 & 0x100) != 0 )\n    v5 = sub_80B40CC(255, 0);\n  else\n    v5 = 0;\n  v36 = 30;\n  if ( (v30 & 0x400) != 0 )\n    v36 = sub_80B40CC(255, 1);\n  if ( (v30 & 0x800) != 0 )\n    v2[12] = sub_80B4193();\n  v39 = 3;\n  if ( (v30 & 0x1000) != 0 )\n    v39 = sub_80B40CC(0x7FFFFFFF, 1);\n  if ( (v30 & 0x2000) != 0 && getuid() )\n    sub_804D5E0(\"you must be root\");\n  if ( (v30 & 0x4000) != 0 )\n    *((_DWORD *)v2 + 7) = sub_80B40CC(86400, 1);\n  optval = 0;\n  if ( (v30 & 0x8000) != 0 )\n    optval = sub_80B40CC(3600000, 0);\n  v32 = 1;\n  if ( (v30 & 0x10000) != 0 )\n    v32 = sub_80B40CC(v36, 1);\n  *((_DWORD *)v2 + 2) = sub_80B45BD(v3, v2[12]);\n  *((_DWORD *)v2 + 3) = 38;\n  if ( *(_DWORD *)(v4 + 4) )\n    *((_DWORD *)v2 + 3) = sub_80B40CC(0x8000, 38);\n  sub_80B3CDB();\n  v6 = sub_804DF99(1, 3, 2);\n  sub_804DC97(v6, 3);\n  if ( (v30 & 0x10) != 0 )\n    sub_80B4258();\n  v7 = sub_804DF99(0, 2, 2);\n  sub_804DC97(v7, 4);\n  if ( sub_80B424A(*((_DWORD *)v2 + 3), 7) )\n    sub_804D3C9((int)\"setsockopt(%s)\", \"SO_SNDBUF\");\n  if ( (v30 & 0x100) != 0 && sub_80B422B(1, 0, v5) )\n    sub_804D3C9((int)\"setsockopt(%s) %d\", \"TOS\", v5);\n  if ( (v30 & 0x10) != 0 )\n    sub_80B4258();\n  *(_DWORD *)v2 = sub_804DB2E(*((_DWORD *)v2 + 3));\n  *((_DWORD *)v2 + 5) = getpid();\n  *((_DWORD *)v2 + 1) = *(_DWORD *)v2 + 28;\n  if ( (v30 & 0x200) != 0 )\n    sub_80B4280();\n  if ( (v30 & 0x2000) != 0 )\n  {\n    v8 = sub_80B45C8();\n    if ( setsockopt(4, 0, 32, (const void *)(v8 + 4), *(_DWORD *)v8) )\n      sub_804D5E0(\"can't set multicast source interface\");\n    sub_804DFB3(*(_DWORD *)v8, (struct sockaddr *)(v8 + 4), 4);\n    free((void *)v8);\n  }\n  v9 = getgid();\n  sub_804DE5E(v9);\n  v10 = getuid();\n  sub_804DE74(v10);\n  v11 = (const char *)sub_80B46B6();\n  printf(\"traceroute to %s (%s)\", *(const char **)v4, v11);\n  if ( (v30 & 0x2000) != 0 )\n    printf(\" from %s\", v50);\n  printf(\", %d hops max, %d byte packets\\n\", v36, *((_DWORD *)v2 + 3));\n  v31 = sub_804DB8D(*((const void **)v2 + 2), **((_DWORD **)v2 + 2) + 4);\n  v45 = sub_804DB2E(**((_DWORD **)v2 + 2));\n  v47 = sub_804DB2E(**((_DWORD **)v2 + 2));\n  s2 = 0;\nLABEL_42:\n  if ( v36 >= v32 )\n  {\n    printf(\"%2d\", v32);\n    v37 = 0;\n    v12 = 0;\n    v29 = 0;\n    v33 = s2;\n    while ( 1 )\n    {\nLABEL_44:\n      if ( v33 - s2 >= v39 )\n      {\n        sub_804DD98(10);\n        if ( !v37 && (!v29 || v29 < v39 - 1) )\n        {\n          ++v32;\n          s2 = v33;\n          goto LABEL_42;\n        }\n        return 0;\n      }\n      sub_804DD8F();\n      if ( optval && v33 != s2 )\n        usleep(1000 * optval);\n      ++v33;\n      v13 = dword_80DBB80;\n      v34 = *(_BYTE **)(dword_80DBB80 + 4);\n      *v34 = (_BYTE)v33;\n      v34[1] = v32;\n      if ( sub_80B422B(2, 0, v32) )\n        sub_804D3C9((int)\"setsockopt(%s) %d\", \"TTL\", v32);\n      sub_80B435E();\n      v14 = *(_DWORD *)v13 + *(_DWORD *)(v13 + 12) - (_DWORD)v34;\n      v15 = sub_804DFCD(v14, v34, 4, (struct sockaddr *)(*(_DWORD *)(v13 + 8) + 4), **(_DWORD **)(v13 + 8));\n      if ( v14 != v15 )\n        sub_804D5F4(\"sent %d octets, ret=%d\", v14, v15);\n      v46 = sub_804EBDE();\n      v43 = 1000 * *((_DWORD *)v2 + 7);\n      for ( i = v46; ; i = v42 )\n      {\n        v58[1] = 3;\n        LOWORD(v59) = 1;\n        if ( v43 < 0\n          || sub_80B2C0A(v43, 1u) <= 0\n          || (v35 = v31 + 1,\n              s1 = (char *)sub_80B32E8(512, v13 + 32, 64, v31 + 1, v47, *v31),\n              v42 = sub_804EBDE(),\n              v43 -= (v42 - i) / 0x3E8u,\n              !s1) )\n        {\n          printf(\"  *\");\n          goto LABEL_44;\n        }\n        if ( (int)s1 >= 0 )\n        {\n          v17 = 4 * (*(_BYTE *)(v13 + 32) & 0xF);\n          if ( v17 + 7 < (int)s1 )\n            break;\n        }\nLABEL_103:\n        ;\n      }\n      s1a = &s1[-v17];\n      v18 = v13 + 32 + v17;\n      v19 = *(_BYTE *)v18;\n      v41 = *(_BYTE *)(v18 + 1);\n      *(_DWORD *)(v13 + 16) = 0;\n      if ( v41 == 4 )\n      {\n        *(_DWORD *)(v13 + 16) = (unsigned __int16)__ROL2__(*(_WORD *)(v18 + 6), 8);\n        if ( v19 == 11 )\n          goto LABEL_103;\n      }\n      else if ( v19 == 11 )\n      {\n        v20 = v41 == 0;\n        goto LABEL_65;\n      }\n      if ( v19 == 3 )\n        goto LABEL_66;\n      v20 = v19 == 0;\nLABEL_65:\n      if ( !v20 )\n        goto LABEL_103;\nLABEL_66:\n      v21 = 4 * (*(_DWORD *)(v18 + 8) & 0xF);\n      v22 = v18 + v21 + 8;\n      if ( (int)s1a <= v21 + 11 )\n        goto LABEL_103;\n      if ( *(_BYTE *)(v18 + 17) != 17 )\n        goto LABEL_103;\n      LOWORD(v18) = (_WORD)v33;\n      v23 = *(_DWORD *)(v13 + 24) + v18;\n      v24 = BYTE1(v23);\n      BYTE1(v23) = v23;\n      LOBYTE(v23) = v24;\n      if ( *(_WORD *)(v22 + 2) != (_WORD)v23 )\n        goto LABEL_103;\n      v44 = -1;\n      if ( v19 != 11 )\n        v44 = v41 + 1;\n      if ( !v12 || memcmp(v45, v35, *v31) )\n      {\n        v25 = (const char *)sub_80B46B6();\n        v26 = (char *)v25;\n        if ( (dword_80DBB9C & 8) != 0 )\n        {\n          printf(\"  %s\", v25);\n        }\n        else\n        {\n          if ( *((_WORD *)v31 + 2) == 2 && !v31[2] )\n          {\n            v27 = 0;\n          }\n          else\n          {\n            v25 = (const char *)sub_80B46A2(v29);\n            v27 = (char *)v25;\n            if ( !v25 )\n              v25 = v26;\n          }\n          printf(\"  %s (%s)\", v25, v26);\n          free(v27);\n        }\n        free(v26);\n        qmemcpy(v45, v35, *v31);\n      }\n      printf(\"  %u.%03u ms\", (v42 - v46) / 0x3E8u, (v42 - v46) % 0x3E8u);\n      if ( *((_WORD *)v31 + 2) == 2 && (v30 & 4) != 0 )\n        printf(\" (%d)\", *((unsigned __int8 *)v2 + 40));\n      v12 = 1;\n      if ( v44 != -1 )\n      {\n        v12 = v44 - 1;\n        switch ( v44 )\n        {\n          case 1:\n            printf(\" !N\");\n            goto LABEL_100;\n          case 2:\n            printf(\" !H\");\n            ++v29;\n            continue;\n          case 3:\n            printf(\" !P\");\n            goto LABEL_104;\n          case 4:\n            if ( *((_BYTE *)v2 + 40) <= 1u )\n              printf(\" !\");\nLABEL_104:\n            v37 = 1;\n            break;\n          case 5:\n            printf(\" !F-%d\", *((_DWORD *)v2 + 4));\n            goto LABEL_102;\n          case 6:\n            printf(\" !S\");\n            goto LABEL_100;\n          case 7:\n          case 8:\n            printf(\" !U\");\n            goto LABEL_100;\n          case 9:\n            printf(\" !I\");\n            goto LABEL_100;\n          case 10:\n          case 14:\n            printf(\" !A\");\n            goto LABEL_100;\n          case 11:\n          case 16:\n            printf(\" !C\");\n            goto LABEL_100;\n          case 12:\n          case 13:\n            printf(\" !T\");\n            goto LABEL_100;\n          case 15:\n            printf(\" !V\");\nLABEL_100:\n            ++v29;\n            break;\n          default:\n            printf(\" !<%d>\", v44 - 1);\nLABEL_102:\n            ++v29;\n            break;\n        }\n        v12 = 1;\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_806323C": [
        "0x806323c",
        "unsigned __int8 *__usercall sub_806323C@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // eax\n\n  while ( strcasecmp(a2, a1 + 1) )\n  {\n    v4 = *(unsigned __int8 *)a1;\n    if ( !(_BYTE)v4 )\n      sub_804CDC2();\n    a1 += v4;\n  }\n  return (unsigned __int8 *)(a1 - 1);\n}\n"
    ],
    "sub_8063268": [
        "0x8063268",
        "int __cdecl sub_8063268(int a1, int a2)\n{\n  const char *v2; // edx\n  unsigned __int8 *v3; // eax\n  int v4; // ecx\n  const char *v5; // edx\n  int v6; // eax\n  int v7; // eax\n  int v8; // eax\n  int v10[17]; // [esp+0h] [ebp-44h] BYREF\n\n  memset(v10, 0, 0x38u);\n  v2 = *(const char **)(a2 + 4);\n  if ( !v2 || (v3 = sub_806323C(\"\\aadd\", v2), v4 = *v3, v10[0] = v4, *(v3 - 1) != a1) )\n    sub_804CDC2();\n  v5 = *(const char **)(a2 + 8);\n  if ( v4 != 6 )\n  {\n    sub_804D67E((char *)&v10[1], v5);\n    switch ( v10[0] )\n    {\n      case 7:\n        v7 = sub_80B40CC(1, 0);\n        break;\n      case 0:\n        v6 = sub_80B40CC(4095, 0);\n        goto LABEL_10;\n      case 1:\n        goto LABEL_14;\n      default:\n        v7 = sub_80B40EC();\n        break;\n    }\n    v10[7] = v7;\n    LOWORD(v10[13]) = sub_80B40CC(7, 0);\n    goto LABEL_14;\n  }\n  v6 = *sub_806323C(byte_80CE019, v5);\nLABEL_10:\n  v10[7] = v6;\nLABEL_14:\n  v8 = sub_804DF99(0, 1, 2);\n  sub_804E029(v8, 0x8983u, (int)v10, \"ioctl error for %s\", *(const char **)(a2 + 4));\n  return 0;\n}\n"
    ],
    "sub_8063340": [
        "0x8063340",
        "void sub_8063340()\n{\n  if ( *(_BYTE *)(dword_80DBB80 + 80) )\n    sub_804D5E0(\"download timed out\");\n}\n"
    ],
    "sub_8063356": [
        "0x8063356",
        "int sub_8063356()\n{\n  int v0; // ebx\n  int result; // eax\n  int v2; // [esp-4h] [ebp-8h]\n\n  v0 = dword_80DBB80;\n  result = *(_DWORD *)(dword_80DBB80 + 76);\n  if ( result )\n  {\n    alarm(*(_DWORD *)(dword_80DBB80 + 76));\n    *(_BYTE *)(v0 + 80) = 1;\n    return v2;\n  }\n  return result;\n}\n"
    ],
    "sub_8063371": [
        "0x8063371",
        "FILE *sub_8063371()\n{\n  int v0; // eax\n  FILE *result; // eax\n  int v2; // [esp-8h] [ebp-Ch]\n  int v3; // [esp-4h] [ebp-8h]\n\n  sub_8063356();\n  v0 = sub_80B467D();\n  *(_BYTE *)(dword_80DBB80 + 80) = 0;\n  result = fdopen(v0, \"r+\");\n  if ( !result )\n    sub_804DAC9(v3, v2);\n  return result;\n}\n"
    ],
    "sub_80633A4": [
        "0x80633a4",
        "int __usercall sub_80633A4@<eax>(const char *a1@<eax>)\n{\n  int v1; // ebx\n\n  strlen(a1);\n  v1 = dword_80DBB80 + 104;\n  sub_80B3958(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\");\n  return v1;\n}\n"
    ],
    "sub_80633D9": [
        "0x80633d9",
        "int __fastcall sub_80633D9(int a1, const char *a2)\n{\n  int v3; // esi\n  int v4; // ebx\n  int v5; // esi\n  unsigned __int8 *i; // eax\n  unsigned __int8 v7; // cl\n\n  sub_8063356();\n  v3 = dword_80DBB80;\n  v4 = dword_80DBB80 + 104;\n  if ( !fgets_unlocked() )\n    sub_804D3C9((int)\"error getting response\");\n  *(_BYTE *)(v3 + 80) = 0;\n  v5 = *(unsigned __int8 *)strchrnul();\n  for ( i = (unsigned __int8 *)v4; ; ++i )\n  {\n    v7 = *i;\n    if ( !*i )\n      break;\n    if ( v7 <= 0x1Fu )\n    {\n      if ( v7 != 9 )\n        break;\n      *i = 32;\n    }\n  }\n  *i = 0;\n  if ( a2 && (dword_80DBB9C & 4) != 0 )\n    fprintf(stderr, a2, v4);\n  return v5;\n}\n"
    ],
    "sub_806345E": [
        "0x806345e",
        "int sub_806345E()\n{\n  int v0; // eax\n  int v2; // [esp-4h] [ebp-4h]\n\n  sub_804D5F4(\"restart failed\");\n  v0 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 8) = 0;\n  *(_DWORD *)(v0 + 12) = 0;\n  sub_804DD09(0, 0, 0);\n  return v2;\n}\n"
    ],
    "sub_806348B": [
        "0x806348b",
        "const char *__usercall sub_806348B@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  char *v3; // esi\n  char *v4; // eax\n  char *v5; // edi\n  const char *v6; // edi\n  char *v7; // ebp\n  char *v8; // eax\n  char *v9; // esi\n  char *v10; // eax\n  char *v11; // eax\n  char *v12; // esi\n  const char *v13; // eax\n\n  free(*(void **)a2);\n  v3 = sub_804DB46(a1);\n  *(_DWORD *)a2 = v3;\n  *(_DWORD *)(a2 + 12) = \"ftp\";\n  v4 = strstr(v3, \"://\");\n  if ( !v4 )\n  {\n    *(_DWORD *)(a2 + 16) = v3;\nLABEL_5:\n    *(_DWORD *)(a2 + 20) = 80;\n    *(_DWORD *)(a2 + 12) = \"http\";\n    goto LABEL_8;\n  }\n  v5 = v4;\n  *v4 = 0;\n  *(_DWORD *)(a2 + 16) = v4 + 3;\n  if ( strcmp(v3, \"ftp\") )\n  {\n    if ( strcmp(v3, \"http\") )\n    {\n      *v5 = 58;\n      sub_804D5E0(\"not an http or ftp url: %s\", v3);\n    }\n    goto LABEL_5;\n  }\n  *(_DWORD *)(a2 + 20) = 21;\nLABEL_8:\n  v6 = *(const char **)(a2 + 16);\n  v7 = strchr(v6, 47);\n  v8 = strchr(v6, 63);\n  v9 = v8;\n  if ( v7 && (!v8 || v7 <= v8) )\n    v9 = v7;\n  v10 = strchr(v6, 35);\n  if ( v9 )\n  {\n    if ( !v10 || v9 <= v10 )\n      goto LABEL_19;\n  }\n  else if ( !v10 )\n  {\n    *(_DWORD *)(a2 + 4) = &data;\n    goto LABEL_20;\n  }\n  v9 = v10;\nLABEL_19:\n  *v9 = 0;\n  *(_DWORD *)(a2 + 4) = v9 + 1;\nLABEL_20:\n  v11 = strrchr(*(const char **)(a2 + 16), 64);\n  v12 = v11;\n  if ( v11 )\n  {\n    *v11 = 0;\n    free(*(void **)(a2 + 8));\n    v13 = (const char *)sub_80B0948();\n    *(_DWORD *)(a2 + 8) = sub_804DB46(v13);\n    *(_DWORD *)(a2 + 16) = v12 + 1;\n  }\n  return a1;\n}\n"
    ],
    "sub_80635AC": [
        "0x80635ac",
        "int __usercall sub_80635AC@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  char v3; // al\n  int v4; // edx\n  char v5; // si\n  const char *v6; // edi\n  char v7; // bp\n  int v8; // ecx\n  int v9; // edi\n  bool j; // zf\n  unsigned __int8 *v11; // eax\n  int v12; // eax\n  _BYTE *i; // [esp+0h] [ebp-14h]\n\n  v3 = sub_80633D9(a2, \"  %s\\n\");\n  v4 = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 + 104) )\n    return 0;\n  v5 = v3;\n  v6 = (const char *)(dword_80DBB80 + 104);\n  for ( i = (_BYTE *)(dword_80DBB80 + 104); ; ++i )\n  {\n    LOBYTE(v4) = *i;\n    v7 = *i | 0x20;\n    if ( (unsigned __int8)(*i - 48) > 9u )\n    {\n      v8 = v4 - 45;\n      LOBYTE(v8) = (unsigned __int8)(v4 - 45) <= 1u;\n      if ( !((unsigned __int8)v8 | ((unsigned __int8)(v7 - 97) <= 0x19u)) && (_BYTE)v4 != 95 )\n        break;\n    }\n    *i = v7;\n  }\n  if ( (_BYTE)v4 != 58 )\n    sub_804D5E0(\"bad header line: %s\", v6);\n  *i = 0;\n  v9 = sub_80B2E8C(v8, v4);\n  for ( j = v5 == 10; !j; j = v12 == 10 )\n  {\n    v11 = *(unsigned __int8 **)(a1 + 16);\n    if ( (unsigned int)v11 >= *(_DWORD *)(a1 + 24) )\n    {\n      v12 = __fgetc_unlocked();\n      if ( v12 == -1 )\n        return v9;\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 16) = v11 + 1;\n      v12 = *v11;\n    }\n  }\n  return v9;\n}\n"
    ],
    "sub_8063662": [
        "0x8063662",
        "ssize_t __usercall sub_8063662@<eax>(ssize_t result@<eax>, int a2@<ecx>)\n{\n  ssize_t v2; // ebp\n  int v3; // ebx\n  int v4; // esi\n  int v5; // edi\n  int v6; // edx\n  __int64 v7; // [esp+0h] [ebp-1Ch]\n\n  if ( (dword_80DBB9C & 2) == 0 )\n  {\n    v2 = result;\n    v3 = dword_80DBB80;\n    if ( result == -1 )\n      sub_80B123C(a2, *(_DWORD *)(dword_80DBB80 + 24));\n    v7 = *(_QWORD *)(v3 + 16);\n    v4 = 0;\n    v5 = 0;\n    if ( !*(_BYTE *)(v3 + 92) && *(_BYTE *)(v3 + 93) )\n    {\n      v5 = (unsigned __int64)(*(_QWORD *)v3 + *(_QWORD *)(v3 + 8) + v7) >> 32;\n      v4 = *(_DWORD *)v3 + *(_DWORD *)(v3 + 8) + v7;\n    }\n    result = sub_80B1258(v7, HIDWORD(v7), v4, v5);\n    if ( !v2 )\n    {\n      *(_DWORD *)(v3 + 44) = 0;\n      result = sub_804D830(10, v6);\n      *(_DWORD *)(v3 + 16) = 0;\n      *(_DWORD *)(v3 + 20) = 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8063704": [
        "0x8063704",
        "ssize_t __usercall sub_8063704@<eax>(FILE *a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // ecx\n  int v4; // ecx\n  int v5; // ebx\n  signed int v6; // eax\n  int v7; // ecx\n  int v8; // edi\n  int v9; // ecx\n  __int64 v10; // kr00_8\n  int v11; // ecx\n  int v12; // ebx\n  const char *v13; // edi\n  signed __int64 v14; // rax\n  int v15; // ebx\n  int v16; // eax\n  int v17; // ecx\n  int v18; // edx\n  int v20; // [esp-4h] [ebp-24h]\n  int v21; // [esp+0h] [ebp-20h]\n  int v22; // [esp+4h] [ebp-1Ch]\n\n  v2 = dword_80DBB80;\n  v21 = *(_DWORD *)(dword_80DBB80 + 76);\n  fileno_unlocked(a1);\n  sub_8063662(-1, v3);\n  v4 = v20;\n  if ( *(_BYTE *)(v2 + 92) )\n  {\nLABEL_23:\n    sub_80633D9(v4, 0);\n    *(_DWORD *)dword_80DBB7C = 0;\n    v12 = dword_80DBB80;\n    v13 = (const char *)(dword_80DBB80 + 104);\n    v14 = strtoull((const char *)(dword_80DBB80 + 104), 0, 16);\n    *(_QWORD *)v12 = v14;\n    if ( v14 < 0 || *(_DWORD *)dword_80DBB7C )\n      sub_804D5E0(\"bad chunk length '%s'\", v13);\n    if ( !v14 )\n      goto LABEL_28;\n    *(_BYTE *)(v12 + 93) = 1;\n  }\n  sub_804D61C();\n  while ( 1 )\n  {\n    clearerr(a1);\n    *(_DWORD *)dword_80DBB7C = 0;\n    v5 = dword_80DBB80;\n    if ( *(_BYTE *)(dword_80DBB80 + 93) && (v6 = *(_DWORD *)dword_80DBB80, *(__int64 *)dword_80DBB80 <= 4095) )\n    {\n      if ( v6 <= 0 )\n        goto LABEL_21;\n    }\n    else\n    {\n      v6 = 4096;\n    }\n    v22 = dword_80DBB80 + 104;\n    v8 = fread((void *)(dword_80DBB80 + 104), 1u, v6, a1);\n    if ( v8 <= 0 )\n      break;\n    sub_804DCAD(v8, v22);\n    *(_QWORD *)(v5 + 16) += v8;\n    if ( *(_BYTE *)(v5 + 93) )\n    {\n      v10 = *(_QWORD *)v5 - v8;\n      *(_QWORD *)v5 = v10;\n      v9 = v10 | HIDWORD(v10);\n      if ( !v10 )\n        goto LABEL_21;\n    }\n    v21 = *(_DWORD *)(v5 + 76);\nLABEL_20:\n    sub_8063662(1, v9);\n  }\n  if ( *(_DWORD *)dword_80DBB7C == 11 )\n  {\n    if ( !sub_80B2C0A(1000, 1u) )\n    {\n      if ( v21 )\n      {\n        if ( !--v21 )\n        {\n          sub_8063662(0, v9);\n          sub_804D5E0(\"download timed out\");\n        }\n      }\n    }\n    goto LABEL_20;\n  }\n  if ( (a1->_flags & 8) != 0 )\n  {\n    sub_8063662(0, v7);\n    sub_804D3C9((int)\"read error\");\n  }\nLABEL_21:\n  clearerr(a1);\n  sub_804D646();\n  if ( *(_BYTE *)(v5 + 92) )\n  {\n    sub_80633D9(v11, 0);\n    goto LABEL_23;\n  }\nLABEL_28:\n  v15 = dword_80DBB80;\n  v16 = lseek64();\n  if ( v18 != -1 || v16 != -1 )\n    ftruncate64();\n  *(_WORD *)(v15 + 92) = 256;\n  return sub_8063662(0, v17);\n}\n"
    ],
    "sub_80638F2": [
        "0x80638f2",
        "int __usercall sub_80638F2@<eax>(FILE *stream@<ecx>, const char *a2@<eax>, const char *a3@<edx>)\n{\n  const char *v5; // ebx\n  int v6; // ebx\n  int result; // eax\n\n  if ( a2 )\n  {\n    v5 = a3;\n    if ( !a3 )\n      v5 = &data;\n    fprintf(stream, \"%s%s\\r\\n\", a2, v5);\n    if ( (dword_80DBB9C & 4) != 0 )\n      fprintf(stderr, \"--> %s%s\\n\\n\", a2, v5);\n    fflush(stream);\n  }\n  v6 = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + 107) = 0;\n  do\n  {\n    do\n      sub_80633D9((int)stream, \"%s\\n\");\n    while ( (unsigned __int8)(*(_BYTE *)(v6 + 104) - 48) > 9u );\n  }\n  while ( *(_BYTE *)(v6 + 107) != 32 );\n  *(_BYTE *)(v6 + 107) = 0;\n  result = sub_80B4187();\n  *(_BYTE *)(v6 + 107) = 32;\n  return result;\n}\n"
    ],
    "sub_8063977": [
        "0x8063977",
        "int __cdecl sub_8063977(int a1, int a2)\n{\n  _DWORD *v2; // ebp\n  const char *v3; // esi\n  _BYTE *v4; // eax\n  int v5; // ebx\n  char *v6; // ebx\n  const char *v7; // eax\n  const char *v8; // esi\n  FILE *v9; // edi\n  const char *v10; // eax\n  int v11; // ebx\n  const char *v12; // eax\n  char *v13; // eax\n  char *v14; // edi\n  char *v15; // eax\n  char v16; // dl\n  char *v17; // eax\n  int v18; // ecx\n  char v19; // al\n  int v20; // eax\n  char *v21; // eax\n  int v22; // ecx\n  int v23; // eax\n  int v24; // edx\n  char *v25; // esi\n  FILE *v26; // eax\n  FILE *v27; // esi\n  const char *v28; // eax\n  const char *v29; // eax\n  const char *v30; // eax\n  const char *v31; // edi\n  size_t v32; // eax\n  int v33; // ecx\n  int v34; // edx\n  int v35; // ecx\n  const char *v36; // eax\n  int v37; // eax\n  const char *v38; // edi\n  _BYTE *i; // eax\n  int v40; // eax\n  __int64 v41; // rax\n  const char *v42; // eax\n  int v43; // eax\n  const char *v44; // ebx\n  char *v45; // eax\n  char *v46; // edx\n  int v47; // eax\n  int v48; // eax\n  int v49; // ebx\n  __int64 v50; // rax\n  int v51; // ebx\n  int v52; // eax\n  int v54; // [esp+4h] [ebp-68h]\n  int v55; // [esp+4h] [ebp-68h]\n  char v56; // [esp+8h] [ebp-64h]\n  void *v57; // [esp+8h] [ebp-64h]\n  int v58; // [esp+Ch] [ebp-60h]\n  int v59; // [esp+Ch] [ebp-60h]\n  char *v60; // [esp+Ch] [ebp-60h]\n  char *v61; // [esp+10h] [ebp-5Ch]\n  char v62; // [esp+17h] [ebp-55h]\n  char *ptr; // [esp+18h] [ebp-54h]\n  char *v64; // [esp+1Ch] [ebp-50h]\n  const char *v65; // [esp+20h] [ebp-4Ch]\n  int v66; // [esp+24h] [ebp-48h]\n  void *v67; // [esp+28h] [ebp-44h] BYREF\n  void *v68; // [esp+2Ch] [ebp-40h] BYREF\n  void *v69; // [esp+34h] [ebp-38h]\n  const char *v70; // [esp+38h] [ebp-34h]\n  void *v71; // [esp+3Ch] [ebp-30h]\n  int v72; // [esp+40h] [ebp-2Ch]\n  void *v73; // [esp+44h] [ebp-28h] BYREF\n  char *v74; // [esp+48h] [ebp-24h]\n  char *v75; // [esp+4Ch] [ebp-20h]\n  const char *v76; // [esp+50h] [ebp-1Ch]\n  char *v77; // [esp+54h] [ebp-18h]\n  int v78; // [esp+58h] [ebp-14h]\n\n  v67 = 0;\n  v2 = sub_804DB2E(0x1068u);\n  dword_80DBB80 = (int)v2;\n  v2[19] = 900;\n  signal(14, (__sighandler_t)sub_8063340);\n  v2[17] = \"on\";\n  v2[18] = \"Wget\";\n  sub_80ABEC2(a2, \"^cqSO:P:Y:U:T:+t:n::\", \"continue\", v2 + 16, v2 + 12, v2 + 17, v2 + 18, v2 + 19, 0, 0, &v67, v2 + 13);\n  v64 = (char *)(a2 + 4 * optind);\n  v3 = (const char *)v67;\n  if ( v67 )\n  {\n    v5 = 0;\n    do\n    {\n      v5 += strlen(*((const char **)v3 + 1)) + 2;\n      v3 = *(const char **)v3;\n    }\n    while ( v3 );\n    v6 = (char *)sub_804DAFA(v5 + 1);\n    v2[14] = v6;\n    while ( v67 )\n    {\n      v7 = (const char *)sub_80AFB01();\n      v58 = sprintf(v6, \"%s\\r\\n\", v7);\n      v8 = \"Host:\";\n      v56 = 1;\n      while ( *v8 )\n      {\n        if ( strstr(v6, v8) == v6 )\n        {\n          *((_BYTE *)v2 + 60) |= v56;\n          break;\n        }\n        v56 *= 2;\n        v8 += strlen(v8) + 1;\n      }\n      v6 += v58;\n    }\n  }\n  v2[21] = -1;\n  v2[22] = 705;\n  v4 = (_BYTE *)v2[16];\n  if ( v4 )\n  {\n    if ( *v4 == 45 && !v4[1] )\n    {\n      v2[21] = 1;\n      dword_80DBB9C &= ~1u;\n    }\n    v2[22] = 577;\n  }\n  while ( 1 )\n  {\n    v10 = *(const char **)v64;\n    if ( !*(_DWORD *)v64 )\n      break;\n    v64 += 4;\n    v68 = 0;\n    v73 = 0;\n    v69 = 0;\n    v75 = 0;\n    sub_806348B(v10, (int)&v73);\n    v11 = dword_80DBB80;\n    if ( !strcmp(*(const char **)(dword_80DBB80 + 68), \"off\") )\n      goto LABEL_29;\n    v12 = \"http_proxy\";\n    if ( *v76 == 102 )\n      v12 = \"ftp_proxy\";\n    v13 = getenv(v12);\n    if ( v13 && *v13 )\n    {\n      sub_806348B(v13, (int)&v68);\n      v62 = 1;\n    }\n    else\n    {\nLABEL_29:\n      v70 = v76;\n      v72 = v78;\n      v68 = sub_804DB46(v77);\n      v71 = v68;\n      v62 = 0;\n    }\n    v14 = v77;\n    if ( *v77 == 91 )\n    {\n      if ( strchr(v77, 37) )\n      {\n        v15 = strchr(v14, 93);\n        if ( v15 )\n        {\n          v16 = v15[1];\n          if ( !v16 || v16 == 58 )\n            sub_80B2C69(v54, v15);\n        }\n      }\n    }\n    v61 = 0;\n    if ( (dword_80DBB9C & 8) == 0 )\n    {\n      v17 = sub_804D32D(v74);\n      *(_DWORD *)(v11 + 64) = v17;\n      v19 = *v17;\n      if ( !v19 || v19 == 47 )\n        *(_DWORD *)(v11 + 64) = \"index.html\";\n      v20 = *(_DWORD *)(v11 + 48);\n      if ( v20 )\n        v21 = (char *)sub_804D2D1(v20, *(_BYTE **)(v11 + 64), v18);\n      else\n        v21 = sub_804DB46(*(const char **)(v11 + 64));\n      v61 = v21;\n      *(_DWORD *)(v11 + 64) = v21;\n    }\n    *(_DWORD *)(v11 + 24) = sub_804D32D(*(const char **)(v11 + 64));\n    *(_DWORD *)(v11 + 8) = 0;\n    *(_DWORD *)(v11 + 12) = 0;\n    if ( (dword_80DBB9C & 1) != 0 )\n    {\n      v23 = open64();\n      *(_DWORD *)(v11 + 84) = v23;\n      if ( v23 >= 0 )\n      {\n        *(_DWORD *)(v11 + 8) = sub_804DD09(0, 0, 2);\n        *(_DWORD *)(v11 + 12) = v24;\n      }\n    }\n    ptr = 0;\n    v66 = 5;\n    while ( 1 )\n    {\n      v57 = (void *)sub_80B45BD(v22, v72);\n      if ( (dword_80DBB9C & 2) == 0 )\n      {\n        v25 = (char *)sub_80B46AC();\n        fprintf(stderr, \"Connecting to %s (%s)\\n\", (const char *)v71, v25);\n        free(v25);\n      }\nLABEL_50:\n      *(_WORD *)(v11 + 92) = 0;\n      if ( !v62 && *v76 == 102 )\n        break;\n      v26 = sub_8063371();\n      v27 = v26;\n      if ( v62 )\n      {\n        fprintf(v26, \"GET %s://%s/%s HTTP/1.1\\r\\n\", v76, v77, v74);\n      }\n      else\n      {\n        v28 = \"BLKRAGET\" + 5;\n        if ( (dword_80DBB9C & 0x800) != 0 )\n          v28 = \"POST\";\n        fprintf(v27, \"%s /%s HTTP/1.1\\r\\n\", v28, v74);\n      }\n      if ( (*(_BYTE *)(v11 + 60) & 1) == 0 )\n        fprintf(v27, \"Host: %s\\r\\n\", v77);\n      if ( (*(_BYTE *)(v11 + 60) & 2) == 0 )\n        fprintf(v27, \"User-Agent: %s\\r\\n\", *(const char **)(v11 + 72));\n      fputs(\"Connection: close\\r\\n\", v27);\n      if ( v75 && (*(_BYTE *)(v11 + 60) & 8) == 0 )\n      {\n        v29 = (const char *)sub_80633A4(v75);\n        fprintf(v27, \"Authorization: Basic %s\\r\\n\", v29);\n      }\n      if ( v62 && v69 && (*(_BYTE *)(v11 + 60) & 0x10) == 0 )\n      {\n        v30 = (const char *)sub_80633A4((const char *)v69);\n        fprintf(v27, \"Proxy-Authorization: Basic %s\\r\\n\", v30);\n      }\n      if ( *(_QWORD *)(v11 + 8) && (*(_BYTE *)(v11 + 60) & 4) == 0 )\n        fprintf(v27, \"Range: bytes=%llu-\\r\\n\", *(_QWORD *)(v11 + 8));\n      if ( *(_DWORD *)(v11 + 56) )\n        fputs_unlocked();\n      if ( (dword_80DBB9C & 0x800) != 0 )\n      {\n        v31 = *(const char **)(v11 + 52);\n        v32 = strlen(v31);\n        fprintf(v27, \"Content-Type: application/x-www-form-urlencoded\\r\\nContent-Length: %u\\r\\n\\r\\n%s\", v32, v31);\n      }\n      else\n      {\n        fputs(\"\\r\\n\", v27);\n      }\n      fflush(v27);\n      while ( 1 )\n      {\n        sub_80633D9(v33, \"  %s\\n\");\n        v65 = (const char *)(v11 + 104);\n        sub_80B2E9F();\n        v36 = (const char *)sub_80B2E8C(v35, v34);\n        v37 = atoi(v36);\n        v59 = v37;\n        if ( v37 > 204 )\n        {\n          if ( v37 == 206 )\n          {\n            if ( *(_QWORD *)(v11 + 8) )\n              goto LABEL_94;\n          }\n          else if ( v37 >= 206 && (unsigned int)(v37 - 300) <= 3 )\n          {\n            goto LABEL_94;\n          }\nLABEL_91:\n          sub_804D5E0(\"server returned error: %s\", v65);\n        }\n        if ( v37 >= 200 )\n          break;\n        if ( v37 && v37 != 100 )\n          goto LABEL_91;\n        while ( sub_80635AC((int)v27, v33) )\n          ;\n      }\n      if ( *(_QWORD *)(v11 + 8) )\n        sub_806345E();\n      do\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\nLABEL_94:\n            v38 = (const char *)sub_80635AC((int)v27, v33);\n            if ( !v38 )\n            {\n              v9 = v27;\n              goto LABEL_19;\n            }\n            for ( i = (_BYTE *)strchrnul(); v38 <= --i && (*i == 9 || *i == 32); *i = 0 )\n              ;\n            v40 = sub_804D222(\"content-length\", v65) + 1;\n            if ( (_BYTE)v40 != 1 )\n              break;\n            v41 = sub_804EC9E(v38, 0, 10);\n            *(_QWORD *)v11 = v41;\n            if ( v41 < 0 || *(_DWORD *)dword_80DBB7C )\n              sub_804D5E0(\"content-length %s is garbage\", v38);\n            *(_BYTE *)(v11 + 93) = 1;\n          }\n          if ( (_BYTE)v40 != 2 )\n            break;\n          v42 = (const char *)sub_80B2F23();\n          v43 = strcmp(v42, \"chunked\");\n          v33 = v55;\n          if ( v43 )\n            sub_804D5E0(\"transfer encoding '%s' is not supported\", v38);\n          *(_BYTE *)(v11 + 92) = 1;\n        }\n      }\n      while ( (_BYTE)v40 != 3 || v59 <= 299 );\n      if ( !--v66 )\n        sub_804D5E0(\"too many redirections\");\n      fclose(v27);\n      if ( *v38 == 47 )\n      {\n        free(ptr);\n        ptr = sub_804DB46(v38 + 1);\n        v74 = ptr;\n        goto LABEL_50;\n      }\n      sub_806348B(v38, (int)&v73);\n      if ( v62 )\n        goto LABEL_50;\n      free(v68);\n      v68 = 0;\n      v70 = v76;\n      v71 = v77;\n      v72 = v78;\n      free(v57);\n    }\n    v27 = sub_8063371();\n    if ( sub_80638F2(v27, 0, 0) != 220 )\n      sub_804D5E0(\"%s\", dword_80DBB80 + 104);\n    v44 = \"busybox\";\n    if ( v75 )\n    {\n      v45 = strchr(v75, 58);\n      v44 = v45;\n      if ( v45 )\n      {\n        *v45 = 0;\n        v44 = v45 + 1;\n      }\n    }\n    v46 = v75;\n    if ( !v75 )\n      v46 = \"anonymous\";\n    v47 = sub_80638F2(v27, \"USER \", v46);\n    if ( v47 != 230 && (v47 != 331 || sub_80638F2(v27, \"PASS \", v44) != 230) )\n      sub_804D5E0(\"ftp login: %s\", dword_80DBB80 + 104);\n    sub_80638F2(v27, \"TYPE I\", 0);\n    v48 = sub_80638F2(v27, \"SIZE \", v74);\n    v49 = dword_80DBB80;\n    if ( v48 == 213 )\n    {\n      v50 = sub_804EC9E((const char *)(dword_80DBB80 + 108), 0, 10);\n      *(_QWORD *)v49 = v50;\n      if ( v50 < 0 || *(_DWORD *)dword_80DBB7C )\n        sub_804D5E0(\"bad SIZE value '%s'\", v49 + 108);\n      *(_BYTE *)(v49 + 93) = 1;\n    }\n    if ( sub_80638F2(v27, \"EPSV\", 0) != 229 && sub_80638F2(v27, \"PASV\", 0) != 227\n      || (v60 = (char *)(v49 + 104), sub_806427C() < 0) )\n    {\n      sub_804D5E0(\"bad response to %s: %s\", \"PASV\", (const char *)(v49 + 104));\n    }\n    sub_80B435E();\n    v9 = sub_8063371();\n    if ( *(_QWORD *)(v49 + 8) )\n    {\n      sprintf(v60, \"REST %llu\", *(_QWORD *)(v49 + 8));\n      if ( sub_80638F2(v27, (const char *)(v49 + 104), 0) == 350 )\n        *(_QWORD *)v49 -= *(_QWORD *)(v49 + 8);\n      else\n        sub_806345E();\n    }\n    if ( sub_80638F2(v27, \"RETR \", v74) > 150 )\n      sub_804D5E0(\"bad response to %s: %s\", \"RETR\", v60);\nLABEL_19:\n    free(v57);\n    if ( (dword_80DBB9C & 0x1000) == 0 )\n    {\n      v51 = dword_80DBB80;\n      if ( *(int *)(dword_80DBB80 + 84) < 0 )\n        *(_DWORD *)(v51 + 84) = sub_804DBE1(*(const char **)(dword_80DBB80 + 64));\n      sub_8063704(v9);\n      if ( (dword_80DBB9C & 8) == 0 )\n      {\n        sub_804DCF3(*(_DWORD *)(v51 + 84));\n        *(_DWORD *)(v51 + 84) = -1;\n      }\n    }\n    if ( v27 != v9 )\n    {\n      fclose(v9);\n      if ( sub_80638F2(v27, 0, 0) != 226 )\n        sub_804D5E0(\"ftp error: %s\", dword_80DBB80 + 104);\n    }\n    fclose(v27);\n    free(v68);\n    free(v73);\n    free(v69);\n    free(v75);\n    free(v61);\n    free(ptr);\n  }\n  v52 = v2[21];\n  if ( v52 >= 0 )\n    sub_804DCF3(v52);\n  return 0;\n}\n"
    ],
    "sub_806427C": [
        "0x806427c",
        "int __usercall sub_806427C@<eax>(int a1@<eax>)\n{\n  char *v2; // eax\n  char *v3; // eax\n  int v5; // esi\n  char *v6; // eax\n  char *v7; // eax\n  char *v8; // eax\n\n  if ( *(_BYTE *)(a1 + 2) == 55 )\n  {\n    v2 = strrchr((const char *)a1, 41);\n    if ( v2 )\n      *v2 = 0;\n    v3 = strrchr((const char *)a1, 44);\n    if ( v3 )\n    {\n      *v3 = 0;\n      v5 = sub_80B40CC(255, 0);\n      v6 = strrchr((const char *)a1, 44);\n      if ( v6 )\n      {\n        *v6 = 0;\n        return v5 + (sub_80B40CC(255, 0) << 8);\n      }\n    }\n    return -1;\n  }\n  v7 = strrchr((const char *)a1, 124);\n  if ( !v7 )\n    return -1;\n  *v7 = 0;\n  v8 = strrchr((const char *)a1, 124);\n  if ( !v8 )\n    return -1;\n  *v8 = 0;\n  return sub_80B40CC(0xFFFF, 0);\n}\n"
    ],
    "sub_8064315": [
        "0x8064315",
        "int __usercall sub_8064315@<eax>(int a1@<eax>)\n{\n  _BYTE *v2; // eax\n  const char *v3; // edx\n  int v4; // esi\n  int v5; // eax\n  const char *v6; // edx\n  int v7; // eax\n\n  while ( 1 )\n  {\n    v2 = *(_BYTE **)a1;\n    if ( !*(_DWORD *)a1 || *v2 != 45 )\n      break;\n    v3 = v2 + 1;\n    v4 = a1 + 4;\n    if ( v2[1] == 45 )\n    {\n      v3 = v2 + 2;\n      if ( !v2[2] )\n      {\n        a1 += 4;\n        break;\n      }\n    }\n    v5 = sub_804D254(\"oneline\", v3);\n    if ( v5 < 0 )\n      goto LABEL_7;\n    v6 = *(const char **)(a1 + 4);\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        if ( !v6 )\nLABEL_7:\n          sub_804CDC2();\n        v7 = sub_804D222(\"inet\", v6);\n        if ( v7 < 0 )\n          sub_8069C50();\n      }\n      else\n      {\n        v7 = v5 - 2;\n        v4 = a1;\n      }\n      byte_80DB764 = byte_80CE4F7[v7];\n      v4 += 4;\n    }\n    else\n    {\n      byte_80DBBA6 = 1;\n    }\n    a1 = v4;\n  }\n  byte_80DBBA5 = byte_80DBBA6 == 0 ? 10 : 92;\n  return a1;\n}\n"
    ],
    "sub_80643B2": [
        "0x80643b2",
        "int __fastcall sub_80643B2(_DWORD *a1, _DWORD *a2)\n{\n  char *v3; // ebx\n\n  v3 = (char *)sub_804DB2E(*a2 + 4);\n  qmemcpy(v3 + 4, a2, *a2);\n  while ( *a1 )\n    a1 = (_DWORD *)*a1;\n  *a1 = v3;\n  sub_80691EB(0);\n  return 0;\n}\n"
    ],
    "sub_80643FF": [
        "0x80643ff",
        "int sub_80643FF()\n{\n  if ( sub_8068AAE(unk_80DB794, *(&qword_80DB778 + 1)) >= 0 )\n  {\n    unk_80DB794 = 0;\n    return 0;\n  }\n  else\n  {\n    sub_804D3A5((int)\"can't send flush request\");\n    return -1;\n  }\n}\n"
    ],
    "sub_8064435": [
        "0x8064435",
        "int __fastcall sub_8064435(int a1, int a2)\n{\n  int v2; // ecx\n  unsigned int v3; // ebp\n  int v5; // eax\n  const char *v6; // eax\n  _DWORD *v7; // eax\n  int v8; // edx\n  const char *v9; // eax\n  char v10; // al\n  int v11; // ecx\n  int v12; // edi\n  const char *v13; // eax\n  const char *v14; // eax\n  const char *v15; // eax\n  const char *v16; // eax\n  char v17; // al\n  char v18; // al\n  char v19; // al\n  char v20; // al\n  int v21; // esi\n  char *v22; // eax\n  int v24; // [esp-8h] [ebp-BCh]\n  int v25; // [esp-4h] [ebp-B8h]\n  unsigned __int16 *v26; // [esp+4h] [ebp-B0h]\n  unsigned __int16 *v27; // [esp+8h] [ebp-ACh]\n  int v28; // [esp+Ch] [ebp-A8h]\n  int v29; // [esp+10h] [ebp-A4h]\n  int v30; // [esp+14h] [ebp-A0h]\n  int v31; // [esp+18h] [ebp-9Ch]\n  char dest[144]; // [esp+24h] [ebp-90h] BYREF\n\n  v2 = *(_DWORD *)(a2 + 4);\n  if ( (unsigned __int16)(v2 - 20) > 1u )\n    return 0;\n  v5 = *(_DWORD *)a2 - 24;\n  if ( v5 < 0 )\n  {\n    sub_804D5F4(\"wrong nlmsg len %d\", v5);\n    return -1;\n  }\n  if ( *(&qword_80DB778 + 1) && (_WORD)v2 != 20 )\n    return 0;\n  sub_806901E(v5);\n  if ( !v27 )\n    v27 = v26;\n  if ( !v26 )\n    v26 = v27;\n  if ( stream && stream != *(FILE **)(a2 + 20) )\n    return 0;\n  if ( ((*(&unk_80DB780 + 1) ^ *(unsigned __int8 *)(a2 + 19)) & (unsigned int)MEMORY[0x80DB788]) != 0 )\n    return 0;\n  v3 = unk_80DB790 & ((unsigned int)unk_80DB78C ^ *(unsigned __int8 *)(a2 + 18));\n  if ( v3 )\n    return 0;\n  if ( qword_80DB778 )\n  {\n    v6 = (const char *)(v28 ? v28 + 4 : sub_80692E5());\n    if ( fnmatch(qword_80DB778, v6, 0) )\n      return 0;\n  }\n  if ( !(_BYTE)qword_80DB7A8\n    || !v27\n    || (memset(dest, 0, 0x14u),\n        dest[0] = *(_BYTE *)(a2 + 16),\n        qmemcpy(&dest[4], v27 + 2, *v27 - 4),\n        !sub_8069CEC(SHIWORD(qword_80DB7A8), &qword_80DB7A8)) )\n  {\n    if ( *(&qword_80DB778 + 1) )\n    {\n      if ( *(_DWORD *)a2 + ((unk_80DB794 + 3) & 0xFFFFFFFC) <= (unsigned int)dword_80DB798 || !sub_80643FF() )\n      {\n        v7 = (_DWORD *)(*(&qword_80DB778 + 1) + ((unk_80DB794 + 3) & 0xFFFFFFFC));\n        qmemcpy(v7, (const void *)a2, *(_DWORD *)a2);\n        v7[1] = 65557;\n        v8 = *(_DWORD *)(unk_80DB780 + 28) + 1;\n        *(_DWORD *)(unk_80DB780 + 28) = v8;\n        v7[2] = v8;\n        unk_80DB794 = (size_t)v7 + *(_DWORD *)a2 - *(&qword_80DB778 + 1);\n        dword_80DB7A4 = 1;\n        return v3;\n      }\n      return -1;\n    }\n    if ( *(_WORD *)(a2 + 4) == 21 )\n      printf(\"Deleted \");\n    if ( BYTE2(pmatch[0].rm_so) )\n    {\n      v9 = (const char *)sub_80692E5();\n      printf(\"%u: %s\", *(_DWORD *)(a2 + 20), v9);\n    }\n    v10 = *(_BYTE *)(a2 + 16);\n    if ( v10 == 2 )\n    {\n      printf(\"    inet \");\n    }\n    else\n    {\n      if ( v10 != 10 )\n      {\n        printf(\"    family %d \", *(unsigned __int8 *)(a2 + 16));\n        goto LABEL_40;\n      }\n      printf(\"    inet6 \");\n    }\n    v11 = v25;\nLABEL_40:\n    if ( v27 )\n    {\n      ((void (*)(void))sub_8069D47)();\n      fputs_unlocked();\n      v12 = *(unsigned __int8 *)(a2 + 17);\n      if ( v26 && memcmp(v26 + 2, v27 + 2, 4u) )\n      {\n        v13 = (const char *)((int (*)(void))sub_8069D47)();\n        printf(\" peer %s/%d \", v13, v12);\n      }\n      else\n      {\n        printf(\"/%d \", v12);\n        v11 = v24;\n      }\n    }\n    if ( v29 )\n    {\n      v14 = (const char *)sub_8069D47(v11, v29 + 4);\n      printf(\"brd %s \", v14);\n    }\n    if ( v30 )\n    {\n      v15 = (const char *)sub_8069D47(v11, v30 + 4);\n      printf(\"any %s \", v15);\n    }\n    v16 = (const char *)sub_8069664();\n    printf(\"scope %s \", v16);\n    v17 = *(_BYTE *)(a2 + 18);\n    if ( (v17 & 1) != 0 )\n    {\n      *(_BYTE *)(a2 + 18) = v17 & 0xFE;\n      printf(\"secondary \");\n    }\n    v18 = *(_BYTE *)(a2 + 18);\n    if ( (v18 & 0x40) != 0 )\n    {\n      *(_BYTE *)(a2 + 18) = v18 & 0xBF;\n      printf(\"tentative \");\n    }\n    v19 = *(_BYTE *)(a2 + 18);\n    if ( (v19 & 0x20) != 0 )\n    {\n      *(_BYTE *)(a2 + 18) = v19 & 0xDF;\n      printf(\"deprecated \");\n    }\n    v20 = *(_BYTE *)(a2 + 18);\n    if ( v20 < 0 )\n      *(_BYTE *)(a2 + 18) = v20 & 0x7F;\n    else\n      printf(\"dynamic \");\n    if ( *(_BYTE *)(a2 + 18) )\n      printf(\"flags %02x \", *(unsigned __int8 *)(a2 + 18));\n    if ( v28 )\n      fputs_unlocked();\n    if ( v31 )\n    {\n      sub_804DD98((unsigned __int8)byte_80DBBA5);\n      if ( *(_DWORD *)(v31 + 8) == -1 )\n        strcpy(dest, \"valid_lft forever\");\n      else\n        sprintf(dest, \"valid_lft %dsec\", *(_DWORD *)(v31 + 8));\n      v21 = *(_DWORD *)(v31 + 4);\n      v22 = &dest[strlen(dest)];\n      if ( v21 == -1 )\n        strcpy(v22, \" preferred_lft forever\");\n      else\n        sprintf(v22, \" preferred_lft %dsec\", v21);\n      printf(\"       %s\", dest);\n    }\n    sub_804DD98(10);\n  }\n  return v3;\n}\n"
    ],
    "sub_8064839": [
        "0x8064839",
        "int __usercall sub_8064839@<eax>(int *a1@<eax>)\n{\n  int v2; // edx\n  int result; // eax\n  int v4; // edx\n  int v5; // esi\n  const char *v6; // eax\n  int v7; // edi\n  int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  const char *v11; // eax\n  int v12; // esi\n  const char *v13; // eax\n  int v14; // [esp-4h] [ebp-124h]\n  int v15; // [esp+0h] [ebp-120h]\n  int v16; // [esp+0h] [ebp-120h]\n  int v17[16]; // [esp+8h] [ebp-118h] BYREF\n  unsigned __int16 *v18; // [esp+4Ch] [ebp-D4h]\n  unsigned __int16 *v19; // [esp+50h] [ebp-D0h]\n  int v20; // [esp+54h] [ebp-CCh]\n  int v21; // [esp+58h] [ebp-C8h]\n  int v22; // [esp+5Ch] [ebp-C4h]\n  int v23; // [esp+60h] [ebp-C0h]\n  int v24; // [esp+70h] [ebp-B0h]\n\n  v2 = *a1;\n  if ( (unsigned __int16)(*((_WORD *)a1 + 2) - 16) <= 1u )\n  {\n    result = -1;\n    v4 = v2 - 32;\n    if ( v4 < 0 )\n      return result;\n    if ( (!stream || stream == (FILE *)a1[5]) && (!HIBYTE(pmatch[0].rm_so) || (a1[6] & 1) != 0) )\n    {\n      sub_806901E(v4);\n      if ( !v20 )\n      {\n        sub_804D5F4(\"nil ifname\");\n        return -1;\n      }\n      if ( !qword_80DB778\n        || LOBYTE(pmatch[0].rm_so) && LOBYTE(pmatch[0].rm_so) != 17\n        || !fnmatch(qword_80DB778, (const char *)(v20 + 4), 0) )\n      {\n        if ( *((_WORD *)a1 + 2) == 17 )\n          printf(\"Deleted \");\n        printf(\"%d: %s\", a1[5], (const char *)(v20 + 4));\n        if ( v22 )\n        {\n          v5 = *(_DWORD *)(v22 + 4);\n          if ( v5 )\n          {\n            v6 = (const char *)((int (*)(void))sub_80692E5)();\n            printf(\"@%s: \", v6);\n            v5 = (sub_8069313() & 1) == 0;\n          }\n          else\n          {\n            printf(\"@NONE: \");\n          }\n        }\n        else\n        {\n          printf(\": \");\n          v5 = 0;\n        }\n        v7 = a1[6];\n        sub_804DD98(60);\n        if ( (v7 & 0x41) == 1 )\n          printf(\"NO-CARRIER,\");\n        v8 = sub_80B0AB7(v7 & 0xFFFFFFBF, \"LOOPBACK\", 135036660);\n        if ( v8 )\n          printf(\"%x\", v8);\n        if ( v5 )\n          printf(\",M-DOWN\");\n        printf(\"> \");\n        if ( v21 )\n        {\n          printf(\"mtu %u \", *(_DWORD *)(v21 + 4));\n          v10 = v14;\n        }\n        if ( v23 )\n        {\n          printf(\"qdisc %s \", (const char *)(v23 + 4));\n          v9 = v15;\n        }\n        if ( v24 )\n        {\n          v11 = (const char *)sub_80692E5(v10, v9);\n          printf(\"master %s \", v11);\n        }\n        if ( BYTE1(pmatch[0].rm_so) )\n        {\n          v12 = socket(2, 1, 0);\n          if ( v12 >= 0 )\n          {\n            memset(v17, 0, 0x20u);\n            sub_804D67E((char *)v17, (const char *)(v20 + 4));\n            if ( sub_804E09D(v12, 0x8942u, (int)v17, \"SIOCGIFTXQLEN\") >= 0 )\n            {\n              close(v12);\n              v10 = v16;\n              if ( v17[4] )\n                printf(\"qlen %d\", v17[4]);\n            }\n            else\n            {\n              close(v12);\n            }\n          }\n        }\n        if ( !LOBYTE(pmatch[0].rm_so) || LOBYTE(pmatch[0].rm_so) == 17 )\n        {\n          v13 = (const char *)sub_80693D1(v10, v17);\n          printf(\"%c    link/%s \", (unsigned __int8)byte_80DBBA5, v13);\n          if ( v18 )\n          {\n            sub_806907E(*((unsigned __int16 *)a1 + 9), *v18 - 4, v17, 64);\n            fputs_unlocked();\n          }\n          if ( v19 )\n          {\n            if ( (a1[6] & 0x10) != 0 )\n              printf(\" peer \");\n            else\n              printf(\" brd \");\n            sub_806907E(*((unsigned __int16 *)a1 + 9), *v19 - 4, v17, 64);\n            fputs_unlocked();\n          }\n        }\n        sub_804DD98(10);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8064B4C": [
        "0x8064b4c",
        "unsigned int __usercall sub_8064B4C@<eax>(int a1@<eax>, __int16 a2@<dx>, const char **a3@<ecx>)\n{\n  int v4; // esi\n  char *v5; // ebp\n  int v6; // eax\n  unsigned int v7; // edx\n  const char *v8; // edi\n  size_t v9; // eax\n  int v10; // edx\n  char v11; // al\n  int i; // esi\n  unsigned __int32 v13; // eax\n  char v14; // al\n  int v16; // [esp+Ch] [ebp-190h]\n  char *v17; // [esp+10h] [ebp-18Ch]\n  int v18; // [esp+14h] [ebp-188h]\n  int v20; // [esp+1Ch] [ebp-180h]\n  char v21; // [esp+23h] [ebp-179h]\n  int v22; // [esp+24h] [ebp-178h]\n  int v23[5]; // [esp+28h] [ebp-174h] BYREF\n  __int16 v24[10]; // [esp+3Ch] [ebp-160h] BYREF\n  int v25[9]; // [esp+50h] [ebp-14Ch] BYREF\n  _DWORD v26[74]; // [esp+74h] [ebp-128h] BYREF\n\n  memset(v26, 0, 0x118u);\n  v26[0] = 24;\n  HIWORD(v26[1]) = a2 | 1;\n  LOWORD(v26[1]) = a1;\n  LOBYTE(v26[4]) = byte_80DB764;\n  v21 = 0;\n  v20 = 0;\n  v16 = 0;\n  v4 = 0;\n  v18 = 0;\n  v5 = 0;\n  v17 = 0;\n  while ( *a3 )\n  {\n    v6 = sub_804D222(\"peer\", *a3);\n    v7 = v6;\n    if ( v6 >= 0 )\n    {\n      v22 = v6;\n      a3 = (const char **)sub_8069C3A();\n      v7 = v22;\n    }\n    v8 = *a3;\n    if ( v7 > 1 )\n    {\n      if ( v7 <= 3 )\n      {\n        if ( v16 )\n          goto LABEL_12;\n        if ( *v8 == 43 )\n        {\n          v16 = -1;\nLABEL_17:\n          if ( !v8[1] )\n            goto LABEL_39;\n        }\n        else if ( *v8 == 45 )\n        {\n          v16 = -2;\n          goto LABEL_17;\n        }\n        sub_8069A87(LOBYTE(v26[4]), v8);\n        if ( !LOBYTE(v26[4]) )\n          LOBYTE(v26[4]) = v25[0];\n        sub_8068F90(&v25[1], BYTE1(v25[0]));\n        v16 = BYTE1(v25[0]);\n        goto LABEL_39;\n      }\n      switch ( v7 )\n      {\n        case 4u:\n          if ( v20 )\nLABEL_12:\n            sub_8069CD4();\n          sub_8069A87(LOBYTE(v26[4]), v8);\n          if ( !LOBYTE(v26[4]) )\n            LOBYTE(v26[4]) = v25[0];\n          sub_8068F90(&v25[1], BYTE1(v25[0]));\n          v20 = BYTE1(v25[0]);\n          break;\n        case 5u:\n          v25[0] = 0;\n          if ( sub_806968A() )\n            sub_8069C50();\n          HIBYTE(v26[4]) = v25[0];\n          v21 = 1;\n          break;\n        case 6u:\n          v17 = (char *)*a3;\n          break;\n        case 7u:\n          v9 = strlen(*a3);\n          sub_8068F90(v8, v9 + 1);\n          v5 = (char *)v8;\n          break;\n        default:\n          if ( v18 )\n            sub_8069CE0();\n          sub_8069AC1(LOBYTE(v26[4]), v8);\n          if ( !LOBYTE(v26[4]) )\n            LOBYTE(v26[4]) = v23[0];\n          sub_8068F90(&v23[1], BYTE1(v23[0]));\n          v18 = BYTE1(v23[0]);\n          break;\n      }\n    }\n    else\n    {\n      if ( v4 )\n        goto LABEL_12;\n      sub_8069AC1(LOBYTE(v26[4]), *a3);\n      v4 = HIBYTE(v24[0]);\n      if ( !LOBYTE(v26[4]) )\n        LOBYTE(v26[4]) = v24[0];\n      sub_8068F90(&v24[2], HIBYTE(v24[0]));\n      BYTE1(v26[4]) = v24[1];\n    }\nLABEL_39:\n    ++a3;\n  }\n  if ( !v17 )\n    sub_804D5E0(\"need \\\"dev IFACE\\\"\");\n  if ( v5 && !sub_804D210(v5, v17) )\n    sub_804D5E0(\"\\\"dev\\\" (%s) must match \\\"label\\\" (%s)\", v17, v5);\n  if ( v4 == 0 && v18 != 0 && a1 != 21 )\n  {\n    qmemcpy(v24, v23, sizeof(v24));\n    sub_8068F90(&v23[1], BYTE1(v23[0]));\n  }\n  if ( !BYTE1(v26[4]) )\n    BYTE1(v26[4]) = BYTE2(v23[0]);\n  if ( v16 >= 0 )\n  {\nLABEL_64:\n    if ( !v21 && a1 != 21 )\n    {\n      v14 = 0;\n      if ( LOBYTE(v23[0]) == 2 && BYTE1(v23[0]) )\n        v14 = LOBYTE(v23[1]) != 127 ? 0 : 0xFE;\n      HIBYTE(v26[4]) = v14;\n    }\n  }\n  else if ( a1 != 21 )\n  {\n    if ( LOBYTE(v26[4]) != 2 )\n      sub_804D5E0(\"broadcast can be set only for IPv4 addresses\");\n    qmemcpy(v25, v24, 0x14u);\n    if ( SHIWORD(v25[0]) <= 30 )\n    {\n      v10 = v25[1];\n      v11 = 0;\n      for ( i = 31; SHIWORD(v25[0]) <= i; --i )\n      {\n        v13 = _byteswap_ulong(1 << (31 - i));\n        if ( v16 == -1 )\n          v10 |= v13;\n        else\n          v10 &= ~v13;\n        v11 = 1;\n      }\n      if ( v11 )\n        v25[1] = v10;\n      sub_8068F90(&v25[1], BYTE1(v25[0]));\n    }\n    goto LABEL_64;\n  }\n  sub_8068A5B();\n  sub_8069345();\n  v26[5] = sub_806932A();\n  return 2 * ((unsigned int)sub_8068D41(0, v26) >> 31);\n}\n"
    ],
    "sub_8064F95": [
        "0x8064f95",
        "int __usercall sub_8064F95@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char **v2; // ebx\n  const char *v3; // eax\n  const char *v4; // esi\n  char v5; // al\n  int *v6; // ebp\n  int j; // ebx\n  int v8; // edx\n  int v9; // ecx\n  const char *v10; // eax\n  _DWORD *k; // ebp\n  int v12; // ebx\n  int v13; // esi\n  int v15; // [esp-4h] [ebp-E60h]\n  int v16; // [esp+0h] [ebp-E5Ch]\n  int *i; // [esp+4h] [ebp-E58h]\n  _BOOL4 v18; // [esp+8h] [ebp-E54h]\n  _DWORD *v19; // [esp+Ch] [ebp-E50h] BYREF\n  int v20[6]; // [esp+10h] [ebp-E4Ch] BYREF\n  char v21; // [esp+28h] [ebp-E34h] BYREF\n  int v22[2]; // [esp+4Ch] [ebp-E10h] BYREF\n  unsigned __int16 *v23; // [esp+54h] [ebp-E08h]\n  int v24; // [esp+58h] [ebp-E04h]\n\n  v2 = a1;\n  v16 = a2;\n  v19 = 0;\n  v20[0] = 0;\n  memset(&qword_80DB778, 0, 0x44u);\n  BYTE2(pmatch[0].rm_so) = byte_80DBBA6;\n  BYTE1(pmatch[0].rm_so) = 1;\n  LOBYTE(pmatch[0].rm_so) = byte_80DB764;\n  v3 = *a1;\n  if ( a2 )\n  {\n    if ( !v3 )\n      sub_804D5E0(\"%s requires an argument\", \"flush\");\n    if ( LOBYTE(pmatch[0].rm_so) == 17 )\n      sub_804D5E0(\"can't flush link addresses\");\n  }\n  v4 = 0;\n  while ( *v2 )\n  {\n    v5 = sub_804D222(\"to\", *v2);\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        v22[0] = 0;\n        v2 = (const char **)sub_8069C3A();\n        MEMORY[0x80DB788] = (char *)-1;\n        if ( sub_806968A() )\n        {\n          if ( strcmp(*v2, \"all\") )\n            sub_8069C50(v15, \"scope\");\n          v22[0] = 255;\n          MEMORY[0x80DB788] = 0;\n        }\n        *(&unk_80DB780 + 1) = v22[0];\n      }\n      else if ( v5 == 2 )\n      {\n        HIBYTE(pmatch[0].rm_so) = 1;\n      }\n      else if ( v5 == 3 )\n      {\n        v2 = (const char **)sub_8069C3A();\n        qword_80DB778 = *v2;\n      }\n      else\n      {\n        if ( v5 == 4 )\n          v2 = (const char **)sub_8069C3A();\n        if ( v4 )\n          sub_8069CE0();\n        v4 = *v2;\n      }\n    }\n    else\n    {\n      v2 = (const char **)sub_8069C3A();\n      sub_8069AC1(SLOBYTE(pmatch[0].rm_so), *v2);\n      if ( !LOBYTE(pmatch[0].rm_so) )\n        LOBYTE(pmatch[0].rm_so) = (_BYTE)qword_80DB7A8;\n    }\n    ++v2;\n  }\n  sub_8068A5B();\n  sub_8068AE2(18, byte_80DB764);\n  sub_8068BB1(&v19, sub_80643B2);\n  if ( v4 )\n    stream = (FILE *)sub_806932A();\n  if ( v16 )\n  {\n    *(&qword_80DB778 + 1) = v22;\n    unk_80DB794 = 0;\n    dword_80DB798 = (char *)3584;\n    unk_80DB780 = (time_t)&v21;\n    while ( 1 )\n    {\n      sub_8068AE2(22, SLOBYTE(pmatch[0].rm_so));\n      dword_80DB7A4 = 0;\n      sub_8068BB1(0, sub_8064435);\n      if ( !dword_80DB7A4 )\n        break;\n      if ( sub_80643FF() < 0 )\n        return 1;\n    }\n    return 0;\n  }\n  else\n  {\n    if ( LOBYTE(pmatch[0].rm_so) != 17 )\n    {\n      sub_8068AE2(22, SLOBYTE(pmatch[0].rm_so));\n      sub_8068BB1(v20, sub_80643B2);\n    }\n    if ( LOBYTE(pmatch[0].rm_so) == 17 || !LOBYTE(pmatch[0].rm_so) )\n    {\n      v18 = 0;\n    }\n    else\n    {\n      v18 = BYTE2(pmatch[0].rm_so) != 0;\nLABEL_40:\n      for ( i = (int *)&v19; ; *i = *v6 )\n      {\n        v6 = (int *)*i;\n        if ( !*i )\n          break;\n        for ( j = v20[0]; j; j = *(_DWORD *)j )\n        {\n          if ( *(_DWORD *)(j + 24) == v6[6]\n            && (!LOBYTE(pmatch[0].rm_so) || SLOBYTE(pmatch[0].rm_so) == *(unsigned __int8 *)(j + 20))\n            && ((*(&unk_80DB780 + 1) ^ *(unsigned __int8 *)(j + 23)) & (unsigned int)MEMORY[0x80DB788]) == 0\n            && (((unsigned int)unk_80DB78C ^ *(unsigned __int8 *)(j + 22)) & unk_80DB790) == 0 )\n          {\n            if ( !(_BYTE)qword_80DB7A8 && !qword_80DB778 )\n              goto LABEL_60;\n            sub_806901E(*(_DWORD *)(j + 4) - 24);\n            if ( !v23 )\n              v23 = (unsigned __int16 *)v22[1];\n            if ( !(_BYTE)qword_80DB7A8\n              || !v23\n              || (memset(&v20[1], 0, 0x14u),\n                  LOBYTE(v20[1]) = *(_BYTE *)(j + 20),\n                  qmemcpy(&v20[2], v23 + 2, *v23 - 4),\n                  !sub_8069CEC(SHIWORD(qword_80DB7A8), &qword_80DB7A8)) )\n            {\n              if ( !qword_80DB778\n                || (!v24 ? (v10 = (const char *)sub_80692E5(v9, v8)) : (v10 = (const char *)(v24 + 4)),\n                    !fnmatch(qword_80DB778, v10, 0)) )\n              {\nLABEL_60:\n                i = v6;\n                goto LABEL_40;\n              }\n            }\n          }\n        }\n      }\n    }\n    for ( k = v19; k; k = (_DWORD *)*k )\n    {\n      if ( (v18 || byte_80DBBA6 || !sub_8064839(k + 1)) && LOBYTE(pmatch[0].rm_so) != 17 )\n      {\n        v12 = v20[0];\n        v13 = k[6];\n        while ( v12 )\n        {\n          if ( *(_WORD *)(v12 + 8) == 20 )\n          {\n            if ( *(_DWORD *)(v12 + 4) <= 0x13u )\n              break;\n            if ( *(_DWORD *)(v12 + 24) == v13\n              && (!LOBYTE(pmatch[0].rm_so) || SLOBYTE(pmatch[0].rm_so) == *(unsigned __int8 *)(v12 + 20)) )\n            {\n              sub_8064435(0, v12 + 4);\n            }\n          }\n          v12 = *(_DWORD *)v12;\n        }\n      }\n    }\n  }\n  return v16;\n}\n"
    ],
    "sub_80653F1": [
        "0x80653f1",
        "int __usercall sub_80653F1@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  __int16 v4; // dx\n  int v5; // eax\n\n  v1 = a1;\n  if ( *a1 )\n  {\n    v2 = sub_804D254(\"add\", *a1);\n    if ( v2 < 0 )\n      sub_8069C50(v3, ident);\n    ++v1;\n    if ( v2 <= 4 )\n    {\n      if ( v2 )\n      {\n        if ( (unsigned int)(v2 - 1) <= 1 )\n        {\n          v4 = 256;\n        }\n        else\n        {\n          v4 = 0;\n          if ( v2 == 3 )\n          {\n            v4 = 1280;\nLABEL_15:\n            v5 = 20;\n            return sub_8064B4C(v5, v4, v1);\n          }\n        }\n        v5 = (v2 == 4) + 20;\n        return sub_8064B4C(v5, v4, v1);\n      }\n      v4 = 1536;\n      goto LABEL_15;\n    }\n  }\n  else\n  {\n    v2 = 2;\n  }\n  return sub_8064F95(v1, v2 == 8);\n}\n"
    ],
    "sub_8065473": [
        "0x8065473",
        "int sub_8065473()\n{\n  int result; // eax\n\n  result = socket(2, 2, 0);\n  if ( result < 0 )\n  {\n    result = socket(17, 2, 0);\n    if ( result < 0 )\n      return sub_804DF99(0, 2, 10);\n  }\n  return result;\n}\n"
    ],
    "sub_80654A9": [
        "0x80654a9",
        "int __fastcall sub_80654A9(int a1, int a2)\n{\n  int result; // eax\n  int v3; // [esp+4h] [ebp-454h] BYREF\n  _DWORD v4[267]; // [esp+2Ch] [ebp-42Ch] BYREF\n\n  memset(v4, 0, 0x420u);\n  v4[0] = 32;\n  v4[1] = 65552;\n  LOBYTE(v4[4]) = byte_80DB764;\n  sub_8068A5B(a2);\n  v4[5] = sub_806932A();\n  sub_8068F90(&v3, 4);\n  result = sub_8068D41(0, v4);\n  if ( result < 0 )\n    sub_804D604();\n  return result;\n}\n"
    ],
    "sub_806552B": [
        "0x806552b",
        "unsigned int __usercall sub_806552B@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // esi\n  const char *v4; // ebp\n  const char *v5; // edi\n  char v6; // al\n  const char **v7; // eax\n  size_t v8; // eax\n  int v9; // ecx\n  int v10; // edi\n  const char *v11; // edx\n  const char **v12; // eax\n  const char **v13; // ebx\n  const char *v14; // edx\n  int v15; // eax\n  int v16; // eax\n  int v17; // edx\n  int v18; // edx\n  unsigned int v19; // edx\n  int v20; // eax\n  int v21; // eax\n  size_t v23; // eax\n  int v24; // [esp+1Ch] [ebp-49Ch]\n  const char *v25; // [esp+20h] [ebp-498h]\n  const char *v26; // [esp+24h] [ebp-494h]\n  int v27; // [esp+24h] [ebp-494h]\n  char *v28; // [esp+28h] [ebp-490h]\n  unsigned int v30; // [esp+30h] [ebp-488h]\n  unsigned int v31; // [esp+34h] [ebp-484h]\n  __int16 v32; // [esp+40h] [ebp-478h] BYREF\n  __int16 v33; // [esp+42h] [ebp-476h] BYREF\n  int v34; // [esp+44h] [ebp-474h] BYREF\n  int v35; // [esp+48h] [ebp-470h]\n  int v36[268]; // [esp+88h] [ebp-430h] BYREF\n\n  memset(v36, 0, 0x420u);\n  v36[0] = 32;\n  HIWORD(v36[1]) = 1;\n  LOWORD(v36[1]) = a2;\n  LOBYTE(v36[4]) = byte_80DB764;\n  if ( a2 == 16 )\n    HIWORD(v36[1]) = 1537;\n  v28 = 0;\n  v3 = 0;\n  v26 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = *a1;\n    if ( !*a1 )\n      break;\n    v6 = sub_804D254(\"link\", *a1);\n    if ( v6 == 2 )\n    {\n      v7 = (const char **)sub_8069C3A(v26);\n      a1 = v7 + 1;\n      v5 = *v7;\n      break;\n    }\n    if ( v6 )\n    {\n      if ( v6 == 1 )\n      {\n        a1 = (const char **)sub_8069C3A(v26);\n        v4 = *a1;\n      }\n      else if ( v6 == 4 )\n      {\n        a1 = (const char **)sub_8069C3A(v26);\n        v28 = (char *)*a1;\n      }\n      else\n      {\n        if ( v6 == 3 )\n        {\n          if ( v3 )\n            sub_8069CD4();\n          a1 = (const char **)sub_8069C3A(v26);\n        }\n        v3 = *a1;\n      }\n    }\n    else\n    {\n      a1 = (const char **)sub_8069C3A(v26);\n      v26 = *a1;\n    }\n    ++a1;\n  }\n  sub_8068A5B(v26);\n  sub_8069345();\n  if ( !v5 )\n    goto LABEL_60;\n  v30 = (v36[0] + 3) & 0xFFFFFFFC;\n  sub_8068F90(0, 0);\n  v8 = strlen(v5);\n  sub_8068F90(v5, v8);\n  if ( !*a1 )\n    goto LABEL_59;\n  v31 = (v36[0] + 3) & 0xFFFFFFFC;\n  sub_8068F90(0, 0);\n  if ( strcmp(v5, \"vlan\") )\n  {\n    if ( strcmp(v5, \"vrf\") )\n      goto LABEL_58;\n    v20 = strcmp(*a1, \"table\");\n    v9 = v24;\n    if ( !v20 )\n    {\n      sub_8069C3A(v27);\n      v34 = sub_8069C92();\n      sub_8068F90(&v34, 4);\n      goto LABEL_58;\n    }\n    v11 = \"type vrf\";\nLABEL_56:\n    sub_8069C50(v9, v11);\n  }\n  v34 = 0;\n  v35 = 0;\n  while ( *a1 )\n  {\n    v10 = sub_804D254(\"id\", *a1);\n    if ( v10 < 0 )\n    {\n      v11 = (const char *)&unk_80CE7E8;\n      goto LABEL_56;\n    }\n    v12 = (const char **)sub_8069C3A(v27);\n    v13 = v12;\n    if ( !v10 )\n    {\n      v32 = sub_8069C97();\n      sub_8068F90(&v32, 2);\n      goto LABEL_50;\n    }\n    v14 = *v12;\n    if ( v10 == 5 )\n    {\n      v15 = sub_804D254(\"802.1q\", v14);\n      if ( v15 )\n      {\n        if ( v15 != 1 )\n          sub_804D5E0(\"unknown VLAN encapsulation protocol '%s'\", *v13);\n        v33 = -30552;\n      }\n      else\n      {\n        v33 = -32512;\n      }\n      sub_8068F90(&v33, 2);\n    }\n    else\n    {\n      v16 = sub_804D222(\"on\", v14);\n      if ( v16 < 0 )\n      {\n        v25 = sub_804D2B4(\"id\", v10);\n        sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", v25);\n      }\n      v17 = v34;\n      switch ( v10 )\n      {\n        case 1:\n          v35 |= 1u;\n          v34 &= ~1u;\n          v18 = v17 & 0xFFFFFFFE | 1;\n          if ( !v16 )\n            goto LABEL_49;\n          break;\n        case 2:\n          v35 |= 2u;\n          v34 &= ~2u;\n          v18 = v17 & 0xFFFFFFFD | 2;\n          if ( !v16 )\n            goto LABEL_49;\n          break;\n        case 3:\n          v35 |= 8u;\n          v34 &= ~8u;\n          v18 = v17 & 0xFFFFFFF7 | 8;\n          if ( !v16 )\n            goto LABEL_49;\n          break;\n        default:\n          v35 |= 4u;\n          v19 = v34 & 0xFFFFFFFB;\n          v34 &= ~4u;\n          if ( v16 )\n            break;\n          v18 = v19 | 4;\nLABEL_49:\n          v34 = v18;\n          break;\n      }\n    }\nLABEL_50:\n    a1 = v13 + 1;\n  }\n  if ( v35 )\n    sub_8068F90(&v34, 8);\nLABEL_58:\n  *(_WORD *)((char *)v36 + v31) = ((LOWORD(v36[0]) + 3) & 0xFFFC) - v31;\nLABEL_59:\n  *(_WORD *)((char *)v36 + v30) = ((LOWORD(v36[0]) + 3) & 0xFFFC) - v30;\nLABEL_60:\n  if ( a2 == 16 )\n  {\n    if ( v4 )\n      v3 = v4;\n    if ( v27 )\n    {\n      v34 = sub_806932A();\n      sub_8068F90(&v34, 4);\n    }\n    if ( v28 )\n    {\n      v21 = sub_8069111(v28);\n      if ( v21 < 0 )\n        return -1;\n      sub_8068F90(&v34, v21);\n    }\nLABEL_71:\n    if ( v3 )\n    {\n      v23 = strlen(v3);\n      if ( v23 - 1 > 0xE )\n      {\n        v11 = \"%.*s: bad variable name\" + 19;\n        goto LABEL_56;\n      }\n      sub_8068F90(v3, v23 + 1);\n    }\n    return 2 * ((unsigned int)sub_8068D41(0, v36) >> 31);\n  }\n  if ( v3 )\n  {\n    v36[5] = sub_806932A();\n    v3 = v4;\n    goto LABEL_71;\n  }\n  return 1;\n}\n"
    ],
    "sub_80659A2": [
        "0x80659a2",
        "int __usercall sub_80659A2@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  int v5; // ebp\n  int v6; // eax\n  int v7; // eax\n  int v8; // esi\n  int v9; // esi\n  int v10; // eax\n  int v11; // esi\n  int v12; // ebx\n  int v13; // esi\n  int v14; // esi\n  int v15; // ebx\n  int v16; // [esp-4h] [ebp-78h]\n  char *s1; // [esp+0h] [ebp-74h]\n  int v18; // [esp+4h] [ebp-70h]\n  char *s2; // [esp+8h] [ebp-6Ch]\n  int v20; // [esp+Ch] [ebp-68h]\n  int v21; // [esp+10h] [ebp-64h]\n  int v22; // [esp+14h] [ebp-60h]\n  int v23; // [esp+18h] [ebp-5Ch]\n  char *s; // [esp+1Ch] [ebp-58h]\n  sa_family_t v25; // [esp+22h] [ebp-52h]\n  struct sockaddr addr[2]; // [esp+24h] [ebp-50h] BYREF\n  int v27[12]; // [esp+44h] [ebp-30h] BYREF\n\n  v1 = a1;\n  byte_80DB560 = 2;\n  if ( !*a1 )\n    goto LABEL_75;\n  v2 = sub_804D254(\"add\", *a1);\n  if ( v2 < 0 )\n    sub_8069C50(v3, ident);\n  ++v1;\n  if ( v2 <= 1 )\n    return sub_806552B(v1, 17 - (v2 == 0));\n  if ( v2 == 2 )\n  {\n    s2 = 0;\n    s = 0;\n    v23 = -1;\n    v21 = -1;\n    v22 = -1;\n    v5 = 0;\n    v18 = 0;\n    s1 = 0;\n    while ( *v1 )\n    {\n      v6 = sub_804D254(\"up\", *v1);\n      if ( (_BYTE)v6 )\n      {\n        switch ( (_BYTE)v6 )\n        {\n          case 1:\n            v18 |= 1u;\n            v5 &= ~1u;\n            break;\n          case 2:\n            v1 = (const char **)sub_8069C3A(s1);\n            s2 = (char *)*v1;\n            break;\n          case 3:\n            v1 = (const char **)sub_8069C3A(s1);\n            if ( v21 != -1 )\n              goto LABEL_20;\n            v21 = sub_8069C5C();\n            break;\n          case 4:\n            v1 = (const char **)sub_8069C3A(s1);\n            if ( v22 != -1 )\nLABEL_20:\n              sub_8069CD4();\n            v22 = sub_8069C5C();\n            break;\n          case 8:\n            v1 = (const char **)sub_8069C3A(s1);\n            s = (char *)*v1;\n            break;\n          case 9:\n            v1 = (const char **)sub_8069C3A(s1);\n            v23 = sub_806932A();\n            break;\n          case 0xA:\n            v23 = 0;\n            break;\n          default:\n            if ( (unsigned __int8)v6 <= 0xAu )\n            {\n              v20 = v6;\n              v1 = (const char **)sub_8069C3A(s1);\n              v7 = sub_804D222(\"on\", *v1);\n              v3 = v20;\n              switch ( (_BYTE)v20 )\n              {\n                case 5:\n                  if ( v7 < 0 )\n                    sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", \"multicast\");\n                  v18 |= 0x1000u;\n                  if ( v7 )\n                    v5 &= ~0x1000u;\n                  else\n                    v5 |= 0x1000u;\n                  break;\n                case 6:\n                  if ( v7 < 0 )\n                    sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", 135051898);\n                  v18 |= 0x80u;\n                  if ( v7 )\n                    v5 |= 0x80u;\n                  else\n                    v5 &= ~0x80u;\n                  break;\n                case 7:\n                  if ( v7 < 0 )\n                    sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", \"promisc\");\n                  v18 |= 0x100u;\n                  if ( v7 )\n                    v5 &= ~0x100u;\n                  else\n                    v5 |= 0x100u;\n                  break;\n              }\n            }\n            else\n            {\n              if ( (_BYTE)v6 == 11 )\n                v1 = (const char **)sub_8069C3A(s1);\n              if ( s1 )\n                sub_8069CE0();\n              s1 = (char *)*v1;\n            }\n            break;\n        }\n      }\n      else\n      {\n        v18 |= 1u;\n        v5 |= 1u;\n      }\n      ++v1;\n    }\n    if ( !s1 )\n      sub_804D5E0(\"%s requires an argument\", \"\\\"dev\\\"\");\n    if ( s )\n    {\n      v8 = sub_804DF99(0, 2, 17);\n      sub_804D67E((char *)v27, s1);\n      sub_804E0BE(v8, 0x8933u, (int)v27, \"SIOCGIFINDEX\");\n      memset(&addr[0].sa_data[6], 0, 0xCu);\n      *(_DWORD *)&addr[0].sa_data[2] = v27[4];\n      *(_DWORD *)&addr[0].sa_family = 1610612753;\n      sub_804DFB3(0x14u, addr, v8);\n      sub_80A998A(20, addr);\n      close(v8);\n      v25 = *(_WORD *)&addr[0].sa_data[6];\n      v9 = (unsigned __int8)addr[0].sa_data[9];\n      memset(addr, 0, sizeof(addr));\n      sub_804D67E((char *)addr, s1);\n      addr[1].sa_family = v25;\n      v10 = sub_8069111(s);\n      if ( v10 < 0 )\n        exit(1);\n      if ( v10 != v9 )\n        sub_804D5E0(\"wrong address (%s) length: expected %d bytes\", s, v9);\n      v11 = sub_8065473();\n      sub_804E0BE(v11, 0x8924u, (int)addr, \"SIOCSIFHWADDR\");\n      close(v11);\n    }\n    if ( s2 && strcmp(s1, s2) )\n    {\n      sub_804D67E((char *)v27, s1);\n      sub_804D67E((char *)&v27[4], s2);\n      v12 = sub_8065473();\n      sub_804E0BE(v12, 0x8923u, (int)v27, \"SIOCSIFNAME\");\n      close(v12);\n      s1 = s2;\n    }\n    if ( v22 != -1 )\n    {\n      v13 = sub_8065473();\n      memset(v27, 0, 0x20u);\n      sub_804D67E((char *)v27, s1);\n      v27[4] = v22;\n      sub_804E0BE(v13, 0x8943u, (int)v27, \"SIOCSIFTXQLEN\");\n      close(v13);\n      v3 = v16;\n    }\n    if ( v21 != -1 )\n    {\n      v14 = sub_8065473();\n      memset(v27, 0, 0x20u);\n      sub_804D67E((char *)v27, s1);\n      v27[4] = v21;\n      sub_804E0BE(v14, 0x8922u, (int)v27, \"SIOCSIFMTU\");\n      close(v14);\n    }\n    if ( v23 != -1 )\n      sub_80654A9(v3, v23);\n    if ( v18 )\n    {\n      sub_804D67E((char *)v27, s1);\n      v15 = sub_8065473();\n      sub_804E0BE(v15, 0x8913u, (int)v27, \"SIOCGIFFLAGS\");\n      if ( ((v5 ^ SLOWORD(v27[4])) & v18) != 0 )\n      {\n        LOWORD(v27[4]) ^= (unsigned __int16)v18 & (LOWORD(v27[4]) ^ v5);\n        sub_804E0BE(v15, 0x8914u, (int)v27, \"SIOCSIFFLAGS\");\n      }\n      close(v15);\n    }\n    return 0;\n  }\n  else\n  {\nLABEL_75:\n    byte_80DB764 = 17;\n    return sub_8064F95(v1, 0);\n  }\n}\n"
    ],
    "sub_8065EB4": [
        "0x8065eb4",
        "int sub_8065EB4()\n{\n  if ( sub_8068AAE(dword_80DB7A4, pmatch[0].rm_so) >= 0 )\n  {\n    dword_80DB7A4 = 0;\n    return 0;\n  }\n  else\n  {\n    sub_804D3A5((int)\"can't send flush request\");\n    return -1;\n  }\n}\n"
    ],
    "sub_8065EEA": [
        "0x8065eea",
        "int __usercall sub_8065EEA@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char **v2; // ebx\n  int v4; // ebp\n  const char *v5; // edi\n  int v6; // eax\n  const char **v7; // eax\n  const char *v8; // ebp\n  unsigned int v9; // eax\n  int v10; // eax\n  int v11; // esi\n  _DWORD v13[3]; // [esp+0h] [ebp-E40h] BYREF\n  char v14; // [esp+Ch] [ebp-E34h] BYREF\n  char v15; // [esp+30h] [ebp-E10h] BYREF\n\n  v2 = a1;\n  memset(v13, 0, sizeof(v13));\n  memset(&qword_80DB778, 0, 0x38u);\n  unk_80DB780 = -1;\n  if ( a2 && !*a1 )\n    sub_804D5E0(\"%s requires an argument\", \"\\\"ip neigh flush\\\"\");\n  if ( !qword_80DB778 )\n    qword_80DB778 = byte_80DB764;\n  unk_80DB780 = a2 == 0 ? 191 : -193;\n  v4 = 0;\n  v5 = 0;\n  while ( *v2 )\n  {\n    v6 = sub_804D254(\"to\", *v2);\n    if ( v6 == 1 )\n    {\n      v2 = (const char **)sub_8069C3A(v13[0]);\n      v5 = *v2;\n    }\n    else if ( v6 == 2 )\n    {\n      v7 = (const char **)sub_8069C3A(v13[0]);\n      v2 = v7;\n      if ( !v4 )\n        unk_80DB780 = 0;\n      v8 = *v7;\n      if ( !strcmp(*v7, \"all\") )\n      {\n        v9 = a2 == 0 ? -1 : 0xFFFFFFBF;\n      }\n      else\n      {\n        v10 = sub_804D254(\"permanent\", v8);\n        if ( v10 < 0 )\n          sub_804D5E0(\"invalid argument '%s' to '%s'\", v8, \"nud state\");\n        v9 = (unsigned __int8)byte_80CEB30[v10];\n        if ( !v9 )\n          v9 = 256;\n      }\n      unk_80DB780 |= v9;\n      v4 = 1;\n    }\n    else\n    {\n      if ( !v6 )\n        v2 = (const char **)sub_8069C3A(v13[0]);\n      sub_8069AC1(qword_80DB778, *v2);\n      if ( !qword_80DB778 )\n        qword_80DB778 = (unsigned __int8)MEMORY[0x80DB788];\n    }\n    ++v2;\n  }\n  sub_8068A5B(v13[0]);\n  sub_8069345();\n  if ( v5 )\n  {\n    *(&qword_80DB778 + 1) = sub_806932A();\n    if ( !*(&qword_80DB778 + 1) )\n      sub_804D5E0(\"can't find device '%s'\", v5);\n  }\n  if ( a2 )\n  {\n    pmatch[0].rm_so = (regoff_t)&v15;\n    dword_80DB7A4 = 0;\n    qword_80DB7A8 = (void *)3584;\n    unk_80DB780 &= ~0x20u;\n    *(&qword_80DB7A8 + 1) = &v14;\n    v11 = 0;\n    while ( 1 )\n    {\n      if ( sub_8068AE2(30, qword_80DB778) < 0 )\n        goto LABEL_31;\n      stream = 0;\n      if ( sub_8068BB1(0, sub_8066192) < 0 )\n        sub_804D3C9((int)\"flush terminated\");\n      if ( !stream )\n        break;\n      ++v11;\n      if ( sub_8065EB4() < 0 )\n        sub_804D604();\n      printf(\"\\n*** Round %d, deleting %d entries ***\\n\", v11, stream);\n      if ( v11 == 10 )\n        sub_804D5E0(\"*** Flush not complete bailing out after %d rounds\", 10);\n    }\n    if ( v11 )\n      printf(\"*** Flush is complete after %d round(s) ***\\n\", v11);\n    else\n      puts(\"Nothing to flush\");\n  }\n  else\n  {\n    LOBYTE(v13[0]) = qword_80DB778;\n    if ( (int)sub_8068B22(12) < 0 )\nLABEL_31:\n      sub_804D3C9((int)\"can't send dump request\");\n    if ( sub_8068BB1(0, sub_8066192) < 0 )\n      sub_804D5E0(\"dump terminated\");\n  }\n  return 0;\n}\n"
    ],
    "sub_8066192": [
        "0x8066192",
        "int __fastcall sub_8066192(int a1, int *a2)\n{\n  int v3; // edx\n  int v4; // eax\n  int v5; // edx\n  int v6; // esi\n  int v7; // ecx\n  _DWORD *v8; // eax\n  int v9; // edi\n  int v10; // eax\n  int v11; // edx\n  unsigned __int16 *v12; // edx\n  const char *v13; // eax\n  const char *v14; // eax\n  const char *v15; // eax\n  unsigned int v16; // esi\n  int v17; // ebx\n  int v18; // eax\n  int v20; // [esp-8h] [ebp-88h]\n  unsigned __int16 *v21; // [esp+4h] [ebp-7Ch]\n  unsigned __int16 *v22; // [esp+8h] [ebp-78h]\n  _DWORD *v23; // [esp+Ch] [ebp-74h]\n  int v24; // [esp+10h] [ebp-70h]\n  char v25[80]; // [esp+30h] [ebp-50h] BYREF\n\n  v3 = *a2;\n  v4 = *((unsigned __int16 *)a2 + 2);\n  if ( (unsigned __int16)(v4 - 28) > 1u )\n    sub_804D5E0(\"not RTM_NEWNEIGH: %08x %08x %08x\", v3, v4, *((unsigned __int16 *)a2 + 3));\n  v5 = v3 - 28;\n  if ( v5 < 0 )\n    sub_804D5E0(\"BUG: wrong nlmsg len %d\", v5);\n  if ( pmatch[0].rm_so && (_WORD)v4 != 28 )\n    return 0;\n  if ( qword_80DB778 && qword_80DB778 != *((unsigned __int8 *)a2 + 16) )\n    return 0;\n  if ( *(&qword_80DB778 + 1) && *(&qword_80DB778 + 1) != a2[5] )\n    return 0;\n  v6 = *((unsigned __int16 *)a2 + 12);\n  if ( (unk_80DB780 & v6) == 0\n    && (*((_BYTE *)a2 + 26) & 8) == 0\n    && ((_WORD)v6 || (unk_80DB780 & 0x100) == 0)\n    && *((_BYTE *)a2 + 16) != 12 )\n  {\n    return 0;\n  }\n  sub_806901E(v5);\n  if ( v21 )\n  {\n    if ( (_BYTE)MEMORY[0x80DB788] )\n    {\n      memset(v25, 0, 0x14u);\n      v25[0] = *((_BYTE *)a2 + 16);\n      qmemcpy(&v25[4], v21 + 2, *v21 - 4);\n      if ( sub_8069CEC(SHIWORD(MEMORY[0x80DB788]), &MEMORY[0x80DB788]) )\n        return 0;\n    }\n  }\n  if ( *(&unk_80DB780 + 1) && v23 && v23[4] )\n    return 0;\n  if ( !pmatch[0].rm_so )\n  {\nLABEL_27:\n    v12 = v21;\n    if ( v21 )\n    {\n      v13 = (const char *)sub_8069D47(v7, v21 + 2);\n      printf(\"%s \", v13);\n      v7 = v20;\n    }\n    if ( !*(&qword_80DB778 + 1) && a2[5] )\n    {\n      v14 = (const char *)sub_80692E5(v7, v12);\n      printf(\"dev %s \", v14);\n    }\n    if ( v22 )\n    {\n      v15 = (const char *)sub_806907E(1, *v22 - 4, v25, 64);\n      printf(\"lladdr %s\", v15);\n    }\n    if ( *((char *)a2 + 26) < 0 )\n      printf(\" router\");\n    if ( (*((_BYTE *)a2 + 26) & 8) != 0 )\n      printf(\" proxy\");\n    if ( v23 )\n    {\n      v16 = sub_806990F();\n      if ( v23[4] )\n        printf(\" ref %d\", v23[4]);\n      printf(\" used %d/%d/%d\", v23[2] / v16, v23[1] / v16, v23[3] / v16);\n    }\n    if ( v24 )\n      printf(\" probes %u\", *(_DWORD *)(v24 + 4));\n    v17 = a2[6];\n    v18 = 32;\n    if ( (v17 & 1) != 0 )\n    {\n      printf(\"%cINCOMPLETE\", 32);\n      v18 = 44;\n    }\n    if ( (v17 & 2) != 0 )\n    {\n      printf(\"%cREACHABLE\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 4) != 0 )\n    {\n      printf(\"%cSTALE\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 8) != 0 )\n    {\n      printf(\"%cDELAY\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x10) != 0 )\n    {\n      printf(\"%cPROBE\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x20) != 0 )\n    {\n      printf(\"%cFAILED\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x40) != 0 )\n    {\n      printf(\"%cNOARP\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x80) != 0 )\n      printf(\"%cPERMANENT\", v18);\n    sub_804DD98(10);\n    return 0;\n  }\n  if ( *a2 + ((dword_80DB7A4 + 3) & 0xFFFFFFFC) <= (unsigned int)qword_80DB7A8 || (v10 = sub_8065EB4(), v11 = -1, !v10) )\n  {\n    v8 = (_DWORD *)(pmatch[0].rm_so + ((dword_80DB7A4 + 3) & 0xFFFFFFFC));\n    qmemcpy(v8, a2, *a2);\n    v8[1] = 65565;\n    v7 = (int)*(&qword_80DB7A8 + 1);\n    v9 = *((_DWORD *)*(&qword_80DB7A8 + 1) + 7);\n    *((_DWORD *)*(&qword_80DB7A8 + 1) + 7) = v9 + 1;\n    v8[2] = v9 + 1;\n    dword_80DB7A4 = (char *)v8 + *a2 - pmatch[0].rm_so;\n    stream = (FILE *)((char *)stream + 1);\n    goto LABEL_27;\n  }\n  return v11;\n}\n"
    ],
    "sub_80664E9": [
        "0x80664e9",
        "int __usercall sub_80664E9@<eax>(const char **a1@<eax>)\n{\n  int v1; // edx\n  const char **v2; // ebx\n  int v3; // eax\n  int v4; // ecx\n\n  v1 = (int)*a1;\n  if ( *a1 )\n  {\n    v2 = a1;\n    v3 = sub_804D254(\"show\", (const char *)v1);\n    if ( v3 )\n    {\n      if ( v3 != 1 )\n        sub_8069C50(v4, ident);\n      a1 = v2 + 1;\n      v1 = 1;\n    }\n    else\n    {\n      a1 = v2 + 1;\n      v1 = 0;\n    }\n  }\n  return sub_8065EEA(a1, v1);\n}\n"
    ],
    "sub_8066525": [
        "0x8066525",
        "int sub_8066525()\n{\n  int result; // eax\n\n  result = 0;\n  memset(&qword_80DB778, 0, 0x8Cu);\n  HIWORD(dword_80DB7C8) = -1;\n  HIWORD(dword_80DB7F0) = -1;\n  return result;\n}\n"
    ],
    "sub_806654A": [
        "0x806654a",
        "int sub_806654A()\n{\n  if ( sub_8068AAE(*(&unk_80DB780 + 1), unk_80DB780) >= 0 )\n  {\n    *(&unk_80DB780 + 1) = 0;\n    return 0;\n  }\n  else\n  {\n    sub_804D3A5((int)\"can't send flush request\");\n    return -1;\n  }\n}\n"
    ],
    "sub_8066580": [
        "0x8066580",
        "int __fastcall sub_8066580(int a1, int *a2)\n{\n  int v3; // eax\n  int v4; // edx\n  int v5; // eax\n  int v6; // eax\n  int v7; // ebp\n  int v8; // ecx\n  _DWORD *v9; // eax\n  int v10; // edx\n  const char *v11; // eax\n  unsigned __int8 v12; // al\n  int v13; // esi\n  int v14; // edx\n  const char *v15; // eax\n  int v16; // ecx\n  unsigned __int8 v17; // al\n  int v18; // esi\n  int v19; // edx\n  const char *v20; // eax\n  int v21; // edx\n  const char *v22; // eax\n  const char *v23; // eax\n  const char *v24; // eax\n  const char *v25; // eax\n  int v26; // edx\n  const char *v27; // eax\n  int v28; // esi\n  unsigned int v29; // ebx\n  unsigned int v30; // eax\n  const char *v31; // eax\n  int v32; // edx\n  bool v33; // zf\n  int v35; // [esp-8h] [ebp-B4h]\n  int v36; // [esp-8h] [ebp-B4h]\n  int v37; // [esp-8h] [ebp-B4h]\n  int v38; // [esp-4h] [ebp-B0h]\n  int v39; // [esp-4h] [ebp-B0h]\n  int v40; // [esp-4h] [ebp-B0h]\n  int v41; // [esp-4h] [ebp-B0h]\n  int v42; // [esp-4h] [ebp-B0h]\n  int v43; // [esp-4h] [ebp-B0h]\n  int v44; // [esp-4h] [ebp-B0h]\n  int v45; // [esp+0h] [ebp-ACh]\n  char v46; // [esp+6h] [ebp-A6h]\n  char v47; // [esp+7h] [ebp-A5h]\n  __int16 v48[20]; // [esp+8h] [ebp-A4h] BYREF\n  int v49; // [esp+34h] [ebp-78h]\n  int v50; // [esp+38h] [ebp-74h]\n  int v51; // [esp+3Ch] [ebp-70h]\n  int v52; // [esp+40h] [ebp-6Ch]\n  int v53; // [esp+44h] [ebp-68h]\n  int v54; // [esp+48h] [ebp-64h]\n  int v55; // [esp+4Ch] [ebp-60h]\n  int v56; // [esp+60h] [ebp-4Ch]\n  int v57; // [esp+6Ch] [ebp-40h]\n\n  v3 = *a2;\n  v4 = *((unsigned __int16 *)a2 + 2);\n  if ( (unsigned __int16)(v4 - 24) > 1u )\n  {\n    fprintf(stderr, \"Not a route: %08x %08x %08x\\n\", v3, v4, *((unsigned __int16 *)a2 + 3));\n    return 0;\n  }\n  if ( unk_80DB780 && (_WORD)v4 != 24 )\n    return 0;\n  v5 = v3 - 28;\n  if ( v5 < 0 )\n    sub_804D5E0(\"wrong nlmsg len %d\", v5);\n  sub_806901E(v5);\n  if ( v57 )\n    v6 = *(_DWORD *)(v57 + 4);\n  else\n    v6 = *((unsigned __int8 *)a2 + 20);\n  v45 = v6;\n  v46 = *((_BYTE *)a2 + 16);\n  if ( v46 == 10 )\n  {\n    if ( qword_80DB778 )\n    {\n      v32 = a2[6] & 0x200;\n      if ( qword_80DB778 >= 0 )\n      {\n        if ( v32 )\n          return 0;\n        if ( qword_80DB778 == 255 )\n        {\n          if ( *((_BYTE *)a2 + 23) != 2 )\n            return 0;\n          goto LABEL_128;\n        }\n        if ( qword_80DB778 != 254 )\n          return 0;\n        v33 = *((_BYTE *)a2 + 23) == 2;\n      }\n      else\n      {\n        v33 = v32 == 0;\n      }\n      if ( v33 )\n        return 0;\n    }\nLABEL_128:\n    v7 = 128;\n    goto LABEL_13;\n  }\n  v7 = v46 == 2 ? 0x20 : -1;\n  if ( qword_80DB778 > 0 && qword_80DB778 != v6 )\n    return 0;\nLABEL_13:\n  if ( ((unk_80DB790 ^ *((unsigned __int8 *)a2 + 22)) & unk_80DB794) == 0 )\n  {\n    v47 = (char)dword_80DB7B4;\n    if ( (!(_BYTE)dword_80DB7B4\n       || v46 == (_BYTE)dword_80DB7B4 && SHIWORD(dword_80DB7B4) <= (int)*((unsigned __int8 *)a2 + 17))\n      && (!(_BYTE)dword_80DB7C8\n       || v46 == (_BYTE)dword_80DB7C8\n       && (dword_80DB7C8 < 0 || SHIWORD(dword_80DB7C8) >= (int)*((unsigned __int8 *)a2 + 17)))\n      && (!(_BYTE)dword_80DB7DC\n       || v46 == (_BYTE)dword_80DB7DC && SHIWORD(dword_80DB7DC) <= (int)*((unsigned __int8 *)a2 + 18))\n      && (!(_BYTE)dword_80DB7F0\n       || v46 == (_BYTE)dword_80DB7F0\n       && (dword_80DB7F0 < 0 || SHIWORD(dword_80DB7F0) >= (int)*((unsigned __int8 *)a2 + 18))) )\n    {\n      memset(v48, 0, sizeof(v48));\n      v8 = 0;\n      if ( v50 )\n      {\n        v48[11] = *((unsigned __int8 *)a2 + 18);\n        HIBYTE(v48[10]) = v46 == 10 ? 16 : 4;\n        qmemcpy(&v48[12], (const void *)(v50 + 4), HIBYTE(v48[10]));\n        v8 = 0;\n      }\n      if ( v49 )\n      {\n        v48[1] = *((unsigned __int8 *)a2 + 17);\n        HIBYTE(v48[0]) = v46 == 10 ? 16 : 4;\n        qmemcpy(&v48[2], (const void *)(v49 + 4), HIBYTE(v48[0]));\n        v8 = 0;\n      }\n      if ( (!v47 || !sub_8069CEC(SHIWORD(dword_80DB7B4), &dword_80DB7B4))\n        && (!(_BYTE)dword_80DB7C8 || dword_80DB7C8 < 0 || !sub_8069CEC(*((unsigned __int8 *)a2 + 17), &dword_80DB7C8))\n        && (!(_BYTE)dword_80DB7DC || !sub_8069CEC(SHIWORD(dword_80DB7DC), &dword_80DB7DC))\n        && (!(_BYTE)dword_80DB7F0 || dword_80DB7F0 < 0 || !sub_8069CEC(*((unsigned __int8 *)a2 + 18), &dword_80DB7F0))\n        && (!stream || v52 && stream == *(FILE **)(v52 + 4)) )\n      {\n        if ( unk_80DB780 )\n        {\n          if ( *((_WORD *)a2 + 8) != 10 || *((_BYTE *)a2 + 23) != 7 || !v54 || *(_DWORD *)(v54 + 4) != -1 )\n          {\n            if ( *a2 + ((*(&unk_80DB780 + 1) + 3) & 0xFFFFFFFC) > (unsigned int)MEMORY[0x80DB788] && sub_806654A() )\n              sub_804D604();\n            v9 = (_DWORD *)(unk_80DB780 + ((*(&unk_80DB780 + 1) + 3) & 0xFFFFFFFC));\n            qmemcpy(v9, a2, *a2);\n            v9[1] = 65561;\n            v10 = *((_DWORD *)unk_80DB78C + 7) + 1;\n            *((_DWORD *)unk_80DB78C + 7) = v10;\n            v9[2] = v10;\n            *(&unk_80DB780 + 1) = (time_t)v9 + *a2 - unk_80DB780;\n            *(&qword_80DB778 + 4) = 1;\n          }\n          return 0;\n        }\n        if ( *((_WORD *)a2 + 2) == 25 )\n        {\n          printf(\"Deleted \");\n          v8 = v38;\n        }\n        if ( *((_BYTE *)a2 + 23) != 1 )\n        {\n          v11 = (const char *)sub_8069778();\n          printf(\"%s \", v11);\n        }\n        v12 = *((_BYTE *)a2 + 17);\n        if ( v49 )\n        {\n          v13 = v12;\n          v14 = v49 + 4;\n          if ( v12 == v7 )\n          {\n            v39 = sub_8069D47(v8, v14);\n            printf(\"%s \", v39);\n          }\n          else\n          {\n            v15 = (const char *)sub_8069D47(v8, v14);\n            printf(\"%s/%u \", v15, v13);\n          }\n        }\n        else if ( v12 )\n        {\n          printf(\"0/%d \", *((unsigned __int8 *)a2 + 17));\n        }\n        else\n        {\n          printf(\"default \");\n          v16 = v40;\n        }\n        v17 = *((_BYTE *)a2 + 18);\n        if ( v50 )\n        {\n          v18 = v17;\n          v19 = v50 + 4;\n          if ( v17 == v7 )\n          {\n            v41 = sub_8069D47(v16, v19);\n            printf(\"from %s \", v41);\n          }\n          else\n          {\n            v20 = (const char *)sub_8069D47(v16, v19);\n            printf(\"from %s/%u \", v20, v18);\n          }\n        }\n        else if ( v17 )\n        {\n          printf(\"from 0/%u \", *((unsigned __int8 *)a2 + 18));\n        }\n        v21 = v53;\n        if ( v53 && SHIWORD(pmatch[0].rm_so) != v7 )\n        {\n          v22 = (const char *)sub_8069D47(v16, v53 + 4);\n          printf(\"via %s \", v22);\n        }\n        if ( v52 )\n        {\n          v23 = (const char *)sub_80692E5(v16, v21);\n          printf(\"dev %s \", v23);\n          v16 = v35;\n        }\n        if ( v45 != 254 && v45 && !qword_80DB778 )\n        {\n          v24 = (const char *)sub_8069733();\n          printf(\"table %s \", v24);\n        }\n        if ( (*((_BYTE *)a2 + 25) & 2) == 0 && *((_BYTE *)a2 + 22) && unk_80DB794 != -1 )\n        {\n          v25 = (const char *)sub_8069664();\n          printf(\"scope %s \", v25);\n        }\n        v26 = v55;\n        if ( v55 )\n        {\n          v27 = (const char *)sub_8069D47(v16, v55 + 4);\n          printf(\" src %s \", v27);\n          v16 = v36;\n        }\n        if ( v54 )\n        {\n          printf(\" metric %d \", *(_DWORD *)(v54 + 4));\n          v26 = v42;\n        }\n        if ( (a2[6] & 1) != 0 )\n          printf(\"dead \");\n        if ( (a2[6] & 4) != 0 )\n          printf(\"onlink \");\n        if ( (a2[6] & 2) != 0 )\n          printf(\"pervasive \");\n        if ( (*((_BYTE *)a2 + 25) & 1) != 0 )\n        {\n          printf(\"notify \");\n          v16 = v43;\n        }\n        if ( *((_BYTE *)a2 + 16) != 10 )\n          goto LABEL_114;\n        v28 = 0;\n        if ( v56 )\n          v28 = v56 + 4;\n        if ( (*((_BYTE *)a2 + 25) & 2) != 0 )\n        {\n          printf(\"%c    cache \", (unsigned __int8)byte_80DBBA5);\n          v26 = v44;\n        }\n        else\n        {\n          if ( !v28 )\n          {\nLABEL_114:\n            if ( v51 && !dword_80DB798 )\n            {\n              v31 = (const char *)sub_80692E5(v16, v26);\n              printf(\" iif %s\", v31);\n            }\n            sub_804DD98(10);\n            return 0;\n          }\n          if ( !*(_DWORD *)(v28 + 8) )\n          {\nLABEL_112:\n            if ( *(_DWORD *)(v28 + 12) )\n            {\n              printf(\" error %d\", *(_DWORD *)(v28 + 12));\n              v16 = v37;\n            }\n            goto LABEL_114;\n          }\n        }\n        v29 = *(_DWORD *)(v28 + 8);\n        if ( v29 )\n        {\n          v30 = sub_806990F();\n          printf(\" expires %dsec\", v29 / v30);\n        }\n        goto LABEL_112;\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8066BBA": [
        "0x8066bba",
        "int __usercall sub_8066BBA@<eax>(const char **a1@<eax>)\n{\n  char v2; // bp\n  const char *v3; // esi\n  const char *v4; // edi\n  int v5; // eax\n  int v6; // eax\n  int v7; // ebx\n  int v8; // ebx\n  _WORD *v9; // eax\n  int v11; // [esp+6h] [ebp-4C0h]\n  char v12; // [esp+9h] [ebp-4BDh]\n  char v13; // [esp+2Eh] [ebp-498h]\n  unsigned __int8 v14; // [esp+2Fh] [ebp-497h]\n  char v15; // [esp+30h] [ebp-496h]\n  char v16[4]; // [esp+32h] [ebp-494h] BYREF\n  int v17; // [esp+36h] [ebp-490h]\n  int v18; // [esp+3Ah] [ebp-48Ch]\n  int v19; // [esp+3Eh] [ebp-488h]\n  int v20; // [esp+42h] [ebp-484h]\n  _WORD v21[3]; // [esp+48h] [ebp-47Eh]\n  int v22[267]; // [esp+9Ah] [ebp-42Ch] BYREF\n\n  memset(v22, 0, 0x41Cu);\n  sub_8066525();\n  v22[0] = 28;\n  v22[1] = 65562;\n  LOBYTE(v22[4]) = byte_80DB764;\n  HIBYTE(v11) = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  while ( *a1 )\n  {\n    switch ( sub_804D222(\"from\", *a1) )\n    {\n      case 0:\n        a1 = (const char **)sub_8069C3A(v11);\n        sub_8069AC1(LOBYTE(v22[4]), *a1);\n        if ( !LOBYTE(v22[4]) )\n          LOBYTE(v22[4]) = v13;\n        if ( v14 )\n          sub_8068F90(v16, v14);\n        BYTE2(v22[4]) = v15;\n        HIBYTE(v11) = 1;\n        break;\n      case 1:\n        a1 = (const char **)sub_8069C3A(v11);\n        v4 = *a1;\n        break;\n      case 2:\n      case 3:\n        a1 = (const char **)sub_8069C3A(v11);\n        v3 = *a1;\n        break;\n      case 4:\n        v22[6] |= 0x100u;\n        break;\n      case 5:\n        v2 = 1;\n        break;\n      case 6:\n        a1 = (const char **)sub_8069C3A(v11);\n        goto LABEL_13;\n      default:\nLABEL_13:\n        sub_8069AC1(LOBYTE(v22[4]), *a1);\n        if ( !LOBYTE(v22[4]) )\n          LOBYTE(v22[4]) = v13;\n        if ( v14 )\n          sub_8068F90(v16, v14);\n        BYTE1(v22[4]) = v15;\n        break;\n    }\n    ++a1;\n  }\n  if ( !BYTE1(v22[4]) )\n    sub_804D5E0(\"need at least destination address\");\n  sub_8068A5B(v11);\n  sub_8069345();\n  if ( v4 )\n  {\n    v6 = sub_806932A();\n    sub_8068F53(v6);\n  }\n  if ( v3 )\n  {\n    v5 = sub_806932A();\n    sub_8068F53(v5);\n  }\n  if ( !LOBYTE(v22[4]) )\n    LOBYTE(v22[4]) = 2;\n  if ( sub_8068D41(v22, v22) < 0 )\n    return 2;\n  if ( v2 && !v12 )\n  {\n    v7 = v22[0];\n    sub_8066580(0, v22);\n    if ( LOWORD(v22[1]) != 24 )\n      sub_804D5E0(\"not a route?\");\n    v8 = v7 - 28;\n    if ( v8 < 0 )\n      sub_804D5E0(\"wrong len %d\", v8);\n    sub_806901E(v8);\n    v9 = *(_WORD **)&v21[1];\n    if ( *(_DWORD *)&v21[1] )\n    {\n      *(_WORD *)(*(_DWORD *)&v21[1] + 2) = 2;\n      BYTE2(v22[4]) = 8 * *v9 - 32;\n    }\n    else if ( !v17 )\n    {\n      sub_804D5E0(\"can't connect the route\");\n    }\n    if ( !v3 && v19 )\n      *(_WORD *)(v19 + 2) = 0;\n    if ( v20 )\n      *(_WORD *)(v20 + 2) = 0;\n    if ( !v4 && v18 )\n      *(_WORD *)(v18 + 2) = 0;\n    v22[1] = 65562;\n    if ( sub_8068D41(v22, v22) < 0 )\n      return 2;\n  }\n  sub_8066580(0, v22);\n  return 0;\n}\n"
    ],
    "sub_8066EDC": [
        "0x8066edc",
        "int __usercall sub_8066EDC@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebp\n  int v4; // eax\n  int v5; // ecx\n  const char *v6; // edx\n  int v7; // eax\n  int v8; // eax\n  int v9; // eax\n  int *v10; // eax\n  int *v11; // esi\n  int v12; // eax\n  int v13; // esi\n  int v15; // [esp-4h] [ebp-E50h]\n  const char *v16; // [esp+0h] [ebp-E4Ch]\n  int v17; // [esp+0h] [ebp-E4Ch]\n  const char *v19; // [esp+8h] [ebp-E44h]\n  struct sockaddr addr; // [esp+Ch] [ebp-E40h] BYREF\n  int v21; // [esp+34h] [ebp-E18h]\n  int v22; // [esp+38h] [ebp-E14h]\n  int buf[900]; // [esp+3Ch] [ebp-E10h] BYREF\n\n  v3 = byte_80DB764;\n  sub_8066525();\n  qword_80DB778 = 254;\n  if ( a2 && !*a1 )\n    sub_804D5E0(\"%s requires an argument\", \"\\\"ip route flush\\\"\");\n  v16 = 0;\n  v19 = 0;\n  while ( *a1 )\n  {\n    v4 = sub_804D254(\"protocol\", *a1);\n    if ( v4 )\n    {\n      if ( (unsigned int)(v4 - 1) <= 1 )\n      {\n        a1 = (const char **)sub_8069C3A(v16);\n        v16 = *a1;\n        goto LABEL_49;\n      }\n      if ( v4 == 3 )\n      {\n        a1 = (const char **)sub_8069C3A(v16);\n        v19 = *a1;\n        goto LABEL_49;\n      }\n      if ( v4 == 4 )\n      {\nLABEL_44:\n        a1 = (const char **)sub_8069C3A(v16);\n        sub_8069AC1(v3, *a1);\n        goto LABEL_49;\n      }\n      if ( v4 == 5 )\n      {\n        a1 = (const char **)sub_8069C3A(v16);\n        v7 = sub_804D254(\"protocol\", *a1);\n        if ( v7 == 6 )\n          goto LABEL_26;\n        if ( v7 == 10 )\n        {\n          qword_80DB778 = 0;\n        }\n        else if ( v7 != 14 )\n        {\n          if ( sub_8069759() )\n          {\n            v6 = \"table\";\n            goto LABEL_23;\n          }\n          qword_80DB778 = buf[0];\n        }\n      }\n      else\n      {\n        if ( v4 == 6 )\n        {\nLABEL_26:\n          qword_80DB778 = -1;\n          goto LABEL_49;\n        }\n        if ( v4 == 9 )\n        {\n          a1 = (const char **)sub_8069C3A(v16);\n          unk_80DB794 = -1;\n          if ( sub_806968A() )\n          {\n            v8 = strcmp(*a1, \"all\");\n            v5 = v15;\n            if ( v8 )\n            {\n              v6 = \"scope\";\nLABEL_23:\n              sub_8069C50(v5, v6);\n            }\n            buf[0] = 255;\n            unk_80DB794 = 0;\n          }\n          unk_80DB790 = buf[0];\n        }\n        else\n        {\n          if ( v4 == 7 )\n          {\n            a1 = (const char **)sub_8069C3A(v16);\n            v9 = sub_804D254(\"protocol\", *a1);\n            if ( v9 == 11 || v9 == 12 )\n              goto LABEL_44;\n            if ( v9 == 13 )\n              a1 = (const char **)sub_8069C3A(v16);\n            sub_8069AC1(v3, *a1);\n            v10 = &dword_80DB7DC;\n            v11 = &dword_80DB7F0;\n          }\n          else\n          {\n            if ( v4 == 8 )\n            {\n              a1 = (const char **)sub_8069C3A(v16);\n              v4 = sub_804D254(\"protocol\", *a1);\n            }\n            if ( v4 == 11 || v4 == 12 )\n              goto LABEL_44;\n            if ( v4 == 13 )\n              a1 = (const char **)sub_8069C3A(v16);\n            sub_8069AC1(v3, *a1);\n            v10 = (int *)&dword_80DB7B4;\n            v11 = &dword_80DB7C8;\n          }\n          qmemcpy(v10, v11, 0x14u);\n        }\n      }\n    }\n    else\n    {\n      buf[0] = 0;\n      a1 = (const char **)sub_8069C3A(v16);\n      if ( sub_8069613() && sub_804D222(\"protocol\", *a1) != 10 )\n      {\n        v6 = \"protocol\";\n        goto LABEL_23;\n      }\n    }\nLABEL_49:\n    ++a1;\n  }\n  if ( !v3 )\n  {\n    v3 = qword_80DB778;\n    if ( qword_80DB778 )\n      v3 = 2;\n  }\n  sub_8068A5B(v16);\n  sub_8069345();\n  if ( v19 )\n    dword_80DB798 = (char *)sub_806932A();\n  if ( v17 )\n    stream = (FILE *)sub_806932A();\n  if ( a2 )\n  {\n    if ( qword_80DB778 != -1 || v3 == 10 )\n      goto LABEL_60;\n    v12 = sub_804DC14(\"/proc/sys/net/ipv4/route/flush\");\n    v13 = v12;\n    if ( v12 >= 0 )\n    {\n      if ( write(v12, \"-1\", 2u) > 1 )\n        close(v13);\n      else\n        sub_804D3A5((int)\"can't flush routing cache\");\n    }\n    if ( v3 != 2 )\n    {\nLABEL_60:\n      *(_QWORD *)&unk_80DB780 = (unsigned int)buf;\n      MEMORY[0x80DB788] = (char *)3584;\n      unk_80DB78C = &addr.sa_data[10];\n      while ( 1 )\n      {\n        sub_8068AE2(26, v3);\n        *(&qword_80DB778 + 4) = 0;\n        sub_8068BB1(0, sub_8066580);\n        if ( !*(&qword_80DB778 + 4) )\n          break;\n        if ( sub_806654A() )\n          return a2;\n      }\n    }\n    return 0;\n  }\n  else\n  {\n    if ( qword_80DB778 == -1 )\n    {\n      memset(addr.sa_data, 0, 0xAu);\n      memset(&buf[3], 0, 0xCu);\n      addr.sa_family = 16;\n      buf[0] = 28;\n      buf[1] = 16842778;\n      v22 = ++v21;\n      buf[2] = v21;\n      LOBYTE(buf[4]) = v3;\n      buf[6] = 512;\n      if ( sub_804DFCD(0x1Cu, buf, *(int *)&addr.sa_data[10], &addr, 0xCu) < 0 )\n        sub_804D3C9((int)\"can't send dump request\");\n    }\n    else\n    {\n      sub_8068AE2(26, v3);\n    }\n    sub_8068BB1(0, sub_8066580);\n  }\n  return a2;\n}\n"
    ],
    "sub_8067375": [
        "0x8067375",
        "unsigned int __usercall sub_8067375@<eax>(int a1@<eax>, __int16 a2@<dx>, const char **a3@<ecx>)\n{\n  int v4; // esi\n  const char *v5; // ebp\n  int v6; // edi\n  int v7; // eax\n  int v8; // eax\n  int v9; // ecx\n  int v10; // eax\n  int v11; // ecx\n  int v12; // ecx\n  const char *v13; // edx\n  int v14; // eax\n  int v16; // [esp+Ch] [ebp-560h]\n  int v17; // [esp+Ch] [ebp-560h]\n  int v18; // [esp+Ch] [ebp-560h]\n  int v19; // [esp+Ch] [ebp-560h]\n  int v20; // [esp+Ch] [ebp-560h]\n  int v21; // [esp+10h] [ebp-55Ch]\n  int v22; // [esp+10h] [ebp-55Ch]\n  char v23; // [esp+17h] [ebp-555h]\n  char v24; // [esp+18h] [ebp-554h]\n  unsigned int v25; // [esp+1Ch] [ebp-550h]\n  int v26[8]; // [esp+20h] [ebp-54Ch] BYREF\n  int v27; // [esp+40h] [ebp-52Ch]\n  char v28[252]; // [esp+44h] [ebp-528h] BYREF\n  _DWORD v29[267]; // [esp+140h] [ebp-42Ch] BYREF\n\n  v21 = a1;\n  memset(v29, 0, 0x41Cu);\n  v29[0] = 28;\n  HIWORD(v29[1]) = a2 | 1;\n  LOWORD(v29[1]) = a1;\n  LOBYTE(v29[4]) = byte_80DB764;\n  LOBYTE(v29[5]) = -2;\n  BYTE2(v29[5]) = -1;\n  if ( a1 != 25 )\n  {\n    *(_WORD *)((char *)&v29[5] + 1) = 3;\n    HIBYTE(v29[5]) = 1;\n  }\n  v27 = 524292;\n  v23 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  while ( *a3 )\n  {\n    v7 = sub_804D254(\"src\", *a3);\n    switch ( v7 )\n    {\n      case 0:\n        a3 = (const char **)sub_8069C3A(v21);\n        sub_8069A87(LOBYTE(v29[4]), *a3);\n        if ( !LOBYTE(v29[4]) )\n          LOBYTE(v29[4]) = v25;\nLABEL_52:\n        sub_8068F90(v26, BYTE1(v25));\n        break;\n      case 1:\n        v4 |= 1u;\n        a3 = (const char **)sub_8069C3A(v21);\n        sub_8069A87(LOBYTE(v29[4]), *a3);\n        if ( !LOBYTE(v29[4]) )\n          LOBYTE(v29[4]) = v25;\n        goto LABEL_52;\n      case 2:\n        a3 = (const char **)sub_8069C3A(v21);\n        v8 = strcmp(*a3, \"lock\");\n        v9 = v16;\n        if ( !v8 )\n        {\n          v6 |= 4u;\n          a3 = (const char **)sub_8069C3A(v21);\n        }\n        v17 = sub_8069C5C(v9, \"mtu\");\n        sub_8068FDE(v17);\n        break;\n      case 3:\n        a3 = (const char **)sub_8069C3A(v21);\n        v10 = strcmp(*a3, \"lock\");\n        v11 = v18;\n        if ( !v10 )\n        {\n          v6 |= 0x100u;\n          a3 = (const char **)sub_8069C3A(v21);\n        }\n        v19 = sub_8069C5C(v11, \"advmss\");\n        sub_8068FDE(v19);\n        break;\n      case 4:\n        a3 = (const char **)sub_8069C3A(v21);\n        if ( sub_806968A() )\n        {\n          v13 = \"scope\";\n          goto LABEL_28;\n        }\n        BYTE2(v29[5]) = v25;\n        v23 = 1;\n        break;\n      case 5:\n        a3 = (const char **)sub_8069C3A(v21);\n        if ( sub_8069613() )\n        {\n          v13 = \"protocol\";\n          goto LABEL_28;\n        }\n        BYTE1(v29[5]) = v25;\n        v4 |= 4u;\n        break;\n      case 6:\n        a3 = (const char **)sub_8069C3A(v21);\n        if ( sub_8069759() )\n        {\n          v13 = \"table\";\nLABEL_28:\n          sub_8069C50(v12, v13);\n        }\n        if ( v25 <= 0xFF )\n        {\n          LOBYTE(v29[5]) = v25;\n        }\n        else\n        {\n          LOBYTE(v29[5]) = 0;\n          sub_8068F53(v25);\n        }\n        break;\n      default:\n        if ( (unsigned int)(v7 - 7) <= 1 )\n        {\n          a3 = (const char **)sub_8069C3A(v21);\n          v5 = *a3;\n          break;\n        }\n        switch ( v7 )\n        {\n          case 10:\n            a3 = (const char **)sub_8069C3A(v21);\n            v20 = sub_8069C92();\n            sub_8068F53(v20);\n            goto LABEL_53;\n          case 11:\n            v29[6] |= 4u;\n            goto LABEL_53;\n          case 9:\n            a3 = (const char **)sub_8069C3A(v21);\n            break;\n        }\n        if ( (unsigned __int8)(**a3 - 48) > 9u && !sub_80697D1() )\n        {\n          a3 = (const char **)sub_8069C3A(v21);\n          HIBYTE(v29[5]) = v24;\n          v4 |= 8u;\n        }\n        if ( (v4 & 2) != 0 )\n          sub_8069CE0();\n        sub_8069AC1(LOBYTE(v29[4]), *a3);\n        if ( !LOBYTE(v29[4]) )\n          LOBYTE(v29[4]) = v25;\n        BYTE1(v29[4]) = BYTE2(v25);\n        v4 |= 2u;\n        if ( BYTE1(v25) )\n          goto LABEL_52;\n        break;\n    }\nLABEL_53:\n    ++a3;\n  }\n  sub_8068A5B(v21);\n  if ( v5 )\n  {\n    sub_8069345();\n    v14 = sub_806932A();\n    sub_8068F53(v14);\n  }\n  if ( (unsigned __int16)v27 > 4u )\n  {\n    if ( v6 )\n      sub_8068FDE(v6);\n    sub_8068F90(v28, (unsigned __int16)v27 - 4);\n  }\n  if ( !v23 )\n  {\n    if ( (HIBYTE(v29[5]) & 0xF7) == 2 )\n    {\n      BYTE2(v29[5]) = -2;\n      goto LABEL_69;\n    }\n    if ( (unsigned __int8)(HIBYTE(v29[5]) - 3) > 2u )\n    {\n      if ( HIBYTE(v29[5]) <= 1u )\n      {\n        if ( v22 == 25 )\n        {\n          BYTE2(v29[5]) = -1;\n        }\n        else if ( (v4 & 1) == 0 )\n        {\n          goto LABEL_64;\n        }\n      }\n    }\n    else\n    {\nLABEL_64:\n      BYTE2(v29[5]) = -3;\n    }\n  }\nLABEL_69:\n  if ( !LOBYTE(v29[4]) )\n    LOBYTE(v29[4]) = 2;\n  return 2 * ((unsigned int)sub_8068D41(0, v29) >> 31);\n}\n"
    ],
    "sub_806780A": [
        "0x806780a",
        "int __usercall sub_806780A@<eax>(const char **a1@<eax>)\n{\n  int v1; // edx\n  const char **v2; // ebx\n  int v3; // ecx\n  int v4; // kr00_4\n  int v5; // ebx\n  __int16 v6; // dx\n\n  v1 = (int)*a1;\n  if ( *a1 )\n  {\n    v2 = a1;\n    v4 = sub_804D254(\"a\", (const char *)v1);\n    a1 = v2 + 1;\n    switch ( v4 )\n    {\n      case 0:\n      case 1:\n        v5 = 24;\n        v6 = 1536;\n        return sub_8067375(v5, v6, a1);\n      case 2:\n        v5 = 24;\n        v6 = 3072;\n        return sub_8067375(v5, v6, a1);\n      case 3:\n      case 4:\n        v5 = 24;\n        v6 = 256;\n        return sub_8067375(v5, v6, a1);\n      case 5:\n        v5 = 25;\n        v6 = 0;\n        return sub_8067375(v5, v6, a1);\n      case 6:\n        return sub_8066BBA(a1);\n      case 7:\n      case 8:\n        v1 = 0;\n        return sub_8066EDC(a1, v1);\n      case 9:\n        v5 = 24;\n        v6 = 1024;\n        return sub_8067375(v5, v6, a1);\n      case 10:\n        v5 = 24;\n        v6 = 1280;\n        return sub_8067375(v5, v6, a1);\n      case 11:\n        v5 = 24;\n        v6 = 512;\n        return sub_8067375(v5, v6, a1);\n      case 12:\n        v1 = 1;\n        return sub_8066EDC(a1, v1);\n      default:\n        sub_8069C50(v3, ident);\n    }\n  }\n  return sub_8066EDC(a1, v1);\n}\n"
    ],
    "sub_80678A9": [
        "0x80678a9",
        "unsigned int __usercall sub_80678A9@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  char v4; // di\n  char v5; // al\n  int v6; // ecx\n  const char *v7; // edx\n  int v8; // eax\n  int v10; // [esp+0h] [ebp-458h]\n  size_t v11; // [esp+0h] [ebp-458h]\n  const char *v12; // [esp+4h] [ebp-454h]\n  unsigned int v13; // [esp+8h] [ebp-450h]\n  int v14[8]; // [esp+Ch] [ebp-44Ch] BYREF\n  int v15[267]; // [esp+2Ch] [ebp-42Ch] BYREF\n\n  memset(v15, 0, 0x41Cu);\n  LOWORD(v15[1]) = a1;\n  v15[0] = 28;\n  HIWORD(v15[1]) = 1;\n  LOBYTE(v15[4]) = byte_80DB764;\n  BYTE1(v15[5]) = 3;\n  if ( a1 == 32 )\n  {\n    HIWORD(v15[1]) = 1537;\n    HIBYTE(v15[5]) = 1;\n  }\n  v4 = 0;\n  while ( *a2 )\n  {\n    v5 = sub_804D254(\"from\", *a2);\n    switch ( v5 )\n    {\n      case -1:\n        v7 = ident;\n        goto LABEL_16;\n      case 0:\n        a2 = (const char **)sub_8069C3A(v12);\n        sub_8069AC1(LOBYTE(v15[4]), *a2);\n        BYTE2(v15[4]) = BYTE2(v13);\n        sub_8068F90(v14, BYTE1(v13));\n        goto LABEL_44;\n      case 1:\n        a2 = (const char **)sub_8069C3A(v12);\n        sub_8069AC1(LOBYTE(v15[4]), *a2);\n        BYTE1(v15[4]) = BYTE2(v13);\n        sub_8068F90(v14, BYTE1(v13));\n        goto LABEL_44;\n    }\n    if ( (unsigned __int8)(v5 - 2) <= 2u )\n    {\nLABEL_19:\n      a2 = (const char **)sub_8069C3A(v12);\n      v10 = sub_8069C92();\n      sub_8068F53(v10);\n      goto LABEL_44;\n    }\n    switch ( v5 )\n    {\n      case 5:\n        a2 = (const char **)sub_8069C3A(v12);\n        if ( sub_8069714() )\n        {\n          v7 = \"TOS\";\n          goto LABEL_16;\n        }\n        HIBYTE(v15[4]) = v13;\n        break;\n      case 6:\n        goto LABEL_19;\n      case 7:\n        a2 = (const char **)sub_8069C3A(v12);\n        if ( sub_80698A2() )\n        {\n          v7 = \"realms\";\n          goto LABEL_16;\n        }\n        sub_8068F53(v13);\n        break;\n      default:\n        if ( (unsigned __int8)(v5 - 8) > 1u )\n        {\n          if ( v5 == 10 || v5 == 11 )\n            goto LABEL_19;\n          if ( (unsigned __int8)(v5 - 12) > 1u )\n          {\n            if ( (unsigned __int8)(v5 - 14) > 1u )\n            {\n              if ( v5 == 16 )\n              {\n                a2 = (const char **)sub_8069C3A(v12);\n              }\n              else if ( v5 == 17 )\n              {\n                sub_804CDC2();\n              }\n              if ( sub_80697D1() )\n              {\n                v7 = \"type\";\nLABEL_16:\n                sub_8069C50(v6, v7);\n              }\n              HIBYTE(v15[5]) = v13;\n            }\n            else\n            {\n              a2 = (const char **)sub_8069C3A(v12);\n              v8 = sub_8069C04();\n              sub_8068F53(v8);\n              HIBYTE(v15[5]) = 10;\n            }\n          }\n          else\n          {\n            a2 = (const char **)sub_8069C3A(v12);\n            v12 = *a2;\n            v11 = strlen(*a2) + 1;\n            sub_8068F90(v12, v11);\n          }\n        }\n        else\n        {\n          a2 = (const char **)sub_8069C3A(v12);\n          if ( sub_8069759() )\n          {\n            v7 = \"table ID\";\n            goto LABEL_16;\n          }\n          if ( v13 <= 0xFF )\n          {\n            LOBYTE(v15[5]) = v13;\n          }\n          else\n          {\n            LOBYTE(v15[5]) = 0;\n            sub_8068F53(v13);\n          }\n          v4 = 1;\n        }\n        break;\n    }\nLABEL_44:\n    ++a2;\n  }\n  if ( !LOBYTE(v15[4]) )\n    LOBYTE(v15[4]) = 2;\n  if ( !v4 && a1 == 32 )\n    LOBYTE(v15[5]) = -2;\n  sub_8068A5B(v12);\n  return 2 * ((unsigned int)sub_8068D41(0, v15) >> 31);\n}\n"
    ],
    "sub_8067BE7": [
        "0x8067be7",
        "int __fastcall sub_8067BE7(int a1, int *a2)\n{\n  int v2; // ecx\n  int result; // eax\n  char v5; // al\n  int v6; // esi\n  int v7; // eax\n  int v8; // ecx\n  int v9; // edi\n  int v10; // edx\n  const char *v11; // eax\n  int v12; // ecx\n  int v13; // edx\n  int v14; // edi\n  int v15; // edx\n  const char *v16; // eax\n  const char *v17; // eax\n  const char *v18; // eax\n  int v19; // eax\n  int v20; // eax\n  const char *v21; // eax\n  const char *v22; // eax\n  char v23; // al\n  const char *v24; // eax\n  int v25; // [esp-8h] [ebp-80h]\n  int v26; // [esp-8h] [ebp-80h]\n  int v27; // [esp-4h] [ebp-7Ch]\n  int v28; // [esp-4h] [ebp-7Ch]\n  int v29; // [esp+4h] [ebp-74h]\n  int v30; // [esp+8h] [ebp-70h]\n  int v31; // [esp+Ch] [ebp-6Ch]\n  int v32; // [esp+14h] [ebp-64h]\n  int v33; // [esp+18h] [ebp-60h]\n  int v34; // [esp+28h] [ebp-50h]\n  int v35; // [esp+2Ch] [ebp-4Ch]\n  int v36; // [esp+34h] [ebp-44h]\n  int v37; // [esp+38h] [ebp-40h]\n  int v38; // [esp+3Ch] [ebp-3Ch]\n\n  v2 = *a2;\n  result = 0;\n  if ( *((_WORD *)a2 + 2) == 32 )\n  {\n    result = -1;\n    if ( v2 - 28 >= 0 )\n    {\n      sub_806901E(v2 - 28);\n      v5 = *((_BYTE *)a2 + 16);\n      v6 = 32;\n      if ( v5 != 2 )\n        v6 = v5 == 10 ? 0x80 : -1;\n      v7 = 0;\n      if ( v33 )\n        v7 = *(_DWORD *)(v33 + 4);\n      printf(\"%u:\\t\", v7);\n      printf(\"from \");\n      if ( v30 )\n      {\n        v9 = *((unsigned __int8 *)a2 + 18);\n        v10 = v30 + 4;\n        if ( v9 == v6 )\n        {\n          sub_8069D47(v8, v10);\n          fputs_unlocked();\n        }\n        else\n        {\n          v11 = (const char *)sub_8069D47(v8, v10);\n          printf(\"%s/%u\", v11, v9);\n        }\n      }\n      else if ( *((_BYTE *)a2 + 18) )\n      {\n        printf(\"0/%d\", *((unsigned __int8 *)a2 + 18));\n      }\n      else\n      {\n        printf(\"all\");\n      }\n      sub_804DD98(32);\n      v13 = v29;\n      if ( v29 )\n      {\n        v14 = *((unsigned __int8 *)a2 + 17);\n        v15 = v29 + 4;\n        if ( v14 == v6 )\n        {\n          sub_8069D47(v12, v15);\n          printf(\"to %s \");\n        }\n        else\n        {\n          v16 = (const char *)sub_8069D47(v12, v15);\n          printf(\"to %s/%u \", v16, v14);\n        }\n      }\n      else if ( *((_BYTE *)a2 + 17) )\n      {\n        printf(\"to 0/%d \");\n      }\n      if ( *((_BYTE *)a2 + 19) )\n      {\n        v17 = (const char *)sub_80696EE();\n        printf(\"tos %s \", v17);\n        v12 = v25;\n      }\n      if ( v34 )\n      {\n        printf(\"fwmark %#x \", *(_DWORD *)(v34 + 4));\n        v13 = v27;\n      }\n      if ( v31 )\n        printf(\"iif %s \", (const char *)(v31 + 4));\n      if ( v38 || *((_BYTE *)a2 + 20) )\n      {\n        v18 = (const char *)sub_8069733(v12, v13);\n        printf(\"lookup %s \", v18);\n        v12 = v26;\n      }\n      if ( v37 )\n      {\n        v19 = *(_DWORD *)(v37 + 4);\n        if ( v19 != -1 )\n          printf(\"%s %d \", \"suppress_prefixlength\", v19);\n      }\n      if ( v36 )\n      {\n        v20 = *(_DWORD *)(v36 + 4);\n        if ( v20 != -1 )\n          printf(\"%s %d \", \"suppress_ifgroup\", v20);\n      }\n      if ( v35 )\n      {\n        if ( HIWORD(*(_DWORD *)(v35 + 4)) )\n        {\n          v21 = (const char *)sub_80696C8(v12, v13);\n          printf(\"realms %s/\", v21);\n          v13 = v28;\n        }\n        v22 = (const char *)sub_80696C8(v12, v13);\n        printf(\"%s \", v22);\n      }\n      v23 = *((_BYTE *)a2 + 23);\n      if ( v23 == 10 )\n      {\n        if ( v32 )\n        {\n          v24 = (const char *)sub_8069D47(v12, v32 + 4);\n          printf(\"map-to %s \", v24);\n        }\n        else\n        {\n          printf(\"masquerade\");\n        }\n      }\n      else if ( v23 != 1 )\n      {\n        sub_8069778(v12, v13);\n        fputs_unlocked();\n      }\n      sub_804DD98(10);\n      return 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8067E6D": [
        "0x8067e6d",
        "unsigned int __usercall sub_8067E6D@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  int v5; // esi\n\n  v1 = a1;\n  if ( *a1 )\n  {\n    v2 = sub_804D254(\"add\", *a1);\n    if ( v2 < 0 )\n      sub_8069C50(v3, ident);\n    ++v1;\n    if ( v2 <= 1 )\n      return sub_80678A9(33 - (v2 == 0), v1);\n  }\n  v5 = byte_80DB764;\n  if ( !byte_80DB764 )\n    v5 = 2;\n  if ( *v1 )\n  {\n    sub_80B3CE5();\n    return -1;\n  }\n  else\n  {\n    sub_8068A5B();\n    sub_8068AE2(34, v5);\n    sub_8068BB1(0, sub_8067BE7);\n    return 0;\n  }\n}\n"
    ],
    "sub_8067EF6": [
        "0x8067ef6",
        "int __usercall sub_8067EF6@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebx\n  int v4; // esi\n  char v6[16]; // [esp+0h] [ebp-28h] BYREF\n  int v7; // [esp+10h] [ebp-18h]\n\n  sub_804D67E(v6, a1);\n  v7 = a2;\n  v3 = sub_804DF99(0, 2, 2);\n  v4 = sub_804E09D(v3, 0x89F0u, (int)v6, \"SIOCGETTUNNEL\");\n  close(v3);\n  return v4;\n}\n"
    ],
    "sub_8067F40": [
        "0x8067f40",
        "int __usercall sub_8067F40@<eax>(int a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  int v5; // eax\n  int v6; // ebx\n  char v8[16]; // [esp+0h] [ebp-28h] BYREF\n  const char *v9; // [esp+10h] [ebp-18h]\n\n  if ( a1 == 35315 && *a3 )\n    a2 = a3;\n  sub_804D67E(v8, a2);\n  v9 = a3;\n  v5 = sub_804DF99(0, 2, 2);\n  v6 = v5;\n  if ( a1 == 35315 )\n    sub_804E0BE(v5, 0x89F3u, (int)v8, \"SIOCCHGTUNNEL\");\n  else\n    sub_804E0BE(v5, 0x89F1u, (int)v8, \"SIOCADDTUNNEL\");\n  close(v6);\n  return 0;\n}\n"
    ],
    "sub_8067FB0": [
        "0x8067fb0",
        "int __usercall sub_8067FB0@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v2; // ebx\n  int v3; // ebx\n  char v5[16]; // [esp+0h] [ebp-24h] BYREF\n  int v6; // [esp+10h] [ebp-14h]\n\n  v2 = (int)a2;\n  if ( !*a2 )\n    a2 = a1;\n  sub_804D67E(v5, a2);\n  v6 = v2;\n  v3 = sub_804DF99(0, 2, 2);\n  sub_804E0BE(v3, 0x89F2u, (int)v5, \"SIOCDELTUNNEL\");\n  close(v3);\n  return 0;\n}\n"
    ],
    "sub_8067FFB": [
        "0x8067ffb",
        "unsigned __int32 __usercall sub_8067FFB@<eax>(int *s1@<ecx>, const char **a2@<eax>, int a3@<edx>)\n{\n  int v5; // eax\n  int v6; // eax\n  char v7; // al\n  char v8; // al\n  int v9; // edx\n  int v10; // eax\n  char *v11; // eax\n  int v12; // ecx\n  int v13; // edx\n  char *v14; // eax\n  int v15; // eax\n  int v16; // ecx\n  unsigned int v17; // eax\n  int v18; // ecx\n  const char *v19; // edx\n  char v20; // al\n  int v21; // esi\n  unsigned int v22; // edx\n  unsigned __int32 result; // eax\n  int v24; // [esp-8h] [ebp-64h]\n  int v25; // [esp-8h] [ebp-64h]\n  int v26; // [esp-4h] [ebp-60h]\n  int v27; // [esp-4h] [ebp-60h]\n  int v28; // [esp+0h] [ebp-5Ch]\n  char v30[16]; // [esp+8h] [ebp-54h] BYREF\n  int v31[17]; // [esp+18h] [ebp-44h] BYREF\n\n  memset(s1, 0, 0x34u);\n  v30[0] = 0;\n  *((_BYTE *)s1 + 32) = 69;\n  *((_WORD *)s1 + 19) = 64;\n  v28 = 0;\n  while ( *a2 )\n  {\n    v5 = sub_804D222(\"mode\", *a2);\n    if ( v5 )\n    {\n      switch ( v5 )\n      {\n        case 7:\n          a2 = (const char **)sub_8069C3A(v28);\n          *((_WORD *)s1 + 10) |= 0x20u;\n          *((_WORD *)s1 + 11) |= 0x20u;\n          if ( strchr(*a2, 46) )\n            v10 = sub_8069C04(v24, v9);\n          else\n            v10 = _byteswap_ulong(sub_8069C5C(v24, \"key\"));\n          s1[7] = v10;\n          goto LABEL_22;\n        case 8:\n          a2 = (const char **)sub_8069C3A(v28);\n          *((_WORD *)s1 + 10) |= 0x20u;\n          v11 = strchr(*a2, 46);\n          v13 = v26;\n          if ( !v11 )\n          {\n            v10 = _byteswap_ulong(sub_8069C5C(v12, \"ikey\"));\nLABEL_22:\n            s1[6] = v10;\n            break;\n          }\nLABEL_28:\n          v15 = sub_8069C04(v12, v13);\n          goto LABEL_30;\n        case 9:\n          a2 = (const char **)sub_8069C3A(v28);\n          *((_WORD *)s1 + 11) |= 0x20u;\n          v14 = strchr(*a2, 46);\n          v13 = v25;\n          v12 = v27;\n          if ( v14 )\n            goto LABEL_28;\n          v15 = _byteswap_ulong(sub_8069C5C(v27, \"okey\"));\nLABEL_30:\n          s1[7] = v15;\n          break;\n        case 10:\n          *((_WORD *)s1 + 10) |= 0x10u;\nLABEL_36:\n          *((_WORD *)s1 + 11) |= 0x10u;\n          break;\n        case 11:\n          *((_WORD *)s1 + 10) |= 0x10u;\n          break;\n        case 12:\n          goto LABEL_36;\n        case 13:\n          *((_WORD *)s1 + 10) |= 0x80u;\nLABEL_42:\n          *((_WORD *)s1 + 11) |= 0x80u;\n          break;\n        case 14:\n          *((_WORD *)s1 + 10) |= 0x80u;\n          break;\n        case 15:\n          goto LABEL_42;\n        case 16:\n          *((_WORD *)s1 + 19) = 0;\n          break;\n        case 17:\n          *((_WORD *)s1 + 19) = 64;\n          break;\n        case 18:\n          a2 = (const char **)sub_8069C3A(v28);\n          if ( sub_804D222(\"mode\", *a2) != 19 )\n            s1[12] = ((int (*)(void))sub_8069C04)();\n          break;\n        case 20:\n          a2 = (const char **)sub_8069C3A(v28);\n          if ( sub_804D222(\"mode\", *a2) != 19 )\n            s1[11] = ((int (*)(void))sub_8069C04)();\n          break;\n        case 21:\n          a2 = (const char **)sub_8069C3A(v28);\n          sub_804D67E(v30, *a2);\n          break;\n        case 22:\n          a2 = (const char **)sub_8069C3A(v28);\n          if ( sub_804D222(\"mode\", *a2) != 23 )\n          {\n            v17 = sub_8069C5C(v16, \"TTL\");\n            if ( v17 > 0xFF )\n            {\n              v19 = \"TTL\";\n              goto LABEL_64;\n            }\n            *((_BYTE *)s1 + 40) = v17;\n          }\n          break;\n        default:\n          if ( (unsigned int)(v5 - 24) > 1 )\n          {\n            if ( v5 == 26 )\n              a2 = (const char **)sub_8069C3A(v28);\n            if ( *(_BYTE *)s1 )\n              sub_8069CE0();\n            sub_804D67E((char *)s1, *a2);\n            if ( a3 == 35315 && !v28 )\n            {\n              memset(v31, 0, 0x34u);\n              if ( sub_8067EF6(*a2, (int)v31) )\n                exit(1);\n              qmemcpy(s1, v31, 0x34u);\n            }\n          }\n          else\n          {\n            a2 = (const char **)sub_8069C3A(v28);\n            if ( sub_804D222(\"mode\", *a2) == 23 )\n            {\n              *((_BYTE *)s1 + 33) = 1;\n            }\n            else\n            {\n              if ( sub_8069714() )\n              {\n                v19 = \"TOS\";\nLABEL_64:\n                sub_8069C50(v18, v19);\n              }\n              *((_BYTE *)s1 + 33) = v31[0];\n            }\n          }\n          break;\n      }\n    }\n    else\n    {\n      a2 = (const char **)sub_8069C3A(v28);\n      v6 = sub_804D222(\"mode\", *a2);\n      if ( (unsigned int)(v6 - 1) > 1 )\n      {\n        if ( (unsigned int)(v6 - 3) > 1 )\n        {\n          if ( (unsigned int)(v6 - 5) > 1 )\n            sub_804D5E0(\"%s tunnel mode\", \"can't guess\");\n          v8 = *((_BYTE *)s1 + 41);\n          if ( v8 && v8 != 41 )\nLABEL_6:\n            sub_804D5E0(\"%s tunnel mode\", \"you managed to ask for more than one\");\n          *((_BYTE *)s1 + 41) = 41;\n        }\n        else\n        {\n          v7 = *((_BYTE *)s1 + 41);\n          if ( v7 && v7 != 47 )\n            goto LABEL_6;\n          *((_BYTE *)s1 + 41) = 47;\n        }\n      }\n      else\n      {\n        if ( (*((_BYTE *)s1 + 41) & 0xFB) != 0 )\n          goto LABEL_6;\n        *((_BYTE *)s1 + 41) = 4;\n      }\n    }\n    ++v28;\n    ++a2;\n  }\n  if ( !*((_BYTE *)s1 + 41) )\n  {\n    if ( !memcmp(s1, \"gre\", 3u) )\n    {\n      *((_BYTE *)s1 + 41) = 47;\n    }\n    else if ( !memcmp(s1, \"ipip\", 4u) )\n    {\n      *((_BYTE *)s1 + 41) = 4;\n    }\n    else if ( !memcmp(s1, \"sit\", 3u) )\n    {\n      *((_BYTE *)s1 + 41) = 41;\n    }\n  }\n  v20 = *((_BYTE *)s1 + 41);\n  if ( (v20 == 4 || v20 == 41) && ((s1[5] & 0x20) != 0 || (*((_BYTE *)s1 + 22) & 0x20) != 0) )\n    sub_804D5E0(\"keys are not allowed with ipip and sit\");\n  if ( v30[0] )\n  {\n    sub_804D67E((char *)v31, v30);\n    v21 = sub_804DF99(0, 2, 2);\n    sub_804E0BE(v21, 0x8933u, (int)v31, \"SIOCGIFINDEX\");\n    close(v21);\n    s1[4] = v31[4];\n  }\n  v22 = s1[12];\n  result = _byteswap_ulong(v22) & 0xF0000000;\n  if ( !s1[6] && result == -536870912 )\n  {\n    s1[6] = v22;\n    *((_WORD *)s1 + 10) |= 0x20u;\n  }\n  if ( s1[7] )\n  {\n    if ( result == -536870912 )\n      goto LABEL_98;\n  }\n  else if ( result == -536870912 )\n  {\n    s1[7] = v22;\n    *((_WORD *)s1 + 11) |= 0x20u;\nLABEL_98:\n    if ( !s1[11] )\n      sub_804D5E0(\"broadcast tunnel requires a source address\");\n  }\n  return result;\n}\n"
    ],
    "sub_806848D": [
        "0x806848d",
        "int __usercall sub_806848D@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  const char *v3; // edx\n  int v5[9]; // [esp+0h] [ebp-38h] BYREF\n  __int16 v6; // [esp+26h] [ebp-12h]\n  char v7; // [esp+28h] [ebp-10h]\n  char v8; // [esp+29h] [ebp-Fh]\n\n  sub_8067FFB(v5, a2, a1);\n  if ( v7 && !v6 )\n    sub_804D5E0(\"ttl != 0 and noptmudisc are incompatible\");\n  switch ( v8 )\n  {\n    case 41:\n      v3 = \"sit0\";\n      break;\n    case 47:\n      v3 = \"gre0\";\n      break;\n    case 4:\n      v3 = \"tunl0\";\n      break;\n    default:\n      sub_804D5E0(\"can't determine tunnel mode (ipip, gre or sit)\");\n  }\n  return sub_8067F40(a1, v3, (const char *)v5);\n}\n"
    ],
    "sub_80684F3": [
        "0x80684f3",
        "const char *__usercall sub_80684F3@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // esi\n  const char *v4; // eax\n  char v5; // cl\n  const char *v6; // edx\n  int v7; // edi\n  int v8; // ebp\n  const char *v9; // eax\n  char *v10; // edi\n  const char *v11; // eax\n  const char *result; // eax\n  const char *v13; // [esp-8h] [ebp-48h]\n  int v14; // [esp-8h] [ebp-48h]\n  char buf[16]; // [esp+0h] [ebp-40h] BYREF\n  char v16[16]; // [esp+10h] [ebp-30h] BYREF\n  int v17; // [esp+20h] [ebp-20h]\n\n  v3 = \"any\";\n  if ( *(_DWORD *)(a1 + 44) )\n    v3 = (const char *)sub_8069D47(a2, a1 + 44);\n  v4 = \"any\";\n  if ( *(_DWORD *)(a1 + 48) )\n    v4 = (const char *)sub_8069D47(a2, a1 + 48);\n  v5 = *(_BYTE *)(a1 + 41);\n  v6 = \"ip\";\n  if ( v5 != 4 )\n  {\n    v6 = \"gre\";\n    if ( v5 != 47 )\n    {\n      v6 = \"ipv6\";\n      if ( v5 != 41 )\n        v6 = \"unknown\";\n    }\n  }\n  printf(\"%s: %s/ip  remote %s  local %s \", (const char *)a1, v6, v4, v3);\n  if ( *(_DWORD *)(a1 + 16) )\n  {\n    v17 = *(_DWORD *)(a1 + 16);\n    v7 = sub_804DF99(0, 2, 2);\n    v8 = sub_804E09D(v7, 0x8910u, (int)v16, \"SIOCGIFNAME\");\n    close(v7);\n    if ( !v8 )\n    {\n      v9 = sub_804DB5D(v16, 16);\n      v10 = (char *)v9;\n      if ( v9 )\n      {\n        printf(\" dev %s \", v9);\n        free(v10);\n      }\n    }\n  }\n  if ( *(_BYTE *)(a1 + 40) )\n    printf(\" ttl %d \", *(unsigned __int8 *)(a1 + 40));\n  else\n    printf(\" ttl inherit \");\n  if ( *(_BYTE *)(a1 + 33) )\n  {\n    printf(\" tos\");\n    if ( (*(_BYTE *)(a1 + 33) & 1) != 0 )\n      printf(\" inherit\");\n    if ( (*(_BYTE *)(a1 + 33) & 0xFE) != 0 )\n    {\n      v11 = (const char *)sub_80696EE();\n      printf(\"%c%s \", (*(_BYTE *)(a1 + 33) & 1) == 0 ? 32 : 47, v11);\n    }\n  }\n  if ( (*(_BYTE *)(a1 + 38) & 0x40) == 0 )\n    printf(\" nopmtudisc\");\n  inet_ntop(2, (const void *)(a1 + 24), buf, 0x10u);\n  result = inet_ntop(2, (const void *)(a1 + 28), v16, 0x10u);\n  if ( (*(_BYTE *)(a1 + 20) & 0x20) != 0 )\n  {\n    if ( (*(_BYTE *)(a1 + 22) & 0x20) != 0 && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a1 + 24) )\n    {\n      result = (const char *)printf(\" key %s\");\n      goto LABEL_30;\n    }\n    result = (const char *)printf(\" ikey %s \", buf);\n  }\n  if ( (*(_BYTE *)(a1 + 22) & 0x20) != 0 )\n    result = (const char *)printf(\" okey %s \");\nLABEL_30:\n  if ( (*(_BYTE *)(a1 + 20) & 0x10) != 0 )\n  {\n    printf(\"%c  Drop packets out of sequence.\\n\", (unsigned __int8)byte_80DBBA5);\n    result = v13;\n  }\n  if ( *(char *)(a1 + 20) < 0 )\n    result = (const char *)printf(\"%c  Checksum in received packet is required.\", (unsigned __int8)byte_80DBBA5);\n  if ( (*(_BYTE *)(a1 + 22) & 0x10) != 0 )\n    result = (const char *)printf(\"%c  Sequence packets on output.\", (unsigned __int8)byte_80DBBA5);\n  if ( *(char *)(a1 + 22) < 0 )\n  {\n    printf(\"%c  Checksum output packets.\", (unsigned __int8)byte_80DBBA5);\n    return (const char *)v14;\n  }\n  return result;\n}\n"
    ],
    "sub_806871D": [
        "0x806871d",
        "char *__usercall sub_806871D@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  char *result; // eax\n  char *v4; // eax\n  int v5; // edi\n  int v6; // ecx\n  int v7; // eax\n  int v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  int v12; // [esp-4h] [ebp-2B4h]\n  char *v13; // [esp+0h] [ebp-2B0h]\n  char *v14; // [esp+0h] [ebp-2B0h]\n  char v15; // [esp+4h] [ebp-2ACh] BYREF\n  char v16; // [esp+8h] [ebp-2A8h] BYREF\n  char v17; // [esp+Ch] [ebp-2A4h] BYREF\n  char v18; // [esp+10h] [ebp-2A0h] BYREF\n  char v19; // [esp+14h] [ebp-29Ch] BYREF\n  char v20; // [esp+18h] [ebp-298h] BYREF\n  char v21; // [esp+1Ch] [ebp-294h] BYREF\n  char v22; // [esp+20h] [ebp-290h] BYREF\n  char v23; // [esp+24h] [ebp-28Ch] BYREF\n  char v24; // [esp+28h] [ebp-288h] BYREF\n  char v25; // [esp+2Ch] [ebp-284h] BYREF\n  char v26; // [esp+30h] [ebp-280h] BYREF\n  char v27; // [esp+34h] [ebp-27Ch] BYREF\n  char v28; // [esp+38h] [ebp-278h] BYREF\n  char s2[16]; // [esp+3Ch] [ebp-274h] BYREF\n  char v30[16]; // [esp+4Ch] [ebp-264h] BYREF\n  int v31; // [esp+5Ch] [ebp-254h]\n  char s1[52]; // [esp+6Ch] [ebp-244h] BYREF\n  char s[528]; // [esp+A0h] [ebp-210h] BYREF\n\n  result = (char *)sub_80B3D18(a2, \"r\");\n  if ( result )\n  {\n    fgets_unlocked();\n    fgets_unlocked();\n    while ( 1 )\n    {\n      result = (char *)fgets_unlocked();\n      if ( !result )\n        break;\n      v4 = strchr(s, 58);\n      if ( !v4 )\n        return sub_804D5F4(\"wrong format of /proc/net/dev\");\n      v13 = v4 + 1;\n      *v4 = 0;\n      if ( sscanf(s, \"%s\", s2) != 1 )\n        return sub_804D5F4(\"wrong format of /proc/net/dev\");\n      if ( sscanf(\n             v13,\n             \"%lu%lu%lu%lu%lu%lu%lu%*d%lu%lu%lu%lu%lu%lu%lu\",\n             &v15,\n             &v16,\n             &v17,\n             &v18,\n             &v19,\n             &v20,\n             &v28,\n             &v21,\n             &v22,\n             &v23,\n             &v24,\n             &v25,\n             &v26,\n             &v27) == 14\n        && (!*(_BYTE *)a1 || !strcmp((const char *)a1, s2)) )\n      {\n        sub_804D67E(v30, s2);\n        v5 = sub_804DF99(0, 2, 2);\n        v14 = (char *)sub_804E09D(v5, 0x8927u, (int)v30, \"SIOCGIFHWADDR\");\n        close(v5);\n        if ( v14 )\n        {\n          sub_804D5F4(\"can't get type of [%s]\", s2);\n        }\n        else if ( (v31 & 0xFFF7) == 768 || (_WORD)v31 == 778 )\n        {\n          memset(s1, 0, sizeof(s1));\n          if ( !sub_8067EF6(s2, (int)s1) )\n          {\n            v7 = *(_DWORD *)(a1 + 16);\n            if ( !v7 || v7 == *(_DWORD *)&s1[16] )\n            {\n              if ( !*(_BYTE *)a1 || (v8 = strcmp(s1, (const char *)a1), v6 = v12, !v8) )\n              {\n                v9 = *(_DWORD *)(a1 + 48);\n                if ( !v9 || v9 == *(_DWORD *)&s1[48] )\n                {\n                  v10 = *(_DWORD *)(a1 + 44);\n                  if ( !v10 || v10 == *(_DWORD *)&s1[44] )\n                  {\n                    v11 = *(_DWORD *)(a1 + 24);\n                    if ( !v11 || v11 == *(_DWORD *)&s1[24] )\n                    {\n                      sub_80684F3((int)s1, v6);\n                      sub_804DD98(10);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8068949": [
        "0x8068949",
        "int __usercall sub_8068949@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  const char **v4; // edx\n  int v5; // eax\n  int v7; // ebx\n  const char *v8; // eax\n  int v9; // ecx\n  const char *v10; // eax\n  int v11; // ecx\n  int v13[10]; // [esp+0h] [ebp-38h] BYREF\n  char v14; // [esp+29h] [ebp-Fh]\n\n  v1 = a1;\n  if ( *a1 )\n  {\n    v2 = sub_804D254(\"add\", *a1);\n    if ( v2 < 0 )\n      sub_8069C50(v3, ident);\n    ++v1;\n    switch ( v2 )\n    {\n      case 0:\n        v4 = v1;\n        v5 = 35313;\n        return sub_806848D(v5, v4);\n      case 1:\n        v4 = v1;\n        v5 = 35315;\n        return sub_806848D(v5, v4);\n      case 2:\n        sub_8067FFB(v13, v1, 35314);\n        switch ( v14 )\n        {\n          case 41:\n            v8 = \"sit0\";\n            break;\n          case 47:\n            v8 = \"gre0\";\n            break;\n          case 4:\n            v8 = \"tunl0\";\n            break;\n          default:\n            v8 = (const char *)v13;\n            break;\n        }\n        return sub_8067FB0(v8, (const char *)v13);\n    }\n  }\n  sub_8067FFB(v13, v1, 35312);\n  if ( v14 == 41 )\n  {\n    v10 = (const char *)v13;\n    if ( !LOBYTE(v13[0]) )\n      v10 = \"sit0\";\n  }\n  else if ( v14 == 47 )\n  {\n    v10 = (const char *)v13;\n    if ( !LOBYTE(v13[0]) )\n      v10 = \"gre0\";\n  }\n  else\n  {\n    v10 = (const char *)v13;\n    if ( v14 != 4 )\n    {\n      sub_806871D((int)v13, v9);\n      return 0;\n    }\n    if ( !LOBYTE(v13[0]) )\n      v10 = \"tunl0\";\n  }\n  v7 = sub_8067EF6(v10, (int)v13);\n  if ( v7 )\n    return -1;\n  sub_80684F3((int)v13, v11);\n  sub_804DD98(10);\n  return v7;\n}\n"
    ],
    "sub_8068A5B": [
        "0x8068a5b",
        "int __usercall sub_8068A5B@<eax>(int *a1@<eax>)\n{\n  int v2; // eax\n  int v4; // [esp-4h] [ebp-10h]\n\n  memset(a1, 0, 0x24u);\n  v2 = sub_804DF99(0, 3, 16);\n  *a1 = v2;\n  *((_WORD *)a1 + 2) = 16;\n  sub_804DFB3(0xCu, (struct sockaddr *)(a1 + 1), v2);\n  sub_80A998A(12, a1 + 1);\n  a1[7] = time(0);\n  return v4;\n}\n"
    ],
    "sub_8068AAE": [
        "0x8068aae",
        "ssize_t __usercall sub_8068AAE@<eax>(int *a1@<eax>, void *a2@<edx>, size_t a3@<ecx>)\n{\n  struct sockaddr v4; // [esp+0h] [ebp-1Ch] BYREF\n\n  memset(v4.sa_data, 0, 0xAu);\n  v4.sa_family = 16;\n  return sub_804DFCD(a3, a2, *a1, &v4, 0xCu);\n}\n"
    ],
    "sub_8068AE2": [
        "0x8068ae2",
        "ssize_t __usercall sub_8068AE2@<eax>(int *a1@<eax>, char a2@<dl>, __int16 a3@<cx>)\n{\n  int v3; // ecx\n  int v5; // [esp+0h] [ebp-14h] BYREF\n  __int16 v6; // [esp+4h] [ebp-10h]\n  __int16 v7; // [esp+6h] [ebp-Eh]\n  int v8; // [esp+8h] [ebp-Ch]\n  int v9; // [esp+Ch] [ebp-8h]\n  char v10; // [esp+10h] [ebp-4h]\n\n  v5 = 20;\n  v6 = a3;\n  v7 = 769;\n  v9 = 0;\n  v3 = a1[7] + 1;\n  a1[7] = v3;\n  a1[8] = v3;\n  v8 = v3;\n  v10 = a2;\n  return sub_8068AAE(a1, &v5, 0x14u);\n}\n"
    ],
    "sub_8068B22": [
        "0x8068b22",
        "ssize_t __userpurge sub_8068B22@<eax>(int *a1@<eax>, __int16 a2@<dx>, int a3@<ecx>, int a4)\n{\n  int v5; // eax\n  int v7[4]; // [esp+0h] [ebp-1Ch] BYREF\n  int v8; // [esp+10h] [ebp-Ch] BYREF\n  __int16 v9; // [esp+14h] [ebp-8h]\n  __int16 v10; // [esp+16h] [ebp-6h]\n  int v11; // [esp+18h] [ebp-4h]\n  _DWORD v12[14]; // [esp+1Ch] [ebp+0h] BYREF\n\n  v7[0] = (int)&v8;\n  v7[1] = 16;\n  v7[2] = a3;\n  v7[3] = a4;\n  memset(v12, 0, 0x2Cu);\n  v12[1] = &v12[8];\n  v12[2] = 12;\n  v12[3] = v7;\n  v12[4] = 2;\n  LOWORD(v12[8]) = 16;\n  v8 = a4 + 16;\n  v9 = a2;\n  v10 = 769;\n  v5 = a1[7] + 1;\n  a1[7] = v5;\n  a1[8] = v5;\n  v11 = v5;\n  return sendmsg(*a1, (const struct msghdr *)&v12[1], 0);\n}\n"
    ],
    "sub_8068BB1": [
        "0x8068bb1",
        "int __usercall sub_8068BB1@<eax>(int *a1@<eax>, int (__fastcall *a2)(int, unsigned int *)@<edx>, int a3@<ecx>)\n{\n  ssize_t v5; // eax\n  int v6; // esi\n  int v7; // eax\n  unsigned int v8; // eax\n  unsigned int *i; // ebx\n  unsigned int v10; // eax\n  unsigned int v11; // edx\n  void *v13; // [esp+8h] [ebp-48h]\n  int v15; // [esp+Ch] [ebp-44h]\n  void *v16[2]; // [esp+10h] [ebp-40h] BYREF\n  void *ptr[3]; // [esp+18h] [ebp-38h] BYREF\n  struct msghdr message; // [esp+24h] [ebp-2Ch] BYREF\n\n  v13 = sub_804DAFA(0x2000u);\n  v16[0] = v13;\n  v16[1] = (void *)0x2000;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      message.msg_name = ptr;\n      message.msg_namelen = 12;\n      message.msg_iov = (struct iovec *)v16;\n      message.msg_iovlen = 1;\n      memset(&message.msg_control, 0, 12);\n      v5 = recvmsg(*a1, &message, 0);\n      v6 = v5;\n      if ( v5 >= 0 )\n        break;\n      if ( *(_DWORD *)dword_80DBB7C != 4 )\n        sub_804D3A5((int)\"OVERRUN\");\n    }\n    if ( !v5 )\n      break;\n    if ( message.msg_namelen != 12 )\n      sub_804D5E0(\"sender address length == %d\", message.msg_namelen);\n    for ( i = (unsigned int *)v13; v6 > 15; i = (unsigned int *)((char *)i + v8) )\n    {\n      v10 = *i;\n      if ( *i <= 0xF || v6 < v10 )\n        break;\n      if ( !ptr[1] && i[3] == a1[2] && i[2] == a1[8] )\n      {\n        v11 = i[1];\n        if ( (_WORD)v11 == 3 )\n        {\n          v7 = 0;\n          goto LABEL_29;\n        }\n        if ( (_WORD)v11 == 2 )\n        {\n          if ( v10 > 0x23 )\n          {\n            *(_DWORD *)dword_80DBB7C = -i[4];\n            sub_804D3A5((int)\"RTNETLINK answers\");\n          }\n          else\n          {\n            sub_804D5F4(\"ERROR truncated\");\n          }\n          goto LABEL_22;\n        }\n        v7 = a2(a3, i);\n        if ( v7 < 0 )\n          goto LABEL_29;\n      }\n      v8 = (*i + 3) & 0xFFFFFFFC;\n      v6 -= v8;\n    }\n    if ( (message.msg_flags & 0x20) != 0 )\n    {\n      sub_804D5F4(\"message truncated\");\n    }\n    else if ( v6 )\n    {\n      sub_804D5E0(\"remnant of size %d!\", v6);\n    }\n  }\n  sub_804D5F4(\"EOF on netlink\");\nLABEL_22:\n  v7 = -1;\nLABEL_29:\n  v15 = v7;\n  free(v13);\n  if ( v15 )\n    sub_804D5E0(\"dump terminated\");\n  return 0;\n}\n"
    ],
    "sub_8068D41": [
        "0x8068d41",
        "int __usercall sub_8068D41@<eax>(int *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)\n{\n  int v6; // edi\n  ssize_t v7; // eax\n  int v8; // ebp\n  unsigned int *i; // esi\n  unsigned int v10; // ecx\n  unsigned int v11; // ecx\n  _DWORD *ptr; // [esp+0h] [ebp-4Ch]\n  unsigned int v14; // [esp+4h] [ebp-48h]\n  ssize_t v15; // [esp+8h] [ebp-44h]\n  _DWORD *v16; // [esp+Ch] [ebp-40h] BYREF\n  int v17; // [esp+10h] [ebp-3Ch]\n  _DWORD v18[3]; // [esp+14h] [ebp-38h] BYREF\n  struct msghdr message; // [esp+20h] [ebp-2Ch] BYREF\n\n  v16 = (_DWORD *)a2;\n  v17 = *(_DWORD *)a2;\n  ptr = sub_804DAFA(0x2000u);\n  message.msg_name = v18;\n  message.msg_namelen = 12;\n  message.msg_iov = (struct iovec *)&v16;\n  message.msg_iovlen = 1;\n  memset(&message.msg_control, 0, 12);\n  memset((char *)v18 + 2, 0, 0xAu);\n  LOWORD(v18[0]) = 16;\n  v6 = a1[7] + 1;\n  a1[7] = v6;\n  *(_DWORD *)(a2 + 8) = v6;\n  if ( !a3 )\n    *(_WORD *)(a2 + 6) |= 4u;\n  if ( sendmsg(*a1, &message, 0) < 0 )\n  {\n    sub_804D3A5((int)\"can't talk to rtnetlink\");\nLABEL_11:\n    v8 = -1;\n    goto LABEL_38;\n  }\n  v16 = ptr;\nLABEL_6:\n  while ( 1 )\n  {\n    v17 = 0x2000;\n    v7 = recvmsg(*a1, &message, 0);\n    if ( v7 >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 4 )\n      sub_804D3A5((int)\"OVERRUN\");\n  }\n  if ( !v7 )\n  {\n    sub_804D5F4(\"EOF on netlink\");\n    goto LABEL_11;\n  }\n  if ( message.msg_namelen != 12 )\n    sub_804D5E0(\"sender address length == %d\", message.msg_namelen);\n  for ( i = ptr; ; i = (unsigned int *)((char *)i + v11) )\n  {\n    do\n    {\n      if ( v7 <= 15 )\n      {\n        if ( (message.msg_flags & 0x20) != 0 )\n        {\n          sub_804D5F4(\"message truncated\");\n        }\n        else if ( v7 )\n        {\n          sub_804D5E0(\"remnant of size %d!\", v7);\n        }\n        goto LABEL_6;\n      }\n      v10 = *i;\n      if ( v7 < (int)*i || (int)(*i - 16) < 0 )\n      {\n        if ( (message.msg_flags & 0x20) == 0 )\n          sub_804D5E0(\"malformed message: len=%d!\", v10);\n        sub_804D5F4(\"truncated message\");\n        goto LABEL_11;\n      }\n    }\n    while ( v18[1] || i[3] != a1[2] || v6 != i[2] );\n    if ( *((_WORD *)i + 2) == 2 )\n      break;\n    if ( a3 )\n    {\n      qmemcpy(a3, i, v10);\n      v8 = 0;\n      goto LABEL_38;\n    }\n    v15 = v7;\n    v14 = *i;\n    sub_804D5F4(\"unexpected reply!\");\n    v11 = (v14 + 3) & 0xFFFFFFFC;\n    v7 = v15 - v11;\n  }\n  if ( (int)(*i - 16) <= 19 )\n  {\n    sub_804D5F4(\"ERROR truncated\");\n    goto LABEL_11;\n  }\n  v8 = i[4];\n  *(_DWORD *)dword_80DBB7C = -v8;\n  if ( v8 )\n  {\n    sub_804D3A5((int)\"RTNETLINK answers\");\n    goto LABEL_11;\n  }\n  if ( a3 )\n    qmemcpy(a3, i, *i);\nLABEL_38:\n  free(ptr);\n  return v8;\n}\n"
    ],
    "sub_8068F53": [
        "0x8068f53",
        "int __userpurge sub_8068F53@<eax>(unsigned int *a1@<eax>, signed int a2@<edx>, __int16 a3@<cx>, int a4)\n{\n  char *v4; // edx\n\n  if ( (int)((*a1 + 11) & 0xFFFFFFFC) > a2 )\n    return -1;\n  v4 = (char *)a1 + ((*a1 + 3) & 0xFFFFFFFC);\n  *((_WORD *)v4 + 1) = a3;\n  *(_WORD *)v4 = 8;\n  *((_DWORD *)v4 + 1) = a4;\n  *a1 = (*a1 + 11) & 0xFFFFFFFC;\n  return 0;\n}\n"
    ],
    "sub_8068F90": [
        "0x8068f90",
        "int __userpurge sub_8068F90@<eax>(\n        unsigned int *a1@<eax>,\n        signed int a2@<edx>,\n        __int16 a3@<cx>,\n        const void *a4,\n        unsigned int a5)\n{\n  unsigned int v5; // ebx\n  int v6; // edi\n  _WORD *v7; // edi\n\n  v5 = a5 + 4;\n  v6 = *a1 + 3;\n  if ( (int)((a5 + 4 + v6) & 0xFFFFFFFC) > a2 )\n    return -1;\n  v7 = (_WORD *)((char *)a1 + (v6 & 0xFFFFFFFC));\n  v7[1] = a3;\n  *v7 = v5;\n  qmemcpy(v7 + 2, a4, a5);\n  *a1 = (v5 + *a1 + 3) & 0xFFFFFFFC;\n  return 0;\n}\n"
    ],
    "sub_8068FDE": [
        "0x8068fde",
        "int __userpurge sub_8068FDE@<eax>(_WORD *a1@<eax>, unsigned int a2@<edx>, __int16 a3@<cx>, int a4)\n{\n  int v4; // ebx\n  char *v5; // edx\n\n  v4 = (unsigned __int16)*a1;\n  if ( ((v4 + 11) & 0xFFFFFFFC) > a2 )\n    return -1;\n  v5 = (char *)a1 + ((v4 + 3) & 0xFFFFFFFC);\n  *((_WORD *)v5 + 1) = a3;\n  *(_WORD *)v5 = 8;\n  *((_DWORD *)v5 + 1) = a4;\n  *a1 = (*a1 + 11) & 0xFFFC;\n  return 0;\n}\n"
    ],
    "sub_806901E": [
        "0x806901e",
        "char *__userpurge sub_806901E@<eax>(void *a1@<eax>, int a2@<edx>, unsigned __int16 *a3@<ecx>, int a4)\n{\n  char *result; // eax\n  int v8; // eax\n  int v9; // ecx\n\n  result = 0;\n  memset(a1, 0, 4 * a2 + 4);\n  while ( a4 > 3 )\n  {\n    v8 = *a3;\n    if ( (unsigned __int16)v8 <= 3u || v8 > a4 )\n      return sub_804D5F4(\"deficit %d, rta_len=%d!\", a4, *a3);\n    v9 = a3[1];\n    if ( v9 <= a2 )\n      *((_DWORD *)a1 + v9) = a3;\n    result = (char *)((v8 + 3) & 0xFFFFFFFC);\n    a4 -= (int)result;\n    a3 = (unsigned __int16 *)((char *)a3 + (_DWORD)result);\n  }\n  if ( !a4 )\n    return result;\n  return sub_804D5F4(\"deficit %d, rta_len=%d!\", a4, *a3);\n}\n"
    ],
    "sub_806907E": [
        "0x806907e",
        "const char *__userpurge sub_806907E@<eax>(\n        unsigned __int8 *a1@<eax>,\n        int a2@<edx>,\n        int a3@<ecx>,\n        char *a4,\n        socklen_t a5)\n{\n  size_t v6; // ebx\n  int v7; // edi\n  int i; // esi\n\n  v6 = a5;\n  if ( a2 == 4 && ((a3 & 0xFFFFFFF7) == 768 || a3 == 778) )\n    return inet_ntop(2, a1, a4, a5);\n  v7 = 0;\n  for ( i = 0; i < a2; ++i )\n  {\n    if ( i )\n    {\n      snprintf(&a4[v7], v6, \":%02x\", a1[i]);\n      v6 -= 3;\n      v7 += 3;\n    }\n    else\n    {\n      snprintf(&a4[v7], v6, \"%02x\", *a1);\n      v6 -= 2;\n      v7 += 2;\n    }\n  }\n  return a4;\n}\n"
    ],
    "sub_8069111": [
        "0x8069111",
        "int __usercall sub_8069111@<eax>(char *s@<ecx>, _DWORD *a2@<eax>, int a3@<edx>)\n{\n  const char *v5; // ebp\n  int result; // eax\n  int i; // ebx\n  char *v8; // eax\n  char *v9; // edx\n  char *sa; // [esp+0h] [ebp-28h]\n  unsigned int v11; // [esp+4h] [ebp-24h] BYREF\n  int v12; // [esp+8h] [ebp-20h]\n\n  v5 = s;\n  if ( strchr(s, 46) )\n  {\n    if ( sub_8069980(2, v5) )\n    {\nLABEL_12:\n      sub_804D5F4(\"\\\"%s\\\" is invalid lladdr\", v5);\n      return -1;\n    }\n    else\n    {\n      result = -1;\n      if ( a3 > 3 )\n      {\n        *a2 = v12;\n        return 4;\n      }\n    }\n  }\n  else\n  {\n    for ( i = 0; i < a3; ++i )\n    {\n      v8 = strchr(v5, 58);\n      v9 = v8;\n      if ( v8 )\n      {\n        *v8 = 0;\n        v9 = v8 + 1;\n      }\n      sa = v9;\n      if ( sscanf(v5, \"%x\", &v11) != 1 || v11 > 0xFF )\n        goto LABEL_12;\n      *((_BYTE *)a2 + i) = v11;\n      if ( !sa )\n        break;\n      v5 = sa;\n    }\n    return i + 1;\n  }\n  return result;\n}\n"
    ],
    "sub_80691C7": [
        "0x80691c7",
        "_DWORD *__usercall sub_80691C7@<eax>(int a1@<eax>)\n{\n  _DWORD *i; // edx\n\n  if ( !dword_80DB65C )\n    return 0;\n  for ( i = *(_DWORD **)(dword_80DB65C + 4 * (a1 & 0xF)); i && i[1] != a1; i = (_DWORD *)*i )\n    ;\n  return i;\n}\n"
    ],
    "sub_80691EB": [
        "0x80691eb",
        "int __fastcall sub_80691EB(int a1, int a2)\n{\n  int result; // eax\n  _DWORD *i; // edi\n  _DWORD *v5; // ebx\n  unsigned __int16 *v6; // eax\n  unsigned __int16 *v7; // edx\n  signed int v8; // ecx\n  int v9; // [esp+0h] [ebp-D4h] BYREF\n  unsigned __int16 *v10; // [esp+4h] [ebp-D0h]\n  int v11; // [esp+Ch] [ebp-C8h]\n\n  if ( *(_WORD *)(a2 + 4) != 16 )\n    return 0;\n  result = -1;\n  if ( *(_DWORD *)a2 > 0x13u )\n  {\n    sub_806901E(&v9, 49, (unsigned __int16 *)(a2 + 32), *(_DWORD *)a2 - 32);\n    if ( v11 )\n    {\n      if ( !dword_80DB65C )\n        dword_80DB65C = (int)sub_804DB2E(0x40u);\n      for ( i = (_DWORD *)(dword_80DB65C + 4 * (*(_DWORD *)(a2 + 20) & 0xF)); ; i = (_DWORD *)*i )\n      {\n        v5 = (_DWORD *)*i;\n        if ( !*i )\n          break;\n        if ( *(_DWORD *)(a2 + 20) == v5[1] )\n          goto LABEL_11;\n      }\n      v5 = sub_804DAFA(0x2Cu);\n      *v5 = *i;\n      v5[1] = *(_DWORD *)(a2 + 20);\n      *i = v5;\nLABEL_11:\n      v5[2] = *(unsigned __int16 *)(a2 + 18);\n      v5[4] = *(_DWORD *)(a2 + 24);\n      v6 = v10;\n      v7 = (unsigned __int16 *)(v5 + 5);\n      if ( v10 )\n      {\n        v8 = *v10 - 4;\n        v5[3] = v8;\n        if ( v8 > 8 )\n          v8 = 8;\n        qmemcpy(v7, v6 + 2, v8);\n      }\n      else\n      {\n        v5[3] = 0;\n        memset(v7, 0, 8u);\n      }\n      strcpy((char *)v5 + 28, (const char *)(v11 + 4));\n    }\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80692E5": [
        "0x80692e5",
        "int __usercall sub_80692E5@<eax>(int a1@<eax>)\n{\n  _DWORD *v2; // eax\n  int v4; // [esp-Ch] [ebp-Ch]\n  int v5; // [esp-8h] [ebp-8h]\n\n  if ( !a1 )\n    return 135039284;\n  v2 = sub_80691C7(a1);\n  if ( v2 )\n    return (int)(v2 + 7);\n  sub_804DDBF(\"if%d\", a1);\n  return sub_80A9707(v5, v4);\n}\n"
    ],
    "sub_8069313": [
        "0x8069313",
        "int __usercall sub_8069313@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  _DWORD *v2; // eax\n\n  v1 = 0;\n  if ( a1 )\n  {\n    v2 = sub_80691C7(a1);\n    v1 = 0;\n    if ( v2 )\n      return v2[4];\n  }\n  return v1;\n}\n"
    ],
    "sub_806932A": [
        "0x806932a",
        "int __usercall sub_806932A@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = if_nametoindex();\n  if ( result <= 0 )\n    sub_804D5E0(\"can't find device '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_8069345": [
        "0x8069345",
        "int __usercall sub_8069345@<eax>(int *a1@<eax>)\n{\n  sub_8068AE2(a1, 0, 18);\n  sub_8068BB1(a1, (int (__fastcall *)(int, unsigned int *))sub_80691EB, 0);\n  return 0;\n}\n"
    ],
    "sub_8069366": [
        "0x8069366",
        "int __usercall sub_8069366@<eax>(_WORD *a1@<eax>, const char *a2@<edx>)\n{\n  const char *v4; // edi\n  int i; // ebx\n  unsigned int v6; // eax\n  _DWORD *v7; // ebx\n  __int16 v8; // ax\n  char v9; // t0\n\n  v4 = \"loop\";\n  for ( i = 0; i != 43; ++i )\n  {\n    if ( !strcasecmp(v4, a2) )\n    {\n      LOWORD(v6) = word_80B5B40[i];\nLABEL_7:\n      v9 = BYTE1(v6);\n      HIBYTE(v8) = v6;\n      LOBYTE(v8) = v9;\n      *a1 = v8;\n      return 0;\n    }\n    v4 += strlen(v4) + 1;\n  }\n  v7 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v6 = sub_804ED6C(0, a2, 0, (int)v7);\n  if ( !*v7 && v6 <= 0xFFFF )\n    goto LABEL_7;\n  return -1;\n}\n"
    ],
    "sub_80693D1": [
        "0x80693d1",
        "char *__usercall sub_80693D1@<eax>(int a1@<eax>, char *a2@<edx>)\n{\n  const char *v4; // ebx\n  int v5; // esi\n\n  v4 = \"generic\";\n  v5 = 0;\n  while ( (unsigned __int16)word_80B8538[v5] != a1 )\n  {\n    v4 += strlen(v4) + 1;\n    if ( ++v5 == 19 )\n    {\n      sprintf(a2, \"[%d]\", a1);\n      return a2;\n    }\n  }\n  return (char *)v4;\n}\n"
    ],
    "sub_8069415": [
        "0x8069415",
        "int __usercall sub_8069415@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v4; // ecx\n  int v5; // ebx\n  unsigned int v6; // eax\n  const char *v8; // [esp+4h] [ebp-3Ch]\n  const char *v9; // [esp+8h] [ebp-38h]\n  char v10[4]; // [esp+Ch] [ebp-34h] BYREF\n\n  sprintf(&v10[3], \"/etc/iproute2/rt_%s\", a1);\n  v5 = sub_80B0511(v4, sub_80B3D37);\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    v6 = sub_804ED6C(0, v8, 0, v5);\n    if ( v6 > 0x3FF )\n    {\n      sub_804D5F4(\"database %s is corrupted at line %d\", a1, *(_DWORD *)(v5 + 24));\n      return sub_80B0536();\n    }\n    *(_DWORD *)(a2 + 4 * v6) = sub_804DB46(v9);\n  }\n  return sub_80B0536();\n}\n"
    ],
    "sub_80694A0": [
        "0x80694a0",
        "void sub_80694A0()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB66C )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB66C = (int)v0;\n    v0[2] = \"global\";\n    v0[257] = \"nowhere\";\n    v0[256] = \"host\";\n    v0[255] = 135036335;\n    v0[202] = \"site\";\n    sub_8069415(\"scopes\", (int)(v0 + 2));\n  }\n}\n"
    ],
    "sub_80694F5": [
        "0x80694f5",
        "void sub_80694F5()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB668 )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB668 = (int)v0;\n    v0[2] = \"unknown\";\n    sub_8069415(\"realms\", (int)(v0 + 2));\n  }\n}\n"
    ],
    "sub_8069522": [
        "0x8069522",
        "void sub_8069522()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB664 )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB664 = (int)v0;\n    v0[2] = 135052877;\n    sub_8069415(\"dsfield\", (int)(v0 + 2));\n  }\n}\n"
    ],
    "sub_806954F": [
        "0x806954f",
        "void sub_806954F()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB660 )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB660 = (int)v0;\n    v0[2] = \"unspec\";\n    v0[257] = \"local\";\n    v0[256] = \"main\";\n    v0[255] = \"default\";\n    sub_8069415(\"tables\", (int)(v0 + 2));\n  }\n}\n"
    ],
    "sub_806959A": [
        "0x806959a",
        "int __usercall sub_806959A@<eax>(char *s2@<ecx>, int a2@<eax>, unsigned int *a3@<edx>, int base)\n{\n  const char *v7; // eax\n  int result; // eax\n  unsigned int i; // ebx\n  const char *v10; // edx\n  unsigned int v11; // edx\n  int v12; // [esp+0h] [ebp-14h]\n\n  v7 = *(const char **)a2;\n  if ( !v7 || (result = strcmp(v7, s2)) != 0 )\n  {\n    for ( i = 0; i != 1024; ++i )\n    {\n      v10 = *(const char **)(a2 + 4 * i + 8);\n      if ( v10 )\n      {\n        v12 = *(_DWORD *)(a2 + 4 * i + 8);\n        result = strcmp(v10, s2);\n        if ( !result )\n        {\n          *(_DWORD *)a2 = v12;\n          *(_DWORD *)(a2 + 4) = i;\n          *a3 = i;\n          return result;\n        }\n      }\n    }\n    v11 = sub_804ED6C(base, s2, 0, 1024);\n    result = -1;\n    if ( v11 <= 0x3FF )\n    {\n      *a3 = v11;\n      return 0;\n    }\n  }\n  else\n  {\n    *a3 = *(_DWORD *)(a2 + 4);\n  }\n  return result;\n}\n"
    ],
    "sub_8069613": [
        "0x8069613",
        "int __usercall sub_8069613@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  int v4; // edx\n\n  if ( !dword_80DB670 )\n  {\n    dword_80DB670 = (int)sub_804DB2E(0x1008u);\n    v4 = dword_80DB670 + 8;\n    qmemcpy((void *)(dword_80DB670 + 8), off_80B5BA0, 0x34u);\n    sub_8069415(\"protos\", v4);\n  }\n  return sub_806959A(a2, dword_80DB670, a1, 0);\n}\n"
    ],
    "sub_8069664": [
        "0x8069664",
        "_BYTE *__usercall sub_8069664@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_80694A0();\n    result = *(_BYTE **)(dword_80DB66C + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
    ],
    "sub_806968A": [
        "0x806968a",
        "int __usercall sub_806968A@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_80694A0();\n  return sub_806959A(a2, dword_80DB66C, a1, 0);\n}\n"
    ],
    "sub_80696A9": [
        "0x80696a9",
        "int __usercall sub_80696A9@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_80694F5();\n  return sub_806959A(a2, dword_80DB668, a1, 0);\n}\n"
    ],
    "sub_80696C8": [
        "0x80696c8",
        "_BYTE *__usercall sub_80696C8@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_80694F5();\n    result = *(_BYTE **)(dword_80DB668 + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
    ],
    "sub_80696EE": [
        "0x80696ee",
        "_BYTE *__usercall sub_80696EE@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_8069522();\n    result = *(_BYTE **)(dword_80DB664 + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
    ],
    "sub_8069714": [
        "0x8069714",
        "int __usercall sub_8069714@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_8069522();\n  return sub_806959A(a2, dword_80DB664, a1, 16);\n}\n"
    ],
    "sub_8069733": [
        "0x8069733",
        "_BYTE *__usercall sub_8069733@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_806954F();\n    result = *(_BYTE **)(dword_80DB660 + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
    ],
    "sub_8069759": [
        "0x8069759",
        "int __usercall sub_8069759@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_806954F();\n  return sub_806959A(a2, dword_80DB660, a1, 0);\n}\n"
    ],
    "sub_8069778": [
        "0x8069778",
        "const char *__usercall sub_8069778@<eax>(signed int a1@<eax>)\n{\n  const char *result; // eax\n\n  switch ( a1 )\n  {\n    case 0:\n      result = \"none\";\n      break;\n    case 1:\n      result = \"unicast\";\n      break;\n    case 2:\n      result = \"local\";\n      break;\n    case 3:\n      result = \"broadcast\";\n      break;\n    case 4:\n      result = \"anycast\";\n      break;\n    case 5:\n      result = \"multicast\";\n      break;\n    case 6:\n      result = \"blackhole\";\n      break;\n    case 7:\n      result = \"unreachable\";\n      break;\n    case 8:\n      result = \"prohibit\";\n      break;\n    case 9:\n      result = \"throw\";\n      break;\n    case 10:\n      result = \"nat\";\n      break;\n    case 11:\n      result = \"xresolve\";\n      break;\n    default:\n      result = sub_804D70F(a1);\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_80697D1": [
        "0x80697d1",
        "int __usercall sub_80697D1@<eax>(unsigned int *a1@<eax>, const char *a2@<edx>, char *a3@<ecx>)\n{\n  char v5; // al\n  unsigned int v6; // edx\n  int result; // eax\n  char *v8; // [esp+0h] [ebp-Ch] BYREF\n\n  v8 = a3;\n  v5 = sub_804D254(\"local\", a2);\n  if ( !v5 )\n  {\n    v6 = 2;\nLABEL_27:\n    *a1 = v6;\n    return 0;\n  }\n  if ( v5 == 1 )\n  {\n    v6 = 10;\n    goto LABEL_27;\n  }\n  if ( (unsigned __int8)(v5 - 2) <= 1u )\n  {\n    v6 = 3;\n    goto LABEL_27;\n  }\n  switch ( v5 )\n  {\n    case 4:\n      v6 = 4;\n      goto LABEL_27;\n    case 5:\n      v6 = 5;\n      goto LABEL_27;\n    case 6:\n      v6 = 8;\n      goto LABEL_27;\n    case 7:\n      v6 = 7;\n      goto LABEL_27;\n    case 8:\n      v6 = 6;\n      goto LABEL_27;\n    case 9:\n      v6 = 11;\n      goto LABEL_27;\n    case 10:\n      v6 = 1;\n      goto LABEL_27;\n    case 11:\n      v6 = 9;\n      goto LABEL_27;\n  }\n  v6 = strtoul(a2, &v8, 0);\n  result = -1;\n  if ( v8 == a2 )\n    return result;\n  if ( !*v8 && v6 <= 0xFF )\n    goto LABEL_27;\n  return -1;\n}\n"
    ],
    "sub_80698A2": [
        "0x80698a2",
        "int __usercall sub_80698A2@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  char *v3; // eax\n  char *v4; // edx\n  char *v5; // esi\n  unsigned int v8[3]; // [esp+4h] [ebp-Ch] BYREF\n\n  v8[0] = 0;\n  v3 = strchr(a2, 47);\n  *a1 = 0;\n  v4 = a2;\n  if ( v3 )\n  {\n    v5 = v3;\n    *v3 = 0;\n    if ( sub_80696A9(a1, a2) )\n    {\n      *v5 = 47;\n      return -1;\n    }\n    *a1 <<= 16;\n    *v5 = 47;\n    v4 = v5 + 1;\n  }\n  if ( !*v4 || !sub_80696A9(v8, v4) )\n  {\n    *a1 |= v8[0];\n    return 0;\n  }\n  return -1;\n}\n"
    ],
    "sub_806990F": [
        "0x806990f",
        "int sub_806990F()\n{\n  int result; // eax\n  FILE *v1; // ebx\n  int v2; // [esp+0h] [ebp-Ch] BYREF\n  int v3; // [esp+4h] [ebp-8h] BYREF\n\n  result = dword_80DB674;\n  if ( !dword_80DB674 )\n  {\n    v1 = (FILE *)sub_80B3D37();\n    if ( v1 )\n    {\n      if ( fscanf(v1, \"%*08x%*08x%08x%08x\", &v2, &v3) == 2 && v2 == 1000000 )\n        dword_80DB674 = v3;\n      fclose(v1);\n    }\n    if ( !dword_80DB674 )\n      dword_80DB674 = sub_80B2F58();\n    return dword_80DB674;\n  }\n  return result;\n}\n"
    ],
    "sub_8069980": [
        "0x8069980",
        "unsigned int __usercall sub_8069980@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  unsigned int result; // eax\n  const char *v7; // esi\n  unsigned int v8; // edx\n  char v9; // di\n  int v10; // [esp+0h] [ebp-14h]\n\n  memset(a1, 0, 0x14u);\n  if ( !strcmp(a2, \"default\") || !strcmp(a2, \"all\") || !strcmp(a2, \"any\") )\n  {\n    *a1 = a3;\n    a1[1] = a3 == 10 ? 16 : 4;\nLABEL_11:\n    *((_WORD *)a1 + 1) = -1;\n    return 0;\n  }\n  if ( strchr(a2, 58) )\n  {\n    *a1 = 10;\n    if ( (a3 == 10 || !a3) && inet_pton(10, a2, a1 + 4) > 0 )\n    {\n      a1[1] = 16;\n      goto LABEL_11;\n    }\n    return -1;\n  }\n  result = a3 & 0xFFFFFFFD;\n  if ( (a3 & 0xFFFFFFFD) != 0 )\n    return -1;\n  *a1 = 2;\n  v7 = a2 - 1;\n  v8 = 0;\n  v10 = 0;\n  while ( 1 )\n  {\n    v9 = *++v7;\n    if ( !*v7 )\n      break;\n    if ( (unsigned __int8)(v9 - 48) > 9u )\n    {\n      if ( v9 != 46 )\n        return -1;\n      if ( (unsigned int)++v10 > 3 )\n        return -1;\n      v8 = 0;\n    }\n    else\n    {\n      v8 = (unsigned __int8)(v9 - 48) + 10 * v8;\n      if ( v8 > 0xFF )\n        return -1;\n      a1[v10 + 4] = v8;\n    }\n  }\n  a1[1] = 4;\n  *((_WORD *)a1 + 1) = -1;\n  return result;\n}\n"
    ],
    "sub_8069A87": [
        "0x8069a87",
        "int __usercall sub_8069A87@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  if ( a3 == 17 )\n    sub_804D5E0(\"\\\"%s\\\" may be inet %s, but it is not allowed in this context\", a2, \"address\");\n  if ( sub_8069980(a1, a2, a3) )\n    sub_804D5E0(\"an %s %s is expected rather than \\\"%s\\\"\", \"inet\", \"address\", a2);\n  return 0;\n}\n"
    ],
    "sub_8069AC1": [
        "0x8069ac1",
        "char __usercall sub_8069AC1@<al>(_WORD *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  unsigned int v5; // eax\n  char *v6; // eax\n  char *v7; // edi\n  unsigned int v8; // ebp\n  unsigned __int32 v9; // eax\n  char v12[4]; // [esp+8h] [ebp-24h] BYREF\n  unsigned int v13; // [esp+Ch] [ebp-20h]\n\n  if ( a3 == 17 )\n    sub_804D5E0(\"\\\"%s\\\" may be inet %s, but it is not allowed in this context\", a2, \"prefix\");\n  memset(a1, 0, 0x14u);\n  if ( !strcmp(a2, \"default\") || !strcmp(a2, \"all\") || !strcmp(a2, \"any\") )\n  {\n    LOBYTE(v5) = a3;\n    *(_BYTE *)a1 = a3;\n    return v5;\n  }\n  v6 = strchr(a2, 47);\n  v7 = v6;\n  if ( v6 )\n    *v6 = 0;\n  v5 = sub_8069980(a1, a2, a3);\n  if ( v5 )\n  {\n    if ( !v7 )\n      return v5;\nLABEL_26:\n    *v7 = 47;\n    return v5;\n  }\n  LOWORD(v5) = 128;\n  if ( *(_BYTE *)a1 != 10 )\n    LOWORD(v5) = 32;\n  a1[1] = v5;\n  if ( v7 )\n  {\n    v12[0] = 0;\n    v8 = sub_804ED6C(0, v7 + 1, 0, (int)a1);\n    if ( *(_DWORD *)dword_80DBB7C || (v5 = (__int16)a1[1], v8 > v5) )\n    {\n      v5 = sub_8069980(v12, v7 + 1, a3);\n      if ( v5 )\n        goto LABEL_24;\n    }\n    if ( v12[0] == 2 )\n    {\n      v9 = _byteswap_ulong(v13);\n      v8 = 0;\n      if ( (-v9 & ~v9) != 0 )\n        goto LABEL_24;\n      while ( v9 )\n      {\n        ++v8;\n        v9 *= 2;\n      }\n      v5 = (__int16)a1[1];\n      if ( v8 > v5 )\nLABEL_24:\n        sub_804D5E0(\"an %s %s is expected rather than \\\"%s\\\"\", \"inet\", \"prefix\", a2);\n    }\n    a1[1] = v8;\n    goto LABEL_26;\n  }\n  return v5;\n}\n"
    ],
    "sub_8069C04": [
        "0x8069c04",
        "int __usercall sub_8069C04@<eax>(const char *a1@<eax>)\n{\n  char v3[4]; // [esp+0h] [ebp-18h] BYREF\n  int v4; // [esp+4h] [ebp-14h]\n\n  if ( sub_8069980(v3, a1, 2) )\n    sub_804D5E0(\"an %s %s is expected rather than \\\"%s\\\"\", \"IP\", \"address\", a1);\n  return v4;\n}\n"
    ],
    "sub_8069C3A": [
        "0x8069c3a",
        "int __usercall sub_8069C3A@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = a1 + 4;\n  if ( !*(_DWORD *)(a1 + 4) )\n    sub_804D5E0(\"command line is not complete, try \\\"help\\\"\");\n  return result;\n}\n"
    ],
    "sub_8069C50": [
        "0x8069c50",
        "void __usercall __noreturn sub_8069C50(const char *a1@<eax>, const char *a2@<edx>)\n{\n  sub_804D5E0(\"invalid argument '%s' to '%s'\", a1, a2);\n}\n"
    ],
    "sub_8069C5C": [
        "0x8069c5c",
        "unsigned int __usercall sub_8069C5C@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  unsigned int result; // eax\n  const char *v4; // [esp+0h] [ebp-Ch]\n  char *endptr; // [esp+4h] [ebp-8h] BYREF\n\n  if ( !*a1 || (v4 = a2, result = strtoul(a1, &endptr, 0), a2 = v4, *endptr) )\n    sub_8069C50(a1, a2);\n  return result;\n}\n"
    ],
    "sub_8069C92": [
        "0x8069c92",
        "// attributes: thunk\nunsigned int __usercall sub_8069C92@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  return sub_8069C5C(a1, a2);\n}\n"
    ],
    "sub_8069C97": [
        "0x8069c97",
        "unsigned int __usercall sub_8069C97@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  unsigned int result; // eax\n  const char *v4; // [esp+0h] [ebp-Ch]\n  char *endptr; // [esp+4h] [ebp-8h] BYREF\n\n  if ( !*a1 || (v4 = a2, result = strtoul(a1, &endptr, 0), a2 = v4, *endptr) || result > 0xFFFF )\n    sub_8069C50(a1, a2);\n  return result;\n}\n"
    ],
    "sub_8069CD4": [
        "0x8069cd4",
        "void __usercall __noreturn sub_8069CD4(const char *a1@<eax>, const char *a2@<edx>)\n{\n  sub_804D5E0(\"duplicate \\\"%s\\\": \\\"%s\\\" is the second value\", a1, a2);\n}\n"
    ],
    "sub_8069CE0": [
        "0x8069ce0",
        "void __usercall __noreturn sub_8069CE0(const char *a1@<eax>, const char *a2@<edx>)\n{\n  sub_804D5E0(\"either \\\"%s\\\" is duplicate, or \\\"%s\\\" is garbage\", a1, a2);\n}\n"
    ],
    "sub_8069CEC": [
        "0x8069cec",
        "int __usercall sub_8069CEC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  const void *v3; // ebp\n  const void *v4; // edi\n  int v5; // esi\n  int v6; // ebx\n\n  v3 = (const void *)(a1 + 4);\n  v4 = (const void *)(a2 + 4);\n  v5 = a3 & 0x1F;\n  v6 = a3 >> 5;\n  if ( a3 >> 5 && memcmp(v3, v4, 4 * v6) )\n    return -1;\n  if ( v5 )\n    return (_byteswap_ulong(-1 << (32 - v5)) & (*((_DWORD *)v4 + v6) ^ *((_DWORD *)v3 + v6))) != 0;\n  return v5;\n}\n"
    ],
    "sub_8069D47": [
        "0x8069d47",
        "const char *__usercall sub_8069D47@<eax>(int a1@<eax>, const void *a2@<edx>)\n{\n  int v4; // edx\n  int v5; // ecx\n  char *v6; // eax\n\n  if ( a1 != 2 && a1 != 10 )\n    return \"???\";\n  sub_804DB2E(0x2Eu);\n  v6 = (char *)sub_80A9707(v5, v4);\n  return inet_ntop(a1, a2, v6, 0x2Eu);\n}\n"
    ],
    "sub_8069D7C": [
        "0x8069d7c",
        "_BYTE *__usercall sub_8069D7C@<eax>(char a1@<al>, const void *a2@<edx>, int a3@<ecx>)\n{\n  int v6; // ebx\n  _BYTE *result; // eax\n\n  v6 = strnlen();\n  result = sub_804DB2E(v6 + a3 + 2);\n  *result = a1;\n  result[1] = v6 + a3;\n  qmemcpy(&result[a3 + 2], a2, v6);\n  return result;\n}\n"
    ],
    "sub_8069DB7": [
        "0x8069db7",
        "unsigned __int16 __usercall sub_8069DB7@<ax>(int a1@<eax>, unsigned __int8 a2@<dl>)\n{\n  __int16 v4; // ax\n  __int16 v5; // ax\n  char v6; // t0\n  unsigned __int16 result; // ax\n\n  sub_806B251((_BYTE *)a1, a2);\n  *(_DWORD *)(a1 + 4) = rand();\n  v4 = sub_804EC4A();\n  word_80DB9C6 = v4;\n  if ( !word_80DB9C4 )\n    word_80DB9C4 = v4;\n  v5 = v4 - word_80DB9C4;\n  v6 = HIBYTE(v5);\n  HIBYTE(v5) = v5;\n  LOBYTE(v5) = v6;\n  *(_WORD *)(a1 + 8) = v5;\n  *(_DWORD *)(a1 + 28) = dword_80DB978;\n  result = word_80DB97C;\n  *(_WORD *)(a1 + 32) = word_80DB97C;\n  if ( dword_80DB9B4 )\n    return (unsigned __int16)sub_806BA8F(a1, (unsigned __int8 *)dword_80DB9B4);\n  return result;\n}\n"
    ],
    "sub_8069E18": [
        "0x8069e18",
        "int __usercall sub_8069E18@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  int v3; // edx\n  int i; // ecx\n  int v5; // edi\n  int j; // esi\n\n  sub_806BADE(16386, 57);\n  result = sub_806BA72();\n  v3 = 0;\n  for ( i = 1; i != 255; ++i )\n  {\n    v5 = (unsigned __int8)byte_80DB984[i >> 3];\n    if ( _bittest(&v5, i & 7) )\n      *(_BYTE *)(result + a1 + v3++ + 242) = i;\n  }\n  if ( v3 )\n  {\n    *(_BYTE *)(a1 + result + 240) = 55;\n    *(_BYTE *)(a1 + result + 241) = v3;\n    *(_BYTE *)(result + a1 + v3 + 242) = -1;\n  }\n  if ( dword_80DB9B8 )\n    result = sub_806BA8F();\n  if ( dword_80DB9BC )\n    result = sub_806BA8F();\n  if ( dword_80DB9C0 )\n    result = sub_806BA8F();\n  if ( (dword_80DBB9C & 0x100000) != 0 && !*(_DWORD *)(a1 + 12) )\n    *(_WORD *)(a1 + 10) |= 0x80u;\n  for ( j = dword_80DB9B0; j; j = *(_DWORD *)(j + 4) )\n    result = sub_806BA8F();\n  return result;\n}\n"
    ],
    "sub_8069EE9": [
        "0x8069ee9",
        "int sub_8069EE9()\n{\n  return sub_806B2E9(-1, 67, &unk_80B855E, dword_80DB980);\n}\n"
    ],
    "sub_8069F03": [
        "0x8069f03",
        "int __usercall sub_8069F03@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char v6[4]; // [esp+0h] [ebp-27Ch] BYREF\n  int v7; // [esp+4h] [ebp-278h]\n\n  sub_8069DB7((int)v6, 1u, a3);\n  v7 = a1;\n  if ( a2 )\n    sub_806BADE(a2, 50);\n  sub_8069E18((int)v6);\n  sub_804D5F4(\"sending %s\", \"discover\");\n  return sub_8069EE9();\n}\n"
    ],
    "sub_8069F5B": [
        "0x8069f5b",
        "int __usercall sub_8069F5B@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char *v6; // eax\n  char v8[4]; // [esp+0h] [ebp-280h] BYREF\n  int v9; // [esp+4h] [ebp-27Ch]\n\n  sub_8069DB7((int)v8, 3u, a3);\n  v9 = a1;\n  sub_806BADE(a3, 50);\n  sub_806BADE(a2, 54);\n  sub_8069E18((int)v8);\n  v6 = inet_ntoa((struct in_addr)a3);\n  sub_804D5F4(\"sending select for %s\", v6);\n  return sub_8069EE9();\n}\n"
    ],
    "sub_8069FC3": [
        "0x8069fc3",
        "int __usercall sub_8069FC3@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char v6[636]; // [esp+0h] [ebp-27Ch] BYREF\n\n  sub_8069DB7((int)v6, 4u, a3);\n  sub_806BADE(a2, 50);\n  sub_806BADE(a1, 54);\n  sub_804D5F4(\"sending %s\", \"decline\");\n  return sub_8069EE9();\n}\n"
    ],
    "sub_806A01A": [
        "0x806a01a",
        "int __usercall sub_806A01A@<eax>(int a1@<eax>, struct in_addr a2@<edx>, int a3@<ecx>)\n{\n  char *v6; // eax\n  char v8[4]; // [esp+0h] [ebp-280h] BYREF\n  int v9; // [esp+4h] [ebp-27Ch]\n  int v10; // [esp+Ch] [ebp-274h]\n\n  sub_8069DB7((int)v8, 3u, a3);\n  v9 = a1;\n  v10 = a3;\n  sub_8069E18((int)v8);\n  v6 = inet_ntoa(a2);\n  sub_804D5F4(\"sending renew to %s\", v6);\n  if ( a2.s_addr )\n    return sub_806B47D(a2.s_addr, 67);\n  else\n    return sub_8069EE9();\n}\n"
    ],
    "sub_806A084": [
        "0x806a084",
        "ssize_t __usercall sub_806A084@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  ssize_t result; // eax\n  unsigned __int16 v4; // dx\n  int v5; // esi\n  __int16 v6; // ax\n  __int16 v7; // bp\n  __int16 v8; // bp\n  struct cmsghdr *i; // eax\n  int v11[2]; // [esp+4h] [ebp-2E4h] BYREF\n  struct msghdr message; // [esp+Ch] [ebp-2DCh] BYREF\n  char v13; // [esp+28h] [ebp-2C0h] BYREF\n  _BYTE v14[9]; // [esp+48h] [ebp-2A0h] BYREF\n  char v15; // [esp+51h] [ebp-297h]\n  __int16 v16; // [esp+52h] [ebp-296h]\n  __int16 v17; // [esp+5Eh] [ebp-28Ah]\n  __int16 v18; // [esp+60h] [ebp-288h]\n  __int16 v19; // [esp+62h] [ebp-286h]\n  char v20[236]; // [esp+64h] [ebp-284h] BYREF\n  int v21; // [esp+150h] [ebp-198h]\n\n  v11[0] = (int)v14;\n  v11[1] = 656;\n  memset(&message, 0, sizeof(message));\n  message.msg_iov = (struct iovec *)v11;\n  message.msg_iovlen = 1;\n  message.msg_control = &v13;\n  message.msg_controllen = 32;\n  while ( 1 )\n  {\n    result = recvmsg(a2, &message, 0);\n    if ( result >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 4 )\n      return result;\n  }\n  if ( result <= 27 )\n    return -2;\n  LOBYTE(v4) = v14[3];\n  HIBYTE(v4) = v14[2];\n  v5 = v4;\n  if ( v4 > result )\n    return -2;\n  if ( v15 != 17 )\n    return -2;\n  if ( v14[0] != 69 )\n    return -2;\n  if ( v17 != 17408 )\n    return -2;\n  LOBYTE(v6) = HIBYTE(v18);\n  HIBYTE(v6) = v18;\n  if ( v4 - 20 != v6 )\n    return -2;\n  v7 = v16;\n  v16 = 0;\n  if ( (unsigned __int16)sub_80AD4D4() != v7 )\n    return -2;\n  if ( message.msg_controllen > 0xB )\n  {\n    for ( i = (struct cmsghdr *)message.msg_control; i; i = __cmsg_nxthdr(&message, i) )\n    {\n      if ( i->cmsg_level == 263 && i->cmsg_type == 8 && (i[1].cmsg_len & 8) != 0 )\n        goto LABEL_21;\n    }\n  }\n  memset(v14, 0, sizeof(v14));\n  v8 = v19;\n  *(_WORD *)&v14[2] = v18;\n  v19 = 0;\n  if ( v8 )\n  {\n    if ( (unsigned __int16)sub_80AD4D4() != v8 )\n      return -2;\n  }\nLABEL_21:\n  if ( v21 != 1666417251 )\n  {\n    sub_804D5F4(\"packet with bad magic, ignoring\");\n    return -2;\n  }\n  result = v5 - 28;\n  qmemcpy(a1, v20, v5 - 28);\n  return result;\n}\n"
    ],
    "sub_806A205": [
        "0x806a205",
        "int sub_806A205()\n{\n  sub_80B3C0D();\n  byte_80DB561 &= ~1u;\n  return sub_80B0A2C();\n}\n"
    ],
    "sub_806A21D": [
        "0x806a21d",
        "int __usercall sub_806A21D@<eax>(char *a1@<eax>, const char *a2@<edx>, unsigned __int8 *a3@<ecx>)\n{\n  return sprintf(a1, \"%s%u.%u.%u.%u\", a2, *a3, a3[1], a3[2], a3[3]);\n}\n"
    ],
    "sub_806A242": [
        "0x806a242",
        "int __usercall sub_806A242@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int result; // eax\n  int v4; // esi\n  int v5; // ebx\n  int v6; // [esp-4h] [ebp-24h]\n  struct sockaddr v7[2]; // [esp+0h] [ebp-20h] BYREF\n\n  byte_80DB766 = a1;\n  result = fd;\n  if ( fd >= 0 )\n  {\n    close(fd);\n    fd = -1;\n    result = v6;\n  }\n  if ( a1 == 1 )\n  {\n    result = sub_806B745(a2, *(_DWORD *)dword_80DB9A4);\n    fd = result;\n  }\n  else if ( a1 )\n  {\n    v4 = dword_80DB980;\n    v5 = sub_804DF99(8, 2, 17);\n    memset(&v7[0].sa_data[6], 0, 0xCu);\n    *(_DWORD *)&v7[0].sa_family = 524305;\n    *(_DWORD *)&v7[0].sa_data[2] = v4;\n    sub_804DFB3(0x14u, v7, v5);\n    result = sub_80B4242();\n    fd = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_806A2EB": [
        "0x806a2eb",
        "char *__usercall sub_806A2EB@<eax>(char *s@<ecx>, unsigned __int8 *a2@<eax>, char a3@<dl>)\n{\n  unsigned __int8 *v3; // esi\n  signed int v5; // ebp\n  int v6; // ecx\n  signed int v7; // edi\n  size_t v8; // eax\n  char *v9; // ebx\n  int v10; // eax\n  int v11; // eax\n  char *v12; // eax\n  char *k; // edx\n  char v14; // al\n  unsigned int v15; // edi\n  int v16; // ebp\n  unsigned int v17; // eax\n  int j; // ecx\n  unsigned __int8 *v19; // esi\n  int v20; // ebp\n  char *v21; // ebx\n  char *v22; // ebx\n  int v23; // eax\n  int v24; // edx\n  char *v25; // ebx\n  char *v26; // ebx\n  char *v27; // ebx\n  int v28; // ebp\n  int v29; // esi\n  char v31; // [esp+0h] [ebp-28h]\n  const char *i; // [esp+0h] [ebp-28h]\n  char *sb; // [esp+4h] [ebp-24h]\n  char *sa; // [esp+4h] [ebp-24h]\n  const char *v35; // [esp+8h] [ebp-20h]\n  int v36[5]; // [esp+14h] [ebp-14h] BYREF\n\n  v3 = a2;\n  v5 = *(a2 - 1);\n  v31 = a3 & 0xF;\n  v6 = a3 & 0xF;\n  v7 = (unsigned __int8)byte_80CFCF3[v6];\n  sb = (char *)((v5 + v7) / (unsigned int)v7 * (unsigned __int8)byte_80CFAA6[v6]);\n  v8 = strlen(s);\n  sa = (char *)sub_804DAFA((size_t)&sb[v8 + 2]);\n  v9 = &sa[sprintf(sa, \"%s=\", s)];\n  v35 = \"wakeup dt=%ld\" + 10;\n  if ( v31 == 7 )\n    v35 = \"%lu\";\n  while ( 2 )\n  {\n    if ( v7 <= v5 )\n    {\n      switch ( v31 )\n      {\n        case 1:\n        case 2:\n          v9 += sub_806A21D(v9, &data, v3);\n          if ( v31 != 1 )\n            v9 += sub_806A21D(v9, \"/\", v3 + 4);\n          goto LABEL_37;\n        case 3:\n        case 4:\n          qmemcpy(v9, v3, v5);\n          v9[v5] = 0;\n          if ( v31 != 4 )\n            return sa;\n          v12 = v9;\n          break;\n        case 5:\n          v10 = *v3;\n          goto LABEL_9;\n        case 6:\n          BYTE1(v10) = *(_WORD *)v3;\n          LOBYTE(v10) = HIBYTE(*(_WORD *)v3);\n          v10 = (unsigned __int16)v10;\nLABEL_9:\n          v11 = sprintf(v9, \"%u\", v10);\n          goto LABEL_10;\n        case 7:\n        case 8:\n          v11 = sprintf(v9, v35, _byteswap_ulong(*(_DWORD *)v3));\nLABEL_10:\n          v9 += v11;\n          goto LABEL_37;\n        case 10:\n          for ( i = &data; v5 > 4; i = \"        \" + 7 )\n          {\n            v15 = *v3;\n            if ( v15 > 0x20 )\n              break;\n            v16 = v5 - 1;\n            v36[0] = 0;\n            v17 = (v15 + 7) >> 3;\n            for ( j = 0; v17 != j; ++j )\n              *((_BYTE *)v36 + j) = v3[j + 1];\n            v19 = &v3[v17 + 1];\n            v20 = v16 - v17;\n            if ( v20 <= 3 )\n              break;\n            v21 = &v9[sub_806A21D(v9, i, (unsigned __int8 *)v36)];\n            v22 = &v21[sprintf(v21, \"/%u \", v15)];\n            v9 = &v22[sub_806A21D(v22, &data, v19)];\n            v3 = v19 + 4;\n            v5 = v20 - 4;\n          }\n          return sa;\n        case 11:\n          if ( v5 > 21 )\n          {\n            v23 = *v3;\n            if ( (unsigned __int8)v23 <= 0x20u )\n            {\n              v24 = v3[1] + 32 - v23;\n              if ( (v24 - 128 < 0) ^ __OFADD__(-128, v24) | (v24 == 128) )\n              {\n                v25 = &v9[sprintf(v9, \"%u \", *v3)];\n                v26 = &v25[sprintf(v25, \"%u \", v3[1])];\n                v27 = &v26[sub_806BEF4()];\n                v28 = v5 - 22;\n                v29 = (int)&v3[v28 + 18];\n                do\n                {\n                  v27 += sub_806A21D(v27, \" \", (unsigned __int8 *)(v29 - v28));\n                  v28 -= 4;\n                }\n                while ( v28 >= 0 );\n              }\n            }\n          }\n          return sa;\n        default:\nLABEL_37:\n          v3 += v7;\n          v5 -= v7;\n          if ( v7 > v5 )\n            return sa;\n          *(_WORD *)v9++ = 32;\n          continue;\n      }\n      while ( 1 )\n      {\n        for ( k = v12; ; ++k )\n        {\n          v14 = *k;\n          if ( (unsigned __int8)((*k | 0x20) - 97) <= 0x19u || (unsigned __int8)(v14 - 48) <= 9u )\n            continue;\n          if ( !v14 || v14 == 46 )\n            break;\n          if ( v14 != 45 && v14 != 95 )\n          {\n            sub_80B2C4E(v5, \"bad\");\n            return sa;\n          }\n        }\n        if ( v14 )\n        {\n          v12 = k + 1;\n          if ( k[1] )\n            continue;\n        }\n        return sa;\n      }\n    }\n    return sa;\n  }\n}\n"
    ],
    "sub_806A57F": [
        "0x806a57f",
        "void __usercall sub_806A57F(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebx\n  char v4; // di\n  unsigned int i; // ebp\n  _BYTE *v6; // eax\n  char *v7; // eax\n  char *v8; // ebp\n  char **v9; // ebx\n  char *v10; // ebp\n  char *v11; // eax\n  char *v12; // eax\n  char *v13; // edi\n  char *v14; // ebp\n  int v15; // edx\n  int v16; // eax\n  int v17; // ecx\n  char *v18; // eax\n  unsigned __int32 v19; // eax\n  int v20; // edx\n  char *v21; // eax\n  signed int v22; // edi\n  int v23; // eax\n  char *v24; // ebp\n  int v25; // eax\n  char **j; // ebx\n  _DWORD *ptr; // [esp+0h] [ebp-44h]\n  char **ptra; // [esp+0h] [ebp-44h]\n  int v29; // [esp+4h] [ebp-40h]\n  unsigned __int8 *v30; // [esp+8h] [ebp-3Ch]\n  _DWORD *v31; // [esp+Ch] [ebp-38h]\n  int v33[12]; // [esp+14h] [ebp-30h] BYREF\n\n  memset(v33, 0, 0x20u);\n  if ( a1 )\n  {\n    v3 = 6;\n    v4 = 0;\n    for ( i = 1; i != 255; ++i )\n    {\n      v6 = (_BYTE *)sub_806B9D0();\n      if ( v6 )\n      {\n        if ( i == 52 )\n        {\n          v4 |= *v6;\n        }\n        else if ( i == 1 )\n        {\n          ++v3;\n        }\n        ++v3;\n        v33[i >> 5] |= 1 << i;\n      }\n    }\n  }\n  else\n  {\n    v4 = 0;\n    v3 = 6;\n  }\n  ptr = sub_804DB2E(4 * v3);\n  v7 = sub_804DDBF(\"interface=%s\", *(const char **)dword_80DB9A4);\n  *ptr = v7;\n  putenv(v7);\n  if ( a1 )\n  {\n    v8 = (char *)sub_804DAFA(0x13u);\n    ptr[1] = v8;\n    sub_806A21D(v8, \"ip=\", (unsigned __int8 *)(a1 + 16));\n    v9 = (char **)(ptr + 2);\n    putenv(v8);\n    if ( *(_DWORD *)(a1 + 20) )\n    {\n      v10 = (char *)sub_804DAFA(0x17u);\n      ptr[2] = v10;\n      sub_806A21D(v10, \"siaddr=\", (unsigned __int8 *)(a1 + 20));\n      v9 = (char **)(ptr + 3);\n      putenv(v10);\n    }\n    if ( (v4 & 1) == 0 && *(_BYTE *)(a1 + 108) )\n    {\n      v11 = sub_804DDBF(\"boot_file=%.128s\", (const char *)(a1 + 108));\n      *v9++ = v11;\n      putenv(v11);\n    }\n    if ( (v4 & 2) == 0 && *(_BYTE *)(a1 + 44) )\n    {\n      v12 = sub_804DDBF(\"sname=%.64s\", (const char *)(a1 + 44));\n      *v9++ = v12;\n      putenv(v12);\n    }\n    v13 = (char *)&unk_80B5BE0;\n    v14 = \"subnet\";\n    while ( *v14 )\n    {\n      LOBYTE(v29) = v13[1];\n      v15 = (unsigned __int8)v29 >> 5;\n      v16 = 1 << (v29 & 0x1F);\n      v17 = v33[v15];\n      if ( (v17 & v16) != 0 )\n      {\n        v33[v15] = v17 & ~v16;\n        v30 = (unsigned __int8 *)sub_806B9D0();\n        v18 = sub_806A2EB(v14, v30, *v13);\n        *v9 = v18;\n        v31 = v9 + 1;\n        putenv(v18);\n        if ( (_BYTE)v29 == 1 )\n        {\n          v19 = _byteswap_ulong(*(_DWORD *)v30);\n          v20 = 0;\n          while ( v19 )\n          {\n            ++v20;\n            v19 *= 2;\n          }\n          v21 = sub_804DDBF(\"mask=%u\", v20);\n          v9[1] = v21;\n          v9 += 2;\n          putenv(v21);\n        }\n        else\n        {\n          ++v9;\n        }\n      }\n      v14 += strlen(v14) + 1;\n      v13 += 2;\n    }\n    v22 = 0;\n    do\n    {\n      v23 = v33[(unsigned int)v22 >> 5];\n      if ( v23 )\n      {\n        if ( _bittest(&v23, v22) )\n        {\n          v30 = (unsigned __int8 *)sub_806B9D0();\n          v29 = *(v30 - 1);\n          v24 = (char *)sub_804DAFA(2 * v29 + 9);\n          *v9 = v24;\n          v25 = sprintf(v24, \"opt%u=\", v22);\n          *(_BYTE *)sub_804D727((int)&v24[v25], (int)v30, v29) = 0;\n          ++v9;\n          putenv(v24);\n        }\n        ++v22;\n      }\n      else\n      {\n        v22 += 32;\n      }\n    }\n    while ( v22 <= 255 );\n  }\n  v33[1] = a2;\n  v33[2] = 0;\n  sub_80B3C03(ptr, v29, v30, v31, a2, dword_80DB9AC);\n  for ( j = ptra; *j; ++j )\n    sub_804DE4D(*j);\n  free(ptra);\n}\n"
    ],
    "sub_806A845": [
        "0x806a845",
        "int __usercall sub_806A845@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char v6[12]; // [esp+0h] [ebp-27Ch] BYREF\n  int v7; // [esp+Ch] [ebp-270h]\n\n  sub_8069DB7((int)v6, 7u, a3);\n  v7 = a2;\n  sub_806BADE(a1, 54);\n  sub_804D5F4(\"sending %s\", \"release\");\n  if ( a1 )\n    return sub_806B47D(a1, 67);\n  else\n    return sub_8069EE9();\n}\n"
    ],
    "sub_806A8AB": [
        "0x806a8ab",
        "int __usercall sub_806A8AB@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  char *v4; // eax\n  char *v5; // eax\n  int v6; // ecx\n  int v7; // ecx\n  int result; // eax\n  char dest[28]; // [esp+0h] [ebp-1Ch] BYREF\n\n  if ( (unsigned __int8)(byte_80DB765 - 2) <= 3u )\n  {\n    v4 = inet_ntoa((struct in_addr)a1);\n    strcpy(dest, v4);\n    v5 = inet_ntoa((struct in_addr)a2);\n    sub_804D5F4(\"unicasting a release of %s to %s\", v5, dest);\n    sub_806A845(a1, a2, v6);\n  }\n  sub_804D5F4(\"entering released state\");\n  sub_806A57F(0, (int)\"deconfig\");\n  result = sub_806A242(0, v7);\n  byte_80DB765 = 6;\n  return result;\n}\n"
    ],
    "sub_806A91B": [
        "0x806a91b",
        "int __cdecl sub_806A91B(int a1, int a2)\n{\n  unsigned int v2; // esi\n  const char *v3; // ebx\n  unsigned int v4; // eax\n  _BYTE *i; // edx\n  const char *v6; // eax\n  char *v7; // ebx\n  int v8; // ecx\n  unsigned int v9; // eax\n  int v10; // ecx\n  int v11; // edi\n  int v12; // ebp\n  unsigned int v13; // ebx\n  int v14; // ecx\n  int v15; // eax\n  int v16; // eax\n  int v17; // ecx\n  int v18; // eax\n  ssize_t v19; // eax\n  int v20; // ecx\n  unsigned __int8 *v21; // eax\n  unsigned __int8 *v22; // eax\n  unsigned __int8 v23; // al\n  unsigned __int8 *v24; // eax\n  unsigned __int32 v25; // edi\n  int v26; // ecx\n  int v27; // ecx\n  unsigned int v28; // eax\n  char *v29; // eax\n  int v30; // ebx\n  const char *v31; // edx\n  int v32; // ecx\n  char *v33; // edi\n  int v34; // ecx\n  unsigned __int8 *v35; // eax\n  int v37; // [esp+8h] [ebp-2E4h]\n  int s_addr; // [esp+10h] [ebp-2DCh]\n  int v39; // [esp+14h] [ebp-2D8h]\n  int v40; // [esp+18h] [ebp-2D4h]\n  int v41; // [esp+1Ch] [ebp-2D0h]\n  int v42; // [esp+20h] [ebp-2CCh]\n  char *v43; // [esp+20h] [ebp-2CCh]\n  int v44; // [esp+24h] [ebp-2C8h]\n  int v45; // [esp+28h] [ebp-2C4h]\n  unsigned int v46; // [esp+2Ch] [ebp-2C0h]\n  const char *v47; // [esp+30h] [ebp-2BCh] BYREF\n  const void *v48; // [esp+34h] [ebp-2B8h] BYREF\n  const void *v49; // [esp+38h] [ebp-2B4h] BYREF\n  char *v50; // [esp+3Ch] [ebp-2B0h] BYREF\n  const char *v51; // [esp+40h] [ebp-2ACh] BYREF\n  _DWORD *v52; // [esp+44h] [ebp-2A8h] BYREF\n  _DWORD *v53; // [esp+48h] [ebp-2A4h] BYREF\n  char *cp; // [esp+4Ch] [ebp-2A0h] BYREF\n  unsigned int v55; // [esp+50h] [ebp-29Ch] BYREF\n  int v56; // [esp+54h] [ebp-298h] BYREF\n  struct pollfd v57; // [esp+58h] [ebp-294h] BYREF\n  int v58; // [esp+64h] [ebp-288h]\n  struct pollfd fds; // [esp+68h] [ebp-284h] BYREF\n  struct in_addr v60; // [esp+78h] [ebp-274h]\n  char v61[4]; // [esp+84h] [ebp-268h] BYREF\n\n  v51 = \"2000\";\n  v52 = 0;\n  v53 = 0;\n  cp = (char *)20;\n  v55 = 3;\n  v56 = 3;\n  *(_DWORD *)dword_80DB9A4 = \"eth0\";\n  dword_80DB9AC = (int)&unk_80CF884;\n  v47 = \"udhcp 1.29.2\";\n  v2 = sub_80ABEC2(\n         a2,\n         \"^CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fBba::v\",\n         \"clientid-none\",\n         &v47,\n         &v48,\n         &v48,\n         &v49,\n         dword_80DB9A4,\n         &dword_80DB9A8,\n         &v50,\n         &dword_80DB9AC,\n         &v55,\n         &v56,\n         &cp,\n         &v52,\n         &v53,\n         &v51);\n  if ( (v2 & 0xC) != 0 )\n  {\n    sub_804D5F4(\"option -h NAME is deprecated, use -x hostname:NAME\");\n    dword_80DB9BC = (int)sub_8069D7C(12, v48, 0);\n  }\n  if ( (v2 & 0x10) != 0 )\n  {\n    dword_80DB9C0 = (int)sub_8069D7C(81, v49, 3);\n    *(_BYTE *)(dword_80DB9C0 + 2) = 1;\n  }\n  s_addr = 0;\n  if ( (v2 & 0x400) != 0 )\n    s_addr = inet_addr(v50);\n  v46 = sub_80B40EC(v51);\n  while ( v52 )\n  {\n    v3 = (const char *)sub_80AFB01(&v52);\n    v4 = sub_804ED6C(0, v3, 0, (int)v3);\n    if ( *(_DWORD *)dword_80DBB7C || v4 > 0xFE )\n      v4 = (unsigned __int8)byte_80B5BE1[2 * sub_806B974(v3, \"subnet\")];\n    byte_80DB984[v4 >> 3] |= 1 << (v4 & 7);\n  }\n  if ( (v2 & 0x20000) == 0 )\n  {\n    for ( i = &unk_80B5BE0; i[1]; i += 2 )\n    {\n      if ( (*i & 0x10) != 0 )\n        byte_80DB984[(unsigned __int8)i[1] >> 3] |= 1 << (i[1] & 7);\n    }\n  }\n  while ( v53 )\n  {\n    v6 = (const char *)sub_80AFB01(&v53);\n    v7 = sub_804DB46(v6);\n    sub_806BCAF(v7, (unsigned __int8 ***)&dword_80DB9B0, (int)&unk_80B5BE0, \"subnet\");\n    free(v7);\n  }\n  v44 = sub_806B66A(*(const char **)dword_80DB9A4, &dword_80DB980, 0, (int)&dword_80DB978);\n  if ( v44 )\n    return 1;\n  if ( (v2 & 1) != 0 || sub_806BB3E((unsigned __int8 **)dword_80DB9B0, 0x3Du) )\n  {\n    v40 = 0;\n  }\n  else\n  {\n    dword_80DB9B4 = (int)sub_8069D7C(61, &data, 7);\n    *(_BYTE *)(dword_80DB9B4 + 2) = 1;\n    v8 = dword_80DB9B4 + 3;\n    v40 = dword_80DB9B4 + 3;\n    *(_DWORD *)(dword_80DB9B4 + 3) = dword_80DB978;\n    *(_WORD *)(v8 + 4) = word_80DB97C;\n  }\n  if ( *v47 )\n    dword_80DB9B8 = (int)sub_8069D7C(60, v47, 0);\n  if ( (v2 & 0x4000) != 0 )\n  {\n    openlog(ident, 1, 24);\n    byte_80DB561 |= 2u;\n  }\n  sub_80B3CDB();\n  sub_80B0A2C((int)dword_80DB9A8);\n  sub_804D5F4(\"started, v1.29.2\");\n  sub_806B5CE();\n  v9 = sub_804EBDE();\n  srand(v9);\n  byte_80DB765 = 0;\n  sub_806A57F(0, (int)\"deconfig\");\n  sub_806A242(2, v10);\nLABEL_31:\n  v11 = 0;\nLABEL_32:\n  v12 = 0;\nLABEL_33:\n  v13 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        sub_806B60F((int)&v57, fd);\n        if ( (int)(v11 - v13) <= 0 )\n        {\nLABEL_35:\n          if ( sub_806B66A(*(const char **)dword_80DB9A4, &dword_80DB980, 0, (int)&dword_80DB978) )\n            goto LABEL_135;\n          if ( v40 )\n          {\n            v14 = v40;\n            *(_DWORD *)v40 = dword_80DB978;\n            *(_WORD *)(v40 + 4) = word_80DB97C;\n          }\n          switch ( byte_80DB765 )\n          {\n            case 0:\n              if ( v56 && v56 <= v12 )\n                goto LABEL_54;\n              if ( !v12 )\n                v41 = rand();\n              sub_8069F03(v41, s_addr, v14);\n              goto LABEL_61;\n            case 1:\n              if ( v12 <= 2 )\n              {\n                sub_8069F5B(v41, v39, s_addr);\nLABEL_61:\n                v11 = v55;\n                ++v12;\n                goto LABEL_33;\n              }\n              sub_806A242(2, v14);\n              byte_80DB765 = 0;\nLABEL_54:\n              sub_806A57F(0, (int)\"leasefail\");\n              if ( (v2 & 0x200000) != 0 )\n              {\n                sub_804D5F4(\"no lease, forking to background\");\n                sub_806A205();\n                v2 = v2 & 0xFFD7FFFF | 0x80000;\n              }\n              else if ( (v2 & 0x40) != 0 )\n              {\n                sub_804D5F4(\"no lease, failing\");\n                v44 = 1;\n                goto LABEL_137;\n              }\n              v11 = (int)cp;\n              goto LABEL_32;\n            case 2:\n              byte_80DB765 = 3;\n              word_80DB9C4 = 0;\n              sub_806A242(1, v14);\n              goto LABEL_63;\n            case 3:\n            case 5:\n              goto LABEL_63;\n            case 4:\n              goto LABEL_66;\n            default:\n              v13 = 0;\n              goto LABEL_134;\n          }\n        }\n        v45 = sub_804EC4A();\n        v15 = 0x7FFFFFFF;\n        if ( (int)(v11 - v13) <= 2147482 )\n          v15 = 1000 * (v11 - v13);\n        v16 = poll(&v57, 2u, v15);\n        if ( v16 >= 0 )\n          break;\n        if ( *(_DWORD *)dword_80DBB7C != 4 )\n          sub_804D3C9((int)\"poll\");\n        v13 = sub_804EC4A() + v13 - v45;\n      }\n      if ( !v16 )\n        goto LABEL_35;\n      v18 = sub_806B646(v17);\n      if ( v18 != 12 )\n        break;\n      sub_806A8AB(v39, s_addr);\nLABEL_134:\n      v11 = 0x7FFFFFFF;\n    }\n    if ( v18 == 15 )\n      break;\n    if ( v18 == 10 )\n    {\n      word_80DB9C4 = 0;\n      sub_804D5F4(\"performing DHCP renew\");\n      switch ( byte_80DB765 )\n      {\n        case 1:\n        case 6:\n          goto LABEL_77;\n        case 2:\n          sub_806A242(1, v14);\n          goto LABEL_75;\n        case 3:\n        case 4:\nLABEL_75:\n          byte_80DB765 = 5;\n          break;\n        case 5:\n          sub_806A57F(0, (int)\"deconfig\");\nLABEL_77:\n          sub_806A242(2, v14);\n          byte_80DB765 = 0;\n          break;\n        default:\n          break;\n      }\n      if ( byte_80DB765 != 5 )\n        goto LABEL_31;\n      if ( v11 > (int)cp )\n        v11 = (int)cp;\nLABEL_63:\n      if ( v11 <= 60 || sub_806A01A(v41, (struct in_addr)v39, s_addr) < 0 )\n      {\n        byte_80DB765 = 4;\nLABEL_66:\n        sub_806A242(2, v14);\n        if ( v11 > 0 )\n        {\n          sub_806A01A(v41, 0, s_addr);\n          goto LABEL_68;\n        }\n        sub_804D5F4(\"lease lost, entering init state\");\n        sub_806A57F(0, (int)\"deconfig\");\n        byte_80DB765 = 0;\n        word_80DB9C4 = 0;\n        goto LABEL_32;\n      }\nLABEL_68:\n      v11 >>= 1;\n      goto LABEL_33;\n    }\n    if ( HIWORD(v58) )\n    {\n      if ( byte_80DB766 == 1 )\n        v19 = sub_806B29E(&fds, fd);\n      else\n        v19 = sub_806A084((char *)&fds, fd);\n      v42 = v19;\n      if ( v19 == -1 )\n      {\n        sub_804D5F4(\"read error: %m, reopening socket\");\n        sleep(v55);\n        sub_806A242(byte_80DB766, v20);\n      }\n      v13 = sub_804EC4A() + v13 - v45;\n      if ( v42 >= 0 && *(_DWORD *)&fds.events == v41 && BYTE2(fds.fd) == 6 )\n      {\n        v43 = (char *)memcmp(v61, &dword_80DB978, 6u);\n        if ( !v43 )\n        {\n          v21 = sub_806B9D0((unsigned __int8 *)&fds, 53);\n          if ( v21 )\n          {\n            if ( byte_80DB765 == 1 )\n            {\nLABEL_106:\n              v23 = *v21;\n              if ( v23 == 5 )\n              {\n                v24 = sub_806B9D0((unsigned __int8 *)&fds, 51);\n                if ( v24 )\n                {\n                  v25 = _byteswap_ulong(*(_DWORD *)v24);\n                  if ( v25 < 0x10 )\n                    v25 = 16;\n                }\n                else\n                {\n                  sub_804D5F4(\"no lease time with ACK, using 1 hour lease\");\n                  v25 = 3600;\n                }\n                if ( (v2 & 0x400000) == 0\n                  || sub_806B7E1(v60.s_addr, 0, 0, (int)&dword_80DB978, *(int *)dword_80DB9A4, v46) )\n                {\n                  v29 = inet_ntoa(v60);\n                  sub_804D5F4(\"lease of %s obtained, lease time %u\", v29, v25);\n                  s_addr = v60.s_addr;\n                  v30 = sub_804EC4A();\n                  v31 = \"performing DHCP renew\" + 16;\n                  if ( byte_80DB765 == 1 )\n                    v31 = \"bound\";\n                  sub_806A57F((int)&fds, (int)v31);\n                  v13 = sub_804EC4A() - v30;\n                  v33 = (char *)(v25 >> 1);\n                  if ( (unsigned int)v33 < v13 )\n                    v13 = 0;\n                  else\n                    v43 = v33;\n                  byte_80DB765 = 2;\n                  sub_806A242(0, v32);\n                  if ( (v2 & 0x100) != 0 )\n                    goto LABEL_135;\n                  v28 = v2 & 0xFFFFFFBF;\n                  if ( (v2 & 0x80000) == 0 )\n                  {\n                    sub_806A205();\n                    v28 = v2 & 0xFFD7FFBF | 0x80000;\n                  }\n                }\n                else\n                {\n                  sub_804D5F4(\"offered address is in use (got ARP reply), declining\");\n                  sub_8069FC3(v39, v60.s_addr, v26);\n                  if ( byte_80DB765 != 1 )\n                    sub_806A57F(0, (int)\"deconfig\");\n                  sub_806A242(2, v27);\n                  byte_80DB765 = 0;\n                  word_80DB9C4 = 0;\n                  v43 = cp;\n                  v28 = v2;\n                  v12 = 0;\n                  v13 = 0;\n                  s_addr = 0;\n                }\n                v2 = v28;\n                v11 = (int)v43;\n              }\n              else if ( v23 == 6\n                     && (!v39 || (v35 = sub_806B9D0((unsigned __int8 *)&fds, 54)) != 0 && v39 == *(_DWORD *)v35) )\n              {\n                sub_804D5F4(\"received %s\", \"DHCP NAK\");\n                sub_806A57F((int)&fds, (int)\"nak\");\n                v34 = v37;\n                if ( byte_80DB765 != 1 )\n                  sub_806A57F(0, (int)\"deconfig\");\n                sub_806A242(2, v34);\n                sleep(3u);\n                byte_80DB765 = 0;\n                word_80DB9C4 = 0;\n                v11 = 0;\n                v12 = 0;\n                v13 = 0;\n                s_addr = 0;\n              }\n            }\n            else if ( byte_80DB765 > 1 )\n            {\n              if ( (unsigned __int8)(byte_80DB765 - 3) <= 2u )\n                goto LABEL_106;\n            }\n            else if ( !byte_80DB765 && *v21 == 2 )\n            {\n              v22 = sub_806B9D0((unsigned __int8 *)&fds, 54);\n              if ( v22 )\n              {\n                v39 = *(_DWORD *)v22;\n              }\n              else\n              {\n                sub_804D5F4(\"no server ID, using 0.0.0.0\");\n                v39 = 0;\n              }\n              s_addr = v60.s_addr;\n              byte_80DB765 = 1;\n              goto LABEL_31;\n            }\n          }\n          else\n          {\n            sub_804D5F4(\"no message type option, ignoring packet\");\n          }\n        }\n      }\n    }\n  }\n  sub_804D5F4(\"received %s\", \"SIGTERM\");\nLABEL_135:\n  if ( (v2 & 0x200) != 0 )\n    sub_806A8AB(v39, s_addr);\nLABEL_137:\n  if ( byte_80DBBA7 )\n    unlink(dword_80DB9A8);\n  return v44;\n}\n"
    ],
    "sub_806B251": [
        "0x806b251",
        "int __usercall sub_806B251@<eax>(_BYTE *a1@<eax>, unsigned __int8 a2@<dl>)\n{\n  memset(a1, 0, 0x274u);\n  *a1 = 1;\n  if ( a2 <= 6u && ((1 << a2) & 0x64) != 0 )\n    *a1 = 2;\n  *(_WORD *)(a1 + 1) = 1537;\n  *((_DWORD *)a1 + 59) = 1666417251;\n  a1[240] = -1;\n  return sub_806BADE(a2, 53);\n}\n"
    ],
    "sub_806B29E": [
        "0x806b29e",
        "ssize_t __usercall sub_806B29E@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  ssize_t result; // eax\n\n  memset(a1, 0, 0x274u);\n  result = sub_804E5BC(0x274u, a1, a2);\n  if ( result >= 0 && (result <= 239 || a1[59] != 1666417251) )\n  {\n    sub_804D5F4(\"packet with bad magic, ignoring\");\n    return -2;\n  }\n  return result;\n}\n"
    ],
    "sub_806B2E9": [
        "0x806b2e9",
        "ssize_t __userpurge sub_806B2E9@<eax>(\n        const void *a1@<eax>,\n        int a2@<edx>,\n        __int16 a3@<cx>,\n        int a4,\n        __int16 a5,\n        int a6,\n        int a7)\n{\n  int v8; // eax\n  int v9; // ebx\n  unsigned int v10; // esi\n  __int16 v11; // ax\n  __int16 v12; // ax\n  ssize_t v13; // esi\n  const char *v14; // edi\n  _DWORD addr[5]; // [esp+8h] [ebp-2B4h] BYREF\n  int buf[7]; // [esp+1Ch] [ebp-2A0h] BYREF\n  char v20[628]; // [esp+38h] [ebp-284h] BYREF\n\n  v8 = socket(17, 2, 8);\n  if ( v8 < 0 )\n  {\n    v14 = \"socket(%s)\";\n    v13 = -1;\nLABEL_10:\n    sub_804D3A5((int)v14, \"PACKET\");\n    return v13;\n  }\n  v9 = v8;\n  memset(&addr[2], 0, 0xCu);\n  memset(buf, 0, sizeof(buf));\n  qmemcpy(v20, a1, sizeof(v20));\n  addr[0] = 524305;\n  addr[1] = a7;\n  HIBYTE(addr[2]) = 6;\n  addr[3] = *(_DWORD *)a6;\n  LOWORD(addr[4]) = *(_WORD *)(a6 + 4);\n  if ( bind(v8, (const struct sockaddr *)addr, 0x14u) < 0 )\n  {\n    v14 = \"bind(%s)\";\n    v13 = -1;\n  }\n  else\n  {\n    v10 = 307 - sub_806BA72();\n    if ( v10 > 0xF8 )\n      v10 = 248;\n    BYTE1(buf[2]) = 17;\n    buf[3] = a2;\n    buf[4] = a4;\n    LOBYTE(v11) = HIBYTE(a3);\n    HIBYTE(v11) = a3;\n    LOWORD(buf[5]) = v11;\n    LOBYTE(v11) = HIBYTE(a5);\n    HIBYTE(v11) = a5;\n    HIWORD(buf[5]) = v11;\n    HIBYTE(v11) = 44 - v10;\n    LOBYTE(v11) = (unsigned __int16)(556 - v10) >> 8;\n    LOWORD(buf[6]) = v11;\n    HIWORD(buf[0]) = v11;\n    HIWORD(buf[6]) = sub_80AD4D4();\n    HIBYTE(v12) = 64 - v10;\n    LOBYTE(v12) = (unsigned __int16)(576 - v10) >> 8;\n    HIWORD(buf[0]) = v12;\n    LOBYTE(buf[0]) = 69;\n    LOBYTE(buf[2]) = 64;\n    HIWORD(buf[2]) = sub_80AD4D4();\n    v13 = sendto(v9, buf, 576 - v10, 0, (const struct sockaddr *)addr, 0x14u);\n    v14 = \"sendto\";\n  }\n  close(v9);\n  if ( v13 < 0 )\n    goto LABEL_10;\n  return v13;\n}\n"
    ],
    "sub_806B47D": [
        "0x806b47d",
        "int __userpurge sub_806B47D@<eax>(void *a1@<eax>, int a2@<edx>, __int16 a3@<cx>, int a4, __int16 a5)\n{\n  int v7; // eax\n  int v8; // ebx\n  __int16 v9; // ax\n  int v10; // ebp\n  const char *v11; // edi\n  __int16 v12; // ax\n  unsigned int v13; // eax\n  struct sockaddr addr; // [esp+4h] [ebp-20h] BYREF\n\n  v7 = socket(2, 2, 17);\n  if ( v7 < 0 )\n  {\n    v11 = \"socket(%s)\";\n    v10 = -1;\nLABEL_10:\n    sub_804D3A5((int)v11, \"UDP\");\n    return v10;\n  }\n  v8 = v7;\n  sub_80B4262();\n  memset(&addr.sa_data[6], 0, 8u);\n  addr.sa_family = 2;\n  LOBYTE(v9) = HIBYTE(a3);\n  HIBYTE(v9) = a3;\n  *(_WORD *)addr.sa_data = v9;\n  *(_DWORD *)&addr.sa_data[2] = a2;\n  v10 = bind(v8, &addr, 0x10u);\n  v11 = \"bind(%s)\";\n  if ( v10 != -1 )\n  {\n    memset(&addr.sa_data[6], 0, 8u);\n    addr.sa_family = 2;\n    LOBYTE(v12) = HIBYTE(a5);\n    HIBYTE(v12) = a5;\n    *(_WORD *)addr.sa_data = v12;\n    *(_DWORD *)&addr.sa_data[2] = a4;\n    v10 = connect(v8, &addr, 0x10u);\n    v11 = \"connect\";\n    if ( v10 != -1 )\n    {\n      v13 = 307 - sub_806BA72();\n      if ( v13 > 0xF8 )\n        v13 = 248;\n      v10 = sub_804E65D(548 - v13, a1, v8);\n      v11 = \"write\";\n    }\n  }\n  close(v8);\n  if ( v10 < 0 )\n    goto LABEL_10;\n  return v10;\n}\n"
    ],
    "sub_806B592": [
        "0x806b592",
        "int __cdecl sub_806B592(char a1)\n{\n  _DWORD *v1; // ebx\n  int v2; // esi\n  int v4; // [esp+0h] [ebp-Ch] BYREF\n\n  v1 = (_DWORD *)dword_80DBB7C;\n  v2 = *(_DWORD *)dword_80DBB7C;\n  HIBYTE(v4) = a1;\n  if ( write(dword_80DB67C, (char *)&v4 + 3, 1u) != 1 )\n    sub_804D3A5((int)\"can't send signal\");\n  *v1 = v2;\n  return v4;\n}\n"
    ],
    "sub_806B5CE": [
        "0x806b5ce",
        "int sub_806B5CE()\n{\n  sub_804DC65(&dword_80DB678);\n  sub_804D670();\n  sub_804D670();\n  sub_804D61C();\n  sub_804D61C();\n  return sub_804E6C8(37888, (void (*)(int))sub_806B592);\n}\n"
    ],
    "sub_806B60F": [
        "0x806b60f",
        "int __usercall sub_806B60F@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = dword_80DB678;\n  *(_DWORD *)a1 = dword_80DB678;\n  *(_WORD *)(a1 + 4) = 1;\n  *(_DWORD *)(a1 + 8) = -1;\n  if ( a2 >= 0 )\n  {\n    result = sub_804D670();\n    *(_DWORD *)(a1 + 8) = a2;\n    *(_WORD *)(a1 + 12) = 1;\n  }\n  *(_WORD *)(a1 + 14) = 0;\n  return result;\n}\n"
    ],
    "sub_806B646": [
        "0x806b646",
        "int __fastcall sub_806B646(int a1)\n{\n  unsigned __int8 v3; // [esp+1h] [ebp-1h] BYREF\n\n  v3 = HIBYTE(a1);\n  if ( sub_804E5BC(1u, &v3, dword_80DB678) == 1 )\n    return v3;\n  else\n    return 0;\n}\n"
    ],
    "sub_806B66A": [
        "0x806b66a",
        "int __userpurge sub_806B66A@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, int a4)\n{\n  int v6; // edi\n  int v9[12]; // [esp+4h] [ebp-30h] BYREF\n\n  memset(v9, 0, 0x20u);\n  v6 = sub_804DF99(255, 3, 2);\n  LOWORD(v9[4]) = 2;\n  sub_804D67E((char *)v9, a1);\n  if ( a3 )\n  {\n    if ( sub_804E062(v6, 0x8915u, (int)v9, \"is interface %s up and configured?\", a1) )\n      goto LABEL_9;\n    *a3 = v9[5];\n  }\n  if ( !a2 )\n    goto LABEL_7;\n  if ( sub_804E09D(v6, 0x8933u, (int)v9, \"SIOCGIFINDEX\") )\n  {\nLABEL_9:\n    close(v6);\n    return -1;\n  }\n  *a2 = v9[4];\nLABEL_7:\n  if ( a4 )\n  {\n    if ( sub_804E09D(v6, 0x8927u, (int)v9, \"SIOCGIFHWADDR\") )\n      goto LABEL_9;\n    *(_DWORD *)a4 = *(int *)((char *)&v9[4] + 2);\n    *(_WORD *)(a4 + 4) = HIWORD(v9[5]);\n  }\n  close(v6);\n  return 0;\n}\n"
    ],
    "sub_806B745": [
        "0x806b745",
        "int __usercall sub_806B745@<eax>(__int16 a1@<ax>, const char *a2@<edx>)\n{\n  int v4; // ebx\n  char *v5; // eax\n  char *v6; // esi\n  int v8; // [esp-4h] [ebp-24h]\n  struct sockaddr v9[2]; // [esp+0h] [ebp-20h] BYREF\n\n  v4 = sub_804DF99(17, 2, 2);\n  sub_80B4262();\n  if ( sub_80B426C() == -1 )\n    sub_804D3C9((int)\"SO_BROADCAST\");\n  v5 = strrchr(a2, 58);\n  v6 = v5;\n  if ( v5 )\n    *v5 = 0;\n  if ( sub_80B4280(v8, a2) )\n    sub_804D604();\n  if ( v6 )\n    *v6 = 58;\n  memset(&v9[0].sa_data[2], 0, 0xCu);\n  v9[0].sa_family = 2;\n  *(_WORD *)v9[0].sa_data = __ROL2__(a1, 8);\n  sub_804DFB3(0x10u, v9, v4);\n  return v4;\n}\n"
    ],
    "sub_806B7E1": [
        "0x806b7e1",
        "int __userpurge sub_806B7E1@<eax>(\n        int a1@<eax>,\n        const void *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        int a5,\n        unsigned int timeout)\n{\n  int v6; // edi\n  unsigned int v9; // ebp\n  int v10; // edi\n  int v11; // eax\n  ssize_t v12; // eax\n  int fd; // [esp+4h] [ebp-64h]\n  struct sockaddr addr; // [esp+Ch] [ebp-5Ch] BYREF\n  int buf; // [esp+1Ch] [ebp-4Ch] BYREF\n  __int16 v18; // [esp+20h] [ebp-48h]\n  int v19; // [esp+22h] [ebp-46h]\n  __int16 v20; // [esp+26h] [ebp-42h]\n  int v21; // [esp+28h] [ebp-40h]\n  int v22; // [esp+2Ch] [ebp-3Ch]\n  __int16 v23; // [esp+30h] [ebp-38h]\n  int s2; // [esp+32h] [ebp-36h] BYREF\n  __int16 v25; // [esp+36h] [ebp-32h]\n  int v26; // [esp+38h] [ebp-30h]\n  _WORD v27[14]; // [esp+3Ch] [ebp-2Ch] BYREF\n\n  v6 = 1;\n  if ( timeout )\n  {\n    v6 = socket(17, 10, 1544);\n    fd = v6;\n    if ( v6 == -1 )\n    {\n      sub_804D3A5((int)\"can't create raw socket\");\n    }\n    else\n    {\n      if ( sub_80B426C() == -1 )\n      {\n        sub_804D3A5((int)\"can't enable bcast on raw socket\");\n      }\n      else\n      {\n        memset(v27, 0, sizeof(v27));\n        buf = -1;\n        v18 = -1;\n        v19 = *(_DWORD *)a4;\n        v20 = *(_WORD *)(a4 + 4);\n        v21 = 16778760;\n        v22 = 67502088;\n        v23 = 256;\n        s2 = v19;\n        v25 = v20;\n        v26 = a3;\n        *(_DWORD *)&v27[3] = a1;\n        memset(&addr, 0, sizeof(addr));\n        sub_80B2C4E(14, a5);\n        if ( sendto(v6, &buf, 0x3Cu, 0, &addr, 0x10u) >= 0 )\n        {\n          v9 = timeout;\n          do\n          {\n            v10 = sub_804EC14();\n            v11 = sub_80B2C0A(v9, 1u);\n            if ( v11 < 0 )\n              break;\n            if ( v11 )\n            {\n              v12 = sub_804E5BC(0x3Cu, &buf, fd);\n              if ( v12 < 0 )\n                break;\n              if ( v12 > 41 && v23 == 512 && v26 == a1 )\n              {\n                v6 = 0;\n                if ( !a2 || memcmp(a2, &s2, 6u) )\n                  goto LABEL_19;\n                break;\n              }\n            }\n            v9 = v9 + v10 - 1 - sub_804EC14();\n          }\n          while ( v9 <= timeout );\n        }\n      }\n      v6 = 1;\nLABEL_19:\n      close(fd);\n    }\n  }\n  return v6;\n}\n"
    ],
    "sub_806B974": [
        "0x806b974",
        "int __usercall sub_806B974@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n  const char *i; // ebx\n  const char *v6; // eax\n  int j; // edx\n  char v8; // cl\n\n  result = sub_804D222(a2, a1);\n  if ( result < 0 )\n  {\n    for ( i = a2; *i; i += strlen(i) + 1 )\n      ;\n    v6 = (const char *)sub_804DB2E(i - a2);\n    for ( j = 0; ; ++j )\n    {\n      v8 = a2[j];\n      if ( !v8 )\n      {\n        if ( !a2[j + 1] )\n          sub_804D5E0(\"unknown option '%s', known options: %s\", a1, v6);\n        v8 = 32;\n      }\n      v6[j] = v8;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_806B9D0": [
        "0x806b9d0",
        "unsigned __int8 *__usercall sub_806B9D0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  unsigned __int8 *v3; // ecx\n  int v4; // esi\n  int v5; // ebx\n  unsigned __int8 v6; // al\n  int v7; // ebp\n\n  v3 = a1 + 240;\n  v4 = 0;\n  v5 = 388;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v6 = *v3;\n      if ( *v3 )\n        break;\n      --v5;\n      ++v3;\nLABEL_4:\n      if ( !v5 )\n        goto LABEL_5;\n    }\n    if ( v6 != 0xFF )\n      break;\n    if ( (v4 & 0x101) == 1 )\n    {\n      v4 |= 0x101u;\n      v3 = a1 + 108;\n      v5 = 128;\n    }\n    else\n    {\n      if ( (v4 & 0x202) != 2 )\n        return 0;\n      v4 |= 0x202u;\n      v3 = a1 + 44;\n      v5 = 64;\n    }\n  }\n  if ( v5 != 1 )\n  {\n    v7 = v3[1] + 2;\n    v5 -= v7;\n    if ( v5 >= 0 )\n    {\n      if ( v6 == a2 )\n        return v3 + 2;\n      if ( v3[1] )\n      {\n        if ( v6 == 52 )\n          v4 |= v3[2];\n      }\n      v3 += v7;\n      goto LABEL_4;\n    }\n  }\nLABEL_5:\n  sub_804D5F4(\"bad packet, malformed option field\");\n  return 0;\n}\n"
    ],
    "sub_806BA72": [
        "0x806ba72",
        "int __usercall sub_806BA72@<eax>(int a1@<eax>)\n{\n  int i; // edx\n  char v2; // cl\n\n  for ( i = 0; ; ++i )\n  {\n    v2 = *(_BYTE *)(a1 + i);\n    if ( v2 == -1 )\n      break;\n    if ( v2 )\n      i += *(unsigned __int8 *)(a1 + i + 1) + 1;\n  }\n  return i;\n}\n"
    ],
    "sub_806BA8F": [
        "0x806ba8f",
        "unsigned __int8 *__usercall sub_806BA8F@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>)\n{\n  int v4; // edi\n  int v5; // eax\n  unsigned int v6; // ecx\n  unsigned int v7; // ebp\n  unsigned __int8 *result; // eax\n  int v9; // [esp-8h] [ebp-18h]\n\n  v4 = a1 + 240;\n  v5 = sub_806BA72(a1 + 240);\n  v6 = a2[1] + 2;\n  v7 = v5 + v6;\n  if ( v5 + v6 + 1 <= 0x133 )\n  {\n    result = (unsigned __int8 *)(v4 + v5);\n    qmemcpy(result, a2, v6);\n    *(_BYTE *)(a1 + v7 + 240) = -1;\n  }\n  else\n  {\n    sub_804D5F4(\"option 0x%02x did not fit into the packet\", *a2);\n    return (unsigned __int8 *)v9;\n  }\n  return result;\n}\n"
    ],
    "sub_806BADE": [
        "0x806bade",
        "unsigned __int8 *__usercall sub_806BADE@<eax>(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>)\n{\n  _BYTE *i; // ebx\n  char v5; // cl\n  unsigned __int8 v7[2]; // [esp+2h] [ebp-16h] BYREF\n  int v8; // [esp+4h] [ebp-14h]\n\n  for ( i = &unk_80B5BE0; ; i += 2 )\n  {\n    v5 = i[1];\n    if ( !v5 )\n      break;\n    if ( v5 == a2 )\n    {\n      v7[0] = a2;\n      v7[1] = byte_80CFCF3[*i & 0xF];\n      v8 = a3;\n      return sub_806BA8F(a1, v7);\n    }\n  }\n  return (unsigned __int8 *)sub_804D5F4(\"can't add option 0x%02x\", a2);\n}\n"
    ],
    "sub_806BB3E": [
        "0x806bb3e",
        "unsigned __int8 **__usercall sub_806BB3E@<eax>(unsigned __int8 **result@<eax>, unsigned __int8 a2@<dl>)\n{\n  unsigned __int8 v2; // cl\n\n  while ( result )\n  {\n    v2 = **result;\n    if ( v2 >= a2 )\n    {\n      if ( v2 != a2 )\n        return 0;\n      return result;\n    }\n    result = (unsigned __int8 **)result[1];\n  }\n  return result;\n}\n"
    ],
    "sub_806BB5A": [
        "0x806bb5a",
        "void __usercall sub_806BB5A(unsigned __int8 ***a1@<eax>, _BYTE *a2@<edx>, const char *a3@<ecx>, void *ptr)\n{\n  _BYTE *v6; // esi\n  _BYTE *v7; // eax\n  unsigned __int8 **v8; // eax\n  unsigned __int8 **v9; // ebp\n  unsigned __int8 **v10; // ebp\n  unsigned __int8 *v11; // eax\n  unsigned __int8 v12; // dl\n  unsigned __int8 **v13; // eax\n  unsigned __int8 *v14; // eax\n  int v15; // ebx\n  unsigned __int8 *v16; // eax\n  char *v17; // [esp+0h] [ebp-18h]\n\n  v6 = a3;\n  if ( (*a2 & 0xF) == 9 )\n  {\n    v17 = sub_804DB46(a3);\n    v7 = sub_804D76F(v17, v6, 255);\n    if ( *(_DWORD *)dword_80DBB7C )\n      sub_804D5E0(\"malformed hex string '%s'\", v6);\n    ptr = (void *)(v7 - v17);\n  }\n  else\n  {\n    v17 = 0;\n  }\n  v8 = sub_806BB3E(*a1, a2[1]);\n  v9 = v8;\n  if ( v8 )\n  {\n    if ( (*a2 & 0x20) != 0 )\n    {\n      v14 = *v8;\n      v15 = v14[1];\n      if ( (unsigned int)ptr + v15 <= 0xFE )\n      {\n        v16 = (unsigned __int8 *)sub_804DB13(v14, (size_t)ptr + v15 + 3);\n        *v9 = v16;\n        if ( (*a2 & 0xFu) - 3 <= 1 )\n          v16[v15++ + 2] = 32;\n        if ( v17 )\n          v6 = v17;\n        qmemcpy(&(*v9)[v15 + 2], v6, (unsigned int)ptr);\n        (*v9)[1] = (_BYTE)ptr + v15;\n      }\n    }\n  }\n  else\n  {\n    v10 = (unsigned __int8 **)sub_804DAFA(8u);\n    v11 = (unsigned __int8 *)sub_804DAFA((size_t)ptr + 2);\n    *v10 = v11;\n    v12 = a2[1];\n    *v11 = v12;\n    v11[1] = (unsigned __int8)ptr;\n    if ( v17 )\n      v6 = v17;\n    qmemcpy(v11 + 2, v6, (unsigned int)ptr);\n    while ( 1 )\n    {\n      v13 = *a1;\n      if ( !*a1 || v12 <= **v13 )\n        break;\n      a1 = (unsigned __int8 ***)(v13 + 1);\n    }\n    v10[1] = (unsigned __int8 *)v13;\n    *a1 = v10;\n  }\n  free(v17);\n}\n"
    ],
    "sub_806BC85": [
        "0x806bc85",
        "int __fastcall sub_806BC85(int a1, _DWORD *a2)\n{\n  _DWORD *v3; // eax\n\n  v3 = (_DWORD *)sub_80B459A(2, 0);\n  if ( !v3 )\n    return 0;\n  *a2 = v3[2];\n  free(v3);\n  return 1;\n}\n"
    ],
    "sub_806BCAF": [
        "0x806bcaf",
        "int __userpurge sub_806BCAF@<eax>(char *a1@<eax>, unsigned __int8 ***a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  char *v5; // eax\n  const char *v6; // ebx\n  unsigned int v7; // eax\n  char *v8; // edi\n  int v9; // esi\n  char *v10; // ebx\n  int v11; // ecx\n  unsigned __int8 v12; // al\n  int v13; // ebp\n  unsigned __int32 *v14; // edx\n  int v15; // ebx\n  int v16; // edx\n  const char *v17; // eax\n  __int16 v18; // ax\n  char v19; // t0\n  int v20; // eax\n  int v21; // eax\n  char *v22; // eax\n  int v23; // ecx\n  char *v24; // ebp\n  int v25; // esi\n  unsigned int v26; // ebx\n  char *v27; // eax\n  unsigned int v28; // ebx\n  int v30; // [esp-8h] [ebp-2Ch]\n  int v31; // [esp-4h] [ebp-28h]\n  char v33[2]; // [esp+6h] [ebp-1Eh] BYREF\n  unsigned __int32 v34; // [esp+8h] [ebp-1Ch] BYREF\n  char v35; // [esp+Ch] [ebp-18h] BYREF\n\n  v5 = strtok(a1, \" \\t=:\");\n  if ( !v5 )\n    return 0;\n  v6 = v5;\n  v7 = sub_804ED6C(0, v5, 0, (int)v5);\n  if ( *(_DWORD *)dword_80DBB7C || v7 > 0xFE )\n  {\n    v8 = (char *)(2 * sub_806B974(v6, a4) + a3);\n  }\n  else\n  {\n    v33[0] = 9;\n    v33[1] = v7;\n    v8 = v33;\n  }\n  v9 = 0;\n  while ( 2 )\n  {\n    if ( *v8 == 9 )\n    {\n      v10 = strtok(0, &data);\n      sub_80B2F61();\n    }\n    else\n    {\n      v10 = strtok(0, \", \\t\");\n    }\n    v11 = v30;\n    if ( v10 )\n    {\n      v12 = *v8 & 0xF;\n      v13 = (unsigned __int8)byte_80CFCF3[v12];\n      switch ( v12 )\n      {\n        case 1u:\n          v14 = &v34;\n          goto LABEL_35;\n        case 2u:\n          v15 = sub_806BC85(v30, &v34);\n          if ( !strtok(0, \", \\t/-\") || !v15 )\n            return 0;\n          v14 = (unsigned __int32 *)&v35;\n          goto LABEL_35;\n        case 3u:\n        case 4u:\n          goto LABEL_19;\n        case 5u:\n          LOBYTE(v34) = sub_804ED6C(0, v10, 0, (int)v10);\n          goto LABEL_26;\n        case 6u:\n          v18 = sub_804ED6C(0, v10, 0, (int)v10);\n          v19 = HIBYTE(v18);\n          HIBYTE(v18) = v18;\n          LOBYTE(v18) = v19;\n          LOWORD(v34) = v18;\n          goto LABEL_26;\n        case 7u:\n          v20 = sub_804ED6C(0, v10, 0, (int)v10);\n          goto LABEL_25;\n        case 8u:\n          v20 = sub_804EDC5(0, v10, 0, (int)v10);\nLABEL_25:\n          v34 = _byteswap_ulong(v20);\nLABEL_26:\n          v21 = *(_DWORD *)dword_80DBB7C == 0;\n          goto LABEL_27;\n        case 9u:\n          v16 = (unsigned __int8)*v10;\n          if ( (_BYTE)v16 == 34 || (_BYTE)v16 == 39 )\n          {\n            v17 = sub_804D378(v10 + 1, v16);\n            if ( v17 )\n            {\n              *v17 = 0;\n              v33[0] = 3;\n              ++v10;\nLABEL_19:\n              v13 = strnlen();\n              if ( v13 <= 0 )\n                return 0;\n            }\n          }\n          v9 = 1;\n          goto LABEL_38;\n        case 0xAu:\n          v22 = strchr(v10, 47);\n          v24 = v22;\n          if ( !v22 )\n            return 0;\n          *v22 = 0;\n          v25 = sub_806BC85(v23, (unsigned __int32 *)((char *)&v34 + 1));\n          v26 = sub_804ED6C(10, v24 + 1, 0, (int)v10);\n          LOBYTE(v34) = v26;\n          v27 = strtok(0, \", \\t/-\");\n          v11 = v31;\n          if ( v26 > 0x20 || !v27 || *(_DWORD *)dword_80DBB7C || !v25 )\n            return 0;\n          v28 = (v26 + 7) >> 3;\n          v13 = v28 + 5;\n          v14 = (unsigned __int32 *)((char *)&v34 + v28 + 1);\nLABEL_35:\n          v21 = sub_806BC85(v11, v14);\nLABEL_27:\n          v9 = v21;\n          if ( !v21 )\n            return 0;\n          v10 = (char *)&v34;\nLABEL_38:\n          sub_806BB5A(a2, v8, v10, (void *)v13);\n          if ( (*v8 & 0x20) == 0 )\n            return v9;\n          continue;\n        default:\n          return 0;\n      }\n    }\n    return v9;\n  }\n}\n"
    ],
    "sub_806BEF4": [
        "0x806bef4",
        "int __usercall sub_806BEF4@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char v4[4]; // [esp+0h] [ebp-28h] BYREF\n  char v5[4]; // [esp+4h] [ebp-24h] BYREF\n  char v6[4]; // [esp+8h] [ebp-20h] BYREF\n  char v7[4]; // [esp+Ch] [ebp-1Ch] BYREF\n  char v8[4]; // [esp+10h] [ebp-18h] BYREF\n  char v9[4]; // [esp+14h] [ebp-14h] BYREF\n  char v10[4]; // [esp+18h] [ebp-10h] BYREF\n  char v11[12]; // [esp+1Ch] [ebp-Ch] BYREF\n\n  sub_804D727((int)v4, a2, 16);\n  return sprintf(a1, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v4, v5, v6, v7, v8, v9, v10, v11);\n}\n"
    ],
    "sub_806BF3E": [
        "0x806bf3e",
        "int sub_806BF3E()\n{\n  FILE *v0; // ebx\n  int v2; // [esp+0h] [ebp-48h] BYREF\n  char s[68]; // [esp+4h] [ebp-44h] BYREF\n\n  v2 = 0;\n  v0 = (FILE *)sub_80B3D45();\n  while ( fgets_unlocked() && sscanf(s, \"Cached: %lu %*s\\n\", &v2) != 1 )\n    ;\n  fclose(v0);\n  return v2;\n}\n"
    ],
    "sub_806BF8C": [
        "0x806bf8c",
        "int __cdecl sub_806BF8C(int a1, int a2)\n{\n  _BYTE *v2; // eax\n  unsigned __int8 v3; // al\n  char v4; // cl\n  unsigned int mem_unit; // ebx\n  int v6; // eax\n  char v8; // [esp+0h] [ebp-5Ch]\n  unsigned int v9; // [esp+0h] [ebp-5Ch]\n  char v10; // [esp+Bh] [ebp-51h]\n  struct sysinfo v11; // [esp+Ch] [ebp-50h] BYREF\n\n  v2 = *(_BYTE **)(a2 + 4);\n  if ( !v2 || *v2 != 45 )\n    goto LABEL_12;\n  v3 = v2[1];\n  if ( v3 == 103 )\n  {\n    v4 = 30;\n    goto LABEL_13;\n  }\n  if ( v3 <= 0x67u )\n  {\n    if ( v3 == 98 )\n    {\n      v4 = 0;\n      goto LABEL_13;\n    }\nLABEL_11:\n    sub_804CDC2();\n  }\n  if ( v3 != 107 )\n  {\n    if ( v3 != 109 )\n      goto LABEL_11;\n    v4 = 20;\n  }\n  else\n  {\nLABEL_12:\n    v4 = 10;\n  }\nLABEL_13:\n  v8 = v4;\n  printf(\"       %11s%11s%11s%11s%11s%11s\\nMem:   \", \"total\", \"used\", \"free\", \"shared\", \"buffers\", \"cached\");\n  sysinfo(&v11);\n  mem_unit = v11.mem_unit;\n  if ( !v11.mem_unit )\n    mem_unit = 1;\n  v10 = v8;\n  v6 = sub_806BF3E();\n  v9 = sub_80B4B88(v6 << 10, (unsigned __int64)(unsigned int)v6 >> 22, mem_unit, 0);\n  printf(\n    \"%11llu%11llu%11llu%11llu%11llu%11llu\\n\",\n    (v11.totalram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)(v11.totalram - v11.freeram)) >> (v10 & 0x1F),\n    (v11.freeram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (v11.sharedram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (v11.bufferram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)v9) >> (v10 & 0x1F));\n  printf(\"-/+ buffers/cache:\");\n  printf(\n    \"%11llu%11llu\\n\",\n    (mem_unit * (unsigned __int64)(v11.totalram - (v9 + v11.bufferram + v11.freeram))) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)(v9 + v11.bufferram + v11.freeram)) >> (v10 & 0x1F));\n  printf(\"Swap:  \");\n  printf(\n    \"%11llu%11llu%11llu\\n\",\n    (v11.totalswap * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)(v11.totalswap - v11.freeswap)) >> (v10 & 0x1F),\n    (v11.freeswap * (unsigned __int64)mem_unit) >> (v10 & 0x1F));\n  return 0;\n}\n"
    ],
    "sub_806C199": [
        "0x806c199",
        "char __usercall sub_806C199@<al>(_DWORD *a1@<eax>)\n{\n  _DWORD *v1; // edx\n\n  v1 = (_DWORD *)unk_80DB780;\n  if ( !unk_80DB780 )\n    return 0;\n  while ( v1[4] != a1[1] || v1[3] != *a1 || (dword_80DBB9C & 1) == 0 && (v1[2] != a1[23] || v1[1] != a1[22]) )\n  {\n    v1 = (_DWORD *)*v1;\n    if ( !v1 )\n      return 0;\n  }\n  return 1;\n}\n"
    ],
    "sub_806C1E3": [
        "0x806c1e3",
        "_DWORD *__usercall sub_806C1E3@<eax>(_DWORD *result@<eax>)\n{\n  time_t *v1; // edx\n  time_t *v2; // esi\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  int v5; // ecx\n  int v6; // ebx\n\n  v1 = (time_t *)unk_80DB780;\n  v2 = &unk_80DB780;\n  while ( v1 )\n  {\n    if ( v1[4] == result[1] && v1[3] == *result && v1[2] == result[23] && v1[1] == result[22] )\n      return result;\n    v2 = v1;\n    v1 = (time_t *)*v1;\n  }\n  v3 = result;\n  result = sub_804DB2E(0x14u);\n  *v2 = (time_t)result;\n  v4 = v3[1];\n  result[3] = *v3;\n  result[4] = v4;\n  v5 = v3[22];\n  v6 = v3[23];\n  result[1] = v5;\n  result[2] = v6;\n  return result;\n}\n"
    ],
    "sub_806C241": [
        "0x806c241",
        "int __fastcall sub_806C241(int a1, int a2)\n{\n  int v2; // ebp\n  int v3; // ebx\n  int *v4; // esi\n  char *v5; // ebx\n  const char *v6; // edi\n  signed int v7; // eax\n  bool v8; // zf\n  int v9; // eax\n  FILE *stream; // [esp+0h] [ebp-1D0h]\n  int v13; // [esp+8h] [ebp-1C8h] BYREF\n  int v14; // [esp+Ch] [ebp-1C4h] BYREF\n  int v15; // [esp+10h] [ebp-1C0h] BYREF\n  __int64 v16; // [esp+14h] [ebp-1BCh] BYREF\n  char v17[68]; // [esp+1Ch] [ebp-1B4h] BYREF\n  __int64 v18[12]; // [esp+60h] [ebp-170h] BYREF\n  char s[272]; // [esp+C0h] [ebp-110h] BYREF\n\n  stream = (FILE *)sub_80B3D37();\n  v2 = 0;\n  if ( !stream )\n    return v2;\n  if ( qword_80DB778 )\n  {\n    v4 = &v14;\n    v5 = (char *)&v13;\n    v6 = \"%*s %*s %*s %x:%x %llu\";\n  }\n  else\n  {\n    v18[0] = 0LL;\n    v3 = socket(2, 2, 0);\n    if ( v3 >= 0 )\n    {\n      fstat64();\n      close(v3);\n    }\n    v4 = &v15;\n    v5 = v17;\n    v6 = \"%*d: %64[0-9A-Fa-f]:%x %*x:%*x %*x %*x:%*x %*x:%*x %*x %*d %*d %llu\";\n  }\n  while ( fgets_unlocked() )\n  {\n    if ( sscanf(s, v6, v5, v4, &v16) == 3 )\n    {\n      v18[11] = v16;\n      if ( qword_80DB778 )\n      {\n        if ( v13 )\n        {\n          if ( v16 )\n          {\n            if ( v14 )\n            {\n              v18[0] = sub_80B0220();\n              LOBYTE(v9) = sub_806C199(v18);\n              v2 = v9;\n              if ( (_BYTE)v9 )\n                goto LABEL_22;\n            }\n          }\n        }\n      }\n      else\n      {\n        v7 = strlen(v17);\n        if ( v7 == 8 )\n        {\n          v8 = (dword_80DBB9C & 8) == 0;\nLABEL_15:\n          if ( v8 )\n            goto LABEL_16;\n        }\n        else\n        {\n          if ( v7 > 8 )\n          {\n            v8 = (dword_80DBB9C & 0x10) == 0;\n            goto LABEL_15;\n          }\nLABEL_16:\n          if ( v15 == a2 )\n            sub_806C1E3(v18);\n        }\n      }\n    }\n  }\n  v2 = 0;\nLABEL_22:\n  fclose(stream);\n  return v2;\n}\n"
    ],
    "sub_806C3AA": [
        "0x806c3aa",
        "int __usercall sub_806C3AA@<eax>(const char *a1@<eax>)\n{\n  DIR *v1; // eax\n  int v2; // esi\n  DIR *v3; // ebp\n  int v4; // eax\n  const char *v5; // ebx\n  void *v6; // edi\n  int v7; // edx\n  int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  int v11; // edx\n  __pid_t pid; // [esp+4h] [ebp-74h]\n  char pida; // [esp+4h] [ebp-74h]\n  int v15[28]; // [esp+8h] [ebp-70h] BYREF\n\n  v1 = opendir(a1);\n  v2 = 0;\n  if ( v1 )\n  {\n    v3 = v1;\n    ++qword_80DB778;\n    v2 = 0;\n    while ( 1 )\n    {\n      do\n      {\n        v4 = readdir64();\n        if ( !v4 )\n        {\nLABEL_26:\n          closedir(v3);\n          --qword_80DB778;\n          return v2;\n        }\n        v5 = (const char *)(v4 + 19);\n        v6 = (void *)sub_80A9BF5();\n      }\n      while ( !v6 );\n      switch ( qword_80DB778 )\n      {\n        case 2:\n          v9 = sub_804D254(\"cwd\", v5);\n          LOBYTE(v8) = 0;\n          switch ( v9 )\n          {\n            case 0:\n            case 1:\n            case 2:\n              goto LABEL_19;\n            case 3:\n            case 4:\n            case 5:\n              v8 = sub_806C3AA();\n              goto LABEL_21;\n            case 6:\n              v8 = sub_806C241(v10, 0);\n              goto LABEL_21;\n            default:\n              goto LABEL_25;\n          }\n          goto LABEL_25;\n        case 3:\nLABEL_19:\n          v11 = stat64();\n          LOBYTE(v8) = 0;\n          if ( v11 >= 0 )\n          {\n            LOBYTE(v8) = sub_806C199(v15);\nLABEL_21:\n            if ( (_BYTE)v8 )\n              v2 = v8;\n          }\n          goto LABEL_25;\n        case 1:\n          v7 = sub_804ED6C(10, v5, 0, (int)v5);\n          LOBYTE(v8) = 0;\n          if ( *(_DWORD *)dword_80DBB7C )\n            goto LABEL_25;\n          if ( *(&qword_80DB778 + 1) == v7 )\n            goto LABEL_25;\n          pid = v7;\n          LOBYTE(v8) = sub_806C3AA();\n          if ( !(_BYTE)v8 )\n            goto LABEL_25;\n          if ( (dword_80DBB9C & 2) != 0 && kill(pid, (int)MEMORY[0x80DB788]) )\n          {\n            sub_804D3A5((int)\"kill pid %s\", v5);\n            *((_BYTE *)&unk_80DB780 + 4) = 1;\n          }\n          if ( (dword_80DBB9C & 4) == 0 )\n            printf(\"%s \", v5);\n          v2 = 1;\n          break;\n      }\n      LOBYTE(v8) = 0;\nLABEL_25:\n      pida = v8;\n      free(v6);\n      if ( pida )\n        goto LABEL_26;\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_806C525": [
        "0x806c525",
        "int __cdecl sub_806C525(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  char v4; // dl\n  const char **i; // ebx\n  char *v6; // eax\n  int v7; // eax\n  const char *v8; // edi\n  char v9; // al\n  int v10; // edx\n  int v12; // [esp-4h] [ebp-84h]\n  int v13; // [esp+0h] [ebp-80h] BYREF\n  char dest[15]; // [esp+5h] [ebp-7Bh] BYREF\n  int v15[27]; // [esp+14h] [ebp-6Ch] BYREF\n\n  *(&qword_80DB778 + 1) = getpid();\n  MEMORY[0x80DB788] = (char *)9;\n  v2 = a2;\n  while ( 1 )\n  {\n    v2 += 4;\n    v3 = *(_BYTE **)v2;\n    if ( !*(_DWORD *)v2 )\n      break;\n    if ( *v3 == 45 )\n    {\n      v4 = v3[1];\n      if ( v4 == 45 )\n      {\n        if ( !v3[2] )\n          break;\n        goto LABEL_9;\n      }\n      if ( (v4 & 0xFD) != 52 || v3[2] )\n      {\nLABEL_9:\n        v6 = (char *)sub_80B2FB5();\n        if ( (int)v6 >= 0 )\n        {\n          MEMORY[0x80DB788] = v6;\n          do\n          {\n            v7 = *(_DWORD *)(v2 + 4);\n            *(_DWORD *)v2 = v7;\n            v2 += 4;\n          }\n          while ( v7 );\n          break;\n        }\n      }\n    }\n  }\n  sub_80ABEAC(a2, \"^mks64\");\n  for ( i = (const char **)(a2 + 4 * optind); ; ++i )\n  {\n    v8 = *i;\n    if ( !*i )\n      break;\n    strcpy(dest, \"/proc/net/\");\n    if ( sscanf(v8, \"%u/%4s\", &v13, &dest[10]) != 2 || access(dest, 4) )\n    {\n      sub_804DFF3(*i);\n      sub_806C1E3(v15);\n    }\n    else\n    {\n      sub_806C241(v12, v13);\n    }\n  }\n  v9 = sub_806C3AA(\"/proc\");\n  v10 = 1;\n  if ( v9 )\n  {\n    if ( (dword_80DBB9C & 4) == 0 )\n      sub_804DD98(10);\n    return *((char *)&unk_80DB780 + 4);\n  }\n  return v10;\n}\n"
    ],
    "sub_806C641": [
        "0x806c641",
        "int __cdecl sub_806C641(int a1, int a2)\n{\n  const char *v2; // ebx\n  char v3; // bl\n  char **v4; // ebp\n  char *v5; // esi\n  char v6; // al\n  int *v7; // esi\n  int v8; // ebx\n  const char *v9; // eax\n  int v10; // eax\n  int v11; // edi\n  char *v12; // ecx\n  char v13; // al\n  char *v14; // edx\n  int v15; // eax\n  int v16; // edi\n  int v17; // eax\n  int v18; // eax\n  char **v19; // edx\n  char *v20; // eax\n  char *v21; // esi\n  int v22; // eax\n  bool v23; // zf\n  __pid_t *i; // esi\n  __pid_t v25; // eax\n  int v26; // edi\n  int sig; // [esp+0h] [ebp-28h]\n  char *v29; // [esp+4h] [ebp-24h]\n  __pid_t v30; // [esp+4h] [ebp-24h]\n  __pid_t *ptr; // [esp+8h] [ebp-20h]\n  char **v32; // [esp+Ch] [ebp-1Ch]\n  int v33; // [esp+10h] [ebp-18h]\n  char *v34; // [esp+14h] [ebp-14h] BYREF\n\n  v2 = *(const char **)a2;\n  v3 = v2[strlen(*(const char **)a2) - 3];\n  v4 = (char **)(a2 + 4);\n  v5 = *(char **)(a2 + 4);\n  if ( v5 && *v5 == 45 )\n  {\n    v6 = v5[1];\n    if ( v6 == 108 && !v5[2] )\n    {\n      v7 = (int *)(a2 + 8);\n      v8 = *(_DWORD *)(a2 + 8);\n      if ( v8 )\n      {\n        while ( 1 )\n        {\n          if ( (unsigned __int8)(*(_BYTE *)v8 - 48) <= 9u )\n          {\n            sub_804ED6C(10, (const char *)v8, 0, v8);\n            if ( *(_DWORD *)dword_80DBB7C )\n              goto LABEL_12;\n            v9 = (const char *)sub_80B30D9();\n            puts(v9);\n          }\n          else\n          {\n            v10 = sub_80B2FB5();\n            if ( v10 < 0 )\n            {\nLABEL_12:\n              sub_804D5F4(\"unknown signal '%s'\", v8);\n              return 1;\n            }\n            printf(\"%d\\n\", v10);\n          }\n          v8 = *++v7;\n          if ( !*v7 )\n            return v8;\n        }\n      }\n      sub_80B30F8();\n      return v8;\n    }\n    if ( v3 == 97 && v6 == 113 && !v5[2] )\n    {\n      v4 = (char **)(a2 + 8);\n      v5 = *(char **)(a2 + 8);\n      if ( !v5 )\n        sub_804CDC2();\n      v11 = 1;\n      if ( *v5 != 45 )\n        goto LABEL_37;\n    }\n    else\n    {\n      v11 = 0;\n    }\n    v12 = v5 + 1;\n    v13 = v5[1];\n    if ( v3 != 108 )\n    {\n      if ( v13 == 45 && !v5[2] )\n      {\n        sig = 15;\nLABEL_34:\n        v5 = v4[1];\n        ++v4;\n        goto LABEL_38;\n      }\nLABEL_27:\n      v14 = v4[1];\n      if ( v14 && v13 == 115 && !v5[2] )\n      {\n        ++v4;\n        v12 = v14;\n      }\n      v29 = v12;\n      sig = sub_80B2FB5();\n      if ( sig < 0 )\n      {\n        sub_804D5F4(\"bad signal name '%s'\", v29);\n        return 1;\n      }\n      goto LABEL_34;\n    }\n    if ( v13 != 111 )\n      goto LABEL_27;\n    ++v5;\n  }\n  else\n  {\n    v11 = 0;\n  }\nLABEL_37:\n  sig = 15;\nLABEL_38:\n  v30 = getpid();\n  if ( v3 != 108 )\n  {\n    if ( !v5 )\n    {\n      sub_804D5F4(\"you need to specify whom to kill\");\n      return 1;\n    }\n    v23 = v3 == 97;\n    v8 = 0;\n    if ( v23 )\n    {\n      do\n      {\n        ptr = (__pid_t *)sub_80AB493();\n        if ( *ptr )\n        {\n          for ( i = ptr; ; ++i )\n          {\n            v25 = *i;\n            if ( !*i )\n              break;\n            if ( v25 != v30 )\n            {\n              if ( kill(v25, sig) )\n              {\n                ++v8;\n                if ( !v11 )\n                  sub_804D3A5((int)\"can't kill pid %d\", *i);\n              }\n            }\n          }\n        }\n        else\n        {\n          ++v8;\n          if ( !v11 )\n            sub_804D5F4(\"%s: no process killed\", v5);\n        }\n        free(ptr);\n        v5 = *++v4;\n      }\n      while ( *v4 );\n      return v8;\n    }\n    while ( 1 )\n    {\n      if ( !*v5 )\n        goto LABEL_89;\n      if ( *v5 == 32 )\n        ++v5;\n      v26 = sub_804EDC5(10, v5, &v34, v8);\n      if ( !*(_DWORD *)dword_80DBB7C || *(_DWORD *)dword_80DBB7C == 22 && *v34 == 32 )\n      {\n        if ( kill(v26, sig) )\n        {\n          sub_804D3A5((int)\"can't kill pid %d\", v26);\n          ++v8;\n        }\n        v5 = v34;\n      }\n      else\n      {\n        sub_804D5F4(\"invalid number '%s'\", v5);\n        ++v8;\nLABEL_89:\n        v5 = *++v4;\n        if ( !*v4 )\n          return v8;\n      }\n    }\n  }\n  v33 = getsid();\n  if ( (unsigned int)(sig - 18) > 1 )\n    kill(-1, 19);\n  v8 = 2;\nLABEL_42:\n  while ( 1 )\n  {\n    v15 = sub_80B0EC0();\n    v16 = v15;\n    if ( !v15 )\n      break;\n    v17 = *(_DWORD *)(v15 + 48);\n    if ( v17 )\n    {\n      if ( v33 != v17 )\n      {\n        v18 = *(_DWORD *)(v16 + 36);\n        if ( v30 != v18 )\n        {\n          v19 = v4;\n          if ( v18 != 1 )\n          {\n            while ( 1 )\n            {\n              v20 = *v19;\n              if ( !*v19 )\n                break;\n              v32 = v19 + 1;\n              if ( *v20 != 45 || v20[1] != 111 )\n              {\n                sub_804D5F4(\"bad option '%s'\");\nLABEL_56:\n                v8 = 1;\n                goto LABEL_60;\n              }\n              v21 = v20 + 2;\n              if ( !v20[2] && v19[1] )\n              {\n                v32 = v19 + 2;\n                v21 = v19[1];\n              }\n              v22 = sub_804EDC5(10, v21, 0, v8);\n              if ( *(_DWORD *)dword_80DBB7C )\n              {\n                sub_804D5F4(\"invalid number '%s'\");\n                goto LABEL_56;\n              }\n              if ( *(_DWORD *)(v16 + 36) == v22 )\n                goto LABEL_42;\n              v19 = v32;\n            }\n            kill(*(_DWORD *)(v16 + 36), sig);\n            v8 = 0;\n          }\n        }\n      }\n    }\n  }\nLABEL_60:\n  if ( (unsigned int)(sig - 18) > 1 )\n    kill(-1, 18);\n  return v8;\n}\n"
    ],
    "sub_806C9BE": [
        "0x806c9be",
        "int __fastcall sub_806C9BE(int a1)\n{\n  int v1; // ebx\n  DIR *v2; // esi\n  int v3; // eax\n  const char *v4; // eax\n  char *v5; // ebp\n  char s[51]; // [esp+1h] [ebp-33h] BYREF\n\n  while ( 1 )\n  {\n    v1 = sub_80B0EC0(a1, 257);\n    if ( !v1 )\n      break;\n    if ( getpid() != *(_DWORD *)(v1 + 36) )\n    {\n      sprintf(s, \"/proc/%u/fd/\", *(_DWORD *)(v1 + 36));\n      v2 = opendir(s);\n      if ( v2 )\n      {\n        while ( 1 )\n        {\n          v3 = readdir64();\n          if ( !v3 )\n            break;\n          if ( *(_BYTE *)(v3 + 19) != 46 )\n          {\n            sub_80B2C4E(10, v3 + 19);\n            v4 = (const char *)sub_804E190(s);\n            v5 = (char *)v4;\n            if ( v4 )\n            {\n              printf(\"%d\\t%s\\t%s\\n\", *(_DWORD *)(v1 + 36), *(const char **)(v1 + 12), v4);\n              free(v5);\n            }\n          }\n        }\n        closedir(v2);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_806CA6F": [
        "0x806ca6f",
        "int __cdecl sub_806CA6F(int a1, int a2)\n{\n  int v2; // ebx\n  unsigned int v3; // eax\n  _DWORD *v4; // esi\n  int v5; // ebx\n  _DWORD *v6; // ebp\n  _DWORD *i; // edi\n  int j; // ecx\n  char v10; // [esp+0h] [ebp-1Ch]\n  int *v11; // [esp+4h] [ebp-18h]\n  int v12[5]; // [esp+8h] [ebp-14h] BYREF\n\n  v12[0] = 0;\n  v10 = sub_80ABEAC(a2, \"so:*\", v12);\n  while ( 1 )\n  {\n    v2 = sub_80AFB6A();\n    if ( !v2 )\n      break;\n    v3 = getppid();\n    *(_DWORD *)(v2 + 4) = sub_804D6F7(v3);\n  }\n  v4 = (_DWORD *)(a2 + 4 * optind);\n  v5 = 1;\n  while ( *v4 )\n  {\n    sub_80AB493();\n    v6 = (_DWORD *)sub_80AB572();\n    for ( i = v6; *i; ++i )\n    {\n      if ( (v10 & 2) != 0 )\n      {\n        for ( j = v12[0]; j; j = *v11 )\n        {\n          v11 = (int *)j;\n          if ( sub_80B40EC() == *i )\n            goto LABEL_15;\n        }\n      }\n      printf((const char *)(v5 + 135085724), *i);\n      v5 = v10 & 1;\n      if ( (v10 & 1) != 0 )\n      {\n        v5 = 0;\n        break;\n      }\nLABEL_15:\n      ;\n    }\n    free(v6);\n    ++v4;\n  }\n  if ( !v5 )\n    sub_804DD98(10);\n  return v5;\n}\n"
    ],
    "sub_806CB4F": [
        "0x806cb4f",
        "int sub_806CB4F()\n{\n  int v0; // edx\n\n  qword_80DB778 = sub_80B4733(*(&qword_80DB778 + 1), 5122);\n  v0 = (*(&qword_80DB778 + 1))++;\n  return 20 * v0 + qword_80DB778;\n}\n"
    ],
    "sub_806CBF2": [
        "0x806cbf2",
        "char *__usercall sub_806CBF2@<eax>(const char *a1@<eax>)\n{\n  int v2; // ebx\n  char *v3; // esi\n  char s[101]; // [esp+7h] [ebp-65h] BYREF\n\n  v2 = 0;\n  v3 = s;\n  while ( strncmp(a1, &MEMORY[0x80B5C42][v2], 6u) )\n  {\n    v3 += sprintf(v3, \"%.6s,\", &MEMORY[0x80B5C42][v2]);\n    v2 += 20;\n    if ( v2 == 240 )\n    {\n      *(v3 - 1) = 0;\n      sub_804D5E0(\"bad -o argument '%s', supported arguments: %s\", a1, s);\n    }\n  }\n  return (char *)&unk_80B5C40 + v2;\n}\n"
    ],
    "sub_806CC5A": [
        "0x806cc5a",
        "char *__usercall sub_806CC5A@<eax>(const char *a1@<eax>)\n{\n  char *v2; // ebp\n  char *v3; // eax\n  char *v4; // ebx\n  char *v5; // esi\n  _DWORD *v6; // ebp\n  char *result; // eax\n\n  while ( 1 )\n  {\n    v2 = strchr(a1, 44);\n    v3 = strchr(a1, 61);\n    v4 = v3;\n    if ( !v2 || v2 >= v3 && v3 )\n      break;\n    *v2 = 0;\n    v5 = sub_806CBF2(a1);\n    qmemcpy((void *)sub_806CB4F(), v5, 0x14u);\n    *v2 = 44;\n    a1 = v2 + 1;\n  }\n  v6 = (_DWORD *)sub_806CB4F();\n  if ( v4 )\n    *v4 = 0;\n  result = sub_806CBF2(a1);\n  qmemcpy(v6, result, 0x14u);\n  if ( v4 )\n  {\n    *v4 = 61;\n    result = v4 + 1;\n    v6[2] = v4 + 1;\n    if ( !v4[1] )\n      return result;\n    result = (char *)strlen(v4 + 1);\n    *(_WORD *)v6 = (_WORD)result;\n  }\n  unk_80DB780 = 1;\n  return result;\n}\n"
    ],
    "sub_806CDEB": [
        "0x806cdeb",
        "int __cdecl sub_806CDEB(int a1, int a2)\n{\n  int v2; // eax\n\n  v2 = sub_80B0E79();\n  return sub_80B2C4E(a2 + 1, v2);\n}\n"
    ],
    "sub_806CE0F": [
        "0x806ce0f",
        "int __cdecl sub_806CE0F(int a1, int a2)\n{\n  const char *v2; // eax\n  int v3; // edx\n  int v4; // eax\n  int v5; // edx\n  unsigned __int16 *v6; // ecx\n  int v7; // ecx\n  char *v8; // ebx\n  int v9; // esi\n  const char **v10; // eax\n  int v11; // esi\n  char *v12; // ebx\n  int v13; // edi\n  size_t v14; // eax\n  char *v15; // ebx\n  int v16; // eax\n  int v18; // [esp+0h] [ebp-24h] BYREF\n  char dest[30]; // [esp+6h] [ebp-1Eh] BYREF\n\n  v18 = 0;\n  sub_80ABEAC(a2, \"Zo:*aAdefl\", &v18);\n  if ( v18 )\n  {\n    do\n    {\n      v2 = (const char *)sub_80AFB01(v18);\n      sub_806CC5A(v2);\n    }\n    while ( v18 );\n  }\n  else\n  {\n    strcpy(dest, \"pid,user,args\");\n    sub_806CC5A(dest);\n  }\n  unk_80DB78C = (char *)2048;\n  if ( isatty(1) )\n  {\n    unk_80DB78C = (char *)(sub_804D986(0, v3) - 1);\n    if ( (unsigned int)unk_80DB78C > 0x800 )\n      unk_80DB78C = (char *)2048;\n  }\n  v4 = 0;\n  v5 = 0;\n  while ( v5 < *(&qword_80DB778 + 1) )\n  {\n    v6 = (unsigned __int16 *)(qword_80DB778 + 20 * v5);\n    *(&unk_80DB780 + 1) |= *((_DWORD *)v6 + 4);\n    if ( **((_BYTE **)v6 + 2) )\n      unk_80DB780 = 1;\n    v4 += *v6 + 1;\n    ++v5;\n    if ( v4 - (int)unk_80DB78C > 0 )\n    {\n      *(&qword_80DB778 + 1) = v5;\n      break;\n    }\n  }\n  v8 = (char *)sub_804DAFA(v4 + 1);\n  MEMORY[0x80DB788] = v8;\n  if ( !unk_80DB780 )\n    goto LABEL_21;\n  if ( *(&qword_80DB778 + 1) )\n  {\n    v9 = 0;\n    while ( 1 )\n    {\n      v10 = (const char **)(qword_80DB778 + 20 * v9++);\n      if ( v9 == *(&qword_80DB778 + 1) )\n        break;\n      v8 += sprintf(v8, \"%-*s \", *(unsigned __int16 *)v10, v10[2]);\n    }\n    strcpy(v8, v10[2]);\n  }\n  while ( 1 )\n  {\n    printf(\"%.*s\\n\", (int)unk_80DB78C, MEMORY[0x80DB788]);\nLABEL_21:\n    v11 = sub_80B0EC0(v7, *(&unk_80DB780 + 1));\n    if ( !v11 )\n      break;\n    v12 = MEMORY[0x80DB788];\n    if ( *(&qword_80DB778 + 1) )\n    {\n      v13 = 0;\n      while ( 1 )\n      {\n        (*(void (__cdecl **)(char *, _DWORD, int))(20 * v13 + qword_80DB778 + 12))(\n          v12,\n          *(unsigned __int16 *)(20 * v13 + qword_80DB778),\n          v11);\n        if ( !*v12 )\n          *(_WORD *)v12 = 45;\n        v14 = strlen(v12);\n        v15 = &v12[v14];\n        v16 = *(unsigned __int16 *)(qword_80DB778 + 20 * v13++) - v14 + 1;\n        if ( v13 == *(&qword_80DB778 + 1) )\n          break;\n        v12 = &v15[sprintf(v15, \"%*s\", v16, &data)];\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_806D001": [
        "0x806d001",
        "int __usercall sub_806D001@<eax>(const char *a1@<eax>, int a2@<ebx>)\n{\n  int v3; // edi\n  char *v4; // eax\n  char *v5; // ebx\n  char *v6; // eax\n  int v7; // esi\n  char v8; // dl\n  const char *v9; // edi\n  int v10; // ecx\n  int v11; // esi\n  int v12; // esi\n  const char *v13; // eax\n  char *v14; // edi\n  char *v15; // esi\n  char v16; // dl\n  char *IO_write_base; // ecx\n  char v20; // [esp+1h] [ebp-11h]\n  char v21; // [esp+1h] [ebp-11h]\n\n  v3 = dword_80DBB9C & 0x20;\n  v4 = sub_804DB46(a1);\n  v5 = v4;\n  while ( *v4 )\n  {\n    if ( *v4 == 47 )\n      *v4 = 46;\n    ++v4;\n  }\n  v6 = strchr(a1, 61);\n  if ( !v6 )\n  {\n    if ( !v3 )\n    {\n      v7 = open64();\n      v8 = 0;\n      if ( v7 >= 0 )\n      {\n        v14 = (char *)sub_80B2402(a2);\n        close(v7);\n        if ( v14 )\n        {\n          v15 = v14;\n          while ( 1 )\n          {\n            v16 = *v15;\n            if ( !*v15 )\n              break;\n            if ( (dword_80DBB9C & 1) != 0 )\n            {\n              v20 = *v15;\n              printf(\"%s = \", v5);\n              v16 = v20;\n            }\n            do\n            {\n              IO_write_base = stdout->_IO_write_base;\n              if ( IO_write_base >= stdout->_IO_buf_base )\n              {\n                v21 = v16;\n                __fputc_unlocked();\n                v16 = v21;\n              }\n              else\n              {\n                stdout->_IO_write_base = IO_write_base + 1;\n                *IO_write_base = v16;\n              }\n              ++v15;\n              if ( v16 == 10 )\n                break;\n              v16 = *v15;\n            }\n            while ( *v15 );\n          }\n          free(v14);\n        }\n        else\n        {\n          sub_804D3A5((int)\"error reading key '%s'\", v5);\n        }\nLABEL_35:\n        v12 = 0;\n        goto LABEL_43;\n      }\n      goto LABEL_14;\n    }\n    sub_804D5F4(\"error: '%s' must be of the form name=value\", v5);\nLABEL_37:\n    v12 = 1;\n    goto LABEL_43;\n  }\n  v9 = v6 + 1;\n  if ( a1 == v6 || !v6[1] )\n  {\n    sub_804D5F4(\"error: malformed setting '%s'\", v5);\n    goto LABEL_37;\n  }\n  *v6 = 0;\n  v5[v6 - a1] = 0;\n  v11 = open64();\n  if ( v11 >= 0 )\n  {\n    sub_804DCD4(v10, v9);\n    close(v11);\n    v12 = 0;\n    if ( (dword_80DBB9C & 0x40) != 0 )\n      goto LABEL_43;\n    if ( (dword_80DBB9C & 1) != 0 )\n      printf(\"%s = \", v5);\n    puts(v9);\n    goto LABEL_35;\n  }\n  v8 = 1;\nLABEL_14:\n  if ( *(_DWORD *)dword_80DBB7C == 2 )\n  {\n    v12 = 1;\n    if ( (dword_80DBB9C & 2) != 0 )\n      sub_804D5F4(\"error: '%s' is an unknown key\", v5);\n  }\n  else\n  {\n    v12 = 0;\n    if ( *(_DWORD *)dword_80DBB7C != 13 )\n    {\n      v13 = \"I2C block read\" + 10;\n      if ( v8 )\n        v13 = \"sett\";\n      sub_804D3A5((int)\"error %sing key '%s'\", v13, v5);\n      goto LABEL_37;\n    }\n  }\nLABEL_43:\n  free(v5);\n  return v12;\n}\n"
    ],
    "sub_806D1DF": [
        "0x806d1df",
        "size_t __usercall sub_806D1DF@<eax>(const char *a1@<eax>)\n{\n  size_t result; // eax\n  const char *v3; // esi\n  const char *v4; // ebp\n  char *i; // ebx\n\n  result = strlen(a1);\n  v3 = &a1[result];\n  v4 = a1 - 1;\n  a1[result] = 46;\nLABEL_2:\n  for ( i = (char *)v3; i > v4; --i )\n  {\n    if ( *i == 46 )\n    {\n      *i = 0;\n      result = access(a1, 0);\n      if ( !result )\n      {\n        *i = 47;\n        v4 = i;\n        goto LABEL_2;\n      }\n      *i = 46;\n    }\n  }\n  *v3 = 0;\n  return result;\n}\n"
    ],
    "sub_806D226": [
        "0x806d226",
        "int __usercall sub_806D226@<eax>(const char *a1@<eax>)\n{\n  DIR *v2; // ebp\n  int v3; // esi\n  int v4; // eax\n  void *v5; // ebx\n  char *v6; // ebx\n  __int16 v8; // [esp+10h] [ebp-60h]\n\n  stat64();\n  if ( (v8 & 0xF000) != 0x4000 || (dword_80DBB9C & 0x20) != 0 )\n  {\n    v6 = sub_804DB46(a1);\n    v3 = sub_806D001(v6, (int)v6);\n    free(v6);\n  }\n  else\n  {\n    v2 = opendir(a1);\n    v3 = -1;\n    if ( v2 )\n    {\n      v3 = 0;\n      while ( readdir64() )\n      {\n        v4 = sub_80A9BF5();\n        v5 = (void *)v4;\n        if ( v4 )\n        {\n          v3 |= sub_806D226();\n          free(v5);\n        }\n      }\n      closedir(v2);\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_806D2C5": [
        "0x806d2c5",
        "int __cdecl sub_806D2C5(int a1, int a2)\n{\n  int v2; // eax\n  const char **v3; // esi\n  int v4; // eax\n  char v5; // bl\n  int v6; // edi\n  int v7; // ebx\n  _BYTE *v8; // ebx\n  int v9; // ecx\n  const char *v11; // [esp+4h] [ebp-18h]\n\n  v2 = sub_80ABEAC(a2, \"+neAapwq\");\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = v2 ^ 3;\n  v5 = v4;\n  dword_80DBB9C = v4;\n  if ( (v4 & 0x10) != 0 )\n  {\n    dword_80DBB9C = v4 | 0x20;\n    if ( !*v3 )\n      *--v3 = \"/etc/sysctl.conf\";\n    v6 = sub_804DBE1(\".\");\n    do\n    {\n      sub_80B052C();\n      sub_804DF04(\"/proc/sys\");\n      while ( 1 )\n      {\n        v7 = sub_80B0560(\";#=\");\n        if ( !v7 )\n          break;\n        sub_80B2F61();\n        v8 = (_BYTE *)sub_80B2F61();\n        sub_806D1DF(v11);\n        *v8 = 61;\n        sub_80B2C69(v9);\n        sub_806D001(v11, (int)v8);\n      }\n      sub_804DF1F(v6);\n      ++v3;\n    }\n    while ( *v3 );\n  }\n  else\n  {\n    sub_804DF04(\"/proc/sys\");\n    v7 = v5 & 0xC;\n    if ( v7 )\n    {\n      return sub_806D226(\".\");\n    }\n    else\n    {\n      while ( *v3 )\n      {\n        sub_806D1DF(*v3);\n        v7 |= sub_806D226(*v3++);\n      }\n    }\n  }\n  return v7;\n}\n"
    ],
    "sub_806D3D4": [
        "0x806d3d4",
        "int __cdecl sub_806D3D4(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12);\n}\n"
    ],
    "sub_806D3E3": [
        "0x806d3e3",
        "int __cdecl sub_806D3E3(_DWORD *a1, _DWORD *a2)\n{\n  int result; // eax\n\n  result = -1;\n  if ( *a2 >= *a1 )\n    return *a2 != *a1;\n  return result;\n}\n"
    ],
    "sub_806D3FB": [
        "0x806d3fb",
        "int __cdecl sub_806D3FB(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 8);\n}\n"
    ],
    "sub_806D40A": [
        "0x806d40a",
        "int __cdecl sub_806D40A(int a1, int a2)\n{\n  int result; // eax\n  unsigned int v3; // edx\n\n  result = -1;\n  v3 = *(_DWORD *)(a1 + 4);\n  if ( *(_DWORD *)(a2 + 4) >= v3 )\n    return *(_DWORD *)(a2 + 4) != v3;\n  return result;\n}\n"
    ],
    "compar": [
        "0x806d424",
        "int __cdecl compar(const void *a1, const void *a2)\n{\n  int i; // esi\n  int v3; // ebx\n  int result; // eax\n\n  for ( i = 0; i != 3; ++i )\n  {\n    v3 = dword_80DBB80;\n    result = (*(int (__cdecl **)(const void *, const void *))(dword_80DBB80 + 4 * i + 80))(a1, a2);\n    if ( result )\n      break;\n  }\n  if ( *(_BYTE *)(v3 + 8) )\n    return -result;\n  return result;\n}\n"
    ],
    "sub_806D451": [
        "0x806d451",
        "int __fastcall sub_806D451(int a1, _QWORD *a2)\n{\n  int v3; // edi\n  const char *v4; // ebx\n  bool v5; // zf\n  int result; // eax\n  __int64 v7; // rcx\n\n  v3 = dword_80DBB80;\n  v4 = (const char *)(dword_80DBB80 + 280);\n  v5 = fgets_unlocked() == 0;\n  result = 0;\n  if ( !v5 && *(_BYTE *)(v3 + 280) == 99 )\n  {\n    result = sscanf(\n               v4,\n               \"cpu %llu %llu %llu %llu %llu %llu %llu %llu\",\n               a2,\n               a2 + 1,\n               a2 + 2,\n               a2 + 3,\n               a2 + 4,\n               a2 + 5,\n               a2 + 6,\n               a2 + 7);\n    if ( result > 3 )\n    {\n      v7 = a2[7] + a2[6] + a2[5] + a2[4] + a2[3] + a2[2] + *a2 + a2[1];\n      a2[8] = v7;\n      a2[9] = v7 - a2[3] - a2[4];\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_806D502": [
        "0x806d502",
        "int sub_806D502()\n{\n  FILE *v0; // ebp\n  int v1; // ebx\n  _DWORD *v2; // edi\n  int i; // ecx\n  _DWORD *v4; // esi\n  int v5; // ebp\n  unsigned int v6; // edx\n  char *v7; // eax\n  int v8; // ebp\n  int result; // eax\n  unsigned int v10; // [esp+0h] [ebp-24h]\n  int v11; // [esp+4h] [ebp-20h]\n  unsigned int v12; // [esp+8h] [ebp-1Ch]\n  char *ptr; // [esp+Ch] [ebp-18h]\n  int v14; // [esp+10h] [ebp-14h]\n\n  v0 = (FILE *)sub_80B3D45();\n  v1 = dword_80DBB80;\n  qmemcpy((void *)(dword_80DBB80 + 180), (const void *)(dword_80DBB80 + 100), 0x50u);\n  if ( sub_806D451(0, (_QWORD *)(v1 + 100)) <= 3 )\n    sub_804D5E0(\"can't read '%s'\", \"/proc/stat\");\n  fclose(v0);\n  *(_DWORD *)(v1 + 260) = 0;\n  v2 = sub_804DAFA(8 * *(_DWORD *)(v1 + 4));\n  v14 = *(_DWORD *)(v1 + 4);\n  ptr = *(char **)(v1 + 92);\n  v10 = 0;\n  for ( i = 0; v14 > i; ++i )\n  {\n    v4 = (_DWORD *)(*(_DWORD *)v1 + 44 * i);\n    v5 = v4[3];\n    v11 = v4[1];\n    v2[2 * i] = v11;\n    v2[2 * i + 1] = v5;\n    v4[2] = 0;\n    v12 = *(_DWORD *)(v1 + 96);\n    if ( v12 )\n    {\n      v6 = v10;\n      while ( 1 )\n      {\n        v7 = &ptr[8 * v6];\n        if ( *((_DWORD *)v7 + 1) == v5 )\n          break;\n        v6 = (v6 + 1) % v12;\n        if ( v10 == v6 )\n          goto LABEL_10;\n      }\n      v8 = v11 - *(_DWORD *)v7;\n      v4[2] = v8;\n      *(_DWORD *)(v1 + 260) += v8;\n      v10 = v6;\n    }\nLABEL_10:\n    ;\n  }\n  free(ptr);\n  *(_DWORD *)(v1 + 92) = v2;\n  result = *(_DWORD *)(v1 + 4);\n  *(_DWORD *)(v1 + 96) = result;\n  return result;\n}\n"
    ],
    "sub_806D5F8": [
        "0x806d5f8",
        "int __usercall sub_806D5F8@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  FILE *v3; // esi\n  char *v4; // eax\n  char *v5; // ebx\n  int v6; // edi\n  size_t v7; // edi\n  const char *v8; // eax\n  int v9; // ebx\n  unsigned int v10; // ecx\n  const char *v11; // eax\n  int v12; // esi\n  unsigned int v13; // eax\n  int v14; // eax\n  unsigned int v15; // edi\n  unsigned int v16; // ecx\n  int v17; // eax\n  const char *i; // esi\n  const char *v19; // eax\n  unsigned int v21; // [esp+0h] [ebp-D0h]\n  char v22; // [esp+0h] [ebp-D0h]\n  char *v23; // [esp+4h] [ebp-CCh]\n  int v25; // [esp+8h] [ebp-C8h]\n  char v26; // [esp+Ch] [ebp-C4h]\n  unsigned int v27; // [esp+10h] [ebp-C0h]\n  unsigned int v28; // [esp+20h] [ebp-B0h]\n  unsigned int v29; // [esp+24h] [ebp-ACh]\n  int v30[13]; // [esp+28h] [ebp-A8h] BYREF\n  char s[116]; // [esp+5Ch] [ebp-74h] BYREF\n\n  memset(v30, 0, sizeof(v30));\n  v3 = (FILE *)sub_80B3D45();\n  while ( fgets_unlocked() )\n  {\n    v4 = strchr(s, 58);\n    v5 = v4;\n    if ( v4 )\n    {\n      *v4 = 0;\n      v6 = sub_804D222(\"MemTotal\", s);\n      if ( v6 >= 0 )\n        v30[v6] = strtoul(v5 + 1, 0, 10);\n    }\n  }\n  fclose(v3);\n  v7 = a2;\n  if ( a2 > 100 )\n    v7 = 100;\n  v21 = v30[0];\n  snprintf(\n    s,\n    v7,\n    \"Mem: %luK used, %luK free, %luK shrd, %luK buff, %luK cached\",\n    v30[0] - v30[1],\n    v30[1],\n    v30[2] + v30[3],\n    v30[4],\n    v30[5]);\n  v8 = \"%s\\n\";\n  if ( (dword_80DBB9C & 4) == 0 )\n    v8 = \"\\x1B[H\\x1B[J%s\\n\";\n  printf(v8, s);\n  v9 = dword_80DBB80;\n  v10 = *(_DWORD *)(dword_80DBB80 + 164) - *(_DWORD *)(dword_80DBB80 + 244);\n  if ( !v10 )\n    v10 = 1;\n  snprintf(\n    s,\n    v7,\n    \"CPU:%4u%% usr%4u%% sys%4u%% nic%4u%% idle%4u%% io%4u%% irq%4u%% sirq\",\n    100 * (*(_DWORD *)(dword_80DBB80 + 100) - *(_DWORD *)(dword_80DBB80 + 180)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 116) - *(_DWORD *)(dword_80DBB80 + 196)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 108) - *(_DWORD *)(dword_80DBB80 + 188)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 124) - *(_DWORD *)(dword_80DBB80 + 204)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 132) - *(_DWORD *)(dword_80DBB80 + 212)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 140) - *(_DWORD *)(dword_80DBB80 + 220)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 148) - *(_DWORD *)(dword_80DBB80 + 228)) / v10);\n  puts(s);\n  v23 = (char *)stpcpy();\n  sub_804E632(0x55u, v23);\n  *((_BYTE *)&v30[12] + v7 + 3) = 0;\n  *(_BYTE *)strchrnul() = 0;\n  puts(s);\n  v11 = \"%.*s\";\n  if ( (dword_80DBB9C & 4) == 0 )\n    v11 = \"\\x1B[7m%.*s\\x1B[m\";\n  printf(v11, a2, \"  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\");\n  v12 = a1 - 4;\n  v27 = 0xC800000 / v21;\n  v26 = 21;\n  while ( v27 > 0x1FF )\n  {\n    v27 >>= 2;\n    v26 -= 2;\n  }\n  v13 = *(_DWORD *)(v9 + 172) - *(_DWORD *)(v9 + 252);\n  if ( *(_DWORD *)(v9 + 260) < v13 )\n    *(_DWORD *)(v9 + 260) = v13;\n  v14 = 6400 * (unsigned __int16)v13;\n  if ( !v14 )\n    v14 = 1;\n  v15 = v14;\n  v22 = 6;\n  do\n  {\n    v15 *= 4;\n    v22 += 2;\n  }\n  while ( v15 <= 0x3FFFFFFF );\n  v16 = *(_DWORD *)(v9 + 260) * (unsigned __int16)(*(_WORD *)(v9 + 164) - *(_WORD *)(v9 + 244));\n  if ( v16 )\n    v15 /= v16;\n  while ( v15 > 0x3FF )\n  {\n    v15 >>= 2;\n    v22 -= 2;\n  }\n  v17 = *(_DWORD *)(v9 + 76);\n  v25 = *(_DWORD *)(v9 + 4) - v17;\n  if ( v25 > v12 )\n    v25 = v12;\n  for ( i = (const char *)(*(_DWORD *)v9 + 44 * v17 + 24); --v25 >= 0; i += 44 )\n  {\n    v28 = (((unsigned int)(1 << v26) >> 1) + *((_DWORD *)i - 6) * v27) >> v26;\n    v29 = (((unsigned int)(1 << v22) >> 1) + v15 * *((_DWORD *)i - 4)) >> v22;\n    sub_80AD152(\" mgtpezy\");\n    v19 = (const char *)sub_80B0E79();\n    if ( a2\n       + 2\n       - snprintf(\n           (char *)(v9 + 280),\n           a2 + 2,\n           \"\\n%5u%6u %-8.8s %s  %.5s%4u%%%4u%% \",\n           *((_DWORD *)i - 3),\n           *((_DWORD *)i - 2),\n           v19,\n           i,\n           s,\n           v28,\n           v29) > 1 )\n      sub_80B1146(*((_DWORD *)i - 3), i + 4);\n    fputs_unlocked();\n  }\n  sub_804DD98((dword_80DBB9C & 4) == 0 ? 13 : 10);\n  return sub_804DD8F();\n}\n"
    ],
    "sub_806D9B6": [
        "0x806d9b6",
        "int __usercall sub_806D9B6@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v3; // eax\n  int v4; // ebx\n  int v5; // eax\n  int v6; // eax\n  int v8; // [esp+0h] [ebp-8h]\n  int v9; // [esp+4h] [ebp-4h]\n\n  if ( (dword_80DBB9C & 0x10) != 0 )\n  {\n    sleep(a2);\n    return a1;\n  }\n  while ( 1 )\n  {\n    v4 = dword_80DBB80;\n    v5 = sub_80B20CC(1000 * a2, dword_80DBB80 + 264, v8, v9);\n    if ( v5 == -1 && *(_DWORD *)dword_80DBB7C != 11 )\n    {\n      dword_80DBB9C |= 0x10u;\n      return a1;\n    }\n    if ( *(unsigned __int8 *)(v4 + 33) == v5 || *(unsigned __int8 *)(v4 + 37) == v5 )\n      return 0;\n    switch ( v5 )\n    {\n      case -2:\n        --*(_DWORD *)(v4 + 76);\n        goto LABEL_24;\n      case -3:\n        ++*(_DWORD *)(v4 + 76);\n        goto LABEL_24;\n      case -6:\n        *(_DWORD *)(v4 + 76) = 0;\n        goto LABEL_24;\n      case -7:\n        *(_DWORD *)(v4 + 76) = *(_DWORD *)(v4 + 4) - (*(_DWORD *)(v4 + 12) >> 1);\n        goto LABEL_24;\n      case -10:\n        *(_DWORD *)(v4 + 76) -= *(_DWORD *)(v4 + 12) >> 1;\n        goto LABEL_24;\n    }\n    if ( v5 == -11 )\n      break;\n    v3 = v5 | 0x20;\n    switch ( v3 )\n    {\n      case 'q':\n        return 0;\n      case 'n':\n        *(_DWORD *)(v4 + 80) = sub_806D3D4;\n        break;\n      case 'm':\n        *(_DWORD *)(v4 + 80) = sub_806D3E3;\n        *(_DWORD *)(v4 + 84) = sub_806D3FB;\nLABEL_32:\n        *(_DWORD *)(v4 + 88) = sub_806D40A;\n        break;\n      case 'p':\n        *(_DWORD *)(v4 + 80) = sub_806D3FB;\n        *(_DWORD *)(v4 + 84) = sub_806D3E3;\n        goto LABEL_32;\n      case 't':\n        *(_DWORD *)(v4 + 80) = sub_806D40A;\n        *(_DWORD *)(v4 + 84) = sub_806D3E3;\n        *(_DWORD *)(v4 + 88) = sub_806D3FB;\n        break;\n      case 'r':\n        *(_BYTE *)(v4 + 8) ^= 1u;\n        break;\n      default:\n        return a1;\n    }\n    a2 = 0;\n  }\n  *(_DWORD *)(v4 + 76) += *(_DWORD *)(v4 + 12) >> 1;\nLABEL_24:\n  v6 = *(_DWORD *)(v4 + 4);\n  if ( *(_DWORD *)(v4 + 76) >= v6 )\n    *(_DWORD *)(v4 + 76) = v6 - 1;\n  a1 = -1;\n  if ( *(int *)(v4 + 76) < 0 )\n    *(_DWORD *)(v4 + 76) = 0;\n  return a1;\n}\n"
    ],
    "sub_806DB16": [
        "0x806db16",
        "int sub_806DB16()\n{\n  _DWORD *v0; // ebx\n  int v2; // [esp-4h] [ebp-8h]\n\n  sub_80B0E38();\n  v0 = (_DWORD *)dword_80DBB80;\n  free(*(void **)dword_80DBB80);\n  *v0 = 0;\n  return v2;\n}\n"
    ],
    "sub_806DB32": [
        "0x806db32",
        "int sub_806DB32()\n{\n  int result; // eax\n\n  if ( (dword_80DBB9C & 4) == 0 )\n    return sub_804D995((const struct termios *)(dword_80DBB80 + 16));\n  return result;\n}\n"
    ],
    "sub_806DB49": [
        "0x806db49",
        "void __cdecl __noreturn sub_806DB49(int a1)\n{\n  sub_806DB32();\n  sub_804E761(a1);\n}\n"
    ],
    "sub_806DB57": [
        "0x806db57",
        "int __cdecl sub_806DB57(int a1, int a2)\n{\n  int v2; // ebp\n  int v3; // edx\n  int v4; // ecx\n  int v5; // ebx\n  int v6; // esi\n  int v7; // edi\n  int v8; // eax\n  int v9; // eax\n  int v10; // esi\n  int v12; // [esp+0h] [ebp-24h]\n  unsigned int seconds; // [esp+4h] [ebp-20h]\n  unsigned int v14; // [esp+8h] [ebp-1Ch] BYREF\n  _BYTE *v15; // [esp+Ch] [ebp-18h] BYREF\n  int v16[5]; // [esp+10h] [ebp-14h] BYREF\n\n  dword_80DBB80 = (int)sub_804DB2E(0x2D8u);\n  sub_80ABEDA();\n  v14 = sub_80ABEAC(a2, \"d:n:b\", &v15, v16);\n  seconds = 5;\n  if ( (v14 & 1) != 0 )\n  {\n    if ( *v15 == 45 )\n      ++v15;\n    seconds = (unsigned __int16)sub_80B4193();\n  }\n  v2 = 0;\n  if ( (v14 & 2) != 0 )\n  {\n    if ( *(_BYTE *)v16[0] == 45 )\n      ++v16[0];\n    v2 = sub_80B40EC();\n  }\n  sub_804DF04(\"/proc\");\n  v3 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 80) = sub_806D3FB;\n  *(_DWORD *)(v3 + 84) = sub_806D3E3;\n  *(_DWORD *)(v3 + 88) = sub_806D40A;\n  if ( (dword_80DBB9C & 4) != 0 )\n  {\n    dword_80DBB9C |= 0x10u;\n  }\n  else\n  {\n    sub_804DA14(1, (struct termios *)(v3 + 16), 0);\n    dword_80DBB84 = sub_806DB32;\n  }\n  sub_804E6C8(117503054, (void (*)(int))sub_806DB49);\n  v12 = sub_806D9B6(13875, 0);\nLABEL_13:\n  while ( v12 )\n  {\n    v5 = dword_80DBB80;\n    if ( (dword_80DBB9C & 4) != 0 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 12) = 0x7FFFFFFF;\nLABEL_20:\n      v14 = 446;\n      goto LABEL_21;\n    }\n    *(_DWORD *)(dword_80DBB80 + 12) = 24;\n    v14 = 79;\n    sub_804D878(1, (int *)&v14, (int *)(v5 + 12));\n    if ( *(_DWORD *)(v5 + 12) > 4u && v14 > 9 )\n    {\n      if ( v14 > 0x1BE )\n        goto LABEL_20;\nLABEL_21:\n      *(_DWORD *)(v5 + 4) = 0;\n      while ( 1 )\n      {\n        v6 = sub_80B0EC0(v4, v12);\n        if ( !v6 )\n          break;\n        v7 = *(_DWORD *)(v5 + 4);\n        *(_DWORD *)(v5 + 4) = v7 + 1;\n        v8 = sub_80B4733(v7, 11270);\n        *(_DWORD *)v5 = v8;\n        v7 *= 44;\n        v9 = v7 + v8;\n        *(_DWORD *)(v9 + 12) = *(_DWORD *)(v6 + 36);\n        *(_DWORD *)(v9 + 16) = *(_DWORD *)(v6 + 40);\n        *(_DWORD *)v9 = *(_DWORD *)(v6 + 16);\n        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v6 + 24) + *(_DWORD *)(v6 + 28);\n        *(_DWORD *)(v9 + 20) = *(_DWORD *)(v6 + 52);\n        strcpy((char *)(v9 + 24), (const char *)(v6 + 68));\n        strcpy((char *)(*(_DWORD *)v5 + v7 + 28), (const char *)(v6 + 72));\n      }\n      if ( !*(_DWORD *)(v5 + 4) )\n      {\n        sub_804D5F4(\"no process info in /proc\");\n        break;\n      }\n      if ( *(_DWORD *)(v5 + 96) )\n      {\n        sub_806D502();\n        qsort(*(void **)v5, *(_DWORD *)(v5 + 4), 0x2Cu, compar);\n        while ( 1 )\n        {\n          sub_806D5F8(*(_DWORD *)(v5 + 12), v14);\n          if ( v2 >= 0 && !--v2 )\n            goto LABEL_33;\n          v10 = sub_806D9B6(v12, seconds);\n          if ( v10 != -1 )\n          {\n            sub_806DB16();\n            v12 = v10;\n            goto LABEL_13;\n          }\n        }\n      }\n      sub_806D502();\n      usleep(0x186A0u);\n      sub_806DB16();\n    }\n    else\n    {\n      sleep(seconds);\n    }\n  }\nLABEL_33:\n  sub_804DD98(10);\n  sub_806DB32();\n  return 0;\n}\n"
    ],
    "sub_806DDCD": [
        "0x806ddcd",
        "int sub_806DDCD()\n{\n  struct tm *v0; // ebx\n  const char *v1; // edx\n  time_t v3; // [esp+0h] [ebp-4Ch] BYREF\n  struct sysinfo v4; // [esp+4h] [ebp-48h] BYREF\n\n  time(&v3);\n  v0 = localtime(&v3);\n  sysinfo(&v4);\n  printf(\" %02u:%02u:%02u up \", v0->tm_hour, v0->tm_min, v0->tm_sec);\n  if ( v4.uptime / 0x15180u )\n  {\n    v1 = \"\\r\\n%s\" + 3;\n    if ( v4.uptime / 0x15180u == 1 )\n      v1 = &data;\n    printf(\"%u day%s, \", v4.uptime / 0x15180u, v1);\n  }\n  if ( v4.uptime / 0xE10u % 0x18 )\n    printf(\"%2u:%02u\", v4.uptime / 0xE10u % 0x18, v4.uptime / 0x3Cu % 0x3C);\n  else\n    printf(\"%u min\", v4.uptime / 0x3Cu % 0x3C);\n  printf(\n    \",  load average: %u.%02u, %u.%02u, %u.%02u\\n\",\n    HIWORD(v4.loads[0]),\n    (100 * (unsigned int)LOWORD(v4.loads[0])) >> 16,\n    HIWORD(v4.loads[1]),\n    (100 * (unsigned int)LOWORD(v4.loads[1])) >> 16,\n    HIWORD(v4.loads[2]),\n    (100 * (unsigned int)LOWORD(v4.loads[2])) >> 16);\n  return 0;\n}\n"
    ],
    "sub_806DEC9": [
        "0x806dec9",
        "void __cdecl __noreturn sub_806DEC9(int a1, int a2)\n{\n  const char **v2; // esi\n  char *i; // edi\n  char *v4; // ebx\n  int v5; // ebp\n  int v6; // edx\n  unsigned int v7; // esi\n  char v8; // [esp+0h] [ebp-18h]\n  unsigned int seconds[5]; // [esp+4h] [ebp-14h] BYREF\n\n  seconds[0] = 2;\n  v8 = sub_80ABEAC(a2, \"^+dtn:+\", seconds);\n  v2 = (const char **)(a2 + 4 * optind);\n  for ( i = (char *)*v2; ; i = sub_804DDBF((char *)\"%s %s\", i, *v2) )\n  {\n    v4 = (char *)*++v2;\n    if ( !*v2 )\n      break;\n  }\n  v5 = -1;\n  while ( 1 )\n  {\n    printf(\"\\x1B[H\\x1B[J\");\n    if ( (v8 & 2) == 0 )\n    {\n      v7 = sub_804D986(2, v6);\n      if ( v5 != v7 )\n      {\n        free(v4);\n        v4 = sub_804DDBF(\"Every %us: %-*s\", seconds[0], v7, i);\n      }\n      if ( v7 > 0x14 )\n        sub_804EBAF(0, 0x14u, &v4[v7 - 20], (time_t)v4);\n      printf(\"%s\\n\\n\", v4);\n      v5 = v7;\n    }\n    sub_804DD8F();\n    system(i);\n    sleep(seconds[0]);\n  }\n}\n"
    ],
    "sub_806DF91": [
        "0x806df91",
        "int __usercall sub_806DF91@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  const char *v2; // ecx\n\n  v2 = \"/log\";\n  if ( !(_BYTE)qword_80DB7A8 )\n    v2 = &data;\n  printf(\"%s%s%s: %s\", a1, (const char *)**(&qword_80DB778 + 1), v2, a2);\n  if ( *(_DWORD *)dword_80DBB7C )\n    printf(\": %m\");\n  return sub_804DD98(10);\n}\n"
    ],
    "sub_806DFDB": [
        "0x806dfdb",
        "int __usercall sub_806DFDB@<eax>(const char *a1@<eax>)\n{\n  ++unk_80DB780;\n  return sub_806DF91(\"warning: \", a1);\n}\n"
    ],
    "sub_806DFED": [
        "0x806dfed",
        "int __usercall sub_806DFED@<eax>(const char *a1@<eax>)\n{\n  ++unk_80DB780;\n  return sub_806DF91(\"fail: \", a1);\n}\n"
    ],
    "sub_806DFFF": [
        "0x806dfff",
        "int __usercall sub_806DFFF@<eax>(const char *a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // ebx\n  regoff_t rm_so; // esi\n  int v5; // edi\n  char *v6; // eax\n\n  if ( stat64() == -1 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n    {\n      sub_804D3A5((int)\"warning: can't stat %s/down\", (const char *)**(&qword_80DB778 + 1));\n      return 0;\n    }\n    v3 = 1;\n  }\n  else\n  {\n    v3 = 0;\n  }\n  rm_so = pmatch[0].rm_so;\n  v5 = sub_80A9893(\"down\", dword_80DB798);\n  if ( *(&dword_80DB7A4 + 3) == 1 )\n  {\n    printf(\"run: \");\n  }\n  else if ( *(&dword_80DB7A4 + 3) )\n  {\n    if ( *(&dword_80DB7A4 + 3) == 2 )\n      printf(\"finish: \");\n  }\n  else\n  {\n    printf(\"down: \");\n  }\n  printf(\"%s: \", a1);\n  if ( *(&dword_80DB7A4 + 3) )\n    printf(\"(pid %d) \", rm_so);\n  v6 = &unk_80DB78C[-v5];\n  if ( (int)&unk_80DB78C[-v5] < 0 )\n    v6 = 0;\n  printf(\"%us\", v6);\n  if ( rm_so )\n  {\n    if ( !v3 )\n      printf(\", normally down\");\n    if ( dword_80DB7A4 )\n      printf(\", paused\");\n    if ( *(&dword_80DB7A4 + 1) == 100 )\n      printf(\", want down\");\n    v2 = 1;\n    if ( *(&dword_80DB7A4 + 2) )\n      printf(\", got TERM\");\n  }\n  else\n  {\n    if ( v3 )\n      printf(\", normally up\");\n    v2 = 2;\n    if ( *(&dword_80DB7A4 + 1) == 117 )\n      printf(\", want up\");\n  }\n  return v2;\n}\n"
    ],
    "sub_806E142": [
        "0x806e142",
        "_BOOL4 sub_806E142()\n{\n  _BOOL4 result; // eax\n  __pid_t v1; // eax\n  int v2[3]; // [esp+0h] [ebp-6Ch] BYREF\n  char v3[96]; // [esp+Ch] [ebp-60h] BYREF\n\n  if ( stat64() == -1 )\n  {\n    result = 1;\n    if ( *(_DWORD *)dword_80DBB7C == 2 )\n      return result;\n    sub_804D3A5((int)\"warning: can't stat %s/check\", (const char *)**(&qword_80DB778 + 1));\n    return 0;\n  }\n  v2[1] = (int)&unk_80D0442;\n  v2[2] = 0;\n  v1 = sub_80B3BA2(\"check\", v3);\n  if ( v1 <= 0 )\n  {\n    sub_804D3A5((int)\"warning: can't %s child %s/check\", \"run\", (const char *)**(&qword_80DB778 + 1));\n    return 0;\n  }\n  if ( sub_804DA34(0, v2, v1) == -1 )\n  {\n    sub_804D3A5((int)\"warning: can't %s child %s/check\", \"wait for\", (const char *)**(&qword_80DB778 + 1));\n    return 0;\n  }\n  return BYTE1(v2[0]) == 0;\n}\n"
    ],
    "sub_806E1E0": [
        "0x806e1e0",
        "void __usercall __noreturn sub_806E1E0(const char *a1@<eax>)\n{\n  sub_804D3A5((int)\"fatal: can't %s\", a1);\n  _exit(151);\n}\n"
    ],
    "sub_806E1F5": [
        "0x806e1f5",
        "int sub_806E1F5()\n{\n  int v0; // ebx\n  bool v1; // zf\n  const char *v2; // eax\n  int v3; // eax\n  ssize_t v4; // esi\n  const char *v5; // eax\n\n  v0 = open64();\n  if ( v0 != -1 )\n  {\n    close(v0);\n    v3 = open64();\n    v0 = v3;\n    if ( v3 != -1 )\n    {\n      v4 = read(v3, &unk_80DB794, 0x14u);\n      close(v0);\n      if ( v4 == -1 )\n      {\n        v5 = (const char *)&unk_80D04CF;\n      }\n      else\n      {\n        v0 = 1;\n        if ( v4 == 20 )\n          return v0;\n        *(_DWORD *)dword_80DBB7C = 0;\n        v5 = \"can't read supervise/status: bad format\";\n      }\n      sub_806DFDB(v5);\n      return -1;\n    }\n    v2 = \"can't open supervise/status\";\n    goto LABEL_10;\n  }\n  if ( *(_DWORD *)dword_80DBB7C != 19 )\n  {\n    v2 = (const char *)&unk_80D049B;\nLABEL_10:\n    sub_806DFDB(v2);\n    return v0;\n  }\n  v1 = *qword_80DB778 == 120;\n  *(_DWORD *)dword_80DBB7C = 0;\n  if ( v1 )\n    sub_806DF91(\"ok: \", \"runsv not running\");\n  else\n    sub_806DFED(\"runsv not running\");\n  return 0;\n}\n"
    ],
    "sub_806E2C4": [
        "0x806e2c4",
        "int sub_806E2C4()\n{\n  int v0; // ebx\n\n  v0 = 0;\n  if ( sub_806E1F5() > 0 )\n  {\n    v0 = sub_806DFFF((const char *)**(&qword_80DB778 + 1));\n    LOBYTE(qword_80DB7A8) = 1;\n    if ( chdir(\"log\") == -1 )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 2 )\n      {\n        printf(\"; \");\n        sub_806DFDB(\"can't change directory\");\nLABEL_8:\n        LOBYTE(qword_80DB7A8) = 0;\n        return v0;\n      }\n    }\n    else\n    {\n      printf(\"; \");\n      if ( !sub_806E1F5() )\n        goto LABEL_8;\n      v0 = sub_806DFFF(\"log\");\n    }\n    sub_804DD98(10);\n    goto LABEL_8;\n  }\n  return v0;\n}\n"
    ],
    "sub_806E349": [
        "0x806e349",
        "int __cdecl sub_806E349(unsigned __int8 *a1)\n{\n  int v2; // ecx\n  int v3; // edi\n  regoff_t rm_so; // ebx\n  unsigned __int8 v5; // dl\n  int result; // eax\n  bool v7; // zf\n  bool v8; // zf\n  bool v9; // zf\n  unsigned __int64 v10; // rax\n  unsigned __int64 v11; // rax\n\n  v3 = sub_806E1F5();\n  if ( v3 != -1 )\n  {\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( !*a1 )\n      {\n        printf(\"ok: \");\n        sub_806DFFF((const char *)**(&qword_80DB778 + 1));\n        sub_804DD98(10);\n        return 1;\n      }\n      if ( !v3 )\n      {\n        result = 1;\n        if ( v5 == 120 )\n          return result;\n        return -1;\n      }\n      rm_so = pmatch[0].rm_so;\n      if ( v5 == 111 )\n      {\n        LODWORD(v11) = sub_80A9893(v2, dword_80DB798);\n        if ( !rm_so )\n        {\n          if ( qword_80DB784 > v11 )\n            return 0;\n          goto LABEL_8;\n        }\n        v9 = *(&dword_80DB7A4 + 1) == 100;\n      }\n      else\n      {\n        if ( v5 > 0x6Fu )\n        {\n          if ( v5 == 116 )\n            goto LABEL_28;\n          if ( v5 > 0x74u )\n          {\n            if ( v5 == 117 )\n            {\n              if ( !pmatch[0].rm_so )\n                return 0;\n              v8 = *(&dword_80DB7A4 + 3) == 1;\n              goto LABEL_33;\n            }\n            v7 = v5 == 120;\n          }\n          else\n          {\n            if ( v5 != 112 || !pmatch[0].rm_so )\n              goto LABEL_8;\n            v7 = dword_80DB7A4 == 0;\n          }\n          goto LABEL_41;\n        }\n        if ( v5 == 99 )\n        {\n          if ( !pmatch[0].rm_so )\n            goto LABEL_8;\n          v9 = dword_80DB7A4 == 0;\n        }\n        else\n        {\n          if ( v5 <= 0x63u )\n          {\n            if ( v5 != 67 || !pmatch[0].rm_so )\n              goto LABEL_8;\n            goto LABEL_34;\n          }\n          if ( v5 != 100 )\n          {\n            if ( v5 != 107 )\n              goto LABEL_8;\nLABEL_28:\n            if ( !pmatch[0].rm_so && *(&dword_80DB7A4 + 1) == 100 )\n              goto LABEL_8;\n            LODWORD(v10) = sub_80A9893(v2, dword_80DB798);\n            if ( qword_80DB784 > v10 || !rm_so )\n              return 0;\n            v8 = *(&dword_80DB7A4 + 2) == 0;\nLABEL_33:\n            if ( !v8 )\n              return 0;\nLABEL_34:\n            v7 = !sub_806E142();\nLABEL_41:\n            if ( v7 )\n              return 0;\n            goto LABEL_8;\n          }\n          if ( pmatch[0].rm_so )\n            return 0;\n          v9 = *(&dword_80DB7A4 + 3) == 0;\n        }\n      }\n      if ( !v9 )\n        return 0;\nLABEL_8:\n      ++a1;\n    }\n  }\n  return -1;\n}\n"
    ],
    "sub_806E4E5": [
        "0x806e4e5",
        "int __cdecl sub_806E4E5(char *s)\n{\n  int v1; // ebx\n  bool v2; // zf\n  size_t v3; // edi\n  ssize_t v4; // esi\n\n  v1 = -1;\n  if ( sub_806E1F5() > 0 )\n  {\n    if ( *(&dword_80DB7A4 + 1) != *s || (v1 = 0, *(&dword_80DB7A4 + 1) == 100) && *(&dword_80DB7A4 + 2) != 1 )\n    {\n      v1 = open64();\n      if ( v1 == -1 )\n      {\n        if ( *(_DWORD *)dword_80DBB7C == 19 )\n        {\n          v2 = *s == 120;\n          *(_DWORD *)dword_80DBB7C = 0;\n          if ( v2 )\n            sub_806DF91(\"ok: \", \"runsv not running\");\n          else\n            sub_806DFED(\"runsv not running\");\n        }\n        else\n        {\n          sub_806DFDB(\"can't open supervise/control\");\n        }\n      }\n      else\n      {\n        v3 = strlen(s);\n        v4 = write(v1, s, v3);\n        close(v1);\n        v1 = 1;\n        if ( v3 != v4 )\n        {\n          sub_806DFDB(\"can't write to supervise/control\");\n          return -1;\n        }\n      }\n    }\n  }\n  return v1;\n}\n"
    ],
    "sub_806E5AB": [
        "0x806e5ab",
        "int __cdecl sub_806E5AB(int a1, int a2)\n{\n  _DWORD *v2; // eax\n  char **v4; // eax\n  char *v5; // ebx\n  const char *v6; // eax\n  char v7; // al\n  bool v8; // zf\n  bool v9; // zf\n  int (__cdecl *v10)(unsigned __int8 *); // ebx\n  int (*v11)(); // edi\n  char v12; // si\n  const char *v13; // ebp\n  int v14; // edi\n  const char *v15; // ebp\n  int v16; // eax\n  int v17; // edx\n  int v18; // eax\n  int v19; // edx\n  _DWORD *v20; // [esp+0h] [ebp-40h]\n  const char *path; // [esp+4h] [ebp-3Ch]\n  unsigned int v22; // [esp+8h] [ebp-38h]\n  int fd; // [esp+Ch] [ebp-34h]\n  char *v24; // [esp+10h] [ebp-30h]\n  _DWORD *v25; // [esp+14h] [ebp-2Ch]\n  char *format; // [esp+18h] [ebp-28h]\n  char *v27; // [esp+1Ch] [ebp-24h]\n  int v28; // [esp+20h] [ebp-20h]\n  char v29[2]; // [esp+26h] [ebp-1Ah] BYREF\n  unsigned int v30; // [esp+28h] [ebp-18h] BYREF\n  int v31[5]; // [esp+2Ch] [ebp-14h] BYREF\n\n  v22 = sub_80ABEAC(a2, \"udopchaitkx\");\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v2 || !v22 )\nLABEL_74:\n    sub_804CDC2();\n  v20 = v2 - 2;\n  if ( optind > 2 )\n  {\n    v20 = v2 - 3;\n    *(v2 - 1) = \"--\";\n  }\n  *v20 = 135052030;\n  v20[1] = v29;\n  v29[1] = 0;\n  v24 = \"udopchaitkx\";\n  while ( 2 )\n  {\n    if ( (v22 & 1) == 0 )\n      goto LABEL_7;\n    v29[0] = *v24;\n    optind = 0;\n    v30 = 7;\n    v31[0] = 0;\n    memset(&qword_80DB778, 0, 0x34u);\n    byte_80DB560 = 100;\n    path = getenv(\"SVDIR\");\n    if ( !path )\n      path = &data;\n    if ( getenv(\"SVWAIT\") )\n      v30 = sub_80B40EC();\n    sub_80ABEAC(v20, \"^w:+v\", &v30, v31);\n    v4 = (char **)&v20[optind];\n    v25 = v4 + 1;\n    v5 = *v4;\n    if ( !*v4 || !v4[1] )\n      goto LABEL_74;\n    *(_QWORD *)&unk_80DB78C = time(0) + 0x400000000000000ALL;\n    qword_80DB784 = *(_QWORD *)&unk_80DB78C;\n    fd = open64();\n    if ( fd == -1 )\n    {\n      v6 = \"open current directory\";\n      goto LABEL_87;\n    }\n    qword_80DB778 = 135062127;\n    v7 = *v5;\n    if ( *v5 != 102 )\n    {\n      if ( (unsigned __int8)*v5 > 0x66u )\n      {\n        if ( (unsigned __int8)v7 <= 0x71u )\n        {\n          if ( (unsigned __int8)v7 >= 0x6Fu )\n            goto LABEL_54;\n          if ( (unsigned __int8)v7 < 0x68u )\n            goto LABEL_74;\n          if ( (unsigned __int8)v7 <= 0x69u )\n            goto LABEL_54;\n          v8 = v7 == 107;\nLABEL_38:\n          if ( !v8 )\n            goto LABEL_74;\n          goto LABEL_54;\n        }\n        if ( v7 != 116 )\n        {\n          if ( (unsigned __int8)v7 <= 0x74u )\n          {\n            if ( v7 == 114 )\n            {\n              if ( !strcmp(v5, \"restart\") )\n              {\n                qword_80DB778 = \"tcu\";\n              }\n              else\n              {\n                if ( strcmp(v5, \"reload\") )\n                  goto LABEL_74;\n                qword_80DB778 = \"h\";\n              }\n            }\n            else if ( !strcmp(v5, \"shutdown\") )\n            {\n              qword_80DB778 = \"x\";\n            }\n            else if ( !strcmp(v5, \"start\") )\n            {\n              qword_80DB778 = \"u\";\n            }\n            else\n            {\n              if ( strcmp(v5, \"stop\") )\n              {\n                v10 = 0;\n                v11 = sub_806E2C4;\n                goto LABEL_78;\n              }\n              qword_80DB778 = 135061336;\n            }\n            goto LABEL_75;\n          }\n          if ( v7 == 117 )\n            goto LABEL_54;\n          v9 = v7 == 120;\n          goto LABEL_46;\n        }\n        if ( !strcmp(v5, \"try-restart\") )\n        {\n          qword_80DB778 = \"tc\";\n          goto LABEL_75;\n        }\nLABEL_52:\n        if ( !strcmp(v5, \"check\") )\n        {\n          qword_80DB778 = 135061484;\n          v10 = sub_806E349;\n          v11 = 0;\nLABEL_78:\n          v12 = 0;\n          goto LABEL_79;\n        }\n        goto LABEL_54;\n      }\n      if ( v7 != 84 )\n      {\n        if ( (unsigned __int8)v7 <= 0x54u )\n        {\n          if ( v7 != 68 )\n          {\n            if ( (unsigned __int8)v7 <= 0x44u )\n            {\n              if ( (unsigned __int8)(v7 - 49) > 1u )\n                goto LABEL_74;\n              goto LABEL_54;\n            }\n            if ( v7 != 69 )\n              goto LABEL_74;\n            goto LABEL_70;\n          }\nLABEL_72:\n          qword_80DB778 = 135061336;\n          goto LABEL_73;\n        }\n        if ( v7 != 99 )\n        {\n          if ( (unsigned __int8)v7 <= 0x63u )\n          {\n            if ( v7 != 88 )\n            {\n              v8 = v7 == 97;\n              goto LABEL_38;\n            }\nLABEL_70:\n            qword_80DB778 = \"x\";\n            goto LABEL_73;\n          }\n          if ( v7 == 100 )\n          {\nLABEL_54:\n            v5[1] = 0;\n            qword_80DB778 = v5;\n            goto LABEL_48;\n          }\n          v9 = v7 == 101;\nLABEL_46:\n          if ( !v9 )\n            goto LABEL_74;\n          qword_80DB778 = \"x\";\nLABEL_48:\n          v10 = 0;\n          if ( !v31[0] )\n          {\nLABEL_76:\n            v11 = (int (*)())sub_806E4E5;\n            goto LABEL_78;\n          }\nLABEL_75:\n          v10 = sub_806E349;\n          goto LABEL_76;\n        }\n        goto LABEL_52;\n      }\n      goto LABEL_66;\n    }\n    if ( !strcmp(v5, \"force-reload\") )\n    {\nLABEL_66:\n      qword_80DB778 = \"tc\";\n      goto LABEL_73;\n    }\n    if ( strcmp(v5, \"force-restart\") )\n    {\n      if ( strcmp(v5, \"force-shutdown\") )\n      {\n        if ( strcmp(v5, \"force-stop\") )\n          goto LABEL_74;\n        goto LABEL_72;\n      }\n      goto LABEL_70;\n    }\n    qword_80DB778 = \"tcu\";\nLABEL_73:\n    v10 = sub_806E349;\n    v11 = (int (*)())sub_806E4E5;\n    v12 = 1;\nLABEL_79:\n    for ( *(&qword_80DB778 + 1) = v25; ; *(&qword_80DB778 + 1) += 4 )\n    {\n      v13 = (const char *)**(&qword_80DB778 + 1);\n      if ( !**(&qword_80DB778 + 1) )\n        break;\n      if ( (unsigned __int8)(*v13 - 46) > 1u\n        && !sub_804D378((const char *)**(&qword_80DB778 + 1), 47)\n        && chdir(path) == -1\n        || chdir(v13) == -1 )\n      {\n        sub_806DFED(\"can't change to service directory\");\nLABEL_92:\n        **(&qword_80DB778 + 1) = -1;\n        goto LABEL_85;\n      }\n      if ( v11 && ((int (__cdecl *)(char *))v11)(qword_80DB778) == -1 )\n        goto LABEL_92;\nLABEL_85:\n      if ( fchdir(fd) == -1 )\n      {\nLABEL_86:\n        v6 = \"change to original directory\";\nLABEL_87:\n        sub_806E1E0(v6);\n      }\n    }\n    if ( !v10 )\n      goto LABEL_117;\n    format = \"timeout: \";\n    if ( v12 )\n      format = \"kill: \";\n    while ( 2 )\n    {\n      v27 = &unk_80DB78C[-qword_80DB784];\n      *(&qword_80DB778 + 1) = v25;\n      v14 = 1;\n      while ( 2 )\n      {\n        v15 = (const char *)**(&qword_80DB778 + 1);\n        if ( **(&qword_80DB778 + 1) )\n        {\n          if ( v15 == (const char *)-1 )\n          {\n            v19 = v14;\n          }\n          else\n          {\n            if ( (unsigned __int8)(*v15 - 46) > 1u && chdir(path) == -1 || chdir(v15) == -1 )\n            {\n              sub_806DFED(\"can't change to service directory\");\n              goto LABEL_110;\n            }\n            v16 = v10(qword_80DB778);\n            v17 = v16;\n            if ( v16 )\n            {\nLABEL_110:\n              **(&qword_80DB778 + 1) = -1;\n              v17 = v14;\n            }\n            else if ( (unsigned int)v27 >= v30 )\n            {\n              printf(format);\n              if ( sub_806E1F5() > 0 )\n              {\n                sub_806DFFF(v15);\n                ++unk_80DB780;\n              }\n              sub_804DD98(10);\n              v14 = 0;\n              if ( v12 )\n                sub_806E4E5(\"k\");\n              goto LABEL_110;\n            }\n            v28 = v17;\n            v18 = fchdir(fd);\n            v19 = v28;\n            if ( v18 == -1 )\n              goto LABEL_86;\n          }\n          *(&qword_80DB778 + 1) += 4;\n          v14 = v19;\n          continue;\n        }\n        break;\n      }\n      if ( !v14 )\n      {\n        usleep(0x668A0u);\n        *(_QWORD *)&unk_80DB78C = time(0) + 0x400000000000000ALL;\n        continue;\n      }\n      break;\n    }\nLABEL_117:\n    if ( !unk_80DB780 )\n    {\nLABEL_7:\n      ++v24;\n      v22 >>= 1;\n      if ( !v22 )\n        return 0;\n      continue;\n    }\n    return 1;\n  }\n}\n"
    ],
    "sub_806EB8B": [
        "0x806eb8b",
        "int __cdecl sub_806EB8B(int a1, int a2)\n{\n  const char *v2; // ebx\n\n  v2 = *(const char **)(a2 + 4);\n  if ( !v2 )\n    sub_804CDC2();\n  byte_80DB560 = 111;\n  if ( (unsigned __int8)(*v2 - 46) > 1u && !sub_804D378(v2, 47) )\n    sub_804DF04(&data);\n  sub_804DF04(v2);\n  if ( open64() >= 0 )\n    return 0;\n  if ( (*(_DWORD *)dword_80DBB7C & 0xFFFFFFFB) != 2 )\n    sub_804D3C9((int)\"can't open '%s'\", \"supervise/ok\");\n  return 100;\n}\n"
    ],
    "sub_806EC08": [
        "0x806ec08",
        "_BOOL4 __usercall sub_806EC08@<eax>(char *a1@<eax>)\n{\n  int v1; // edx\n  char v2; // cl\n\n  v1 = 0;\n  v2 = *a1;\n  do\n  {\n    ++v1;\n    if ( (unsigned __int8)(v2 - 48) > 9u )\n      break;\n    v2 = a1[v1];\n  }\n  while ( v1 != 9 );\n  return v2 == 0;\n}\n"
    ],
    "sub_806EC35": [
        "0x806ec35",
        "int __usercall sub_806EC35@<eax>(int result@<eax>)\n{\n  int v1; // edx\n\n  v1 = dword_80DBB88;\n  *(_DWORD *)(dword_80DBB88 + 12) += *(_DWORD *)(dword_80DBB88 + 4) - result;\n  *(_DWORD *)(v1 + 4) = result;\n  return result;\n}\n"
    ],
    "sub_806EC47": [
        "0x806ec47",
        "_BYTE *__cdecl sub_806EC47(_BYTE *a1, char *a2)\n{\n  _BYTE *result; // eax\n  char v4; // cl\n\n  result = a1;\n  while ( 1 )\n  {\n    v4 = *a2;\n    if ( !*a2 )\n      break;\n    ++a2;\n    if ( *result++ != v4 )\n      return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_806EC60": [
        "0x806ec60",
        "int __usercall sub_806EC60@<eax>(_BYTE *a1@<eax>)\n{\n  while ( (unsigned __int8)(*a1 - 48) <= 9u )\n  {\n    if ( !*++a1 )\n      return 1;\n  }\n  return 0;\n}\n"
    ],
    "sub_806EC79": [
        "0x806ec79",
        "int __usercall sub_806EC79@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int i; // esi\n  int v3; // ecx\n  int v4; // ebx\n\n  for ( i = 0; ; ++i )\n  {\n    v3 = *(unsigned __int8 *)(a1 + i);\n    v4 = *(unsigned __int8 *)(a2 + i);\n    if ( v3 != v4 )\n      break;\n    if ( !*(_BYTE *)(a1 + i) )\n      goto LABEL_9;\n    if ( v3 == 61 )\n    {\n      v4 = 61;\n      return v3 - v4;\n    }\n  }\n  if ( v3 == 61 )\n    v3 = 0;\n  if ( v4 == 61 )\nLABEL_9:\n    v4 = 0;\n  return v3 - v4;\n}\n"
    ],
    "sub_806ECAC": [
        "0x806ecac",
        "unsigned int __usercall sub_806ECAC@<eax>(unsigned __int8 *a1@<eax>)\n{\n  unsigned int i; // edx\n  int v2; // ecx\n\n  for ( i = 16 * *a1; ; i += v2 )\n  {\n    v2 = *a1;\n    if ( (_BYTE)v2 == 61 || !(_BYTE)v2 )\n      break;\n    ++a1;\n  }\n  return dword_80DBB90 + 4 * (i % 0x27) + 28;\n}\n"
    ],
    "sub_806ECD8": [
        "0x806ecd8",
        "int __cdecl sub_806ECD8(int *a1, int *a2)\n{\n  return sub_806EC79(*a1, *a2);\n}\n"
    ],
    "sub_806ECE9": [
        "0x806ece9",
        "_DWORD *__usercall sub_806ECE9@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *v4; // esi\n\n  while ( 1 )\n  {\n    v4 = (_DWORD *)*a1;\n    if ( !*a1 || !sub_806EC79(v4[2], a2) )\n      break;\n    a1 = v4;\n  }\n  return a1;\n}\n"
    ],
    "sub_806ED0E": [
        "0x806ed0e",
        "int __usercall sub_806ED0E@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // ecx\n  int *v3; // ebx\n  int v4; // eax\n  int *v5; // edx\n\n  v2 = dword_80DB6E0;\n  v3 = &dword_80DB6E0;\n  while ( v2 != result )\n  {\n    v3 = (int *)(v2 + 28);\n    v2 = *(_DWORD *)(v2 + 28);\n  }\n  *v3 = *(_DWORD *)(v2 + 28);\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return result;\n    v4 = dword_80DB6E0;\n    v5 = &dword_80DB6E0;\n    while ( v4 && *(_BYTE *)(v4 + 24) == 1 )\n    {\n      v5 = (int *)(v4 + 28);\n      v4 = *(_DWORD *)(v4 + 28);\n    }\n  }\n  else\n  {\n    v5 = &dword_80DB6E0;\n  }\n  result = *v5;\n  *(_DWORD *)(v2 + 28) = *v5;\n  *v5 = v2;\n  return result;\n}\n"
    ],
    "sub_806ED5D": [
        "0x806ed5d",
        "int __usercall sub_806ED5D@<eax>(int a1@<eax>)\n{\n  unsigned int v2; // eax\n  unsigned int v3; // ecx\n  int v4; // edx\n  int result; // eax\n  int v6; // ecx\n\n  v2 = *(_DWORD *)(a1 + 12);\n  v3 = v2 + 12 * *(_DWORD *)(a1 + 20) - 12;\n  v4 = *(_DWORD *)(v3 + 4);\n  if ( *(_BYTE *)(dword_80DBB8C + 59) )\n  {\n    while ( !v4 )\n    {\n      v3 -= 12;\n      if ( v2 > v3 )\n        break;\n      v4 = *(_DWORD *)(v3 + 4);\n    }\n  }\n  result = BYTE1(v4);\n  v6 = v4 & 0x7F;\n  if ( (v4 & 0x7F) != 0 )\n  {\n    if ( (_BYTE)v4 == 127 )\n    {\n      v6 = BYTE1(v4);\n    }\n    else if ( v6 == 2 )\n    {\n      *(_BYTE *)(a1 + 25) |= 1u;\n    }\n    return v6 + 128;\n  }\n  return result;\n}\n"
    ],
    "sub_806EDB0": [
        "0x806edb0",
        "int sub_806EDB0()\n{\n  int result; // eax\n\n  result = byte_80DB76C;\n  if ( (unsigned __int8)(byte_80DB76C - 1) <= 1u )\n  {\n    if ( --dword_80DB6A0 > 0 )\n      return 1;\n    else\n      byte_80DB76C = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_806EDE0": [
        "0x806ede0",
        "int sub_806EDE0()\n{\n  return 1;\n}\n"
    ],
    "sub_806EDE6": [
        "0x806ede6",
        "int sub_806EDE6()\n{\n  return 0;\n}\n"
    ],
    "sub_806EDE9": [
        "0x806ede9",
        "int sub_806EDE9()\n{\n  return *(unsigned __int8 *)(dword_80DBB8C + 1);\n}\n"
    ],
    "sub_806EDF3": [
        "0x806edf3",
        "char sub_806EDF3()\n{\n  char result; // al\n\n  ++*((_DWORD *)off_80DB55C + 1);\n  result = byte_80DB76F;\n  byte_80DB76E = byte_80DB76F;\n  return result;\n}\n"
    ],
    "sub_806EE06": [
        "0x806ee06",
        "void *sub_806EE06()\n{\n  void *result; // eax\n\n  result = off_80DB55C;\n  ++*((_DWORD *)off_80DB55C + 18);\n  return result;\n}\n"
    ],
    "sub_806EE0F": [
        "0x806ee0f",
        "_DWORD *sub_806EE0F()\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x4Cu);\n  *result = off_80DB55C;\n  result[2] = -1;\n  off_80DB55C = result;\n  return result;\n}\n"
    ],
    "sub_806EE2E": [
        "0x806ee2e",
        "int __usercall sub_806EE2E@<eax>(int a1@<eax>)\n{\n  int v1; // esi\n  int result; // eax\n  int v3; // ebx\n  int v4; // edx\n  _DWORD *v5; // eax\n  _DWORD *v6; // edx\n\n  v1 = dword_80DBB90;\n  if ( !a1 )\n    return *(_DWORD *)(dword_80DBB90 + 20);\n  v3 = 0;\n  do\n  {\n    v4 = v3 + 1;\n    v3 += 2;\n    if ( *(_BYTE *)a1 != 17 )\n      v3 = v4;\n    a1 = *(_DWORD *)(a1 + 4);\n  }\n  while ( a1 );\n  v5 = sub_804DB2E(8 * v3 + 8);\n  v6 = v5;\n  v5[1] = v3;\n  while ( --v3 != -1 )\n  {\n    v5[2 * v3 + 3] = -2;\n    v5[2 * v3 + 2] = -2;\n  }\n  result = *(_DWORD *)(v1 + 20);\n  *v6 = result;\n  *(_DWORD *)(v1 + 20) = v6;\n  return result;\n}\n"
    ],
    "sub_806EE89": [
        "0x806ee89",
        "void *__usercall sub_806EE89@<eax>(void *result@<eax>)\n{\n  int v1; // edx\n  void **v2; // ebx\n  void *v3; // [esp+0h] [ebp-8h]\n\n  v1 = *((_DWORD *)result + 3);\n  if ( (v1 & 1) != 0 )\n  {\n    *((_DWORD *)result + 3) = v1 | 2;\n  }\n  else\n  {\n    v2 = (void **)result;\n    v3 = *(void **)result;\n    free(*((void **)result + 1));\n    free(v2[2]);\n    free(v2);\n    return v3;\n  }\n  return result;\n}\n"
    ],
    "sub_806EEC0": [
        "0x806eec0",
        "int __usercall sub_806EEC0@<eax>(int result@<eax>)\n{\n  void **v1; // esi\n  void **i; // ebx\n  void *v3; // eax\n  int v4; // [esp-Ch] [ebp-Ch]\n\n  if ( *(_BYTE *)(result + 12) )\n  {\n    v1 = *(void ***)(result + 16);\n    for ( i = v1; ; ++i )\n    {\n      v3 = *i;\n      if ( !*i )\n        break;\n      free(v3);\n    }\n    free(v1);\n    return v4;\n  }\n  return result;\n}\n"
    ],
    "sub_806EEEB": [
        "0x806eeeb",
        "_DWORD *__usercall sub_806EEEB@<eax>(_DWORD *result@<eax>)\n{\n  int v2; // [esp-4h] [ebp-4h]\n\n  if ( result )\n  {\n    if ( --*result < 0 )\n    {\n      free(result);\n      return (_DWORD *)v2;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_806EEFB": [
        "0x806eefb",
        "int __usercall sub_806EEFB@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int v2; // ebx\n  _BYTE *v4; // eax\n  int v5; // eax\n\n  v2 = 11;\n  if ( a1 != 256 )\n  {\n    if ( a1 == 257 )\n    {\n      v5 = 0;\n      return ((int)(unsigned __int16)word_80B8564[v5] >> (4 * a2)) & 0xF;\n    }\n    v2 = 12;\n    if ( (unsigned __int8)(a1 + 127) > 7u )\n    {\n      v4 = (_BYTE *)strchrnul();\n      v2 = 0;\n      if ( *v4 )\n      {\n        v5 = (unsigned __int8)byte_80D0D31[v4 - \"\\t\\n !\\\"$&'()*-:;<=>?[\\\\]`|}~\"];\n        return ((int)(unsigned __int16)word_80B8564[v5] >> (4 * a2)) & 0xF;\n      }\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_806EF5C": [
        "0x806ef5c",
        "char *__usercall sub_806EF5C@<eax>(const char *a1@<eax>)\n{\n  dword_80DB6A4 -= (strlen(a1) + 8) & 0xFFFFFFF8;\n  return strcpy((char *)dword_80DB6A4, a1);\n}\n"
    ],
    "sub_806EF86": [
        "0x806ef86",
        "int __usercall sub_806EF86@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *v1; // ebx\n  int v2; // esi\n  char v3; // al\n  char *v4; // eax\n  char *v5; // eax\n  char *v6; // eax\n  int v7; // eax\n  int v8; // eax\n\n  v1 = a1;\n  if ( a1 )\n  {\n    v2 = dword_80DB6A8;\n    v3 = *a1;\n    dword_80DB6A8 += (unsigned __int8)byte_80D0F76[v3];\n    switch ( v3 )\n    {\n      case 0:\n        v4 = (char *)sub_806EF86();\n        goto LABEL_8;\n      case 1:\n        *(_DWORD *)(v2 + 4) = sub_806F087();\n        *(_BYTE *)(v2 + 1) = v1[1];\n        break;\n      case 2:\n      case 3:\n      case 4:\n      case 12:\n        goto LABEL_9;\n      case 5:\n      case 6:\n      case 7:\n      case 9:\n      case 10:\n        goto LABEL_6;\n      case 8:\n      case 13:\n        *(_DWORD *)(v2 + 12) = sub_806EF86();\nLABEL_6:\n        v5 = (char *)sub_806EF86();\n        goto LABEL_18;\n      case 11:\n        v4 = sub_806EF5C(*((const char **)v1 + 4));\nLABEL_8:\n        *(_DWORD *)(v2 + 16) = v4;\nLABEL_9:\n        *(_DWORD *)(v2 + 12) = sub_806EF86();\n        v6 = (char *)sub_806EF86();\n        goto LABEL_11;\n      case 14:\n        *(_DWORD *)(v2 + 12) = sub_806EF86();\n        v6 = sub_806EF5C(*((const char **)v1 + 2));\nLABEL_11:\n        *(_DWORD *)(v2 + 8) = v6;\n        v7 = *((_DWORD *)v1 + 1);\n        goto LABEL_20;\n      case 15:\n        *(_DWORD *)(v2 + 12) = sub_806F087();\n        v5 = sub_806EF5C(*((const char **)v1 + 2));\n        goto LABEL_18;\n      case 16:\n      case 17:\n      case 18:\n      case 19:\n      case 20:\n      case 21:\n        *(_DWORD *)(v2 + 16) = sub_806EF86();\n        goto LABEL_17;\n      case 22:\n      case 23:\n        *(_DWORD *)(v2 + 16) = sub_806EF86();\n        v8 = *((_DWORD *)v1 + 3);\n        goto LABEL_16;\n      case 24:\n      case 25:\n        v8 = sub_806EF86();\nLABEL_16:\n        *(_DWORD *)(v2 + 12) = v8;\nLABEL_17:\n        v5 = (char *)*((_DWORD *)v1 + 2);\nLABEL_18:\n        *(_DWORD *)(v2 + 8) = v5;\n        goto LABEL_19;\n      case 26:\nLABEL_19:\n        v7 = sub_806EF86();\nLABEL_20:\n        *(_DWORD *)(v2 + 4) = v7;\n        break;\n      default:\n        break;\n    }\n    *(_BYTE *)v2 = *v1;\n    return v2;\n  }\n  return (int)v1;\n}\n"
    ],
    "sub_806F087": [
        "0x806f087",
        "int __usercall sub_806F087@<eax>(int **a1@<eax>, int a2@<ecx>)\n{\n  int *v3; // ebx\n  int v4; // edi\n  int v6; // [esp+0h] [ebp-10h] BYREF\n\n  v6 = a2;\n  v3 = &v6;\n  while ( a1 )\n  {\n    v4 = dword_80DB6A8;\n    *v3 = dword_80DB6A8;\n    dword_80DB6A8 = v4 + 8;\n    *(_DWORD *)(v4 + 4) = sub_806EF86(a1[1]);\n    a1 = (int **)*a1;\n    v3 = (int *)*v3;\n  }\n  *v3 = 0;\n  return v6;\n}\n"
    ],
    "sub_806F0C2": [
        "0x806f0c2",
        "int *__usercall sub_806F0C2@<eax>(const char *a1@<eax>)\n{\n  int v2; // edx\n  unsigned int v3; // eax\n  const char *v4; // ecx\n  int *i; // ebx\n  int v6; // edi\n\n  v2 = *(unsigned __int8 *)a1;\n  v3 = 16 * v2;\n  v4 = a1;\n  while ( v2 )\n  {\n    v3 += v2;\n    v2 = *(unsigned __int8 *)++v4;\n  }\n  for ( i = (int *)(dword_80DB6F0 + 4 * (v3 % 0x27)); ; i = (int *)v6 )\n  {\n    v6 = *i;\n    if ( !*i || !strcmp(a1, *(const char **)(v6 + 4)) )\n      break;\n  }\n  return i;\n}\n"
    ],
    "sub_806F10D": [
        "0x806f10d",
        "int __cdecl sub_806F10D(const char *a1, char *s2)\n{\n  return strcmp(a1, (const char *)(*(_DWORD *)s2 + 1));\n}\n"
    ],
    "sub_806F11D": [
        "0x806f11d",
        "const char *__usercall sub_806F11D@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  __int16 v4; // ax\n  const char *i; // ecx\n  __int16 v6; // dx\n  const char **v7; // ebp\n  const char *j; // ebx\n  size_t v9; // eax\n\n  v4 = 16 * *(unsigned __int8 *)a1;\n  for ( i = a1; ; ++i )\n  {\n    v6 = *(unsigned __int8 *)i;\n    if ( !(_BYTE)v6 )\n      break;\n    v4 += v6;\n  }\n  v7 = (const char **)(dword_80DB6B0 + 4 * ((v4 & 0x7FFFu) % 0x1F));\n  for ( j = *v7; j; j = *(const char **)j )\n  {\n    if ( !strcmp(j + 10, a1) )\n      goto LABEL_10;\n    v7 = (const char **)j;\n  }\n  if ( a2 )\n  {\n    v9 = strlen(a1);\n    j = (const char *)sub_804DB2E(v9 + 12);\n    *v7 = j;\n    *((_BYTE *)j + 8) = -1;\n    strcpy((char *)j + 10, a1);\n  }\nLABEL_10:\n  dword_80DB6AC = (int)v7;\n  return j;\n}\n"
    ],
    "sub_806F1A1": [
        "0x806f1a1",
        "int __cdecl sub_806F1A1(const char *a1, char *s2)\n{\n  return strcmp(a1, *(const char **)s2);\n}\n"
    ],
    "sub_806F1B0": [
        "0x806f1b0",
        "int __usercall sub_806F1B0@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // ebp\n  int v3; // ecx\n  _DWORD *v4; // edi\n  _DWORD *v5; // ebx\n  int v7; // ebx\n  int v8; // ecx\n  int v9; // esi\n  int *v10; // edi\n  int v11; // eax\n  int v12; // [esp+0h] [ebp-14h] BYREF\n\n  v12 = result;\n  if ( a2 <= 1 )\n    return result;\n  v2 = a2 >> 1;\n  v3 = a2 >> 1;\n  v4 = (_DWORD *)result;\n  v5 = 0;\n  while ( --v3 != -1 )\n  {\n    v5 = v4;\n    v4 = (_DWORD *)*v4;\n  }\n  *v5 = 0;\n  v7 = sub_806F1B0(-1, a2 >> 1);\n  v9 = sub_806F1B0(v8, a2 - v2);\n  v10 = &v12;\n  while ( strcmp(*(const char **)(v9 + 4), *(const char **)(v7 + 4)) < 0 )\n  {\n    *v10 = v9;\n    v10 = (int *)v9;\n    if ( !*(_DWORD *)v9 )\n    {\n      *(_DWORD *)v9 = v7;\n      return v12;\n    }\n    v11 = v7;\n    v9 = *(_DWORD *)v9;\nLABEL_9:\n    v7 = v11;\n  }\n  *v10 = v7;\n  v10 = (int *)v7;\n  v11 = *(_DWORD *)v7;\n  if ( *(_DWORD *)v7 )\n    goto LABEL_9;\n  *(_DWORD *)v7 = v9;\n  return v12;\n}\n"
    ],
    "sub_806F22F": [
        "0x806f22f",
        "void __usercall __noreturn sub_806F22F(char a1@<al>)\n{\n  int v1; // edx\n\n  v1 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  *(_BYTE *)(v1 + 43) = a1;\n  longjmp(*(struct __jmp_buf_tag **)(v1 + 32), 1);\n}\n"
    ],
    "sub_806F249": [
        "0x806f249",
        "int __usercall sub_806F249@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebp\n  int i; // esi\n  _DWORD *v3; // edi\n  _DWORD *j; // ebx\n  const char *v5; // eax\n  int v6; // ebx\n  int result; // eax\n\n  v1 = a1;\n  for ( i = 0; a1[i]; ++i )\n    ;\n  v3 = sub_804DAFA(4 * (i + 1));\n  for ( j = v3; ; *(j - 1) = sub_804DB46(v5) )\n  {\n    v5 = *v1;\n    if ( !*v1 )\n      break;\n    ++v1;\n    ++j;\n  }\n  *j = 0;\n  v6 = dword_80DBB90;\n  result = sub_806EEC0(dword_80DBB90);\n  *(_BYTE *)(v6 + 12) = 1;\n  *(_DWORD *)v6 = i;\n  *(_DWORD *)(v6 + 16) = v3;\n  *(_DWORD *)(v6 + 4) = 1;\n  *(_DWORD *)(v6 + 8) = -1;\n  return result;\n}\n"
    ],
    "sub_806F2B1": [
        "0x806f2b1",
        "char __usercall sub_806F2B1@<al>(int a1@<eax>)\n{\n  int v2; // esi\n  _BYTE *v3; // eax\n  char v4; // bl\n  int v5; // ebp\n  int v6; // eax\n  int v8[9]; // [esp+0h] [ebp-24h] BYREF\n\n  v2 = dword_80DBB8C;\n  v3 = *(_BYTE **)(dword_80DBB8C + 4 * a1 + 192);\n  v4 = 1;\n  if ( v3 )\n    v4 = (*v3 == 0) + 2;\n  if ( *(_DWORD *)(dword_80DBB8C + 8) || v4 != 1 )\n    goto LABEL_19;\n  if ( a1 == 15 )\n  {\n    v4 = *(_BYTE *)(dword_80DBB8C + 48) == 0 ? 1 : 3;\n    goto LABEL_21;\n  }\n  if ( a1 > 15 )\n  {\n    if ( a1 == 20 || a1 == 22 )\n    {\n      v4 = *(_BYTE *)(dword_80DBB8C + 49) == 0 ? 1 : 3;\n      goto LABEL_19;\n    }\nLABEL_18:\n    v4 = 1;\nLABEL_19:\n    if ( a1 == 17 )\n      v4 = 2;\n    goto LABEL_21;\n  }\n  if ( a1 != 2 )\n  {\n    v4 = 3;\n    if ( a1 == 3 )\n      goto LABEL_21;\n    goto LABEL_18;\n  }\n  v4 = 2;\n  if ( !*(_BYTE *)(dword_80DBB8C + 48) && !*(_DWORD *)(dword_80DBB8C + 16) )\n    v4 = 2 - (*(_BYTE *)(dword_80DBB8C + 51) != 0);\nLABEL_21:\n  v5 = a1 - 1;\n  LOBYTE(v6) = *(_BYTE *)(dword_80DBB8C + a1 - 1 + 60);\n  if ( (_BYTE)v6 )\n  {\n    if ( (_BYTE)v6 == 4 )\n      return v6;\nLABEL_28:\n    if ( v4 == (_BYTE)v6 )\n      return v6;\n    goto LABEL_29;\n  }\n  v6 = sigaction(a1, 0, (struct sigaction *)v8);\n  if ( v6 )\n    return v6;\n  LOBYTE(v6) = v8[0];\n  if ( v8[0] == 1 )\n  {\n    if ( !*(_BYTE *)(v2 + 49) )\n      return v6;\n    LOBYTE(v6) = a1 - 20;\n    if ( (unsigned int)(a1 - 20) > 2 )\n      return v6;\n    LOBYTE(v6) = 3;\n    goto LABEL_28;\n  }\n  if ( !v8[0] && v4 == 1 )\n  {\n    *(_BYTE *)(v2 + v5 + 60) = 1;\n    return v6;\n  }\nLABEL_29:\n  *(_BYTE *)(v2 + v5 + 60) = v4;\n  v8[0] = 0;\n  if ( v4 == 2 )\n  {\n    v8[0] = (int)sub_806F444;\n  }\n  else if ( v4 == 3 )\n  {\n    v8[0] = 1;\n  }\n  v8[1] = 0;\n  v8[3] = -1;\n  v8[4] = -1;\n  LOBYTE(v6) = sub_804E698(a1, (const struct sigaction *)v8);\n  return v6;\n}\n"
    ],
    "sub_806F3DD": [
        "0x806f3dd",
        "int __usercall sub_806F3DD@<eax>(int result@<eax>)\n{\n  int v1; // esi\n  int v2; // ebx\n  int v3; // [esp-8h] [ebp-10h]\n\n  v1 = dword_80DBB8C;\n  v2 = result - 1;\n  if ( (unsigned __int8)(*(_BYTE *)(dword_80DBB8C + result - 1 + 60) - 3) > 1u )\n  {\n    signal(result, (__sighandler_t)1);\n    result = v3;\n  }\n  *(_BYTE *)(v1 + v2 + 60) = 4;\n  return result;\n}\n"
    ],
    "sub_806F406": [
        "0x806f406",
        "void __noreturn sub_806F406()\n{\n  int v0; // ebx\n\n  v0 = dword_80DBB8C;\n  *(_BYTE *)(dword_80DBB8C + 40) = 0;\n  sub_804E6A5(1);\n  if ( *(_DWORD *)(v0 + 8) || !*(_BYTE *)(v0 + 48) )\n  {\n    signal(2, 0);\n    raise(2);\n  }\n  *(_BYTE *)v0 = -126;\n  sub_806F22F(0);\n}\n"
    ],
    "sub_806F444": [
        "0x806f444",
        "int __cdecl sub_806F444(int a1)\n{\n  int result; // eax\n\n  result = dword_80DBB8C;\n  if ( a1 != 17 || (*(_BYTE *)(dword_80DBB8C + 41) = 1, *(_DWORD *)(result + 260)) )\n  {\n    *(_BYTE *)(result + a1 + 123) = 1;\n    *(_BYTE *)(result + 42) = a1;\n    if ( a1 == 2 && !*(_DWORD *)(result + 200) )\n    {\n      if ( !*(_DWORD *)(result + 36) )\n      {\n        *(_BYTE *)(result + 42) = 0;\n        sub_806F406();\n      }\n      *(_BYTE *)(result + 40) = 1;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_806F48C": [
        "0x806f48c",
        "char sub_806F48C()\n{\n  int v0; // eax\n  char result; // al\n\n  v0 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 36) = 0;\n  result = *(_BYTE *)(v0 + 40);\n  if ( result )\n    sub_806F406();\n  return result;\n}\n"
    ],
    "sub_806F4A5": [
        "0x806f4a5",
        "char sub_806F4A5()\n{\n  int v0; // edx\n  char result; // al\n\n  v0 = dword_80DBB8C;\n  if ( (*(_DWORD *)(dword_80DBB8C + 36))-- == 1 )\n  {\n    result = *(_BYTE *)(v0 + 40);\n    if ( result )\n      sub_806F406();\n  }\n  return result;\n}\n"
    ],
    "sub_806F4BD": [
        "0x806f4bd",
        "char sub_806F4BD()\n{\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  sub_804DD8F();\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806F4D4": [
        "0x806f4d4",
        "char __usercall sub_806F4D4@<al>(int a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // esi\n  void **v4; // edi\n  _BYTE *v5; // edx\n  char v6; // cl\n  bool v7; // cc\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v2 = dword_80DB6B0;\n  v3 = dword_80DB6B0 + 124;\nLABEL_2:\n  if ( v2 != v3 )\n  {\n    v4 = (void **)v2;\n    while ( 1 )\n    {\n      v5 = *v4;\n      if ( !*v4 )\n      {\n        v2 += 4;\n        goto LABEL_2;\n      }\n      v6 = v5[8];\n      if ( v6 )\n      {\n        if ( v6 != 2 )\n          goto LABEL_11;\n        v7 = dword_80DB554 < a1;\n      }\n      else\n      {\n        v7 = *((_DWORD *)v5 + 1) < a1;\n      }\n      if ( v7 )\n      {\nLABEL_11:\n        v4 = (void **)*v4;\n      }\n      else\n      {\n        *v4 = *(void **)v5;\n        free(v5);\n      }\n    }\n  }\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806F5DA": [
        "0x806f5da",
        "char sub_806F5DA()\n{\n  _DWORD *v0; // eax\n  _DWORD *v1; // ebx\n\n  v0 = ptr;\n  if ( ptr )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    do\n    {\n      v1 = (_DWORD *)*v0;\n      free(v0);\n      v0 = v1;\n    }\n    while ( v1 );\n    ptr = 0;\n    LOBYTE(v0) = sub_806F4A5();\n    dword_80DB6BC = 0;\n  }\n  else\n  {\n    dword_80DB6BC = 0;\n  }\n  return (char)v0;\n}\n"
    ],
    "sub_806F626": [
        "0x806f626",
        "int __usercall sub_806F626@<eax>(const char *a1@<eax>)\n{\n  void **v1; // eax\n\n  v1 = (void **)sub_806F0C2(a1);\n  if ( !*v1 )\n    return 1;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  *v1 = sub_806EE89(*v1);\n  sub_806F4A5();\n  return 0;\n}\n"
    ],
    "sub_806F659": [
        "0x806f659",
        "char sub_806F659()\n{\n  _DWORD *v0; // ebx\n  int v1; // edx\n  char v2; // al\n  int v3; // eax\n  int v4; // edx\n  _DWORD *v5; // ecx\n  int v6; // edx\n\n  v0 = (_DWORD *)*((_DWORD *)off_80DB55C + 7);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v1 = v0[3];\n  if ( v1 )\n  {\n    v2 = *(_BYTE *)(*((_DWORD *)off_80DB55C + 5) - 1);\n    if ( v2 == 32 || v2 == 9 )\n      byte_80DB76B |= 1u;\n    if ( v0[4] != *(_DWORD *)(v1 + 8) )\n      free((void *)v0[4]);\n    v3 = v0[3];\n    v4 = *(_DWORD *)(v3 + 12);\n    *(_DWORD *)(v3 + 12) = v4 & 0xFFFFFFFE;\n    if ( (v4 & 2) != 0 )\n      sub_806F626(*(const char **)(v3 + 4));\n  }\n  v5 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 5) = v0[1];\n  v5[3] = v0[2];\n  v5[18] = v0[7];\n  v6 = v0[6];\n  v5[16] = v0[5];\n  v5[17] = v6;\n  v5[7] = *v0;\n  if ( v0 != v5 + 8 )\n    free(v0);\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806F6F7": [
        "0x806f6f7",
        "char sub_806F6F7()\n{\n  void *v0; // ebx\n  char result; // al\n\n  v0 = off_80DB55C;\n  if ( off_80DB55C != &unk_80DB5E0 )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    if ( *((int *)v0 + 2) >= 0 )\n      close(*((_DWORD *)v0 + 2));\n    free(*((void **)v0 + 6));\n    while ( *((_DWORD *)v0 + 7) )\n      sub_806F659();\n    off_80DB55C = *(void **)v0;\n    free(v0);\n    return sub_806F4A5();\n  }\n  return result;\n}\n"
    ],
    "sub_806F74D": [
        "0x806f74d",
        "char __usercall sub_806F74D@<al>(const char *a1@<eax>)\n{\n  _DWORD *v2; // ebx\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  sub_806EE0F();\n  v2 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 5) = a1;\n  v2[3] = strlen(a1);\n  v2[6] = 0;\n  v2[1] = 1;\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806F78A": [
        "0x806f78a",
        "char __usercall sub_806F78A@<al>(const char *a1@<eax>, int a2@<edx>)\n{\n  size_t v4; // edi\n  _DWORD *v5; // eax\n  _DWORD *v6; // edx\n  int v7; // ebx\n\n  v4 = strlen(a1);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v5 = (char *)off_80DB55C + 32;\n  if ( *((_DWORD *)off_80DB55C + 7) )\n  {\n    v5 = sub_804DB2E(0x20u);\n    *v5 = *((_DWORD *)off_80DB55C + 7);\n  }\n  v6 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 7) = v5;\n  v5[1] = v6[5];\n  v5[2] = v6[3];\n  v5[7] = v6[18];\n  v7 = v6[17];\n  v5[5] = v6[16];\n  v5[6] = v7;\n  v5[3] = a2;\n  if ( a2 )\n  {\n    *(_DWORD *)(a2 + 12) |= 1u;\n    v5[4] = a1;\n  }\n  v6[5] = a1;\n  v6[3] = v4;\n  v6[18] = 0;\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806F817": [
        "0x806f817",
        "char sub_806F817()\n{\n  int v0; // ebx\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v0 = *(_DWORD *)dword_80DB6AC;\n  *(_DWORD *)dword_80DB6AC = **(_DWORD **)dword_80DB6AC;\n  if ( *(_BYTE *)(v0 + 8) == 1 )\n    sub_806EEEB(*(_DWORD **)(v0 + 4));\n  free((void *)v0);\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806F84B": [
        "0x806f84b",
        "int sub_806F84B()\n{\n  void *v0; // ebx\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v0 = sub_804DB2E(8u);\n  *(_DWORD *)v0 = dword_80DB694;\n  dword_80DB694 = v0;\n  sub_806F4A5();\n  return *(_DWORD *)v0;\n}\n"
    ],
    "sub_806F87B": [
        "0x806f87b",
        "char __usercall sub_806F87B@<al>(void *a1@<eax>, void *a2@<edx>, void *a3@<ecx>)\n{\n  void *v3; // esi\n  void **v6; // ebx\n\n  v3 = a1;\n  v6 = &ptr;\n  if ( dword_80DB6BC )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v6 = (void **)sub_804DB2E(0x10u);\n    *(_DWORD *)dword_80DB6BC = v6;\n    LOBYTE(a1) = sub_806F4A5();\n  }\n  dword_80DB6BC = (int)v6;\n  v6[1] = v3;\n  v6[2] = a2;\n  v6[3] = a3;\n  return (char)a1;\n}\n"
    ],
    "sub_806F8CC": [
        "0x806f8cc",
        "char __usercall sub_806F8CC@<al>(int a1@<eax>)\n{\n  int v1; // ebx\n  void *v2; // esi\n  char v3; // dl\n  void **i; // eax\n  _DWORD *v5; // esi\n  int v6; // edi\n\n  if ( dword_80DB6BC )\n  {\n    v1 = a1;\n    if ( dword_80DB6C8 <= a1 )\n    {\n      dword_80DB6BC = (int)&ptr;\n      v3 = 0;\n      for ( i = &ptr; *i; i = (void **)*i )\n      {\n        if ( *((_DWORD *)*i + 1) >= v1 )\n        {\n          if ( v3 )\n            dword_80DB6BC = (int)i;\n          while ( 1 )\n          {\n            a1 = dword_80DB6BC;\n            if ( !*(_DWORD *)dword_80DB6BC )\n              break;\n            ++*(_DWORD *)(dword_80DBB8C + 36);\n            v5 = (_DWORD *)dword_80DB6BC;\n            v6 = **(_DWORD **)dword_80DB6BC;\n            free(*(void **)dword_80DB6BC);\n            *v5 = v6;\n            sub_806F4A5();\n          }\n          goto LABEL_19;\n        }\n        v3 = 1;\n      }\n      if ( v3 )\n        dword_80DB6BC = (int)i;\n      a1 = dword_80DB6BC;\nLABEL_19:\n      if ( *(_DWORD *)(a1 + 8) > v1 )\n        *(_DWORD *)(a1 + 8) = v1;\n    }\n    else\n    {\n      while ( ptr )\n      {\n        ++*(_DWORD *)(dword_80DBB8C + 36);\n        v2 = *(void **)ptr;\n        free(ptr);\n        ptr = v2;\n        LOBYTE(a1) = sub_806F4A5();\n      }\n      if ( dword_80DB6C4 <= v1 )\n      {\n        dword_80DB6BC = (int)&ptr;\n        dword_80DB6C8 = v1;\n      }\n      else\n      {\n        dword_80DB6BC = 0;\n      }\n    }\n  }\n  return a1;\n}\n"
    ],
    "sub_806F9B7": [
        "0x806f9b7",
        "char __usercall sub_806F9B7@<al>(int a1@<eax>)\n{\n  int v2; // edi\n  int v3; // esi\n  int i; // ebp\n  void *v5; // eax\n\n  v2 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v3 = *(_DWORD *)(a1 + 20);\n  for ( i = *(_DWORD *)(a1 + 12); --v3 >= 0; i += 12 )\n  {\n    v5 = *(void **)(i + 8);\n    if ( v5 != (void *)(v2 + 44) )\n      free(v5);\n  }\n  if ( *(_DWORD *)(a1 + 12) != a1 )\n    free(*(void **)(a1 + 12));\n  *(_BYTE *)(a1 + 25) &= ~8u;\n  sub_806ED0E(a1, 2);\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806FA10": [
        "0x806fa10",
        "char __usercall sub_806FA10@<al>(_DWORD *a1@<eax>)\n{\n  _DWORD *v1; // ebx\n  int v2; // eax\n  _DWORD *v3; // edx\n  int v4; // edx\n  int v5; // ecx\n\n  if ( *a1 )\n  {\n    v1 = a1;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    while ( 1 )\n    {\n      v2 = dword_80DBB88;\n      v3 = *(_DWORD **)dword_80DBB88;\n      if ( *(_DWORD *)dword_80DBB88 == *v1 )\n        break;\n      *(_DWORD *)dword_80DBB88 = *v3;\n      free(v3);\n    }\n    v4 = v1[1];\n    *(_DWORD *)(dword_80DBB88 + 4) = v4;\n    v5 = v1[2];\n    *(_DWORD *)(v2 + 12) = v5;\n    *(_DWORD *)(v2 + 8) = v5 + v4;\n    LOBYTE(a1) = sub_806F4A5();\n  }\n  return (char)a1;\n}\n"
    ],
    "sub_806FA55": [
        "0x806fa55",
        "int sub_806FA55()\n{\n  int result; // eax\n\n  do\n    result = fcntl64();\n  while ( result < 0 && (*(_DWORD *)dword_80DBB7C == 4 || *(_DWORD *)dword_80DBB7C == 16) );\n  return result;\n}\n"
    ],
    "sub_806FA86": [
        "0x806fa86",
        "char __usercall sub_806FA86@<al>(FILE *a1@<eax>)\n{\n  char *IO_write_base; // eax\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  IO_write_base = a1->_IO_write_base;\n  if ( IO_write_base >= a1->_IO_buf_base )\n  {\n    __fputc_unlocked();\n  }\n  else\n  {\n    a1->_IO_write_base = IO_write_base + 1;\n    *IO_write_base = 10;\n  }\n  fflush(a1);\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806FAC0": [
        "0x806fac0",
        "char __usercall sub_806FAC0@<al>(const char *a1@<eax>, void *a2@<edx>)\n{\n  int v4; // ebx\n  const char *v5; // esi\n\n  v4 = dword_80DBB8C;\n  fprintf(stderr, \"%s: \", *(const char **)(dword_80DBB8C + 28));\n  v5 = dword_80DB70C;\n  if ( dword_80DB70C )\n  {\n    if ( strcmp(*(const char **)(v4 + 28), dword_80DB70C) )\n      fprintf(stderr, \"%s: \", v5);\n    if ( !*(_BYTE *)(v4 + 48) || *((int *)off_80DB55C + 2) > 0 )\n      fprintf(stderr, \"line %d: \", *(_DWORD *)(v4 + 12));\n  }\n  vfprintf(stderr, a1, a2);\n  return sub_806FA86(stderr);\n}\n"
    ],
    "sub_806FB57": [
        "0x806fb57",
        "void __noreturn sub_806FB57(const char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  *(_BYTE *)dword_80DBB8C = 2;\n  sub_806FAC0(a1, va);\n  sub_806F4BD();\n  sub_806F22F(1);\n}\n"
    ],
    "sub_806FB7B": [
        "0x806fb7b",
        "_DWORD *__usercall sub_806FB7B@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // edi\n  _DWORD *v4; // eax\n  int v5; // ebx\n  _DWORD *v6; // ecx\n  _DWORD *v7; // ebp\n  const char *v8; // ebx\n  int v9; // eax\n  void (*v10)(void); // esi\n  char *v11; // edx\n  char v12; // al\n  unsigned int v13; // esi\n  _DWORD *v15; // [esp+0h] [ebp-14h]\n  _DWORD *v16; // [esp+0h] [ebp-14h]\n  _DWORD *v17; // [esp+0h] [ebp-14h]\n\n  v2 = (char *)a1;\n  v4 = (_DWORD *)sub_806ECAC(a1);\n  v5 = a2 | *(_BYTE *)(dword_80DBB8C + 55) & 1;\n  v6 = sub_806ECE9(v4, (int)v2);\n  v7 = (_DWORD *)*v6;\n  if ( !*v6 )\n  {\n    v13 = v5;\n    if ( (v5 & 0x80u) != 0 )\n      return v7;\n    if ( (v5 & 0x27) == 32 )\n      goto LABEL_17;\n    v17 = v6;\n    v7 = sub_804DB2E(0x10u);\n    *v7 = *v17;\n    *v17 = v7;\nLABEL_23:\n    if ( (v13 & 0x118) == 0 )\n      v2 = sub_804DB46(v2);\n    v7[2] = v2;\n    v7[1] = v13;\n    return v7;\n  }\n  if ( (v7[1] & 0x202) == 2 )\n  {\n    if ( (v5 & 0x100) != 0 )\n      free(v2);\n    v8 = (const char *)v7[2];\n    *(_BYTE *)dword_80DBB8C = 1;\n    v9 = strchrnul();\n    sub_806FB57(\"%.*s: is read only\", v9 - (_DWORD)v8, v8);\n  }\n  if ( (v5 & 0x80u) == 0 )\n  {\n    v10 = (void (*)(void))v7[3];\n    if ( v10 && (v5 & 0x40) == 0 )\n    {\n      v11 = v2;\n      do\n      {\n        v12 = *v11;\n        if ( !*v11 )\n          break;\n        ++v11;\n      }\n      while ( v12 != 61 );\n      v15 = v6;\n      v10();\n      v6 = v15;\n    }\n    if ( (v7[1] & 0x18) == 0 )\n    {\n      v16 = v6;\n      free((void *)v7[2]);\n      v6 = v16;\n    }\n    if ( (v7[1] & 4 | v5 & 0x27) == 32 )\n    {\n      *v6 = *v7;\n      free(v7);\nLABEL_17:\n      if ( (v5 & 0x118) == 256 )\n        free(v2);\n      return v7;\n    }\n    v13 = v5 | v7[1] & 0xFFFFFEC7;\n    goto LABEL_23;\n  }\n  return v7;\n}\n"
    ],
    "sub_806FCB3": [
        "0x806fcb3",
        "char __usercall sub_806FCB3@<al>(int **a1@<eax>, int a2@<edx>)\n{\n  int **v2; // ebx\n\n  if ( a1 )\n  {\n    v2 = a1;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    do\n    {\n      sub_806FB7B((unsigned __int8 *)v2[1], a2);\n      v2 = (int **)*v2;\n    }\n    while ( v2 );\n    LOBYTE(a1) = sub_806F4A5();\n  }\n  return (char)a1;\n}\n"
    ],
    "sub_806FCE2": [
        "0x806fce2",
        "_DWORD *__usercall sub_806FCE2@<eax>(const char *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  int v5; // edi\n  int v6; // eax\n  int v7; // ebp\n  size_t v8; // ecx\n  unsigned __int8 *v9; // edi\n  _BYTE *v10; // eax\n  int v11; // edx\n  _DWORD *v14; // [esp+0h] [ebp-18h]\n\n  v5 = sub_80AB128();\n  v6 = strchrnul();\n  v7 = v6 - (_DWORD)a1;\n  if ( (const char *)v6 == a1 || v5 != v6 )\n    sub_806FB57(\"%.*s: bad variable name\", v6 - (_DWORD)a1, a1);\n  if ( a2 )\n  {\n    v8 = strlen(a2);\n  }\n  else\n  {\n    a3 |= 0x20u;\n    v8 = 0;\n  }\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v9 = (unsigned __int8 *)sub_804DAFA(v8 + v7 + 2);\n  v10 = (_BYTE *)mempcpy();\n  if ( a2 )\n  {\n    *v10 = 61;\n    v10 = (_BYTE *)mempcpy();\n  }\n  *v10 = 0;\n  v11 = a3;\n  BYTE1(v11) = BYTE1(a3) | 1;\n  v14 = sub_806FB7B(v9, v11);\n  sub_806F4A5();\n  return v14;\n}\n"
    ],
    "sub_806FDFD": [
        "0x806fdfd",
        "_DWORD *__usercall sub_806FDFD@<eax>(const char *a1@<eax>)\n{\n  return sub_806FCE2(a1, 0, 0);\n}\n"
    ],
    "sub_806FE06": [
        "0x806fe06",
        "_DWORD *__usercall sub_806FE06@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  return sub_806FCE2(a1, a2, 0);\n}\n"
    ],
    "sub_806FE0D": [
        "0x806fe0d",
        "int __usercall sub_806FE0D@<eax>(char *a1@<eax>)\n{\n  if ( !sub_806EC60(a1) )\n    sub_806FB57(\"Illegal number: %s\", a1);\n  return atoi(a1);\n}\n"
    ],
    "sub_806FE64": [
        "0x806fe64",
        "int __fastcall sub_806FE64(int a1, int a2)\n{\n  char *v2; // eax\n  int v3; // ebx\n  int v4; // esi\n  int result; // eax\n  void **v6; // eax\n  void **v7; // ebp\n  int v8; // edi\n  void **v9; // ebx\n  int v10; // ecx\n  int v11; // eax\n  void *v12; // edx\n  void **v13; // [esp+0h] [ebp-14h]\n\n  v2 = *(char **)(a2 + 4);\n  v3 = 1;\n  if ( v2 )\n    v3 = sub_806FE0D(v2);\n  v4 = dword_80DBB90;\n  result = 1;\n  if ( *(_DWORD *)dword_80DBB90 >= v3 )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    *(_DWORD *)v4 -= v3;\n    v6 = *(void ***)(v4 + 16);\n    v7 = v6;\n    v8 = v3;\n    while ( --v8 >= 0 )\n    {\n      if ( *(_BYTE *)(v4 + 12) )\n      {\n        v13 = v6;\n        free(*v7);\n        v6 = v13;\n      }\n      ++v7;\n    }\n    if ( v3 < 0 )\n      v3 = 0;\n    v9 = &v6[v3];\n    v10 = *(_DWORD *)(v4 + 16);\n    v11 = 0;\n    do\n    {\n      v12 = v9[v11];\n      *(_DWORD *)(v10 + v11 * 4) = v12;\n      ++v11;\n    }\n    while ( v12 );\n    *(_DWORD *)(v4 + 4) = 1;\n    *(_DWORD *)(v4 + 8) = -1;\n    sub_806F4A5();\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_806FEF4": [
        "0x806fef4",
        "int __fastcall sub_806FEF4(int a1, int a2)\n{\n  char *v2; // eax\n\n  byte_80DB76C = 4;\n  v2 = *(char **)(a2 + 4);\n  if ( v2 )\n    return sub_806FE0D(v2);\n  else\n    return *(unsigned __int8 *)dword_80DBB8C;\n}\n"
    ],
    "sub_806FF10": [
        "0x806ff10",
        "int __usercall sub_806FF10@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = a2;\n  if ( a1 != a2 )\n    result = dup2(a1, a2);\n  if ( result < 0 )\n    sub_806FB57(\"%d: %m\", a1);\n  return result;\n}\n"
    ],
    "sub_806FF33": [
        "0x806ff33",
        "char __usercall sub_806FF33@<al>(int a1@<eax>, char a2@<dl>)\n{\n  int v2; // ebp\n  _DWORD *v4; // ebx\n  int i; // esi\n  int v6; // ecx\n  int v8; // [esp+0h] [ebp-14h]\n\n  v2 = dword_80DBB90;\n  if ( !*(_DWORD *)(dword_80DBB90 + 20) )\n    return a2;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v4 = *(_DWORD **)(v2 + 20);\n  for ( i = 0; v4[1] > i; ++i )\n  {\n    v6 = v4[2 * i + 3];\n    if ( v6 == -1 )\n    {\n      if ( !a1 )\n        close(v4[2 * i + 2]);\n    }\n    else if ( v6 != -2 )\n    {\n      if ( !a1 )\n      {\n        v8 = v4[2 * i + 3];\n        sub_806FF10(v8, v4[2 * i + 2]);\n        v6 = v8;\n      }\n      close(v6);\n    }\n  }\n  *(_DWORD *)(v2 + 20) = *v4;\n  free(v4);\n  return sub_806F4A5();\n}\n"
    ],
    "sub_806FFAE": [
        "0x806ffae",
        "int __usercall sub_806FFAE@<eax>(int a1@<eax>, __pid_t a2@<edx>)\n{\n  int result; // eax\n\n  result = tcsetpgrp(a1, a2);\n  if ( result )\n    sub_806FB57(\"can't set tty process group: %m\");\n  return result;\n}\n"
    ],
    "sub_806FFC6": [
        "0x806ffc6",
        "int __usercall sub_806FFC6@<eax>(int a1@<eax>)\n{\n  unsigned int v1; // esi\n  _DWORD *v2; // ebx\n  unsigned int v3; // edi\n  _DWORD *v4; // eax\n  int result; // eax\n\n  v1 = (a1 + 7) & 0xFFFFFFF8;\n  v2 = (_DWORD *)dword_80DBB88;\n  if ( *(_DWORD *)(dword_80DBB88 + 12) < v1 )\n  {\n    v3 = (a1 + 7) & 0xFFFFFFF8;\n    if ( v1 < 0x1F8 )\n      v3 = 504;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v4 = sub_804DAFA(v3 + 4);\n    *v4 = *v2;\n    v2[1] = v4 + 1;\n    v2[3] = v3;\n    v2[2] = (char *)v4 + v3 + 4;\n    *v2 = v4;\n    sub_806F4A5();\n  }\n  result = v2[1];\n  v2[1] = result + v1;\n  v2[3] -= v1;\n  return result;\n}\n"
    ],
    "sub_8070037": [
        "0x8070037",
        "int __usercall sub_8070037@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  int v2; // ecx\n\n  v2 = dword_80DBB88;\n  *a1 = *(_DWORD *)dword_80DBB88;\n  a1[1] = *(_DWORD *)(v2 + 4);\n  a1[2] = *(_DWORD *)(v2 + 12);\n  return sub_806FFC6(a2);\n}\n"
    ],
    "sub_8070056": [
        "0x8070056",
        "int __usercall sub_8070056@<eax>(_DWORD *a1@<eax>)\n{\n  int v1; // edx\n\n  v1 = 0;\n  if ( *(_DWORD *)(dword_80DBB88 + 4) == *(_DWORD *)dword_80DBB88 + 4 )\n    v1 = *(_DWORD *)dword_80DBB88 != dword_80DBB88 + 16;\n  return sub_8070037(a1, v1);\n}\n"
    ],
    "sub_807007B": [
        "0x807007b",
        "char *__usercall sub_807007B@<eax>(const char *a1@<eax>)\n{\n  size_t v2; // ebx\n  char *result; // eax\n\n  v2 = strlen(a1) + 1;\n  result = (char *)sub_806FFC6(v2);\n  qmemcpy(result, a1, v2);\n  return result;\n}\n"
    ],
    "sub_807009B": [
        "0x807009b",
        "int __usercall sub_807009B@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  _BYTE *v4; // esi\n  int v5; // eax\n  int v6; // ebx\n  int v7; // esi\n  _DWORD *v8; // ebx\n  _DWORD *v9; // eax\n\n  v4 = (_BYTE *)dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v5 = open64();\n  v6 = v5;\n  if ( v5 < 0 )\n  {\n    if ( (a2 & 2) == 0 )\n    {\n      *v4 = 127;\n      sub_806FB57(\"can't open '%s': %m\", a1);\n    }\n    goto LABEL_16;\n  }\n  if ( v5 > 9 )\n  {\n    v7 = v5;\n    goto LABEL_11;\n  }\n  v7 = fcntl64();\n  if ( v7 >= 0 )\n    goto LABEL_9;\n  if ( *(_DWORD *)dword_80DBB7C != 9 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C )\n      sub_806FB57(\"%d: %m\", v6);\nLABEL_9:\n    close(v6);\n  }\nLABEL_11:\n  if ( (a2 & 1) != 0 )\n  {\n    sub_806EE0F();\n    *((_DWORD *)off_80DB55C + 6) = 0;\n  }\n  v8 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 2) = v7;\n  if ( !v8[6] )\n    v8[6] = sub_804DAFA(0x400u);\n  v9 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 4) = 0;\n  v9[3] = 0;\n  v9[1] = 1;\n  v6 = v7;\nLABEL_16:\n  sub_806F4A5();\n  return v6;\n}\n"
    ],
    "sub_8070172": [
        "0x8070172",
        "void __usercall __noreturn sub_8070172(const char *a1@<eax>)\n{\n  *(_DWORD *)(dword_80DBB8C + 12) = *((_DWORD *)off_80DB55C + 1);\n  sub_806FB57(\"syntax error: %s\", a1);\n}\n"
    ],
    "sub_807023E": [
        "0x807023e",
        "void __noreturn sub_807023E()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_807028A": [
        "0x807028a",
        "void __noreturn sub_807028A()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8070322": [
        "0x8070322",
        "void __noreturn sub_8070322()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8070349": [
        "0x8070349",
        "int __usercall sub_8070349@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  char *v4; // edi\n  int v5; // eax\n  char v6; // bl\n  const char *v7; // ebx\n  unsigned int v8; // eax\n  void *v9; // edx\n  int v10; // ecx\n  _BYTE *v11; // eax\n  void *v14; // [esp+4h] [ebp-18h]\n  int v15; // [esp+8h] [ebp-14h]\n\n  v3 = dword_80DB6E0;\n  if ( !a1 )\n    goto LABEL_10;\n  if ( *a1 != 37 )\n    goto LABEL_28;\n  v4 = a1 + 1;\n  v5 = (unsigned __int8)a1[1];\n  v6 = v5;\n  if ( !v5 )\n    goto LABEL_10;\n  if ( a1[2] )\n    goto LABEL_11;\n  if ( v5 == 37 || v5 == 43 )\n  {\nLABEL_10:\n    v7 = \"No current job\";\n    goto LABEL_24;\n  }\n  if ( v5 == 45 )\n  {\n    if ( !dword_80DB6E0 )\n    {\n      v7 = \"No previous job\";\n      goto LABEL_30;\n    }\n    v3 = *(_DWORD *)(dword_80DB6E0 + 28);\n    v7 = \"No previous job\";\nLABEL_24:\n    if ( v3 )\n      goto LABEL_25;\nLABEL_30:\n    sub_806FB57(v7, a1);\n  }\nLABEL_11:\n  if ( !sub_806EC60(v4) || (v8 = atoi(v4)) == 0 || dword_80DB6E4 < v8 )\n  {\n    v9 = sub_806EC47;\n    if ( v6 == 63 )\n    {\n      v4 = a1 + 2;\n      v9 = strstr;\n    }\n    v10 = v3;\n    v7 = \"%s: no such job\";\n    v3 = 0;\n    while ( v10 )\n    {\n      v15 = v10;\n      v14 = v9;\n      v11 = ((_BYTE *(__cdecl *)(_BYTE *, char *))v9)(*(_BYTE **)(*(_DWORD *)(v10 + 12) + 8), v4);\n      v9 = v14;\n      if ( v11 )\n      {\n        if ( v3 )\n          goto LABEL_30;\n        v3 = v15;\n        v7 = \"%s: ambiguous\";\n      }\n      v10 = *(_DWORD *)(v15 + 28);\n    }\n    goto LABEL_24;\n  }\n  v3 = dword_80DB6E8 + 32 * (v8 + 0x7FFFFFF);\n  if ( (*(_BYTE *)(v3 + 25) & 8) == 0 )\nLABEL_28:\n    sub_806FB57(\"%s: no such job\", a1);\nLABEL_25:\n  if ( a2 && (*(_BYTE *)(v3 + 25) & 2) == 0 )\n    sub_806FB57(\"job %s not created under job control\", a1);\n  return v3;\n}\n"
    ],
    "sub_8070461": [
        "0x8070461",
        "int __usercall sub_8070461@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // eax\n\n  do\n  {\n    v2 = fcntl64();\n    if ( v2 >= 0 )\n    {\n      close(a1);\n      return v2;\n    }\n    v3 = *(_DWORD *)dword_80DBB7C;\n  }\n  while ( *(_DWORD *)dword_80DBB7C == 4 || v3 == 16 );\n  if ( v3 != 9 )\n    sub_806FB57(\"%d: %m\", v2);\n  return a1;\n}\n"
    ],
    "sub_80704B0": [
        "0x80704b0",
        "int __fastcall sub_80704B0(int a1, _BYTE **a2)\n{\n  const char *v3; // ebx\n  int v4; // eax\n  int v5; // ecx\n\n  v3 = a2[1];\n  if ( v3 )\n  {\n    v4 = sub_806FE0D(a2[1]);\n    if ( v4 <= 0 )\n      sub_806FB57(\"Illegal number: %s\", v3);\n  }\n  else\n  {\n    v4 = 1;\n  }\n  v5 = dword_80DB69C;\n  if ( v4 <= dword_80DB69C )\n  {\n    v5 = v4;\nLABEL_9:\n    byte_80DB76C = (**a2 == 99) + 1;\n    dword_80DB6A0 = v5;\n    return 0;\n  }\n  if ( dword_80DB69C > 0 )\n    goto LABEL_9;\n  return 0;\n}\n"
    ],
    "sub_8070501": [
        "0x8070501",
        "char sub_8070501(const char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_806FAC0(a1, va);\n}\n"
    ],
    "sub_807050F": [
        "0x807050f",
        "__pid_t __usercall sub_807050F@<eax>(__pid_t result@<eax>, __pid_t a2@<esi>)\n{\n  __pid_t v2; // edi\n  char v3; // si\n  int v4; // ebp\n  int v5; // ebx\n  int v6; // ebx\n  __pid_t v7; // edx\n  __pid_t v8; // eax\n  __pid_t v9; // esi\n\n  if ( byte_80DB76D != result )\n  {\n    v2 = *(_DWORD *)(dword_80DBB8C + 8);\n    if ( !v2 )\n    {\n      v3 = result;\n      if ( result )\n      {\n        v4 = open64();\n        if ( v4 < 0 )\n        {\n          v5 = 2;\n          while ( !isatty(v5) )\n          {\n            if ( --v5 == -1 )\n            {\n              v6 = -1;\n              goto LABEL_13;\n            }\n          }\n        }\n        v6 = fcntl64();\n        if ( v4 >= 0 )\n          close(v4);\n        if ( v6 >= 0 )\n        {\n          while ( 1 )\n          {\n            v7 = tcgetpgrp(v6);\n            if ( v7 < 0 )\n              break;\n            a2 = v7;\n            v8 = getpgrp();\n            if ( v8 == a2 )\n            {\n              pgid = v8;\n              sub_806F2B1(20);\n              sub_806F2B1(22);\n              sub_806F2B1(21);\n              v2 = *(_DWORD *)(dword_80DBB8C + 4);\n              setpgid(0, v2);\n              sub_806FFAE(v6, v2);\n              LOBYTE(v2) = v3;\n              goto LABEL_21;\n            }\n            killpg(0, 21);\n          }\n        }\nLABEL_13:\n        sub_8070501(\"can't access tty; job control turned off\");\n        *(_BYTE *)(dword_80DBB8C + 49) = 0;\n      }\n      else\n      {\n        v6 = dword_80DB558;\n        v9 = pgid;\n        tcsetpgrp(dword_80DB558, pgid);\n        setpgid(0, v9);\n        sub_806F2B1(20);\n        sub_806F2B1(22);\n        sub_806F2B1(21);\n      }\n      if ( v6 >= 0 )\n        close(v6);\n      v6 = -1;\nLABEL_21:\n      dword_80DB558 = v6;\n      byte_80DB76D = v2;\n    }\n    return a2;\n  }\n  return result;\n}\n"
    ],
    "sub_8070672": [
        "0x8070672",
        "int __usercall sub_8070672@<eax>(__pid_t a1@<esi>)\n{\n  int v1; // ebx\n  int result; // eax\n\n  v1 = dword_80DBB8C;\n  if ( *(unsigned __int8 *)(dword_80DBB8C + 48) + 1 != byte_80DB767 )\n  {\n    byte_80DB767 = *(_BYTE *)(dword_80DBB8C + 48) + 1;\n    sub_806F2B1(2);\n    sub_806F2B1(3);\n    sub_806F2B1(15);\n  }\n  sub_807050F(*(unsigned __int8 *)(v1 + 49), a1);\n  result = dword_80DB6F8;\n  if ( *(_BYTE *)(v1 + 58) )\n    *(_DWORD *)dword_80DB6F8 |= 8u;\n  else\n    *(_DWORD *)dword_80DB6F8 &= ~8u;\n  return result;\n}\n"
    ],
    "sub_80706CA": [
        "0x80706ca",
        "char __usercall sub_80706CA@<al>(int a1@<eax>)\n{\n  char *v2; // edi\n  int v3; // esi\n  _DWORD *i; // ebp\n  int v5; // eax\n  _DWORD *v6; // ebp\n  void *v7; // eax\n  _DWORD *v8; // esi\n  _DWORD *v9; // eax\n  _DWORD *v10; // eax\n  int v11; // eax\n  _DWORD *v12; // eax\n\n  v2 = strchr((const char *)a1, 61);\n  v3 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  for ( i = (_DWORD *)*((_DWORD *)dword_80DB694 + 1); i; i = (_DWORD *)*i )\n  {\n    v5 = i[1];\n    if ( v5 && !sub_806EC79(*(_DWORD *)(v5 + 8), a1) )\n    {\n      if ( v2 )\n        sub_806FB7B((unsigned __int8 *)a1, 0);\n      return sub_806F4A5();\n    }\n  }\n  v6 = sub_804DB2E(0x10u);\n  if ( *(_BYTE *)a1 != 45 || *(_BYTE *)(a1 + 1) )\n  {\n    v9 = (_DWORD *)sub_806ECAC((unsigned __int8 *)a1);\n    v8 = (_DWORD *)*sub_806ECE9(v9, a1);\n    if ( v8 )\n    {\n      v6[3] = v8[2];\n      v11 = v8[1];\n      v6[2] = v11;\n      v8[1] = v11 | 0xC;\n      if ( v2 )\n        sub_806FB7B((unsigned __int8 *)a1, 0);\n      else\n        sub_806FE06((const char *)a1, 0);\n    }\n    else\n    {\n      if ( v2 )\n        v10 = sub_806FB7B((unsigned __int8 *)a1, 4);\n      else\n        v10 = sub_806FCE2((const char *)a1, 0, 4);\n      v8 = v10;\n      v6[2] = 32;\n    }\n  }\n  else\n  {\n    v7 = sub_804DAFA(0xFu);\n    qmemcpy(v7, (const void *)(v3 + 45), 0xFu);\n    v6[3] = v7;\n    v8 = 0;\n  }\n  v6[1] = v8;\n  v12 = dword_80DB694;\n  *v6 = *((_DWORD *)dword_80DB694 + 1);\n  v12[1] = v6;\n  return sub_806F4A5();\n}\n"
    ],
    "sub_80707D8": [
        "0x80707d8",
        "int sub_80707D8()\n{\n  int v0; // ebx\n  int result; // eax\n\n  if ( !dword_80DB694 )\n    sub_806FB57(\"not in a function\");\n  v0 = dword_80DB708;\n  while ( 1 )\n  {\n    v0 += 4;\n    result = *(_DWORD *)(v0 - 4);\n    if ( !result )\n      break;\n    sub_80706CA(result);\n  }\n  return result;\n}\n"
    ],
    "sub_8070805": [
        "0x8070805",
        "_DWORD *__usercall sub_8070805@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  char *v4; // ebx\n  char *v5; // eax\n  char *v6; // edi\n  char *v7; // eax\n  char *v9; // [esp+0h] [ebp-14h]\n\n  v3 = dword_80DBB8C;\n  v4 = *(char **)(dword_80DBB8C + 20);\n  if ( a2 )\n    sub_806FCE2(\"OLDPWD\", *(const char **)(dword_80DBB8C + 20), 1);\n  ++*(_DWORD *)(v3 + 36);\n  v5 = *(char **)(v3 + 24);\n  v6 = (char *)(v3 + 44);\n  if ( v5 != (char *)(v3 + 44) )\n  {\n    if ( v5 != v4 )\n      free(*(void **)(v3 + 24));\n    *(_DWORD *)(v3 + 24) = v6;\n  }\n  if ( a1 && v4 != a1 )\n  {\n    v7 = sub_804DB46(a1);\nLABEL_14:\n    if ( v7 != v4 )\n    {\n      if ( v6 != v4 )\n      {\n        v9 = v7;\n        free(v4);\n        v7 = v9;\n      }\n      v4 = v7;\n    }\n    goto LABEL_18;\n  }\n  v7 = getcwd(0, 0);\n  if ( !v7 )\n    v7 = (char *)(v3 + 44);\n  *(_DWORD *)(v3 + 24) = v7;\n  if ( !a1 )\n    goto LABEL_14;\nLABEL_18:\n  *(_DWORD *)(v3 + 20) = v4;\n  sub_806F4A5();\n  return sub_806FCE2(\"PWD\", v4, 1);\n}\n"
    ],
    "sub_80708A7": [
        "0x80708a7",
        "decompilation failure at 80708A7!\n"
    ],
    "sub_80708D4": [
        "0x80708d4",
        "int __usercall sub_80708D4@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v2; // ebx\n  const char *v4; // edi\n  int v5; // eax\n  int v6; // ecx\n  _BYTE *v7; // edx\n  char v8; // al\n  char v9; // al\n  int v10; // esi\n  const char *v11; // edx\n  int v12; // ecx\n  int v13; // eax\n  char v14; // dl\n  char *v15; // ecx\n  int v16; // edx\n  const char *v18; // [esp+0h] [ebp-18h]\n  int i; // [esp+0h] [ebp-18h]\n  int v20; // [esp+4h] [ebp-14h]\n  char *v21; // [esp+4h] [ebp-14h]\n\n  v2 = a1;\n  if ( a1 )\n    *(_DWORD *)(dword_80DBB8C + 16) = 0;\nLABEL_13:\n  v6 = dword_80DB708;\n  v7 = *(_BYTE **)dword_80DB708;\n  if ( !*(_DWORD *)dword_80DB708 )\n    return 0;\n  v4 = v7 + 1;\n  v8 = *v7;\n  if ( ((*v7 - 43) & 0xFD) != 0 )\n    return 0;\n  dword_80DB708 += 4;\n  if ( v8 != 45 )\n  {\n    v10 = 0;\n    goto LABEL_5;\n  }\n  v9 = v7[1];\n  if ( !v9 )\n  {\n    if ( !v2 )\n    {\n      *(_WORD *)(dword_80DBB8C + 52) = 0;\n      return v2;\n    }\n    return 0;\n  }\n  if ( v9 != 45 || v7[2] )\n  {\n    v10 = 1;\n    while ( 1 )\n    {\nLABEL_5:\n      v5 = *(unsigned __int8 *)v4++;\n      if ( !*(v4 - 1) )\n        goto LABEL_13;\n      if ( v5 == 99 )\n      {\n        if ( !v2 )\n          goto LABEL_42;\n        *(_DWORD *)(dword_80DBB8C + 16) = v4;\n      }\n      else if ( v5 == 111 )\n      {\n        v11 = *(const char **)dword_80DB708;\n        if ( *(_DWORD *)dword_80DB708 )\n        {\n          v12 = 0;\n          do\n          {\n            v20 = v12;\n            v18 = v11;\n            v13 = strcmp(v11, off_80B5FE0[v12] + 1);\n            v11 = v18;\n            if ( !v13 )\n            {\n              *(_BYTE *)(dword_80DBB8C + v20 + 45) = v10;\n              goto LABEL_36;\n            }\n            v12 = v20 + 1;\n          }\n          while ( v20 != 14 );\n          sub_8070501(\"illegal option %co %s\", v10 == 0 ? 43 : 45, v18);\n          return 1;\n        }\n        for ( i = 0; i != 15; ++i )\n        {\n          v21 = off_80B5FE0[i];\n          v14 = *(_BYTE *)(dword_80DBB8C + i + 45);\n          if ( v10 )\n          {\n            v15 = \"can't access tty; job control turned off\" + 37;\n            if ( v14 )\n              v15 = \"on\";\n            sub_80708A7(\"%-16s%s\\n\", v21 + 1, v15);\n          }\n          else\n          {\n            sub_80708A7(\"set %co %s\\n\", v14 == 0 ? 43 : 45, v21 + 1);\n          }\n        }\nLABEL_36:\n        if ( *(_DWORD *)dword_80DB708 )\n          dword_80DB708 += 4;\n      }\n      else\n      {\n        if ( !v2 )\n          goto LABEL_42;\n        if ( v5 == 108 )\n        {\n          if ( a2 )\n            *a2 = 1;\n        }\n        else\n        {\n          if ( v5 == 45 && v10 )\n          {\n            if ( !strcmp(v4, \"login\") && a2 )\n              *a2 = 1;\n            goto LABEL_13;\n          }\nLABEL_42:\n          v16 = 0;\n          while ( v5 != (unsigned __int8)*off_80B5FE0[v16] )\n          {\n            if ( ++v16 == 15 )\n              sub_806FB57(\"illegal option %c%c\", v10 == 0 ? 43 : 45, *((unsigned __int8 *)v4 - 1));\n          }\n          *(_BYTE *)(dword_80DBB8C + v16 + 45) = v10;\n        }\n      }\n    }\n  }\n  if ( !v2 && !*(_DWORD *)(v6 + 4) )\n  {\n    sub_806F249((const char **)(v6 + 4));\n    return v2;\n  }\n  return 0;\n}\n"
    ],
    "sub_8070B2F": [
        "0x8070b2f",
        "void __noreturn sub_8070B2F()\n{\n  sub_8070322();\n}\n"
    ],
    "sub_8070B69": [
        "0x8070b69",
        "int sub_8070B69()\n{\n  int v0; // esi\n  unsigned int v1; // ebx\n\n  sub_80708A7(\"Built-in commands:\\n------------------\\n\");\n  v0 = 0;\n  v1 = 0;\n  do\n  {\n    v1 += sub_80708A7((char *)\"%c%s\", v1 == 0 ? 9 : 32, (&off_80B5D80)[2 * v0] + 1);\n    if ( v1 > 0x3C )\n    {\n      sub_80708A7((char *)\"\\n\");\n      v1 = 0;\n    }\n    ++v0;\n  }\n  while ( v0 != 44 );\n  sub_806FA86(stdout);\n  return 0;\n}\n"
    ],
    "sub_8070BC7": [
        "0x8070bc7",
        "char sub_8070BC7()\n{\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  fputs_unlocked();\n  sub_806F4A5();\n  return sub_806F4BD();\n}\n"
    ],
    "sub_8070BEF": [
        "0x8070bef",
        "int sub_8070BEF()\n{\n  int v0; // ebx\n  int result; // eax\n\n  v0 = dword_80DBB8C;\n  result = 0;\n  if ( !*(_BYTE *)(dword_80DBB8C + 2) && dword_80DB6E0 && *(_BYTE *)(dword_80DB6E0 + 24) == 1 )\n  {\n    sub_8070BC7();\n    *(_BYTE *)(v0 + 2) = 2;\n    return 1;\n  }\n  return result;\n}\n"
    ],
    "sub_8070C23": [
        "0x8070c23",
        "int __fastcall sub_8070C23(int a1, int a2)\n{\n  char *v3; // eax\n\n  if ( !sub_8070BEF() )\n  {\n    v3 = *(char **)(a2 + 4);\n    if ( v3 )\n      *(_BYTE *)dword_80DBB8C = sub_806FE0D(v3);\n    sub_806F22F(4);\n  }\n  return 0;\n}\n"
    ],
    "sub_8070C51": [
        "0x8070c51",
        "void *__usercall sub_8070C51@<eax>(unsigned int a1@<eax>)\n{\n  void *v2; // edx\n\n  v2 = (void *)sub_806FFC6(a1);\n  memset(v2, 0, a1);\n  return v2;\n}\n"
    ],
    "sub_8070C69": [
        "0x8070c69",
        "_DWORD *sub_8070C69()\n{\n  _DWORD *result; // eax\n\n  result = sub_8070C51(0x10u);\n  *(_BYTE *)result = 15;\n  result[2] = dword_80DB68C;\n  result[3] = dword_80DB688;\n  return result;\n}\n"
    ],
    "sub_8070C89": [
        "0x8070c89",
        "int __usercall sub_8070C89@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v2; // ebx\n  int result; // eax\n\n  v2 = sub_8070C51(8u);\n  v2[1] = sub_807007B(a1);\n  result = dword_80DB6B8;\n  *(_DWORD *)dword_80DB6B8 = v2;\n  dword_80DB6B8 = (int)v2;\n  return result;\n}\n"
    ],
    "sub_8070CB3": [
        "0x8070cb3",
        "void *__usercall sub_8070CB3@<eax>(const void *a1@<eax>)\n{\n  return bsearch(a1, &off_80B5D80, 0x2Cu, 8u, (__compar_fn_t)sub_806F10D);\n}\n"
    ],
    "sub_8070CCB": [
        "0x8070ccb",
        "void *__usercall sub_8070CCB@<eax>(const void *a1@<eax>)\n{\n  return bsearch(a1, &off_80B5F14, 0x11u, 4u, (__compar_fn_t)sub_806F1A1);\n}\n"
    ],
    "sub_8070CE3": [
        "0x8070ce3",
        "int sub_8070CE3(char *s, size_t maxlen, char *format, ...)\n{\n  int v4; // [esp+0h] [ebp-4h]\n  va_list maxlena; // [esp+14h] [ebp+10h] BYREF\n\n  va_start(maxlena, format);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v4 = vsnprintf(s, maxlen, format, maxlena);\n  sub_806F4A5();\n  return v4;\n}\n"
    ],
    "sub_8070D18": [
        "0x8070d18",
        "int __usercall sub_8070D18@<eax>(char *a1@<eax>, __int16 a2@<dx>, int a3@<ecx>)\n{\n  int v4; // ebx\n  char *v5; // eax\n  int v6; // eax\n  int v7; // edx\n  char *v8; // eax\n  char v10; // [esp+0h] [ebp-Ch]\n\n  v4 = a2 & 0x7F;\n  if ( (a2 & 0x7F) != 0 )\n  {\n    if ( (_BYTE)a2 == 127 )\n    {\n      LOBYTE(v4) = HIBYTE(a2);\n      if ( !a3 )\n        goto LABEL_8;\n    }\n    else if ( !a3 || v4 != 13 && v4 != 2 )\n    {\nLABEL_8:\n      v10 = a2;\n      v5 = (char *)strsignal();\n      v6 = sub_8070CE3(a1, 0x20u, v5, v4 & 0x7F);\n      v4 = v6;\n      if ( v10 < 0 )\n      {\n        strcpy(&a1[v6], \" (core dumped)\");\n        v4 += 14;\n      }\n      return v4;\n    }\n    return 0;\n  }\n  if ( !a3 )\n  {\n    v7 = HIBYTE(a2);\n    v8 = \"Done\";\n    if ( v7 )\n      v8 = \"Done(%d)\";\n    return sub_8070CE3(a1, 0x10u, v8, v7);\n  }\n  return v4;\n}\n"
    ],
    "sub_8070DA4": [
        "0x8070da4",
        "__pid_t __usercall sub_8070DA4@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // edi\n  __pid_t v3; // esi\n  int v4; // eax\n  int v5; // eax\n  int v6; // ebp\n  int v7; // edx\n  int v8; // ebx\n  int v9; // edi\n  int v10; // eax\n  _DWORD *v12; // [esp+0h] [ebp-54h]\n  _DWORD *v13; // [esp+4h] [ebp-50h]\n  int stat_loc; // [esp+Ch] [ebp-48h] BYREF\n  int v16[17]; // [esp+10h] [ebp-44h] BYREF\n\n  v2 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  if ( a1 == 2 )\n  {\n    while ( 1 )\n    {\n      *(_BYTE *)(v2 + 41) = 0;\n      v3 = waitpid(-1, &stat_loc, byte_80DB76D == 0 ? 1 : 3);\n      if ( v3 )\n        break;\n      v16[0] = -1;\n      v16[1] = -1;\n      sigprocmask(2, (const sigset_t *)v16, (sigset_t *)v16);\n      while ( !*(_BYTE *)(v2 + 41) && !*(_BYTE *)(v2 + 42) )\n        sigsuspend((const sigset_t *)v16);\n      sigprocmask(2, (const sigset_t *)v16, 0);\n      if ( !*(_BYTE *)(v2 + 41) )\n        goto LABEL_33;\n    }\n  }\n  else\n  {\n    v4 = a1 ^ 1;\n    if ( byte_80DB76D )\n      v4 |= 2u;\n    v3 = waitpid(-1, &stat_loc, v4);\n  }\n  if ( v3 > 0 )\n  {\n    v5 = dword_80DB6E0;\n    v6 = stat_loc;\n    while ( v5 )\n    {\n      if ( *(_BYTE *)(v5 + 24) != 2 )\n      {\n        v12 = *(_DWORD **)(v5 + 12);\n        v13 = &v12[3 * *(_DWORD *)(v5 + 20)];\n        v7 = 2;\n        v8 = 0;\n        do\n        {\n          if ( *v12 == v3 )\n          {\n            v12[1] = v6;\n            v8 = v5;\n          }\n          v9 = v12[1];\n          if ( v9 == -1 || !v7 )\n          {\n            v7 = 0;\n          }\n          else if ( (_BYTE)v9 == 127 )\n          {\n            *(_DWORD *)(v5 + 16) = v9;\n            v7 = 1;\n          }\n          v12 += 3;\n        }\n        while ( v13 > v12 );\n        if ( v8 )\n        {\n          if ( v7 )\n          {\n            *(_BYTE *)(v8 + 25) |= 0x10u;\n            if ( *(unsigned __int8 *)(v8 + 24) != v7 )\n            {\n              *(_BYTE *)(v8 + 24) = v7;\n              if ( v7 == 1 )\n                sub_806ED0E(v8, 0);\n            }\n          }\n          sub_806F4A5();\n          if ( v8 == a2 )\n          {\n            v10 = sub_8070D18((char *)v16, stat_loc, 1);\n            if ( v10 )\n            {\n              *((_BYTE *)v16 + v10) = 10;\n              *((_BYTE *)v16 + v10 + 1) = 0;\n              sub_8070BC7();\n            }\n          }\n          return v3;\n        }\n      }\n      v5 = *(_DWORD *)(v5 + 28);\n    }\n    if ( (_BYTE)v6 != 127 )\n      --dword_80DB6DC;\n  }\nLABEL_33:\n  sub_806F4A5();\n  return v3;\n}\n"
    ],
    "sub_8070F47": [
        "0x8070f47",
        "void __noreturn sub_8070F47()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8071014": [
        "0x8071014",
        "int __usercall sub_8071014@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // edi\n\n  v2 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  while ( !*(_BYTE *)(a1 + 24) )\n    sub_8070DA4(1, a1);\n  sub_806F4A5();\n  v3 = sub_806ED5D(a1);\n  if ( (*(_BYTE *)(a1 + 25) & 2) != 0 )\n  {\n    sub_806FFAE(dword_80DB558, *(_DWORD *)(v2 + 4));\n    if ( (*(_BYTE *)(a1 + 25) & 1) != 0 )\n      raise(2);\n  }\n  if ( *(_BYTE *)(a1 + 24) == 2 )\n    sub_806F9B7(a1);\n  return v3;\n}\n"
    ],
    "sub_807107C": [
        "0x807107c",
        "char __usercall sub_807107C@<al>(int a1@<eax>, char *a2@<edx>)\n{\n  _DWORD *v3; // esi\n  char result; // al\n  int v5; // edi\n  char v6; // dl\n  char v7; // cl\n  int v8; // ecx\n  int v9; // edx\n  int v10; // eax\n  int v11; // eax\n  char *v12; // eax\n  const char *v13; // [esp-8h] [ebp-74h]\n  const char *v14; // [esp-4h] [ebp-70h]\n  int v15; // [esp+0h] [ebp-6Ch]\n  _DWORD *v16; // [esp+4h] [ebp-68h]\n  FILE *stream; // [esp+8h] [ebp-64h]\n  char *s; // [esp+Ch] [ebp-60h]\n  char dest[92]; // [esp+10h] [ebp-5Ch] BYREF\n\n  stream = stdout;\n  if ( ((unsigned __int8)a2 & 8) != 0 )\n    stream = stderr;\n  v3 = *(_DWORD **)(a1 + 12);\n  if ( ((unsigned __int8)a2 & 1) != 0 )\n    return fprintf(stream, \"%d\\n\", *v3);\n  s = a2;\n  v5 = sub_8070CE3(dest, 0x10u, \"[%d]   \", ((a1 - dword_80DB6E8) >> 5) + 1);\n  v6 = (char)s;\n  if ( dword_80DB6E0 == a1 )\n  {\n    dest[v5 - 3] = 43;\n  }\n  else if ( dword_80DB6E0 && *(_DWORD *)(dword_80DB6E0 + 28) == a1 )\n  {\n    dest[v5 - 3] = 45;\n  }\n  s = (char *)v5;\n  v15 = v6 & 2;\n  if ( (v6 & 2) != 0 )\n    s = (char *)(v5 + sub_8070CE3(&dest[v5], 0x10u, (char *)\"%d \", *v3));\n  v16 = &v3[3 * *(_DWORD *)(a1 + 20)];\n  v7 = *(_BYTE *)(a1 + 24);\n  if ( v7 )\n  {\n    v9 = *(v16 - 2);\n    if ( v7 == 1 )\n      v9 = *(_DWORD *)(a1 + 16);\n    v10 = sub_8070D18(&dest[(_DWORD)s], v9, 0);\n    v8 = (int)&s[v10];\n  }\n  else\n  {\n    strcpy(&dest[(_DWORD)s], \"Running\");\n    v8 = (int)(s + 7);\n  }\n  while ( 1 )\n  {\n    v12 = \"| \";\n    if ( *(_DWORD **)(a1 + 12) == v3 )\n      v12 = (char *)&data;\n    v14 = (const char *)v3[2];\n    v13 = v12;\n    v11 = 33 - v8;\n    if ( 33 - v8 < 0 )\n      v11 = 0;\n    s = dest;\n    fprintf(stream, \"%s%*c%s%s\", dest, v11, 32, v13, v14);\n    v3 += 3;\n    if ( v16 == v3 )\n      break;\n    dest[0] = 0;\n    v8 = 33;\n    if ( v15 )\n      v8 = sub_8070CE3(s, 0x30u, \"\\n%*c%d \", v5, 32, *v3) - 1;\n  }\n  result = sub_806FA86(stream);\n  *(_BYTE *)(a1 + 25) &= ~0x10u;\n  if ( *(_BYTE *)(a1 + 24) == 2 )\n    return sub_806F9B7(a1);\n  return result;\n}\n"
    ],
    "sub_80711FF": [
        "0x80711ff",
        "char __usercall sub_80711FF@<al>(char *a1@<eax>)\n{\n  __pid_t v2; // eax\n  int i; // ebx\n\n  do\n    v2 = sub_8070DA4(0, 0);\n  while ( v2 > 0 );\n  for ( i = dword_80DB6E0; i; i = *(_DWORD *)(i + 28) )\n  {\n    if ( ((unsigned __int8)a1 & 4) == 0 || (*(_BYTE *)(i + 25) & 0x10) != 0 )\n      LOBYTE(v2) = sub_807107C(i, a1);\n  }\n  return v2;\n}\n"
    ],
    "sub_8071239": [
        "0x8071239",
        "void __noreturn sub_8071239()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_807128B": [
        "0x807128b",
        "void __noreturn sub_807128B()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8071387": [
        "0x8071387",
        "int sub_8071387()\n{\n  return sub_80795F7();\n}\n"
    ],
    "sub_807138E": [
        "0x807138e",
        "_BYTE *__cdecl sub_807138E(_BYTE *a1, char *a2, int name_2, const char *a4, int pattern_2, int a6)\n{\n  char *i; // esi\n  char v8; // dl\n  const char *v9; // eax\n  int v10; // eax\n  char v12; // [esp+1h] [ebp-9h]\n\n  for ( i = a2; ; ++i )\n  {\n    v8 = *i;\n    v9 = i;\n    if ( a6 )\n    {\n      *i = 0;\n      v9 = a2;\n    }\n    v12 = v8;\n    v10 = fnmatch(a4, v9, 0);\n    *i = v12;\n    if ( !v10 )\n      break;\n    if ( pattern_2 && *a1 == 0x81 )\n      ++a1;\n    ++a1;\n    if ( !v12 )\n      return 0;\n  }\n  return a1;\n}\n"
    ],
    "sub_80713E7": [
        "0x80713e7",
        "char *__cdecl sub_80713E7(unsigned int a1, const char *a2, char *name, char *pattern, char *patterna, int a6)\n{\n  char *v7; // ebx\n  int v8; // ebp\n  char v9; // dl\n  const char *v10; // eax\n  int v11; // eax\n  char *v12; // ecx\n  char *v13; // edx\n  int v14; // eax\n  char v16; // [esp+1h] [ebp-11h]\n\n  v7 = pattern - 1;\n  v8 = 0;\n  while ( (unsigned int)v7 >= a1 )\n  {\n    v9 = *name;\n    v10 = name;\n    if ( a6 )\n    {\n      *name = 0;\n      v10 = a2;\n    }\n    v16 = v9;\n    v11 = fnmatch(pattern, v10, 0);\n    *name = v16;\n    if ( !v11 )\n      return v7;\n    v12 = v7 - 1;\n    if ( patterna )\n    {\n      if ( --v8 < 0 )\n      {\n        v13 = v7 - 1;\n        do\n        {\n          v14 = v12 - v13;\n          if ( a1 >= (unsigned int)v13 )\n            break;\n          --v13;\n        }\n        while ( *v13 == -127 );\n        v8 = v14;\n      }\n      if ( (v8 & 1) != 0 )\n      {\n        --v8;\n        v12 = v7 - 2;\n      }\n    }\n    --name;\n    v7 = v12;\n  }\n  return 0;\n}\n"
    ],
    "sub_807146D": [
        "0x807146d",
        "__int64 sub_807146D()\n{\n  __int64 v0; // rax\n  __int64 v2; // [esp+0h] [ebp-20h]\n  const char *v3; // [esp+8h] [ebp-18h]\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  LODWORD(v0) = sub_8078F92();\n  if ( v3 )\n    sub_806FB57(v3);\n  v2 = v0;\n  sub_806F4A5();\n  return v2;\n}\n"
    ],
    "sub_80714BF": [
        "0x80714bf",
        "int sub_80714BF()\n{\n  __int64 v0; // rax\n\n  v0 = sub_807146D();\n  if ( v0 < (__int64)0xFFFFFFFF80000000LL )\n    v0 = 0xFFFFFFFF80000000LL;\n  if ( v0 > 0x7FFFFFFF )\n    LODWORD(v0) = 0x7FFFFFFF;\n  return v0;\n}\n"
    ],
    "sub_80714EE": [
        "0x80714ee",
        "_BOOL4 __fastcall sub_80714EE(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  __int64 v3; // rax\n\n  if ( !*(_DWORD *)(a2 + 4) )\n    sub_806FB57(\"expression expected\");\n  v2 = (_DWORD *)(a2 + 4);\n  do\n  {\n    v3 = sub_807146D();\n    ++v2;\n  }\n  while ( *v2 );\n  return v3 == 0;\n}\n"
    ],
    "sub_807151B": [
        "0x807151b",
        "int __usercall sub_807151B@<eax>(int a1@<eax>)\n{\n  int v1; // eax\n  int v2; // ebx\n  int i; // ebp\n  int v4; // esi\n  char *v5; // eax\n  char *v6; // ebp\n  char *v7; // edi\n  char *v8; // edx\n  int v9; // ecx\n  int v10; // esi\n\n  v1 = dword_80DB6E4;\n  v2 = dword_80DB6E8;\n  for ( i = dword_80DB6E8; --v1 >= 0; i += 32 )\n  {\n    if ( (*(_BYTE *)(i + 25) & 8) == 0 )\n      goto LABEL_19;\n    if ( (*(_DWORD *)(i + 24) & 0x4FF) == 1026 && !byte_80DB76D )\n    {\n      sub_806F9B7(i);\n      goto LABEL_19;\n    }\n  }\n  v4 = 32 * dword_80DB6E4;\n  v5 = (char *)sub_804DB13((void *)dword_80DB6E8, 32 * dword_80DB6E4 + 128);\n  v6 = &v5[-v2];\n  v7 = &v5[v4];\n  if ( v5 != (char *)v2 )\n  {\n    v8 = &v5[v4];\n    v9 = v4;\n    while ( v9 )\n    {\n      v9 -= 32;\n      if ( *((_DWORD *)v8 - 5) == v2 + v9 )\n        *((_DWORD *)v8 - 5) = &v5[v9];\n      v10 = *((_DWORD *)v8 - 1);\n      if ( v10 )\n        *((_DWORD *)v8 - 1) = &v6[v10];\n      v8 -= 32;\n    }\n    if ( dword_80DB6E0 )\n      dword_80DB6E0 += (int)v6;\n  }\n  dword_80DB6E4 += 4;\n  dword_80DB6E8 = (int)v5;\n  i = (int)v7;\n  v7[121] &= ~8u;\n  v7[89] &= ~8u;\n  v7[57] &= ~8u;\n  v7[25] &= ~8u;\nLABEL_19:\n  memset((void *)i, 0, 0x20u);\n  if ( byte_80DB76D )\n    *(_BYTE *)(i + 25) |= 2u;\n  *(_DWORD *)(i + 28) = dword_80DB6E0;\n  dword_80DB6E0 = i;\n  *(_BYTE *)(i + 25) |= 8u;\n  *(_DWORD *)(i + 12) = i;\n  if ( a1 > 1 )\n    *(_DWORD *)(i + 12) = sub_804DAFA(12 * a1);\n  return i;\n}\n"
    ],
    "sub_8071623": [
        "0x8071623",
        "char sub_8071623()\n{\n  int v0; // ebx\n  unsigned int v1; // ecx\n  unsigned int v2; // ebp\n  const void *v3; // esi\n  int v4; // esi\n  _DWORD *v5; // eax\n  void *v7; // eax\n  unsigned int v8; // [esp+0h] [ebp-14h]\n\n  v0 = dword_80DBB88;\n  v1 = *(_DWORD *)(dword_80DBB88 + 12);\n  v2 = 2 * v1;\n  if ( v1 > 2 * v1 )\n    sub_806FB57(\"out of memory\");\n  if ( v2 <= 0x7F )\n    v2 += 128;\n  v3 = *(const void **)(dword_80DBB88 + 4);\n  if ( v3 != (const void *)(*(_DWORD *)dword_80DBB88 + 4) || *(_DWORD *)dword_80DBB88 == dword_80DBB88 + 16 )\n  {\n    v8 = *(_DWORD *)(dword_80DBB88 + 12);\n    v7 = (void *)sub_806FFC6(v2);\n    qmemcpy(v7, v3, v8);\n    *(_DWORD *)(v0 + 4) = v7;\n    *(_DWORD *)(v0 + 12) += v2;\n    return v8;\n  }\n  else\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v4 = **(_DWORD **)v0;\n    v5 = sub_804DB13(*(void **)v0, v2 + 4);\n    *v5 = v4;\n    *(_DWORD *)v0 = v5++;\n    *(_DWORD *)(v0 + 4) = v5;\n    *(_DWORD *)(v0 + 12) = v2;\n    *(_DWORD *)(v0 + 8) = (char *)v5 + v2;\n    return sub_806F4A5();\n  }\n}\n"
    ],
    "sub_80716AF": [
        "0x80716af",
        "int __usercall sub_80716AF@<eax>(unsigned int a1@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  int v4; // ebx\n\n  v3 = dword_80DBB88;\n  v4 = a2 - *(_DWORD *)(dword_80DBB88 + 4);\n  while ( *(_DWORD *)(v3 + 12) - v4 < a1 )\n    sub_8071623();\n  return v4 + *(_DWORD *)(v3 + 4);\n}\n"
    ],
    "sub_80716D8": [
        "0x80716d8",
        "int __usercall sub_80716D8@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *v2; // edx\n  _BYTE *v3; // ebp\n  _BYTE *v4; // eax\n  int i; // ebx\n  _BYTE *v6; // eax\n  int v8; // [esp+0h] [ebp-14h]\n\n  v2 = *(_BYTE **)(dword_80DBB88 + 4);\n  do\n  {\n    v8 = (int)v2;\n    v3 = (_BYTE *)strchrnul();\n    *(_BYTE *)sub_80716AF(v3 - a1 + 3, v8) = 39;\n    v4 = (_BYTE *)mempcpy();\n    v2 = v4 + 1;\n    *v4 = 39;\n    if ( *v3 != 39 )\n      break;\n    for ( i = 0; ; ++i )\n    {\n      a1 = &v3[i + 1];\n      if ( v3[i + 1] != 39 )\n        break;\n    }\n    *(_BYTE *)sub_80716AF(i + 4, (int)v2) = 34;\n    v6 = (_BYTE *)mempcpy();\n    v2 = v6 + 1;\n    *v6 = 34;\n  }\n  while ( *a1 );\n  *v2 = 0;\n  return *(_DWORD *)(dword_80DBB88 + 4);\n}\n"
    ],
    "sub_807176F": [
        "0x807176f",
        "int __usercall sub_807176F@<eax>(int a1@<eax>)\n{\n  const char *v2; // eax\n\n  v2 = (const char *)sub_80716D8(*(_BYTE **)(a1 + 8));\n  return sub_80708A7(\"%s=%s\\n\", *(const char **)(a1 + 4), v2);\n}\n"
    ],
    "sub_807178D": [
        "0x807178d",
        "int __fastcall sub_807178D(int a1, int a2)\n{\n  int i; // ebx\n  _DWORD *j; // esi\n  int v4; // edi\n  const char **v5; // esi\n  const char *v6; // ebx\n  char *v7; // eax\n  int v8; // eax\n  int *v9; // ecx\n  int v10; // ebp\n  _DWORD *v11; // ebp\n  const char *v13; // [esp+0h] [ebp-18h]\n  int *v14; // [esp+4h] [ebp-14h]\n\n  if ( *(_DWORD *)(a2 + 4) )\n  {\n    v5 = (const char **)a2;\n    v4 = 0;\n    while ( 1 )\n    {\n      v6 = *++v5;\n      if ( !*v5 )\n        break;\n      v7 = strchr(v6 + 1, 61);\n      if ( v7 )\n      {\n        v13 = v7 + 1;\n        *v7 = 0;\n        v9 = sub_806F0C2(v6);\n        v10 = *v9;\n        ++*(_DWORD *)(dword_80DBB8C + 36);\n        if ( v10 )\n        {\n          if ( (*(_BYTE *)(v10 + 12) & 1) == 0 )\n            free(*(void **)(v10 + 8));\n          *(_DWORD *)(v10 + 8) = sub_804DB46(v13);\n          *(_DWORD *)(v10 + 12) &= ~2u;\n        }\n        else\n        {\n          v14 = v9;\n          v11 = sub_804DB2E(0x10u);\n          v11[1] = sub_804DB46(v6);\n          v11[2] = sub_804DB46(v13);\n          *v14 = (int)v11;\n        }\n        sub_806F4A5();\n      }\n      else\n      {\n        v8 = *sub_806F0C2(v6);\n        if ( v8 )\n        {\n          sub_807176F(v8);\n        }\n        else\n        {\n          fprintf(stderr, \"%s: %s not found\\n\", \"alias\", v6);\n          v4 = 1;\n        }\n      }\n    }\n  }\n  else\n  {\n    for ( i = 0; i != 156; i += 4 )\n    {\n      for ( j = *(_DWORD **)(dword_80DB6F0 + i); j; j = (_DWORD *)*j )\n        sub_807176F((int)j);\n    }\n    return 0;\n  }\n  return v4;\n}\n"
    ],
    "sub_807189F": [
        "0x807189f",
        "_BYTE *__usercall sub_807189F@<eax>(_BYTE *a1@<eax>)\n{\n  char *i; // esi\n  char v2; // dl\n\n  for ( i = a1; ; ++i )\n  {\n    v2 = *i;\n    if ( !*i )\n      break;\n    if ( (unsigned __int8)(v2 - 43) > 0x4Fu\n      || v2 == 96\n      || (unsigned __int8)(v2 - 59) <= 4u\n      || (unsigned __int8)(v2 - 91) <= 1u )\n    {\n      return (_BYTE *)sub_80716D8(a1);\n    }\n  }\n  return a1;\n}\n"
    ],
    "sub_80718D9": [
        "0x80718d9",
        "int __usercall sub_80718D9@<eax>(int result@<eax>, unsigned int a2@<edx>, int a3@<ecx>, char a4)\n{\n  unsigned __int8 *v4; // ebx\n  unsigned int v7; // eax\n  unsigned __int8 *v8; // ebp\n  unsigned __int8 v9; // cl\n  unsigned __int8 *v10; // [esp+4h] [ebp-18h]\n  unsigned __int8 v11; // [esp+Bh] [ebp-11h]\n\n  if ( a2 )\n  {\n    v4 = (unsigned __int8 *)result;\n    v7 = a2;\n    if ( (a4 & 0x11) != 0 )\n      v7 = 2 * a2;\n    v8 = (unsigned __int8 *)sub_80716AF(v7, dword_80DB6D4);\n    result = (int)&v4[a2];\n    v10 = &v4[a2];\n    while ( 1 )\n    {\n      v9 = *v4++;\n      if ( v9 )\n        break;\n      if ( (a4 & 2) != 0 )\n        goto LABEL_12;\nLABEL_13:\n      if ( v4 == v10 )\n      {\n        dword_80DB6D4 = (int)v8;\n        return result;\n      }\n    }\n    if ( (a4 & 0x11) != 0 )\n    {\n      v11 = *(v4 - 1);\n      result = sub_806EEFB(v9, a3);\n      v9 = v11;\n      if ( result == 12 || a3 | a4 & 1 && result == 2 )\n        *v8++ = -127;\n    }\nLABEL_12:\n    *v8++ = v9;\n    goto LABEL_13;\n  }\n  return result;\n}\n"
    ],
    "sub_8071971": [
        "0x8071971",
        "int __usercall sub_8071971@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  unsigned int v3; // [esp-4h] [ebp-10h]\n\n  v3 = strlen(a1);\n  sub_80716AF(v3, a2);\n  return mempcpy();\n}\n"
    ],
    "sub_8071998": [
        "0x8071998",
        "int __usercall sub_8071998@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>)\n{\n  int result; // eax\n\n  dword_80DB6D4 = sub_80716AF(0x18u, dword_80DB6D4);\n  result = sub_8070CE3((char *)dword_80DB6D4, 0x18u, \"%lld\", __PAIR64__(a2, a1));\n  dword_80DB6D4 += result;\n  return result;\n}\n"
    ],
    "sub_80719CE": [
        "0x80719ce",
        "const char *__usercall sub_80719CE@<eax>(const char *a1@<eax>, char a2@<dl>, _DWORD *a3@<ecx>)\n{\n  const char *v5; // eax\n  char *v6; // eax\n  char *v7; // ebp\n  int v8; // edi\n  size_t v9; // eax\n  const char *v10; // ebp\n  const char *v11; // eax\n  int v12; // esi\n  int v13; // edi\n  char v14; // dl\n  int v15; // ecx\n  char v16; // cl\n  bool v17; // dl\n  unsigned __int8 v18; // cl\n  bool v19; // si\n  const char *v21; // [esp+0h] [ebp-24h]\n  char *v22; // [esp+4h] [ebp-20h]\n  _DWORD *v23; // [esp+8h] [ebp-1Ch]\n  int v24; // [esp+Ch] [ebp-18h]\n  int v25; // [esp+10h] [ebp-14h]\n\n  v23 = a3;\n  v5 = &unk_80D0D10;\n  if ( a3 )\n    v5 = (const char *)&unk_80D0D0F;\n  v6 = strpbrk(a1, v5);\n  v7 = v6;\n  if ( v6 )\n  {\n    v24 = a2 & 8;\n    if ( (a2 & 1) != 0 )\n    {\n      v8 = v6 - a1;\n      v9 = strlen(v6) + v6 - a1 + 1;\n      if ( (a2 & 8) != 0 )\n      {\n        v10 = &a1[-*(_DWORD *)(dword_80DBB88 + 4)];\n        a1 = (const char *)sub_80716AF(v9, dword_80DB6D4);\n        v21 = &v10[*(_DWORD *)(dword_80DBB88 + 4)];\n        v7 = (char *)&v21[v8];\n      }\n      else\n      {\n        if ( (a2 & 0x10) != 0 )\n          v11 = (const char *)sub_804DAFA(v9);\n        else\n          v11 = (const char *)sub_806FFC6(v9);\n        v21 = a1;\n        a1 = v11;\n      }\n      v6 = (char *)a1;\n      if ( v8 )\n        v6 = (char *)mempcpy();\n    }\n    else\n    {\n      v21 = a1;\n    }\n    v12 = a2 & 2;\n    v13 = v12;\n    while ( 1 )\n    {\n      v14 = *v7;\n      if ( !*v7 )\n        break;\n      v22 = v7 + 1;\n      v25 = v13;\n      if ( v14 != -120 )\n      {\n        v15 = 0;\n        if ( v14 != 92 )\n        {\n          if ( v14 == -127 )\n          {\n            v16 = v7[1];\n            if ( !v12 )\n              goto LABEL_28;\n            v17 = (unsigned __int8)(v16 - 91) <= 3u;\n            v18 = v16 - 33;\n            v19 = 1;\n            if ( v18 <= 0x1Eu )\n              v19 = ((0x40001201u >> v18) & 1) == 0;\n            if ( !v19 || v17 )\n            {\n              *v6 = 92;\n              v15 = v13;\n              ++v6;\n            }\n            else\n            {\nLABEL_28:\n              v15 = v13;\n            }\n            ++v7;\n          }\n          else\n          {\n            v15 = v13;\n            if ( v23 && v7 == &v21[*v23] )\n            {\n              *v23 = v6 - a1;\n              v13 = 0;\n              v15 = 0;\n              v23 = 0;\n            }\n          }\n        }\n        v22 = v7 + 1;\n        *v6 = *v7;\n        v25 = v13;\n        v13 = v15;\n        ++v6;\n      }\n      v12 = v13;\n      v13 = v25;\n      v7 = v22;\n    }\n    *v6 = 0;\n    if ( v24 )\n      dword_80DB6D4 = (int)(v6 + 1);\n  }\n  return a1;\n}\n"
    ],
    "sub_8071B5D": [
        "0x8071b5d",
        "int __usercall sub_8071B5D@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // esi\n  size_t v3; // eax\n  char *v4; // eax\n  int v5; // ebx\n  char v6; // di\n  char *v7; // ebp\n  char v8; // cl\n  bool v9; // zf\n  char *v10; // edx\n  char *i; // esi\n  char v12; // al\n  int v14; // [esp-2h] [ebp-14h] BYREF\n\n  v14 = a2;\n  v2 = (char *)a1;\n  HIBYTE(v14) = 0;\n  v3 = strlen(a1);\n  v4 = (char *)sub_80716AF(8 * v3 + 8, dword_80DB6D8);\n  v5 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    v7 = v2 + 1;\n    v8 = *v2;\n    if ( !*v2 )\n      break;\n    if ( v8 == -127 )\n    {\n      v7 = v2 + 2;\n      v8 = v2[1];\n      goto LABEL_35;\n    }\n    if ( (unsigned __int8)v8 > 0x81u )\n    {\n      if ( v8 == -124 )\n      {\n        v10 = \"$(...)\";\n      }\n      else if ( (unsigned __int8)v8 > 0x84u )\n      {\n        if ( v8 == -121 )\n        {\n          v10 = \"))\";\n        }\n        else\n        {\n          if ( v8 == -120 )\n          {\n            v5 ^= 1u;\n            v8 = 34;\n            goto LABEL_35;\n          }\n          v10 = \"$((\";\n          if ( v8 != -122 )\n            goto LABEL_35;\n        }\n      }\n      else if ( v8 == -126 )\n      {\n        v7 = v2 + 2;\n        v6 = v2[1];\n        v10 = \"${#\";\n        if ( (v6 & 0xF) != 10 )\n          v10 = \"${\";\n      }\n      else\n      {\n        v10 = \"}\";\n        if ( (v5 & 1) != 0 )\n          v10 = \"\\\"}\";\n        v5 >>= 1;\n        v6 = 0;\n      }\n    }\n    else\n    {\n      if ( v8 == 39 )\n        goto LABEL_34;\n      if ( (unsigned __int8)v8 <= 0x27u )\n      {\n        if ( v8 != 34 )\n        {\n          v9 = v8 == 36;\n          goto LABEL_11;\n        }\n        goto LABEL_34;\n      }\n      if ( v8 != 61 )\n      {\n        v9 = v8 == 92;\nLABEL_11:\n        if ( v9 )\n        {\nLABEL_34:\n          BYTE2(v14) = *v2;\n          v8 = 92;\n          v10 = (char *)&v14 + 2;\n        }\n        else\n        {\nLABEL_35:\n          v10 = 0;\n        }\nLABEL_36:\n        i = v4 + 1;\n        *v4++ = v8;\n        if ( !v10 )\n          goto LABEL_42;\n        goto LABEL_39;\n      }\n      if ( !v6 )\n        goto LABEL_35;\n      if ( (v6 & 0xF) != 1 )\n        v5 *= 2;\n      v10 = (char *)(3 * (v6 & 0xF) + 134962496);\n      if ( (v6 & 0x10) != 0 )\n      {\n        v8 = 58;\n        goto LABEL_36;\n      }\n    }\nLABEL_39:\n    for ( i = v4; ; *(i - 1) = v12 )\n    {\n      v12 = *v10++;\n      if ( !v12 )\n        break;\n      ++i;\n    }\nLABEL_42:\n    v4 = i;\n    v2 = v7;\n  }\n  if ( (v5 & 1) != 0 )\n    *v4++ = 34;\n  *v4 = 0;\n  dword_80DB6D8 = (int)v4;\n  return v14;\n}\n"
    ],
    "sub_8071CBE": [
        "0x8071cbe",
        "int sub_8071CBE()\n{\n  int v0; // esi\n  int v1; // ebx\n\n  v0 = dword_80DBB88;\n  v1 = *(_DWORD *)(dword_80DBB88 + 12);\n  sub_8071623();\n  return v1 + *(_DWORD *)(v0 + 4);\n}\n"
    ],
    "sub_8071CD6": [
        "0x8071cd6",
        "_BYTE *__usercall sub_8071CD6@<eax>(char a1@<al>, _BYTE *a2@<edx>)\n{\n  _BYTE *v3; // eax\n\n  v3 = a2;\n  if ( *(_BYTE **)(dword_80DBB88 + 8) == a2 )\n    v3 = (_BYTE *)sub_8071CBE();\n  *v3 = a1;\n  return v3 + 1;\n}\n"
    ],
    "sub_8071CF0": [
        "0x8071cf0",
        "int __usercall sub_8071CF0@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>)\n{\n  _DWORD *v5; // eax\n  _DWORD *v6; // esi\n  _DWORD *i; // ebx\n  _DWORD *v8; // edx\n  int v10; // [esp+0h] [ebp-14h]\n\n  v5 = *(_DWORD **)(dword_80DBB88 + 4);\n  v6 = (_DWORD *)(dword_80DBB90 + 28);\n  v10 = a1 | a2;\n  do\n  {\n    for ( i = (_DWORD *)*v6; ; i = (_DWORD *)*i )\n    {\n      v8 = *(_DWORD **)(dword_80DBB88 + 8);\n      if ( !i )\n        break;\n      if ( (i[1] & v10) == a1 )\n      {\n        if ( v5 == v8 )\n          v5 = (_DWORD *)sub_8071CBE();\n        *v5++ = i[2];\n      }\n    }\n    ++v6;\n  }\n  while ( (unsigned int)v6 < dword_80DBB90 + 184 );\n  if ( v5 == v8 )\n    v5 = (_DWORD *)sub_8071CBE();\n  if ( a3 )\n    *a3 = v5;\n  *v5 = 0;\n  return sub_806FFC6((int)v5 - *(_DWORD *)(dword_80DBB88 + 4) + 4);\n}\n"
    ],
    "sub_8071D7C": [
        "0x8071d7c",
        "int __usercall sub_8071D7C@<eax>(_DWORD *a1@<eax>, const char *a2@<edx>)\n{\n  _BYTE *v2; // esi\n  _BYTE *i; // ebx\n  char *v6; // edx\n  _BYTE *v7; // eax\n  unsigned int v9; // [esp+4h] [ebp-14h]\n\n  v2 = (_BYTE *)*a1;\n  if ( !*a1 )\n    return 0;\n  for ( i = (_BYTE *)*a1; *i != 58 && *i != 0 && *i != 37; ++i )\n    ;\n  v9 = i - v2 + strlen(a2) + 2;\n  while ( *(_DWORD *)(dword_80DBB88 + 12) < v9 )\n    sub_8071623();\n  v6 = *(char **)(dword_80DBB88 + 4);\n  if ( v2 != i )\n  {\n    v7 = (_BYTE *)mempcpy();\n    v6 = v7 + 1;\n    *v7 = 47;\n  }\n  strcpy(v6, a2);\n  dword_80DB6FC = 0;\n  if ( *i == 37 )\n  {\n    dword_80DB6FC = (int)++i;\n    while ( *i != 58 && *i )\n      ++i;\n  }\n  if ( *i == 58 )\n    *a1 = i + 1;\n  else\n    *a1 = 0;\n  return sub_806FFC6(v9);\n}\n"
    ],
    "sub_8071E56": [
        "0x8071e56",
        "char __usercall sub_8071E56@<al>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int v5; // ebx\n  int v6; // ebp\n  int v7; // edx\n  void **i; // edx\n  int v9; // eax\n  __pid_t v10; // edi\n  int v11; // ebx\n  int v14; // [esp+4h] [ebp-1Ch]\n  int v15; // [esp+4h] [ebp-1Ch]\n  void **ptr; // [esp+8h] [ebp-18h]\n  void **v17; // [esp+Ch] [ebp-14h]\n\n  v5 = dword_80DBB8C;\n  v6 = *(_DWORD *)(dword_80DBB8C + 8);\n  *(_DWORD *)(dword_80DBB8C + 8) = v6 + 1;\n  while ( off_80DB55C != &unk_80DB5E0 )\n    sub_806F6F7();\n  if ( dword_80DB5E8 > 0 )\n  {\n    close(dword_80DB5E8);\n    *((_DWORD *)off_80DB55C + 2) = 0;\n  }\n  if ( a3 == 2 )\n  {\n    if ( a2 )\n    {\n      if ( !*(_BYTE *)a2 )\n      {\n        v7 = *(_DWORD *)(a2 + 12);\n        if ( v7 )\n        {\n          v14 = *(_DWORD *)(a2 + 12);\n          if ( !strcmp(*(const char **)(v7 + 8), \"trap\") && !*(_DWORD *)(v14 + 4) )\n            *(_DWORD *)(v5 + 452) = sub_804DB8D((const void *)(v5 + 192), 0x104u);\n        }\n      }\n    }\n  }\n  ++*(_DWORD *)(v5 + 36);\n  v15 = dword_80DBB8C + 192;\n  for ( i = (void **)(dword_80DBB8C + 192); (unsigned int)i < dword_80DBB8C + 452; ++i )\n  {\n    if ( *i && *(_BYTE *)*i )\n    {\n      if ( v15 == *(_DWORD *)(dword_80DBB8C + 452) )\n      {\n        v17 = i;\n        free(*i);\n        i = v17;\n      }\n      *i = 0;\n      if ( i != (void **)v15 )\n      {\n        ptr = i;\n        sub_806F2B1(((int)i - v15) >> 2);\n        i = ptr;\n      }\n    }\n  }\n  *(_BYTE *)(dword_80DBB8C + 188) = 0;\n  LOBYTE(v9) = sub_806F4A5();\n  byte_80DB76D = 0;\n  if ( a3 == 2 )\n  {\nLABEL_35:\n    if ( v6 )\n      goto LABEL_39;\n    goto LABEL_36;\n  }\n  if ( (*(_BYTE *)(a1 + 25) & 2) == 0 )\n  {\n    if ( a3 != 1 )\n      goto LABEL_35;\n    goto LABEL_32;\n  }\n  if ( v6 )\n  {\n    if ( a3 != 1 )\n      goto LABEL_39;\nLABEL_32:\n    sub_806F3DD(2);\n    LOBYTE(v9) = sub_806F3DD(3);\n    if ( !*(_DWORD *)(a1 + 20) )\n    {\n      close(0);\n      v9 = open64();\n      if ( v9 )\n        sub_806FB57(\"can't open '%s': %m\", \"/dev/null\");\n    }\n    goto LABEL_35;\n  }\n  if ( *(_DWORD *)(a1 + 20) )\n    v10 = **(_DWORD **)(a1 + 12);\n  else\n    v10 = getpid();\n  setpgid(0, v10);\n  if ( !a3 )\n    sub_806FFAE(dword_80DB558, v10);\n  sub_806F2B1(20);\n  sub_806F2B1(22);\nLABEL_36:\n  if ( *(_BYTE *)(v5 + 48) )\n  {\n    sub_806F2B1(2);\n    sub_806F2B1(15);\n  }\n  LOBYTE(v9) = sub_806F2B1(3);\nLABEL_39:\n  v11 = dword_80DB6E0;\n  if ( !a2 || *(_BYTE *)a2 || (v9 = *(_DWORD *)(a2 + 12)) == 0 || (v9 = strcmp(*(const char **)(v9 + 8), \"jobs\")) != 0 )\n  {\n    while ( v11 )\n    {\n      LOBYTE(v9) = sub_806F9B7(v11);\n      v11 = *(_DWORD *)(v11 + 28);\n    }\n    dword_80DB6DC = 0;\n  }\n  else\n  {\n    LOBYTE(v9) = sub_806F9B7(v11);\n  }\n  return v9;\n}\n"
    ],
    "sub_80720BA": [
        "0x80720ba",
        "int __usercall sub_80720BA@<eax>(char **envp@<ecx>, const char **argv@<edx>, const char *a3@<eax>)\n{\n  int result; // eax\n\n  while ( 1 )\n  {\n    result = execve(a3, (char *const *)argv, envp);\n    if ( a3 == \"/proc/self/exe\" )\n      break;\n    result = dword_80DBB7C;\n    if ( *(_DWORD *)dword_80DBB7C != 8 )\n      break;\n    *argv-- = a3;\n    *argv = \"ash\";\n    a3 = \"/proc/self/exe\";\n  }\n  return result;\n}\n"
    ],
    "sub_80720F6": [
        "0x80720f6",
        "char *__usercall sub_80720F6@<eax>(int a1@<eax>, char *a2@<edx>)\n{\n  char *result; // eax\n\n  result = a2;\n  if ( a1 != 2 && a1 != 20 )\n    return strerror(a1);\n  return result;\n}\n"
    ],
    "sub_807210C": [
        "0x807210c",
        "void __noreturn sub_807210C()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_807222A": [
        "0x807222a",
        "int sub_807222A()\n{\n  unsigned int v0; // ebx\n  unsigned __int8 *v1; // esi\n  unsigned int v2; // ecx\n  struct tms v4; // [esp+0h] [ebp-1Ch] BYREF\n\n  v0 = sub_80B2F58();\n  times(&v4);\n  v1 = \" \";\n  do\n  {\n    v2 = *(clock_t *)((char *)&v4.tms_utime + v1[1]) / v0;\n    sub_80708A7(\n      \"%um%u.%03us%c\",\n      v2 / 0x3C,\n      v2 % 0x3C,\n      1000 * (*(clock_t *)((char *)&v4.tms_utime + v1[1]) % v0) / v0,\n      *v1);\n    v1 += 2;\n  }\n  while ( *v1 );\n  return 0;\n}\n"
    ],
    "sub_807228A": [
        "0x807228a",
        "int __usercall sub_807228A@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebx>)\n{\n  const char **v5; // ebx\n  const char *v6; // ebp\n  _BYTE *v7; // esi\n  const char *v8; // eax\n  unsigned int v10; // [esp+0h] [ebp-14h] BYREF\n\n  v10 = a4;\n  v5 = (const char **)sub_8071CF0(a2, a3, &v10);\n  qsort(v5, (int)(v10 - (_DWORD)v5) >> 2, 4u, (__compar_fn_t)sub_806ECD8);\n  v6 = a1;\n  if ( *a1 )\n    v6 = \"        \" + 7;\n  while ( v10 > (unsigned int)v5 )\n  {\n    v7 = (_BYTE *)sub_80AB128();\n    v8 = (const char *)(dword_80DBB8C + 44);\n    if ( *v7 == 61 )\n      v8 = (const char *)sub_80716D8(++v7);\n    sub_80708A7(\"%s%s%.*s%s\\n\", a1, v6, v7 - *v5, *v5, v8);\n    ++v5;\n  }\n  return 0;\n}\n"
    ],
    "sub_807230A": [
        "0x807230a",
        "int __usercall sub_807230A@<eax>(int a1@<edx>, unsigned int a2@<ebx>, __pid_t a3@<esi>)\n{\n  int v4; // ebx\n\n  if ( !*(_DWORD *)(a1 + 4) )\n    return sub_807228A((const char *)(dword_80DBB8C + 44), 0, 32, a2);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v4 = sub_80708D4(0, 0);\n  if ( !v4 )\n  {\n    sub_8070672(a3);\n    if ( *(_DWORD *)dword_80DB708 )\n      sub_806F249((const char **)dword_80DB708);\n  }\n  sub_806F4A5();\n  return v4;\n}\n"
    ],
    "sub_8072358": [
        "0x8072358",
        "void __usercall __noreturn sub_8072358(int a1@<eax>)\n{\n  ((void (__cdecl __noreturn *)(int))loc_807018F)(a1);\n}\n"
    ],
    "sub_80723FC": [
        "0x80723fc",
        "int __usercall sub_80723FC@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_80963DC(a1, a2);\n}\n"
    ],
    "sub_8072406": [
        "0x8072406",
        "int __usercall sub_8072406@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  _BYTE **v4; // esi\n  int v5; // edx\n  void *v6; // esp\n  char *v7; // ebx\n  int *v8; // eax\n  int v9; // ecx\n  int v10; // ecx\n  const char *v11; // eax\n  int v13; // [esp+0h] [ebp-1Ch]\n  int v14; // [esp+4h] [ebp-18h] BYREF\n  int i; // [esp+8h] [ebp-14h]\n  int v16; // [esp+Ch] [ebp-10h]\n\n  v14 = a1;\n  v3 = *(const char **)(a2 + 4);\n  if ( v3 && strcmp(v3, \"-l\") )\n  {\n    v4 = (_BYTE **)(a2 + 4);\n    do\n    {\n      if ( **v4 == 37 )\n      {\n        v5 = sub_8070349(*v4, 0);\n        v16 = *(_DWORD *)(v5 + 20);\n        if ( (*(_BYTE *)(v5 + 25) & 2) != 0 )\n          v16 = 1;\n        v6 = alloca(16 * v16 + 16);\n        v7 = (char *)&v14;\n        *v4 = &v14;\n        for ( i = 0; i < v16; ++i )\n        {\n          v8 = (int *)(*(_DWORD *)(v5 + 12) + 12 * i);\n          v9 = v8[1];\n          if ( v9 == -1 || (_BYTE)v9 == 127 )\n          {\n            v10 = *v8;\n            v11 = \" -%u\";\n            if ( (*(_BYTE *)(v5 + 25) & 2) == 0 )\n              v11 = \" %u\";\n            v13 = v5;\n            v7 += sprintf(v7, v11, v10);\n            v5 = v13;\n          }\n        }\n        *v7 = 0;\n      }\n      ++v4;\n    }\n    while ( *v4 );\n  }\n  return sub_806C641(v14, a2);\n}\n"
    ],
    "sub_80724DF": [
        "0x80724df",
        "int sub_80724DF()\n{\n  sub_80AED34();\n  return 0;\n}\n"
    ],
    "sub_80724EC": [
        "0x80724ec",
        "int __usercall sub_80724EC@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_809191A(a1, a2);\n}\n"
    ],
    "sub_80724F6": [
        "0x80724f6",
        "int __usercall sub_80724F6@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_8099228(a1, a2);\n}\n"
    ],
    "sub_8072500": [
        "0x8072500",
        "char __usercall sub_8072500@<al>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4)\n{\n  char *v5; // ebp\n  char *v6; // ebx\n  int v7; // edx\n  DIR *v8; // eax\n  _BYTE *v9; // eax\n  _BYTE *v10; // esi\n  _BOOL4 v11; // eax\n  int v12; // esi\n  char *v13; // eax\n  char *v14; // eax\n  char *v15; // edx\n  const char *v16; // eax\n  char *v17; // eax\n  int v18; // eax\n  const char *v19; // ebp\n  _BYTE *v20; // ebp\n  int v21; // ebp\n  int v22; // ecx\n  char *dest; // [esp+0h] [ebp-8Ch]\n  char *desta; // [esp+0h] [ebp-8Ch]\n  char *pattern; // [esp+4h] [ebp-88h]\n  int v27; // [esp+8h] [ebp-84h]\n  DIR *dirp; // [esp+Ch] [ebp-80h]\n  int v30; // [esp+10h] [ebp-7Ch]\n  char v31; // [esp+17h] [ebp-75h]\n  char *v32; // [esp+18h] [ebp-74h]\n\n  v5 = a2;\n  dest = (char *)(a4 + *(_DWORD *)a1);\n  pattern = a2;\n  v6 = a2;\n  v7 = 0;\n  while ( 1 )\n  {\n    LOBYTE(v8) = *v6;\n    if ( !*v6 )\n      break;\n    if ( (_BYTE)v8 == 42 || (_BYTE)v8 == 63 )\n    {\nLABEL_18:\n      v12 = 0;\n      v7 = 1;\n    }\n    else if ( (_BYTE)v8 == 91 )\n    {\n      v9 = v6 + 1;\n      if ( v6[1] == 33 )\n        v9 = v6 + 2;\n      while ( 1 )\n      {\n        v10 = v9;\n        if ( *v9 == 92 )\n          v10 = v9 + 1;\n        if ( !*v10 || *v10 == 47 )\n          break;\n        v9 = v10 + 1;\n        if ( v10[1] == 93 )\n          goto LABEL_18;\n      }\n      v12 = 0;\n    }\n    else\n    {\n      v11 = (_BYTE)v8 == 92;\n      v12 = v11;\n      if ( v6[v11] == 47 )\n      {\n        if ( v7 )\n          goto LABEL_28;\n        pattern = &v6[v11 + 1];\n      }\n    }\n    v6 += v12 + 1;\n  }\n  if ( v7 )\n  {\n    v12 = 0;\nLABEL_28:\n    if ( pattern > v5 )\n    {\n      v14 = v5;\n      do\n      {\n        v15 = v14 + 1;\n        if ( *v14 != 92 )\n          v15 = v14;\n        v14 = v15 + 1;\n        *dest++ = *v15;\n      }\n      while ( pattern > v15 + 1 );\n    }\n    *dest = 0;\n    v16 = *(const char **)a1;\n    v32 = &dest[-*(_DWORD *)a1];\n    if ( dest == *(char **)a1 )\n      v16 = \".\";\n    v8 = opendir(v16);\n    dirp = v8;\n    if ( v8 )\n    {\n      v27 = 1;\n      if ( *v6 )\n      {\n        *v6 = 0;\n        v6 += v12 + 1;\n        v27 = 0;\n      }\n      v30 = a3 - (v6 - v5);\n      v17 = pattern;\n      if ( *pattern == 92 )\n        v17 = pattern + 1;\n      v31 = *v17;\n      while ( !*(_BYTE *)(dword_80DBB8C + 40) )\n      {\n        v18 = readdir64();\n        if ( !v18 )\n          break;\n        if ( *(_BYTE *)(v18 + 19) != 46 || v31 == 46 )\n        {\n          v19 = (const char *)(v18 + 19);\n          if ( !fnmatch(pattern, (const char *)(v18 + 19), 0) )\n          {\n            if ( v27 )\n            {\n              strcpy(dest, v19);\n              sub_8070C89(*(const char **)a1);\n            }\n            else\n            {\n              v20 = (_BYTE *)stpcpy();\n              *v20 = 47;\n              v21 = (int)&v20[-*(_DWORD *)a1 + 1];\n              v22 = v30 + v21;\n              if ( *(_DWORD *)(a1 + 4) < (unsigned int)(v30 + v21 + 255) )\n              {\n                desta = (char *)(v22 + 4351);\n                *(_DWORD *)a1 = sub_804DB13(*(void **)a1, v22 + 4351);\n                *(_DWORD *)(a1 + 4) = desta;\n              }\n              sub_8072500(v21);\n              dest = &v32[*(_DWORD *)a1];\n            }\n          }\n        }\n      }\n      LOBYTE(v8) = closedir(dirp);\n      if ( !v27 )\n      {\n        v8 = (DIR *)(v12 == 0 ? 47 : 92);\n        v6[~v12] = (char)v8;\n      }\n    }\n    return (char)v8;\n  }\n  if ( a4 )\n  {\n    do\n    {\n      v13 = v5 + 1;\n      if ( *v5 != 92 )\n        v13 = v5;\n      *dest++ = *v13;\n      v5 = v13 + 1;\n    }\n    while ( *v13 );\n    v8 = (DIR *)lstat64();\n    if ( !v8 )\n      LOBYTE(v8) = sub_8070C89(*(const char **)a1);\n  }\n  return (char)v8;\n}\n"
    ],
    "sub_807275C": [
        "0x807275c",
        "void __usercall __noreturn sub_807275C(int a1@<eax>)\n{\n  char *v2; // eax\n  int v3; // edi\n  char *v4; // eax\n  char s[16]; // [esp+0h] [ebp-5Ch] BYREF\n  char v6[76]; // [esp+10h] [ebp-4Ch] BYREF\n\n  v2 = (char *)*(&off_80B5EE0 + byte_80DB768);\n  if ( byte_80DB768 > 3 )\n  {\n    sprintf(s, \"\\\"%s\\\"\", (const char *)*(&off_80B5EE0 + byte_80DB768));\n    v2 = s;\n  }\n  v3 = sprintf(v6, \"unexpected %s\", v2);\n  if ( a1 != -1 )\n  {\n    v4 = (char *)*(&off_80B5EE0 + a1);\n    if ( a1 > 3 )\n    {\n      sprintf(s, \"\\\"%s\\\"\", (const char *)*(&off_80B5EE0 + a1));\n      v4 = s;\n    }\n    sprintf(&v6[v3], \" (expecting %s)\", v4);\n  }\n  sub_8070172(v6);\n}\n"
    ],
    "sub_80727DF": [
        "0x80727df",
        "size_t __usercall sub_80727DF@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  _DWORD *i; // ebx\n  int v6; // edx\n  int v7; // edx\n  int v8; // esi\n  _DWORD *j; // edi\n\n  while ( 2 )\n  {\n    if ( a2 )\n    {\n      a1 += (unsigned __int8)byte_80D0F76[*a2];\n      switch ( *a2 )\n      {\n        case 0:\n          sub_80727DF(a3, *((_DWORD *)a2 + 4));\n          goto LABEL_9;\n        case 1:\n          for ( i = (_DWORD *)*((_DWORD *)a2 + 1); i; i = (_DWORD *)*i )\n            a1 = sub_80727DF(a3, i[1]);\n          return a1;\n        case 2:\n        case 3:\n        case 4:\n        case 12:\n          v7 = *((_DWORD *)a2 + 3);\n          goto LABEL_11;\n        case 5:\n        case 6:\n        case 7:\n        case 9:\n        case 10:\n          v6 = *((_DWORD *)a2 + 2);\n          goto LABEL_20;\n        case 8:\n        case 13:\n          sub_80727DF(a3, *((_DWORD *)a2 + 3));\n          v6 = *((_DWORD *)a2 + 2);\n          goto LABEL_20;\n        case 11:\n          strlen(*((const char **)a2 + 4));\nLABEL_9:\n          v7 = *((_DWORD *)a2 + 3);\nLABEL_11:\n          a1 = sub_80727DF(a3, v7);\n          a2 = (char *)*((_DWORD *)a2 + 2);\n          continue;\n        case 14:\n          v8 = sub_80727DF(a3, *((_DWORD *)a2 + 3));\n          return ((strlen(*((const char **)a2 + 2)) + 8) & 0xFFFFFFF8) + v8;\n        case 15:\n          for ( j = (_DWORD *)*((_DWORD *)a2 + 3); j; j = (_DWORD *)*j )\n            a1 = sub_80727DF(a3, j[1]);\n          a1 += (strlen(*((const char **)a2 + 2)) + 8) & 0xFFFFFFF8;\n          goto LABEL_21;\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        case 20:\n        case 21:\n        case 22:\n        case 23:\n          v6 = *((_DWORD *)a2 + 4);\n          goto LABEL_20;\n        case 24:\n        case 25:\n          v6 = *((_DWORD *)a2 + 3);\nLABEL_20:\n          a1 = sub_80727DF(a3, v6);\n          goto LABEL_21;\n        case 26:\nLABEL_21:\n          a2 = (char *)*((_DWORD *)a2 + 1);\n          continue;\n        default:\n          return a1;\n      }\n    }\n    return a1;\n  }\n}\n"
    ],
    "sub_80728DD": [
        "0x80728dd",
        "int __usercall sub_80728DD@<eax>(int result@<eax>, int a2@<edx>)\n{\n  unsigned __int8 *v2; // ebx\n  const char *v3; // esi\n  const char *v4; // eax\n  const char *v5; // esi\n  _DWORD *v6; // ebx\n  int v7; // edx\n  int v8; // edx\n  int v9; // edx\n  int v10; // edx\n  const char *v11; // ebx\n  int v12; // edx\n  int v13; // edx\n  int v14; // edx\n  int k; // esi\n  int i; // esi\n  int j; // ebx\n  const char *v18; // eax\n  int v19; // edx\n  int v20; // edx\n  int m; // ebx\n  int v22; // edx\n  int v23; // edx\n  const char *v24; // eax\n  int v25; // edx\n  int v26; // edx\n  int v27; // eax\n  signed int v28; // eax\n\n  v2 = (unsigned __int8 *)result;\n  while ( 2 )\n  {\n    if ( !v2 )\n      return result;\n    result = *v2;\n    switch ( *v2 )\n    {\n      case 0u:\n        for ( i = *((_DWORD *)v2 + 3); i; i = *(_DWORD *)(i + 4) )\n        {\n          result = sub_80728DD();\n          if ( *(_DWORD *)(i + 4) )\n            result = sub_8071B5D(\" \", a2);\n        }\n        for ( j = *((_DWORD *)v2 + 4); j; j = *(_DWORD *)(j + 4) )\n        {\n          sub_8071B5D(\" \", a2);\n          result = sub_80728DD();\n        }\n        return result;\n      case 2u:\n      case 3u:\n        goto LABEL_13;\n      case 4u:\n        sub_8071B5D(\"(\", a2);\n        v11 = \")\";\n        goto LABEL_22;\n      case 5u:\n        v5 = \" && \";\n        goto LABEL_12;\n      case 6u:\n        v5 = \" || \";\n        goto LABEL_12;\n      case 7u:\n        v5 = \"; \";\nLABEL_12:\n        sub_80728DD();\n        result = sub_8071B5D(v5, v8);\nLABEL_13:\n        v2 = (unsigned __int8 *)*((_DWORD *)v2 + 2);\n        continue;\n      case 8u:\n        sub_8071B5D(\"if \", a2);\n        sub_80728DD();\n        sub_8071B5D(\"; then \", v9);\n        if ( *((_DWORD *)v2 + 3) )\n        {\n          sub_80728DD();\n          sub_8071B5D(\"; else \", v10);\n        }\n        v11 = \"; fi\";\n        goto LABEL_22;\n      case 9u:\n        v4 = \"while \";\n        goto LABEL_20;\n      case 0xAu:\n        v4 = \"until \";\nLABEL_20:\n        sub_8071B5D(v4, a2);\n        sub_80728DD();\n        goto LABEL_21;\n      case 0xBu:\n        sub_8071B5D(\"for \", a2);\n        sub_8071B5D(*((const char **)v2 + 4), v13);\n        sub_8071B5D(\" in \", v14);\n        for ( k = *((_DWORD *)v2 + 2); k; k = *(_DWORD *)(k + 4) )\n        {\n          sub_80728DD();\n          if ( *(_DWORD *)(k + 4) )\n            sub_8071B5D(\" \", v12);\n        }\nLABEL_21:\n        sub_8071B5D(\"; do \", v12);\n        v11 = \"; done\";\nLABEL_22:\n        sub_80728DD();\n        goto LABEL_40;\n      case 0xCu:\n        sub_8071B5D(\"case \", a2);\n        sub_8071B5D(*(const char **)(*((_DWORD *)v2 + 2) + 8), v19);\n        sub_8071B5D(\" in \", v20);\n        for ( m = *((_DWORD *)v2 + 3); m; m = *(_DWORD *)(m + 4) )\n        {\n          sub_80728DD();\n          sub_8071B5D(\") \", v22);\n          sub_80728DD();\n          sub_8071B5D(\";; \", v23);\n        }\n        v11 = \"esac\";\n        goto LABEL_40;\n      case 0xEu:\n        sub_8071B5D(*((const char **)v2 + 2), a2);\n        v11 = \"() { ... }\";\n        goto LABEL_40;\n      case 0xFu:\n        v11 = (const char *)*((_DWORD *)v2 + 2);\n        goto LABEL_40;\n      case 0x10u:\n        v3 = \">\";\n        goto LABEL_51;\n      case 0x11u:\n      case 0x16u:\n        v3 = \">&\";\n        goto LABEL_51;\n      case 0x12u:\n        v3 = \">|\";\n        goto LABEL_51;\n      case 0x13u:\n        v3 = \"<\";\n        goto LABEL_51;\n      case 0x14u:\n        v3 = \"<>\";\n        goto LABEL_51;\n      case 0x15u:\n        v3 = \">>\";\n        goto LABEL_51;\n      case 0x17u:\n        v3 = \"<&\";\nLABEL_51:\n        v24 = sub_804D6F7(*((_DWORD *)v2 + 2));\n        sub_8071B5D(v24, v25);\n        v27 = sub_8071B5D(v3, v26);\n        LOBYTE(v27) = *v2;\n        result = v27 - 22;\n        if ( (unsigned __int8)result > 1u )\n        {\n          v2 = (unsigned __int8 *)*((_DWORD *)v2 + 4);\n          continue;\n        }\n        v28 = *((_DWORD *)v2 + 3);\n        if ( v28 < 0 )\n          v18 = \"-\";\n        else\n          v18 = sub_804D6F7(v28);\n        return sub_8071B5D(v18, a2);\n      case 0x18u:\n      case 0x19u:\n        v11 = \"<<...\";\nLABEL_40:\n        v18 = v11;\n        return sub_8071B5D(v18, a2);\n      case 0x1Au:\n        result = sub_8071B5D(\"!\", a2);\n        v2 = (unsigned __int8 *)*((_DWORD *)v2 + 1);\n        continue;\n      default:\n        v6 = (_DWORD *)*((_DWORD *)v2 + 1);\n        while ( 1 )\n        {\n          result = sub_80728DD();\n          v6 = (_DWORD *)*v6;\n          if ( !v6 )\n            break;\n          sub_8071B5D(\" | \", v7);\n        }\n        return result;\n    }\n  }\n}\n"
    ],
    "sub_8072B54": [
        "0x8072b54",
        "__pid_t __usercall sub_8072B54@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int v6; // eax\n  __pid_t v7; // esi\n  int v8; // edx\n  int v9; // eax\n  __pid_t *v10; // ebx\n  int v11; // edi\n\n  v6 = fork();\n  if ( v6 < 0 )\n  {\n    if ( a1 )\n      sub_806F9B7(a1);\n    sub_806FB57(\"can't fork: %m\");\n  }\n  v7 = v6;\n  if ( v6 )\n  {\n    if ( a1 )\n    {\n      if ( a3 != 2 )\n      {\n        if ( (*(_BYTE *)(a1 + 25) & 2) != 0 )\n        {\n          if ( *(_DWORD *)(a1 + 20) )\n            v6 = **(_DWORD **)(a1 + 12);\n          setpgid(v7, v6);\n        }\n        if ( a3 == 1 )\n        {\n          *(_DWORD *)(dword_80DBB8C + 472) = v7;\n          sub_806ED0E(a1, 1);\n        }\n      }\n      v8 = *(_DWORD *)(a1 + 12);\n      v9 = *(_DWORD *)(a1 + 20);\n      *(_DWORD *)(a1 + 20) = v9 + 1;\n      v10 = (__pid_t *)(v8 + 12 * v9);\n      *v10 = v7;\n      v10[1] = -1;\n      v10[2] = dword_80DBB8C + 44;\n      if ( byte_80DB76D && a2 )\n      {\n        v11 = dword_80DBB88;\n        dword_80DB6D8 = *(_DWORD *)(dword_80DBB88 + 4);\n        sub_80728DD(a2, v8);\n        v10[2] = (__pid_t)sub_804DB46(*(const char **)(v11 + 4));\n      }\n    }\n    else\n    {\n      while ( dword_80DB6DC && sub_8070DA4(0, 0) > 0 )\n        ;\n      ++dword_80DB6DC;\n    }\n  }\n  else\n  {\n    *(_DWORD *)(dword_80DBB8C + 456) = 0;\n    sub_8071E56(a1, a2, a3);\n  }\n  return v7;\n}\n"
    ],
    "sub_8072C57": [
        "0x8072c57",
        "void __noreturn sub_8072C57(int a1, int a2, ...)\n{\n  va_list va; // [esp+Ch] [ebp+Ch] BYREF\n\n  va_start(va, a2);\n  sub_806FAC0(\"%s: %s\", va);\n  sub_806F4BD();\n  sub_806F22F(4);\n}\n"
    ],
    "sub_8072C74": [
        "0x8072c74",
        "void __usercall __noreturn sub_8072C74(const char *a1@<eax>, const char **a2@<edx>, int a3@<ecx>, int a4)\n{\n  int v6; // ebx\n  const char *v7; // eax\n  int v8; // edi\n  char v9; // al\n  char *v10; // eax\n  char **envp; // [esp+0h] [ebp-18h]\n  int v12[5]; // [esp+4h] [ebp-14h] BYREF\n\n  v12[0] = a3;\n  envp = (char **)sub_8071CF0(1, 32, 0);\n  if ( strchr(a1, 47) )\n  {\n    sub_80720BA(envp, a2, a1);\n    v6 = *(_DWORD *)dword_80DBB7C;\n  }\n  else\n  {\n    v6 = 2;\n    while ( 1 )\n    {\n      v7 = (const char *)sub_8071D7C(v12, a1);\n      v8 = (int)v7;\n      if ( !v7 )\n        break;\n      if ( --a4 < 0 && !dword_80DB6FC )\n      {\n        sub_80720BA(envp, a2, v7);\n        if ( *(_DWORD *)dword_80DBB7C != 2 && *(_DWORD *)dword_80DBB7C != 20 )\n          v6 = *(_DWORD *)dword_80DBB7C;\n      }\n      sub_806EC35(v8);\n    }\n  }\n  v9 = 127;\n  if ( v6 != 2 )\n    v9 = v6 == 13 ? 126 : 2;\n  *(_BYTE *)dword_80DBB8C = v9;\n  v10 = sub_80720F6(v6, \"not found\");\n  sub_8072C57(4, (int)\"%s: %s\", a1, v10);\n}\n"
    ],
    "sub_8072DB0": [
        "0x8072db0",
        "char sub_8072DB0()\n{\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  fputs_unlocked();\n  return sub_806F4A5();\n}\n"
    ],
    "sub_8072DD3": [
        "0x8072dd3",
        "void __usercall __noreturn sub_8072DD3(int a1@<eax>)\n{\n  ((void (__cdecl __noreturn *)(int))loc_807018F)(a1);\n}\n"
    ],
    "sub_8072EED": [
        "0x8072eed",
        "char *__usercall sub_8072EED@<eax>(unsigned __int8 *a1@<eax>)\n{\n  _DWORD *v2; // eax\n  int v3; // ebx\n  char *result; // eax\n  char v5; // dl\n\n  v2 = (_DWORD *)sub_806ECAC(a1);\n  v3 = *sub_806ECE9(v2, (int)a1);\n  if ( !v3 )\n    return 0;\n  if ( (*(_BYTE *)(v3 + 5) & 2) != 0 )\n    (*(void (**)(void))(v3 + 12))();\n  if ( (*(_BYTE *)(v3 + 4) & 0x20) != 0 )\n    return 0;\n  if ( v3 == dword_80DBB90 + 280 && *(_DWORD *)(dword_80DBB90 + 288) == dword_80DBB90 + 332 )\n    sub_8070CE3((char *)(dword_80DBB90 + 339), 0xDu, \"%d\", *(_DWORD *)(dword_80DBB90 + 328));\n  result = *(char **)(v3 + 8);\n  do\n  {\n    v5 = *result;\n    if ( !*result )\n      break;\n    ++result;\n  }\n  while ( v5 != 61 );\n  return result;\n}\n"
    ],
    "sub_8072F60": [
        "0x8072f60",
        "_DWORD *sub_8072F60()\n{\n  int v0; // eax\n  unsigned int v1; // ebx\n  unsigned int v2; // esi\n  _DWORD *v3; // eax\n  unsigned __int8 **i; // ebx\n  unsigned __int8 *v5; // esi\n  unsigned int v6; // eax\n  const char *v7; // eax\n  char *v8; // eax\n  unsigned int v9; // edx\n  const char *v10; // eax\n  char *v11; // eax\n  const char *v12; // ebx\n  int v14; // [esp+0h] [ebp-1F0h]\n  int v15; // [esp+4h] [ebp-1ECh]\n  int v16; // [esp+58h] [ebp-198h]\n  int v17; // [esp+5Ch] [ebp-194h]\n  struct utsname name; // [esp+60h] [ebp-190h] BYREF\n\n  dword_80DB5F8 = (int)sub_804DAFA(0x400u);\n  dword_80DB5F4 = dword_80DB5F8;\n  dword_80DB5E4 = 1;\n  *(_BYTE *)(dword_80DBB8C + 76) = 1;\n  sub_806F2B1(17);\n  signal(1, 0);\n  v0 = dword_80DBB90;\n  *(_DWORD *)(dword_80DBB90 + 224) = \"PS1=\\\\w \\\\$ \";\n  v1 = v0 + 184;\n  v2 = v0 + 328;\n  do\n  {\n    v3 = (_DWORD *)sub_806ECAC(*(unsigned __int8 **)(v1 + 8));\n    *(_DWORD *)v1 = *v3;\n    *v3 = v1;\n    v1 += 16;\n  }\n  while ( v2 > v1 );\n  for ( i = (unsigned __int8 **)environ; i; ++i )\n  {\n    v5 = *i;\n    if ( !*i )\n      break;\n    if ( strchr((const char *)v5, 61) )\n      sub_806FB7B(v5, 9);\n  }\n  sub_806FB7B(\"OPTIND=1\", 8);\n  v6 = getppid();\n  v7 = sub_804D6F7(v6);\n  sub_806FE06(\"PPID\", v7);\n  v8 = sub_8072EED(\"SHLVL\");\n  v9 = 1;\n  if ( v8 )\n    v9 = atoi(v8) + 1;\n  v10 = sub_804D6F7(v9);\n  sub_806FCE2(\"SHLVL\", v10, 1);\n  if ( !sub_8072EED(\"HOSTNAME\") )\n  {\n    uname(&name);\n    sub_806FE06(\"HOSTNAME\", name.nodename);\n  }\n  v11 = sub_8072EED((unsigned __int8 *)\"PWD\");\n  v12 = v11;\n  if ( v11\n    && (*v11 != 47\n     || stat64()\n     || stat64()\n     || v15 != *(_DWORD *)&name.sysname[4]\n     || v14 != *(_DWORD *)name.sysname\n     || v17 != *(_DWORD *)&name.nodename[27]\n     || v16 != *(_DWORD *)&name.nodename[23]) )\n  {\n    v12 = 0;\n  }\n  return sub_8070805(v12, 0);\n}\n"
    ],
    "sub_80730FF": [
        "0x80730ff",
        "int __usercall sub_80730FF@<eax>(unsigned __int8 *a1@<eax>, char a2@<dl>, __int16 a3@<cx>, int *a4)\n{\n  int v4; // ebx\n  int v5; // edx\n  char v6; // bp\n  int v7; // edi\n  unsigned __int8 v8; // dl\n  signed int v9; // eax\n  unsigned int v10; // ebx\n  _BYTE *v11; // eax\n  int v12; // edi\n  char v13; // bp\n  int i; // edx\n  char v15; // cl\n  int v16; // eax\n  _DWORD *v17; // esi\n  int v18; // eax\n  char *v19; // esi\n  int v21; // [esp+4h] [ebp-24h]\n  char *v22; // [esp+8h] [ebp-20h]\n  int v23; // [esp+Ch] [ebp-1Ch]\n  unsigned int s; // [esp+10h] [ebp-18h]\n  int v25; // [esp+14h] [ebp-14h] BYREF\n\n  v4 = *a4;\n  v5 = a2 & 0xF;\n  if ( v5 == 3 || v5 == 10 )\n  {\n    v23 = 1;\n    v6 = 2;\n  }\n  else\n  {\n    v6 = a3 & 0x11 | 2;\n    v23 = 0;\n  }\n  v7 = (a3 << 8) & 0x100;\n  v21 = v4 != 0;\n  v8 = *a1;\n  if ( *a1 == 45 )\n  {\n    v11 = (_BYTE *)sub_80716AF(0xFu, dword_80DB6D4);\n    dword_80DB6D4 = (int)v11;\n    v12 = dword_80DBB8C;\n    v13 = 0;\n    v10 = 0;\n    for ( i = 14; i != -1; --i )\n    {\n      if ( *(_BYTE *)(v12 + i + 45) )\n      {\n        v15 = *off_80B5FE0[i];\n        if ( v15 )\n        {\n          *v11 = v15;\n          ++v10;\n          ++v11;\n          v13 = 1;\n        }\n      }\n    }\n    if ( v13 )\n      dword_80DB6D4 = (int)v11;\n    goto LABEL_55;\n  }\n  if ( *a1 <= 0x2Du )\n  {\n    if ( v8 == 35 )\n    {\n      v9 = *(_DWORD *)dword_80DBB90;\n      goto LABEL_24;\n    }\n    if ( v8 <= 0x23u )\n    {\n      if ( v8 != 33 )\n        goto LABEL_52;\n      v9 = *(_DWORD *)(dword_80DBB8C + 472);\n      if ( v9 )\n      {\nLABEL_24:\n        v10 = sub_8071998(v9, v9 >> 31);\n        goto LABEL_55;\n      }\n      return -1;\n    }\n    if ( v8 == 36 )\n    {\n      v9 = *(_DWORD *)(dword_80DBB8C + 4);\n      goto LABEL_24;\n    }\n    if ( v8 != 42 )\n      goto LABEL_52;\n    if ( v4 )\n      v7 = 0;\nLABEL_37:\n    v16 = 32;\n    if ( (*(_BYTE *)(dword_80DBB90 + 188) & 0x20) == 0 )\n      v16 = *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB90 + 192) + 4);\n    v7 |= v16;\nLABEL_40:\n    HIBYTE(v25) = v7;\n    *a4 = (_BYTE)v7 == 0;\n    v17 = *(_DWORD **)(dword_80DBB90 + 16);\n    if ( v17 )\n    {\n      v10 = 0;\n      while ( 1 )\n      {\n        v22 = (char *)*v17++;\n        if ( !v22 )\n          break;\n        s = strlen(v22);\n        sub_80718D9((int)v22, s, v21, v6);\n        v10 += s;\n        if ( *v17 && v7 )\n        {\n          ++v10;\n          sub_80718D9((int)&v25 + 3, 1u, v21, v6);\n        }\n      }\n      goto LABEL_55;\n    }\n    return -1;\n  }\n  if ( v8 == 63 )\n  {\n    v9 = *(unsigned __int8 *)dword_80DBB8C;\n    goto LABEL_24;\n  }\n  if ( v8 > 0x3Fu )\n  {\n    if ( v8 != 64 )\n      goto LABEL_52;\n    if ( v4 && ((a3 << 8) & 0x100) != 0 )\n      goto LABEL_40;\n    goto LABEL_37;\n  }\n  if ( (unsigned __int8)(v8 - 48) > 9u )\n  {\nLABEL_52:\n    v19 = sub_8072EED(a1);\n    goto LABEL_53;\n  }\n  v18 = atoi((const char *)a1);\n  if ( v18 < 0 || *(_DWORD *)dword_80DBB90 < v18 )\n    return -1;\n  if ( v18 )\n    v19 = *(char **)(*(_DWORD *)(dword_80DBB90 + 16) + 4 * v18 - 4);\n  else\n    v19 = *(char **)(dword_80DBB8C + 28);\nLABEL_53:\n  if ( !v19 )\n    return -1;\n  v10 = strlen(v19);\n  sub_80718D9((int)v19, v10, v21, v6);\nLABEL_55:\n  if ( v23 )\n    dword_80DB6D4 -= v10;\n  return v10;\n}\n"
    ],
    "sub_807335A": [
        "0x807335a",
        "void __noreturn sub_807335A()\n{\n  ((void (__cdecl __noreturn *)(_DWORD, _DWORD))loc_807018F)(0, 0);\n}\n"
    ],
    "sub_8073440": [
        "0x8073440",
        "int __usercall sub_8073440@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ebp\n  unsigned int v4; // eax\n  _BYTE *v5; // edi\n  int v6; // eax\n  int v7; // ebx\n  const char *v8; // eax\n  const char *v9; // edx\n  char v10; // cl\n  int v11; // edi\n  int v12; // ebx\n  _BYTE *v13; // edx\n  char *v14; // eax\n  const char *v15; // edx\n  char *v16; // eax\n  signed int v17; // ebp\n  const char *v18; // eax\n  int v19; // eax\n  const char *v21; // [esp+0h] [ebp-20h]\n  const char *v22; // [esp+0h] [ebp-20h]\n  const char **v23; // [esp+4h] [ebp-1Ch]\n  const char *v24; // [esp+8h] [ebp-18h]\n  char v25[18]; // [esp+Eh] [ebp-12h] BYREF\n\n  if ( a1 <= 2 )\n    sub_806FB57(\"usage: getopts optstring var [arg]\");\n  v2 = dword_80DBB90;\n  if ( a1 == 3 )\n  {\n    v3 = *(_DWORD *)(dword_80DBB90 + 16);\n    v4 = *(_DWORD *)dword_80DBB90 + 1;\n  }\n  else\n  {\n    v3 = a2 + 12;\n    v4 = a1 - 2;\n  }\n  if ( v4 < *(_DWORD *)(dword_80DBB90 + 4) )\n  {\n    *(_DWORD *)(dword_80DBB90 + 4) = 1;\n    *(_DWORD *)(v2 + 8) = -1;\n  }\n  v24 = *(const char **)(a2 + 8);\n  v5 = *(_BYTE **)(a2 + 4);\n  v6 = *(_DWORD *)(v2 + 4);\n  v7 = *(_DWORD *)(v2 + 8);\n  v25[1] = 0;\n  *(_DWORD *)(v2 + 4) = -1;\n  v23 = (const char **)(v3 + 4 * v6 - 4);\n  if ( v6 <= 1\n    || v7 < 0\n    || (v21 = *(const char **)(v3 + 4 * v6 - 8), v7 > (int)strlen(v21))\n    || (v8 = &v21[v7]) == 0\n    || !*v8 )\n  {\n    v9 = *v23;\n    if ( !*v23 || *v9 != 45 || (v8 = v9 + 1, (v10 = v9[1]) == 0) || (++v23, v10 == 45) && !v9[2] )\n    {\n      sub_806FDFD(\"OPTARG\");\n      v11 = 1;\n      LOBYTE(v12) = 63;\nLABEL_46:\n      v22 = 0;\n      goto LABEL_49;\n    }\n  }\n  v22 = v8 + 1;\n  v12 = *(unsigned __int8 *)v8;\n  v13 = v5;\n  while ( (_BYTE)v12 != *v13 )\n  {\n    if ( !*v13 )\n    {\n      v14 = sub_8072EED(\"OPTERR\");\n      if ( v14 && *v14 == 48 && !v14[1] || *v5 == 58 )\n      {\n        v25[0] = v12;\n        sub_806FE06(\"OPTARG\", v25);\n      }\n      else\n      {\n        fprintf(stderr, \"Illegal option -%c\\n\", v12);\n        sub_806FDFD(\"OPTARG\");\n      }\n      goto LABEL_28;\n    }\n    if ( v13[1] == 58 )\n      v13 += 2;\n    else\n      ++v13;\n  }\n  if ( v13[1] == 58 )\n  {\n    v15 = *v23;\n    if ( v8[1] )\n    {\n      if ( v15 != v22 )\n      {\nLABEL_45:\n        sub_806FE06(\"OPTARG\", v22);\n        v11 = 0;\n        goto LABEL_46;\n      }\n    }\n    else\n    {\n      if ( !v15 )\n      {\n        v16 = sub_8072EED(\"OPTERR\");\n        if ( (!v16 || *v16 != 48 || v16[1]) && *v5 != 58 )\n        {\n          fprintf(stderr, \"No arg for -%c option\\n\", v12);\n          sub_806FDFD(\"OPTARG\");\n          v22 = 0;\nLABEL_28:\n          v11 = 0;\n          LOBYTE(v12) = 63;\n          goto LABEL_49;\n        }\n        v25[0] = v12;\n        sub_806FE06(\"OPTARG\", v25);\n        LOBYTE(v12) = 58;\n        v22 = 0;\n        goto LABEL_48;\n      }\n      v22 = *v23;\n    }\n    ++v23;\n    goto LABEL_45;\n  }\n  sub_806FE06(\"OPTARG\", (const char *)(dword_80DBB8C + 44));\nLABEL_48:\n  v11 = 0;\nLABEL_49:\n  v17 = (((int)v23 - v3) >> 2) + 1;\n  v18 = sub_804D70F(v17);\n  sub_806FCE2(\"OPTIND\", v18, 64);\n  v25[0] = v12;\n  sub_806FE06(v24, v25);\n  v19 = -1;\n  if ( v22 )\n    v19 = v22 - *(v23 - 1);\n  *(_DWORD *)(v2 + 8) = v19;\n  *(_DWORD *)(v2 + 4) = v17;\n  return v11;\n}\n"
    ],
    "sub_80736A0": [
        "0x80736a0",
        "void __noreturn sub_80736A0()\n{\n  sub_8070322();\n}\n"
    ],
    "sub_8073952": [
        "0x8073952",
        "int sub_8073952()\n{\n  _DWORD *v0; // eax\n  int v1; // edx\n  int result; // eax\n  int v3; // edx\n  unsigned __int8 *v4; // edx\n  _DWORD *v5; // edx\n  int v6; // ecx\n  char v7; // dl\n  signed int v8; // ebx\n  _WORD *v9; // edi\n  int v10; // ebp\n  char *v11; // eax\n  int v12; // esi\n  int v13; // eax\n  int v14; // eax\n  _DWORD *v15; // edi\n  char *v16; // esi\n  int v17; // eax\n  char v18; // bl\n  unsigned __int8 *v19; // eax\n  _DWORD *v20; // edx\n  int v21; // [esp-14h] [ebp-14h]\n\n  v0 = off_80DB55C;\n  v1 = *((_DWORD *)off_80DB55C + 18);\n  if ( v1 )\n  {\n    *((_DWORD *)off_80DB55C + 18) = v1 - 1;\n    return v0[v1 + 15];\n  }\n  v3 = *((_DWORD *)off_80DB55C + 3) - 1;\n  *((_DWORD *)off_80DB55C + 3) = v3;\n  if ( v3 >= 0 )\n  {\n    v4 = (unsigned __int8 *)v0[5];\n    v0[5] = v4 + 1;\n    result = *v4;\n    v5 = off_80DB55C;\n    *((_DWORD *)off_80DB55C + 17) = *((_DWORD *)off_80DB55C + 16);\n    v5[16] = result;\n    return result;\n  }\n  v6 = v0[7];\n  if ( v6 )\n  {\n    if ( v3 != -1 || !*(_DWORD *)(v6 + 12) || (v7 = *(_BYTE *)(v0[5] - 1), v7 == 32) || (result = 257, v7 == 9) )\n    {\n      sub_806F659();\n      result = sub_8073952();\n    }\n  }\n  else\n  {\n    if ( v3 >= -90 && v0[6] )\n    {\n      v8 = v0[4];\n      if ( v8 > 0 )\n      {\nLABEL_33:\n        v15 = off_80DB55C;\n        v16 = (char *)*((_DWORD *)off_80DB55C + 5);\n        do\n        {\n          --v8;\n          if ( *v16 )\n          {\n            if ( *v16 == 10 )\n            {\n              v15[3] = &v16[-v15[5]];\n              ++v16;\n              goto LABEL_41;\n            }\n            ++v16;\n          }\n          else\n          {\n            memmove(v16, v16 + 1, v8);\n          }\n        }\n        while ( v8 );\n        v17 = (int)&v16[-v15[5] - 1];\n        v15[3] = v17;\n        if ( v17 < 0 )\n          goto LABEL_15;\nLABEL_41:\n        v15[4] = v8;\n        if ( *(_BYTE *)(dword_80DBB8C + 53) )\n        {\n          v18 = *v16;\n          *v16 = 0;\n          sub_8070BC7();\n          *v16 = v18;\n        }\n        v19 = (unsigned __int8 *)*((_DWORD *)off_80DB55C + 5);\n        *((_DWORD *)off_80DB55C + 5) = v19 + 1;\n        result = *v19;\n        goto LABEL_44;\n      }\n      sub_806F4BD();\nLABEL_15:\n      v9 = (_WORD *)*((_DWORD *)off_80DB55C + 6);\n      *((_DWORD *)off_80DB55C + 5) = v9;\n      while ( 1 )\n      {\n        v10 = dword_80DBB8C;\n        if ( !*(_BYTE *)(dword_80DBB8C + 48) || *((_DWORD *)off_80DB55C + 2) )\n        {\n          v8 = sub_80B2319(1023, v9);\n          if ( v8 > 0 )\n            goto LABEL_33;\n          goto LABEL_31;\n        }\n        v11 = sub_8072EED(\"TMOUT\");\n        v12 = -1;\n        if ( v11 )\n        {\n          v12 = 1000 * atoi(v11);\n          if ( v12 <= 0 )\n            v12 = -1;\n        }\n        v13 = dword_80DB6F8;\n        *(_DWORD *)(dword_80DB6F8 + 4) = v12;\n        *(_DWORD *)(v13 + 8) = *(_DWORD *)(dword_80DBB90 + 208) + 5;\n        v14 = sub_80AED5C(1024);\n        v8 = v14;\n        if ( v14 )\n          break;\n        write(1, \"^C\", 2u);\n        if ( *(_DWORD *)(v10 + 200) )\n        {\n          *v9 = 10;\n          raise(2);\n          v8 = 1;\n          goto LABEL_33;\n        }\n        *(_BYTE *)v10 = -126;\n        sub_804DD98(10);\n      }\n      if ( v14 >= 0 )\n        goto LABEL_33;\n      if ( *(_DWORD *)dword_80DBB7C == 11 && v12 > 0 )\n      {\n        puts(\"\\atimed out waiting for input: auto-logout\");\n        sub_80769A1(v21);\n      }\nLABEL_31:\n      v0 = off_80DB55C;\n      *((_DWORD *)off_80DB55C + 3) = -99;\n    }\n    ++v0[5];\n    result = 256;\n  }\nLABEL_44:\n  v20 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 17) = *((_DWORD *)off_80DB55C + 16);\n  v20[16] = result;\n  return result;\n}\n"
    ],
    "sub_8073B87": [
        "0x8073b87",
        "int sub_8073B87()\n{\n  int result; // eax\n\n  do\n    result = sub_8073952();\n  while ( result == 257 );\n  return result;\n}\n"
    ],
    "sub_8073B94": [
        "0x8073b94",
        "int __fastcall sub_8073B94(int a1)\n{\n  int result; // eax\n  int v2; // ebx\n  int v3; // eax\n  char *v4; // eax\n  int v5; // esi\n  int v6; // edx\n  int v7; // esi\n\n  if ( byte_80DB76A )\n  {\n    byte_80DB76A = 0;\n    return byte_80DB768;\n  }\n  sub_8074B7B(a1, 2);\n  while ( 1 )\n  {\n    do\n    {\n      do\n        v2 = sub_8074C1E();\n      while ( v2 == 32 || v2 == 9 );\n    }\n    while ( v2 == 257 );\n    if ( v2 != 35 )\n      break;\n    do\n      v3 = sub_8073952();\n    while ( v3 != 10 && v3 != 256 );\n    sub_806EE06();\n  }\n  if ( v2 != 92 )\n  {\n    if ( v2 == 256 )\n    {\n      v5 = 135073155;\n      goto LABEL_22;\n    }\n    if ( v2 == 10 )\n      sub_806EDF3();\n    v4 = strchr(\"\\n()&|;\", v2);\n    v5 = (int)v4;\n    if ( v4 )\n    {\n      if ( v4 - \"\\n()&|;\" <= 2 )\n      {\nLABEL_22:\n        v7 = v5 - (_DWORD)\"\\n()&|;\";\n        result = byte_80D0D73[v7];\n        byte_80DB768 = byte_80D0D73[v7];\n        return result;\n      }\n      if ( v2 == sub_8074C1E() )\n      {\n        v5 += 4;\n        goto LABEL_22;\n      }\n      sub_806EE06();\n      if ( v2 != 38 || v6 != 62 )\n        goto LABEL_22;\n    }\n  }\n  return sub_8073F3E(0, 0, 0);\n}\n"
    ],
    "sub_8073C7A": [
        "0x8073c7a",
        "int __fastcall sub_8073C7A(int a1)\n{\n  char v1; // si\n  int v2; // ebx\n  int v3; // ecx\n  _BYTE *v4; // eax\n  int v5; // edx\n  const char *v6; // eax\n\n  v1 = byte_80DB76B;\n  while ( 1 )\n  {\n    v2 = sub_8073B94(a1);\n    if ( (v1 & 4) != 0 )\n    {\n      while ( v2 == 1 )\n      {\n        sub_8076C18();\n        v2 = sub_8073B94(v3);\n      }\n    }\n    if ( v2 != 3 || byte_80DB769 )\n      break;\n    if ( (v1 & 2) != 0 )\n    {\n      v4 = sub_8070CCB(dword_80DB68C);\n      if ( v4 )\n      {\n        v2 = (v4 - (_BYTE *)&off_80B5EE0) >> 2;\n        byte_80DB768 = v2;\n        break;\n      }\n    }\n    if ( (byte_80DB76B & 1) == 0 )\n      break;\n    v5 = *sub_806F0C2(dword_80DB68C);\n    if ( !v5 || (*(_BYTE *)(v5 + 12) & 1) != 0 )\n      break;\n    v6 = *(const char **)(v5 + 8);\n    if ( *v6 )\n      sub_806F78A(v6, v5);\n  }\n  byte_80DB76B = 0;\n  return v2;\n}\n"
    ],
    "sub_8073D17": [
        "0x8073d17",
        "_DWORD *__fastcall sub_8073D17(int a1)\n{\n  int v1; // ebx\n  _DWORD *v2; // esi\n  _DWORD *result; // eax\n  char *v4; // esi\n\n  v1 = dword_80DB684;\n  if ( *(_BYTE *)dword_80DB684 == 24 )\n    byte_80DB76B = 8;\n  if ( sub_8073C7A(a1) != 3 )\n    sub_807275C(-1);\n  if ( *(_BYTE *)v1 == 24 )\n  {\n    v2 = (_DWORD *)dword_80DB680;\n    if ( !byte_80DB769 )\n      *(_BYTE *)v1 = 25;\n    sub_80719CE(dword_80DB68C, 0, 0);\n    v2[2] = dword_80DB68C;\n    *v2 = 0;\n    result = (_DWORD *)dword_80DB690;\n    if ( dword_80DB690 )\n    {\n      while ( *result )\n        result = (_DWORD *)*result;\n      *result = v2;\n    }\n    else\n    {\n      dword_80DB690 = (int)v2;\n    }\n  }\n  else\n  {\n    if ( (unsigned __int8)(*(_BYTE *)v1 - 22) > 1u )\n      goto LABEL_20;\n    v4 = dword_80DB68C;\n    *(_DWORD *)(v1 + 16) = 0;\n    result = (_DWORD *)sub_804ED6C(10, v4, 0, v1);\n    if ( !*(_DWORD *)dword_80DBB7C && (int)result >= 0 )\n    {\n      *(_DWORD *)(v1 + 12) = result;\n      return result;\n    }\n    if ( *v4 != 45 || v4[1] )\n    {\nLABEL_20:\n      result = sub_8070C69();\n      *(_DWORD *)(v1 + 16) = result;\n    }\n    else\n    {\n      *(_DWORD *)(v1 + 12) = -1;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8073DE5": [
        "0x8073de5",
        "_BYTE *__usercall sub_8073DE5@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int v3; // ebx\n  int v4; // eax\n  int v5; // ecx\n  _DWORD *i; // eax\n  int v7; // ecx\n  int v8; // eax\n  int v9; // edx\n  char v10; // si\n  _BYTE *v11; // ebp\n  int v12; // eax\n  int v13; // ecx\n  int v14; // esi\n  _DWORD *v15; // eax\n  _DWORD *v16; // eax\n  int v18; // [esp+4h] [ebp-14h]\n\n  v3 = 0;\n  while ( 2 )\n  {\n    v4 = sub_8073C7A(a2);\n    byte_80DB76A = 1;\n    if ( !v4 )\n    {\n      if ( !v3 )\n        v3 = -(a1 & 1);\nLABEL_8:\n      sub_8076C18();\n      return (_BYTE *)v3;\n    }\n    if ( v4 == 1 && (a1 & 1) != 0 )\n      goto LABEL_8;\n    byte_80DB76B = 7;\n    if ( a1 == 2 )\n    {\n      v8 = sub_8073C7A(v5);\n      byte_80DB76A = 1;\n      v9 = 572496897;\n      if ( _bittest(&v9, v8) )\n        return (_BYTE *)v3;\n    }\n    for ( i = (_DWORD *)sub_8077325(); ; i[2] = v18 )\n    {\n      v11 = i;\n      v12 = sub_8073C7A(v7);\n      if ( v12 == 6 )\n      {\n        v10 = 5;\n        goto LABEL_14;\n      }\n      if ( v12 != 7 )\n        break;\n      v10 = 6;\nLABEL_14:\n      byte_80DB76B = 7;\n      v18 = sub_8077325();\n      i = sub_8070C51(0xCu);\n      *(_BYTE *)i = v10;\n      i[1] = v11;\n      v7 = v18;\n    }\n    byte_80DB76A = 1;\n    v14 = sub_8073C7A(v13);\n    if ( v14 == 5 )\n    {\n      if ( *v11 == 1 )\n      {\n        v11[1] = 1;\n      }\n      else\n      {\n        if ( *v11 != 2 )\n        {\n          v15 = sub_8070C51(0x10u);\n          v15[2] = v11;\n          v11 = v15;\n        }\n        *v11 = 3;\n      }\n      if ( v3 )\n      {\nLABEL_26:\n        v16 = sub_8070C51(0xCu);\n        *(_BYTE *)v16 = 7;\n        v16[1] = v3;\n        v16[2] = v11;\n        v11 = v16;\n        goto LABEL_27;\n      }\n      goto LABEL_30;\n    }\n    if ( v3 )\n      goto LABEL_26;\nLABEL_27:\n    if ( v14 < 0 )\n      goto LABEL_32;\n    if ( v14 <= 1 )\n    {\n      byte_80DB76A = 1;\nLABEL_30:\n      v3 = (int)v11;\n      a1 |= 2u;\n      continue;\n    }\n    break;\n  }\n  if ( (unsigned int)(v14 - 4) <= 1 )\n    goto LABEL_30;\nLABEL_32:\n  if ( (a1 & 1) != 0 )\n    sub_807275C(-1);\n  byte_80DB76A = 1;\n  return v11;\n}\n"
    ],
    "sub_8073F3E": [
        "0x8073f3e",
        "int __usercall sub_8073F3E@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4)\n{\n  _BYTE *v5; // edi\n  unsigned __int8 *i; // ebx\n  int v7; // eax\n  _BYTE *v8; // eax\n  int v9; // edi\n  _BOOL4 v10; // edx\n  int v11; // edi\n  void *v12; // esp\n  int v13; // ebx\n  int v14; // eax\n  int v15; // ecx\n  int v16; // esi\n  char v17; // al\n  int v18; // edi\n  char v19; // al\n  int v20; // eax\n  int v21; // edx\n  int v22; // eax\n  int v23; // eax\n  char v24; // dl\n  int v25; // eax\n  int v26; // eax\n  int v27; // ecx\n  int v28; // eax\n  int v29; // eax\n  const char *v30; // eax\n  char *v31; // edi\n  int v32; // ebx\n  int v34; // ebx\n  _DWORD *v35; // eax\n  int v36; // ecx\n  _DWORD *v37; // edi\n  int v38; // eax\n  int v39; // eax\n  int v40; // ecx\n  int v41; // eax\n  int v42; // ecx\n  int v43; // edi\n  int v44; // edx\n  int v45; // ecx\n  int v46; // esi\n  int v47; // ecx\n  int v48; // eax\n  int v49; // ecx\n  int v50; // ecx\n  int v51; // edx\n  int v52; // eax\n  char *v53; // eax\n  _BYTE *v54; // edx\n  int v55; // eax\n  int v56; // eax\n  unsigned int v57; // ebx\n  void *v58; // esp\n  int v59; // ecx\n  int v60; // eax\n  int v61; // esi\n  int v62; // eax\n  _BYTE *v63; // ecx\n  _BYTE *v64; // edx\n  const char *v65; // eax\n  char *v66; // eax\n  char *v67; // esi\n  int v68; // ecx\n  char v69; // dl\n  int v70; // ecx\n  _BYTE *v71; // edi\n  _BYTE *v72; // eax\n  _BYTE *v73; // edx\n  int v74; // eax\n  _DWORD v75[10]; // [esp-Eh] [ebp-78h] BYREF\n  int v76; // [esp+1Ah] [ebp-50h]\n  int v77; // [esp+1Eh] [ebp-4Ch]\n  const void **v78; // [esp+22h] [ebp-48h] BYREF\n  char v79; // [esp+28h] [ebp-42h]\n  char v80; // [esp+29h] [ebp-41h]\n  _BYTE *v81; // [esp+2Ah] [ebp-40h]\n  unsigned int v82; // [esp+2Eh] [ebp-3Ch]\n  int v83; // [esp+32h] [ebp-38h]\n  __int64 v84; // [esp+36h] [ebp-34h] BYREF\n  char *v85; // [esp+3Eh] [ebp-2Ch]\n  char v86; // [esp+42h] [ebp-28h] BYREF\n  char v87; // [esp+43h] [ebp-27h] BYREF\n  int v88[7]; // [esp+44h] [ebp-26h] BYREF\n\n  v77 = a2;\n  v82 = a3;\n  memset((char *)v88 + 2, 0, 0x18u);\n  if ( a2 == 4 )\n  {\n    BYTE2(v88[0]) = 1;\nLABEL_4:\n    HIBYTE(v88[0]) |= 4u;\n    goto LABEL_5;\n  }\n  BYTE2(v88[0]) = v77;\n  if ( v77 == 1 )\n    goto LABEL_4;\nLABEL_5:\n  v5 = *(_BYTE **)(dword_80DBB88 + 4);\n  v84 = (unsigned int)v88 + 2;\n  v79 = 0;\n  v80 = 0;\n  while ( 2 )\n  {\n    if ( v82 > 1 )\n    {\n      if ( a1 == 257 )\n        a1 = sub_8073B87();\n      if ( a4 )\n      {\n        while ( a1 == 9 )\n          a1 = sub_8073B87();\n      }\n      v83 = (int)&v5[-*(_DWORD *)(dword_80DBB88 + 4)];\n      for ( i = (unsigned __int8 *)v82; ; ++i )\n      {\n        v5 = sub_8071CD6(a1, v5);\n        v7 = *i;\n        if ( !(_BYTE)v7 )\n          break;\n        if ( v7 != a1 )\n          goto LABEL_19;\n        a1 = sub_8073B87();\n      }\n      if ( a1 == 256 || a1 == 10 )\n      {\n        ++*((_DWORD *)off_80DB55C + 1);\n        byte_80DB76E = byte_80DB76F;\n        a1 = 256;\n        goto LABEL_22;\n      }\nLABEL_19:\n      v8 = (_BYTE *)(*(_DWORD *)(dword_80DBB88 + 4) + v83 + 1);\n      v9 = v5 - v8;\n      if ( v9 )\n      {\n        v10 = a1 > 255;\n        a1 = *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB88 + 4) + v83);\n        v11 = v9 - v10;\n        if ( v11 )\n        {\n          v12 = alloca(v11 + 16);\n          v75[9] = v11;\n          v75[8] = v8;\n          v75[7] = &v78;\n          *(_BYTE *)mempcpy() = 0;\n          sub_806F78A((const char *)&v78, 0);\n        }\n      }\nLABEL_22:\n      v5 = (_BYTE *)(*(_DWORD *)(dword_80DBB88 + 4) + v83);\n    }\n    v13 = (int)v5;\nLABEL_24:\n    v83 = *(_DWORD *)(dword_80DBB88 + 8);\n    if ( (unsigned int)(v83 - v13) <= 3 )\n      v13 = sub_80716AF(4u, v13);\n    LOBYTE(v83) = *(_BYTE *)v84;\n    v14 = sub_806EEFB(a1, v83);\n    LOBYTE(v15) = v83;\n    switch ( v14 )\n    {\n      case 0:\n        goto LABEL_111;\n      case 1:\n        if ( !(_BYTE)v83 && !*(_DWORD *)(v84 + 4) )\n          goto LABEL_114;\n        v5 = (_BYTE *)(v13 + 1);\n        *(_BYTE *)v13 = a1;\n        sub_8074C05(v15);\n        a1 = sub_8073952();\n        continue;\n      case 2:\n        v20 = sub_8073B87();\n        if ( v20 == 256 )\n        {\n          *(_WORD *)v13 = 23681;\n          sub_806EE06();\n          v13 = v21;\n          goto LABEL_113;\n        }\n        if ( v20 == 10 )\n        {\n          ((void (*)(void))sub_8074C05)();\n          goto LABEL_113;\n        }\n        if ( v77 == 4 && v20 == 36 )\n        {\n          *(_WORD *)v13 = 23681;\n          v13 += 2;\n        }\n        LOBYTE(v83) = *(_BYTE *)(v84 + 1);\n        if ( ((v20 != 36) & ((unsigned __int8)v83 >> 2)) == 0 || ((v20 - 92) & 0xFFFFFFFB) == 0 )\n          goto LABEL_75;\n        if ( v20 == 34 )\n        {\n          if ( !v82 )\n            goto LABEL_75;\n        }\n        else if ( v20 != 125 )\n        {\n          goto LABEL_74;\n        }\n        if ( *(_DWORD *)(v84 + 4) )\n          goto LABEL_75;\nLABEL_74:\n        *(_WORD *)v13 = 23681;\n        v13 += 2;\nLABEL_75:\n        *(_BYTE *)v13 = -127;\n        *(_BYTE *)(v13 + 1) = v20;\n        v13 += 2;\n        goto LABEL_104;\n      case 3:\n        *(_BYTE *)v84 = 2;\n        goto LABEL_77;\n      case 4:\n        v22 = v84;\n        *(_BYTE *)v84 = 1;\n        *(_BYTE *)(v22 + 1) |= 4u;\n        goto LABEL_80;\n      case 5:\n        if ( !v82 || *(_DWORD *)(v84 + 4) )\n        {\n          v23 = v84;\n          if ( !*(_DWORD *)(v84 + 8) )\n          {\n            *(_BYTE *)v84 = 0;\n            *(_BYTE *)(v23 + 1) &= ~4u;\n          }\n          v79 = 0;\n          v80 = 1;\n          if ( a1 == 34 )\n          {\nLABEL_80:\n            if ( *(_DWORD *)(v84 + 4) )\n              *(_BYTE *)(v84 + 1) = !(*(_BYTE *)(v84 + 1) & 1) | *(_BYTE *)(v84 + 1) & 0xFE;\n          }\nLABEL_77:\n          if ( !v82 )\n          {\n            *(_BYTE *)v13 = -120;\n            goto LABEL_112;\n          }\n        }\n        else\n        {\n          *(_BYTE *)v13++ = a1;\n          v79 = 0;\n        }\n        goto LABEL_113;\n      case 6:\n        if ( (byte_80DB76B & 8) == 0 )\n        {\n          LOBYTE(v81) = 1;\n          goto LABEL_233;\n        }\n        *(_BYTE *)v13++ = 96;\nLABEL_104:\n        v80 = 1;\n        goto LABEL_113;\n      case 7:\n        v41 = sub_8074C1E(v15);\n        v43 = v41;\n        if ( (byte_80DB76B & 8) != 0 || v41 > 255 )\n          goto LABEL_161;\n        if ( v41 != 40 )\n        {\n          if ( v41 != 123 && v41 != 95 && (unsigned __int8)((v41 | 0x20) - 97) > 0x19u )\n          {\n            if ( (unsigned int)(v41 - 33) > 0x1F || (v44 = -1040215539, !_bittest(&v44, v41 - 33)) )\n            {\nLABEL_161:\n              if ( *(_BYTE *)v84 != 1 && v41 == 39 )\n                v79 = 1;\n              else\n                *(_BYTE *)v13++ = 36;\n              sub_806EE06();\n              goto LABEL_113;\n            }\n          }\n          LOBYTE(v83) = *(_BYTE *)v84;\n          *(_BYTE *)v13 = -126;\n          v45 = dword_80DBB88;\n          v78 = (const void **)(v13 + 1 - *(_DWORD *)(dword_80DBB88 + 4));\n          v81 = (_BYTE *)(v13 + 2);\n          v46 = 1;\n          if ( v41 == 123 )\n          {\n            v43 = sub_8074C1E(dword_80DBB88);\n            v46 = 0;\n          }\n          while ( 1 )\n          {\n            if ( v43 == 95 || (unsigned __int8)((v43 | 0x20) - 97) <= 0x19u )\n              goto LABEL_174;\n            if ( (unsigned __int8)(v43 - 48) <= 9u )\n            {\n              do\n              {\n                v81 = sub_8071CD6(v43, v81);\n                v43 = sub_8074C1E(v50);\n              }\n              while ( (unsigned __int8)(v43 - 48) <= 9u );\n              goto LABEL_195;\n            }\n            v51 = sub_8074C1E(v45);\n            if ( (_BYTE)v46 || v43 != 35 )\n              goto LABEL_190;\n            if ( v51 == 95 )\n              break;\n            if ( (unsigned __int8)(v51 - 48) > 9u && (unsigned __int8)((v51 | 0x20) - 97) > 0x19u )\n            {\n              v76 = v51;\n              v52 = sub_8074C1E(v45);\n              if ( v76 != 125 && v52 == 125 )\n              {\n                v43 = v76;\n                v46 = 10;\n                v51 = 125;\n              }\n              else\n              {\n                sub_806EE06();\n                v51 = v76;\n              }\nLABEL_190:\n              if ( (unsigned int)(v43 - 33) <= 0x1F )\n              {\n                v49 = -1040215539;\n                if ( _bittest(&v49, v43 - 33) )\n                {\n                  v81 = (_BYTE *)(v13 + 3);\n                  *(_BYTE *)(v13 + 2) = v43;\n                  v43 = v51;\n                  goto LABEL_195;\n                }\n              }\n              if ( (_BYTE)v46 == 10 )\n                LOBYTE(v46) = 0;\nLABEL_218:\n              sub_806EE06();\nLABEL_219:\n              if ( (_BYTE)v83 == 3 )\n                LOBYTE(v83) = 1;\nLABEL_222:\n              if ( (*(_BYTE *)v84 != (_BYTE)v83 || (*(_BYTE *)(v84 + 1) & 1) != 0) && (_BYTE)v46 != 1 )\n              {\n                v54 = *(_BYTE **)(v84 + 16);\n                if ( !v54 )\n                  v54 = v75;\n                memset(v54, 0, 0x14u);\n                *v54 = v83;\n                v55 = v84;\n                *((_DWORD *)v54 + 5) = v84;\n                *(_DWORD *)(v55 + 16) = v54;\n                v54[1] = (4 * ((_BYTE)v83 != 0)) | v54[1] & 0xF9 | 2;\n                LODWORD(v84) = v54;\n              }\n              *((_BYTE *)v78 + *(_DWORD *)(dword_80DBB88 + 4)) = v46;\n              if ( (_BYTE)v46 != 1 )\n              {\n                v56 = v84;\n                ++*(_DWORD *)(v84 + 4);\n                if ( (*(_BYTE *)(v56 + 1) & 4) != 0 )\n                  ++*(_DWORD *)(v56 + 8);\n              }\n              v13 = (int)sub_8071CD6(61, v81);\n              goto LABEL_113;\n            }\n            v46 = 10;\n            v43 = v51;\n          }\n          LOBYTE(v43) = 95;\n          v46 = 10;\n          do\n          {\n            do\n            {\nLABEL_174:\n              v81 = sub_8071CD6(v43, v81);\n              v48 = sub_8074C1E(v47);\n              v43 = v48;\n            }\n            while ( v48 == 95 );\n          }\n          while ( (unsigned __int8)(v48 - 48) <= 9u || (unsigned __int8)((v48 | 0x20) - 97) <= 0x19u );\nLABEL_195:\n          if ( v43 != 125 && (_BYTE)v46 == 10 )\n          {\n            LOBYTE(v46) = 10;\n            goto LABEL_218;\n          }\n          if ( (_BYTE)v46 )\n            goto LABEL_218;\n          if ( v43 != 37 )\n          {\n            if ( v43 > 37 )\n            {\n              if ( v43 != 47 )\n              {\n                if ( v43 == 58 )\n                {\n                  v43 = sub_8074C1E(v49);\n                  if ( !strchr(\"}-+?=\", v43) )\n                  {\n                    sub_806EE06();\n                    LOBYTE(v46) = 12;\n                    goto LABEL_219;\n                  }\n                  v46 = 16;\n                }\n                goto LABEL_207;\n              }\n              if ( sub_8074C1E(v49) != 47 )\n              {\n                LOBYTE(v83) = 0;\n                LOBYTE(v46) = 13;\n                goto LABEL_218;\n              }\n              LOBYTE(v46) = 14;\n            }\n            else\n            {\n              if ( v43 != 35 )\n              {\nLABEL_207:\n                v53 = strchr(\"}-+?=\", v43);\n                if ( v53 )\n                  v46 |= v53 - \"}-+?=\" + 1;\n                goto LABEL_219;\n              }\n              LOBYTE(v46) = 8;\nLABEL_211:\n              if ( v43 == sub_8074C1E(v49) )\n                LOBYTE(v46) = v46 + 1;\n              else\n                sub_806EE06();\n            }\n            LOBYTE(v83) = 0;\n            goto LABEL_222;\n          }\n          LOBYTE(v46) = 6;\n          goto LABEL_211;\n        }\n        if ( sub_8074C1E(v42) == 40 )\n        {\n          v73 = *(_BYTE **)(v84 + 16);\n          if ( !v73 )\n            v73 = v75;\n          memset(v73, 0, 0x14u);\n          *v73 = 3;\n          v74 = v84;\n          *((_DWORD *)v73 + 5) = v84;\n          *(_DWORD *)(v74 + 16) = v73;\n          v73[1] |= 4u;\n          *(_BYTE *)v13 = -122;\n          LODWORD(v84) = v73;\n          goto LABEL_112;\n        }\n        sub_806EE06();\n        LOBYTE(v81) = 0;\nLABEL_233:\n        v83 = *(_DWORD *)(dword_80DBB88 + 4);\n        v78 = 0;\n        v57 = v13 - v83;\n        if ( v57 )\n        {\n          v58 = alloca(v57 + 15);\n          v78 = (const void **)&v78;\n          qmemcpy(&v78, (const void *)v83, v57);\n          v15 = 0;\n        }\n        if ( (_BYTE)v81 )\n        {\n          while ( 1 )\n          {\n            sub_8074B7B(v15, 2);\n            v60 = sub_8074C1E(v59);\n            LOBYTE(v61) = v60;\n            if ( v60 == 96 )\n              break;\n            if ( v60 > 96 )\n            {\n              if ( (unsigned int)(v60 - 256) <= 1 )\n                goto LABEL_250;\n            }\n            else if ( v60 == 10 )\n            {\n              sub_806EDF3();\n            }\n            else if ( v60 == 92 )\n            {\n              v62 = sub_8073952();\n              v61 = v62;\n              if ( v62 != 92 )\n              {\n                if ( v62 != 96 && v62 != 36 && ((*(_BYTE *)(v84 + 1) & 4) == 0 || v62 != 34) )\n                  v83 = (int)sub_8071CD6(92, (_BYTE *)v83);\n                if ( v61 > 255 )\n                {\nLABEL_250:\n                  v30 = \"EOF in backquote substitution\";\nLABEL_119:\n                  sub_8070172(v30);\n                }\n              }\n            }\n            v83 = (int)sub_8071CD6(v61, (_BYTE *)v83);\n          }\n          v63 = sub_8071CD6(0, (_BYTE *)v83);\n          v64 = *(_BYTE **)(dword_80DBB88 + 4);\n          if ( v63 != v64 )\n          {\n            v65 = (const char *)sub_806FFC6(v63 - v64);\n            sub_806F74D(v65);\n          }\n        }\n        v66 = (char *)HIDWORD(v84);\n        v67 = (char *)&v84 + 4;\n        while ( v66 )\n        {\n          v67 = v66;\n          v66 = *(char **)v66;\n        }\n        *(_DWORD *)v67 = sub_8070C51(8u);\n        v69 = 0;\n        if ( (_BYTE)v81 )\n        {\n          v69 = byte_80DB76F;\n          byte_80DB76F = 0;\n        }\n        LOBYTE(v83) = v69;\n        v71 = sub_8073DE5(2, v68);\n        if ( (_BYTE)v81 )\n        {\n          byte_80DB76F = v83;\n        }\n        else if ( sub_8073C7A(v70) != 10 )\n        {\n          sub_807275C(10);\n        }\n        *(_DWORD *)(*(_DWORD *)v67 + 4) = v71;\n        if ( (_BYTE)v81 )\n        {\n          sub_806F6F7();\n          byte_80DB76A = 0;\n        }\n        while ( *(_DWORD *)(dword_80DBB88 + 12) <= v57 )\n          sub_8071623();\n        v72 = *(_BYTE **)(dword_80DBB88 + 4);\n        if ( v78 )\n        {\n          qmemcpy(v72, v78, v57);\n          v72 += v57;\n        }\n        v13 = (int)(v72 + 1);\n        *v72 = -124;\n        goto LABEL_113;\n      case 8:\n        v24 = *(_BYTE *)(v84 + 1);\n        if ( (v24 & 1) == 0 )\n        {\n          v25 = *(_DWORD *)(v84 + 4);\n          if ( v25 > 0 )\n          {\n            v26 = v25 - 1;\n            v27 = v84;\n            *(_DWORD *)(v84 + 4) = v26;\n            if ( v26 || (v24 & 2) == 0 )\n            {\n              v28 = *(_DWORD *)(v84 + 8);\n              LOBYTE(a1) = -125;\n              if ( v28 > 0 )\n                *(_DWORD *)(v84 + 8) = v28 - 1;\n            }\n            else\n            {\n              LODWORD(v84) = *(_DWORD *)(v27 + 20);\n              LOBYTE(a1) = -125;\n            }\n          }\n        }\n        goto LABEL_111;\n      case 9:\n        ++*(_DWORD *)(v84 + 12);\n        goto LABEL_111;\n      case 10:\n        v29 = *(_DWORD *)(v84 + 12);\n        if ( v29 <= 0 )\n        {\n          if ( sub_8074C1E(v15) == 41 )\n          {\n            LODWORD(v84) = *(_DWORD *)(v84 + 20);\n            LOBYTE(a1) = -121;\n          }\n          else\n          {\n            sub_806EE06();\n          }\n        }\n        else\n        {\n          *(_DWORD *)(v84 + 12) = v29 - 1;\n        }\n        goto LABEL_111;\n      case 11:\n        goto LABEL_114;\n      case 12:\n        if ( a1 != 92 || !v79 )\n          goto LABEL_56;\n        a1 = sub_8073952();\n        v85 = strchr(\"nrbtfavx\\\\01234567\", a1);\n        if ( !v85 )\n        {\n          if ( a1 != 39 && a1 != 34 )\nLABEL_51:\n            LOWORD(a1) = a1 | 0x100;\n          if ( (a1 & 0x100) != 0 )\n          {\n            if ( !v82 || (*(_BYTE *)(v84 + 1) & 4) != 0 )\n              *(_BYTE *)v13++ = -127;\n            *(_BYTE *)v13++ = 92;\n          }\n          goto LABEL_56;\n        }\n        v86 = a1;\n        v85 = &v86;\n        if ( (unsigned __int8)(a1 - 48) > 7u )\n        {\n          if ( a1 == 120 )\n          {\n            v83 = 3;\n            while ( 1 )\n            {\n              v18 = v83;\n              v19 = sub_8073952();\n              *++v85 = v19;\n              if ( (unsigned __int8)(v19 - 48) > 9u && (unsigned __int8)((v19 | 0x20) - 97) > 5u )\n                break;\n              if ( !--v83 )\n              {\n                v18 = 0;\n                break;\n              }\n            }\n            sub_806EE06();\n            if ( v18 == 3 )\n              goto LABEL_51;\n          }\n          else\n          {\n            v85 = &v87;\n          }\n        }\n        else\n        {\n          v16 = 3;\n          do\n          {\n            v17 = sub_8073952();\n            *++v85 = v17;\n            if ( (unsigned __int8)(v17 - 48) > 7u )\n              break;\n            --v16;\n          }\n          while ( v16 );\n          sub_806EE06();\n        }\n        *v85 = 0;\n        v85 = &v86;\n        LOBYTE(a1) = sub_80B0CB3();\n        if ( !(_BYTE)a1 )\n          goto LABEL_113;\nLABEL_56:\n        if ( !v82 || (*(_BYTE *)(v84 + 1) & 4) != 0 || *(_DWORD *)(v84 + 4) )\n          *(_BYTE *)v13++ = -127;\n        goto LABEL_111;\n      case 14:\n        goto LABEL_113;\n      default:\n        if ( *(_DWORD *)(v84 + 4) )\n        {\n          if ( a1 != 257 )\n          {\nLABEL_111:\n            *(_BYTE *)v13 = a1;\nLABEL_112:\n            ++v13;\n          }\nLABEL_113:\n          a1 = sub_8073952();\n          goto LABEL_24;\n        }\n        if ( a1 == 38 )\n        {\n          if ( sub_8073952() == 62 )\n            a1 = 318;\n          sub_806EE06();\n        }\nLABEL_114:\n        if ( *(_BYTE *)v84 == 3 )\n        {\n          v30 = \"missing '))'\";\n          goto LABEL_119;\n        }\n        if ( !v82 && *(_BYTE *)v84 )\n        {\n          v30 = \"unterminated quoted string\";\n          goto LABEL_119;\n        }\n        if ( *(_DWORD *)(v84 + 4) )\n        {\n          v30 = \"missing '}'\";\n          goto LABEL_119;\n        }\n        *(_BYTE *)v13 = 0;\n        v31 = *(char **)(dword_80DBB88 + 4);\n        v32 = v13 + 1 - (_DWORD)v31;\n        if ( v82 )\n        {\nLABEL_128:\n          byte_80DB769 = v80;\n          dword_80DB688 = HIDWORD(v84);\n          sub_806FFC6(v32);\n          dword_80DB68C = v31;\n          byte_80DB768 = 3;\n          return 3;\n        }\n        else\n        {\n          if ( (a1 & 0xFFFFFFFD) != 60 && a1 != 318 || v80 || !sub_806EC08(v31) )\n          {\n            sub_806EE06();\n            goto LABEL_128;\n          }\n          v34 = -1;\n          if ( *v31 )\n            v34 = atoi(v31);\n          v35 = sub_8070C51(0x18u);\n          v37 = v35;\n          if ( a1 == 62 )\n          {\n            v35[2] = 1;\n            v38 = sub_8074C1E(v36);\n            switch ( v38 )\n            {\n              case '>':\n                *(_BYTE *)v37 = 21;\n                goto LABEL_150;\n              case '|':\n                *(_BYTE *)v37 = 18;\n                goto LABEL_150;\n              case '&':\n                *(_BYTE *)v37 = 22;\n                goto LABEL_150;\n            }\n            *(_BYTE *)v37 = 16;\nLABEL_149:\n            sub_806EE06();\n          }\n          else if ( a1 == 318 )\n          {\n            v35[2] = 1;\n            sub_8073952();\n            *(_BYTE *)v37 = 17;\n          }\n          else\n          {\n            v39 = sub_8074C1E(v36);\n            switch ( v39 )\n            {\n              case '<':\n                v37 = sub_8070C51(0x10u);\n                *(_BYTE *)v37 = 24;\n                dword_80DB680 = (int)sub_8070C51(0x10u);\n                *(_DWORD *)(dword_80DB680 + 4) = v37;\n                if ( sub_8074C1E(v40) != 45 )\n                  goto LABEL_149;\n                *(_BYTE *)(dword_80DB680 + 12) = 1;\n                break;\n              case '>':\n                *(_BYTE *)v37 = 20;\n                break;\n              case '&':\n                *(_BYTE *)v37 = 23;\n                break;\n              default:\n                *(_BYTE *)v37 = 19;\n                goto LABEL_149;\n            }\n          }\nLABEL_150:\n          if ( v34 >= 0 )\n            v37[2] = v34;\n          dword_80DB684 = (int)v37;\n          byte_80DB768 = 2;\n          return 2;\n        }\n    }\n  }\n}\n"
    ],
    "sub_8074AA5": [
        "0x8074aa5",
        "int __usercall sub_8074AA5@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v2; // eax\n  int v3; // ebx\n  int v4; // eax\n  int v5; // eax\n  char v7; // [esp+0h] [ebp-50h]\n  int v9; // [esp+8h] [ebp-48h]\n  int v10; // [esp+Ch] [ebp-44h]\n  char v11[40]; // [esp+28h] [ebp-28h] BYREF\n\n  sub_806F74D(a1);\n  v7 = byte_80DB76F;\n  byte_80DB76F = 0;\n  v10 = *(_DWORD *)(dword_80DBB8C + 32);\n  v9 = *(_DWORD *)(dword_80DBB8C + 36);\n  v2 = _setjmp((struct __jmp_buf_tag *)v11);\n  v3 = dword_80DBB8C;\n  if ( !v2 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v11;\n    v5 = sub_8073952();\n    sub_8073F3E(v5, a2, 1u, 0);\n  }\n  *(_DWORD *)(v3 + 32) = v10;\n  v4 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 36) = v9;\n  if ( !*(_DWORD *)(v4 + 36) && *(_BYTE *)(v4 + 40) )\n    sub_806F406();\n  byte_80DB76F = v7;\n  sub_806F6F7();\n  sub_8075D0B();\n  return *(_DWORD *)(dword_80DBB88 + 4);\n}\n"
    ],
    "sub_8074B7B": [
        "0x8074b7b",
        "char __usercall sub_8074B7B@<al>(char result@<al>, int a2@<edx>)\n{\n  int v2; // ebx\n  const char *v3; // ebx\n  const char *v4; // [esp+0h] [ebp-14h]\n  _DWORD v5[4]; // [esp+4h] [ebp-10h] BYREF\n\n  if ( result )\n  {\n    byte_80DB76E = 0;\n    if ( a2 == 1 )\n    {\n      v2 = *(_DWORD *)(dword_80DBB90 + 224);\n    }\n    else\n    {\n      if ( a2 != 2 )\n      {\n        v3 = (const char *)(dword_80DBB8C + 44);\n        goto LABEL_8;\n      }\n      v2 = *(_DWORD *)(dword_80DBB90 + 240);\n    }\n    v3 = (const char *)(v2 + 4);\nLABEL_8:\n    sub_8070037(v5, *(_DWORD *)(dword_80DBB88 + 12));\n    v4 = (const char *)sub_8074AA5(v3, 4);\n    free(dword_80DB6F4);\n    dword_80DB6F4 = sub_804DB46(v4);\n    return sub_806FA10(v5);\n  }\n  return result;\n}\n"
    ],
    "sub_8074C05": [
        "0x8074c05",
        "char sub_8074C05()\n{\n  ++*((_DWORD *)off_80DB55C + 1);\n  return sub_8074B7B(byte_80DB76F, 2);\n}\n"
    ],
    "sub_8074C1E": [
        "0x8074c1e",
        "int sub_8074C1E()\n{\n  int v0; // ebx\n\n  while ( 1 )\n  {\n    v0 = sub_8073952();\n    if ( v0 != 92 )\n      break;\n    if ( sub_8073952() != 10 )\n    {\n      sub_806EE06();\n      return v0;\n    }\n    sub_8074C05();\n  }\n  return v0;\n}\n"
    ],
    "sub_8074C47": [
        "0x8074c47",
        "_BYTE *__usercall sub_8074C47@<eax>(int a1@<eax>)\n{\n  int v1; // ecx\n\n  byte_80DB76A = 0;\n  byte_80DB76B = 0;\n  dword_80DB690 = 0;\n  byte_80DB76F = a1;\n  sub_8074B7B(a1, a1);\n  byte_80DB76E = 0;\n  return sub_8073DE5(1, v1);\n}\n"
    ],
    "sub_8074C7C": [
        "0x8074c7c",
        "int __usercall sub_8074C7C@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  _BYTE *v3; // esi\n  _BOOL4 v4; // eax\n  int v5; // eax\n  char *v7; // [esp+0h] [ebp-48h]\n  int v8; // [esp+4h] [ebp-44h]\n  struct __jmp_buf_tag *env; // [esp+Ch] [ebp-3Ch]\n  _DWORD v11[3]; // [esp+10h] [ebp-38h] BYREF\n  char v12[44]; // [esp+1Ch] [ebp-2Ch] BYREF\n\n  v7 = sub_807007B(a1);\n  sub_806F74D(v7);\n  sub_8070056(v11);\n  env = *(struct __jmp_buf_tag **)(dword_80DBB8C + 32);\n  v8 = 0;\n  v2 = _setjmp((struct __jmp_buf_tag *)v12);\n  if ( !v2 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v12;\n    do\n    {\n      v3 = sub_8074C47(0);\n      if ( v3 == (_BYTE *)-1 )\n        break;\n      v4 = 0;\n      if ( byte_80DB76A )\n        v4 = byte_80DB768 == 0;\n      v5 = sub_8074EF2(v3, a2 & (v4 ^ 0xFFFFFFFE), v7);\n      if ( v3 )\n        v8 = v5;\n      sub_806FA10(v11);\n    }\n    while ( !byte_80DB76C );\n  }\n  sub_806FA10(v11);\n  sub_806F6F7();\n  sub_806EC35((int)v7);\n  *(_DWORD *)(dword_80DBB8C + 32) = env;\n  if ( v2 )\n    longjmp(env, v2);\n  return v8;\n}\n"
    ],
    "sub_8074D56": [
        "0x8074d56",
        "int __usercall sub_8074D56@<eax>(int a1@<eax>, int a2@<ecx>, char a3)\n{\n  int v3; // ebx\n  const char *v4; // esi\n  char v5; // al\n  int v6; // ebp\n  int v7; // edi\n  _BYTE *i; // eax\n  _BYTE *v9; // edx\n  _BYTE *v10; // eax\n  char v14; // [esp+Ch] [ebp-40h]\n  char *v15; // [esp+10h] [ebp-3Ch]\n  int v16; // [esp+14h] [ebp-38h]\n  char v17[52]; // [esp+18h] [ebp-34h] BYREF\n\n  v15 = dword_80DB70C;\n  v16 = *(_DWORD *)(dword_80DBB8C + 32);\n  v3 = _setjmp((struct __jmp_buf_tag *)v17);\n  if ( !v3 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v17;\n    dword_80DB70C = *(char **)a2;\n    dword_80DB708 = a2 + 4;\n    dword_80DB700 = 0;\n    if ( (char **)a1 == &off_80B5DE0 )\n    {\n      v4 = *(const char **)(a2 + 4);\n      v5 = 0;\n      if ( v4 )\n      {\n        v6 = a2 + 8;\n        if ( *(_DWORD *)(a2 + 8) )\n        {\n          v7 = dword_80DBB88;\n          for ( i = *(_BYTE **)(dword_80DBB88 + 4); ; i = sub_8071CD6(32, v9) )\n          {\n            v9 = (_BYTE *)sub_8071971(v4, (int)i);\n            v6 += 4;\n            v4 = *(const char **)(v6 - 4);\n            if ( !v4 )\n              break;\n          }\n          v10 = sub_8071CD6(0, v9);\n          v4 = (const char *)sub_806FFC6((int)&v10[-*(_DWORD *)(v7 + 4)]);\n        }\n        v5 = sub_8074C7C(v4, a3 & 2);\n      }\n    }\n    else\n    {\n      v5 = (*(int (__fastcall **)(int, int))(a1 + 4))(a1, a2);\n    }\n    v14 = v5;\n    sub_806F4BD();\n    *(_BYTE *)dword_80DBB8C = stdout->_flags & 8 | v14;\n  }\n  clearerr(stdout);\n  dword_80DB70C = v15;\n  *(_DWORD *)(dword_80DBB8C + 32) = v16;\n  return v3;\n}\n"
    ],
    "sub_8074E89": [
        "0x8074e89",
        "int __fastcall sub_8074E89(int a1, int a2)\n{\n  _BYTE *v2; // esi\n  char v3; // cl\n  _BYTE *v4; // edi\n  int v5; // ebx\n  const char *v6; // eax\n\n  v2 = (_BYTE *)dword_80DBB8C;\n  if ( !*(_BYTE *)(dword_80DBB8C + 42) )\n    return a2;\n  v3 = *(_BYTE *)dword_80DBB8C;\n  *(_BYTE *)(dword_80DBB8C + 42) = 0;\n  v4 = v2 + 124;\n  v5 = 1;\n  while ( !v4[v5 - 1] )\n  {\nLABEL_10:\n    if ( ++v5 == 65 )\n      goto LABEL_11;\n  }\n  if ( !byte_80DB76C )\n  {\n    v6 = *(const char **)&v2[4 * v5 + 192];\n    if ( v6 || v5 != 2 )\n    {\n      v4[v5 - 1] = 0;\n      if ( v6 )\n      {\n        HIBYTE(a2) = v3;\n        sub_8074C7C(v6, 0);\n        v3 = HIBYTE(a2);\n      }\n    }\n    goto LABEL_10;\n  }\n  v2[42] = v5;\nLABEL_11:\n  *v2 = v3;\n  return a2;\n}\n"
    ],
    "sub_8074EF2": [
        "0x8074ef2",
        "int __usercall sub_8074EF2@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, char *a4, int a5)\n{\n  unsigned __int8 *v5; // ebx\n  int v6; // ecx\n  int (*v7)(void); // eax\n  int v8; // eax\n  int v9; // ebp\n  int v10; // esi\n  int v11; // eax\n  int v12; // esi\n  int v13; // eax\n  int v14; // eax\n  size_t v15; // esi\n  void *v16; // ebp\n  const char *v17; // eax\n  const char *v18; // esi\n  int v20; // [esp-8h] [ebp-1Ch]\n  int v21; // [esp-8h] [ebp-1Ch]\n  int v22; // [esp-8h] [ebp-1Ch]\n  int v23; // [esp-4h] [ebp-18h]\n  int v24; // [esp+0h] [ebp-14h]\n\n  v5 = (unsigned __int8 *)dword_80DBB8C;\n  if ( a4 )\n  {\n    sub_8074E89(a2, a1);\n    switch ( *a4 )\n    {\n      case 0:\n        v7 = (int (*)(void))sub_8077DB8;\n        goto LABEL_13;\n      case 1:\n        v7 = (int (*)(void))sub_8077B33;\n        goto LABEL_13;\n      case 2:\n        v10 = dword_80DBB90;\n        v11 = *((_DWORD *)a4 + 1);\n        *(_DWORD *)(dword_80DBB90 + 328) = v11;\n        *((_DWORD *)v5 + 3) = v11;\n        if ( dword_80DB698 )\n          *(_DWORD *)(v10 + 328) = v11 - (dword_80DB698 - 1);\n        sub_8076588();\n        sub_806EE2E(*((_DWORD *)a4 + 3));\n        v9 = sub_80764FE();\n        if ( !v9 )\n        {\n          v9 = sub_8074EF2(*((_DWORD *)a4 + 2), a5 & 2, a3);\n          a1 = v23;\n        }\n        v12 = 0;\n        if ( *((_DWORD *)a4 + 3) )\n          sub_806FF33(0, a1);\n        goto LABEL_32;\n      case 3:\n      case 4:\n        v7 = sub_807665F;\nLABEL_13:\n        v9 = 0;\n        if ( v5[45] )\n          v9 = -((a5 & 2) == 0);\n        goto LABEL_24;\n      case 5:\n      case 6:\n      case 7:\n        v9 = sub_8074EF2(\n               *((_DWORD *)a4 + 1),\n               ((unsigned __int8)a5 | (unsigned __int8)(((unsigned int)(*a4 - 5) >> 1) - 1)) & 2,\n               *a4 - 5);\n        a2 = v21;\n        v12 = 0;\n        if ( (v9 == 0) != v24 && !byte_80DB76C )\n          goto LABEL_22;\n        break;\n      case 8:\n        v14 = sub_8074EF2(*((_DWORD *)a4 + 1), 2, a3);\n        v9 = v14;\n        a2 = v22;\n        v12 = 0;\n        if ( byte_80DB76C )\n          break;\n        if ( v14 )\n        {\n          v9 = 0;\n          if ( !*((_DWORD *)a4 + 3) )\n            goto LABEL_32;\nLABEL_22:\n          v7 = (int (*)(void))sub_8074EF2;\nLABEL_23:\n          v9 = 0;\n        }\n        else\n        {\n          v7 = (int (*)(void))sub_8074EF2;\n        }\nLABEL_24:\n        v13 = v7();\n        a1 = a5;\n        v12 = v9;\n        v9 = v13;\nLABEL_32:\n        *v5 = v9;\n        break;\n      case 9:\n      case 10:\n        v7 = (int (*)(void))sub_8076871;\n        goto LABEL_23;\n      case 11:\n        v7 = (int (*)(void))sub_80768DE;\n        goto LABEL_23;\n      case 12:\n        v7 = (int (*)(void))sub_807672E;\n        goto LABEL_23;\n      case 14:\n        ++*((_DWORD *)v5 + 9);\n        v15 = sub_80727DF(0, a4, v6) + 4;\n        v16 = sub_804DB2E(v15);\n        dword_80DB6A8 = (int)v16 + 4;\n        dword_80DB6A4 = (int)v16 + v15;\n        sub_806EF86(a4);\n        v17 = sub_806F11D(*((const char **)a4 + 2), 1);\n        v18 = v17;\n        if ( v17[8] == 1 )\n          sub_806EEEB(*((_DWORD **)v17 + 1));\n        *((_DWORD *)v18 + 1) = v16;\n        *((_WORD *)v18 + 4) = 1;\n        sub_806F4A5();\n        v9 = 0;\n        goto LABEL_31;\n      default:\n        v8 = sub_8074EF2(*((_DWORD *)a4 + 1), 2, a3);\n        a2 = v20;\n        v9 = v8 == 0;\nLABEL_31:\n        v12 = 0;\n        goto LABEL_32;\n    }\n  }\n  else\n  {\n    v9 = 0;\n    v12 = 0;\n  }\n  sub_8074E89(a2, a1);\n  if ( (v9 & v12) != 0 || (a5 & 1) != 0 )\n    sub_806F22F(4);\n  return *v5;\n}\n"
    ],
    "sub_807510E": [
        "0x807510e",
        "char __usercall sub_807510E@<al>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int i; // ebp\n  unsigned __int8 v4; // dl\n  bool v5; // zf\n  char *pw_dir; // ebx\n  char v7; // dl\n  struct passwd *v8; // eax\n  unsigned int v9; // eax\n  int v10; // ecx\n  unsigned int v11; // edx\n  int v12; // ebp\n  int v13; // ebx\n  size_t v14; // eax\n  int v15; // ecx\n  unsigned int v16; // edi\n  char v17; // bl\n  char result; // al\n  char *v19; // ebx\n  void *v20; // edi\n  int v21; // esi\n  int v22; // edx\n  int v23; // ecx\n  int v24; // ebx\n  signed int v25; // eax\n  unsigned int v26; // edx\n  unsigned int v27; // eax\n  void *v28; // edx\n  unsigned int v29; // ecx\n  int v30; // ebx\n  _BYTE *j; // ebx\n  _BYTE *v32; // eax\n  int v33; // edx\n  char *v34; // esi\n  const char *v35; // ebx\n  __int64 v36; // rax\n  int v37; // eax\n  int v38; // [esp-8h] [ebp-BCh]\n  void *v39; // [esp-4h] [ebp-B8h]\n  int v40; // [esp-4h] [ebp-B8h]\n  unsigned int v41; // [esp+0h] [ebp-B4h]\n  int v42; // [esp+4h] [ebp-B0h]\n  char *v43; // [esp+8h] [ebp-ACh]\n  char *reject; // [esp+Ch] [ebp-A8h]\n  char *v45; // [esp+10h] [ebp-A4h] BYREF\n  unsigned int v46; // [esp+14h] [ebp-A0h]\n  int v47; // [esp+18h] [ebp-9Ch] BYREF\n  int buf[2]; // [esp+1Ch] [ebp-98h] BYREF\n  int pipedes[2]; // [esp+24h] [ebp-90h] BYREF\n\n  v41 = a2;\n  v46 = a2 & 0xC0;\n  reject = (char *)&unk_80D0D15;\n  if ( (a2 & 4) != 0 )\n  {\n    reject = (char *)&unk_80D0D14;\n    if ( (a2 & 0x20) == 0 )\n      reject = (char *)&unk_80D0D13;\n  }\n  v42 = a2 & 2;\n  if ( (a2 & 2) == 0 )\n    goto LABEL_31;\n  v41 = a2 & 0xFFFFFFFD;\n  v42 = 0;\nLABEL_6:\n  if ( *(_BYTE *)a1 != 126 )\n    goto LABEL_31;\n  for ( i = a1; ; ++i )\n  {\n    v4 = *(_BYTE *)(i + 1);\n    if ( !v4 )\n      break;\n    if ( v4 == 0x81 )\n      goto LABEL_31;\n    if ( v4 > 0x81u )\n    {\n      if ( v4 == 0x83 )\n        break;\n      if ( v4 == 0x88 )\n        goto LABEL_31;\n    }\n    else if ( v4 == 47 || v4 == 58 && (v41 & 4) != 0 )\n    {\n      break;\n    }\n  }\n  *(_BYTE *)(i + 1) = 0;\n  v5 = *(_BYTE *)(a1 + 1) == 0;\n  LOBYTE(v45) = v4;\n  if ( v5 )\n  {\n    pw_dir = sub_8072EED(\"HOME\");\n    v7 = (char)v45;\n  }\n  else\n  {\n    v8 = getpwnam((const char *)(a1 + 1));\n    v7 = (char)v45;\n    if ( !v8 )\n    {\nLABEL_26:\n      *(_BYTE *)(i + 1) = v7;\n      goto LABEL_31;\n    }\n    pw_dir = v8->pw_dir;\n  }\n  if ( !pw_dir || !*pw_dir )\n    goto LABEL_26;\n  *(_BYTE *)(i + 1) = v7;\n  v9 = strlen(pw_dir);\n  sub_80718D9((int)pw_dir, v9, 2, v41 & 0x11);\n  a1 = i + 1;\nLABEL_31:\n  while ( 2 )\n  {\n    v45 = (char *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n    v13 = 0;\n    while ( 1 )\n    {\n      v14 = strcspn((const char *)(a1 + v13), reject);\n      v15 = v38;\n      v16 = v14 + v13;\n      v17 = *(_BYTE *)(a1 + v14 + v13);\n      if ( v17 && (v17 == -121 || v17 >= 0) )\n        ++v16;\n      result = (char)v45;\n      v43 = v45;\n      if ( v16 )\n      {\n        sub_80716AF(v16, dword_80DB6D4);\n        dword_80DB6D4 = mempcpy();\n        v15 = dword_80DBB88;\n        v43 = (char *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n        result = v46 == 64;\n        if ( v46 == 64 && v42 == 0 )\n        {\n          v15 = dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4);\n          if ( (int)v45 < (int)v43 )\n            result = sub_806F87B(v45, v43, 0);\n        }\n      }\n      v12 = a1 + v16 + 1;\n      if ( v17 == 58 )\n        goto LABEL_49;\n      if ( v17 != 61 )\n        break;\n      if ( (v41 & 0x20) != 0 )\n      {\n        v12 = a1 + v16;\n        goto LABEL_46;\n      }\n      v41 |= 0x20u;\n      ++reject;\nLABEL_49:\n      a1 += v16;\n      if ( *(_BYTE *)(v12 - 1) == 126 )\n        goto LABEL_6;\n      v12 = a1;\nLABEL_46:\n      v13 = 0;\nLABEL_47:\n      v45 = v43;\n      a1 = v12;\n    }\n    if ( v17 )\n    {\n      switch ( v17 )\n      {\n        case -127:\n          ++v43;\n          v13 = 1;\n          goto LABEL_53;\n        case -126:\n          v12 = sub_8075AA1(v15, v42 | v41);\n          goto LABEL_30;\n        case -125:\n          return result;\n        case -124:\n          v19 = *(char **)(dword_80DB6D0 + 4);\n          v45 = (char *)(((int)(v42 | v41) >> 7) & 1);\n          ++*(_DWORD *)(dword_80DBB8C + 36);\n          v20 = (void *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n          sub_8070037(&v47, (int)v20);\n          if ( v19 )\n          {\n            if ( pipe(pipedes) < 0 )\n              sub_806FB57(\"can't create pipe: %m\");\n            v21 = sub_807151B(1);\n            if ( !sub_8072B54(v21, (int)v19, 2) )\n            {\n              sub_806F48C();\n              close(pipedes[0]);\n              v20 = v39;\n              if ( pipedes[1] != 1 )\n              {\n                sub_806FF10(pipedes[1], 1);\n                close(pipedes[1]);\n                v21 = v40;\n              }\n              *(_BYTE *)(dword_80DBB8C + 45) = 0;\n              sub_806F5DA();\n              sub_8074EF2(v22, v23, (int)v20, v19, 1);\n            }\n            close(buf[1]);\n            v24 = buf[0];\n          }\n          else\n          {\n            v21 = 0;\n            v24 = -1;\n          }\n          sub_806FA10(&v45);\n          while ( 2 )\n          {\n            if ( v24 >= 0 )\n            {\n              v25 = sub_80B2319(128, buf);\n              if ( v25 > 0 )\n              {\n                sub_80718D9((int)buf, v25, v42 | v41, v41 & 0x11);\n                continue;\n              }\n              close(v24);\n              *(_BYTE *)(dword_80DBB8C + 1) = sub_8071014(v21);\n            }\n            break;\n          }\n          sub_806F4A5();\n          v26 = dword_80DB6D4;\n          v27 = *(_DWORD *)(dword_80DBB88 + 4);\n          while ( v26 > v27 && *(_BYTE *)(v26 - 1) == 10 )\n            --v26;\n          dword_80DB6D4 = v26;\n          v28 = (void *)(v26 - v27);\n          if ( (v41 & 0x80u) == 0 )\n            sub_806F87B(v20, v28, 0);\n          dword_80DB6D0 = *(_DWORD *)dword_80DB6D0;\n          goto LABEL_30;\n        case -121:\n          v12 = a1 + v16;\n          v29 = *(_DWORD *)(dword_80DBB88 + 4);\n          v30 = dword_80DB6D4;\n          *(_BYTE *)(dword_80DB6D4 - 1) = 0;\n          for ( j = (_BYTE *)(v30 - 2); ; j += ~v33 )\n          {\n            while ( *j != 0x86 )\n              --j;\n            v32 = j;\n            do\n            {\n              v33 = j - v32;\n              if ( v29 >= (unsigned int)v32 )\n                break;\n              --v32;\n            }\n            while ( *v32 == 0x81 );\n            if ( (v33 & 1) == 0 )\n              break;\n          }\n          v34 = &j[-v29];\n          sub_806F8CC((int)&j[-v29]);\n          dword_80DB6D4 = (int)j;\n          v35 = j + 1;\n          if ( (((unsigned __int8)v42 | (unsigned __int8)v41) & 0x11) != 0 )\n            sub_80719CE(v35, 0, 0);\n          v36 = sub_807146D();\n          v37 = sub_8071998(v36, HIDWORD(v36));\n          if ( (((unsigned __int8)v42 | (unsigned __int8)v41) & 0x80) == 0 )\n            sub_806F87B(v34, &v34[v37], 0);\n          goto LABEL_30;\n        case -120:\n          if ( v42 || memcmp((const void *)(a1 + v16 + 1), &unk_80D0F92, 5u) )\n          {\n            v42 ^= 0x80u;\n            v13 = 0;\nLABEL_53:\n            if ( (v41 & 0x11) != 0 )\n            {\n              v12 = a1 + v16;\n              ++v13;\n              ++v43;\n            }\n            goto LABEL_47;\n          }\n          v11 = v41;\n          LOBYTE(v11) = v41 | 0x80;\n          v12 = sub_8075AA1(v10, v11) + 1;\nLABEL_30:\n          a1 = v12;\n          break;\n        default:\n          goto LABEL_46;\n      }\n      continue;\n    }\n    return result;\n  }\n}\n"
    ],
    "sub_807559B": [
        "0x807559b",
        "char *__usercall sub_807559B@<eax>(\n        char *a1@<eax>,\n        const char *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        int a5,\n        char a6,\n        char a7)\n{\n  int v9; // ebp\n  char *i; // edi\n  char v11; // al\n  unsigned int v12; // edx\n  _BYTE *v13; // eax\n  int v14; // ebp\n  char *v15; // edi\n  const char *v16; // eax\n  const char *v17; // ebp\n  char *v18; // eax\n  char *v19; // ebx\n  int v20; // esi\n  unsigned int v21; // ebx\n  char *j; // eax\n  char *v23; // eax\n  bool k; // zf\n  char v25; // dl\n  int v26; // eax\n  unsigned int v27; // ebx\n  char *v28; // eax\n  int v29; // esi\n  char *v30; // ebx\n  int v31; // esi\n  char *v32; // ebp\n  int *v33; // ecx\n  int v34; // esi\n  char *v35; // eax\n  int v36; // edi\n  _BYTE *v37; // edx\n  int v38; // edi\n  char *m; // esi\n  char v40; // al\n  int v41; // ebp\n  int v42; // eax\n  int v43; // esi\n  char *(__cdecl *v44)(unsigned int, const char *, char *, char *, char *, int); // edx\n  char *v45; // eax\n  int v46; // esi\n  char *v48; // [esp+0h] [ebp-40h]\n  const char *v49; // [esp+4h] [ebp-3Ch]\n  int v50; // [esp+8h] [ebp-38h]\n  char *name; // [esp+14h] [ebp-2Ch]\n  char *v53; // [esp+18h] [ebp-28h]\n  int v54; // [esp+1Ch] [ebp-24h]\n  int v55; // [esp+20h] [ebp-20h]\n  _BYTE *v56; // [esp+24h] [ebp-1Ch]\n  int v57; // [esp+28h] [ebp-18h]\n  int v58; // [esp+2Ch] [ebp-14h] BYREF\n\n  v9 = dword_80DB6D0;\n  v48 = (char *)(a7 & 0x11);\n  i = 0;\n  if ( (unsigned int)(a4 - 13) <= 1 )\n  {\n    for ( i = a1; ; ++i )\n    {\n      v11 = *i;\n      if ( !*i )\n        break;\n      if ( v11 == 47 )\n      {\n        *i = 0;\n        goto LABEL_11;\n      }\n      if ( v11 == -127 && i[1] )\n        ++i;\n    }\n    i = 0;\n  }\nLABEL_11:\n  if ( (unsigned int)(a4 - 4) <= 1 || (v12 = 18, a4 == 12) )\n    v12 = 2;\n  sub_807510E((int)a1, v12);\n  v58 = -1;\n  if ( i )\n  {\n    v58 = dword_80DB6D4 - (*(_DWORD *)(dword_80DBB88 + 4) + a3);\n    dword_80DB6D4 = (int)sub_8071CD6(47, (_BYTE *)dword_80DB6D4);\n    sub_807510E((int)(i + 1), 2u);\n    *i = 47;\n  }\n  v13 = sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n  dword_80DB6D4 = (int)v13;\n  dword_80DB6D0 = v9;\n  v14 = *(_DWORD *)(dword_80DBB88 + 4);\n  v15 = (char *)(v14 + a5);\n  if ( a4 != 5 )\n  {\n    if ( a4 == 12 )\n    {\n      v17 = (const char *)(a3 + v14);\n      v18 = strchr(v17, 58);\n      v19 = v18;\n      if ( v18 )\n        *v18 = 0;\n      v20 = sub_80714BF();\n      if ( v19 )\n        *v19 = 58;\n      v21 = a3 - a5 - 1;\n      if ( (a7 & 0x11) != 0 )\n      {\n        for ( j = v15; j < v17 - 1; ++j )\n        {\n          if ( *j == -127 )\n          {\n            --v21;\n            ++j;\n          }\n        }\n      }\n      v23 = (char *)(v17 + 1);\n      for ( k = *v17 == 58; ; k = v25 == 58 )\n      {\n        if ( k )\n        {\n          v26 = sub_80714BF();\n          goto LABEL_43;\n        }\n        v25 = *v23++;\n        if ( !v25 )\n          break;\n      }\n      v26 = v21;\nLABEL_43:\n      if ( v20 < 0 )\n        v20 += v21;\n      if ( v20 >= v21 )\n      {\n        v20 = 0;\n        v26 = 0;\n      }\n      else if ( v26 < 0 )\n      {\n        v26 += v21 - v20;\n      }\n      v27 = v21 - v20;\n      if ( v27 >= v26 )\n        v27 = v26;\n      v28 = v15;\n      while ( v20 )\n      {\n        if ( (a7 & 0x11) != 0 && *v28 == -127 )\n          ++v28;\n        ++v28;\n        --v20;\n      }\n      while ( v27 )\n      {\n        if ( (a7 & 0x11) != 0 && *v28 == -127 )\n        {\n          *v15 = -127;\n          ++v28;\n          ++v15;\n        }\n        *v15 = *v28;\n        --v27;\n        ++v28;\n        ++v15;\n      }\n      goto LABEL_111;\n    }\n    if ( a4 != 4 )\n    {\n      v56 = &v13[-v14];\n      v50 = 0;\n      while ( 1 )\n      {\nLABEL_63:\n        v29 = *(_DWORD *)(dword_80DBB88 + 4);\n        dword_80DB6D4 = (int)&v56[v29];\n        v30 = (char *)(v29 + a5);\n        v31 = a3 + v29;\n        v49 = v30;\n        if ( (a7 & 0x11) != 0 )\n        {\n          v49 = sub_80719CE(v30, 9, 0);\n          if ( v30 != v49 )\n          {\n            v31 = dword_80DB6D4;\n            v30 = (char *)(a5 + *(_DWORD *)(dword_80DBB88 + 4));\n          }\n        }\n        name = (char *)(v31 - 1);\n        v32 = (char *)(*(_DWORD *)(dword_80DBB88 + 4) + a3);\n        v33 = 0;\n        if ( !v50 )\n        {\n          v33 = 0;\n          if ( v58 >= 0 )\n            v33 = &v58;\n        }\n        sub_80719CE((const char *)(*(_DWORD *)(dword_80DBB88 + 4) + a3), 2, v33);\n        v54 = dword_80DB6D4;\n        v55 = *(_DWORD *)(dword_80DBB88 + 4);\n        if ( (unsigned int)(a4 - 13) > 1 )\n          break;\n        if ( !v50 )\n        {\n          v50 = dword_80DBB8C + 44;\n          if ( v58 >= 0 )\n          {\n            v50 = (int)&v32[v58 + 1];\n            v32[v58] = 0;\n          }\n        }\n        if ( !*v32 )\n          return 0;\n        v53 = v32 - 1;\n        v34 = 0;\n        while ( 1 )\n        {\n          if ( v30 >= v53 )\n            goto LABEL_105;\nLABEL_77:\n          v35 = sub_80713E7((unsigned int)v30, v49, name, v32, v48, 1);\n          if ( !v35 )\n            break;\n          if ( a4 == 14 )\n          {\n            while ( v30 < v35 )\n            {\n              if ( (a7 & 0x11) != 0 && *v30 == -127 )\n                ++v30;\n              ++v30;\n              ++v49;\n            }\n          }\n          else\n          {\n            v30 = v35;\n          }\n          v38 = v34;\n          for ( m = (char *)v50; *m; ++m )\n          {\n            v57 = *(_DWORD *)(dword_80DBB88 + 4);\n            if ( *m == 92 && (a7 & 0x11) != 0 )\n            {\n              dword_80DB6D4 = (int)sub_8071CD6(129, (_BYTE *)dword_80DB6D4);\n              ++v38;\n            }\n            dword_80DB6D4 = (int)sub_8071CD6(*m, (_BYTE *)dword_80DB6D4);\n            if ( *(_DWORD *)(dword_80DBB88 + 4) != v57 )\n              goto LABEL_63;\n            ++v38;\n          }\n          v34 = v38;\n          if ( a4 == 13 )\n          {\n            while ( 1 )\n            {\n              v40 = v30[v34 - v38];\n              if ( !v40 )\n                break;\n              v41 = *(_DWORD *)(dword_80DBB88 + 4);\n              dword_80DB6D4 = (int)sub_8071CD6(v40, (_BYTE *)dword_80DB6D4);\n              if ( *(_DWORD *)(dword_80DBB88 + 4) != v41 )\n                goto LABEL_63;\n              ++v34;\n            }\nLABEL_105:\n            sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n            v42 = *(_DWORD *)(dword_80DBB88 + 4);\n            v15 = (char *)(v42 + a5);\n            memmove((void *)(v42 + a5), (const void *)(v54 - v55 + v42), v34 + 1);\n            dword_80DB6D4 = (int)&v15[v34];\n            return v15;\n          }\n        }\n        v36 = *(_DWORD *)(dword_80DBB88 + 4);\n        while ( 1 )\n        {\n          v37 = sub_8071CD6(*v30, (_BYTE *)dword_80DB6D4);\n          dword_80DB6D4 = (int)v37;\n          if ( (a7 & 0x11) != 0 && *v30 == -127 )\n          {\n            ++v34;\n            dword_80DB6D4 = (int)sub_8071CD6(*++v30, v37);\n          }\n          if ( *(_DWORD *)(dword_80DBB88 + 4) != v36 )\n            break;\n          ++v30;\n          ++v34;\n          ++v49;\n          if ( v53 <= v30 )\n            goto LABEL_105;\n          if ( *v32 != 42 )\n            goto LABEL_77;\n        }\n      }\n      v43 = (a4 - 6) >> 1;\n      v44 = sub_80713E7;\n      if ( ((a4 - 6) & 1) != v43 )\n        v44 = (char *(__cdecl *)(unsigned int, const char *, char *, char *, char *, int))&sub_807138E;\n      v45 = v44((unsigned int)v30, v49, name, v32, v48, (a4 - 6) >> 1);\n      v15 = v45;\n      if ( !v45 )\n        return 0;\n      if ( v43 )\n      {\n        v46 = v32 - v45;\n        memmove(v30, v45, v32 - v45);\n        v15 = &v30[v46 - 1];\n      }\nLABEL_111:\n      *v15 = 0;\n      goto LABEL_112;\n    }\n    v16 = (const char *)(dword_80DBB8C + 44);\n    if ( v15 )\n    {\n      if ( *a1 != -125 )\n        goto LABEL_26;\n      if ( (a6 & 0x10) != 0 )\n        v16 = \" or null\";\n    }\n    v15 = \"parameter not set\";\nLABEL_26:\n    sub_806FB57(\"%.*s: %s%s\", a1 - a2 - 1, a2, v15, v16);\n  }\n  sub_806FE06(a2, (const char *)(v14 + a5));\nLABEL_112:\n  dword_80DB6D4 = (int)v15;\n  return v15;\n}\n"
    ],
    "sub_8075AA1": [
        "0x8075aa1",
        "char *__usercall sub_8075AA1@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // ebp\n  _BOOL4 v3; // edi\n  char *v4; // ebx\n  int v5; // esi\n  signed int v6; // eax\n  int v7; // ebp\n  _DWORD *v8; // edi\n  char *v9; // edx\n  char v10; // bp\n  int v11; // eax\n  char v12; // cl\n  void *v14; // [esp+0h] [ebp-28h]\n  unsigned __int8 v16; // [esp+Ah] [ebp-1Eh]\n  char v17; // [esp+Bh] [ebp-1Dh]\n  void *v18; // [esp+14h] [ebp-14h] BYREF\n\n  v17 = *a1;\n  v16 = *a1 & 0xF;\n  if ( !v16 )\n    sub_8070172(\"bad substitution\");\n  v2 = a1 + 1;\n  v18 = (void *)(a2 & 0x80);\n  v3 = 1;\n  if ( (a2 & 0x80) != 0 )\n  {\n    v3 = 0;\n    if ( a1[1] == 64 )\n      v3 = *(_DWORD *)dword_80DBB90 != 0;\n  }\n  v14 = (void *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n  v4 = strchr(v2, 61) + 1;\n  while ( 1 )\n  {\n    v5 = sub_80730FF((unsigned __int8 *)v2, v17, a2, (int *)&v18) - ((v17 & 0x10) != 0);\n    if ( v16 == 3 )\n    {\n      v5 = ~v5;\nLABEL_10:\n      if ( v5 < 0 )\n      {\n        sub_807510E((int)v4, a2 | 0x42);\n        goto LABEL_30;\n      }\nLABEL_24:\n      if ( !v3 )\n        goto LABEL_30;\n      goto LABEL_25;\n    }\n    if ( v16 == 2 )\n      goto LABEL_10;\n    if ( (unsigned __int8)(v16 - 4) > 1u )\n      break;\n    if ( v5 >= 0 )\n      goto LABEL_24;\n    sub_807559B(v4, v2, 0, v16, (int)v14, v17, a2 & 0xEE);\n    v17 &= ~0x10u;\n    sub_806F8CC((int)v14);\n  }\n  if ( v5 < 0 && *(_BYTE *)(dword_80DBB8C + 57) )\n    sub_806FB57(\"%.*s: %s%s\", v4 - v2 - 1, v2, \"parameter not set\", (const char *)(dword_80DBB8C + 44));\n  if ( v16 == 10 )\n  {\n    v6 = v5;\n    if ( v5 < 0 )\n      v6 = 0;\n    sub_8071998(v6, v6 >> 31);\n  }\n  else\n  {\n    if ( v16 == 1 )\n    {\n      if ( !v3 )\n        return v4;\n      goto LABEL_25;\n    }\n    if ( v5 < 0 )\n      goto LABEL_33;\n    dword_80DB6D4 = (int)sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n    v7 = dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4);\n    if ( !sub_807559B(v4, 0, v7, v16, (int)v14, v17, a2) )\n      dword_80DB6D4 = *(_DWORD *)(dword_80DBB88 + 4) + v7 - 1;\n    sub_806F8CC((int)v14);\n  }\n  if ( !v3 )\n    goto LABEL_33;\nLABEL_25:\n  sub_806F87B(v14, (void *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4)), v18);\nLABEL_30:\n  if ( v16 == 1 )\n    return v4;\nLABEL_33:\n  v8 = (_DWORD *)dword_80DB6D0;\n  v9 = v4;\n  v10 = 0;\n  v11 = 1;\n  while ( 1 )\n  {\n    ++v4;\n    v12 = *v9;\n    if ( *v9 == -127 )\n    {\n      v4 = v9 + 2;\n      goto LABEL_36;\n    }\n    if ( v12 == -124 )\n    {\n      if ( v5 >= 0 )\n      {\n        v8 = (_DWORD *)*v8;\n        v10 = 1;\n      }\n      goto LABEL_36;\n    }\n    if ( v12 != -126 )\n      break;\n    v4 = v9 + 2;\n    if ( (v9[1] & 0xF) != 1 )\n      ++v11;\nLABEL_36:\n    v9 = v4;\n  }\n  if ( v12 != -125 )\n    goto LABEL_36;\n  if ( --v11 )\n    goto LABEL_36;\n  if ( v10 )\n    dword_80DB6D0 = (int)v8;\n  return v4;\n}\n"
    ],
    "sub_8075D0B": [
        "0x8075d0b",
        "char __usercall sub_8075D0B@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)\n{\n  char v3; // bl\n  int v4; // esi\n  _BYTE *v5; // eax\n  unsigned __int8 *v6; // ebx\n  void **v7; // edi\n  unsigned __int8 *v8; // edx\n  _BOOL4 v9; // ebp\n  unsigned __int8 *v10; // esi\n  char *v11; // eax\n  unsigned __int8 *v12; // esi\n  unsigned __int8 *v13; // edx\n  _DWORD *v14; // eax\n  _DWORD *v15; // eax\n  int i; // esi\n  int v17; // edi\n  const char *v18; // eax\n  char v19; // al\n  char *v20; // eax\n  char v21; // dl\n  char *v22; // eax\n  char *v23; // ebx\n  int *v24; // ebx\n  char *v25; // edi\n  int v26; // ebp\n  _DWORD *v27; // ecx\n  int v28; // edx\n  _DWORD *v29; // eax\n  _DWORD *v30; // eax\n  int v31; // eax\n  int v33; // [esp+0h] [ebp-3Ch]\n  unsigned int v34; // [esp+4h] [ebp-38h]\n  char *s; // [esp+8h] [ebp-34h]\n  unsigned int v37; // [esp+10h] [ebp-2Ch]\n  char *v38; // [esp+14h] [ebp-28h]\n  int v39; // [esp+18h] [ebp-24h]\n  int c; // [esp+1Ch] [ebp-20h]\n  unsigned int ca; // [esp+1Ch] [ebp-20h]\n  int v42; // [esp+20h] [ebp-1Ch]\n  int v43; // [esp+20h] [ebp-1Ch]\n  void *ptr[6]; // [esp+24h] [ebp-18h] BYREF\n\n  v3 = a3;\n  dword_80DB6D0 = *(_DWORD *)(a1 + 12);\n  v4 = dword_80DBB88;\n  dword_80DB6D4 = *(_DWORD *)(dword_80DBB88 + 4);\n  sub_807510E(*(_DWORD *)(a1 + 8), a3);\n  v5 = sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n  dword_80DB6D4 = (int)(v5 - 1);\n  if ( !a2 )\n    return sub_806F5DA();\n  v33 = sub_806FFC6((int)&v5[-*(_DWORD *)(v4 + 4)]);\n  dword_80DB6B8 = (int)&dword_80DB6B4;\n  v39 = v3 & 1;\n  if ( (v3 & 1) != 0 )\n  {\n    if ( dword_80DB6BC )\n    {\n      v38 = \" \\t\\n\";\n      if ( (*(_BYTE *)(dword_80DBB90 + 188) & 0x20) == 0 )\n        v38 = (char *)(*(_DWORD *)(dword_80DBB90 + 192) + 4);\n      v6 = (unsigned __int8 *)v33;\n      v37 = 0;\n      v7 = &::ptr;\n      do\n      {\n        v8 = (unsigned __int8 *)v7[1] + v33;\n        v34 = (unsigned int)v7[3];\n        s = v38;\n        if ( v34 )\n          s = (char *)(dword_80DBB8C + 44);\n        v9 = 0;\n        while ( v8 < (unsigned __int8 *)((char *)v7[2] + v33) )\n        {\n          v10 = v8 + 1;\n          if ( *v8 != 0x81 )\n            v10 = v8;\n          v42 = (int)v8;\n          c = *v10;\n          v11 = strchr(s, c);\n          v12 = v10 + 1;\n          v13 = (unsigned __int8 *)v42;\n          if ( v11 )\n          {\n            if ( !(v37 | v34) )\n            {\n              v9 = strchr(\" \\t\\n\", c) != 0;\n              v13 = (unsigned __int8 *)v42;\n            }\n            if ( v13 == v6 && v9 )\n            {\n              v9 = v39;\n              v6 = v12;\n            }\n            else\n            {\n              *v13 = 0;\n              v14 = sub_8070C51(8u);\n              v14[1] = v6;\n              *(_DWORD *)dword_80DB6B8 = v14;\n              dword_80DB6B8 = (int)v14;\n              v6 = v12;\n              if ( !v34 )\n              {\n                ca = (unsigned int)v7[2] + v33;\n                while ( 1 )\n                {\n                  v12 = v6;\n                  if ( ca <= (unsigned int)v6 )\n                    break;\n                  if ( *v6 == 0x81 )\n                    v12 = v6 + 1;\n                  v43 = *v12;\n                  if ( !strchr(s, v43) )\n                  {\nLABEL_29:\n                    v12 = v6;\n                    break;\n                  }\n                  if ( strchr(\" \\t\\n\", v43) )\n                  {\n                    v6 = v12 + 1;\n                  }\n                  else\n                  {\n                    if ( !v9 )\n                      goto LABEL_29;\n                    v6 = v12 + 1;\n                    v9 = 0;\n                  }\n                }\n              }\n            }\n          }\n          v8 = v12;\n        }\n        v7 = (void **)*v7;\n        v37 = v34;\n      }\n      while ( v7 );\n      if ( v34 )\n      {\nLABEL_36:\n        v15 = sub_8070C51(8u);\n        v15[1] = v6;\n        *(_DWORD *)dword_80DB6B8 = v15;\n        dword_80DB6B8 = (int)v15;\nLABEL_37:\n        *(_DWORD *)dword_80DB6B8 = 0;\n        dword_80DB6B8 = (int)&dword_80DB6B4;\n        for ( i = dword_80DB6B4; i; i = *(_DWORD *)i )\n        {\n          v17 = dword_80DBB8C;\n          v18 = *(const char **)(i + 4);\n          if ( !*(_BYTE *)(dword_80DBB8C + 46) )\n          {\n            while ( 1 )\n            {\n              v22 = strpbrk(v18, asc_80D0CF7);\n              v23 = v22;\n              if ( !v22 )\n                goto LABEL_40;\n              v19 = *v22;\n              if ( v19 == 92 )\n                break;\n              if ( (unsigned __int8)v19 <= 0x5Cu )\n              {\n                if ( v19 != 91 || strchr(v23 + 1, 93) )\n                {\nLABEL_59:\n                  v24 = (int *)dword_80DB6B8;\n                  ++*(_DWORD *)(v17 + 36);\n                  v25 = (char *)sub_80719CE(*(const char **)(i + 4), 19, 0);\n                  v26 = strlen(v25);\n                  ptr[1] = (void *)(v26 + 4096);\n                  ptr[0] = sub_804DAFA(v26 + 4096);\n                  sub_8072500((int)ptr, v25, v26, 0);\n                  free(ptr[0]);\n                  if ( *(char **)(i + 4) != v25 )\n                    free(v25);\n                  sub_806F4A5();\n                  if ( v24 != (int *)dword_80DB6B8 )\n                  {\n                    *(_DWORD *)dword_80DB6B8 = 0;\n                    v27 = (_DWORD *)*v24;\n                    v28 = 0;\n                    while ( v27 )\n                    {\n                      ++v28;\n                      v27 = (_DWORD *)*v27;\n                    }\n                    v29 = (_DWORD *)sub_806F1B0(*v24, v28);\n                    *v24 = (int)v29;\n                    while ( *v29 )\n                      v29 = (_DWORD *)*v29;\n                    dword_80DB6B8 = (int)v29;\n                    goto LABEL_69;\n                  }\n                  goto LABEL_40;\n                }\n                v20 = v23;\n              }\n              else\n              {\n                if ( v19 == -127 )\n                  break;\n                if ( v19 != -120 )\n                  goto LABEL_59;\n                while ( 1 )\n                {\n                  v20 = v23 + 1;\n                  v21 = v23[1];\n                  if ( v21 == -120 )\n                    break;\n                  v23 += 2;\n                  if ( v21 != -127 )\n                    v23 = v20;\n                  if ( !*v23 )\n                    goto LABEL_40;\n                }\n              }\nLABEL_46:\n              v18 = v20 + 1;\n            }\n            v20 = v23 + 1;\n            if ( !v23[1] )\n              goto LABEL_40;\n            goto LABEL_46;\n          }\nLABEL_40:\n          *(_DWORD *)dword_80DB6B8 = i;\n          sub_80719CE(*(const char **)(i + 4), 0, 0);\n          dword_80DB6B8 = i;\nLABEL_69:\n          ;\n        }\n        goto LABEL_71;\n      }\n    }\n    else\n    {\n      v6 = (unsigned __int8 *)v33;\n    }\n    if ( !*v6 )\n      goto LABEL_37;\n    goto LABEL_36;\n  }\n  v30 = sub_8070C51(8u);\n  v30[1] = v33;\n  *(_DWORD *)dword_80DB6B8 = v30;\n  dword_80DB6B8 = (int)v30;\nLABEL_71:\n  v31 = dword_80DB6B8;\n  *(_DWORD *)dword_80DB6B8 = 0;\n  if ( dword_80DB6B4 )\n  {\n    **(_DWORD **)(a2 + 4) = dword_80DB6B4;\n    *(_DWORD *)(a2 + 4) = v31;\n  }\n  return sub_806F5DA();\n}\n"
    ],
    "sub_80760C6": [
        "0x80760c6",
        "char __usercall sub_80760C6@<al>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // esi\n  int v3; // edi\n  int v4; // ebx\n  char v5; // al\n  int v6; // ecx\n  size_t v7; // eax\n  size_t v8; // ebp\n  int v9; // eax\n  char *v10; // edx\n  size_t v11; // ecx\n  const char *v12; // ebp\n  char *v13; // eax\n  int v14; // ecx\n  int v15; // eax\n  char *v16; // eax\n  int v17; // eax\n  int v18; // edx\n  int v19; // eax\n  _DWORD *v20; // ebp\n  int v21; // eax\n  int v22; // eax\n  int v23; // eax\n  int v24; // eax\n  int v25; // edx\n  _DWORD *v26; // eax\n  int i; // eax\n  bool v28; // al\n  int v30; // [esp+0h] [ebp-78h]\n  char *v31; // [esp+0h] [ebp-78h]\n  int v32; // [esp+0h] [ebp-78h]\n  int v33; // [esp+4h] [ebp-74h]\n  int v34; // [esp+4h] [ebp-74h]\n  int v35; // [esp+4h] [ebp-74h]\n  int v36[4]; // [esp+8h] [ebp-70h] BYREF\n  int v37; // [esp+18h] [ebp-60h]\n\n  if ( a1 )\n  {\n    v2 = a1;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v3 = 0;\n    if ( a2 )\n      v3 = *(_DWORD *)(dword_80DBB90 + 20);\n    while ( 1 )\n    {\n      v4 = *((_DWORD *)v2 + 2);\n      v5 = *v2;\n      if ( (unsigned __int8)(*v2 - 22) > 1u )\n        break;\n      v6 = *((_DWORD *)v2 + 3);\n      if ( v4 != v6 )\n      {\n        v30 = -1;\n        goto LABEL_40;\n      }\nLABEL_79:\n      v2 = (char *)*((_DWORD *)v2 + 1);\n      if ( !v2 )\n      {\n        LOBYTE(a1) = sub_806F4A5();\n        return (char)a1;\n      }\n    }\n    if ( (unsigned __int8)(v5 - 24) > 1u )\n    {\n      v12 = (const char *)*((_DWORD *)v2 + 5);\n      switch ( v5 )\n      {\n        case 16:\n        case 17:\n          if ( !*(_BYTE *)(dword_80DBB8C + 54) || stat64() < 0 )\n            goto LABEL_31;\n          if ( (v37 & 0xF000) == 0x8000 )\n          {\n            *(_DWORD *)dword_80DBB7C = 17;\nLABEL_32:\n            v16 = sub_80720F6(*(_DWORD *)dword_80DBB7C, \"nonexistent directory\");\n            sub_806FB57(\"can't create %s: %s\", v12, v16);\n          }\n          v14 = open64();\n          if ( v14 < 0 )\n            goto LABEL_32;\n          v32 = v14;\n          v15 = fstat64();\n          v6 = v32;\n          if ( !v15 && (v37 & 0xF000) == 0x8000 )\n          {\n            close(v32);\n            *(_DWORD *)dword_80DBB7C = 17;\n            goto LABEL_32;\n          }\n          break;\n        case 18:\n        case 20:\n        case 21:\nLABEL_31:\n          v6 = open64();\n          if ( v6 < 0 )\n            goto LABEL_32;\n          goto LABEL_33;\n        default:\n          v6 = open64();\n          if ( v6 < 0 )\n          {\n            v13 = sub_80720F6(*(_DWORD *)dword_80DBB7C, \"no such file\");\n            sub_806FB57(\"can't open %s: %s\", v12, v13);\n          }\n          goto LABEL_33;\n      }\n      goto LABEL_33;\n    }\n    if ( pipe(v36) < 0 )\n      sub_806FB57(\"can't create pipe: %m\");\n    if ( *v2 == 24 )\n    {\n      v31 = *(char **)(*((_DWORD *)v2 + 3) + 8);\n      v7 = strlen(v31);\n      v8 = v7;\n      if ( v7 <= 0x1000 )\n      {\n        sub_804E586(v7, v31);\nLABEL_19:\n        close(v36[1]);\n        v6 = v36[0];\nLABEL_33:\n        if ( v4 == v6 )\n        {\n          v17 = 0;\n          if ( v3 )\n          {\n            while ( 1 )\n            {\n              v18 = *(_DWORD *)(v3 + 8 * v17 + 8);\n              if ( v18 == -2 )\n                break;\n              if ( v4 == v18 )\n                goto LABEL_79;\n              ++v17;\n            }\n            v19 = v3 + 8 * v17;\n            *(_DWORD *)(v19 + 8) = v4;\n            *(_DWORD *)(v19 + 12) = -1;\n          }\n        }\n        else\n        {\n          v30 = v6;\n          while ( 1 )\n          {\nLABEL_40:\n            if ( v4 == dword_80DB558 )\n            {\n              v33 = v6;\n              dword_80DB558 = sub_8070461(v4);\nLABEL_49:\n              v21 = 1;\n              v6 = v33;\n            }\n            else\n            {\n              if ( v3 )\n              {\n                v20 = off_80DB55C;\n                if ( !v4 )\n                {\n                  v20 = 0;\n                  goto LABEL_50;\n                }\n                while ( v20 )\n                {\n                  if ( v4 == v20[2] )\n                  {\n                    v33 = v6;\n                    v20[2] = sub_8070461(v4);\n                    goto LABEL_49;\n                  }\n                  v20 = (_DWORD *)*v20;\n                }\nLABEL_50:\n                while ( 1 )\n                {\n                  v22 = *(_DWORD *)(v3 + 8 * (_DWORD)v20 + 8);\n                  if ( v22 == -2 )\n                    break;\n                  if ( v4 == *(_DWORD *)(v3 + 8 * (_DWORD)v20 + 12) )\n                  {\n                    v34 = v6;\n                    v23 = sub_806FA55();\n                    *(_DWORD *)(v3 + 8 * (_DWORD)v20 + 12) = v23;\n                    v6 = v34;\n                    if ( v23 < 0 )\n                      goto LABEL_53;\n                    goto LABEL_60;\n                  }\n                  if ( v4 == v22 )\n                    goto LABEL_60;\n                  v20 = (_DWORD *)((char *)v20 + 1);\n                }\n                v35 = v6;\n                v24 = sub_806FA55();\n                v6 = v35;\n                if ( v24 < 0 && *(_DWORD *)dword_80DBB7C != 9 )\nLABEL_53:\n                  sub_804D604();\n                v25 = v3 + 8 * (_DWORD)v20;\n                *(_DWORD *)(v25 + 12) = v24;\n                *(_DWORD *)(v25 + 8) = v4;\n                if ( v4 == *(_DWORD *)(dword_80DBB90 + 24) )\n                  *(_DWORD *)(dword_80DBB90 + 24) = v24;\n              }\nLABEL_60:\n              v21 = 0;\n            }\n            if ( v6 == -1 )\n              break;\n            if ( v6 == dword_80DB558 )\n            {\nLABEL_75:\n              *(_DWORD *)dword_80DBB7C = 9;\n              sub_806FB57(\"%d: %m\", v6);\n            }\n            v26 = off_80DB55C;\n            if ( v6 )\n            {\n              while ( v26 )\n              {\n                if ( v6 == v26[2] )\n                  goto LABEL_75;\n                v26 = (_DWORD *)*v26;\n              }\n            }\n            if ( v3 )\n            {\n              for ( i = 0; i < *(_DWORD *)(v3 + 4) && *(_DWORD *)(v3 + 8 * i + 8) != -2; ++i )\n              {\n                if ( v6 == *(_DWORD *)(v3 + 8 * i + 12) )\n                  goto LABEL_75;\n              }\n            }\n            sub_806FF10(v6, v4);\n            if ( v30 >= 0 )\n              close(v30);\n            v28 = v4 == 1;\n            v4 = 2;\n            v6 = 1;\n            v30 = -1;\n            if ( !v28 || *v2 != 17 )\n              goto LABEL_79;\n          }\n          if ( !v21 )\n            close(v4);\n        }\n        goto LABEL_79;\n      }\n    }\n    else\n    {\n      v8 = 0;\n    }\n    if ( !sub_8072B54(0, 0, 2) )\n    {\n      close(v36[0]);\n      sub_806F3DD(2);\n      sub_806F3DD(3);\n      sub_806F3DD(1);\n      sub_806F3DD(20);\n      signal(13, 0);\n      v9 = *((_DWORD *)v2 + 3);\n      if ( *v2 == 24 )\n      {\n        v10 = *(char **)(v9 + 8);\n        v11 = v8;\n      }\n      else\n      {\n        sub_8075D0B(v9, 0, 0x80u);\n        v10 = *(char **)(dword_80DBB88 + 4);\n        v11 = dword_80DB6D4 - (_DWORD)v10;\n      }\n      sub_804E586(v11, v10);\n      _exit(0);\n    }\n    goto LABEL_19;\n  }\n  return (char)a1;\n}\n"
    ],
    "sub_80764FE": [
        "0x80764fe",
        "int __usercall sub_80764FE@<eax>(char *a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // esi\n  int v3; // eax\n  int v6; // [esp+4h] [ebp-34h]\n  struct __jmp_buf_tag *env; // [esp+8h] [ebp-30h]\n  char v8[44]; // [esp+Ch] [ebp-2Ch] BYREF\n\n  env = *(struct __jmp_buf_tag **)(dword_80DBB8C + 32);\n  v6 = *(_DWORD *)(dword_80DBB8C + 36);\n  v1 = _setjmp((struct __jmp_buf_tag *)v8);\n  v2 = dword_80DBB8C;\n  if ( !v1 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v8;\n    sub_80760C6(a1, 1);\n  }\n  *(_DWORD *)(v2 + 32) = env;\n  if ( v1 && *(_BYTE *)(v2 + 43) != 1 )\n    longjmp(env, 1);\n  v3 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 36) = v6;\n  if ( !*(_DWORD *)(v3 + 36) && *(_BYTE *)(v3 + 40) )\n    sub_806F406();\n  return v1;\n}\n"
    ],
    "sub_8076588": [
        "0x8076588",
        "char __usercall sub_8076588@<al>(int a1@<eax>)\n{\n  int i; // ebx\n  char *v2; // esi\n  int v4[4]; // [esp+0h] [ebp-10h] BYREF\n\n  for ( i = a1; i; i = *(_DWORD *)(i + 4) )\n  {\n    v4[0] = 0;\n    v4[1] = (int)v4;\n    LOBYTE(a1) = *(_BYTE *)i;\n    if ( *(char *)i < 16 )\n      continue;\n    if ( (char)a1 <= 21 )\n    {\n      sub_8075D0B(*(_DWORD *)(i + 16), (int)v4, 0xAu);\nLABEL_8:\n      a1 = *(_DWORD *)(v4[0] + 4);\n      *(_DWORD *)(i + 20) = a1;\n      continue;\n    }\n    if ( (char)a1 <= 23 )\n    {\n      a1 = *(_DWORD *)(i + 16);\n      if ( a1 )\n      {\n        sub_8075D0B(a1, (int)v4, 3u);\n        if ( !v4[0] )\n          goto LABEL_11;\n        v2 = *(char **)(v4[0] + 4);\n        if ( !sub_806EC08(v2) )\n        {\n          if ( *(_DWORD *)(i + 8) != 1 )\nLABEL_11:\n            sub_806FB57(\"redir error\");\n          *(_BYTE *)i = 17;\n          goto LABEL_8;\n        }\n        a1 = sub_804ED6C(10, v2, 0, i);\n        if ( *(_DWORD *)dword_80DBB7C || a1 < 0 )\n        {\n          if ( *v2 != 45 || v2[1] )\n            sub_8070172(\"bad fd number\");\n          *(_DWORD *)(i + 12) = -1;\n        }\n        else\n        {\n          *(_DWORD *)(i + 12) = a1;\n        }\n      }\n    }\n  }\n  return a1;\n}\n"
    ],
    "sub_807665F": [
        "0x807665f",
        "int __cdecl sub_807665F(int a1, int a2)\n{\n  int v2; // esi\n  char v3; // bl\n  int v4; // ecx\n  int v5; // eax\n  int v6; // ebp\n  int v7; // edx\n  int v8; // ecx\n  int v9; // eax\n  int v11; // [esp+0h] [ebp-1Ch]\n  int v12; // [esp+8h] [ebp-14h]\n\n  v2 = a2;\n  v3 = *(_BYTE *)a1;\n  v12 = *(_BYTE *)a1 == 3;\n  v4 = dword_80DBB90;\n  v5 = *(_DWORD *)(a1 + 4);\n  *(_DWORD *)(dword_80DBB90 + 328) = v5;\n  v6 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 12) = v5;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v4 + 328) = v5 - (dword_80DB698 - 1);\n  sub_8076588(*(_DWORD *)(a1 + 12));\n  if ( v3 == 3 || (a2 & 1) == 0 || *(_BYTE *)(v6 + 188) )\n  {\n    ++*(_DWORD *)(v6 + 36);\n    v6 = sub_807151B(1);\n    if ( sub_8072B54(v6, a1, v12) )\n      goto LABEL_11;\n    sub_806F4A5();\n    if ( v3 == 3 )\n      v2 = a2 & 0xFFFFFFFC | 1;\n    else\n      v2 = a2 | 1;\n  }\n  sub_80760C6(*(char **)(a1 + 12), 0);\n  sub_8074EF2(v7, v8, a1, *(char **)(a1 + 8), v2);\nLABEL_11:\n  v9 = 0;\n  if ( v3 != 3 )\n    v9 = sub_8071014(v6);\n  v11 = v9;\n  sub_806F4A5();\n  return v11;\n}\n"
    ],
    "sub_807672E": [
        "0x807672e",
        "int __cdecl sub_807672E(_DWORD *a1, int a2)\n{\n  int v2; // ecx\n  int v3; // eax\n  _DWORD *v4; // ebx\n  int v5; // ebx\n  _DWORD *i; // esi\n  const char *v7; // ebp\n  int v8; // edi\n  const char *v9; // eax\n  int v10; // edi\n  int v11; // edx\n  int v12; // ecx\n  char *v13; // eax\n  int v15[2]; // [esp+0h] [ebp-30h] BYREF\n  _DWORD v16[3]; // [esp+8h] [ebp-28h] BYREF\n  _DWORD v17[7]; // [esp+14h] [ebp-1Ch] BYREF\n\n  v2 = dword_80DBB90;\n  v3 = a1[1];\n  *(_DWORD *)(dword_80DBB90 + 328) = v3;\n  *(_DWORD *)(dword_80DBB8C + 12) = v3;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v2 + 328) = v3 - (dword_80DB698 - 1);\n  sub_8070056(v16);\n  v15[0] = 0;\n  v15[1] = (int)v15;\n  sub_8075D0B(a1[2], (int)v15, 2u);\n  v4 = (_DWORD *)a1[3];\nLABEL_4:\n  if ( v4 && !byte_80DB76C )\n  {\n    for ( i = (_DWORD *)v4[2]; ; i = (_DWORD *)i[1] )\n    {\n      if ( !i )\n      {\n        v4 = (_DWORD *)v4[1];\n        goto LABEL_4;\n      }\n      v7 = *(const char **)(v15[0] + 4);\n      sub_8070056(v17);\n      dword_80DB6D0 = i[3];\n      v8 = dword_80DBB88;\n      dword_80DB6D4 = *(_DWORD *)(dword_80DBB88 + 4);\n      sub_807510E(i[2], 0x12u);\n      if ( *(_DWORD *)(v8 + 8) == dword_80DB6D4 )\n        dword_80DB6D4 = sub_8071CBE();\n      *(_BYTE *)dword_80DB6D4 = 0;\n      sub_806F5DA();\n      v9 = sub_80719CE(*(const char **)(v8 + 4), 2, 0);\n      v10 = fnmatch(v9, v7, 0);\n      sub_806FA10(v17);\n      if ( !v10 )\n        break;\n    }\n    if ( !byte_80DB76C )\n    {\n      v13 = (char *)v4[3];\n      if ( v13 )\n      {\n        v5 = sub_8074EF2(v11, v12, 0, v13, a2);\n        goto LABEL_17;\n      }\n    }\n  }\n  v5 = 0;\nLABEL_17:\n  sub_806FA10(v16);\n  return v5;\n}\n"
    ],
    "sub_8076871": [
        "0x8076871",
        "int __usercall sub_8076871@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char a4)\n{\n  int v4; // ebx\n  int v5; // ebp\n  int v6; // eax\n  int v8; // [esp-8h] [ebp-18h]\n  int v9; // [esp-8h] [ebp-18h]\n  int v10; // [esp-4h] [ebp-14h]\n  int v11; // [esp-4h] [ebp-14h]\n\n  ++dword_80DB69C;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = sub_8074EF2(a1, a2, a3, *(char **)(a3 + 4), 2);\n    v6 = sub_806EDB0();\n    a1 = v8;\n    a2 = v10;\n    if ( v6 == 4 )\n    {\n      v4 = v5;\n      goto LABEL_9;\n    }\n    if ( !v6 )\n      break;\nLABEL_9:\n    if ( (v6 & 0xFFFFFFFD) != 0 )\n      goto LABEL_10;\n  }\n  if ( *(_BYTE *)a3 != 9 )\n    v5 = v5 == 0;\n  if ( !v5 )\n  {\n    v4 = sub_8074EF2(v8, v10, a3, *(char **)(a3 + 8), a4 & 2);\n    v6 = sub_806EDB0();\n    a1 = v9;\n    a2 = v11;\n    goto LABEL_9;\n  }\nLABEL_10:\n  --dword_80DB69C;\n  return v4;\n}\n"
    ],
    "sub_80768DE": [
        "0x80768de",
        "int __cdecl sub_80768DE(int a1, char a2)\n{\n  int v2; // ecx\n  int v3; // eax\n  int i; // ebx\n  int v5; // ebx\n  int v6; // ebp\n  int v7; // edx\n  int v8; // ecx\n  int v10; // [esp+0h] [ebp-24h] BYREF\n  int *v11; // [esp+4h] [ebp-20h]\n  _DWORD v12[7]; // [esp+8h] [ebp-1Ch] BYREF\n\n  v2 = dword_80DBB90;\n  v3 = *(_DWORD *)(a1 + 4);\n  *(_DWORD *)(dword_80DBB90 + 328) = v3;\n  *(_DWORD *)(dword_80DBB8C + 12) = v3;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v2 + 328) = v3 - (dword_80DB698 - 1);\n  sub_8070056(v12);\n  v10 = 0;\n  v11 = &v10;\n  for ( i = *(_DWORD *)(a1 + 8); i; i = *(_DWORD *)(i + 4) )\n    sub_8075D0B(i, (int)&v10, 3u);\n  *v11 = 0;\n  ++dword_80DB69C;\n  v5 = v10;\n  v6 = 0;\n  while ( v5 )\n  {\n    sub_806FE06(*(const char **)(a1 + 16), *(const char **)(v5 + 4));\n    v6 = sub_8074EF2(v7, v8, a2 & 2, *(char **)(a1 + 12), a2 & 2);\n    if ( (sub_806EDB0() & 0xFFFFFFFD) != 0 )\n      break;\n    v5 = *(_DWORD *)v5;\n  }\n  --dword_80DB69C;\n  sub_806FA10(v12);\n  return v6;\n}\n"
    ],
    "sub_80769A1": [
        "0x80769a1",
        "void __usercall __noreturn sub_80769A1(__pid_t a1@<esi>)\n{\n  bool v1; // zf\n  int v2; // eax\n  const char *v3; // eax\n  int status; // [esp+0h] [ebp-28h]\n  char v5[36]; // [esp+4h] [ebp-24h] BYREF\n\n  status = *(unsigned __int8 *)dword_80DBB8C;\n  v1 = _setjmp((struct __jmp_buf_tag *)v5) == 0;\n  v2 = dword_80DBB8C;\n  if ( v1 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v5;\n    v3 = *(const char **)(v2 + 192);\n    if ( v3 )\n    {\n      *(_DWORD *)(dword_80DBB8C + 192) = 0;\n      byte_80DB76C = 0;\n      sub_8074C7C(v3, 0);\n    }\n  }\n  else if ( *(_BYTE *)(dword_80DBB8C + 43) == 4 )\n  {\n    status = *(unsigned __int8 *)dword_80DBB8C;\n  }\n  sub_807050F(0, a1);\n  sub_806F4BD();\n  _exit(status);\n}\n"
    ],
    "sub_8076A14": [
        "0x8076a14",
        "int __usercall sub_8076A14@<eax>(unsigned __int8 a1@<al>)\n{\n  int v2; // esi\n  int v3; // edi\n  char *v4; // ebx\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // eax\n  char *v10; // [esp+0h] [ebp-20h]\n  _DWORD v11[7]; // [esp+4h] [ebp-1Ch] BYREF\n\n  v2 = 0;\n  v3 = 0;\n  do\n  {\n    sub_8070056(v11);\n    if ( byte_80DB76D )\n      sub_80711FF((char *)0xC);\n    v4 = (char *)dword_80DBB8C;\n    v5 = sub_8074C47(a1 & (*(_BYTE *)(dword_80DBB8C + 48) != 0));\n    if ( v5 == (char *)-1 )\n    {\n      if ( (a1 & 1) == 0 || v2 > 49 )\n        return v3;\n      if ( !sub_8070BEF() )\n      {\n        if ( !v4[47] )\n          return v3;\n        sub_8070BC7();\n      }\n      ++v2;\n    }\n    else if ( !v4[50] )\n    {\n      v4[2] >>= 1;\n      v10 = v5;\n      v8 = sub_8074EF2(v6, v7, v3, v5, 0);\n      v2 = 0;\n      if ( v10 )\n        v3 = v8;\n    }\n    sub_806FA10(v11);\n  }\n  while ( !byte_80DB76C );\n  byte_80DB76C &= ~4u;\n  return v3;\n}\n"
    ],
    "sub_8076ACB": [
        "0x8076acb",
        "void __noreturn sub_8076ACB()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8076BF3": [
        "0x8076bf3",
        "char __usercall sub_8076BF3@<al>(const char *a1@<eax>)\n{\n  int v1; // eax\n  int v2; // eax\n\n  v1 = sub_8074AA5(a1, 1);\n  v2 = sub_807009B(v1, 3);\n  if ( v2 >= 0 )\n  {\n    sub_8076A14(0);\n    LOBYTE(v2) = sub_806F6F7();\n  }\n  return v2;\n}\n"
    ],
    "sub_8076C18": [
        "0x8076c18",
        "void sub_8076C18()\n{\n  int v0; // ebx\n  int v1; // edi\n  unsigned int v2; // esi\n  int v3; // eax\n  _DWORD *v4; // eax\n  int v5; // [esp+0h] [ebp-14h]\n\n  v0 = dword_80DB690;\n  dword_80DB690 = 0;\n  while ( v0 )\n  {\n    sub_8074B7B(byte_80DB76E, 2);\n    v1 = *(char *)(v0 + 12);\n    v2 = *(_DWORD *)(v0 + 8);\n    v5 = (**(_BYTE **)(v0 + 4) == 24) + 1;\n    v3 = sub_8073952();\n    sub_8073F3E(v3, v5, v2, v1);\n    v4 = sub_8070C51(0x10u);\n    *(_BYTE *)v4 = 15;\n    v4[2] = dword_80DB68C;\n    v4[3] = dword_80DB688;\n    *(_DWORD *)(*(_DWORD *)(v0 + 4) + 12) = v4;\n    v0 = *(_DWORD *)v0;\n  }\n}\n"
    ],
    "sub_8076C9F": [
        "0x8076c9f",
        "_DWORD *__fastcall sub_8076C9F(int a1)\n{\n  int v1; // edi\n  int v2; // ecx\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  int v5; // ecx\n  int v6; // ecx\n  int v7; // eax\n  int v8; // ecx\n  _DWORD *v9; // ebp\n  int v10; // ecx\n  _DWORD *v11; // esi\n  int v12; // ecx\n  int v13; // ecx\n  int v14; // ecx\n  int v15; // esi\n  int v16; // ecx\n  int v17; // ecx\n  int v18; // ecx\n  int v19; // edx\n  int v20; // ecx\n  const char *v21; // eax\n  int v22; // ecx\n  int v23; // ecx\n  int *v24; // esi\n  int v25; // ecx\n  _DWORD *v26; // eax\n  _DWORD *v27; // eax\n  int v28; // ecx\n  int v29; // ecx\n  _DWORD *v30; // eax\n  int v31; // ecx\n  int v32; // ecx\n  _DWORD *v33; // ebp\n  _DWORD *v34; // esi\n  _DWORD *v35; // ebp\n  _DWORD *v36; // eax\n  int v37; // ecx\n  int v38; // ecx\n  int v39; // ecx\n  int v40; // eax\n  int v41; // ecx\n  int *v42; // ebp\n  int *v43; // edi\n  int v44; // eax\n  int v45; // edx\n  int v46; // eax\n  char *v47; // edx\n  const char *v48; // esi\n  int v49; // eax\n  int v50; // eax\n  int *v51; // edx\n  const char *v52; // eax\n  unsigned int v53; // eax\n  int v54; // eax\n  int v55; // eax\n  const void *v56; // esi\n  _BYTE **v57; // eax\n  int *v58; // esi\n  int v59; // ecx\n  int v60; // eax\n  int v61; // esi\n  _DWORD *v62; // eax\n  int v64; // [esp-8h] [ebp-44h]\n  int v65; // [esp-4h] [ebp-40h]\n  int v66; // [esp-4h] [ebp-40h]\n  int v67; // [esp-4h] [ebp-40h]\n  _DWORD *v68; // [esp+0h] [ebp-3Ch]\n  char v69; // [esp+0h] [ebp-3Ch]\n  int *v70; // [esp+4h] [ebp-38h]\n  int v71; // [esp+8h] [ebp-34h]\n  char v72; // [esp+Fh] [ebp-2Dh]\n  int v73; // [esp+10h] [ebp-2Ch]\n  _DWORD *v74; // [esp+18h] [ebp-24h] BYREF\n  int v75; // [esp+1Ch] [ebp-20h] BYREF\n  int v76; // [esp+20h] [ebp-1Ch] BYREF\n  int v77; // [esp+24h] [ebp-18h] BYREF\n  int v78; // [esp+28h] [ebp-14h] BYREF\n\n  v75 = 0;\n  v1 = *((_DWORD *)off_80DB55C + 1);\n  switch ( sub_8073C7A(a1) )\n  {\n    case 2:\n    case 3:\n    case 22:\n      byte_80DB76A = 1;\n      v76 = 0;\n      v77 = 0;\n      v78 = 0;\n      v73 = *((_DWORD *)off_80DB55C + 1);\n      v69 = 0;\n      v72 = 0;\n      v71 = 1;\n      v42 = &v78;\n      v70 = &v77;\n      v3 = 0;\n      v43 = &v76;\n      break;\n    case 9:\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 4;\n      v3[1] = v1;\n      v3[2] = sub_8073DE5(0, v41);\n      v15 = 10;\n      goto LABEL_96;\n    case 14:\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 12;\n      v3[1] = v1;\n      if ( sub_8073C7A(v29) != 3 )\n        goto LABEL_33;\n      v30 = sub_8070C51(0x10u);\n      v3[2] = v30;\n      *(_BYTE *)v30 = 15;\n      v30[2] = dword_80DB68C;\n      v30[3] = dword_80DB688;\n      byte_80DB76B = 7;\n      if ( sub_8073C7A(v31) != 24 )\n      {\n        v7 = 24;\n        goto LABEL_4;\n      }\n      v33 = v3 + 3;\n      while ( 1 )\n      {\n        byte_80DB76B = 6;\n        if ( sub_8073C7A(v32) == 19 )\n          break;\n        if ( byte_80DB768 == 9 )\n          sub_8073C7A(v32);\n        v34 = sub_8070C51(0x10u);\n        *v33 = v34;\n        *(_BYTE *)v34 = 13;\n        v35 = v34 + 2;\n        while ( 1 )\n        {\n          v36 = sub_8070C51(0x10u);\n          v74 = v36;\n          *v35 = v36;\n          *(_BYTE *)v36 = 15;\n          v36[2] = dword_80DB68C;\n          v36[3] = dword_80DB688;\n          v68 = v36;\n          if ( sub_8073C7A(v37) != 8 )\n            break;\n          v35 = v68 + 1;\n          sub_8073C7A(v38);\n        }\n        if ( byte_80DB768 != 10 )\n          goto LABEL_44;\n        v34[3] = sub_8073DE5(2, v38);\n        v33 = v34 + 1;\n        byte_80DB76B = 6;\n        v40 = sub_8073C7A(v39);\n        if ( v40 == 19 )\n          break;\n        if ( v40 != 11 )\n        {\n          v7 = 11;\n          goto LABEL_4;\n        }\n      }\n      *v33 = 0;\n      goto LABEL_98;\n    case 21:\n      if ( sub_8073C7A(v2) != 3 || byte_80DB769 || *(_BYTE *)sub_80AB128(v20, v19) )\n      {\n        v21 = \"bad for loop variable\";\n        goto LABEL_91;\n      }\n      v3 = sub_8070C51(0x14u);\n      *(_BYTE *)v3 = 11;\n      v3[1] = v1;\n      v3[4] = dword_80DB68C;\n      byte_80DB76B = 7;\n      if ( sub_8073C7A(v22) == 24 )\n      {\n        v24 = (int *)&v74;\n        while ( sub_8073C7A(v23) == 3 )\n        {\n          v26 = sub_8070C51(0x10u);\n          *(_BYTE *)v26 = 15;\n          v26[2] = dword_80DB68C;\n          v26[3] = dword_80DB688;\n          *v24 = (int)v26;\n          v24 = v26 + 1;\n        }\n        *v24 = 0;\n        v3[2] = v74;\n        if ( byte_80DB768 != 4 && byte_80DB768 != 1 )\n          goto LABEL_26;\n      }\n      else\n      {\n        v27 = sub_8070C51(0x10u);\n        *(_BYTE *)v27 = 15;\n        v27[2] = &unk_80D0F91;\n        v3[2] = v27;\n        if ( byte_80DB768 != 4 )\n          byte_80DB76A = 1;\n      }\n      byte_80DB76B = 7;\n      if ( sub_8073C7A(v25) != 15 )\n      {\nLABEL_14:\n        v7 = 15;\n        goto LABEL_4;\n      }\n      v3[3] = sub_8073DE5(0, v28);\nLABEL_31:\n      v15 = 16;\n      goto LABEL_96;\n    case 23:\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 8;\n      v3[1] = sub_8073DE5(0, v4);\n      if ( sub_8073C7A(v5) != 25 )\n        goto LABEL_3;\n      v3[2] = sub_8073DE5(0, v6);\n      v9 = v3;\n      while ( 2 )\n      {\n        if ( sub_8073C7A(v8) == 17 )\n        {\n          v11 = sub_8070C51(0x10u);\n          v9[3] = v11;\n          *(_BYTE *)v11 = 8;\n          v11[1] = sub_8073DE5(0, v12);\n          if ( sub_8073C7A(v13) == 25 )\n          {\n            v11[2] = sub_8073DE5(0, v14);\n            v9 = v11;\n            continue;\n          }\nLABEL_3:\n          v7 = 25;\n          goto LABEL_4;\n        }\n        break;\n      }\n      if ( byte_80DB768 == 18 )\n      {\n        v9[3] = sub_8073DE5(0, v10);\n      }\n      else\n      {\n        v9[3] = 0;\n        byte_80DB76A = 1;\n      }\n      v15 = 20;\nLABEL_96:\n      if ( sub_8073C7A(v10) != v15 )\n      {\n        v7 = v15;\n        goto LABEL_4;\n      }\nLABEL_98:\n      byte_80DB76B = 3;\n      v58 = &v75;\n      while ( sub_8073C7A(v32) == 2 )\n      {\n        v60 = dword_80DB684;\n        *v58 = dword_80DB684;\n        v58 = (int *)(v60 + 4);\n        sub_8073D17(v59);\n      }\n      byte_80DB76A = 1;\n      *v58 = 0;\n      v61 = v75;\n      if ( v75 )\n      {\n        if ( *(_BYTE *)v3 != 4 )\n        {\n          v62 = sub_8070C51(0x10u);\n          *(_BYTE *)v62 = 2;\n          v62[1] = v1;\n          v62[2] = v3;\n          v3 = v62;\n        }\n        v3[3] = v61;\n      }\n      return v3;\n    case 26:\n    case 27:\n      v3 = sub_8070C51(0xCu);\n      *(_BYTE *)v3 = (byte_80DB768 != 27) + 9;\n      v3[1] = sub_8073DE5(0, v16);\n      if ( sub_8073C7A(v17) != 15 )\n        goto LABEL_14;\n      v3[2] = sub_8073DE5(0, v18);\n      goto LABEL_31;\n    case 28:\n      v3 = sub_8073DE5(0, v2);\n      v15 = 29;\n      goto LABEL_96;\n    default:\n      goto LABEL_26;\n  }\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      byte_80DB76B = v71;\n      v44 = sub_8073C7A(v2);\n      if ( v44 > 7 )\n        break;\n      if ( v44 >= 6 )\n      {\n        if ( !v72 )\n          goto LABEL_95;\n        v47 = \"-o\";\n        if ( v44 == 6 )\n          v47 = (char *)\"-a\";\n        dword_80DB68C = v47;\n      }\n      else\n      {\n        if ( v44 == 2 )\n        {\n          v3 = (_DWORD *)dword_80DB684;\n          *v42 = dword_80DB684;\n          v42 = v3 + 1;\n          sub_8073D17(v2);\n          continue;\n        }\n        if ( v44 != 3 )\n          goto LABEL_95;\n      }\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 15;\n      v48 = dword_80DB68C;\n      v3[2] = dword_80DB68C;\n      v49 = strcmp(\"[[\", v48);\n      v2 = v65;\n      if ( v49 )\n      {\n        v50 = strcmp(\"]]\", v48);\n        v2 = v66;\n        if ( !v50 )\n          v72 = 0;\n      }\n      else\n      {\n        v72 = 1;\n      }\n      v3[3] = dword_80DB688;\n      v51 = v3 + 1;\n      if ( v71 && (v52 = (const char *)((int (*)(void))sub_80AB128)(), v51 = v3 + 1, v48 != v52) && *v52 == 61 )\n      {\n        *v70 = (int)v3;\n        v70 = v3 + 1;\n      }\n      else\n      {\n        *v43 = (int)v3;\n        v43 = v51;\n        v71 = 0;\n      }\n      if ( v69 )\n      {\n        byte_80DB76B = 6;\n        v53 = sub_8073C7A(v2);\n        v2 = v53;\n        byte_80DB76A = 1;\n        if ( v53 > 0x1C )\n          goto LABEL_26;\n        v54 = 1 << v53;\n        if ( ((1 << v2) & 0x1CA04000) == 0 )\n        {\n          if ( (v54 & 0x200) != 0 )\n          {\n            v69 = 0;\n            continue;\n          }\n          if ( (v54 & 8) == 0 || (v55 = strcmp(\"[[\", dword_80DB68C), v45 = v64, v2 = v67, v55) )\n          {\nLABEL_26:\n            v7 = -1;\n            goto LABEL_4;\n          }\n        }\nLABEL_83:\n        if ( v76 && v43 == (int *)(v76 + 4) && !v77 && !v78 )\n        {\n          if ( v69 || sub_8073C7A(v2) == 10 )\n          {\n            v56 = (const void *)v3[2];\n            if ( !*(_BYTE *)sub_80AB128(v2, v45) )\n            {\n              v57 = (_BYTE **)sub_8070CB3(v56);\n              if ( !v57 || (**v57 & 1) == 0 )\n              {\n                *(_BYTE *)v3 = 14;\n                byte_80DB76B = 7;\n                v3[1] = *((_DWORD *)off_80DB55C + 1);\n                v3[3] = sub_8076C9F();\n                return v3;\n              }\n            }\n            v21 = \"bad function name\";\nLABEL_91:\n            sub_8070172(v21);\n          }\nLABEL_44:\n          v7 = 10;\nLABEL_4:\n          sub_807275C(v7);\n        }\nLABEL_95:\n        byte_80DB76A = 1;\n        *v43 = 0;\n        *v70 = 0;\n        *v42 = 0;\n        v3 = sub_8070C51(0x14u);\n        v3[1] = v73;\n        v3[3] = v76;\n        v3[2] = v77;\n        v3[4] = v78;\n        return v3;\n      }\n    }\n    if ( v44 == 9 )\n      goto LABEL_83;\n    if ( v44 == 22 )\n    {\n      v46 = sub_8073C7A(v2);\n      byte_80DB76A = 1;\n      if ( v46 == 3 )\n      {\n        v69 = 1;\n        continue;\n      }\nLABEL_33:\n      v7 = 3;\n      goto LABEL_4;\n    }\n    goto LABEL_95;\n  }\n}\n"
    ],
    "sub_8077325": [
        "0x8077325",
        "_DWORD *__fastcall sub_8077325(int a1)\n{\n  int v1; // ecx\n  int v2; // ebp\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  _DWORD *v5; // edi\n  _DWORD *v6; // esi\n  _DWORD *v7; // ebx\n  int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // eax\n\n  if ( sub_8073C7A(a1) == 13 )\n  {\n    byte_80DB76B = 3;\n    v2 = 1;\n  }\n  else\n  {\n    byte_80DB76A = 1;\n    v2 = 0;\n  }\n  v3 = sub_8076C9F(v1);\n  if ( sub_8073C7A(v4) == 8 )\n  {\n    v5 = sub_8070C51(8u);\n    *(_BYTE *)v5 = 1;\n    v6 = sub_8070C51(8u);\n    v5[1] = v6;\n    v6[1] = v3;\n    do\n    {\n      v7 = sub_8070C51(8u);\n      byte_80DB76B = 7;\n      v7[1] = sub_8076C9F(v8);\n      *v6 = v7;\n      v6 = v7;\n    }\n    while ( sub_8073C7A(v9) == 8 );\n    *v7 = 0;\n    v3 = v5;\n  }\n  byte_80DB76A = 1;\n  if ( v2 )\n  {\n    v10 = sub_8070C51(8u);\n    *(_BYTE *)v10 = 26;\n    v10[1] = v3;\n    return v10;\n  }\n  return v3;\n}\n"
    ],
    "sub_80773CC": [
        "0x80773cc",
        "char __usercall sub_80773CC@<al>(int a1@<eax>)\n{\n  _DWORD *v2; // eax\n  void *v3; // ebx\n  int v4; // esi\n  int v5; // edx\n  int v6; // edi\n  int v7; // eax\n  const void *v8; // esi\n  void (*v9)(void); // edx\n  char *v10; // eax\n  char v11; // cl\n  void *v13; // [esp+0h] [ebp-14h]\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v2 = dword_80DB694;\n  dword_80DB694 = *(void **)dword_80DB694;\n  v3 = (void *)v2[1];\n  free(v2);\n  while ( v3 )\n  {\n    v13 = *(void **)v3;\n    v4 = *((_DWORD *)v3 + 1);\n    if ( a1 )\n    {\n      v5 = *((_DWORD *)v3 + 2);\n      v6 = 4;\n      if ( v5 != 32 )\n      {\n        v6 = 12;\n        if ( *(_DWORD *)(v4 + 8) != *((_DWORD *)v3 + 3) )\n        {\n          v6 = 4;\n          if ( (v5 & 0x18) == 0 )\n            free(*((void **)v3 + 3));\n        }\n      }\n      v7 = *(_DWORD *)(v4 + 4) ^ v6 & (*(_DWORD *)(v4 + 4) ^ *((_DWORD *)v3 + 2));\n      *(_DWORD *)(v4 + 4) = v7;\n      if ( (v7 & 0x27) == 32 )\n        goto LABEL_14;\n    }\n    else\n    {\n      if ( !v4 )\n      {\n        v8 = (const void *)*((_DWORD *)v3 + 3);\n        qmemcpy((void *)(dword_80DBB8C + 45), v8, 0xFu);\n        free(*((void **)v3 + 3));\n        sub_8070672((__pid_t)v8 + 15);\n        goto LABEL_23;\n      }\n      if ( *((_DWORD *)v3 + 2) == 32 )\n      {\n        *(_DWORD *)(v4 + 4) &= 0xFFFFFFF9;\nLABEL_14:\n        sub_806FDFD(*(const char **)(v4 + 8));\n        goto LABEL_23;\n      }\n      v9 = *(void (**)(void))(v4 + 12);\n      if ( v9 )\n      {\n        v10 = (char *)*((_DWORD *)v3 + 3);\n        do\n        {\n          v11 = *v10;\n          if ( !*v10 )\n            break;\n          ++v10;\n        }\n        while ( v11 != 61 );\n        v9();\n      }\n      if ( (*(_BYTE *)(v4 + 4) & 0x18) == 0 )\n        free(*(void **)(v4 + 8));\n      *(_DWORD *)(v4 + 4) = *((_DWORD *)v3 + 2);\n      *(_DWORD *)(v4 + 8) = *((_DWORD *)v3 + 3);\n    }\nLABEL_23:\n    free(v3);\n    v3 = v13;\n  }\n  return sub_806F4A5();\n}\n"
    ],
    "sub_80774DC": [
        "0x80774dc",
        "int __usercall sub_80774DC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4)\n{\n  int v4; // ebp\n  int v5; // eax\n  _DWORD *v6; // ebx\n  int v7; // edx\n  int v8; // ecx\n  int v9; // ebx\n  int v12; // [esp+4h] [ebp-58h]\n  int v15; // [esp+10h] [ebp-4Ch]\n  char v16[20]; // [esp+14h] [ebp-48h] BYREF\n  char v17[52]; // [esp+28h] [ebp-34h] BYREF\n\n  qmemcpy(v16, (const void *)dword_80DBB90, sizeof(v16));\n  v12 = dword_80DB698;\n  v15 = *(_DWORD *)(dword_80DBB8C + 32);\n  v4 = _setjmp((struct __jmp_buf_tag *)v17);\n  v5 = dword_80DBB8C;\n  if ( !v4 )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    *(_DWORD *)(v5 + 32) = v17;\n    v6 = (_DWORD *)dword_80DBB90;\n    *(_BYTE *)(dword_80DBB90 + 12) = 0;\n    ++*(_DWORD *)a1;\n    dword_80DB698 = *(_DWORD *)(a1 + 8);\n    sub_806F4A5();\n    *v6 = a2 - 1;\n    v6[4] = a3 + 4;\n    v6[1] = 1;\n    v6[2] = -1;\n    sub_806F84B();\n    sub_8074EF2(v7, v8, (int)v17, *(char **)(a1 + 16), a4 & 2);\n    sub_80773CC(0);\n  }\n  v9 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  dword_80DB698 = v12;\n  sub_806EEEB((_DWORD *)a1);\n  sub_806EEC0(dword_80DBB90);\n  qmemcpy((void *)dword_80DBB90, v16, 0x14u);\n  *(_DWORD *)(v9 + 32) = v15;\n  sub_806F4A5();\n  byte_80DB76C &= ~4u;\n  return v4;\n}\n"
    ],
    "sub_80775EB": [
        "0x80775eb",
        "char __usercall sub_80775EB@<al>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>, char *haystack)\n{\n  char *v6; // eax\n  char *v7; // eax\n  const char *v8; // eax\n  const char *v9; // ebp\n  char v10; // dl\n  int v11; // eax\n  char *v12; // eax\n  int v13; // eax\n  const char *v14; // edi\n  size_t v15; // eax\n  const char *v16; // eax\n  int v17; // eax\n  const char *v18; // eax\n  char *v19; // eax\n  char v21; // [esp-4h] [ebp-9Ch]\n  int v23; // [esp+4h] [ebp-94h]\n  char *v24; // [esp+8h] [ebp-90h]\n  _BYTE *v25; // [esp+Ch] [ebp-8Ch]\n  int v26; // [esp+10h] [ebp-88h]\n  _BOOL4 v27; // [esp+14h] [ebp-84h]\n  int v28; // [esp+18h] [ebp-80h]\n  int v29[3]; // [esp+1Ch] [ebp-7Ch] BYREF\n  int v30; // [esp+38h] [ebp-60h]\n\n  v6 = strchr(a1, 47);\n  if ( v6 )\n  {\n    *(_DWORD *)(a2 + 4) = -1;\n    if ( (a3 & 2) != 0 && (v6 = (char *)stat64(), (int)v6 < 0) )\nLABEL_5:\n      *(_BYTE *)a2 = -1;\n    else\n      *(_BYTE *)a2 = 0;\n    return (char)v6;\n  }\n  v7 = (char *)(*(_DWORD *)(dword_80DBB90 + 208) + 5);\n  v27 = v7 == haystack;\n  if ( v7 != haystack )\n  {\n    if ( strstr(haystack, \"%builtin\") )\n      a3 |= 0x28u;\n    else\n      a3 |= 8u;\n  }\n  v8 = sub_806F11D(a1, 0);\n  v9 = v8;\n  if ( v8 )\n  {\n    v10 = v8[8];\n    v11 = 4;\n    if ( v10 != 1 )\n      v11 = v10 == 2 ? 32 : 8;\n    if ( (v11 & a3) != 0 )\n    {\n      v27 = 0;\n      v9 = 0;\n    }\n    else if ( !v9[9] )\n    {\n      goto LABEL_66;\n    }\n  }\n  v12 = (char *)sub_8070CB3(a1);\n  v24 = v12;\n  if ( !v12 )\n    goto LABEL_23;\n  if ( (**(_BYTE **)v12 & 2) != 0 )\n    goto LABEL_62;\n  if ( (a3 & 8) == 0 )\n  {\n    if ( dword_80DB554 > 0 )\n      goto LABEL_23;\nLABEL_62:\n    if ( v27 )\n    {\n      ++*(_DWORD *)(dword_80DBB8C + 36);\n      v9 = sub_806F11D(a1, 1);\n      *((_BYTE *)v9 + 8) = 2;\n      v17 = (int)v24;\n      goto LABEL_65;\n    }\n    *(_BYTE *)a2 = 2;\n    v6 = v24;\n    goto LABEL_67;\n  }\n  if ( (a3 & 0x20) == 0 )\n    goto LABEL_62;\nLABEL_23:\n  v26 = -1;\n  if ( v9 && v9[9] )\n  {\n    v13 = dword_80DB554;\n    if ( v9[8] != 2 )\n      v13 = *((_DWORD *)v9 + 1);\n    v26 = v13;\n  }\n  v28 = 2;\n  v23 = -1;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v6 = (char *)sub_8071D7C(&haystack, a1);\n          v14 = v6;\n          if ( !v6 )\n          {\n            if ( v9 && v27 )\n              LOBYTE(v6) = sub_806F817();\n            if ( (a3 & 1) != 0 )\n            {\n              v18 = sub_806F11D(\"command_not_found_handle\", 0);\n              if ( v18 && v18[8] == 1 )\n              {\n                v29[0] = (int)\"command_not_found_handle\";\n                v29[1] = (int)a1;\n                v29[2] = 0;\n                sub_80774DC(*((_DWORD *)v18 + 1), 2, (int)v29, 0);\n                *(_BYTE *)a2 = -1;\n                LOBYTE(v6) = v21;\n                return (char)v6;\n              }\n              v19 = sub_80720F6(v28, \"not found\");\n              LOBYTE(v6) = sub_8070501(\"%s: %s\", a1, v19);\n            }\n            goto LABEL_5;\n          }\n          sub_806EC35((int)v6);\n          ++v23;\n          v25 = (_BYTE *)dword_80DB6FC;\n          if ( !dword_80DB6FC )\n            break;\n          if ( sub_806EC47((_BYTE *)dword_80DB6FC, \"builtin\") )\n          {\n            if ( v24 )\n              goto LABEL_62;\n          }\n          else if ( (a3 & 4) == 0 && sub_806EC47(v25, \"func\") )\n          {\n            break;\n          }\n        }\n        if ( *v14 != 47 || v26 < v23 )\n          break;\n        if ( v26 <= v23 )\n          goto LABEL_66;\n      }\n      if ( stat64() >= 0 )\n        break;\n      if ( *(_DWORD *)dword_80DBB7C != 2 && *(_DWORD *)dword_80DBB7C != 20 )\n        v28 = *(_DWORD *)dword_80DBB7C;\n    }\n    if ( (v30 & 0xF000) == 0x8000 )\n      break;\n    v28 = 13;\n  }\n  if ( v25 )\n  {\n    v15 = strlen(v14);\n    sub_806FFC6(v15 + 1);\n    sub_807009B((int)v14, 1);\n    sub_8076A14(0);\n    sub_806F6F7();\n    v16 = sub_806F11D(a1, 0);\n    v9 = v16;\n    if ( !v16 || v16[8] != 1 )\n      sub_806FB57(\"%s not defined in %s\", a1, v14);\n    sub_806EC35((int)v14);\n    goto LABEL_66;\n  }\n  if ( !v27 )\n  {\n    *(_BYTE *)a2 = 0;\n    v6 = (char *)v23;\n    goto LABEL_67;\n  }\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v9 = sub_806F11D(a1, 1);\n  *((_BYTE *)v9 + 8) = 0;\n  v17 = v23;\nLABEL_65:\n  *((_DWORD *)v9 + 1) = v17;\n  sub_806F4A5();\nLABEL_66:\n  *((_BYTE *)v9 + 9) = 0;\n  *(_BYTE *)a2 = v9[8];\n  v6 = (char *)*((_DWORD *)v9 + 1);\nLABEL_67:\n  *(_DWORD *)(a2 + 4) = v6;\n  return (char)v6;\n}\n"
    ],
    "sub_807796A": [
        "0x807796a",
        "int __usercall sub_807796A@<eax>(const void *a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  int v4; // ebx\n  int v5; // edi\n  _BYTE **v6; // edi\n  int v7; // eax\n  int v8; // eax\n  const char *v9; // eax\n  char *v11; // [esp+0h] [ebp-1Ch] BYREF\n  char v12[4]; // [esp+4h] [ebp-18h] BYREF\n  _BYTE **v13; // [esp+8h] [ebp-14h]\n\n  v11 = a2;\n  v4 = a3;\n  if ( !a2 )\n    a2 = (char *)(*(_DWORD *)(dword_80DBB90 + 208) + 5);\n  v11 = a2;\n  if ( a3 )\n    sub_8072DB0();\n  if ( sub_8070CCB(a1) )\n    goto LABEL_18;\n  v5 = *sub_806F0C2((const char *)a1);\n  if ( v5 )\n  {\n    if ( !v4 )\n    {\n      sub_8072DB0();\n      sub_807176F(v5);\n      return v4;\n    }\n    sub_80708A7(\" is an alias for %s\", *(_DWORD *)(v5 + 8));\nLABEL_26:\n    sub_8072DB0();\n    return 0;\n  }\n  sub_80775EB((const char *)a1, (int)v12, 2, v11);\n  switch ( v12[0] )\n  {\n    case 1:\nLABEL_18:\n      sub_8072DB0();\n      goto LABEL_26;\n    case 2:\n      if ( v4 )\n      {\n        v9 = \"special \";\n        if ( (**v13 & 1) == 0 )\n          v9 = (const char *)(dword_80DBB8C + 44);\n        sub_80708A7(\" is a %sshell builtin\", v9);\n        goto LABEL_26;\n      }\n      goto LABEL_18;\n    case 0:\n      v6 = v13;\n      if ( (int)v13 >= 0 )\n      {\n        do\n        {\n          v7 = sub_8071D7C(&v11, (const char *)a1);\n          v8 = sub_806EC35(v7);\n          v6 = (_BYTE **)((char *)v6 - 1);\n        }\n        while ( v6 != (_BYTE **)-1 );\n        a1 = (const void *)v8;\n      }\n      if ( v4 )\n      {\n        sub_80708A7(\" is %s\", a1);\n        goto LABEL_26;\n      }\n      goto LABEL_18;\n  }\n  if ( v4 )\n    sub_8072DB0();\n  return 127;\n}\n"
    ],
    "sub_8077AA3": [
        "0x8077aa3",
        "int __fastcall sub_8077AA3(int a1, int a2)\n{\n  _BYTE *v2; // eax\n  int v3; // edi\n  int v4; // eax\n  int v5; // esi\n  int i; // ebx\n  const void *v7; // eax\n\n  v2 = *(_BYTE **)(a2 + 4);\n  if ( v2 )\n  {\n    v3 = *v2 != 45;\n    v4 = (*v2 == 45) + 1;\n  }\n  else\n  {\n    v3 = 1;\n    v4 = 1;\n  }\n  v5 = a2 + 4 * v4;\n  for ( i = 0; ; i |= sub_807796A(v7, 0, v3) )\n  {\n    v5 += 4;\n    v7 = *(const void **)(v5 - 4);\n    if ( !v7 )\n      break;\n  }\n  return i;\n}\n"
    ],
    "sub_8077AEC": [
        "0x8077aec",
        "void __noreturn sub_8077AEC()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8077B33": [
        "0x8077b33",
        "int __cdecl sub_8077B33(int a1, int a2)\n{\n  _DWORD *v2; // edx\n  int v3; // eax\n  int v4; // ecx\n  int v5; // ebp\n  _DWORD *v6; // ebx\n  int v7; // esi\n  int v8; // edx\n  int v9; // edx\n  int v10; // ecx\n  int v11; // eax\n  int v13; // [esp-4h] [ebp-2Ch]\n  int v14; // [esp+0h] [ebp-28h]\n  int fd; // [esp+4h] [ebp-24h]\n  int pipedes[2]; // [esp+8h] [ebp-20h] BYREF\n  char v17[24]; // [esp+10h] [ebp-18h] BYREF\n\n  v2 = *(_DWORD **)(a1 + 4);\n  v3 = 0;\n  while ( v2 )\n  {\n    ++v3;\n    v2 = (_DWORD *)*v2;\n  }\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v5 = sub_807151B(v3);\n  v6 = *(_DWORD **)(a1 + 4);\n  v7 = -1;\n  while ( v6 )\n  {\n    v8 = v6[1];\n    if ( !*(_BYTE *)v8 )\n    {\n      if ( *(_DWORD *)(v8 + 12) )\n      {\n        fd = v6[1];\n        if ( !*(_BYTE *)sub_80AB128(v4, v8) )\n          sub_80775EB(\n            *(const char **)(*(_DWORD *)(fd + 12) + 8),\n            (int)v17,\n            0,\n            (char *)(*(_DWORD *)(dword_80DBB90 + 208) + 5));\n      }\n    }\n    pipedes[1] = -1;\n    if ( *v6 && pipe(pipedes) < 0 )\n    {\n      close(v7);\n      sub_806FB57(\"can't create pipe: %m\");\n    }\n    if ( !sub_8072B54(v5, v6[1], *(char *)(a1 + 1)) )\n    {\n      sub_806F4A5();\n      if ( pipedes[1] >= 0 )\n      {\n        close(pipedes[0]);\n        v10 = v13;\n      }\n      if ( v7 > 0 )\n      {\n        dup2(v7, 0);\n        close(v7);\n      }\n      if ( pipedes[1] > 1 )\n      {\n        dup2(pipedes[1], 1);\n        close(pipedes[1]);\n      }\n      sub_8074EF2(v9, v10, a1, (char *)v6[1], a2 | 1);\n    }\n    if ( v7 >= 0 )\n      close(v7);\n    v7 = a2 | 1;\n    if ( fd != -1 )\n      close(fd);\n    v6 = (_DWORD *)*v6;\n  }\n  v11 = 0;\n  if ( !*(_BYTE *)(a1 + 1) )\n    v11 = sub_8071014(v5);\n  v14 = v11;\n  sub_806F4A5();\n  return v14;\n}\n"
    ],
    "sub_8077C97": [
        "0x8077c97",
        "void __noreturn sub_8077C97()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
    ],
    "sub_8077DB8": [
        "0x8077db8",
        "int __cdecl sub_8077DB8(_DWORD *a1, char a2)\n{\n  int v2; // ecx\n  int v3; // eax\n  int v4; // ebx\n  int v5; // eax\n  _BYTE **v6; // eax\n  int v7; // edx\n  int v8; // ecx\n  _BOOL4 v9; // esi\n  int v10; // ebx\n  int *v11; // edi\n  _BYTE *v12; // ebp\n  _BYTE *v13; // eax\n  unsigned int v14; // ecx\n  _DWORD *i; // eax\n  const char **v16; // eax\n  _DWORD *j; // edx\n  int *v18; // esi\n  char *v19; // eax\n  const char *v20; // ebx\n  const char **v21; // edx\n  int v22; // ebx\n  int v23; // edi\n  int v24; // ebp\n  int v25; // ebp\n  int **k; // edi\n  _BYTE *v27; // eax\n  _BYTE *v28; // edx\n  int m; // edi\n  bool v30; // zf\n  _BYTE *v31; // eax\n  int v32; // ecx\n  int v33; // ebp\n  char v34; // si\n  const char **v35; // eax\n  const char *v36; // esi\n  char *v37; // edi\n  char v38; // cl\n  int v39; // ebx\n  int v40; // eax\n  int n; // eax\n  char v43; // [esp-4h] [ebp-58h]\n  int v44; // [esp+0h] [ebp-54h]\n  char *v45; // [esp+4h] [ebp-50h]\n  const char **v46; // [esp+8h] [ebp-4Ch]\n  const char *v47; // [esp+Ch] [ebp-48h]\n  char *v48; // [esp+10h] [ebp-44h]\n  void *v49; // [esp+14h] [ebp-40h]\n  int v50; // [esp+18h] [ebp-3Ch]\n  _DWORD *v51; // [esp+20h] [ebp-34h] BYREF\n  int *v52; // [esp+24h] [ebp-30h]\n  int **v53; // [esp+28h] [ebp-2Ch] BYREF\n  int ***v54; // [esp+2Ch] [ebp-28h]\n  char v55[4]; // [esp+30h] [ebp-24h] BYREF\n  char **v56; // [esp+34h] [ebp-20h]\n  _DWORD v57[7]; // [esp+38h] [ebp-1Ch] BYREF\n\n  v2 = dword_80DBB90;\n  v3 = a1[1];\n  *(_DWORD *)(dword_80DBB90 + 328) = v3;\n  v4 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 12) = v3;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v2 + 328) = v3 - (dword_80DB698 - 1);\n  sub_8070056(v57);\n  v49 = (void *)sub_806F84B();\n  *(_BYTE *)(v4 + 1) = 0;\n  v55[0] = 2;\n  v56 = (char **)&off_80B7D60;\n  v54 = &v53;\n  v53 = 0;\n  v52 = (int *)&v51;\n  v51 = 0;\n  v5 = a1[3];\n  v44 = 0;\n  if ( v5 )\n  {\n    v6 = (_BYTE **)sub_8070CB3(*(const void **)(v5 + 8));\n    v9 = 0;\n    if ( v6 )\n      v9 = (**v6 & 4) != 0;\n    v10 = a1[3];\n    v44 = 0;\n    while ( v10 )\n    {\n      v11 = v52;\n      if ( !v9 || (v12 = *(_BYTE **)(v10 + 8), v13 = (_BYTE *)sub_80AB128(v8, v7), v12 == v13) || (v14 = 4, *v13 != 61) )\n        v14 = 3;\n      sub_8075D0B(v10, (int)&v51, v14);\n      for ( i = (_DWORD *)*v11; i; i = (_DWORD *)*i )\n        ++v44;\n      v10 = *(_DWORD *)(v10 + 4);\n    }\n  }\n  v16 = (const char **)(sub_806FFC6(4 * v44 + 8) + 4);\n  v46 = v16;\n  for ( j = v51; j; j = (_DWORD *)*j )\n    *v16++ = (const char *)j[1];\n  *v16 = 0;\n  v47 = 0;\n  if ( *(_BYTE *)(dword_80DBB8C + 48) )\n  {\n    if ( dword_80DB698 || !v44 )\n      v47 = 0;\n    else\n      v47 = *(v16 - 1);\n  }\n  sub_8076588(a1[4]);\n  v50 = sub_806EE2E(a1[4]);\n  v18 = (int *)dword_80DBB90;\n  *(_DWORD *)(dword_80DBB90 + 24) = 2;\n  if ( *(_BYTE *)(dword_80DBB8C + 52) )\n  {\n    v19 = sub_8072EED(\"BASH_XTRACEFD\");\n    v20 = v19;\n    if ( v19 )\n    {\n      if ( sub_806EC60(v19) )\n        v18[6] = atoi(v20);\n    }\n  }\n  v22 = sub_80764FE((char *)a1[4]);\n  v45 = (char *)v18[52];\n  v23 = a1[2];\n  while ( v23 )\n  {\n    v24 = (int)v54;\n    sub_8075D0B(v23, (int)&v53, 4u);\n    sub_80706CA(*(_DWORD *)(*(_DWORD *)v24 + 4));\n    v25 = *(_DWORD *)(*(_DWORD *)v24 + 4);\n    if ( sub_806EC79(v25, (int)v45) )\n      v25 = (int)v45;\n    v23 = *(_DWORD *)(v23 + 4);\n    v45 = (char *)v25;\n  }\n  if ( *(_BYTE *)(dword_80DBB8C + 52) )\n  {\n    sub_8074AA5((const char *)(v18[64] + 4), 1);\n    dprintf();\n    for ( k = v53; k; k = (int **)*k )\n    {\n      v27 = (_BYTE *)strchrnul();\n      v28 = v27;\n      if ( *v27 )\n        v28 = v27 + 1;\n      sub_807189F(v28);\n      dprintf();\n    }\n    for ( m = (int)v51; m; m = *(_DWORD *)m )\n    {\n      v30 = sub_8070CCB(*(const void **)(m + 4)) == 0;\n      v31 = *(_BYTE **)(m + 4);\n      if ( v30 )\n        sub_807189F(v31);\n      else\n        sub_80716D8(v31);\n      dprintf();\n    }\n    sub_804E65D(1u, (void *)\"\\n\", v18[6]);\n  }\n  if ( !v44 )\n  {\n    v33 = -1;\n    if ( v22 )\n    {\n      *(_BYTE *)dword_80DBB8C = v22;\n      goto LABEL_109;\n    }\nLABEL_72:\n    if ( v55[0] == 1 )\n    {\n      sub_80773CC(1);\n      sub_8070DA4(0, 0);\n      v40 = sub_80774DC((int)v56, v44, (int)v46, a2);\n      LOBYTE(v21) = v43;\n      if ( v40 )\n        goto LABEL_90;\n      v34 = 0;\n      goto LABEL_93;\n    }\n    if ( v55[0] == 2 )\n    {\n      v34 = 0;\n      goto LABEL_81;\n    }\n    if ( (a2 & 1) == 0 || *(_BYTE *)(dword_80DBB8C + 188) )\n    {\n      ++*(_DWORD *)(dword_80DBB8C + 36);\n      v39 = sub_807151B(1);\n      if ( sub_8072B54(v39, (int)a1, 0) )\n      {\n        v22 = sub_8071014(v39);\n        sub_806F4A5();\nLABEL_109:\n        v34 = 0;\n        goto LABEL_94;\n      }\n      sub_806F48C();\n    }\n    sub_806FCB3(v53, 17);\n    sub_8072C74(*v46, v46, (int)v45, (int)v56);\n  }\n  v48 = v45 + 5;\n  v45 += 5;\n  v32 = 1;\n  v33 = -1;\n  while ( 1 )\n  {\n    sub_80775EB(*v46, (int)v55, v32, v45);\n    if ( v55[0] == -1 )\n    {\n      sub_806F4BD();\n      v34 = 0;\n      v22 = 127;\n      goto LABEL_70;\n    }\n    if ( v55[0] != 2 )\n    {\n      if ( v22 )\n      {\n        v34 = 0;\nLABEL_70:\n        *(_BYTE *)dword_80DBB8C = v22;\n        if ( v33 == 1 )\n          sub_806F22F(1);\n        goto LABEL_94;\n      }\n      goto LABEL_72;\n    }\n    if ( v33 == -1 )\n    {\n      LOBYTE(v21) = **v56;\n      v33 = (unsigned __int8)v21 & 1;\n    }\n    if ( v56 == &off_80B5DE8 )\n    {\n      v34 = 1;\n      goto LABEL_105;\n    }\n    if ( v56 != &off_80B5DC8 )\n      goto LABEL_104;\n    v45 = v48;\n    v21 = v46;\nLABEL_56:\n    v35 = v21 + 1;\n    v36 = v21[1];\n    if ( !v36 )\n      goto LABEL_104;\n    if ( *v36 == 45 )\n    {\n      v37 = (char *)(v36 + 2);\n      v38 = v36[1];\n      if ( v38 )\n        break;\n    }\nLABEL_67:\n    v44 -= v35 - v46;\n    v32 = 5;\n    v46 = v35;\n  }\n  if ( v38 == 45 && !v36[2] )\n  {\n    v21 += 2;\n    if ( !v35[1] )\n      goto LABEL_104;\n    v35 = v21;\n    if ( !v21 )\n      goto LABEL_104;\n    goto LABEL_67;\n  }\n  while ( v38 == 112 )\n  {\n    v38 = *v37++;\n    v21 = v35;\n    v45 = \"/bin:/usr/bin\";\n    if ( !v38 )\n      goto LABEL_56;\n  }\nLABEL_104:\n  v34 = 0;\nLABEL_105:\n  if ( v22 )\n    goto LABEL_70;\nLABEL_81:\n  if ( v33 == 1 || !v44 )\n  {\n    sub_80773CC(1);\n    if ( v44 > 1 )\n    {\n      if ( v34 )\n        sub_806FCB3(v53, 1);\n    }\n  }\n  sub_8070DA4(0, 0);\n  if ( sub_8074D56((int)v56, (int)v46, a2) )\n  {\n    if ( *(_BYTE *)(dword_80DBB8C + 43) == 1 && v33 != 1 )\n    {\n      sub_806F48C();\n      goto LABEL_93;\n    }\nLABEL_90:\n    longjmp(*(struct __jmp_buf_tag **)(dword_80DBB8C + 32), 1);\n  }\nLABEL_93:\n  v22 = *(unsigned __int8 *)dword_80DBB8C;\nLABEL_94:\n  if ( !a1[4] )\n    goto LABEL_97;\n  for ( n = v34; ; n = 0 )\n  {\n    sub_806FF33(n, (char)v21);\nLABEL_97:\n    if ( v50 == *(_DWORD *)(dword_80DBB90 + 20) )\n      break;\n  }\n  while ( v49 != dword_80DB694 )\n    sub_80773CC(0);\n  if ( v47 )\n    sub_806FE06(\"_\", v47);\n  sub_806FA10(v57);\n  return v22;\n}\n"
    ],
    "sub_807839B": [
        "0x807839b",
        "void __cdecl __noreturn sub_807839B(int a1, _BYTE **a2)\n{\n  _DWORD *v2; // eax\n  _DWORD *v3; // eax\n  char *v4; // ebx\n  _DWORD *v5; // edx\n  int i; // eax\n  int *v7; // esi\n  char v8; // dl\n  _DWORD *v9; // eax\n  int v10; // ebx\n  const char *v11; // eax\n  int v12; // ebx\n  _BYTE *v13; // eax\n  _BOOL4 v14; // edx\n  int v15; // esi\n  int *v16; // edi\n  int v17; // ebp\n  int v18; // eax\n  char *v19; // eax\n  _DWORD *v20; // eax\n  char *v21; // eax\n  char *v22; // eax\n  char *v23; // eax\n  int v24; // ecx\n  char *v25; // ebx\n  _BOOL4 v26; // [esp+4h] [ebp-44h] BYREF\n  _DWORD v27[3]; // [esp+8h] [ebp-40h] BYREF\n  char v28[52]; // [esp+14h] [ebp-34h] BYREF\n\n  v2 = sub_804DB2E(0x1DCu);\n  dword_80DBB8C = (int)v2;\n  v2[5] = v2 + 11;\n  v2[6] = v2 + 11;\n  v2[113] = v2 + 48;\n  v3 = sub_804DB2E(0x20Cu);\n  dword_80DBB88 = (int)v3;\n  *v3 = v3 + 4;\n  v3[1] = v3 + 5;\n  v3[3] = 504;\n  v3[2] = v3 + 131;\n  v4 = (char *)sub_804DB2E(0x160u);\n  dword_80DBB90 = (int)v4;\n  v5 = &unk_80B5F60;\n  for ( i = 0; i != 144; i += 16 )\n  {\n    *(_DWORD *)&v4[i + 188] = *v5;\n    *(_DWORD *)&v4[i + 192] = v5[1];\n    *(_DWORD *)&v4[i + 196] = v5[2];\n    v5 += 3;\n  }\n  strcpy(v4 + 332, \"LINENO=\");\n  *((_DWORD *)v4 + 72) = v4 + 332;\n  dword_80DB6F0 = (int)sub_804DB2E(0x9Cu);\n  dword_80DB6B0 = (int)sub_804DB2E(0x7Cu);\n  dword_80DB6F8 = sub_80AED15();\n  v7 = (int *)_setjmp((struct __jmp_buf_tag *)v28);\n  if ( v7 )\n  {\n    byte_80DB76C = 0;\n    dword_80DB69C = 0;\n    sub_806F5DA();\n    v9 = off_80DB55C;\n    *((_DWORD *)off_80DB55C + 4) = 0;\n    v9[3] = 0;\n    while ( off_80DB55C != &unk_80DB5E0 )\n      sub_806F6F7();\n    while ( *(_DWORD *)(dword_80DBB90 + 20) )\n      sub_806FF33(0, v8);\n    while ( dword_80DB694 )\n      sub_80773CC(0);\n    goto LABEL_54;\n  }\n  v12 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 32) = v28;\n  *(_DWORD *)(v12 + 4) = getpid();\n  sub_8072F60();\n  sub_8070056(v27);\n  v13 = *a2;\n  v14 = 0;\n  if ( *a2 )\n    v14 = *v13 == 45;\n  v26 = v14;\n  *(_DWORD *)(v12 + 28) = v13;\n  do\n  {\n    *((_BYTE *)v7 + v12 + 45) = 2;\n    v7 = (int *)((char *)v7 + 1);\n  }\n  while ( v7 != (int *)15 );\n  dword_80DB708 = (int)(a2 + 1);\n  v15 = sub_80708D4(1, &v26);\n  if ( v15 )\n    sub_806F22F(1);\n  v16 = (int *)dword_80DB708;\n  v17 = *(_DWORD *)(v12 + 16);\n  if ( !*(_DWORD *)dword_80DB708 )\n  {\n    if ( v17 )\n      sub_806FB57(\"%s requires an argument\", \"-c\");\n    *(_BYTE *)(v12 + 51) = 1;\n  }\n  if ( (*(_DWORD *)(v12 + 48) & 0xFF0000FF) == 16777218 && isatty(0) && isatty(1) )\n    *(_BYTE *)(v12 + 48) = 1;\n  if ( *(_BYTE *)(v12 + 49) == 2 )\n    *(_BYTE *)(v12 + 49) = *(_BYTE *)(v12 + 48);\n  do\n  {\n    if ( *(_BYTE *)(v12 + v15 + 45) == 2 )\n      *(_BYTE *)(v12 + v15 + 45) = 0;\n    ++v15;\n  }\n  while ( v15 != 15 );\n  v18 = *v16;\n  if ( v17 )\n  {\n    v7 = v16 + 1;\n    *(_DWORD *)(v12 + 16) = v18;\n    if ( !v16[1] )\n    {\nLABEL_44:\n      v20 = (_DWORD *)dword_80DBB90;\n      *(_DWORD *)(dword_80DBB90 + 16) = v7;\n      v20[1] = 1;\n      v20[2] = -1;\n      while ( *v7 )\n      {\n        ++*v20;\n        ++v7;\n      }\n      sub_8070672((__pid_t)v7);\n      if ( v26 )\n      {\n        sub_8076BF3(\"/etc/profile\");\n        if ( sub_8072EED(\"HOME\") )\n          sub_8076BF3(\"$HOME/.profile\");\n      }\n      if ( *(_BYTE *)(dword_80DBB8C + 48) )\n      {\n        v21 = sub_8072EED(\"ENV\");\n        if ( v21 )\n        {\n          if ( *v21 )\n            sub_8076BF3(v21);\n        }\n      }\n      sub_806FA10(v27);\n      v10 = dword_80DBB8C;\n      v11 = *(const char **)(dword_80DBB8C + 16);\n      if ( v11 )\n        sub_8074C7C(v11, *(_BYTE *)(dword_80DBB8C + 51) == 0);\n      if ( *(_BYTE *)(v10 + 51) || !*(_DWORD *)(v10 + 16) )\n      {\n        if ( *(_BYTE *)(v10 + 48) )\n        {\n          v22 = sub_8072EED(\"HISTFILE\");\n          if ( v22\n            || (v23 = sub_8072EED(\"HOME\")) != 0\n            && (++*(_DWORD *)(v10 + 36),\n                v25 = (char *)sub_804D2D1((int)v23, \".ash_history\", v24),\n                sub_806FE06(\"HISTFILE\", v25),\n                free(v25),\n                sub_806F4A5(),\n                (v22 = sub_8072EED(\"HISTFILE\")) != 0) )\n          {\n            *(_DWORD *)(dword_80DB6F8 + 28) = v22;\n          }\n        }\n        sub_8076A14(1u);\n      }\nLABEL_54:\n      sub_80769A1((__pid_t)v7);\n    }\n  }\n  else\n  {\n    v7 = v16;\n    if ( *(_BYTE *)(v12 + 51) )\n      goto LABEL_44;\n    sub_807009B(v18, 0);\n  }\n  v19 = (char *)*v7;\n  *(_DWORD *)(v12 + 28) = *v7;\n  dword_80DB70C = v19;\n  ++v7;\n  goto LABEL_44;\n}\n"
    ],
    "sub_80787C0": [
        "0x80787c0",
        "const char *__usercall sub_80787C0@<eax>(int a1@<eax>, char a2@<dl>, _DWORD *a3@<ecx>, _DWORD *a4)\n{\n  _DWORD *v5; // ebp\n  _DWORD *v6; // ecx\n  unsigned __int64 v7; // rdi\n  bool v8; // zf\n  unsigned __int64 v9; // rax\n  char v10; // al\n  int v11; // eax\n  __int64 v12; // rax\n  bool v13; // al\n  unsigned __int8 v14; // al\n  char v15; // cl\n  char v16; // cl\n  int v17; // ecx\n  unsigned __int64 v18; // rax\n  int v19; // ecx\n  bool v20; // cl\n  _DWORD *v22; // [esp+0h] [ebp-44h]\n  __int64 v23; // [esp+0h] [ebp-44h]\n  int v24; // [esp+8h] [ebp-3Ch]\n  unsigned __int64 i; // [esp+Ch] [ebp-38h]\n  char s[42]; // [esp+1Ah] [ebp-2Ah] BYREF\n\n  if ( (_DWORD *)*a4 == a3 )\n    return \"arithmetic syntax error\";\n  v5 = (_DWORD *)(*a4 - 24);\n  v22 = (_DWORD *)*a4;\n  v24 = sub_8078F03();\n  v6 = v22;\n  if ( !v24 )\n  {\n    HIDWORD(v7) = *(v22 - 6);\n    LODWORD(v7) = *(v22 - 5);\n    switch ( a2 )\n    {\n      case 17:\n        HIDWORD(v7) = -HIDWORD(v7);\n        LODWORD(v7) = (unsigned __int64)-__SPAIR64__(v7, HIDWORD(v7)) >> 32;\nLABEL_99:\n        if ( (unsigned __int8)((a2 & 0xF) - 2) > 1u )\n        {\nLABEL_106:\n          *v5 = HIDWORD(v7);\n          v5[1] = v7;\n          v5[5] = 0;\n          return (const char *)v24;\n        }\n        if ( v5[5] )\n        {\n          sprintf(s, \"%lld\", __PAIR64__(v7, HIDWORD(v7)));\n          (*(void (**)(void))(a1 + 8))();\n          if ( a2 == 19 )\n          {\n            LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) - 1) >> 32;\n            --HIDWORD(v7);\n          }\n          else if ( a2 == 51 )\n          {\n            LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) + 1) >> 32;\n            ++HIDWORD(v7);\n          }\n          goto LABEL_106;\n        }\n        return \"arithmetic syntax error\";\n      case 48:\n        v8 = v7 == 0;\nLABEL_46:\n        v13 = v8;\n        goto LABEL_34;\n      case 16:\n        v9 = ~v7;\nLABEL_30:\n        v7 = v9;\n        goto LABEL_99;\n    }\n    if ( (unsigned __int8)(a2 - 18) <= 1u )\n    {\n      LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) + 1) >> 32;\n      ++HIDWORD(v7);\n      goto LABEL_99;\n    }\n    if ( (unsigned __int8)(a2 - 50) <= 1u )\n    {\n      LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) - 1) >> 32;\n      --HIDWORD(v7);\n      goto LABEL_99;\n    }\n    if ( a2 == 49 )\n      goto LABEL_99;\n    if ( a3 != v5 )\n    {\n      *a4 = v5;\n      v10 = *((_BYTE *)v22 - 8);\n      if ( a2 == 4 )\n      {\n        if ( !v10 )\n          return \"malformed ?: operator\";\n        v5 = v22 - 12;\n      }\n      else\n      {\n        if ( v10 )\n          return \"malformed ?: operator\";\n        v5 = v22 - 12;\n        if ( a2 == 2 )\n        {\nLABEL_21:\n          v23 = *((_QWORD *)v6 - 6);\n          switch ( a2 )\n          {\n            case 4:\n              if ( !v23 )\n              {\n                HIDWORD(v7) = *(v6 - 4);\n                LODWORD(v7) = *(v6 - 3);\n              }\n              goto LABEL_99;\n            case 36:\n              if ( a3 == v5 )\n                return \"malformed ?: operator\";\n              *((_BYTE *)v6 - 32) = 36;\n              *(v6 - 10) = HIDWORD(v7);\n              *(v6 - 9) = v7;\nLABEL_98:\n              v7 = __PAIR64__(v23, HIDWORD(v23));\n              goto LABEL_99;\n            case 66:\n            case 7:\n              HIDWORD(v9) = HIDWORD(v7) | v23;\n              LODWORD(v9) = v7 | HIDWORD(v23);\n              goto LABEL_30;\n            case 5:\n              HIDWORD(v12) = HIDWORD(v7) | v23;\n              LODWORD(v12) = v7 | HIDWORD(v23);\nLABEL_33:\n              v13 = v12 != 0;\nLABEL_34:\n              HIDWORD(v7) = v13;\nLABEL_35:\n              LODWORD(v7) = 0;\n              goto LABEL_99;\n            case 9:\n            case 34:\n              HIDWORD(v9) = HIDWORD(v7) & v23;\n              LODWORD(v9) = v7 & HIDWORD(v23);\n              goto LABEL_30;\n            case 8:\n            case 98:\n              HIDWORD(v9) = HIDWORD(v7) ^ v23;\n              LODWORD(v9) = v7 ^ HIDWORD(v23);\n              goto LABEL_30;\n            case 6:\n              HIDWORD(v7) = v23 != 0 && v7 != 0;\n              goto LABEL_35;\n            case 10:\n              v8 = v7 == __PAIR64__(v23, HIDWORD(v23));\n              goto LABEL_46;\n            case 42:\n              HIDWORD(v12) = HIDWORD(v7) ^ v23;\n              LODWORD(v12) = v7 ^ HIDWORD(v23);\n              goto LABEL_33;\n            case 75:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) > v23 )\nLABEL_70:\n                v14 = 0;\n              break;\n            case -30:\n            case 44:\n              v15 = BYTE4(v7);\n              HIDWORD(v7) = (unsigned __int64)v23 >> SBYTE4(v7);\n              LODWORD(v7) = SHIDWORD(v23) >> v15;\n              if ( (v15 & 0x20) != 0 )\n              {\n                HIDWORD(v7) = SHIDWORD(v23) >> v15;\n                LODWORD(v7) = (int)v7 >> 31;\n              }\n              goto LABEL_99;\n            case -62:\n            case 12:\n              v16 = BYTE4(v7);\n              LODWORD(v7) = (unsigned __int64)(v23 << SBYTE4(v7)) >> 32;\n              HIDWORD(v7) = (_DWORD)v23 << SBYTE4(v7);\n              if ( (v16 & 0x20) != 0 )\n                v7 = HIDWORD(v7);\n              goto LABEL_99;\n            case 43:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) >= v23 )\n                goto LABEL_70;\n              break;\n            case 11:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) <= v23 )\n                goto LABEL_70;\n              break;\n            case 107:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) < v23 )\n                goto LABEL_70;\n              break;\n            default:\n              switch ( a2 )\n              {\n                case 3:\n                case 14:\n                  v17 = HIDWORD(v7) * HIDWORD(v23) + v7 * v23;\n                  LODWORD(v7) = (HIDWORD(v7) * (unsigned __int64)(unsigned int)v23) >> 32;\n                  HIDWORD(v7) *= (_DWORD)v23;\n                  LODWORD(v7) = v17 + v7;\n                  goto LABEL_99;\n                case 13:\n                case -126:\n                  LODWORD(v7) = (v23 + __PAIR64__(v7, HIDWORD(v7))) >> 32;\n                  HIDWORD(v7) += v23;\n                  goto LABEL_99;\n                case -94:\n                case 45:\n                  v18 = v23 - __PAIR64__(v7, HIDWORD(v7));\n                  break;\n                default:\n                  if ( (unsigned __int8)(a2 - 1) <= 1u )\n                    goto LABEL_99;\n                  if ( a2 == 47 )\n                  {\n                    if ( (v7 & 0x80000000) != 0LL )\n                      return \"exponent less than 0\";\n                    for ( i = 1LL; ; HIDWORD(i) += v19 )\n                    {\n                      LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) - 1) >> 32;\n                      --HIDWORD(v7);\n                      if ( __PAIR64__(v7, HIDWORD(v7)) == -1LL )\n                        break;\n                      v19 = i * HIDWORD(v23) + HIDWORD(i) * v23;\n                      i = (unsigned int)v23 * (unsigned __int64)(unsigned int)i;\n                    }\n                    v7 = __PAIR64__(i, HIDWORD(i));\n                    goto LABEL_99;\n                  }\n                  if ( !v7 )\n                    return \"divide by zero\";\n                  v20 = a2 == 46 || a2 == 35;\n                  if ( a2 != 78 && a2 != 67 && !v20 )\n                    goto LABEL_98;\n                  if ( v7 == -1LL && !(2 * v23) )\n                    v7 = 0x100000000LL;\n                  if ( v20 )\n                    LODWORD(v18) = sub_80B492D(v23, HIDWORD(v23), HIDWORD(v7), v7);\n                  else\n                    LODWORD(v18) = sub_80B4A4A(v23, HIDWORD(v23), HIDWORD(v7), v7);\n                  break;\n              }\n              v7 = __PAIR64__(v18, HIDWORD(v18));\n              goto LABEL_99;\n          }\n          HIDWORD(v7) = v14;\n          goto LABEL_35;\n        }\n      }\n      v11 = sub_8078F03();\n      v6 = v22;\n      if ( v11 )\n        return (const char *)v11;\n      goto LABEL_21;\n    }\n    return \"arithmetic syntax error\";\n  }\n  return (const char *)v24;\n}\n"
    ],
    "sub_8078C52": [
        "0x8078c52",
        "__int64 __usercall sub_8078C52@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  unsigned __int64 v3; // rax\n  __int64 *v4; // ecx\n  void *v5; // esp\n  void *v6; // esp\n  __int64 *v7; // edi\n  char *v8; // ebx\n  void *v9; // esp\n  int v10; // eax\n  _DWORD *v11; // ebx\n  char v12; // al\n  const char *v13; // ecx\n  char v14; // bl\n  char *v15; // ebx\n  const char *i; // eax\n  unsigned __int8 v17; // al\n  __int64 *v19; // [esp-4h] [ebp-2Ch]\n  int v20; // [esp-4h] [ebp-2Ch]\n  __int64 *v21; // [esp+0h] [ebp-28h]\n  __int64 v22; // [esp+4h] [ebp-24h] BYREF\n  unsigned __int8 v23; // [esp+Fh] [ebp-19h] BYREF\n  int v24; // [esp+10h] [ebp-18h]\n  char *nptr; // [esp+14h] [ebp-14h] BYREF\n  __int64 *v26; // [esp+18h] [ebp-10h] BYREF\n  int v27; // [esp+1Ch] [ebp-Ch] BYREF\n\n  LODWORD(v22) = a1;\n  HIDWORD(v22) = sub_80B2E8C(a3, a2);\n  nptr = (char *)HIDWORD(v22);\n  v3 = __PAIR64__(&v23, strlen((const char *)HIDWORD(v22)));\n  v4 = v19;\n  v5 = alloca(24 * ((unsigned int)(v3 + 2) >> 1) + 16);\n  v26 = &v22;\n  v6 = alloca(v3 + 17);\n  v21 = &v22;\n  v7 = (__int64 *)((char *)&v22 + 1);\n  LOBYTE(v22) = 0;\n  LOBYTE(v24) = 0;\nLABEL_2:\n  while ( 2 )\n  {\n    while ( 2 )\n    {\n      while ( 2 )\n      {\n        LODWORD(v3) = sub_80B2E8C(v4, HIDWORD(v3));\n        nptr = (char *)v3;\n        LOBYTE(v4) = *(_BYTE *)v3;\n        if ( !*(_BYTE *)v3 )\n        {\n          if ( HIDWORD(v22) == (_DWORD)v3 )\n          {\n            v22 = 0LL;\n            LODWORD(v3) = 0;\n          }\n          else\n          {\n            if ( (_UNKNOWN *)v3 != &unk_80D1094 )\n            {\n              nptr = (char *)&unk_80D1093;\n              continue;\n            }\n            if ( v26 != (__int64 *)&v27 )\n              goto LABEL_64;\n            LODWORD(v3) = 0;\n            if ( v26 )\n              LODWORD(v3) = sub_8078F03();\n          }\n          goto LABEL_68;\n        }\n        break;\n      }\n      v23 = *(_BYTE *)v3;\n      LODWORD(v3) = sub_80AB128(v4, HIDWORD(v3));\n      v8 = (char *)v3;\n      HIDWORD(v3) = nptr;\n      if ( nptr != (char *)v3 )\n      {\n        LODWORD(v3) = v3 - (_DWORD)nptr;\n        v24 = v3 + 1;\n        v9 = alloca(v3 + 16);\n        *((_DWORD *)v26 + 5) = &v22;\n        sub_80B2C4E(v24, HIDWORD(v3));\n        nptr = v8;\nLABEL_12:\n        v10 = (int)v26;\n        *((_BYTE *)v26 + 16) = 0;\n        v26 = (__int64 *)(v10 + 24);\n        LOBYTE(v24) = 20;\n        continue;\n      }\n      break;\n    }\n    if ( (unsigned __int8)(v23 - 48) <= 9u )\n    {\n      *((_DWORD *)v26 + 5) = 0;\n      v11 = (_DWORD *)dword_80DBB7C;\n      *(_DWORD *)dword_80DBB7C = 0;\n      v3 = strtoull((const char *)HIDWORD(v3), &nptr, 0);\n      v4 = v26;\n      *v26 = v3;\n      if ( *v11 )\n      {\n        *(_DWORD *)v4 = 0;\n        *((_DWORD *)v4 + 1) = 0;\n      }\n      goto LABEL_12;\n    }\n    if ( (_BYTE)v24 != 20 || *((_DWORD *)v26 - 1) )\n    {\n      v13 = \"<<=\";\n    }\n    else\n    {\n      v12 = *nptr;\n      v13 = \"<<=\";\n      if ( ((*nptr - 43) & 0xFD) == 0 && v12 == nptr[1] )\n      {\n        v14 = v12 != 43 ? 45 : 13;\n        HIDWORD(v3) = ++nptr;\n        goto LABEL_32;\n      }\n    }\nLABEL_22:\n    v15 = nptr;\n    for ( i = v13; *i; ++i )\n    {\n      if ( *i != *v15 )\n      {\n        while ( *i )\n          ++i;\n        v13 = i + 2;\n        if ( !i[2] )\n          goto LABEL_64;\n        goto LABEL_22;\n      }\n      ++v15;\n    }\n    nptr = v15;\n    v14 = i[1];\n    if ( (_BYTE)v24 == 19 )\n      goto LABEL_43;\nLABEL_32:\n    if ( (_BYTE)v24 == 51 || (_BYTE)v24 == 20 )\n    {\nLABEL_43:\n      LOBYTE(v24) = 20;\n      goto LABEL_44;\n    }\n    if ( v14 == 19 )\n    {\n      v14 = 18;\n    }\n    else if ( (unsigned __int8)v14 > 0x13u )\n    {\n      if ( v14 == 45 )\n      {\n        v14 = 17;\n      }\n      else if ( v14 == 51 )\n      {\n        v14 = 50;\n      }\n    }\n    else if ( v14 == 13 )\n    {\n      v14 = 49;\n    }\nLABEL_44:\n    v23 = v14 & 0x1F;\n    if ( (unsigned __int8)((v14 & 0x1F) - 1) > 0xEu && v23 != 20 )\n    {\n      v4 = v7;\n      goto LABEL_63;\n    }\n    if ( (_BYTE)v24 != 20 )\n      break;\n    while ( 1 )\n    {\n      v4 = v7;\n      if ( v7 == v21 )\n        break;\n      v7 = (__int64 *)((char *)v7 - 1);\n      HIDWORD(v3) = *(unsigned __int8 *)v7;\n      if ( v14 == 52 )\n      {\n        if ( !BYTE4(v3) )\n          goto LABEL_2;\n        goto LABEL_58;\n      }\n      v17 = BYTE4(v3) & 0x1F;\n      if ( v23 != 3 )\n      {\n        if ( v17 == 3 )\n          v17 = 2;\nLABEL_54:\n        if ( v17 < v23 )\n          goto LABEL_63;\n        if ( v17 != v23 )\n          goto LABEL_58;\n        goto LABEL_56;\n      }\n      v23 = 2;\n      if ( v17 != 3 )\n        goto LABEL_54;\nLABEL_56:\n      if ( ((v23 - 2) & 0xFD) == 0 || v23 == 15 )\n        goto LABEL_63;\nLABEL_58:\n      LODWORD(v3) = sub_80787C0(v22, SBYTE4(v3), &v22, &v26);\n      HIDWORD(v3) = v20;\n      if ( (_DWORD)v3 )\n        goto LABEL_65;\n    }\n    if ( v14 != 52 )\n    {\nLABEL_63:\n      v7 = (__int64 *)((char *)v4 + 1);\n      *(_BYTE *)v4 = v14;\n      LOBYTE(v24) = v14;\n      continue;\n    }\n    break;\n  }\nLABEL_64:\n  LODWORD(v3) = \"arithmetic syntax error\";\nLABEL_65:\n  v22 = -1LL;\nLABEL_68:\n  *(_DWORD *)v22 = v3;\n  return v22;\n}\n"
    ],
    "sub_8078F03": [
        "0x8078f03",
        "const char *__usercall sub_8078F03@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v5; // ebp\n  const char *v6; // ecx\n  int i; // edx\n  int v8; // eax\n  int *v10; // [esp+0h] [ebp-20h]\n  const char *v11; // [esp+4h] [ebp-1Ch]\n  int v12[6]; // [esp+8h] [ebp-18h] BYREF\n\n  v2 = 0;\n  if ( *(_DWORD *)(a2 + 20) )\n  {\n    v2 = (*(int (**)(void))(a1 + 4))();\n    if ( v2 )\n    {\n      v5 = *(_DWORD *)(a1 + 12);\n      v6 = *(const char **)(a2 + 20);\n      for ( i = v5; ; i = *v10 )\n      {\n        if ( !i )\n        {\n          v12[1] = (int)v6;\n          v12[0] = v5;\n          *(_DWORD *)(a1 + 12) = v12;\n          *(_QWORD *)a2 = sub_8078C52(a1, v2, (int)v6);\n          *(_DWORD *)(a1 + 12) = v5;\n          return *(const char **)a1;\n        }\n        v11 = v6;\n        v10 = (int *)i;\n        v8 = strcmp(*(const char **)(i + 4), v6);\n        v6 = v11;\n        if ( !v8 )\n          break;\n      }\n      return \"expression recursion loop detected\";\n    }\n    else\n    {\n      *(_DWORD *)a2 = 0;\n      *(_DWORD *)(a2 + 4) = 0;\n    }\n  }\n  return (const char *)v2;\n}\n"
    ],
    "sub_8078F92": [
        "0x8078f92",
        "__int64 __usercall sub_8078F92@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  *(_DWORD *)a1 = 0;\n  *(_DWORD *)(a1 + 12) = 0;\n  return sub_8078C52(a1, a2, a3);\n}\n"
    ],
    "sub_8078FAA": [
        "0x8078faa",
        "int __usercall sub_8078FAA@<eax>(__pid_t *a1@<eax>)\n{\n  __pid_t v2; // eax\n  __pid_t v3; // eax\n  int v4; // edi\n  int v5; // esi\n  unsigned int v6; // edx\n  unsigned int i; // ecx\n  unsigned int v8; // edx\n  int v9; // ebp\n  int v10; // eax\n\n  if ( !*a1 )\n  {\n    v2 = getpid();\n    a1[2] = v2;\n    *a1 = v2;\n    v3 = sub_804EBDE();\n    a1[3] = v3;\n    a1[1] = v3;\n  }\n  v4 = 1664525 * a1[1] + 1013904223;\n  a1[1] = v4;\n  v5 = 2 * *a1;\n  if ( *a1 < 0 )\n    v5 ^= 0x8000000B;\n  *a1 = v5;\n  v6 = a1[2];\n  for ( i = a1[3]; ; i = v10 )\n  {\n    v8 = (4 * v6) ^ v6;\n    v9 = v8 ^ i ^ (i >> 3);\n    v8 >>= 7;\n    v10 = v8 ^ v9;\n    if ( v9 != v8 )\n    {\n      a1[2] = i;\n      a1[3] = v10;\n      return ((_WORD)v5 - (_WORD)v4 + (_WORD)v10) & 0x7FFF;\n    }\n    v6 = i;\n    if ( i > 2 )\n      break;\n  }\n  a1[2] = i;\n  a1[3] = v10;\n  LOWORD(v10) = 0;\n  return ((_WORD)v5 - (_WORD)v4 + (_WORD)v10) & 0x7FFF;\n}\n"
    ],
    "sub_8079037": [
        "0x8079037",
        "int __usercall sub_8079037@<eax>(char a1@<al>, unsigned int *a2@<edx>, char *a3@<ecx>)\n{\n  unsigned int v3; // esi\n  unsigned int v4; // edi\n  char v6; // cl\n  unsigned int v7; // esi\n  unsigned int v8; // edi\n  int v9; // [esp-4h] [ebp-Ch]\n\n  v3 = a2[2];\n  v4 = a2[3];\n  if ( (a1 & 1) == 0 )\n  {\n    v3 = *a2;\n    v4 = a2[1];\n  }\n  if ( v4 == -1 && v3 == -1 )\n  {\n    puts(\"unlimited\");\n    return v9;\n  }\n  else\n  {\n    v6 = *a3;\n    v7 = __PAIR64__(v4, v3) >> v6;\n    v8 = v4 >> v6;\n    if ( (v6 & 0x20) != 0 )\n    {\n      v7 = v8;\n      v8 = 0;\n    }\n    return printf(\"%llu\\n\", __PAIR64__(v8, v7));\n  }\n}\n"
    ],
    "sub_8079086": [
        "0x8079086",
        "_BOOL4 __usercall sub_8079086@<eax>(_BYTE *a1@<eax>, char a2@<dl>)\n{\n  _BYTE *v2; // ecx\n  char v3; // bl\n  _BOOL4 result; // eax\n  char v5; // al\n\n  if ( !a1 )\n    return 0;\n  v2 = a1;\n  v3 = *a1;\n  if ( (unsigned __int8)((*a1 | 0x20) - 97) <= 0x19u || (result = 0, v3 == 95) )\n  {\n    do\n    {\n      do\n        v5 = *++v2;\n      while ( (unsigned __int8)(*v2 - 48) <= 9u );\n    }\n    while ( (unsigned __int8)((*v2 | 0x20) - 97) <= 0x19u || v5 == 95 );\n    return v5 == a2;\n  }\n  return result;\n}\n"
    ],
    "sub_80790CD": [
        "0x80790cd",
        "int __userpurge sub_80790CD@<eax>(\n        void (*a1)(void)@<eax>,\n        _DWORD *a2@<edx>,\n        const char *a3@<ecx>,\n        char a4,\n        const char *a5,\n        int a6,\n        const char *a7,\n        const char *a8,\n        char *a9)\n{\n  char **i; // ebp\n  char *v10; // ebx\n  int v11; // edi\n  unsigned int v12; // ebp\n  int v13; // ecx\n  unsigned __int8 v14; // al\n  int v15; // edi\n  size_t v16; // esi\n  int v17; // eax\n  int v18; // ebp\n  int v19; // ecx\n  char *v20; // eax\n  bool v21; // al\n  int v22; // ecx\n  int v23; // eax\n  char *v24; // eax\n  char *v25; // eax\n  int v26; // eax\n  size_t v27; // eax\n  const char *j; // edx\n  int v30; // [esp-4h] [ebp-B0h]\n  int v31; // [esp-4h] [ebp-B0h]\n  int v32; // [esp-4h] [ebp-B0h]\n  int v33; // [esp-4h] [ebp-B0h]\n  _DWORD *v34; // [esp+0h] [ebp-ACh]\n  int v36; // [esp+8h] [ebp-A4h]\n  char v37; // [esp+Ch] [ebp-A0h]\n  char v39; // [esp+1Ah] [ebp-92h]\n  char v40; // [esp+1Bh] [ebp-91h]\n  struct pollfd fds; // [esp+1Ch] [ebp-90h] BYREF\n  struct termios termios_p; // [esp+24h] [ebp-88h] BYREF\n  struct termios v43; // [esp+60h] [ebp-4Ch] BYREF\n\n  v34 = a2;\n  *(_DWORD *)dword_80DBB7C = 0;\n  for ( i = (char **)a2; ; ++i )\n  {\n    v10 = *i;\n    if ( !*i )\n      break;\n    if ( !sub_8079086(*i, 0) )\n    {\n      sub_804D5F4(\"read: '%s': not a valid identifier\", v10);\n      return 1;\n    }\n  }\n  if ( a5 )\n  {\n    v36 = sub_804ED6C(10, a5, 0, 0);\n    v11 = (int)\"invalid count\";\n    if ( v36 < 0 || *(_DWORD *)dword_80DBB7C )\n      return v11;\n  }\n  else\n  {\n    v36 = 0;\n  }\n  if ( a7 )\n  {\n    v12 = sub_804ED6C(10, a7, (char **)&v43, 0);\n    if ( v12 > 0x1FFFFF )\n      v12 = 0x1FFFFF;\n    if ( *(_DWORD *)dword_80DBB7C )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 22 )\n        return (int)&unk_80D10BC;\n      v13 = 4;\n      if ( *(_BYTE *)v43.c_iflag != 46 )\n        return (int)&unk_80D10BC;\n      while ( 1 )\n      {\n        v14 = *(_BYTE *)++v43.c_iflag;\n        if ( !*(_BYTE *)v43.c_iflag )\n          break;\n        if ( v13 == 1 )\n          goto LABEL_26;\n        v12 = 10 * v12 + v14 - 48;\n        --v13;\n        if ( (unsigned __int8)(v14 - 48) > 9u )\n          return (int)&unk_80D10BC;\n      }\n    }\n    else\n    {\n      v13 = 4;\n    }\n    while ( --v13 > 0 )\n      v12 *= 10;\n  }\n  else\n  {\n    v12 = 0;\n  }\nLABEL_26:\n  fds.fd = 0;\n  if ( a8 )\n  {\n    fds.fd = sub_804ED6C(10, a8, 0, 0);\n    v11 = (int)\"invalid file descriptor\";\n    if ( fds.fd < 0 || *(_DWORD *)dword_80DBB7C )\n      return v11;\n  }\n  if ( a7 && !v12 )\n  {\n    fds.events = 1;\n    return poll(&fds, 1u, 0) <= 0;\n  }\n  if ( a6 && isatty(fds.fd) )\n  {\n    fputs_unlocked();\n    sub_804DD8F();\n  }\n  if ( !a3 )\n    a3 = \" \\t\\n\";\n  if ( v36 || (a4 & 1) != 0 )\n  {\n    tcgetattr(fds.fd, &termios_p);\n    qmemcpy(&v43, &termios_p, sizeof(v43));\n    if ( v36 )\n    {\n      termios_p.c_lflag &= ~2u;\n      *(_WORD *)&termios_p.c_cc[5] = 256;\n    }\n    if ( (a4 & 1) != 0 )\n      termios_p.c_lflag &= 0xFFFFFF97;\n    a4 |= 1u;\n    tcsetattr(fds.fd, 0, &termios_p);\n  }\n  if ( a7 )\n    v12 += sub_804EC14();\n  v39 = 10;\n  if ( a9 )\n    v39 = *a9;\n  v37 = 0;\n  v15 = 1;\n  v16 = 0;\n  do\n  {\n    if ( !(_BYTE)v16 )\n      v10 = (char *)sub_804DB13(v10, v16 + 257);\n    if ( a7 )\n    {\n      v17 = v12 - sub_804EC14();\n      if ( v17 <= 0 )\n      {\n        v11 = 1;\n        v18 = 0;\n        goto LABEL_107;\n      }\n    }\n    else\n    {\n      v17 = -1;\n    }\n    *(_DWORD *)dword_80DBB7C = 0;\n    fds.events = 1;\n    if ( poll(&fds, 1u, v17) <= 0 )\n    {\n      v18 = *(_DWORD *)dword_80DBB7C;\n      v11 = 1;\n      goto LABEL_107;\n    }\n    if ( read(fds.fd, &v10[v16], 1u) != 1 )\n    {\n      v18 = *(_DWORD *)dword_80DBB7C;\n      v11 = 1;\n      goto LABEL_87;\n    }\n    LOBYTE(v19) = v10[v16];\n    if ( !(_BYTE)v19 )\n      goto LABEL_85;\n    if ( (a4 & 2) == 0 )\n    {\n      if ( v37 )\n      {\n        v37 = 0;\n        if ( (_BYTE)v19 != 10 )\n          goto LABEL_80;\n        goto LABEL_85;\n      }\n      if ( (_BYTE)v19 == 92 )\n      {\n        v37 = 1;\n        goto LABEL_85;\n      }\n    }\n    if ( v39 == (_BYTE)v19 )\n      break;\n    if ( a9 || !*v34 )\n      goto LABEL_80;\n    v40 = v10[v16];\n    v20 = strchr(a3, (unsigned __int8)v19);\n    v19 = v30;\n    v21 = v20 != 0;\n    LOBYTE(v19) = v40;\n    if ( v15 && v21 )\n    {\n      if ( (unsigned __int8)(v40 - 9) <= 4u || v40 == 32 )\n        goto LABEL_85;\n      if ( v15 == 2 )\n      {\n        v15 = 1;\n        goto LABEL_85;\n      }\n    }\n    if ( !v34[1] || !v21 )\n    {\n      v15 = 0;\nLABEL_80:\n      ++v16;\n      goto LABEL_85;\n    }\n    v10[v16] = 0;\n    ((void (__fastcall *)(int, char *))a1)(v19, v10);\n    ++v34;\n    LOBYTE(v22) = v40;\n    v19 = v22 - 9;\n    if ( (_BYTE)v19 == 23 || (v15 = 1, (unsigned __int8)v19 <= 4u) )\n      v15 = 2;\n    v16 = 0;\nLABEL_85:\n    --v36;\n  }\n  while ( v36 );\n  v11 = 0;\n  v18 = 0;\nLABEL_87:\n  if ( *v34 )\n  {\n    do\n    {\n      if ( --v16 == -1 )\n        break;\n      v23 = (unsigned __int8)v10[v16];\n      if ( (unsigned __int8)(v23 - 9) > 4u && (_BYTE)v23 != 32 )\n        break;\n      v24 = strchr(a3, v23);\n      v19 = v31;\n    }\n    while ( v24 );\n    v10[v16 + 1] = 0;\n    if ( v16 != -1 )\n    {\n      v25 = strchr(a3, (unsigned __int8)v10[v16]);\n      v19 = v32;\n      if ( v25 )\n      {\n        while ( v16 )\n        {\n          v26 = (unsigned __int8)v10[v16 - 1];\n          if ( (_BYTE)v26 != 32 && (unsigned __int8)(v26 - 9) > 4u || !strchr(a3, v26) )\n            goto LABEL_100;\n          --v16;\n        }\n        v16 = 0;\nLABEL_100:\n        v27 = strcspn(v10, a3);\n        v19 = v33;\n        if ( v27 >= v16 )\n          v10[v16] = 0;\n      }\n    }\n    for ( j = v10; ; j = &data )\n    {\n      ((void (__fastcall *)(int, const char *))a1)(v19, j);\n      if ( !*++v34 )\n        break;\n    }\n  }\n  else\n  {\n    v10[v16] = 0;\n    a1();\n  }\nLABEL_107:\n  free(v10);\n  if ( (a4 & 1) != 0 )\n    tcsetattr(fds.fd, 0, &v43);\n  *(_DWORD *)dword_80DBB7C = v18;\n  return v11;\n}\n"
    ],
    "sub_80795F7": [
        "0x80795f7",
        "int __usercall sub_80795F7@<eax>(char **a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // eax\n  int i; // esi\n  char *v5; // esi\n  char *v6; // edi\n  __int64 v8; // rax\n  __int64 v9; // rax\n  int argc; // [esp+0h] [ebp-24h]\n  _QWORD v11[4]; // [esp+4h] [ebp-20h] BYREF\n\n  optind = 0;\n  argc = sub_804CD3D(a1);\n  v2 = 0;\n  do\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            v3 = getopt(argc, a1, \"-HSaf::t::d::s::c::m::l::p::n::v::w::e::r::\");\n            if ( v3 == -1 )\n              return 0;\n            if ( v3 != 72 )\n              break;\n            v2 |= 1u;\n          }\n          if ( v3 != 83 )\n            break;\n          v2 |= 2u;\n        }\n        if ( v3 != 97 )\n          break;\n        for ( i = 0; i != 104; i += 8 )\n        {\n          getrlimit64();\n          printf(\"-%c: %-30s \", (unsigned __int8)byte_80B6022[i], *(const char **)((char *)&off_80B6024 + i));\n          sub_8079037(v2, (unsigned int *)v11, (char *)&unk_80B6021 + i);\n        }\n      }\n      if ( v3 == 1 )\n        v3 = 102;\n      v5 = &byte_80B6020;\n      while ( (unsigned __int8)v5[2] != v3 )\n      {\n        v5 += 8;\n        if ( v5 == (char *)&unk_80B6088 )\n          return 0;\n      }\n      getrlimit64();\n      v6 = optarg;\n      if ( optarg )\n        break;\n      v6 = a1[optind];\n      if ( v6 && *v6 != 45 )\n      {\n        ++optind;\n        break;\n      }\n      sub_8079037(v2, (unsigned int *)v11, v5 + 1);\n    }\n    if ( !strcmp(v6, \"unlimited\") )\n    {\n      v9 = -1LL;\n    }\n    else\n    {\n      v8 = sub_804EC9E(v6, 0, 10);\n      if ( *(_DWORD *)dword_80DBB7C )\n      {\n        sub_804D5F4(\"invalid number '%s'\", v6);\n        return 1;\n      }\n      v9 = v8 << v5[1];\n    }\n    if ( !v2 )\n      v2 = 3;\n    if ( (v2 & 1) != 0 )\n      v11[1] = v9;\n    if ( (v2 & 2) != 0 )\n      v11[0] = v9;\n  }\n  while ( setrlimit64() >= 0 );\n  sub_804D3A5((int)\"error setting limit\");\n  return 1;\n}\n"
    ],
    "sub_80797A7": [
        "0x80797a7",
        "int __cdecl sub_80797A7(int a1, int a2)\n{\n  char v2; // si\n  int v3; // ebx\n  int v4; // ebx\n  int v5; // eax\n  _BYTE *v6; // eax\n  int v7; // ecx\n  _BYTE *v8; // esi\n  char *v9; // edi\n  char *v10; // edx\n  int v11; // eax\n  int v13; // [esp+0h] [ebp-14h] BYREF\n  char *endptr; // [esp+4h] [ebp-10h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"c:n\", &v13);\n  v3 = v2 & 1;\n  if ( (v2 & 1) != 0 )\n    v3 = sub_80B40CC(8, 1);\n  if ( (v2 & 2) == 0 )\n    sub_80B3C0D();\n  byte_80DB561 = 2;\n  klogctl(1, 0, 0);\n  openlog(\"kernel\", 0, 0);\n  if ( v3 )\n    klogctl(8, 0, v3);\n  signal(1, (__sighandler_t)1);\n  sub_804E6F4(117503054, (int)sub_804E68E);\n  syslog(5, \"klogd started: %s\", \"BusyBox v1.29.2 (2024-11-01 02:03:16 UTC)\");\n  v4 = 0;\nLABEL_8:\n  while ( !byte_80DBBA4 )\n  {\n    endptr = (char *)&qword_80DB778 + v4;\n    v5 = klogctl(2, (char *)&qword_80DB778 + v4, 1023 - v4);\n    if ( v5 >= 0 )\n    {\n      endptr[v5] = 0;\n      for ( endptr = (char *)&qword_80DB778; ; endptr = v9 )\n      {\n        v6 = (_BYTE *)strchrnul();\n        v8 = v6;\n        if ( *v6 )\n        {\n          v9 = v6 + 1;\n          *v6 = 0;\n        }\n        else\n        {\n          sub_80B2C69(v7);\n          v4 = v8 - endptr;\n          if ( v8 - endptr <= 1022 )\n            goto LABEL_8;\n          v9 = 0;\n          v4 = 0;\n        }\n        v10 = endptr;\n        v11 = 6;\n        if ( *endptr == 60 )\n        {\n          ++endptr;\n          if ( v10[1] )\n            v11 = strtoul(v10 + 1, &endptr, 10);\n          if ( *endptr == 62 )\n            ++endptr;\n        }\n        if ( *endptr )\n          syslog(v11, \"%s\", endptr);\n        if ( !v9 )\n          break;\n      }\n    }\n    else if ( *(_DWORD *)dword_80DBB7C != 4 )\n    {\n      sub_804D3A5((int)\"klogctl(2) error\");\n      break;\n    }\n  }\n  klogctl(7, 0, 0);\n  klogctl(0, 0, 0);\n  syslog(5, \"klogd: exiting\");\n  if ( byte_80DBBA4 )\n    sub_804E761(byte_80DBBA4);\n  return 1;\n}\n"
    ],
    "sub_8079987": [
        "0x8079987",
        "int sub_8079987()\n{\n  char *v0; // eax\n  char *v1; // esi\n  int v2; // ebx\n  struct sockaddr addr[7]; // [esp+2h] [ebp-7Ah] BYREF\n\n  memset(addr[0].sa_data, 0, 0x6Cu);\n  addr[0].sa_family = 1;\n  strcpy(addr[0].sa_data, \"/dev/log\");\n  v0 = sub_804E1D0(\"/dev/log\");\n  if ( v0 )\n  {\n    v1 = v0;\n    sub_80B2C4E(108, v0);\n    free(v1);\n  }\n  unlink(addr[0].sa_data);\n  v2 = sub_804DF99(0, 2, 1);\n  sub_804DFB3(0x6Eu, addr, v2);\n  chmod(\"/dev/log\", 0x1B6u);\n  return v2;\n}\n"
    ],
    "sub_8079A14": [
        "0x8079a14",
        "int __usercall sub_8079A14@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  if ( (unsigned __int8)(*a1 - 48) <= 9u )\n    return atoi(a1);\n  while ( *(_DWORD *)a2 )\n  {\n    if ( !strcasecmp(a1, *(const char **)a2) )\n      return *(_DWORD *)(a2 + 4);\n    a2 += 8;\n  }\n  return -1;\n}\n"
    ],
    "sub_8079A4F": [
        "0x8079a4f",
        "int __usercall sub_8079A4F@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  const char *v3; // esi\n  char *v4; // edi\n  const char **v5; // ebx\n  char **i; // eax\n  const char *v7; // ecx\n  char **j; // eax\n  int result; // eax\n  time_t v10; // esi\n  int v11; // eax\n  int v12; // ebx\n  int v13; // eax\n  bool v14; // dl\n  const char *v15; // eax\n  const char *v16; // edi\n  const char *v17; // eax\n  int v18; // eax\n  void *v19; // esp\n  void *v20; // esp\n  const char *v21; // edi\n  int v22; // [esp-4h] [ebp-84h]\n  int *v23; // [esp+0h] [ebp-80h] BYREF\n  char *old; // [esp+4h] [ebp-7Ch]\n  int n; // [esp+8h] [ebp-78h]\n  char *s; // [esp+Ch] [ebp-74h]\n  time_t timer; // [esp+10h] [ebp-70h] BYREF\n  char v28[16]; // [esp+14h] [ebp-6Ch] BYREF\n  int v29; // [esp+24h] [ebp-5Ch]\n  const char *v30; // [esp+40h] [ebp-40h]\n\n  n = a1;\n  v3 = a2;\n  if ( a3 > 15 && a2[3] == 32 && a2[6] == 32 && a2[9] == 58 && a2[12] == 58 && a2[15] == 32 )\n  {\n    timer = 0;\n    v4 = a2;\n    v3 = a2 + 16;\n  }\n  else\n  {\n    time(&timer);\n    v4 = ctime(&timer) + 4;\n  }\n  v4[15] = 0;\n  v5 = (const char **)dword_80DBB80;\n  s = (char *)(dword_80DBB80 + 808);\n  if ( (dword_80DBB9C & 0x10) != 0 )\n  {\n    sprintf(s, \"%s %s\\n\", v4, v3);\n  }\n  else\n  {\n    for ( i = &off_80B60C0; ; i += 2 )\n    {\n      v7 = *i;\n      if ( !*i )\n        break;\n      if ( (char *)(n & 0x3F8) == i[1] )\n      {\n        v23 = (int *)(n & 7);\n        for ( j = &off_80B6180; ; j += 2 )\n        {\n          old = *j;\n          if ( !old )\n            break;\n          if ( v23 == (int *)j[1] )\n          {\n            snprintf(v28, 0x14u, \"%s.%s\", v7, old);\n            goto LABEL_19;\n          }\n        }\n        break;\n      }\n    }\n    snprintf(v28, 0x14u, \"<%d>\", n);\nLABEL_19:\n    sprintf(s, \"%s %.64s %s %s\\n\", v4, v5[9], v28, v3);\n  }\n  result = n & 7;\n  if ( result < (int)v5[5] )\n  {\n    v10 = timer;\n    n = strlen(s);\n    if ( (int)v5[1] <= 1 )\n    {\n      if ( v5[1] == (const char *)1 )\n        goto LABEL_40;\n      if ( **v5 == 45 && !(*v5)[1] )\n      {\n        v5[1] = (const char *)1;\n        goto LABEL_40;\n      }\n    }\n    else\n    {\n      if ( !v10 )\n        v10 = time(0);\n      if ( v5[2] == (const char *)v10 )\n        goto LABEL_40;\n      v5[2] = (const char *)v10;\n      close((int)v5[1]);\n    }\n    while ( 1 )\n    {\n      v11 = open64();\n      v5[1] = (const char *)v11;\n      if ( v11 < 0 )\n      {\n        v12 = sub_80AA444();\n        if ( v12 < 0 )\n          v12 = 2;\n        result = sub_804E586(n, s);\n        if ( v12 != 2 )\n        {\n          close(v12);\n          return v22;\n        }\n        return result;\n      }\n      v13 = fstat64();\n      v14 = 0;\n      if ( !v13 )\n        v14 = (v29 & 0xF000) == 0x8000;\n      *((_BYTE *)v5 + 16) = v14;\n      v5[3] = v30;\nLABEL_40:\n      v15 = v5[6];\n      if ( !v15 || !*((_BYTE *)v5 + 16) || v15 >= v5[3] )\n        break;\n      v16 = v5[7];\n      v17 = *v5;\n      if ( v16 )\n      {\n        v23 = (int *)&v23;\n        v18 = (strlen(v17) + 7) & 0xFFFFFFFC;\n        v19 = alloca(v18);\n        old = (char *)&v23;\n        v20 = alloca(v18);\n        v21 = v16 - 1;\n        while ( 1 )\n        {\n          sprintf((char *)&v23, \"%s.%d\", *v5, v21);\n          if ( !v21 )\n            break;\n          sprintf(old, \"%s.%d\", *v5, --v21);\n          rename(old, (const char *)&v23);\n        }\n        rename(*v5, (const char *)&v23);\n      }\n      unlink(*v5);\n      close((int)v5[1]);\n    }\n    result = sub_804E586(n, s);\n    if ( result > 0 )\n      v5[3] += result;\n  }\n  return result;\n}\n"
    ],
    "sub_8079D02": [
        "0x8079d02",
        "char *__usercall sub_8079D02@<eax>(char *result@<eax>)\n{\n  if ( (dword_80DBB9C & 0x100) != 0 )\n    return (char *)sub_8079A4F(46, result, 0);\n  return result;\n}\n"
    ],
    "sub_8079D1A": [
        "0x8079d1a",
        "void __cdecl __noreturn sub_8079D1A(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  char v3; // si\n  _DWORD *v4; // edi\n  int v5; // ecx\n  int v6; // eax\n  int v7; // esi\n  ssize_t v8; // edi\n  char v9; // al\n  _DWORD *i; // ebp\n  int v11; // ebx\n  int v12; // eax\n  int v13; // eax\n  int v14; // eax\n  int v15; // eax\n  unsigned int v16; // ebx\n  int v17; // eax\n  char *j; // ecx\n  char *v19; // edx\n  char v20; // dl\n  int v21; // [esp+0h] [ebp-28h] BYREF\n  int v22; // [esp+4h] [ebp-24h] BYREF\n  int v23; // [esp+8h] [ebp-20h] BYREF\n  int v24; // [esp+Ch] [ebp-1Ch] BYREF\n  int v25; // [esp+10h] [ebp-18h] BYREF\n  char *v26; // [esp+14h] [ebp-14h] BYREF\n\n  v25 = 0;\n  v2 = sub_804DB2E(0x5A8u);\n  qmemcpy(v2, &off_80B60A0, 0x20u);\n  dword_80DBB80 = (int)v2;\n  v3 = sub_80ABEAC(a2, \"^m:nO:l:Ss:b:R:*L\", &v21, v2, &v22, &v23, &v24, &v25);\n  while ( v25 )\n  {\n    v4 = sub_804DB2E(0x10u);\n    v4[3] = sub_80AFB01(v21);\n    *v4 = -1;\n    v4[1] = sub_804EC4A() - 121;\n    sub_80AFAC3(v5, v4);\n  }\n  if ( (v3 & 8) != 0 )\n    v2[5] = sub_80B40CC(8, 1);\n  if ( (v3 & 0x20) != 0 )\n    v2[6] = sub_80B40CC(0x1FFFFF, 0) << 10;\n  if ( (v3 & 0x40) != 0 )\n    v2[7] = sub_80B40CC(99, 0);\n  if ( (v3 & 0x80) == 0 )\n    dword_80DBB9C |= 0x100u;\n  v2[9] = sub_80B2BD8();\n  *(_BYTE *)strchrnul() = 0;\n  if ( (v3 & 2) == 0 )\n    sub_80B3C0D();\n  sub_804E7B4(15, (int)sub_804E68E);\n  sub_804E7B4(2, (int)sub_804E68E);\n  signal(1, (__sighandler_t)1);\n  v6 = sub_8079987();\n  sub_804DC97(v6, 0);\n  sub_8079D02(\"syslogd started: BusyBox v1.29.2\");\nLABEL_15:\n  if ( byte_80DBBA4 )\n  {\nLABEL_57:\n    sub_8079D02(\"syslogd exiting\");\n    sub_804E761(byte_80DBBA4);\n  }\nLABEL_16:\n  v7 = dword_80DBB80;\n  v8 = read(0, (void *)(dword_80DBB80 + 40), 0xFFu);\n  if ( v8 < 0 )\n  {\n    if ( !byte_80DBBA4 )\n      sub_804D3A5((int)&MEMORY[0x80D1B32]);\n    goto LABEL_57;\n  }\n  while ( 1 )\n  {\n    if ( !v8 )\n      goto LABEL_16;\n    v9 = *(_BYTE *)(v7 + v8 - 1 + 40);\n    if ( v9 != 10 )\n    {\n      if ( v9 )\n        break;\n    }\n    --v8;\n  }\n  *(_BYTE *)(v7 + v8 + 40) = 10;\n  for ( i = *(_DWORD **)(v7 + 32); ; i = (_DWORD *)*i )\n  {\n    if ( !i )\n    {\n      if ( (dword_80DBB9C & 0x100) != 0 )\n      {\n        *(_BYTE *)(v7 + v8 + 40) = 0;\n        v26 = (char *)(v7 + 40);\n        v16 = v8 + v7 + 40;\n        while ( v16 > (unsigned int)v26 )\n        {\n          if ( *v26 != 60 )\n            goto LABEL_44;\n          v17 = sub_804ED6C(10, v26 + 1, &v26, v16);\n          if ( *v26 == 62 )\n            ++v26;\n          if ( (v17 & 0xFFFFFC00) != 0 )\nLABEL_44:\n            v17 = 13;\n          for ( j = (char *)(v7 + 296); ; ++j )\n          {\n            v19 = v26++;\n            v20 = *v19;\n            if ( !v20 )\n              break;\n            if ( v20 == 10 )\n              v20 = 32;\n            if ( (v20 & 0xE0) == 0 && v20 != 9 )\n            {\n              *j = 94;\n              v20 += 64;\n              ++j;\n            }\n            *j = v20;\n          }\n          *j = 0;\n          sub_8079A4F(v17, (char *)(v7 + 296), (int)&j[-v7 - 296]);\n        }\n      }\n      goto LABEL_15;\n    }\n    v11 = i[1];\n    if ( *(_DWORD *)v11 != -1 )\n      goto LABEL_37;\n    if ( !*(_DWORD *)(v11 + 8) )\n    {\n      v12 = sub_804EC4A();\n      if ( (unsigned int)(v12 - *(_DWORD *)(v11 + 4)) <= 0x77\n        || (*(_DWORD *)(v11 + 4) = v12, v13 = sub_80B45B2(), (*(_DWORD *)(v11 + 8) = v13) == 0) )\n      {\n        *(_DWORD *)v11 = -1;\n        continue;\n      }\n    }\n    v14 = sub_804DF99(0, 2, *(unsigned __int16 *)(*(_DWORD *)(v11 + 8) + 4));\n    *(_DWORD *)v11 = v14;\n    if ( v14 != -1 )\n    {\nLABEL_37:\n      if ( sendto(\n             *(_DWORD *)v11,\n             (const void *)(v7 + 40),\n             v8 + 1,\n             16448,\n             (const struct sockaddr *)(*(_DWORD *)(v11 + 8) + 4),\n             **(_DWORD **)(v11 + 8)) == -1 )\n      {\n        v15 = *(_DWORD *)dword_80DBB7C;\n        if ( *(_DWORD *)dword_80DBB7C == 104 || v15 == 107 || v15 == 32 )\n        {\n          close(*(_DWORD *)v11);\n          *(_DWORD *)v11 = -1;\n          free(*(void **)(v11 + 8));\n          *(_DWORD *)(v11 + 8) = 0;\n        }\n      }\n    }\n  }\n}\n"
    ],
    "sub_807A066": [
        "0x807a066",
        "int __cdecl sub_807A066(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // eax\n  const char *v4; // esi\n  char *i; // edi\n  const char *v6; // eax\n  int v7; // ebx\n  int v8; // eax\n  int v9; // ebx\n  const char **v10; // edi\n  int v11; // ebp\n  char *v12; // esi\n  int v14; // [esp+0h] [ebp-1Ch]\n  const char *v15; // [esp+4h] [ebp-18h] BYREF\n  char *ident; // [esp+8h] [ebp-14h] BYREF\n\n  geteuid();\n  ident = (char *)sub_80A9A17();\n  v2 = sub_80ABEAC(a2, \"p:st:\", &v15, &ident);\n  v3 = v2 & 2;\n  if ( (v2 & 2) != 0 )\n    v3 = 32;\n  openlog(ident, v3, 0);\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = v15;\n    for ( i = (char *)v15; ; ++i )\n    {\n      if ( !*i )\n      {\n        v6 = v15;\n        LOWORD(v7) = 8;\n        goto LABEL_9;\n      }\n      if ( *i == 46 )\n        break;\n    }\n    *i = 0;\n    v7 = sub_8079A14(v4, (int)&off_80B60C0);\n    if ( v7 < 0 )\n      sub_804D5E0(\"unknown %s name: %s\", \"facility\", v4);\n    v6 = i + 1;\n    *i = 46;\nLABEL_9:\n    v8 = sub_8079A14(v6, (int)&off_80B6180);\n    if ( v8 < 0 )\n      sub_804D5E0(\"unknown %s name: %s\", \"priority\", v4);\n    v9 = v8 & 7 | v7 & 0x3F8;\n  }\n  else\n  {\n    v9 = 13;\n  }\n  v10 = (const char **)(a2 + 4 * optind);\n  if ( *v10 )\n  {\n    v11 = 0;\n    v12 = 0;\n    do\n    {\n      v14 = v11;\n      v11 += strlen(*v10) + 1;\n      v12 = (char *)sub_804DB13(v12, v11 + 1);\n      sprintf(&v12[v14], \" %s\", *v10++);\n    }\n    while ( *v10 );\n    syslog(v9, \"%s\", v12 + 1);\n  }\n  else\n  {\n    while ( fgets_unlocked() )\n    {\n      if ( (_BYTE)qword_80DB778 && (_WORD)qword_80DB778 != 10 )\n        syslog(v9, \"%s\", (const char *)&qword_80DB778);\n    }\n  }\n  closelog();\n  return 0;\n}\n"
    ],
    "sub_807A1EF": [
        "0x807a1ef",
        "int __cdecl sub_807A1EF(int a1, _DWORD *a2)\n{\n  int i; // eax\n\n  for ( i = 1; *++a2; i = 0 )\n    sub_80846BA(*a2);\n  sub_8084661(i);\n  return 0;\n}\n"
    ],
    "sub_807A218": [
        "0x807a218",
        "int __usercall sub_807A218@<eax>(int a1@<eax>)\n{\n  int priority_max; // esi\n  int priority_min; // eax\n  const char *v4; // edx\n\n  priority_max = sched_get_priority_max(a1);\n  priority_min = sched_get_priority_min(a1);\n  v4 = \"%s not supported\\n\";\n  if ( (priority_min | priority_max) >= 0 )\n    v4 = \"%s min/max priority\\t: %u/%u\\n\";\n  return printf(v4, 12 * a1 + 134963712, priority_min, priority_max);\n}\n"
    ],
    "sub_807A254": [
        "0x807a254",
        "int __cdecl sub_807A254(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // ebx\n  _DWORD *v4; // edi\n  __pid_t v5; // esi\n  const char *v6; // ebp\n  int v7; // eax\n  int priority_max; // [esp+8h] [ebp-18h]\n  struct sched_param param; // [esp+Ch] [ebp-14h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^+mprfobi\");\n  if ( (v2 & 1) != 0 )\n  {\n    sub_807A218(0);\n    sub_807A218(1);\n    sub_807A218(2);\n    sub_807A218(3);\n    sub_807A218(5);\n    sub_80AB247();\n  }\n  v3 = (v2 << 28 >> 31) + 2;\n  if ( (v2 & 0x10) != 0 )\n    v3 = 0;\n  if ( (v2 & 0x20) != 0 )\n    v3 = 3;\n  if ( (v2 & 0x40) != 0 )\n    v3 = 5;\n  v4 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v4 )\n    goto LABEL_10;\n  if ( (v2 & 2) == 0 )\n  {\n    if ( v4[1] )\n    {\n      v5 = 0;\n      v6 = \"current\";\n      goto LABEL_21;\n    }\nLABEL_10:\n    sub_804CDC2();\n  }\n  v5 = sub_80B40CC(0x7FFFFFFF, 1);\n  v6 = \"current\";\n  while ( 1 )\n  {\n    v7 = sched_getscheduler(v5);\n    if ( v7 < 0 )\n      sub_804D3C9((int)\"can't %cet pid %d's policy\", 103, v5);\n    printf(\"pid %d's %s scheduling policy: %s\\n\", v5, v6, (const char *)(12 * v7 + 134963712));\n    if ( sched_getparam(v5, &param) )\n      sub_804D3C9((int)\"can't get pid %d's attributes\", v5);\n    printf(\"pid %d's %s scheduling priority: %d\\n\", v5, v6, param.__sched_priority);\n    if ( !v4[1] )\n      break;\n    v4[1] = 0;\n    v6 += 8;\nLABEL_21:\n    priority_max = sched_get_priority_max(v3);\n    sched_get_priority_min(v3);\n    param.__sched_priority = sub_80B4093(priority_max);\n    if ( sched_setscheduler(v5, v3, &param) < 0 )\n      sub_804D3C9((int)\"can't %cet pid %d's policy\", 115, v5);\n    if ( v4[1] )\n      sub_80AB1EC();\n  }\n  return 0;\n}\n"
    ],
    "sub_807A3E7": [
        "0x807a3e7",
        "int __cdecl sub_807A3E7(int a1, int a2)\n{\n  char v2; // al\n  char v3; // bl\n  char *v4; // esi\n  int v5; // eax\n  int v6; // ebx\n  int v7; // edi\n  unsigned __int8 v8; // al\n  unsigned __int8 *v9; // ecx\n  bool v10; // zf\n  int v12; // [esp+0h] [ebp-18h] BYREF\n  int len[5]; // [esp+4h] [ebp-14h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"cs:+n:+r\", &v12, len);\n  if ( (v2 & 4) != 0 )\n  {\n    if ( klogctl(8, 0, len[0]) )\n      goto LABEL_3;\n  }\n  else\n  {\n    v3 = v2;\n    if ( (v2 & 2) == 0 )\n      v12 = klogctl(10, 0, 0);\n    if ( v12 <= 0x3FFF )\n      v12 = 0x4000;\n    if ( v12 > 0x1000000 )\n      v12 = 0x1000000;\n    v4 = (char *)sub_804DAFA(v12);\n    v5 = klogctl((v3 & 1) + 3, v4, v12);\n    v12 = v5;\n    if ( v5 < 0 )\nLABEL_3:\n      sub_804D3C9((int)\"klogctl\");\n    if ( v5 )\n    {\n      if ( (v3 & 8) != 0 )\n      {\n        sub_804E586(v5, v4);\n        v10 = v4[v12 - 1] == 10;\n      }\n      else\n      {\n        v6 = 0;\n        v7 = 10;\n        do\n        {\n          v8 = v4[v6];\n          if ( v7 == 10 && v8 == 60 )\n          {\n            do\n              ++v6;\n            while ( v4[v6 - 1] != 62 && v12 > v6 );\n          }\n          else\n          {\n            ++v6;\n            v7 = v8;\n            v9 = *(unsigned __int8 **)(_stdout + 16);\n            if ( (unsigned int)v9 >= *(_DWORD *)(_stdout + 28) )\n            {\n              __fputc_unlocked();\n            }\n            else\n            {\n              *(_DWORD *)(_stdout + 16) = v9 + 1;\n              *v9 = v8;\n            }\n          }\n        }\n        while ( v12 > v6 );\n        v10 = v7 == 10;\n      }\n      if ( !v10 )\n        sub_804DD98(10);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_807A516": [
        "0x807a516",
        "int __cdecl sub_807A516(int a1, int a2)\n{\n  char v2; // si\n  const char *v3; // ebx\n  int v4; // eax\n  unsigned int v5; // eax\n\n  v2 = sub_80ABEAC(a2, \"^tT\");\n  v3 = *(const char **)(a2 + 4 * optind);\n  if ( !v3 )\n    v3 = \"/dev/cdrom\";\n  v4 = sub_804DC1E(v3);\n  sub_804DC97(v4, 3);\n  if ( (v2 & 1) != 0 || (v2 & 2) != 0 && ioctl(3, 0x5326u) == 2 )\n    v5 = 21273;\n  else\n    v5 = 21257;\n  sub_804E029(3, v5, 0, \"%s\", v3);\n  return 0;\n}\n"
    ],
    "sub_807A591": [
        "0x807a591",
        "int __cdecl sub_807A591(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // eax\n  int v5; // [esp+8h] [ebp-14h] BYREF\n  int v6[4]; // [esp+Ch] [ebp-10h] BYREF\n\n  v6[0] = 135052877;\n  if ( (sub_80ABEAC(a2, \"^l:o:\", &v5, v6) & 1) == 0 )\n    sub_804CDC2();\n  sub_80B3F8E();\n  sub_80B3F8E();\n  v2 = (const char **)(a2 + 4 * optind);\n  sub_804DBC2(*v2);\n  v3 = posix_fallocate64();\n  *(_DWORD *)dword_80DBB7C = v3;\n  if ( v3 )\n    sub_804D3C9((int)\"fallocate '%s'\", *v2);\n  return 0;\n}\n"
    ],
    "sub_807A638": [
        "0x807a638",
        "int __usercall sub_807A638@<eax>(char *s1@<ecx>, int *a2@<eax>, int a3@<edx>, char *s2)\n{\n  int result; // eax\n  int v7; // edx\n  int v8; // ebx\n\n  result = strcmp(s1, s2);\n  v7 = *a2;\n  if ( result )\n    v8 = v7 | a3;\n  else\n    v8 = v7 & ~a3;\n  *a2 = v8;\n  return result;\n}\n"
    ],
    "sub_807A65D": [
        "0x807a65d",
        "int __usercall sub_807A65D@<eax>(int *a1@<eax>)\n{\n  unsigned int v2; // esi\n  int v3; // edi\n  int v4; // edx\n  int v5; // ecx\n  long double v6; // fst7\n  long double v7; // fst6\n  long double v8; // fst5\n  const char *v9; // eax\n  int v11; // [esp+6Ch] [ebp-58h]\n  int v12; // [esp+70h] [ebp-54h]\n  int v13; // [esp+74h] [ebp-50h]\n  int v14; // [esp+78h] [ebp-4Ch]\n  int v15; // [esp+7Ch] [ebp-48h]\n  int v16; // [esp+80h] [ebp-44h]\n  int v17; // [esp+84h] [ebp-40h]\n  int v18; // [esp+88h] [ebp-3Ch]\n  int v19; // [esp+90h] [ebp-34h]\n  int v20; // [esp+94h] [ebp-30h]\n  int v21; // [esp+98h] [ebp-2Ch]\n  int v22; // [esp+9Ch] [ebp-28h]\n  int v23; // [esp+A0h] [ebp-24h]\n\n  v2 = a1[25];\n  v3 = a1[26];\n  v4 = *a1;\n  v23 = a1[27];\n  v22 = a1[30];\n  v21 = a1[28];\n  v5 = a1[1];\n  v20 = a1[29];\n  v19 = a1[31];\n  if ( v2 )\n  {\n    v6 = 1.0e12 / (long double)v2;\n    v7 = v6 / (long double)(unsigned int)(v22 + v23 + v3 + v4);\n    v8 = v7 / (long double)(unsigned int)(v19 + v20 + v5 + v21);\n  }\n  else\n  {\n    v7 = 0.0;\n    v8 = 0.0;\n    v6 = 0.0;\n  }\n  v18 = a1[17];\n  v17 = a1[18];\n  v16 = a1[14];\n  v15 = a1[15];\n  v14 = a1[11];\n  v13 = a1[12];\n  v12 = a1[8];\n  v11 = a1[9];\n  v9 = \"false\";\n  if ( a1[24] )\n    v9 = \"true\";\n  return printf(\n           \"\\n\"\n           \"mode \\\"%ux%u-%u\\\"\\n\"\n           \"\\t# D: %.3f MHz, H: %.3f kHz, V: %.3f Hz\\n\"\n           \"\\tgeometry %u %u %u %u %u\\n\"\n           \"\\ttimings %u %u %u %u %u %u %u\\n\"\n           \"\\taccel %s\\n\"\n           \"\\trgba %u/%u,%u/%u,%u/%u,%u/%u\\n\"\n           \"endmode\\n\"\n           \"\\n\",\n           v4,\n           v5,\n           (int)(v8 + 0.5),\n           (double)(v6 / 1000000.0),\n           (double)(v7 / 1000.0),\n           (double)v8,\n           v4,\n           v5,\n           a1[2],\n           a1[3],\n           a1[6],\n           v2,\n           v3,\n           v23,\n           v21,\n           v20,\n           v22,\n           v19,\n           v9,\n           v11,\n           v12,\n           v13,\n           v14,\n           v15,\n           v16,\n           v17,\n           v18);\n}\n"
    ],
    "sub_807A7BE": [
        "0x807a7be",
        "int __usercall sub_807A7BE@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int i; // ecx\n  int v3; // ebx\n  int v4; // ecx\n  int result; // eax\n  int v6; // edx\n  int j; // ecx\n  int v8; // ebx\n\n  for ( i = 0; i != 16; i += 4 )\n  {\n    v3 = *(_DWORD *)(a2 + i);\n    if ( v3 > 0 )\n      *(_DWORD *)(a1 + i) = v3;\n  }\n  v4 = *(_DWORD *)(a2 + 24);\n  if ( v4 > 0 )\n    *(_DWORD *)(a1 + 24) = v4;\n  result = a1 + 100;\n  v6 = a2 + 100;\n  for ( j = 0; j != 36; j += 4 )\n  {\n    v8 = *(_DWORD *)(v6 + j);\n    if ( v8 > 0 )\n      *(_DWORD *)(result + j) = v8;\n  }\n  return result;\n}\n"
    ],
    "sub_807A7F9": [
        "0x807a7f9",
        "int __cdecl sub_807A7F9(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // edi\n  int v4; // esi\n  const char *v5; // ebp\n  char *v6; // ecx\n  const char *v7; // ebp\n  int v8; // eax\n  char *v9; // edx\n  char v10; // cl\n  int v11; // ebx\n  char *v12; // ebp\n  char *v13; // eax\n  char v14; // dl\n  int v15; // eax\n  const char *v17; // [esp+8h] [ebp-18Ch]\n  char *v18; // [esp+Ch] [ebp-188h]\n  unsigned __int8 v19; // [esp+Ch] [ebp-188h]\n  char *v20; // [esp+10h] [ebp-184h]\n  char *s; // [esp+18h] [ebp-17Ch]\n  char sa; // [esp+18h] [ebp-17Ch]\n  char *v23; // [esp+3Ch] [ebp-158h]\n  char *v24; // [esp+40h] [ebp-154h]\n  char *v25; // [esp+44h] [ebp-150h] BYREF\n  char *s1; // [esp+48h] [ebp-14Ch] BYREF\n  char *haystack; // [esp+4Ch] [ebp-148h] BYREF\n  char v28; // [esp+50h] [ebp-144h] BYREF\n  char v29; // [esp+5Ch] [ebp-138h] BYREF\n  int v30; // [esp+98h] [ebp-FCh]\n  char v31; // [esp+A8h] [ebp-ECh] BYREF\n  char v32; // [esp+ACh] [ebp-E8h] BYREF\n  char v33; // [esp+B0h] [ebp-E4h] BYREF\n  char v34; // [esp+B4h] [ebp-E0h] BYREF\n  char v35; // [esp+B8h] [ebp-DCh] BYREF\n  char v36; // [esp+BCh] [ebp-D8h] BYREF\n  char v37; // [esp+C0h] [ebp-D4h] BYREF\n  int v38; // [esp+C4h] [ebp-D0h] BYREF\n  int v39[7]; // [esp+C8h] [ebp-CCh] BYREF\n  _DWORD v40[44]; // [esp+E4h] [ebp-B0h] BYREF\n\n  memset(v40, 255, 0xA0u);\n  v2 = a2 + 4;\n  v3 = a1 - 1;\n  v20 = \"/dev/fb0\";\n  v4 = 0;\n  while ( v3 > 0 )\n  {\n    v5 = *(const char **)v2;\n    if ( !*(_DWORD *)v2 )\n      break;\n    if ( *v5 == 45 )\n    {\n      v6 = 0;\n      v7 = v5 + 1;\n      while ( 1 )\n      {\n        s = v6;\n        v18 = (char *)(11 * (_DWORD)v6 + 134963808);\n        v8 = strcmp(v7, v18);\n        v9 = v18;\n        if ( !v8 )\n          break;\n        v6 = s + 1;\n        if ( s == (char *)35 )\n          goto LABEL_6;\n      }\n      v19 = v18[9];\n      if ( v19 >= v3 )\nLABEL_6:\n        sub_804CDC2();\n      v10 = v9[10];\n      if ( v10 == 7 )\n      {\n        v40[32] |= 2u;\n        goto LABEL_40;\n      }\n      if ( (unsigned __int8)v10 <= 7u )\n      {\n        if ( v10 == 3 )\n        {\n          sa = 3;\n          v40[0] = sub_80B40EC();\n          v40[1] = sub_80B40EC();\n          v40[2] = sub_80B40EC();\n          v40[3] = sub_80B40EC();\n          v40[6] = sub_80B40EC();\n        }\n        else\n        {\n          if ( (unsigned __int8)v10 <= 3u )\n          {\n            if ( v10 == 1 )\n            {\n              v20 = *(char **)(v2 + 4);\n              goto LABEL_40;\n            }\n            if ( v10 == 2 )\n            {\nLABEL_40:\n              if ( ((1 << v10) & 0x2806) == 0 )\n                goto LABEL_41;\n              goto LABEL_42;\n            }\nLABEL_39:\n            if ( (unsigned __int8)v10 <= 0xDu )\n              goto LABEL_40;\nLABEL_41:\n            v4 |= 1u;\nLABEL_42:\n            v3 -= v19;\n            v2 += 4 * v19;\n            v5 = v17;\n            goto LABEL_43;\n          }\n          if ( v10 != 4 )\n          {\n            if ( v10 == 6 )\n            {\n              v40[32] |= 1u;\n              goto LABEL_40;\n            }\n            goto LABEL_39;\n          }\n          sa = 4;\n          v40[25] = sub_80B40EC();\n          v40[26] = sub_80B40EC();\n          v40[27] = sub_80B40EC();\n          v40[28] = sub_80B40EC();\n          v40[29] = sub_80B40EC();\n          v40[30] = sub_80B40EC();\n          v40[31] = sub_80B40EC();\n        }\n        v10 = sa;\n        goto LABEL_40;\n      }\n      if ( v10 == 100 )\n      {\n        v40[0] = sub_80B40EC();\n        goto LABEL_41;\n      }\n      if ( (unsigned __int8)v10 > 0x64u )\n      {\n        if ( v10 == 101 )\n        {\n          v40[1] = sub_80B40EC();\n          goto LABEL_41;\n        }\n        if ( v10 == 104 )\n        {\n          v40[6] = sub_80B40EC();\n          goto LABEL_41;\n        }\n      }\n      else\n      {\n        if ( v10 == 11 )\n        {\n          v4 |= 8u;\n          goto LABEL_40;\n        }\n        if ( v10 == 13 )\n        {\n          v4 |= 2u;\n          goto LABEL_40;\n        }\n      }\n      goto LABEL_39;\n    }\n    if ( v3 != 1 )\n      goto LABEL_6;\n    v4 |= 4u;\nLABEL_43:\n    --v3;\n    v2 += 4;\n    v17 = v5;\n  }\n  v11 = sub_804DBE1(v20);\n  sub_804E0BE(v11, 0x4600u, (int)&v25, \"FBIOGET_VSCREENINFO\");\n  if ( (v4 & 4) != 0 )\n  {\n    sub_80B052C();\n    while ( sub_80B0560(\"# \\t\\r\") )\n    {\n      if ( !strcmp(v23, \"mode\") )\n      {\n        if ( v24 )\n        {\n          v12 = strstr(v24, v17);\n          if ( v12 )\n          {\n            v13 = &v12[strlen(v17)];\n            v14 = *v13;\n            if ( ((*v13 & 0xDF) == 0 || (unsigned __int8)(v14 - 9) <= 4u) && *(v13 - 1) != 34 )\n              break;\n            if ( v14 == 34 && *(v12 - 1) == 34 )\n              break;\n          }\n        }\n      }\n    }\n    if ( !v23 )\nLABEL_56:\n      sub_804D5E0(\"unknown video mode '%s'\", v17);\n    while ( 1 )\n    {\n      if ( !sub_80B0560(\"# \\t\") )\n        goto LABEL_56;\n      if ( !strcmp(v23, \"endmode\") )\n        break;\n      v15 = sub_804D222(\"geometry\", v23);\n      switch ( v15 )\n      {\n        case 0:\n          sscanf(v24, \"%d %d %d %d %d\", &v25, &s1, &haystack, &v28, &v29);\n          break;\n        case 1:\n          sscanf(v24, \"%d %d %d %d %d %d %d\", &v31, &v32, &v33, &v34, &v35, &v36, &v37);\n          break;\n        case 2:\n        case 3:\n          sub_807A638(v24, v39, dword_80B7D90[v15], \"false\");\n          break;\n        case 4:\n          sub_807A638(v24, &v38, (int)*(&off_80B7D7C + v15), \"low\");\n          break;\n        default:\n          continue;\n      }\n    }\n    v4 |= 1u;\n  }\n  if ( (v4 & 1) == 0 )\n  {\n    if ( v4 )\n      goto LABEL_74;\nLABEL_73:\n    sub_807A65D((int *)&v25);\n    return 0;\n  }\n  sub_807A7BE((int)&v25, (int)v40);\n  if ( (v4 & 8) != 0 )\n    v30 = 64;\n  sub_804E0BE(v11, 0x4601u, (int)&v25, \"FBIOPUT_VSCREENINFO\");\nLABEL_74:\n  if ( (v4 & 2) != 0 )\n    goto LABEL_73;\n  return 0;\n}\n"
    ],
    "sub_807AD5C": [
        "0x807ad5c",
        "int __cdecl sub_807AD5C(int a1, int a2)\n{\n  unsigned int v2; // esi\n  const char **v3; // ebx\n  int v4; // edi\n  const char *v5; // edx\n  unsigned int i; // ebx\n  size_t v7; // ebx\n  ssize_t v8; // ebp\n  void *v10; // [esp+10h] [ebp-9Ch]\n  char v11[4]; // [esp+14h] [ebp-98h] BYREF\n  int v12; // [esp+18h] [ebp-94h]\n  unsigned int v13; // [esp+1Ch] [ebp-90h]\n  unsigned int v14; // [esp+20h] [ebp-8Ch] BYREF\n  int v15; // [esp+24h] [ebp-88h]\n  int v16; // [esp+28h] [ebp-84h]\n  unsigned int v17; // [esp+2Ch] [ebp-80h]\n  int v18; // [esp+4Ch] [ebp-60h]\n\n  v2 = sub_80ABEAC(a2, \"^n\");\n  v3 = (const char **)(a2 + 4 * optind);\n  sub_804DFF3(*v3);\n  if ( (v18 & 0xF000) != 24576 )\n    sub_804D5E0(\"%s: not a block device\", *v3);\n  v4 = sub_804DBE1(*v3);\n  sub_804E0BE(v4, 0x801C0204, (int)&v14, \"FDGETPRM\");\n  v5 = \"Double\";\n  if ( v16 != 2 )\n    v5 = \"Single\";\n  printf(\"%s-sided, %u tracks, %u sec/track. Total capacity %d kB\\n\", v5, v17, v15, v14 >> 1);\n  printf(\"Formatting... \");\n  sub_804E0BE(v4, 0x247u, 0, \"FDFMTBEG\");\n  for ( i = 0; v17 > i; ++i )\n  {\n    v12 = 0;\n    v13 = i;\n    sub_804E0BE(v4, 0x400C0248u, (int)v11, \"FDFMTTRK\");\n    printf(\"%3d\\b\\b\\b\", i);\n    if ( v16 == 2 )\n    {\n      v12 = 1;\n      sub_804E0BE(v4, 0x400C0248u, (int)v11, \"FDFMTTRK\");\n    }\n  }\n  sub_804E0BE(v4, 0x249u, 0, \"FDFMTEND\");\n  puts(\"Done\");\n  if ( !v2 )\n  {\n    v7 = (v16 * v15) << 9;\n    v10 = sub_804DAFA(v7);\n    printf(\"Verifying... \");\n    while ( v17 > v2 )\n    {\n      printf(\"%3d\\b\\b\\b\", v2);\n      v8 = sub_804E5BC(v7, v10, v4);\n      if ( v7 != v8 )\n      {\n        if ( v8 < 0 )\n          sub_804D3A5((int)\"read error\");\n        sub_804D5E0(\"problem reading cylinder %d, expected %d, read %d\", v2, v7, v8);\n      }\n      while ( --v8 >= 0 )\n      {\n        if ( *((_BYTE *)v10 + v8) != 0xF6 )\n          printf(\"bad data in cyl %d\\nContinuing... \", v2);\n      }\n      ++v2;\n    }\n    puts(\"Done\");\n  }\n  return 0;\n}\n"
    ],
    "sub_807AF33": [
        "0x807af33",
        "const char *__usercall sub_807AF33@<eax>(char a1@<al>)\n{\n  void **i; // ecx\n  _BYTE *v2; // edx\n\n  for ( i = &off_80B6400; ; ++i )\n  {\n    v2 = *i;\n    if ( !*i )\n      break;\n    if ( *v2 == a1 )\n      return v2 + 1;\n  }\n  return \"Unknown\";\n}\n"
    ],
    "sub_807AF4F": [
        "0x807af4f",
        "_BOOL4 __usercall sub_807AF4F@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  char v2; // cl\n\n  v1 = 0;\n  v2 = 0;\n  do\n    v2 |= *(_BYTE *)(a1 + v1++);\n  while ( v1 != 16 );\n  return v2 == 0;\n}\n"
    ],
    "sub_807AF64": [
        "0x807af64",
        "unsigned int __usercall sub_807AF64@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned int v4; // edi\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  unsigned int v7; // eax\n  unsigned int result; // eax\n  unsigned int v9; // [esp+0h] [ebp-18h]\n  char v10; // [esp+7h] [ebp-11h]\n\n  v9 = a2;\n  v10 = *(_BYTE *)(dword_80DBB80 + 43);\n  v4 = *(_DWORD *)(dword_80DBB80 + 32);\n  v5 = *(_DWORD *)(dword_80DBB80 + 28);\n  if ( v10 && a2 / (v5 * v4) > 0x3FF )\n    v9 = ((v5 * v4) << 10) - 1;\n  v6 = v9 / v4 / v5;\n  a1[1] = v9 / v4 % v5;\n  a1[3] = v6;\n  a1[2] = (v6 >> 2) & 0xC0 | (v9 % v4 + 1);\n  if ( v10 && a3 / (v5 * v4) > 0x3FF )\n    a3 = ((v5 * v4) << 10) - 1;\n  v7 = a3 / v4 / v5;\n  a1[5] = a3 / v4 % v5;\n  a1[7] = v7;\n  result = v7 >> 2;\n  a1[6] = (a3 % v4 + 1) | result & 0xC0;\n  return result;\n}\n"
    ],
    "sub_807B008": [
        "0x807b008",
        "int sub_807B008()\n{\n  int result; // eax\n  int v1; // edx\n\n  result = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 32) * *(_DWORD *)(dword_80DBB80 + 28);\n  if ( *(_BYTE *)(dword_80DBB80 + 41) && v1 )\n    *(_DWORD *)(dword_80DBB80 + 12) = v1;\n  else\n    *(_DWORD *)(dword_80DBB80 + 12) = 1;\n  return result;\n}\n"
    ],
    "sub_807B02A": [
        "0x807b02a",
        "int __usercall sub_807B02A@<eax>(int *a1@<eax>)\n{\n  _DWORD *v1; // ecx\n  int v2; // edi\n  int v3; // edx\n  unsigned int v4; // esi\n\n  v1 = (_DWORD *)(dword_80DBB80 + 2252);\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    if ( *(_DWORD *)(dword_80DBB80 + 8) == v3 )\n      return 0;\n    if ( v3 == 4 )\n    {\n      v2 = 4;\n      v4 = 0;\n    }\n    if ( *(_BYTE *)(*v1 + 4) )\n      break;\nLABEL_11:\n    ++v3;\n    v1 += 5;\n  }\n  if ( v4 <= v1[2] + *(_DWORD *)(*v1 + 8) )\n  {\n    v2 = v3;\n    v4 = v1[2] + *(_DWORD *)(*v1 + 8);\n    goto LABEL_11;\n  }\n  if ( a1 )\n    *a1 = v2;\n  return v3;\n}\n"
    ],
    "sub_807B080": [
        "0x807b080",
        "int __usercall sub_807B080@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // edi\n  _DWORD *v3; // ebx\n  unsigned int i; // ecx\n  int v5; // esi\n  char v6; // bp\n  int v7; // ebp\n  int v8; // [esp+0h] [ebp-18h]\n\n  v8 = result;\n  v2 = dword_80DBB80;\n  v3 = (_DWORD *)(dword_80DBB80 + 2252);\n  for ( i = 0; *(_DWORD *)(v2 + 8) > i; ++i )\n  {\n    v5 = *v3;\n    v6 = *(_BYTE *)(*v3 + 4);\n    if ( v6 == 15 || v6 == 0 || (v6 & 0x7F) == 5 )\n    {\n      result = v8;\n      *(_DWORD *)(v8 + 4 * i) = -1;\n      *(_DWORD *)(a2 + 4 * i) = 0;\n    }\n    else\n    {\n      v7 = v3[2] + *(_DWORD *)(v5 + 8);\n      result = v8;\n      *(_DWORD *)(v8 + 4 * i) = v7;\n      *(_DWORD *)(a2 + 4 * i) = v7 + *(_DWORD *)(v5 + 12) - 1;\n    }\n    v3 += 5;\n  }\n  return result;\n}\n"
    ],
    "sub_807B0FC": [
        "0x807b0fc",
        "int sub_807B0FC()\n{\n  int v0; // eax\n\n  v0 = sub_804DBE1(\"/dev/null\");\n  return sub_804DC97(v0, 3);\n}\n"
    ],
    "sub_807B112": [
        "0x807b112",
        "int sub_807B112()\n{\n  int v0; // edx\n  const char *v1; // ebp\n  unsigned __int64 v3; // [esp+0h] [ebp-24h]\n  unsigned int v4; // [esp+8h] [ebp-1Ch]\n\n  v4 = *(_DWORD *)(dword_80DBB80 + 84);\n  v3 = (unsigned __int64)v4 << 9 >> 20;\n  if ( HIDWORD(v3) || (v0 = 77, (unsigned int)v3 > 0x270F) )\n  {\n    v3 = (v3 + 512) >> 10;\n    v0 = 71;\n  }\n  v1 = \" cylinders\" + 1;\n  if ( !*(_BYTE *)(dword_80DBB80 + 41) )\n    v1 = \" sectors\" + 1;\n  return printf(\n           \"Disk %s: %llu %cB, %llu bytes, %u sectors\\n\"\n           \"%u cylinders, %u heads, %u sectors/track\\n\"\n           \"Units: %s of %u * %u = %u bytes\\n\"\n           \"\\n\",\n           *(const char **)(dword_80DBB80 + 4),\n           v3,\n           v0,\n           (unsigned __int64)v4 << 9,\n           v4,\n           *(_DWORD *)(dword_80DBB80 + 36),\n           *(_DWORD *)(dword_80DBB80 + 28),\n           *(_DWORD *)(dword_80DBB80 + 32),\n           v1,\n           *(_DWORD *)(dword_80DBB80 + 12),\n           *(_DWORD *)(dword_80DBB80 + 16),\n           *(_DWORD *)(dword_80DBB80 + 16) * *(_DWORD *)(dword_80DBB80 + 12));\n}\n"
    ],
    "sub_807B1D6": [
        "0x807b1d6",
        "int sub_807B1D6()\n{\n  int result; // eax\n  int v1; // [esp-8h] [ebp-8h]\n\n  result = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 + 40) && *(_DWORD *)(dword_80DBB80 + 36) > 0x400u && !*(_BYTE *)(dword_80DBB80 + 44) )\n  {\n    printf(\n      \"\\n\"\n      \"The number of cylinders for this disk is set to %u.\\n\"\n      \"There is nothing wrong with that, but this is larger than 1024,\\n\"\n      \"and could in certain setups cause problems with:\\n\"\n      \"1) software that runs at boot time (e.g., old versions of LILO)\\n\"\n      \"2) booting and partitioning software from other OSs\\n\"\n      \"   (e.g., DOS FDISK, OS/2 FDISK)\\n\",\n      *(_DWORD *)(dword_80DBB80 + 36));\n    return v1;\n  }\n  return result;\n}\n"
    ],
    "sub_807B200": [
        "0x807b200",
        "int sub_807B200()\n{\n  _DWORD *v0; // ebx\n  int result; // eax\n\n  v0 = (_DWORD *)dword_80DBB80;\n  if ( !*(_DWORD *)(dword_80DBB80 + 28)\n    || !*(_DWORD *)(dword_80DBB80 + 32)\n    || (result = 0, !*(_DWORD *)(dword_80DBB80 + 36)) )\n  {\n    printf(\"Unknown value(s) for:\");\n    if ( !v0[7] )\n      printf(\" heads\");\n    if ( !v0[8] )\n      printf(\" sectors\");\n    if ( !v0[9] )\n      printf(\" cylinders\");\n    puts(\" (settable in the extra functions menu)\");\n    return 1;\n  }\n  return result;\n}\n"
    ],
    "sub_807B26B": [
        "0x807b26b",
        "int sub_807B26B()\n{\n  puts(\"Command Action\");\n  if ( *(_BYTE *)(dword_80DBB80 + 40) == 5 )\n  {\n    puts(\"o\\tcreate a new empty DOS partition table\");\n    puts(\"p\\tprint the partition table\");\n    puts(\"q\\tquit without saving changes\");\n    return puts(\"s\\tcreate a new empty Sun disklabel\");\n  }\n  else\n  {\n    puts(\"a\\ttoggle a bootable flag\");\n    puts(\"b\\tedit bsd disklabel\");\n    puts(\"c\\ttoggle the dos compatibility flag\");\n    puts(\"d\\tdelete a partition\");\n    puts(\"l\\tlist known partition types\");\n    puts(\"n\\tadd a new partition\");\n    puts(\"o\\tcreate a new empty DOS partition table\");\n    puts(\"p\\tprint the partition table\");\n    puts(\"q\\tquit without saving changes\");\n    puts(\"s\\tcreate a new empty Sun disklabel\");\n    puts(\"t\\tchange a partition's system id\");\n    puts(\"u\\tchange display/entry units\");\n    puts(\"v\\tverify the partition table\");\n    puts(\"w\\twrite table to disk and exit\");\n    return puts(\"x\\textra functionality (experts only)\");\n  }\n}\n"
    ],
    "sub_807B34A": [
        "0x807b34a",
        "void __usercall __noreturn sub_807B34A(char *a1@<eax>)\n{\n  int v1; // ebx\n\n  v1 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 42) )\n  {\n    sub_807B0FC();\n    longjmp((struct __jmp_buf_tag *)(v1 + 88), 1);\n  }\n  sub_804D5E0(a1, *(_DWORD *)(dword_80DBB80 + 4));\n}\n"
    ],
    "sub_807B370": [
        "0x807b370",
        "int __usercall sub_807B370@<eax>(unsigned int a1@<eax>)\n{\n  int result; // eax\n  int v2; // edx\n\n  if ( (((*(unsigned int *)(dword_80DBB80 + 16) * (unsigned __int64)a1) >> 32) & 0x80000000) != 0LL\n    || (result = lseek64(), v2 == -1) && (++result, !result) )\n  {\n    sub_807B34A(\"can't seek on %s\");\n  }\n  return result;\n}\n"
    ],
    "sub_807B39C": [
        "0x807b39c",
        "ssize_t __usercall sub_807B39C@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v4; // esi\n  ssize_t result; // eax\n\n  *(_DWORD *)(a1 + 8) = a2;\n  v4 = dword_80DBB80;\n  *(_DWORD *)(a1 + 12) = sub_804DB2E(*(_DWORD *)(dword_80DBB80 + 16));\n  sub_807B370(a2);\n  result = sub_804E5E3(3, *(char **)(a1 + 12), *(_DWORD *)(v4 + 16));\n  if ( result != *(_DWORD *)(v4 + 16) )\n    sub_807B34A(\"can't read from %s\");\n  *(_BYTE *)(a1 + 16) = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  *(_DWORD *)a1 = 0;\n  return result;\n}\n"
    ],
    "sub_807B3F2": [
        "0x807b3f2",
        "void *__usercall sub_807B3F2@<eax>(void *result@<eax>)\n{\n  void *v1; // edx\n\n  if ( result )\n  {\n    v1 = result;\n    result = 0;\n    memset(v1, 0, 0x10u);\n  }\n  return result;\n}\n"
    ],
    "sub_807B407": [
        "0x807b407",
        "void *__usercall sub_807B407@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // ebp\n  int v3; // esi\n  _BYTE *v4; // edi\n  int v5; // eax\n  _DWORD *v6; // edx\n  int v8; // ebp\n  _DWORD *v9; // eax\n  int v10; // edx\n  int v11; // edx\n  int v12; // edx\n  char *i; // eax\n  int v14; // [esp+0h] [ebp-14h]\n\n  v1 = a1;\n  v2 = dword_80DBB80;\n  v3 = dword_80DBB80 + 20 * a1;\n  v4 = *(_BYTE **)(v3 + 2252);\n  v14 = *(_DWORD *)(v3 + 2256);\n  v5 = sub_807B200();\n  v6 = (_DWORD *)v14;\n  if ( v5 )\n    return (void *)v14;\n  *(_BYTE *)(v3 + 2268) = 1;\n  if ( v1 > 3 )\n  {\n    if ( *(_BYTE *)(v14 + 4) || v1 == 4 )\n    {\n      if ( v1 == 4 )\n      {\n        if ( *(int *)(v2 + 8) > 5 )\n        {\n          v10 = *(_DWORD *)(v2 + 2352);\n          if ( v10 )\n            *(_DWORD *)(v10 + 8) = *(_DWORD *)(v10 + 8) - *(_DWORD *)(v2 + 80) + *(_DWORD *)(v2 + 2360);\n          *(_DWORD *)(v2 + 2360) = *(_DWORD *)(v2 + 80);\n          *(_BYTE *)(v2 + 2368) = 1;\n        }\n      }\n      else\n      {\n        v14 = v2 + 20 * (v1 - 1);\n        v9 = *(_DWORD **)(v14 + 2256);\n        qmemcpy(v9, v6, 0x10u);\n        v9[2] = v6[2];\n        v9[3] = v6[3];\n        *(_BYTE *)(v14 + 2268) = 1;\n      }\n      v11 = *(_DWORD *)(v2 + 8);\n      if ( v11 <= 5 )\n        return sub_807B3F2(*(void **)(v2 + 20 * v1 + 2252));\n      v12 = v11 - 1;\n      *(_DWORD *)(v2 + 8) = v12;\n      for ( i = (char *)(v2 + 20 * v1 + 2252); ; qmemcpy(i - 20, i, 0x14u) )\n      {\n        i += 20;\n        if ( v12 <= v1 )\n          break;\n        ++v1;\n      }\n    }\n    else\n    {\n      --*(_DWORD *)(v2 + 8);\n      v8 = 20 * (v1 - 1) + v2;\n      sub_807B3F2(*(void **)(v8 + 2256));\n      *(_BYTE *)(v8 + 2268) = 1;\n    }\n    return (void *)v14;\n  }\n  if ( ((v4[4] & 0x7F) == 5 || v4[4] == 15) && *(_DWORD *)(v2 + 48) == v1 )\n  {\n    *(_DWORD *)(v2 + 8) = 4;\n    *(_DWORD *)(v2 + 20 * v1 + 2256) = 0;\n    *(_DWORD *)(v2 + 80) = 0;\n  }\n  return sub_807B3F2(v4);\n}\n"
    ],
    "sub_807B55A": [
        "0x807b55a",
        "int sub_807B55A()\n{\n  int *v0; // ebx\n  int v1; // esi\n  int v2; // eax\n  int v3; // eax\n  int result; // eax\n\n  v0 = (int *)dword_80DBB80;\n  v1 = dword_80DBB80 + 124;\n  v2 = sub_80AED5C(80);\n  if ( v2 <= 0 )\n    exit(0);\n  v3 = v2 - 1;\n  if ( *((_BYTE *)v0 + v3 + 124) == 10 )\n    *((_BYTE *)v0 + v3 + 124) = 0;\n  for ( *v0 = v1; ; ++*v0 )\n  {\n    result = *(unsigned __int8 *)*v0;\n    if ( (unsigned __int8)(result - 1) > 0x1Fu )\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_807B5A1": [
        "0x807b5a1",
        "char sub_807B5A1()\n{\n  while ( !sub_807B55A() )\n    ;\n  return **(_BYTE **)dword_80DBB80;\n}\n"
    ],
    "sub_807B5BA": [
        "0x807b5ba",
        "char *__usercall sub_807B5BA@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>)\n{\n  int v6; // edx\n  int v7; // ecx\n  char *v8; // edi\n\n  sub_804DB2E(0x24u);\n  v8 = (char *)sub_80A9707(v7, v6);\n  sprintf(v8, \"%u,%u,%u\", a1 | (4 * a3) & 0x300, a2, a3 & 0x3F);\n  return v8;\n}\n"
    ],
    "sub_807B600": [
        "0x807b600",
        "void __noreturn sub_807B600()\n{\n  int v0; // ebx\n  int v1; // eax\n  int v2; // esi\n  int i; // edi\n  int v4; // ebp\n\n  v0 = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 + 40) )\n  {\n    if ( *(_BYTE *)(dword_80DBB80 + 2268) )\n      *(_BYTE *)(dword_80DBB80 + 2328) = 1;\n    if ( *(_BYTE *)(v0 + 2288) )\n      *(_BYTE *)(v0 + 2328) = 1;\n    if ( *(_BYTE *)(v0 + 2308) )\n      *(_BYTE *)(v0 + 2328) = 1;\n    v2 = v0 + 2320;\n    for ( i = 3; *(_DWORD *)(v0 + 8) > i; ++i )\n    {\n      if ( *(_BYTE *)(v2 + 8) )\n      {\n        *(_WORD *)(*(_DWORD *)(v2 + 4) + 510) = -21931;\n        v4 = *(_DWORD *)(v2 + 4);\n        sub_807B370(*(_DWORD *)v2);\n        sub_804DCAD(*(_DWORD *)(v0 + 16), v4);\n      }\n      v2 += 20;\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  puts(\"Calling ioctl() to re-read partition table\");\n  sync();\n  sleep(1u);\n  v1 = sub_804E062(3, 0x125Fu, 0, \"WARNING: rereading partition table failed, kernel still uses old table\");\n  exit(v1 != 0);\n}\n"
    ],
    "sub_807B6C6": [
        "0x807b6c6",
        "int sub_807B6C6()\n{\n  int i; // ebx\n  unsigned int v1; // esi\n  int v2; // ebx\n  unsigned int v3; // eax\n  unsigned int v4; // edi\n  int v5; // edx\n  int v7[6]; // [esp+0h] [ebp-18h]\n\n  for ( i = 0; *(&off_80B6400 + i); ++i )\n    ;\n  v1 = (i + 2) / 3u;\n  v7[0] = v1;\n  v7[1] = v1 + ((i + 1 - v1) >> 1);\n  v7[2] = i;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  do\n  {\n    printf(\n      \"%c%2x %-22.22s\",\n      v2 == 0 ? 10 : 32,\n      *(unsigned __int8 *)*(&off_80B6400 + v3),\n      (const char *)*(&off_80B6400 + v3) + 1);\n    v5 = v2 + 1;\n    v3 = v4 + v7[v2];\n    if ( v2 + 1 <= 2 )\n    {\n      ++v2;\n      if ( v3 < v7[v5] )\n        continue;\n    }\n    v3 = ++v4;\n    v2 = 0;\n  }\n  while ( v4 < v1 );\n  return sub_804DD98(10);\n}\n"
    ],
    "sub_807B75A": [
        "0x807b75a",
        "unsigned int __usercall sub_807B75A@<eax>(\n        unsigned int a1@<eax>,\n        unsigned int a2@<edx>,\n        unsigned int a3@<ecx>,\n        int a4,\n        int a5)\n{\n  int v6; // eax\n  int v7; // ebx\n  const char *v8; // eax\n  char v9; // cl\n  unsigned int v10; // eax\n  int i; // esi\n  int v12; // edx\n  char v13; // dl\n  unsigned __int8 v14; // dl\n  char v15; // cl\n  unsigned __int64 v16; // rax\n  __int64 v17; // rax\n  unsigned int v18; // ecx\n  unsigned int result; // eax\n  char v20; // [esp+3h] [ebp-21h]\n  int v21; // [esp+4h] [ebp-20h]\n  char *format; // [esp+10h] [ebp-14h]\n\n  if ( a2 <= a3 && a2 >= a1 )\n  {\n    format = \"%s (%u-%u, default %u): \";\n    v21 = 1;\n    goto LABEL_5;\n  }\n  format = \"%s (%u-%u): \";\n  v21 = 0;\n  printf(\"%s (%u-%u): \", a5, a1, a3);\n  while ( 1 )\n  {\n    v6 = sub_807B55A();\n    v7 = dword_80DBB80;\n    if ( !v6 )\n    {\n      *(_DWORD *)dword_80DBB80 = dword_80DBB80 + 124;\n      *(_WORD *)(v7 + 124) = 10;\n    }\n    v8 = *(const char **)v7;\n    v9 = **(_BYTE **)v7;\n    v20 = v9;\n    if ( v9 == 10 || (unsigned __int8)(v9 - 48) <= 9u )\n    {\n      result = strtoul(v8, 0, 10);\n      i = v21;\n      while ( (unsigned __int8)(**(_BYTE **)v7 - 48) <= 9u )\n      {\n        ++*(_DWORD *)v7;\n        i = 0;\n      }\n      goto LABEL_32;\n    }\n    if ( v9 == 45 || v9 == 43 )\n      break;\nLABEL_5:\n    printf(format, a5, a1, a3, a2);\n  }\n  v10 = strtoul(v8 + 1, 0, 10);\n  for ( i = v21; ; i = 0 )\n  {\n    v12 = (*(_DWORD *)v7)++;\n    v13 = *(_BYTE *)(v12 + 1);\n    if ( (unsigned __int8)(v13 - 48) > 9u )\n      break;\n  }\n  v14 = v13 | 0x20;\n  if ( v14 == 107 )\n  {\n    v15 = 10;\n    goto LABEL_24;\n  }\n  if ( v14 > 0x6Bu )\n  {\n    if ( v14 == 109 )\n    {\n      v15 = 20;\n    }\n    else\n    {\n      if ( v14 != 116 )\n        goto LABEL_26;\n      v15 = 40;\n    }\nLABEL_24:\n    v16 = ((unsigned int)(*(_DWORD *)(v7 + 12) * *(_DWORD *)(v7 + 16)) >> 1) + ((unsigned __int64)v10 << v15);\n    v17 = sub_80B4B88(v16, HIDWORD(v16), *(_DWORD *)(v7 + 12) * *(_DWORD *)(v7 + 16), 0);\n    v18 = v17;\n    v10 = 0;\n    if ( __PAIR64__(HIDWORD(v17), v18) )\n      v10 = v18 - 1;\n    goto LABEL_26;\n  }\n  if ( v14 == 103 )\n  {\n    v15 = 30;\n    goto LABEL_24;\n  }\nLABEL_26:\n  if ( v20 == 45 )\n    v10 = -v10;\n  result = a4 + v10;\nLABEL_32:\n  if ( i )\n  {\n    printf(\"Using default value %u\\n\", a2);\n    result = a2;\n  }\n  if ( result > a3 || result < a1 )\n  {\n    puts(\"Value is out of range\");\n    goto LABEL_5;\n  }\n  return result;\n}\n"
    ],
    "sub_807B8F6": [
        "0x807b8f6",
        "unsigned int __usercall sub_807B8F6@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  unsigned int v3; // eax\n  unsigned int v4; // ebx\n\n  v3 = sub_807B75A(1u, 0, a2, 0, (int)\"Partition number\");\n  v4 = v3 - 1;\n  if ( a1 && !*(_BYTE *)(*(_DWORD *)(dword_80DBB80 + 20 * v4 + 2252) + 4) )\n    printf(\"Warning: partition %u has empty type\\n\", v3);\n  return v4;\n}\n"
    ],
    "sub_807B940": [
        "0x807b940",
        "unsigned int __usercall sub_807B940@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v3; // esi\n  int v4; // ebx\n  int v5; // eax\n  _BOOL4 v6; // eax\n  unsigned int v8; // [esp+0h] [ebp-10h]\n\n  v3 = 0;\n  v4 = -1;\n  while ( v3 != a2 )\n  {\n    v5 = *(_DWORD *)(dword_80DBB80 + 20 * v3 + 2252);\n    if ( v5 )\n    {\n      v8 = a2;\n      v6 = sub_807AF4F(v5);\n      a2 = v8;\n      if ( !v6 )\n      {\n        if ( v4 >= 0 )\n          return sub_807B8F6(a1, v8);\n        v4 = v3;\n      }\n    }\n    ++v3;\n  }\n  if ( v4 < 0 )\n  {\n    puts(\"No partition is defined yet!\");\n    return -1;\n  }\n  else\n  {\n    printf(\"Selected partition %u\\n\", v4 + 1);\n  }\n  return v4;\n}\n"
    ],
    "sub_807B9B3": [
        "0x807b9b3",
        "unsigned int sub_807B9B3()\n{\n  int v0; // ebx\n  int i; // esi\n  int v2; // eax\n\n  v0 = -1;\n  for ( i = 0; i != 4; ++i )\n  {\n    v2 = *(_DWORD *)(dword_80DBB80 + 20 * i + 2252);\n    if ( v2 && sub_807AF4F(v2) )\n    {\n      if ( v0 != -1 )\n        return sub_807B8F6(0, 4u);\n      v0 = i;\n    }\n  }\n  if ( v0 == -1 )\n    puts(\"All primary partitions have been defined already!\");\n  else\n    printf(\"Selected partition %u\\n\", v0 + 1);\n  return v0;\n}\n"
    ],
    "sub_807BA19": [
        "0x807ba19",
        "char __usercall sub_807BA19@<al>(unsigned int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // edi\n  unsigned int v4; // ebp\n  unsigned int v5; // ebx\n  __int16 v6; // dx\n  unsigned int v7; // edi\n  unsigned int v8; // edx\n  int v9; // ecx\n  unsigned int v10; // edx\n  unsigned int v11; // edi\n  unsigned int v12; // ebx\n  int v14; // [esp+0h] [ebp-3Ch]\n  int v15; // [esp+4h] [ebp-38h]\n  int v16; // [esp+8h] [ebp-34h]\n  int v17; // [esp+Ch] [ebp-30h]\n  int v18; // [esp+10h] [ebp-2Ch]\n  int v19; // [esp+14h] [ebp-28h]\n  int v20; // [esp+18h] [ebp-24h]\n  int v21; // [esp+1Ch] [ebp-20h]\n  int v22; // [esp+20h] [ebp-1Ch]\n  unsigned int v23; // [esp+24h] [ebp-18h]\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 + 28);\n  if ( v3 )\n  {\n    v4 = *(_DWORD *)(dword_80DBB80 + 32);\n    if ( a2 <= 3 )\n    {\n      if ( v4 )\n      {\n        v5 = a1;\n        LOBYTE(a1) = *(_BYTE *)(a1 + 2);\n        v14 = *(unsigned __int8 *)(v5 + 3) | (4 * (_WORD)a1) & 0x300;\n        HIBYTE(v6) = (unsigned __int16)((4 * a1) & 0x300) >> 8;\n        v15 = *(unsigned __int8 *)(v5 + 1);\n        v16 = a1 & 0x3F;\n        LOBYTE(v6) = *(_BYTE *)(v5 + 6);\n        v17 = *(unsigned __int8 *)(v5 + 7) | (4 * v6) & 0x300;\n        v18 = *(unsigned __int8 *)(v5 + 5);\n        v19 = v6 & 0x3F;\n        v7 = v4 * v3;\n        v8 = *(_DWORD *)(v5 + 8) % v7;\n        v21 = *(_DWORD *)(v5 + 8) / v7;\n        v22 = v8 / v4;\n        v20 = v8 % v4 + 1;\n        v9 = *(_DWORD *)(v5 + 12) + *(_DWORD *)(v5 + 8);\n        v23 = (v9 - 1) / v7;\n        a1 = (v9 - 1) % v7 / v4;\n        v10 = (v9 - 1) % v7 % v4;\n        v11 = a1;\n        v12 = v10 + 1;\n        if ( *(_DWORD *)(dword_80DBB80 + 36) <= 0x400u )\n        {\n          LOBYTE(a1) = v16 != v20;\n          if ( v16 != v20 || v15 != v22 || v14 != v21 )\n          {\n            printf(\"Partition %u has different physical/logical start (non-Linux?):\\n\", a2 + 1);\n            printf(\"     phys=(%u,%u,%u) \", v14, v15, v16);\n            LOBYTE(a1) = printf(\"logical=(%u,%u,%u)\\n\", v21, v22, v20);\n          }\n        }\n        if ( *(_DWORD *)(v2 + 36) <= 0x400u )\n        {\n          LOBYTE(a1) = v17 != v23;\n          if ( v17 != v23 || v19 != v12 || v18 != v11 )\n          {\n            printf(\"Partition %u has different physical/logical end:\\n\", a2 + 1);\n            printf(\"     phys=(%u,%u,%u) \", v17, v18, v19);\n            LOBYTE(a1) = printf(\"logical=(%u,%u,%u)\\n\", v23, v11, v12);\n          }\n        }\n      }\n    }\n  }\n  return a1;\n}\n"
    ],
    "sub_807BBA8": [
        "0x807bba8",
        "char __usercall sub_807BBA8@<al>(int a1@<eax>)\n{\n  int v1; // esi\n  char result; // al\n  __int16 v3; // dx\n  __int16 v4; // cx\n  unsigned __int8 **v5; // ebp\n  int i; // edi\n  unsigned __int8 *v7; // ebx\n\n  v1 = dword_80DBB80;\n  printf(\n    \"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n    *(const char **)(dword_80DBB80 + 4),\n    *(_DWORD *)(dword_80DBB80 + 28),\n    *(_DWORD *)(dword_80DBB80 + 32),\n    *(_DWORD *)(dword_80DBB80 + 36));\n  result = puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n  v5 = (unsigned __int8 **)(v1 + 2252);\n  for ( i = 0; *(_DWORD *)(v1 + 8) > i; ++i )\n  {\n    if ( a1 )\n      v7 = v5[1];\n    else\n      v7 = *v5;\n    result = i + 1;\n    if ( v7 )\n    {\n      LOBYTE(v3) = v7[6];\n      LOBYTE(v4) = v7[2];\n      result = printf(\n                 \"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n                 i + 1,\n                 *v7,\n                 v7[1],\n                 v4 & 0x3F,\n                 v7[3] | (4 * v4) & 0x300,\n                 v7[5],\n                 v3 & 0x3F,\n                 (4 * v3) & 0x300 | v7[7],\n                 *((_DWORD *)v7 + 2),\n                 *((_DWORD *)v7 + 3),\n                 v7[4]);\n      if ( v7[4] )\n        result = sub_807BA19((unsigned int)v7, i);\n    }\n    v5 += 5;\n  }\n  return result;\n}\n"
    ],
    "sub_807BC8E": [
        "0x807bc8e",
        "int sub_807BC8E()\n{\n  _DWORD *v0; // ebx\n  int v1; // eax\n  void *v2; // esp\n  void *v3; // esp\n  int result; // eax\n  unsigned __int8 *v5; // edi\n  unsigned __int8 v6; // al\n  int v7; // esi\n  unsigned __int8 v8; // al\n  unsigned int v9; // edx\n  unsigned int v10; // edi\n  int i; // edi\n  unsigned int v12; // edx\n  unsigned int v13; // ecx\n  unsigned int v14; // eax\n  unsigned int v15; // edx\n  unsigned int v16; // eax\n  unsigned int v17; // eax\n  unsigned int v18; // edx\n  int v19; // eax\n  unsigned int v20; // esi\n  int v21; // edi\n  int v22; // eax\n  int v23; // edx\n  unsigned int v24; // eax\n  int v25; // [esp-8h] [ebp-40h]\n  int v26[2]; // [esp+0h] [ebp-38h] BYREF\n  unsigned int v27; // [esp+8h] [ebp-30h]\n  unsigned int v28; // [esp+Ch] [ebp-2Ch]\n  int v29; // [esp+10h] [ebp-28h]\n  int v30; // [esp+14h] [ebp-24h]\n  unsigned __int8 **v31; // [esp+18h] [ebp-20h]\n  int v32; // [esp+1Ch] [ebp-1Ch]\n  int *v33; // [esp+20h] [ebp-18h]\n  int *v34; // [esp+24h] [ebp-14h]\n  unsigned int v35; // [esp+28h] [ebp-10h]\n\n  v26[1] = (int)v26;\n  v0 = (_DWORD *)dword_80DBB80;\n  v1 = 4 * *(_DWORD *)(dword_80DBB80 + 8) + 4;\n  v2 = alloca(v1);\n  v34 = v26;\n  v3 = alloca(v1);\n  v33 = v26;\n  result = sub_807B200();\n  if ( !result )\n  {\n    sub_807B080((int)v34, (int)v33);\n    v31 = (unsigned __int8 **)(v0 + 563);\n    v32 = 0;\n    v35 = 1;\n    while ( v32 < v0[2] )\n    {\n      v5 = *v31;\n      v6 = (*v31)[4];\n      v7 = v32 + 1;\n      if ( v6 != 0 && v6 != 15 && (v6 & 0x7F) != 5 )\n      {\n        sub_807BA19((unsigned int)v5, v32);\n        if ( v34[v7 - 1] > (unsigned int)&v31[2][*((_DWORD *)*v31 + 2)] )\n          printf(\"Warning: bad start-of-data in partition %u\\n\", v7);\n        v30 = v33[v7 - 1];\n        v8 = v5[6];\n        v29 = v8;\n        v9 = v5[5];\n        v28 = (v8 & 0x3F) - 1;\n        v10 = v5[7] | (4 * v8) & 0x300;\n        v27 = v9 + v0[7] * (v28 + v0[8] * v10);\n        if ( !v27 )\n        {\n          v26[0] = v9;\n          printf(\"Partition %u contains sector 0\\n\", v7);\n          v9 = v26[0];\n        }\n        if ( v9 >= v0[7] )\n          printf(\"Partition %u: head %u greater than maximum %u\\n\", v7, v9 + 1, v0[7]);\n        if ( v28 >= v0[8] )\n          printf(\"Partition %u: sector %u greater than maximum %u\\n\", v7, v29, v0[8]);\n        if ( v10 >= v0[9] )\n          printf(\"Partition %u: cylinder %u greater than maximum %u\\n\", v7, v10 + 1, v0[9]);\n        if ( v0[9] <= 0x400u && v30 != v27 )\n          printf(\"Partition %u: previous sectors %u disagrees with total %u\\n\", v7, v30, v27);\n        v35 = v35 + v33[v7 - 1] + 1 - v34[v7 - 1];\n        for ( i = 0; i != v32; ++i )\n        {\n          v12 = v34[v7 - 1];\n          v13 = v34[i];\n          v14 = v33[i];\n          if ( v12 < v13 || v12 > v14 )\n          {\n            v15 = v33[v7 - 1];\n            if ( v13 > v15 || v15 > v14 )\n              continue;\n          }\n          printf(\"Warning: partition %u overlaps partition %u\\n\", i + 1, v7);\n          v16 = v34[v7 - 1];\n          if ( v16 < v34[i] )\n            v16 = v34[i];\n          v17 = v35 + v16;\n          v18 = v33[v7 - 1];\n          if ( v18 > v33[i] )\n            v18 = v33[i];\n          v35 = v17 - v18;\n        }\n      }\n      v31 += 5;\n      v32 = v7;\n    }\n    if ( v0[20] )\n    {\n      v19 = v0[5 * v0[12] + 563];\n      v20 = *(_DWORD *)(v19 + 12) + *(_DWORD *)(v19 + 8) - 1;\n      v21 = 4;\n      while ( 1 )\n      {\n        v22 = v0[2];\n        if ( v21 >= v22 )\n          break;\n        ++v35;\n        v23 = v0[5 * v21++ + 563];\n        if ( *(_BYTE *)(v23 + 4) )\n        {\n          if ( (unsigned int)v34[v21 - 1] < v0[20] || v33[v21 - 1] > v20 )\n            printf(\"Logical partition %u not entirely in partition %u\\n\", v21, v0[12] + 1);\n        }\n        else if ( v22 > 5 || v21 != 5 )\n        {\n          printf(\"Warning: partition %u is empty\\n\", v21);\n        }\n      }\n    }\n    v24 = v0[9] * v0[8] * v0[7];\n    if ( v35 <= v24 )\n    {\n      result = v24 - v35;\n      if ( result )\n      {\n        printf(\"%u unallocated sectors\\n\", result);\n        return v25;\n      }\n    }\n    else\n    {\n      return printf(\"Total allocated sectors %u greater than CHS size %u\\n\", v35, v0[9] * v0[8] * v0[7]);\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_807BF56": [
        "0x807bf56",
        "char sub_807BF56()\n{\n  int v0; // esi\n  int v1; // eax\n  unsigned int v2; // edi\n  int v3; // ebx\n  int v4; // ebx\n  int i; // eax\n  __int16 v6; // dx\n  const char *v7; // ebx\n  signed int v8; // eax\n  int v9; // esi\n  int j; // ebp\n  int v11; // edi\n  unsigned __int8 *v12; // ebx\n  const char *v13; // edi\n  int v14; // edx\n  int v15; // ecx\n  size_t v16; // eax\n  char *v17; // edx\n  int v18; // eax\n  const char *v19; // edx\n  size_t v20; // eax\n  char v22; // [esp-4h] [ebp-74h]\n  char v23; // [esp-4h] [ebp-74h]\n  int v24; // [esp+0h] [ebp-70h]\n  int v25; // [esp+8h] [ebp-68h]\n  int v26; // [esp+Ch] [ebp-64h]\n  int v27; // [esp+10h] [ebp-60h]\n  char *v28; // [esp+14h] [ebp-5Ch]\n  size_t v29; // [esp+18h] [ebp-58h]\n  const char *v30; // [esp+20h] [ebp-50h]\n  char *v31; // [esp+24h] [ebp-4Ch]\n  char *v32; // [esp+28h] [ebp-48h]\n  size_t v33; // [esp+2Ch] [ebp-44h]\n  const char *v34; // [esp+2Ch] [ebp-44h]\n  char *v35; // [esp+30h] [ebp-40h]\n  char s[6]; // [esp+35h] [ebp-3Bh] BYREF\n  char v37[53]; // [esp+3Bh] [ebp-35h] BYREF\n\n  v0 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 40) == 5 )\n  {\n    *(_BYTE *)sub_80AD152(\" KMGTPEZY\") = 0;\n    printf(\"Disk %s: %llu sectors, %s\\n\", *(const char **)(v0 + 4), (unsigned __int64)*(unsigned int *)(v0 + 84), s);\n    printf(\"Logical sector size: %u\\n\", *(_DWORD *)(v0 + 16));\n    printf(\"Disk identifier (GUID): \");\n    printf(\n      \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n      *(unsigned __int8 *)(dword_80DB71C + 59),\n      *(unsigned __int8 *)(dword_80DB71C + 58),\n      *(unsigned __int8 *)(dword_80DB71C + 57),\n      *(unsigned __int8 *)(dword_80DB71C + 56),\n      *(unsigned __int8 *)(dword_80DB71C + 61),\n      *(unsigned __int8 *)(dword_80DB71C + 60),\n      *(unsigned __int8 *)(dword_80DB71C + 63),\n      *(unsigned __int8 *)(dword_80DB71C + 62),\n      *(unsigned __int8 *)(dword_80DB71C + 64),\n      *(unsigned __int8 *)(dword_80DB71C + 65),\n      *(unsigned __int8 *)(dword_80DB71C + 66),\n      *(unsigned __int8 *)(dword_80DB71C + 67),\n      *(unsigned __int8 *)(dword_80DB71C + 68),\n      *(unsigned __int8 *)(dword_80DB71C + 69),\n      *(unsigned __int8 *)(dword_80DB71C + 70),\n      *(unsigned __int8 *)(dword_80DB71C + 71));\n    printf(\"\\nPartition table holds up to %u entries\\n\", *(_DWORD *)(dword_80DB71C + 80));\n    printf(\n      \"First usable sector is %llu, last usable sector is %llu\\n\\n\",\n      *(_QWORD *)(dword_80DB71C + 40),\n      *(_QWORD *)(dword_80DB71C + 48));\n    LOBYTE(v1) = puts(\"Number  Start (sector)    End (sector)  Size Name\");\n    v2 = 0;\n    while ( v2 < dword_80DB714 )\n    {\n      v3 = dword_80DB718 + v2 * dword_80DB710;\n      ++v2;\n      LOBYTE(v1) = *(_DWORD *)(v3 + 32) | *(_DWORD *)(v3 + 36);\n      if ( *(_QWORD *)(v3 + 32) )\n      {\n        *(_BYTE *)sub_80AD152(\" KMGTPEZY\") = 0;\n        printf(\"%6u %15llu %15llu %s \", v2, *(_QWORD *)(v3 + 32), *(_QWORD *)(v3 + 40), s);\n        v4 = v3 + 56;\n        for ( i = 0; i != 36; ++i )\n        {\n          v6 = *(_WORD *)(v4 + 2 * i);\n          if ( !v6 )\n            break;\n          if ( (unsigned __int16)(v6 - 32) > 0x5Eu )\n            LOBYTE(v6) = 63;\n          v37[i] = v6;\n        }\n        v37[i] = 0;\n        v22 = (char)stdout;\n        fputs_unlocked();\n        sub_804DD98(10);\n        LOBYTE(v1) = v22;\n      }\n    }\n  }\n  else\n  {\n    sub_807B112();\n    v7 = *(const char **)(v0 + 4);\n    v8 = strlen(v7);\n    v9 = 7;\n    if ( v8 )\n    {\n      if ( (unsigned __int8)(v7[v8 - 1] - 48) <= 9u )\n        ++v8;\n      v9 = v8;\n      if ( v8 < 7 )\n        v9 = 7;\n    }\n    LOBYTE(v1) = printf(\n                   \"%-*s Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\\n\",\n                   v9 - 1,\n                   \"Device\");\n    for ( j = 0; ; ++j )\n    {\n      v11 = dword_80DBB80;\n      if ( j >= *(_DWORD *)(dword_80DBB80 + 8) )\n        break;\n      LOBYTE(v1) = 20 * j;\n      v12 = *(unsigned __int8 **)(dword_80DBB80 + 20 * j + 2252);\n      if ( v12 )\n      {\n        v1 = sub_807AF4F(*(_DWORD *)(dword_80DBB80 + 20 * j + 2252));\n        if ( !v1 )\n        {\n          sprintf(s, \"%02x\", *v12);\n          if ( (*v12 & 0x7F) == 0 )\n          {\n            s[0] = *v12 == 0 ? 32 : 42;\n            s[1] = 32;\n          }\n          v25 = *(_DWORD *)(*(_DWORD *)(v11 + 20 * j + 2252) + 8) + *(_DWORD *)(v11 + 20 * j + 2260);\n          v24 = *((_DWORD *)v12 + 3);\n          v27 = v25;\n          if ( v24 )\n            v27 = v25 + v24 - 1;\n          *(_BYTE *)sub_80AD152(\" KMGTPEZY\") = 0;\n          v26 = v12[4];\n          v30 = sub_807AF33(v12[4]);\n          v31 = sub_807B5BA(v12[7], v12[5], v12[6]);\n          v32 = sub_807B5BA(v12[3], v12[1], v12[2]);\n          v13 = *(const char **)(v11 + 4);\n          sub_804DB2E(0x50u);\n          v28 = (char *)sub_80A9707(v15, v14);\n          v16 = strlen(v13);\n          v29 = v16;\n          v17 = \"p\";\n          if ( (unsigned __int8)(v13[v16 - 1] - 48) > 9u )\n            v17 = (char *)&data;\n          v35 = v17;\n          v33 = v16 - 4;\n          v18 = strcmp(&v13[v16 - 4], \"disc\");\n          v19 = v35;\n          if ( !v18 )\n          {\n            v29 = v33;\n            v19 = \"part\";\n          }\n          v34 = v19;\n          v20 = strlen(v19);\n          snprintf(v28, 0x50u, \"%*.*s%s%-2u\", v9 - v20, v29, v13, v34, j + 1);\n          printf(\"%s%s %-11s %-11s %10u %10u %10u %s %2x %s\\n\", v28, s, v32, v31, v25, v27, v24, v37, v26, v30);\n          LOBYTE(v1) = sub_807BA19((unsigned int)v12, j);\n        }\n      }\n    }\n    if ( !*(_BYTE *)(dword_80DBB80 + 40) )\n    {\n      v1 = sub_807B02A(0);\n      if ( v1 )\n      {\n        puts(\"\\nPartition table entries are not in disk order\");\n        LOBYTE(v1) = v23;\n      }\n    }\n  }\n  return v1;\n}\n"
    ],
    "sub_807C371": [
        "0x807c371",
        "int __usercall sub_807C371@<eax>(int a1@<eax>)\n{\n  int v1; // ebp\n  int v2; // edx\n  int v3; // eax\n  int v4; // esi\n  char *v5; // eax\n  int v6; // eax\n  int v7; // eax\n  unsigned int v8; // eax\n  int v9; // ecx\n  unsigned int v10; // eax\n  int v11; // ebx\n  unsigned int v12; // ebx\n  unsigned int v13; // eax\n  size_t v14; // ebx\n  char *v15; // esi\n  int v16; // eax\n  int v17; // edi\n  int v18; // ebx\n  int v19; // esi\n  __int64 v20; // rax\n  int result; // eax\n  int v22; // eax\n  char v23; // dl\n  _DWORD *v24; // ebx\n  _DWORD *v25; // eax\n  int v26; // edx\n  int v27; // edi\n  int v28; // edi\n  _DWORD *v29; // eax\n  _DWORD *v30; // eax\n  int v31; // esi\n  _DWORD *v32; // ebx\n  char v33; // dl\n  int v34; // eax\n  int i; // esi\n  _BYTE *v36; // esi\n  int v37; // eax\n  int v38; // edx\n  int v39; // ecx\n  int v40; // ebx\n  int v42; // [esp+0h] [ebp-3Ch]\n  int v43; // [esp+4h] [ebp-38h]\n  int v44; // [esp+4h] [ebp-38h]\n  int v45; // [esp+8h] [ebp-34h]\n  int v46; // [esp+8h] [ebp-34h]\n  int v47; // [esp+Ch] [ebp-30h]\n  unsigned int v48; // [esp+14h] [ebp-28h] BYREF\n  unsigned __int64 v49; // [esp+18h] [ebp-24h] BYREF\n  _DWORD *v50; // [esp+24h] [ebp-18h]\n\n  v1 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 8) = 4;\n  v2 = v1 + 650;\n  v3 = v1 + 2252;\n  do\n  {\n    *(_DWORD *)v3 = v2;\n    *(_DWORD *)(v3 + 4) = 0;\n    *(_DWORD *)(v3 + 8) = 0;\n    *(_DWORD *)(v3 + 12) = v1 + 204;\n    *(_BYTE *)(v3 + 16) = a1 == 2;\n    v2 += 16;\n    v3 += 20;\n  }\n  while ( v1 + 2332 != v3 );\n  if ( a1 == 2 )\n    goto LABEL_76;\n  v4 = open64();\n  if ( v4 < 0 )\n  {\n    v4 = open64();\n    if ( v4 < 0 )\n    {\n      v5 = \"can't open '%s'\";\n      if ( a1 == 1 )\n        return 1;\nLABEL_40:\n      sub_807B34A(v5);\n    }\n    printf(\"'%s' is opened for read only\\n\", *(const char **)(v1 + 4));\n  }\n  sub_804DC97(v4, 3);\n  if ( sub_804E5E3(3, (char *)(v1 + 204), 0x200u) == 512 )\n  {\n    if ( !*(_DWORD *)(v1 + 20) )\n    {\n      if ( !ioctl(3, 0x1268u, &v49) )\n        *(_DWORD *)(v1 + 16) = v49;\n      if ( *(_DWORD *)(v1 + 16) != 512 )\n        printf(\"Note: sector size is %u (not 512)\\n\", *(_DWORD *)(v1 + 16));\n    }\n    v45 = *(_DWORD *)(v1 + 16) >> 9;\n    *(_DWORD *)(v1 + 32) = 0;\n    *(_DWORD *)(v1 + 36) = 0;\n    *(_DWORD *)(v1 + 28) = 0;\n    *(_DWORD *)(v1 + 76) = 0;\n    *(_DWORD *)(v1 + 72) = 0;\n    *(_DWORD *)(v1 + 68) = 0;\n    *(_DWORD *)(v1 + 64) = 0;\n    if ( !ioctl(3, 0x301u, &v49) )\n    {\n      *(_DWORD *)(v1 + 72) = (unsigned __int8)v49;\n      *(_DWORD *)(v1 + 76) = BYTE1(v49);\n    }\n    if ( *(_BYTE *)(v1 + 714) == 85 && *(_BYTE *)(v1 + 715) == 0xAA )\n    {\n      v16 = 0;\n      v43 = 0;\n      v17 = 0;\n      v18 = 0;\n      v19 = 1;\n      do\n      {\n        if ( *(_BYTE *)(v1 + v16 + 654) )\n        {\n          if ( v19 )\n          {\n            v17 = *(_BYTE *)(v1 + v16 + 656) & 0x3F;\n            v18 = *(unsigned __int8 *)(v1 + v16 + 655) + 1;\n            v19 = 0;\n          }\n          else if ( (*(_BYTE *)(v1 + v16 + 656) & 0x3F) != v17 || *(unsigned __int8 *)(v1 + v16 + 655) + 1 != v18 )\n          {\n            v43 = 1;\n          }\n        }\n        v16 += 16;\n      }\n      while ( v16 != 64 );\n      if ( !(v19 | v43) )\n      {\n        *(_DWORD *)(v1 + 64) = v18;\n        *(_DWORD *)(v1 + 68) = v17;\n      }\n    }\n    v6 = *(_DWORD *)(v1 + 56);\n    if ( !v6 )\n    {\n      v6 = *(_DWORD *)(v1 + 64);\n      if ( !v6 )\n      {\n        v6 = *(_DWORD *)(v1 + 72);\n        if ( !v6 )\n          v6 = 255;\n      }\n    }\n    *(_DWORD *)(v1 + 28) = v6;\n    v7 = *(_DWORD *)(v1 + 60);\n    if ( !v7 )\n    {\n      v7 = *(_DWORD *)(v1 + 68);\n      if ( !v7 )\n      {\n        v7 = *(_DWORD *)(v1 + 76);\n        if ( !v7 )\n          v7 = 63;\n      }\n    }\n    *(_DWORD *)(v1 + 32) = v7;\n    if ( ioctl(3, 0x80041272, &v49) )\n    {\n      if ( ioctl(3, 0x1260u, &v48) )\n      {\n        LODWORD(v20) = lseek64();\n        v48 = 0;\n        if ( v20 > 0 )\n          v48 = sub_80B4B88(v20, HIDWORD(v20), *(_DWORD *)(v1 + 16), 0);\n        lseek64();\n      }\n      v8 = v48;\n    }\n    else\n    {\n      v49 >>= 9;\n      if ( HIDWORD(v49) )\n      {\n        sub_804D5F4(\"device has more than 2^32 sectors, can't use all of them\");\n        v49 = 0xFFFFFFFFLL;\n      }\n      v8 = v49;\n    }\n    *(_DWORD *)(v1 + 84) = v8;\n    *(_DWORD *)(v1 + 24) = 1;\n    v9 = *(_DWORD *)(v1 + 32);\n    if ( *(_BYTE *)(v1 + 43) )\n      *(_DWORD *)(v1 + 24) = v9;\n    v10 = v8 / (v45 * *(_DWORD *)(v1 + 28) * v9);\n    *(_DWORD *)(v1 + 36) = v10;\n    if ( !v10 )\n      *(_DWORD *)(v1 + 36) = *(_DWORD *)(v1 + 52);\n    sub_807B008();\n    if ( *(_BYTE *)(v1 + 714) == 85\n      && *(_BYTE *)(v1 + 715) == 0xAA\n      && *(_BYTE *)(v1 + 654) == 0xEE\n      && (sub_807B39C((int)&v49, 1u), dword_80DB71C = (int)v50, v50[1] == 1414676816)\n      && *v50 == 541673029 )\n    {\n      if ( !dword_80DBB98 )\n        sub_80AA3E8();\n      v11 = *(_DWORD *)(dword_80DB71C + 16);\n      *(_DWORD *)(dword_80DB71C + 16) = 0;\n      if ( v11 != ~sub_80AA41E(dword_80DBB98) )\n        puts(\"\\nwarning: GPT header CRC is invalid\\n\");\n      v12 = *(_DWORD *)(dword_80DB71C + 80);\n      dword_80DB714 = v12;\n      v13 = *(_DWORD *)(dword_80DB71C + 84);\n      dword_80DB710 = v13;\n      if ( v12 <= 0x100 && v13 <= 0x1000 && *(_DWORD *)(dword_80DB71C + 12) <= *(_DWORD *)(v1 + 16) )\n      {\n        v14 = v13 * v12;\n        v15 = (char *)sub_804DAFA(v14);\n        dword_80DB718 = (int)v15;\n        sub_807B370(*(_DWORD *)(dword_80DB71C + 72));\n        if ( v14 != sub_804E5E3(3, v15, v14) )\n          goto LABEL_39;\n        if ( *(_DWORD *)(dword_80DB71C + 88) != ~sub_80AA41E(dword_80DBB98) )\n          puts(\"\\nwarning: GPT array CRC is invalid\\n\");\n        puts(\"Found valid GPT with protective MBR; using GPT\\n\");\n        *(_BYTE *)(v1 + 40) = 5;\n        return 0;\n      }\n      puts(\"\\nwarning: unable to parse GPT disklabel\\n\");\n      *(_BYTE *)(v1 + 40) = 0;\n    }\n    else\n    {\n      *(_BYTE *)(v1 + 40) = 0;\n    }\n    if ( *(_BYTE *)(v1 + 714) != 85 || *(_BYTE *)(v1 + 715) != 0xAA )\n    {\n      result = -1;\n      if ( a1 )\n        return result;\n      puts(\"Device contains neither a valid DOS partition table, nor Sun, SGI, OSF or GPT disklabel\");\n      sub_807CB4E();\n      return 0;\n    }\nLABEL_76:\n    sub_807B1D6();\n    sub_807B200();\n    v22 = 0;\n    do\n    {\n      v23 = *(_BYTE *)(*(_DWORD *)(v1 + 20 * v22 + 2252) + 4);\n      v46 = v22 + 1;\n      if ( (v23 & 0x7F) == 5 || v23 == 15 )\n      {\n        if ( *(_DWORD *)(v1 + 8) == 4 )\n        {\n          v24 = (_DWORD *)dword_80DBB80;\n          *(_DWORD *)(dword_80DBB80 + 48) = v22;\n          v25 = &v24[5 * v22];\n          v26 = v25[563];\n          v25[564] = v26;\n          v27 = v26;\n          if ( *(_DWORD *)(v26 + 8) )\n          {\n            while ( 1 )\n            {\n              v31 = v24[2];\n              if ( (*(_BYTE *)(v27 + 4) & 0x7F) != 5 && *(_BYTE *)(v27 + 4) != 15 )\n                break;\n              if ( v31 > 59 )\n              {\n                printf(\"Warning: deleting partitions after %u\\n\", v24[2]);\n                v32 = &v24[5 * v31 - 5];\n                *((_BYTE *)v32 + 2268) = 1;\n                sub_807B3F2((void *)v32[564]);\n                goto LABEL_117;\n              }\n              sub_807B39C((int)&v24[5 * v31 + 563], v24[20] + *(_DWORD *)(v27 + 8));\n              if ( !v24[20] )\n                v24[20] = *(_DWORD *)(v27 + 8);\n              v44 = v24[5 * v31 + 566];\n              v42 = v44 + 446;\n              v28 = v44 + 446;\n              v47 = 5 * v31;\n              do\n              {\n                if ( *(_DWORD *)(v28 + 12) )\n                {\n                  v33 = *(_BYTE *)(v28 + 4);\n                  if ( (v33 & 0x7F) == 5 || v33 == 15 )\n                  {\n                    if ( v24[v47 + 564] )\n                      printf(\"Warning: extra link pointer in partition table %u\\n\");\n                    else\n                      v24[v47 + 564] = v28;\n                  }\n                  else if ( v33 )\n                  {\n                    if ( v24[v47 + 563] )\n                      printf(\"Warning: ignoring extra data in partition table %u\\n\");\n                    else\n                      v24[v47 + 563] = v28;\n                  }\n                }\n                v28 += 16;\n              }\n              while ( v28 != v44 + 510 );\n              v29 = &v24[5 * v31];\n              if ( !v29[563] )\n              {\n                if ( v29[564] == v42 )\n                  v29[563] = v44 + 462;\n                else\n                  v29[563] = v42;\n              }\n              v30 = &v24[5 * v31];\n              if ( !v30[564] )\n              {\n                if ( v42 == v30[563] )\n                  v30[564] = v44 + 462;\n                else\n                  v30[564] = v42;\n              }\n              v27 = v24[5 * v31 + 564];\n              ++v24[2];\n            }\nLABEL_110:\n            v34 = v24[2];\n            for ( i = 4; i < v34; ++i )\n            {\n              if ( !*(_DWORD *)(v24[5 * i + 563] + 12) && (v34 > 5 || *(_BYTE *)(v24[583] + 4)) )\n              {\n                printf(\"Omitting empty partition (%u)\\n\", i + 1);\n                sub_807B407(i);\n                goto LABEL_110;\n              }\n            }\n          }\n          else\n          {\n            puts(\"Bad offset in primary extended partition\");\n          }\n        }\n        else\n        {\n          printf(\"Ignoring extra extended partition %u\\n\", v46);\n        }\n      }\nLABEL_117:\n      v22 = v46;\n    }\n    while ( v46 != 4 );\n    v36 = (_BYTE *)(v1 + 2324);\n    v37 = 3;\n    while ( *(_DWORD *)(v1 + 8) > v37 )\n    {\n      v38 = *(unsigned __int8 *)(*(_DWORD *)v36 + 510);\n      v39 = *(unsigned __int8 *)(*(_DWORD *)v36 + 511);\n      v40 = v37 + 1;\n      if ( __PAIR16__(v39, v38) != 0xAA55 )\n      {\n        printf(\n          \"Warning: invalid flag 0x%02x,0x%02x of partition table %u will be corrected by w(rite)\\n\",\n          v38,\n          v39,\n          v37 + 1);\n        v36[4] = 1;\n      }\n      v37 = v40;\n      v36 += 20;\n    }\n    return 0;\n  }\n  if ( a1 != 1 )\n  {\nLABEL_39:\n    v5 = \"can't read from %s\";\n    goto LABEL_40;\n  }\n  sub_807B0FC();\n  return 1;\n}\n"
    ],
    "sub_807CB4E": [
        "0x807cb4e",
        "int sub_807CB4E()\n{\n  int v0; // edx\n  int v1; // eax\n\n  printf(\n    \"Building a new %s. Changes will remain in memory only,\\n\"\n    \"until you decide to write them. After that the previous content\\n\"\n    \"won't be recoverable.\\n\"\n    \"\\n\",\n    \"DOS disklabel\");\n  v0 = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + 40) = 0;\n  *(_DWORD *)(v0 + 8) = 4;\n  v1 = 0;\n  memset((void *)(v0 + 650), 0, 0x40u);\n  *(_WORD *)(v0 + 714) = -21931;\n  *(_DWORD *)(v0 + 80) = 0;\n  do\n  {\n    *(_BYTE *)(v0 + v1 + 2268) = 0;\n    v1 += 20;\n  }\n  while ( v1 != 1200 );\n  *(_BYTE *)(v0 + 2268) = 1;\n  return sub_807C371(2);\n}\n"
    ],
    "sub_807CBB8": [
        "0x807cbb8",
        "int __usercall sub_807CBB8@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // eax\n  int result; // eax\n  FILE *v4; // ebx\n  _BYTE *v5; // eax\n  _BOOL4 v6; // edx\n  _DWORD *v7; // ebx\n  _BOOL4 v10; // [esp+8h] [ebp-D0h]\n  char v11; // [esp+1Ch] [ebp-BCh]\n  char s[108]; // [esp+6Ch] [ebp-6Ch] BYREF\n\n  v2 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 4) = a1;\n  result = _setjmp((struct __jmp_buf_tag *)(v2 + 88));\n  if ( result )\n    return result;\n  if ( !a2 && sub_804D210((_BYTE *)a1, \"/dev/hd\") )\n  {\n    snprintf(s, 0x64u, \"/proc/ide/%s/media\", (const char *)(a1 + 5));\n    v4 = (FILE *)sub_80B3D37();\n    if ( v4 && fgets_unlocked() )\n    {\n      v5 = sub_804D210(s, \"cdrom\");\n      v6 = 1;\n      if ( !v5 )\n        v6 = sub_804D210(s, \"tape\") != 0;\n      goto LABEL_13;\n    }\n    result = stat64();\n    if ( !result )\n    {\n      v6 = (v11 & 0x92) == 0;\n      if ( !v4 )\n        goto LABEL_14;\n      goto LABEL_13;\n    }\n    if ( v4 )\n    {\n      v6 = 0;\nLABEL_13:\n      v10 = v6;\n      result = fclose(v4);\n      v6 = v10;\nLABEL_14:\n      if ( v6 )\n        return result;\n    }\n  }\n  v7 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  result = sub_807C371(1);\n  if ( result <= 0 )\n  {\n    if ( result )\n    {\n      sub_807B112();\n      printf(\"Disk %s doesn't contain a valid partition table\\n\", (const char *)a1);\n    }\n    else\n    {\n      sub_807BF56();\n      if ( *(int *)(dword_80DBB80 + 8) > 4 )\n        sub_807B407(*(_DWORD *)(dword_80DBB80 + 48));\n    }\n    return sub_807B0FC();\n  }\n  else if ( a2 || *v7 == 13 )\n  {\n    return sub_804D3A5((int)\"can't open '%s'\", (const char *)a1);\n  }\n  return result;\n}\n"
    ],
    "sub_807CD1D": [
        "0x807cd1d",
        "int __fastcall sub_807CD1D(int a1)\n{\n  int result; // eax\n  int v2; // edi\n  int v3; // ebp\n  size_t v4; // eax\n  char v5; // [esp+0h] [ebp-164h] BYREF\n  char v6; // [esp+4h] [ebp-160h] BYREF\n  char v7; // [esp+8h] [ebp-15Ch] BYREF\n  char v8[4]; // [esp+Ch] [ebp-158h] BYREF\n  int v9; // [esp+10h] [ebp-154h]\n  char s[100]; // [esp+14h] [ebp-150h] BYREF\n  char v11[100]; // [esp+78h] [ebp-ECh] BYREF\n  char v12[136]; // [esp+DCh] [ebp-88h] BYREF\n\n  sub_80B3D18(a1, \"r\");\n  while ( 1 )\n  {\n    result = fgets_unlocked();\n    if ( !result )\n      return result;\n    if ( sscanf(s, \" %u %u %u %[^\\n ]\", &v5, &v6, &v7, v11) == 4 )\n    {\n      sprintf(v12, \"/dev/%s\", v11);\n      v2 = open64();\n      if ( v2 == -1 || (v3 = ioctl(v2, 0x301u, v8), close(v2), v3) )\n      {\n        v4 = strlen(v12);\n        if ( !v4 || (unsigned __int8)(v11[v4 + 99] - 48) > 9u )\nLABEL_7:\n          sub_807CBB8((int)v12, 0);\n      }\n      else if ( !v9 )\n      {\n        goto LABEL_7;\n      }\n    }\n  }\n}\n"
    ],
    "sub_807CDFD": [
        "0x807cdfd",
        "unsigned int __usercall sub_807CDFD@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  int v3; // esi\n  int v4; // eax\n  void *v5; // esp\n  void *v6; // esp\n  unsigned int result; // eax\n  unsigned int v8; // edi\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // eax\n  int i; // ecx\n  unsigned int v13; // esi\n  unsigned int v14; // eax\n  int v15; // edx\n  unsigned int v16; // esi\n  int k; // eax\n  int v18; // ecx\n  unsigned int v19; // ecx\n  unsigned int v20; // edi\n  unsigned int v21; // ecx\n  unsigned int v22; // eax\n  int v23; // ecx\n  int v24; // edx\n  int v25; // ecx\n  int m; // eax\n  unsigned int v27; // edx\n  unsigned int v28; // edx\n  unsigned int v29; // edi\n  const char *v30; // eax\n  unsigned int v31; // ecx\n  int v32; // edi\n  unsigned int v33; // edx\n  unsigned int v34; // eax\n  int v35; // edi\n  int v36; // eax\n  int v37; // edx\n  unsigned int v38; // edx\n  int v39; // eax\n  int v40; // ecx\n  int v41; // eax\n  char *v42; // eax\n  unsigned int v43; // eax\n  int v44; // [esp-8h] [ebp-138h]\n  int v45; // [esp+0h] [ebp-130h] BYREF\n  int v46; // [esp+4h] [ebp-12Ch]\n  int *v47; // [esp+8h] [ebp-128h]\n  int *v48; // [esp+Ch] [ebp-124h]\n  int v49; // [esp+10h] [ebp-120h]\n  int j; // [esp+14h] [ebp-11Ch]\n  int *v51; // [esp+18h] [ebp-118h]\n  int v52; // [esp+1Ch] [ebp-114h]\n  unsigned int v53; // [esp+20h] [ebp-110h]\n  char s[268]; // [esp+24h] [ebp-10Ch] BYREF\n\n  v52 = a1;\n  v46 = a2;\n  v47 = &v45;\n  v2 = dword_80DBB80;\n  v49 = *(_DWORD *)(dword_80DBB80 + 20 * a1 + 2252);\n  v3 = *(_DWORD *)(dword_80DBB80 + 20 * *(_DWORD *)(dword_80DBB80 + 48) + 2252);\n  v4 = 4 * *(_DWORD *)(dword_80DBB80 + 8) + 4;\n  v5 = alloca(v4);\n  v51 = &v45;\n  v6 = alloca(v4);\n  v48 = &v45;\n  if ( v49 && *(_BYTE *)(v49 + 4) )\n  {\n    printf(\"Partition %u is already defined, delete it before re-adding\\n\", v52 + 1);\n    return v44;\n  }\n  sub_807B080((int)v51, (int)v48);\n  if ( v52 > 3 )\n  {\n    v8 = *(_DWORD *)(v2 + 80) + *(_DWORD *)(v2 + 24);\n    v53 = *(_DWORD *)(v3 + 8) + *(_DWORD *)(v3 + 12) - 1;\n  }\n  else\n  {\n    v8 = *(_DWORD *)(v2 + 24);\n    if ( *(_BYTE *)(v2 + 41) || (v9 = *(_DWORD *)(v2 + 84), v53 = v9 - 1, !v9) )\n      v53 = *(_DWORD *)(v2 + 36) * *(_DWORD *)(v2 + 32) * *(_DWORD *)(v2 + 28) - 1;\n    v10 = *(_DWORD *)(v2 + 80);\n    if ( v10 )\n    {\n      v51[*(_DWORD *)(v2 + 48)] = v10;\n      v48[*(_DWORD *)(v2 + 48)] = *(_DWORD *)(v3 + 8) + *(_DWORD *)(v3 + 12) - 1;\n    }\n  }\n  if ( *(_BYTE *)(v2 + 41) )\n  {\n    for ( i = 0; ; ++i )\n    {\n      LOBYTE(j) = *(_BYTE *)(v2 + 41);\n      if ( i >= *(_DWORD *)(v2 + 8) )\n        break;\n      v13 = *(_DWORD *)(v2 + 12);\n      v14 = v51[i];\n      v15 = v14 - 1;\n      if ( (_BYTE)j )\n        v15 = v14 / v13;\n      v51[i] = v15 * v13;\n    }\n  }\n  v11 = \"cylinder\";\n  if ( !*(_BYTE *)(v2 + 41) )\n    v11 = \"single port, single-sector\" + 20;\n  snprintf(s, 0x100u, \"First %s\", v11);\nLABEL_20:\n  for ( j = 0; ; j = 1 )\n  {\n    v45 = *(_DWORD *)(v2 + 8);\n    v16 = v8;\n    for ( k = 0; k < v45; ++k )\n    {\n      if ( *(_DWORD *)(v2 + 20 * k + 2260) == v16 )\n        v16 += *(_DWORD *)(v2 + 24);\n      v18 = 0;\n      if ( v52 > 3 )\n        v18 = *(_DWORD *)(v2 + 24);\n      v19 = v48[k] + v18;\n      if ( v51[k] <= v16 && v19 >= v16 )\n        v16 = v19 + 1;\n    }\n    if ( v53 < v16 )\n      break;\n    if ( v8 + *(_DWORD *)(v2 + 12) > v16 )\n    {\n      if ( j )\n      {\n        v43 = v8;\n        v8 = v16;\n        v16 = v43;\n        goto LABEL_74;\n      }\nLABEL_36:\n      if ( v8 != v16 )\n      {\n        v8 = v16;\n        goto LABEL_20;\n      }\n      goto LABEL_38;\n    }\n    if ( !j )\n      goto LABEL_36;\n    printf(\"Sector %u is already allocated\\n\", v8);\nLABEL_38:\n    if ( *(_BYTE *)(v2 + 41) )\n    {\n      v20 = *(_DWORD *)(v2 + 12);\n      v21 = v53 / v20 + 1;\n      v22 = v16 / v20 + 1;\n    }\n    else\n    {\n      v22 = v16;\n      v21 = v53;\n    }\n    v8 = sub_807B75A(v22, v22, v21, 0, (int)s);\n    if ( *(_BYTE *)(v2 + 41) )\n    {\n      v8 = *(_DWORD *)(v2 + 12) * (v8 - 1);\n      if ( v16 >= v8 )\n        break;\n    }\nLABEL_74:\n    if ( v8 == v16 )\n      break;\n  }\n  if ( v52 > 4 )\n  {\n    v23 = *(_DWORD *)(v2 + 24);\n    v24 = v2 + 20 * v52;\n    *(_DWORD *)(v24 + 2260) = v16 - v23;\n    if ( v16 - v23 == *(_DWORD *)(v2 + 80) )\n    {\n      *(_DWORD *)(v24 + 2260) = v16 - v23 + 1;\n      if ( v23 == 1 )\n        ++v16;\n    }\n  }\n  v25 = *(_DWORD *)(v2 + 8);\n  for ( m = 0; m < v25; ++m )\n  {\n    v27 = *(_DWORD *)(v2 + 20 * m + 2260);\n    if ( v27 > v16 && v27 <= v53 )\n      v53 = v27 - 1;\n    v28 = v51[m];\n    if ( v53 >= v28 && v28 > v16 )\n      v53 = v28 - 1;\n  }\n  if ( v53 < v16 )\n  {\n    result = puts(\"No free sectors available\");\n    if ( v52 > 4 )\n      --*(_DWORD *)(v2 + 8);\n    return result;\n  }\n  if ( *(_BYTE *)(v2 + 41) )\n  {\n    v29 = *(_DWORD *)(v2 + 12);\n    v51 = (int *)v53;\n    if ( v16 / v29 + 1 != v53 / v29 + 1 )\n    {\n      v30 = \"cylinder\";\nLABEL_62:\n      snprintf(s, 0x100u, \"Last %s or +size{,K,M,G,T}\", v30);\n      if ( *(_BYTE *)(v2 + 41) )\n      {\n        v31 = *(_DWORD *)(v2 + 12);\n        v32 = v16 / v31 + 1;\n        v33 = v53 / v31 + 1;\n      }\n      else\n      {\n        v32 = v16;\n        v33 = v53;\n      }\n      v34 = sub_807B75A(v32, v33, v33, v32, (int)s);\n      v51 = (int *)v34;\n      if ( *(_BYTE *)(v2 + 41) )\n      {\n        v51 = (int *)(*(_DWORD *)(v2 + 12) * v34 - 1);\n        if ( (unsigned int)v51 > v53 )\n          v51 = (int *)v53;\n      }\n    }\n  }\n  else\n  {\n    v51 = (int *)v16;\n    v30 = \"single port, single-sector\" + 20;\n    if ( v53 != v16 )\n      goto LABEL_62;\n  }\n  v35 = v2 + 20 * v52;\n  v36 = *(_DWORD *)(v35 + 2252);\n  v37 = *(_DWORD *)(v35 + 2260);\n  *(_BYTE *)v36 = 0;\n  *(_BYTE *)(v36 + 4) = v46;\n  *(_DWORD *)(v36 + 8) = v16 - v37;\n  *(_DWORD *)(v36 + 12) = (char *)v51 + 1 - v16;\n  result = sub_807AF64((_BYTE *)v36, v16, (unsigned int)v51);\n  *(_BYTE *)(v35 + 2268) = 1;\n  if ( v52 > 4 )\n  {\n    v38 = *(_DWORD *)(v35 + 2260);\n    v53 = 20 * (v52 - 1) + v2;\n    v39 = *(_DWORD *)(v53 + 2256);\n    v40 = *(_DWORD *)(v2 + 80);\n    *(_BYTE *)v39 = 0;\n    *(_BYTE *)(v39 + 4) = 5;\n    *(_DWORD *)(v39 + 8) = v38 - v40;\n    *(_DWORD *)(v39 + 12) = (char *)v51 + 1 - v38;\n    sub_807AF64((_BYTE *)v39, v38, (unsigned int)v51);\n    result = v53;\n    *(_BYTE *)(v53 + 2268) = 1;\n  }\n  if ( v46 == 5 )\n  {\n    v41 = v52;\n    *(_DWORD *)(v2 + 48) = v52;\n    *(_DWORD *)(v2 + 20 * v41 + 2256) = v49;\n    *(_DWORD *)(v2 + 80) = v16;\n    *(_DWORD *)(v2 + 2340) = v16;\n    v42 = (char *)sub_804DB2E(*(_DWORD *)(v2 + 16));\n    *(_DWORD *)(v2 + 2344) = v42;\n    *(_DWORD *)(v2 + 2332) = v42 + 446;\n    result = (unsigned int)(v42 + 462);\n    *(_DWORD *)(v2 + 2336) = result;\n    *(_BYTE *)(v2 + 2348) = 1;\n    *(_DWORD *)(v2 + 8) = 5;\n  }\n  return result;\n}\n"
    ],
    "sub_807D31C": [
        "0x807d31c",
        "unsigned int sub_807D31C()\n{\n  int v0; // esi\n  int v1; // ebx\n  char *v2; // eax\n  int v3; // edx\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 8);\n  if ( v1 > 5 || *(_BYTE *)(*(_DWORD *)(dword_80DBB80 + 2332) + 4) )\n  {\n    v2 = (char *)sub_804DB2E(*(_DWORD *)(dword_80DBB80 + 16));\n    v3 = v0 + 20 * v1;\n    *(_DWORD *)(v3 + 2264) = v2;\n    *(_DWORD *)(v3 + 2252) = v2 + 446;\n    *(_DWORD *)(v3 + 2256) = v2 + 462;\n    *(_DWORD *)(v3 + 2260) = 0;\n    *(_BYTE *)(v3 + 2268) = 1;\n    ++*(_DWORD *)(v0 + 8);\n  }\n  return sub_807CDFD(*(_DWORD *)(v0 + 8) - 1, 131);\n}\n"
    ],
    "sub_807D386": [
        "0x807d386",
        "int __cdecl sub_807D386(int a1, int a2)\n{\n  _DWORD *v2; // ebp\n  char v3; // al\n  int v4; // ecx\n  int *v5; // ebx\n  int v6; // edx\n  unsigned __int8 v7; // al\n  unsigned int v8; // ebx\n  _BYTE *v9; // esi\n  char v10; // al\n  int v11; // eax\n  int v12; // eax\n  int i; // edx\n  const char *v14; // eax\n  unsigned __int8 v15; // al\n  int v16; // eax\n  int v17; // edx\n  unsigned int v18; // eax\n  int v19; // ebx\n  int v20; // esi\n  unsigned int v21; // eax\n  unsigned int v22; // edi\n  unsigned int v23; // eax\n  const char *v24; // eax\n  char *v25; // esi\n  int v26; // ebx\n  char v27; // al\n  int v28; // edi\n  unsigned int v29; // edx\n  unsigned int v30; // eax\n  unsigned int v31; // esi\n  unsigned int v32; // eax\n  int j; // esi\n  int v34; // edi\n  unsigned int k; // ebx\n  int v36; // eax\n  char *v37; // ebx\n  int v38; // eax\n  char *v39; // edx\n  void *v40; // eax\n  int v41; // eax\n  int m; // eax\n  int v43; // edx\n  int v44; // ecx\n  int *v45; // esi\n  _DWORD *v46; // esi\n  _DWORD *v47; // eax\n  _DWORD *v48; // edx\n  char *v49; // ebx\n  _DWORD *v50; // ecx\n  int v51; // esi\n  int n; // eax\n  unsigned int v53; // eax\n  unsigned int v54; // eax\n  int result; // eax\n  int v56; // [esp+8h] [ebp-78h]\n  unsigned int v57; // [esp+8h] [ebp-78h]\n  int v58; // [esp+8h] [ebp-78h]\n  char *v59; // [esp+8h] [ebp-78h]\n  char *v60; // [esp+8h] [ebp-78h]\n  int v61; // [esp+8h] [ebp-78h]\n  int v62; // [esp+Ch] [ebp-74h]\n  char *v63; // [esp+Ch] [ebp-74h]\n  int v64; // [esp+Ch] [ebp-74h]\n  void *v65; // [esp+10h] [ebp-70h]\n  char *v66; // [esp+10h] [ebp-70h]\n  int v67; // [esp+14h] [ebp-6Ch]\n  int v68; // [esp+1Ch] [ebp-64h] BYREF\n  char v69[16]; // [esp+20h] [ebp-60h] BYREF\n\n  v2 = sub_804DB2E(0xD7Cu);\n  dword_80DBB80 = (int)v2;\n  v2[4] = 512;\n  v2[6] = 1;\n  v2[2] = 4;\n  v2[3] = 1;\n  *((_BYTE *)v2 + 43) = 1;\n  sub_807B0FC();\n  v3 = sub_80ABEAC(a2, \"b:+C:+H:+lS:+u\", v2 + 4, v2 + 13, v2 + 14, v2 + 15);\n  v5 = (int *)(a2 + 4 * optind);\n  if ( (v3 & 1) != 0 )\n  {\n    v6 = v2[4];\n    if ( (unsigned int)(v6 - 512) > 0xFE00 )\n      goto LABEL_3;\n    v4 = v6 - 1;\n    if ( (v6 & (v6 - 1)) != 0 )\n      goto LABEL_3;\n    v2[6] = 2;\n    v2[5] = 1;\n  }\n  if ( (unsigned int)(v2[14] - 1) > 0xFE )\n    v2[14] = 0;\n  if ( (unsigned int)(v2[15] - 1) > 0x3E )\n    v2[15] = 0;\n  if ( (v3 & 0x20) != 0 )\n    *((_BYTE *)v2 + 41) = 0;\n  if ( (v3 & 8) == 0 )\n  {\n    if ( *v5 && !v5[1] )\n    {\n      v2[1] = *v5;\n      sub_807C371(0);\n      while ( 1 )\n      {\nLABEL_21:\n        sub_804DD98(10);\n        v7 = sub_807B5A1() | 0x20;\n        switch ( v7 )\n        {\n          case 'a':\n            if ( *((_BYTE *)v2 + 40) )\n              goto LABEL_35;\n            v8 = sub_807B8F6(1, v2[2]);\n            v9 = (_BYTE *)v2[5 * v8 + 563];\n            if ( ((v9[4] & 0x7F) == 5 || v9[4] == 15) && !*v9 )\n              printf(\"WARNING: Partition %u is an extended partition\\n\", v8 + 1);\n            *v9 = *v9 == 0 ? 0x80 : 0;\n            LOBYTE(v2[5 * v8 + 567]) = 1;\n            continue;\n          case 'b':\n          case 's':\n            continue;\n          case 'c':\n            if ( *((_BYTE *)v2 + 40) )\n            {\nLABEL_35:\n              printf(\"%c: unknown command\\n\");\n            }\n            else\n            {\n              v10 = 1 - *((_BYTE *)v2 + 43);\n              *((_BYTE *)v2 + 43) = v10;\n              if ( v10 )\n                v2[6] = v2[8];\n              else\n                v2[6] = 1;\n              printf(\"DOS Compatibility flag is %sset\\n\");\n            }\n            continue;\n          case 'd':\n            v11 = sub_807B940(1, v2[2]);\n            if ( v11 >= 0 )\n              sub_807B407(v11);\n            continue;\n          case 'i':\n            printf(\"%c: unknown command\\n\", 105);\n            goto LABEL_39;\n          case 'l':\nLABEL_39:\n            sub_807B6C6();\n            continue;\n          case 'm':\n            sub_807B26B();\n            continue;\n          case 'n':\n            v12 = sub_807B200();\n            if ( v12 )\n              continue;\n            for ( i = 0; i != 20; i += 5 )\n              v12 += *(_BYTE *)(v2[i + 563] + 4) == 0;\n            if ( v12 )\n            {\n              v14 = \"l   logical (5 or over)\";\n              if ( !v2[20] )\n                v14 = \"e   extended\";\n              snprintf(v69, 0x50u, \"Partition type\\n   p   primary partition (1-4)\\n   %s\\n\", v14);\n              while ( 2 )\n              {\n                v15 = sub_807B5A1();\n                if ( (v15 | 0x20) == 112 )\n                {\n                  v16 = sub_807B9B3();\n                  v17 = 131;\n                  if ( v16 >= 0 )\n                    goto LABEL_62;\n                }\n                else\n                {\n                  if ( v15 == 108 )\n                  {\n                    if ( v2[20] )\n                      goto LABEL_57;\nLABEL_63:\n                    printf(\"Invalid partition number for type '%c'\\n\", v15);\n                    continue;\n                  }\n                  if ( v15 != 101 || v2[20] )\n                    goto LABEL_63;\n                  v16 = sub_807B9B3();\n                  if ( v16 >= 0 )\n                  {\n                    v17 = 5;\nLABEL_62:\n                    sub_807CDFD(v16, v17);\n                  }\n                }\n                break;\n              }\n            }\n            else if ( (int)v2[2] <= 59 )\n            {\n              if ( v2[20] )\nLABEL_57:\n                sub_807D31C();\n              else\n                puts(\"You must delete some partition and add an extended partition first\");\n            }\n            else\n            {\n              puts(\"The maximum number of partitions has been created\");\n            }\n            break;\n          case 'o':\n            sub_807CB4E();\n            continue;\n          case 'p':\n            sub_807BF56();\n            continue;\n          case 'q':\n            sub_804DD98(10);\n            return 0;\n          case 't':\n            v18 = sub_807B940(0, v2[2]);\n            v19 = v18;\n            if ( v18 != -1 )\n            {\n              v20 = v2[5 * v18 + 563];\n              v56 = *(unsigned __int8 *)(v20 + 4);\n              if ( *(_BYTE *)(v20 + 4) || *(_DWORD *)(v20 + 12) )\n              {\n                do\n                {\n                  while ( 1 )\n                  {\n                    sub_807B5A1();\n                    if ( (*(_BYTE *)*v2 | 0x20) != 108 )\n                      break;\n                    sub_807B6C6();\n                  }\n                  v21 = sub_804ED6C(16, (const char *)*v2, 0, v19);\n                  v22 = v21;\n                }\n                while ( v21 > 0xFF );\n                if ( !v21 )\n                  puts(\n                    \"Type 0 means free space to many systems\\n\"\n                    \"(but not to Linux). Having partitions of\\n\"\n                    \"type 0 is probably unwise.\");\n                v23 = v22;\n                LOBYTE(v23) = v22 & 0x7F;\n                if ( (v23 == 5 || v22 == 15) == ((*(_BYTE *)(v20 + 4) & 0x7F) == 5 || *(_BYTE *)(v20 + 4) == 15) )\n                {\n                  if ( v56 != v22 )\n                  {\n                    *(_BYTE *)(v20 + 4) = v22;\n                    v24 = sub_807AF33(v22);\n                    printf(\"Changed system type of partition %u to %x (%s)\\n\", v19 + 1, v22, v24);\n                    LOBYTE(v2[5 * v19 + 567]) = 1;\n                  }\n                }\n                else\n                {\n                  puts(\"You cannot change a partition into an extended one or vice versa\");\n                }\n              }\n              else\n              {\n                printf(\"Partition %u does not exist yet!\\n\");\n              }\n            }\n            continue;\n          case 'u':\n            *((_BYTE *)v2 + 41) = *((_BYTE *)v2 + 41) == 0;\n            sub_807B008();\n            printf(\"Changing display/entry units to %s\\n\");\n            continue;\n          case 'v':\n            sub_807BC8E();\n            continue;\n          case 'w':\nLABEL_82:\n            sub_807B600();\n          case 'x':\nLABEL_84:\n            while ( 2 )\n            {\n              sub_804DD98(10);\n              switch ( (unsigned __int8)sub_807B5A1() | 0x20 )\n              {\n                case 'a':\n                case 'g':\n                case 'i':\n                case 'o':\n                case 'y':\n                  continue;\n                case 'b':\n                  if ( !*((_BYTE *)v2 + 40) )\n                  {\n                    v57 = sub_807B8F6(0, v2[2]);\n                    v25 = (char *)&v2[5 * v57];\n                    v26 = *((_DWORD *)v25 + 563);\n                    if ( !sub_807B200() )\n                    {\n                      v62 = *(_DWORD *)(v26 + 12);\n                      v27 = *(_BYTE *)(v26 + 4);\n                      if ( v27 == 15 || v27 == 0 || v62 == 0 || (v27 & 0x7F) == 5 )\n                      {\n                        printf(\"Partition %u has no data area\\n\", v57 + 1);\n                      }\n                      else\n                      {\n                        v28 = *(_DWORD *)(*((_DWORD *)v25 + 563) + 8) + *((_DWORD *)v25 + 565);\n                        v29 = sub_807B75A(0, v28, v62 + v28 - 1, v28, (int)\"New beginning of data\");\n                        if ( v28 != v29 )\n                        {\n                          v65 = (void *)v29;\n                          v30 = v29 - *((_DWORD *)v25 + 565);\n                          v31 = *(_DWORD *)(v26 + 8) + v62 - v30;\n                          *(_DWORD *)(v26 + 8) = v30;\n                          *(_DWORD *)(v26 + 12) = v31;\n                          sub_807B5A1();\n                          if ( (*(_BYTE *)*v2 | 0x20) == 121 )\n                            sub_807AF64((_BYTE *)v26, (unsigned int)v65, (unsigned int)v65 + v31 - 1);\n                          LOBYTE(v2[5 * v57 + 567]) = 1;\n                        }\n                      }\n                    }\n                  }\n                  continue;\n                case 'c':\n                  v32 = sub_807B75A(1u, v2[9], 0x100000u, 0, (int)&unk_80D28ED);\n                  v2[9] = v32;\n                  v2[13] = v32;\n                  if ( !*((_BYTE *)v2 + 40) )\n                    sub_807B1D6();\n                  continue;\n                case 'd':\n                  printf(\"Device: %s\\n\", (const char *)v2[1]);\n                  for ( j = 3; j < v2[2]; ++j )\n                  {\n                    v58 = v2[5 * j + 566];\n                    v34 = 0;\n                    for ( k = 0; k < v2[4]; ++k )\n                    {\n                      if ( !v34 )\n                        printf(\"0x%03X:\", k);\n                      printf(\" %02X\", *(unsigned __int8 *)(v58 + k));\n                      if ( v34 == 15 )\n                      {\n                        sub_804DD98(10);\n                        v34 = -1;\n                      }\n                      ++v34;\n                    }\n                    if ( v34 )\n                      sub_804DD98(10);\n                    sub_804DD98(10);\n                  }\n                  continue;\n                case 'e':\n                  v36 = 1;\n                  if ( *((_BYTE *)v2 + 40) )\n                    continue;\n                  goto LABEL_131;\n                case 'f':\n                  if ( *((_BYTE *)v2 + 40) )\n                    continue;\n                  if ( !sub_807B02A(0) )\n                  {\n                    puts(\"Ordering is already correct\\n\");\n                    continue;\n                  }\n                  while ( 1 )\n                  {\n                    v41 = sub_807B02A(&v68);\n                    if ( !v41 )\n                      goto LABEL_128;\n                    if ( v41 > 3 )\n                      break;\n                    v37 = (char *)&v2[5 * v41];\n                    v38 = *((_DWORD *)v37 + 564);\n                    v39 = (char *)&v2[5 * v68];\n                    *((_DWORD *)v37 + 564) = *((_DWORD *)v39 + 564);\n                    *((_DWORD *)v39 + 564) = v38;\n                    v40 = (void *)*((_DWORD *)v37 + 563);\n                    v63 = v39;\n                    v59 = (char *)*((_DWORD *)v39 + 563);\n                    qmemcpy(v69, v40, sizeof(v69));\n                    memmove(v40, v59, 0x10u);\n                    qmemcpy(v59, v69, 0x10u);\n                    v63[2268] = 1;\n                    v37[2268] = 1;\n                  }\n                  break;\n                case 'h':\n                  v53 = sub_807B75A(1u, v2[7], 0x100u, 0, (int)&unk_80D2938);\n                  v2[7] = v53;\n                  v2[14] = v53;\n                  sub_807B008();\n                  continue;\n                case 'p':\n                  v36 = 0;\nLABEL_131:\n                  sub_807BBA8(v36);\n                  continue;\n                case 'q':\n                  sub_804DD98(10);\n                  exit(0);\n                  return result;\n                case 'r':\n                  goto LABEL_21;\n                case 's':\n                  v54 = sub_807B75A(1u, v2[8], 0x3Fu, 0, (int)&unk_80D2948);\n                  v2[8] = v54;\n                  v2[15] = v54;\n                  if ( *((_BYTE *)v2 + 43) )\n                  {\n                    v2[6] = v54;\n                    puts(\"Warning: setting sector offset for DOS compatibility\");\n                  }\n                  sub_807B008();\n                  continue;\n                case 'v':\n                  sub_807BC8E();\n                  continue;\n                case 'w':\n                  goto LABEL_82;\n                default:\n                  puts(\"Command Action\");\n                  puts(\"b\\tmove beginning of data in a partition\");\n                  puts(\"c\\tchange number of cylinders\");\n                  puts(\"d\\tprint the raw data in the partition table\");\n                  puts(\"e\\tlist extended partitions\");\n                  puts(\"f\\tfix partition order\");\n                  puts(\"h\\tchange number of heads\");\n                  puts(\"p\\tprint the partition table\");\n                  puts(\"q\\tquit without saving changes\");\n                  puts(\"r\\treturn to main menu\");\n                  puts(\"s\\tchange number of sectors/track\");\n                  puts(\"v\\tverify the partition table\");\n                  puts(\"w\\twrite table to disk and exit\");\n                  continue;\n              }\n              break;\n            }\n            while ( 1 )\n            {\n              v45 = v2 + 590;\n              for ( m = 5; ; ++m )\n              {\n                if ( m >= v2[2] - 1 )\n                {\n                  while ( 1 )\n                  {\n                    v51 = v2[2];\n                    v50 = v2 + 583;\n                    v61 = 4;\n                    do\n                    {\n                      if ( v61 >= v51 - 1 )\n                      {\n                        for ( n = 4; v51 > n; ++n )\n                          LOBYTE(v2[5 * n + 567]) = 1;\nLABEL_128:\n                        puts(\"Done\");\n                        goto LABEL_84;\n                      }\n                      v47 = (_DWORD *)*v50;\n                      ++v61;\n                      v48 = (_DWORD *)v50[5];\n                      v64 = v50[2];\n                      v66 = (char *)v50[7];\n                      v67 = *(_DWORD *)(*v50 + 8) + v64;\n                      v49 = &v66[v48[2]];\n                      v50 += 5;\n                    }\n                    while ( v67 <= (int)v49 );\n                    qmemcpy(v69, v47, sizeof(v69));\n                    qmemcpy(v47, v48, 0x10u);\n                    qmemcpy(v48, v69, 0x10u);\n                    v47[2] = &v49[-v64];\n                    v48[2] = v67 - (_DWORD)v66;\n                  }\n                }\n                v43 = *v45;\n                v44 = v45[5];\n                v45 += 5;\n                if ( v43 > v44 )\n                  break;\n              }\n              v46 = &v2[5 * m];\n              v46[565] = v44;\n              v60 = (char *)&v2[5 * m + 5];\n              *((_DWORD *)v60 + 565) = v43;\n              *(_DWORD *)(v46[563] + 8) += v43 - v44;\n              *(_DWORD *)(*((_DWORD *)v60 + 563) + 8) += v44 - v43;\n              *(_DWORD *)(v2[5 * m + 559] + 8) = v44 - v2[20];\n              *(_DWORD *)(v46[564] + 8) = v43 - v2[20];\n            }\n          default:\n            printf(\"%c: unknown command\\n\", v7);\n            sub_807B26B();\n            continue;\n        }\n      }\n    }\nLABEL_3:\n    sub_804CDC2();\n  }\n  *((_BYTE *)v2 + 44) = 1;\n  if ( *v5 )\n  {\n    *((_BYTE *)v2 + 42) = 1;\n    do\n      sub_807CBB8(*v5++, 1);\n    while ( *v5 );\n  }\n  else\n  {\n    sub_807CD1D(v4);\n  }\n  return 0;\n}\n"
    ],
    "sub_807DD00": [
        "0x807dd00",
        "int __cdecl sub_807DD00(int a1, int a2)\n{\n  char v2; // di\n  const char **v3; // ebx\n  int v4; // ebp\n  const char **v5; // esi\n  const char *v6; // eax\n  int v7; // eax\n  int v8; // ebx\n\n  v2 = sub_80ABEC2(a2, \"^+sxnu\", \"shared\");\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( v3[1] )\n  {\n    v4 = open64();\n    if ( v4 < 0 )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 21 || (v4 = open64(), v4 < 0) )\n        sub_804D3C9((int)\"can't open '%s'\", *v3);\n    }\n  }\n  else\n  {\n    v4 = sub_80B4187(*v3);\n  }\n  v5 = v3 + 1;\n  v6 = v3[1];\n  if ( v6 && *v6 == 45 && (v6[1] == 99 && !v6[2] || !strcmp(v6 + 1, \"-command\")) )\n  {\n    v5 = v3 + 2;\n    if ( v3[3] )\n      sub_804D5E0(\"-c takes only one argument\");\n    v2 |= 0x10u;\n  }\n  v7 = v2 & 0xF;\n  if ( (v2 & 0xB) == 0 )\n    v7 |= 2u;\n  v8 = flock(v4, v7);\n  if ( v8 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 11 )\n      sub_80B0A23();\n    return 1;\n  }\n  else if ( *v5 )\n  {\n    if ( (v2 & 0x10) != 0 )\n    {\n      *(v5 - 2) = sub_80AB879();\n      *(v5 - 1) = \"-c\";\n      v5 -= 2;\n    }\n    v8 = sub_80B3C03(v5);\n    if ( v8 < 0 )\n      sub_804D3F1(*v5);\n  }\n  return v8;\n}\n"
    ],
    "sub_807DE2D": [
        "0x807de2d",
        "int __cdecl sub_807DE2D(int a1, int a2)\n{\n  const char *v2; // eax\n  int v3; // eax\n\n  v2 = (const char *)sub_80B2E5A();\n  v3 = sub_804DBE1(v2);\n  sub_804E029(v3, ident[1] == 114 ? 4705 : 587, 0, \"%s\", *(const char **)(a2 + 4));\n  return 0;\n}\n"
    ],
    "sub_807DE78": [
        "0x807de78",
        "int __cdecl sub_807DE78(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // eax\n\n  v2 = sub_80ABEC2(a2, &unk_80D2E74, \"freeze\");\n  v3 = sub_804DBE1(*(const char **)(a2 + 4 * optind));\n  sub_804E0BE(v3, -(v2 & 1) - 1073457032, 0, \"(opts & 1) ? FIFREEZE : FITHAW\");\n  return 0;\n}\n"
    ],
    "sub_807DEC0": [
        "0x807dec0",
        "int __cdecl sub_807DEC0(int a1, int a2)\n{\n  char v2; // bl\n  const char *v3; // ebp\n  int v4; // eax\n  int v6; // [esp+0h] [ebp-34h] BYREF\n  int v7; // [esp+4h] [ebp-30h] BYREF\n  int v8; // [esp+8h] [ebp-2Ch] BYREF\n  __int64 v9[5]; // [esp+Ch] [ebp-28h] BYREF\n\n  v2 = sub_80ABEC2(a2, \"^o:l:m:v\", \"offset\", &v6, &v7, &v8);\n  memset(v9, 0, 0x18u);\n  v9[1] = -1LL;\n  if ( (v2 & 1) != 0 )\n    v9[0] = sub_80B3F8E();\n  if ( (v2 & 2) != 0 )\n    v9[1] = sub_80B3F8E();\n  if ( (v2 & 4) != 0 )\n    v9[2] = sub_80B3F8E();\n  v3 = *(const char **)(a2 + 4 * optind);\n  v4 = sub_804DC1E(v3);\n  sub_804E0BE(v4, 0xC0185879, (int)v9, \"FITRIM\");\n  if ( (v2 & 8) != 0 )\n    printf(\"%s: %llu bytes trimmed\\n\", v3, v9[1]);\n  return 0;\n}\n"
    ],
    "sub_807DFA4": [
        "0x807dfa4",
        "char *__usercall sub_807DFA4@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  size_t v3; // eax\n  _BYTE *v4; // ebp\n  char *v5; // edx\n  int v6; // esi\n  char v7; // cl\n\n  v1 = a1;\n  if ( (dword_80DBB9C & 0x40) != 0 )\n    return sub_804DB46(a1);\n  v3 = strlen(a1);\n  v4 = sub_804DAFA(4 * v3 + 3);\n  v5 = v4 + 1;\n  *v4 = 39;\n  v6 = dword_80DBB9C & 0x8000;\n  while ( 1 )\n  {\n    v7 = *v1;\n    if ( !*v1 )\n      break;\n    if ( v7 == 39 )\n    {\n      *(_DWORD *)v5 = 656890919;\nLABEL_10:\n      v5 += 4;\n      goto LABEL_17;\n    }\n    if ( v6 )\n    {\n      if ( v7 == 33 )\n      {\n        *(_DWORD *)v5 = 656497703;\n        goto LABEL_10;\n      }\n      if ( v7 == 10 )\n      {\n        *(_WORD *)v5 = 28252;\n        v5 += 2;\n        goto LABEL_17;\n      }\n      if ( (unsigned __int8)(v7 - 9) <= 4u || v7 == 32 )\n      {\n        *(_WORD *)v5 = 23591;\n        v5[2] = v7;\n        v5[3] = 39;\n        goto LABEL_10;\n      }\n    }\n    *v5++ = v7;\nLABEL_17:\n    ++v1;\n  }\n  *(_WORD *)v5 = 39;\n  return v4;\n}\n"
    ],
    "sub_807E046": [
        "0x807e046",
        "int __usercall sub_807E046@<eax>(char *s@<ecx>, int argc@<edx>, char *const *a3@<eax>, struct option *longopts)\n{\n  int v7; // eax\n  int v8; // edx\n  const char *v9; // eax\n  char *v10; // eax\n  char *v11; // eax\n  char *const *v12; // ebx\n  const char *v13; // eax\n  char *v14; // eax\n  int v16; // [esp+0h] [ebp-1Ch]\n  int c; // [esp+4h] [ebp-18h]\n  int longind[5]; // [esp+8h] [ebp-14h] BYREF\n\n  if ( (dword_80DBB9C & 4) != 0 )\n    opterr = 0;\n  optind = 0;\n  v16 = 0;\n  while ( 1 )\n  {\n    v7 = (dword_80DBB9C & 0x80u) == 0\n       ? getopt_long(argc, a3, s, longopts, longind)\n       : getopt_long_only(argc, a3, s, longopts, longind);\n    v8 = v7;\n    if ( v7 == -1 )\n      break;\n    if ( v7 == 58 || v7 == 63 )\n    {\n      v16 = 1;\n    }\n    else if ( (dword_80DBB9C & 8) == 0 )\n    {\n      if ( v7 == 2 )\n      {\n        printf(\" --%s\", longopts[longind[0]].name);\n        if ( longopts[longind[0]].has_arg )\n          goto LABEL_17;\n      }\n      else\n      {\n        v9 = optarg;\n        if ( v8 == 1 )\n          goto LABEL_19;\n        c = v8;\n        printf(\" -%c\", v8);\n        v10 = strchr(s, c);\n        if ( v10 && v10[1] == 58 )\n        {\nLABEL_17:\n          v9 = optarg;\n          if ( !optarg )\n            v9 = &data;\nLABEL_19:\n          v11 = sub_807DFA4(v9);\n          printf(\" %s\", v11);\n        }\n      }\n    }\n  }\n  if ( (dword_80DBB9C & 8) == 0 )\n  {\n    printf(\" --\");\n    v12 = &a3[optind];\n    while ( 1 )\n    {\n      v13 = (const char *)*((_DWORD *)++v12 - 1);\n      if ( !v13 )\n        break;\n      v14 = sub_807DFA4(v13);\n      printf(\" %s\", v14);\n    }\n    sub_804DD98(10);\n  }\n  return v16;\n}\n"
    ],
    "sub_807E1A6": [
        "0x807e1a6",
        "int __cdecl sub_807E1A6(int a1, int a2)\n{\n  char *v2; // eax\n  const char *v3; // esi\n  size_t v5; // eax\n  char *v6; // eax\n  struct option *v7; // ebp\n  char *v8; // eax\n  char *v9; // edi\n  int v10; // esi\n  size_t v11; // eax\n  size_t v12; // edx\n  struct option *v13; // edx\n  char *v14; // esi\n  int v15; // edx\n  int v16; // ecx\n  char **v17; // eax\n  struct option *v18; // [esp+0h] [ebp-28h]\n  int v19; // [esp+0h] [ebp-28h]\n  char v20; // [esp+4h] [ebp-24h]\n  char *s; // [esp+8h] [ebp-20h] BYREF\n  int v22; // [esp+Ch] [ebp-1Ch] BYREF\n  char *s1; // [esp+10h] [ebp-18h] BYREF\n  int v24[5]; // [esp+14h] [ebp-14h] BYREF\n\n  s = 0;\n  v22 = 0;\n  v24[0] = 0;\n  v2 = getenv(\"GETOPT_COMPATIBLE\");\n  v3 = *(const char **)(a2 + 4);\n  if ( !v3 )\n  {\n    if ( v2 )\n    {\n      puts(\" --\");\n      return 0;\n    }\nLABEL_4:\n    sub_804D5E0(\"missing optstring argument\");\n  }\n  if ( *v3 == 45 && !v2 )\n  {\n    v20 = sub_80ABEC2(a2, \"+o:n:qQs:Tual:*\", \"options\", &s, &v22, &s1, v24);\n    v7 = 0;\n    while ( v24[0] )\n    {\n      v8 = (char *)sub_80AFB01(v18);\n      v9 = strtok(v8, \", \\t\\n\");\n      v10 = 0;\n      if ( v7 )\n      {\n        while ( v7[v10].name )\n          ++v10;\n      }\n      while ( v9 )\n      {\n        v11 = strlen(v9);\n        if ( v11 )\n        {\n          v12 = v11 - 1;\n          if ( v9[v11 - 1] == 58 )\n          {\n            v19 = 1;\n            if ( v11 != 1 && v9[v12 - 1] == 58 )\n            {\n              v12 = v11 - 2;\n              v19 = 2;\n            }\n            v9[v12] = 0;\n            if ( !v12 )\n              sub_804D5E0(\"empty long option specified\");\n          }\n          else\n          {\n            v19 = 0;\n          }\n          v7 = (struct option *)sub_80B4733(v10, 4100);\n          v13 = &v7[v10];\n          v13->has_arg = v19;\n          v13->val = 2;\n          v18 = v13;\n          v13->name = sub_804DB46(v9);\n          ++v10;\n        }\n        v9 = strtok(0, \", \\t\\n\");\n      }\n    }\n    if ( (v20 & 0x10) != 0 )\n    {\n      v14 = s1;\n      if ( strcmp(s1, \"bash\") )\n      {\n        if ( strcmp(v14, \"sh\") )\n        {\n          if ( !strcmp(v14, \"tcsh\") || !strcmp(v14, \"csh\") )\n            dword_80DBB9C |= 0x8000u;\n          else\n            sub_804D5F4(\"unknown shell '%s', assuming bash\");\n        }\n      }\n    }\n    if ( (v20 & 0x20) != 0 )\n    {\n      return 4;\n    }\n    else\n    {\n      v15 = optind - 1;\n      if ( !s )\n      {\n        s = *(char **)(a2 + 4 * optind);\n        if ( !s )\n          goto LABEL_4;\n        v15 = optind;\n      }\n      v16 = v22;\n      if ( !v22 )\n        v16 = *(_DWORD *)a2;\n      v17 = (char **)(a2 + 4 * v15);\n      *v17 = (char *)v16;\n      return sub_807E046(s, a1 - v15, v17, v7);\n    }\n  }\n  else\n  {\n    dword_80DBB9C |= 0x40u;\n    v5 = strspn(v3, \"-+\");\n    v6 = sub_804DB46(&v3[v5]);\n    *(_DWORD *)(a2 + 4) = *(_DWORD *)a2;\n    return sub_807E046(v6, a1 - 1, (char *const *)(a2 + 4), 0);\n  }\n}\n"
    ],
    "sub_807E3FB": [
        "0x807e3fb",
        "int __cdecl sub_807E3FB(int a1, char **argv)\n{\n  int v2; // ebx\n  int v3; // eax\n  int v4; // esi\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // ebp\n  int v9; // ecx\n  int v10; // ecx\n  const char *v11; // edx\n  FILE *v12; // ebp\n  int v13; // edx\n  int v14; // ecx\n  void *v15; // esi\n  _BYTE *v16; // eax\n  int v17; // ecx\n  int v19; // [esp-8h] [ebp-1Ch]\n  int v20; // [esp-4h] [ebp-18h]\n\n  v2 = sub_80AAA6C();\n  while ( 1 )\n  {\n    v3 = getopt(a1, argv, \"bcdoxCe:f:n:s:v\");\n    v4 = v3;\n    if ( v3 <= 0 )\n      break;\n    v5 = strchr(\"bcdoxCe:f:n:s:v\", v3);\n    v6 = v19;\n    v7 = v20;\n    if ( !v5 )\n      sub_804CDC2();\n    v8 = v5 - \"bcdoxCe:f:n:s:v\";\n    if ( v5 - \"bcdoxCe:f:n:s:v\" <= 4 )\n    {\n      sub_80AAFEF(v20, \"\\\"%07.7_Ax\\n\\\"\");\n      sub_80AAFEF(v9, off_80B7E64[v8]);\n    }\n    switch ( v4 )\n    {\n      case 'C':\n        sub_80AAFEF(v7, \"\\\"%08.8_Ax\\n\\\"\");\n        sub_80AAFEF(v10, \"\\\"%08.8_ax  \\\"8/1 \\\"%02x \\\"\\\"  \\\"8/1 \\\"%02x \\\"\");\n        v11 = \"\\\"  |\\\"16/1 \\\"%_p\\\"\\\"|\\n\\\"\";\n        goto LABEL_11;\n      case 'e':\n        v11 = optarg;\nLABEL_11:\n        sub_80AAFEF(v7, v11);\n        break;\n      case 'f':\n        v12 = (FILE *)sub_80B3D45(v7, v6);\n        while ( 1 )\n        {\n          v15 = (void *)sub_80AB85A();\n          if ( !v15 )\n            break;\n          v16 = (_BYTE *)sub_80B2E8C(v14, v13);\n          if ( *v16 )\n          {\n            if ( *v16 != 35 )\n              sub_80AAFEF(v17, v16);\n          }\n          free(v15);\n        }\n        fclose(v12);\n        break;\n      case 'n':\n        *(_DWORD *)(v2 + 8) = sub_80B4187(v7, v6);\n        break;\n      case 's':\n        *(_QWORD *)v2 = sub_80B3DD5(v7, 0, 0, 0, -1, 0x7FFFFFFF, &unk_80B7580);\n        break;\n      case 'v':\n        *(_BYTE *)(v2 + 12) = 0;\n        break;\n    }\n  }\n  if ( !*(_DWORD *)(v2 + 16) )\n  {\n    ((void (*)(void))sub_80AAFEF)();\n    ((void (*)(void))sub_80AAFEF)();\n  }\n  return sub_80AAA86(a1, &argv[optind]);\n}\n"
    ],
    "sub_807E579": [
        "0x807e579",
        "int __cdecl sub_807E579(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // ecx\n  char v4; // si\n  int v5; // esi\n  int v6; // ecx\n  int v7; // ecx\n  void *v8; // ebp\n  int v9; // ecx\n  unsigned int i; // edi\n  int v11; // ecx\n  int v12; // ecx\n  const char *v14; // [esp+Ch] [ebp-7Ch]\n  unsigned int v15; // [esp+10h] [ebp-78h]\n  int v16; // [esp+14h] [ebp-74h]\n  int v17; // [esp+18h] [ebp-70h] BYREF\n  int v18; // [esp+1Ch] [ebp-6Ch] BYREF\n  unsigned int v19; // [esp+20h] [ebp-68h] BYREF\n  unsigned int v20; // [esp+24h] [ebp-64h] BYREF\n  char v21[20]; // [esp+28h] [ebp-60h] BYREF\n\n  v19 = 2;\n  v20 = 0;\n  v2 = sub_80AAA6C();\n  v4 = sub_80ABEAC(a2, \"^l:s:apg:+c:+\", &v17, &v18, &v19, &v20);\n  v16 = a2 + 4 * optind;\n  *(_BYTE *)(v2 + 12) = 0;\n  if ( (v4 & 1) != 0 )\n    *(_DWORD *)(v2 + 8) = sub_80B4093(0x7FFFFFFF);\n  if ( (v4 & 2) != 0 )\n    *(_QWORD *)v2 = sub_80B3F1E(0, 0, -1, 0x7FFFFFFF);\n  v5 = v4 & 8;\n  if ( v5 )\n  {\n    if ( !v20 )\n      v20 = 30;\n    v19 = v20;\n  }\n  else\n  {\n    if ( !v20 )\n      v20 = 16;\n    sub_80AAFEF(v3, \"\\\"%08.8_ax: \\\"\");\n  }\n  if ( v19 && v19 < v20 )\n  {\n    if ( v19 != 1 )\n    {\n      v8 = sub_804DAFA(10 * v20);\n      v9 = (int)v8;\n      for ( i = 1; v20 >= i; ++i )\n        v9 = stpcpy();\n      sub_80AAFEF(v9, v8);\n      free(v8);\n      goto LABEL_22;\n    }\n    v15 = v20;\n    v14 = \"%u/1 \\\"%%02x \\\"\";\n  }\n  else\n  {\n    v15 = v20;\n    v14 = \"%u/1 \\\"%%02x\\\"\";\n  }\n  sprintf(v21, v14, v15, v16);\n  sub_80AAFEF(v6, v21);\nLABEL_22:\n  if ( v5 )\n  {\n    sub_80AAFEF(v7, \"\\\"\\n\\\"\");\n  }\n  else\n  {\n    sprintf(v21, \"\\\"  \\\"%u/1 \\\"%%_p\\\"\\\"\\n\\\"\", v20);\n    sub_80AAFEF(v11, v21);\n  }\n  return sub_80AAA86(v12, v16);\n}\n"
    ],
    "sub_807E710": [
        "0x807e710",
        "int __cdecl sub_807E710(int a1, int a2)\n{\n  char v2; // di\n  int v3; // esi\n  int v4; // eax\n  int v5; // ebp\n  struct tm *v6; // ecx\n  char *v7; // ebx\n  int v9; // [esp+0h] [ebp-58h] BYREF\n  struct timeval tv; // [esp+4h] [ebp-54h] BYREF\n  struct timezone v11; // [esp+Ch] [ebp-4Ch] BYREF\n  struct timeval v12; // [esp+14h] [ebp-44h] BYREF\n  struct tm tp; // [esp+1Ch] [ebp-3Ch] BYREF\n\n  v9 = 0;\n  tzset();\n  v2 = sub_80ABEC2(a2, \"^lurswtf:\", \"localtime\", &v9);\n  if ( (v2 & 3) != 0 )\n    v3 = v2 & 2;\n  else\n    v3 = sub_80B29EC(v9);\n  if ( (v2 & 8) != 0 )\n  {\n    v11.tz_minuteswest = timezone / 60;\n    v11.tz_dsttime = 0;\n    sub_80B2A42();\n    sub_80B2AC7();\n    tv.tv_sec = sub_80B2AF7();\n    tv.tv_usec = 0;\n    v4 = settimeofday(&tv, &v11);\nLABEL_6:\n    if ( v4 )\n      sub_804D3C9((int)\"settimeofday\");\n    return 0;\n  }\n  if ( (v2 & 0x10) == 0 )\n  {\n    if ( (v2 & 0x20) == 0 )\n    {\n      sub_80B2A42();\n      sub_80B2AC7();\n      tp.tm_sec = sub_80B2AF7();\n      v7 = ctime(&tp.tm_sec);\n      sub_80A9BE3();\n      printf(\"%s  0.000000 seconds\\n\", v7);\n      return 0;\n    }\n    gettimeofday(&v12, 0);\n    v6 = localtime(&v12.tv_sec);\n    tp.tm_sec = timezone / 60;\n    if ( v6->tm_isdst > 0 )\n      tp.tm_sec = timezone / 60 - 60;\n    tp.tm_min = 0;\n    gettimeofday(&v12, 0);\n    if ( !v3 )\n      v12.tv_sec += 60 * tp.tm_sec;\n    v4 = settimeofday(&v12, (const struct timezone *)&tp);\n    goto LABEL_6;\n  }\n  v5 = sub_80B2A42();\n  gettimeofday(&v12, 0);\n  if ( v3 )\n    gmtime_r(&v12.tv_sec, &tp);\n  else\n    localtime_r(&v12.tv_sec, &tp);\n  tp.tm_isdst = 0;\n  sub_804E0BE(v5, 0x4024700Au, (int)&tp, \"RTC_SET_TIME\");\n  return 0;\n}\n"
    ],
    "sub_807E8BC": [
        "0x807e8bc",
        "int __cdecl sub_807E8BC(int argc, char **argv)\n{\n  char *v2; // edx\n  char v3; // al\n  bool v4; // zf\n  int v5; // edi\n  const char **v6; // esi\n  int v7; // ebx\n  int v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // ebp\n  key_t v12; // eax\n  int v13; // eax\n  int v14; // edx\n  const char *v15; // eax\n  int v16; // eax\n  const char *v17; // ecx\n  int v18; // edx\n  const char *v19; // eax\n\n  if ( argc == 1 )\n    return 0;\n  v2 = argv[1];\n  v3 = *v2;\n  if ( *v2 == 109 )\n  {\n    if ( v2[1] != 115 )\n    {\nLABEL_34:\n      v7 = 0;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v10 = getopt(argc, argv, \"q:m:s:Q:M:S:\");\n          v11 = v10;\n          if ( v10 == -1 )\n          {\n            if ( optind == argc )\n              return v7;\nLABEL_12:\n            sub_804CDC2();\n          }\n          if ( v10 == 63 )\n            goto LABEL_12;\n          if ( (v10 & 0x20) == 0 )\n            break;\n          v13 = sub_80B40EC();\n          if ( v11 != 113 )\n          {\n            if ( v11 == 109 )\n              goto LABEL_55;\nLABEL_57:\n            v16 = semctl(v13, 0, 0, 0);\n            goto LABEL_58;\n          }\nLABEL_53:\n          v16 = msgctl(v13, 0, 0);\nLABEL_58:\n          if ( v16 )\n          {\n            v17 = \"t\\tchange a partition's system id\" + 30;\n            if ( (v11 & 0x20) == 0 )\n              v17 = \"error: '%s' is an unknown key\" + 26;\n            ++v7;\n            v18 = *(_DWORD *)dword_80DBB7C;\n            if ( *(_DWORD *)dword_80DBB7C == 13 )\n            {\nLABEL_68:\n              v19 = (const char *)&unk_80D31E2;\n              goto LABEL_70;\n            }\n            if ( *(int *)dword_80DBB7C <= 13 )\n            {\n              if ( v18 == 1 )\n                goto LABEL_68;\nLABEL_69:\n              v19 = \"unknown error in\";\n              goto LABEL_70;\n            }\n            v19 = \"invalid\";\n            if ( v18 != 22 )\n            {\n              v19 = \"already removed\";\n              if ( v18 != 43 )\n                goto LABEL_69;\n            }\nLABEL_70:\n            sub_804D5F4(\"%s %s (%s)\", v19, v17, optarg);\n          }\n        }\n        v12 = sub_80B40AC();\n        if ( v12 )\n        {\n          if ( (v11 | 0x20) != 113 )\n          {\n            if ( (v11 | 0x20) == 109 )\n            {\n              if ( shmget() < 0 )\n                goto LABEL_42;\nLABEL_55:\n              v16 = shmctl();\n              goto LABEL_58;\n            }\n            v13 = semget(v12, 0, 0);\n            if ( v13 < 0 )\n              goto LABEL_42;\n            goto LABEL_57;\n          }\n          v13 = msgget(v12, 0);\n          if ( v13 >= 0 )\n            goto LABEL_53;\nLABEL_42:\n          ++v7;\n          v14 = *(_DWORD *)dword_80DBB7C;\n          v15 = (const char *)&unk_80D31E2;\n          if ( *(_DWORD *)dword_80DBB7C != 13 )\n          {\n            v15 = \"already removed\";\n            if ( v14 != 43 )\n            {\n              v15 = \"invalid\";\n              if ( v14 != 2 )\n                v15 = \"unknown error in\";\n            }\n          }\n          sub_804D5F4(\"%s %s (%s)\", v15, \"key\", optarg);\n        }\n        else\n        {\n          ++v7;\n          sub_804D5F4(\"illegal key (%s)\", optarg);\n        }\n      }\n    }\n    v4 = v2[2] == 103;\n  }\n  else\n  {\n    if ( v3 != 115 )\n      goto LABEL_34;\n    v3 = v2[1];\n    if ( v3 != 101 && v3 != 104 )\n      goto LABEL_34;\n    v4 = v2[2] == 109;\n  }\n  if ( !v4 || v2[3] )\n    goto LABEL_34;\n  if ( argc <= 2 )\n    goto LABEL_12;\n  v5 = 0;\n  if ( v3 != 104 )\n  {\n    v5 = 2;\n    if ( v3 != 109 )\n      v5 = v3 == 101;\n  }\n  v6 = (const char **)(argv + 2);\n  v7 = 0;\n  while ( *v6 )\n  {\n    v8 = sub_804ED6C(10, *v6, 0, v7);\n    if ( *(_DWORD *)dword_80DBB7C || v8 < 0 )\n    {\n      sub_804D5F4(\"invalid id: %s\", *v6);\nLABEL_29:\n      ++v7;\n      goto LABEL_30;\n    }\n    if ( v5 == 1 )\n    {\n      v9 = semctl(v8, 0, 0, 0);\n    }\n    else if ( v5 == 2 )\n    {\n      v9 = msgctl(v8, 0, 0);\n    }\n    else\n    {\n      if ( v5 )\n        goto LABEL_30;\n      v9 = shmctl();\n    }\n    if ( v9 )\n    {\n      sub_804D3A5((int)\"can't remove id %s\", *v6);\n      goto LABEL_29;\n    }\nLABEL_30:\n    ++v6;\n  }\n  if ( v7 )\n    sub_80AB247();\n  puts(\"resource(s) deleted\");\n  return v7;\n}\n"
    ],
    "sub_807EB6D": [
        "0x807eb6d",
        "__int64 __usercall sub_807EB6D@<edx:eax>(int a1@<eax>, __uid_t *a2@<edx>)\n{\n  struct group *v3; // eax\n  __int64 v5; // [esp-8h] [ebp-Ch]\n\n  printf(\"%-10d %-10o\", a1, a2[5] & 0x1FF);\n  if ( getpwuid(a2[3]) )\n    printf(\" %-10s\");\n  else\n    printf(\" %-10d\");\n  if ( getgrgid(a2[4]) )\n    printf(\" %-10s\");\n  else\n    printf(\" %-10d\");\n  if ( getpwuid(a2[1]) )\n    printf(\" %-10s\");\n  else\n    printf(\" %-10d\");\n  v3 = getgrgid(a2[2]);\n  if ( v3 )\n    printf(\" %-10s\\n\", v3->gr_name);\n  else\n    printf(\" %-10d\\n\", a2[2]);\n  return v5;\n}\n"
    ],
    "sub_807EC1D": [
        "0x807ec1d",
        "int __usercall sub_807EC1D@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // ebp\n  int i; // esi\n  int v6; // ebx\n  struct passwd *v7; // eax\n  const char *v8; // eax\n  const char *v9; // eax\n  const char *v10; // eax\n  struct passwd *v11; // [esp+0h] [ebp-8Ch]\n  struct msqid_ds buf; // [esp+4h] [ebp-88h] BYREF\n  int v13; // [esp+60h] [ebp-2Ch]\n  int v14; // [esp+64h] [ebp-28h]\n  int v15; // [esp+6Ch] [ebp-20h]\n  int v16; // [esp+70h] [ebp-1Ch]\n\n  v2 = msgctl(0, 12, &buf);\n  if ( v2 < 0 )\n    return printf(\"kernel not configured for %s\\n\", \"message queues\");\n  v4 = v2;\n  switch ( a1 )\n  {\n    case 1:\n      result = msgctl(0, 3, &buf);\n      if ( result >= 0 )\n      {\n        printf(\"------ Message%s --------\\n\", \"s: Limits\");\n        return printf(\n                 \"max queues system wide = %d\\n\"\n                 \"max size of message (bytes) = %d\\n\"\n                 \"default max size of queue (bytes) = %d\\n\",\n                 buf.msg_perm.cgid,\n                 buf.msg_perm.gid,\n                 buf.msg_perm.cuid);\n      }\n      return result;\n    case 2:\n      printf(\"------ Message%s --------\\n\", \"s: Status\");\n      return printf(\n               \"allocated queues = %d\\nused headers = %d\\nused space = %d bytes\\n\",\n               buf.msg_perm.__key,\n               buf.msg_perm.uid,\n               *(_DWORD *)&buf.msg_perm.__seq);\n    case 3:\n      printf(\"------ Message%s --------\\n\", \" Queues: Creators/Owners\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s %-10s\\n\", \"msqid\", \"perms\", \"cuid\", \"cgid\", \"uid\", 135036634);\n      goto LABEL_10;\n    case 4:\n      printf(\"------ Message%s --------\\n\", \" Queues Send/Recv/Change Times\");\n      printf(\"%-8s %-10s %-20s %-20s %-20s\\n\", \"msqid\", \"owner\", \"send\", \"recv\", \"change\");\n      goto LABEL_10;\n    case 5:\n      printf(\"------ Message%s --------\\n\", \" Queues PIDs\");\n      printf(\"%-10s %-10s %-10s %-10s\\n\", \"msqid\", \"owner\", \"lspid\", \"lrpid\");\n      goto LABEL_10;\n    default:\n      printf(\"------ Message%s --------\\n\", \" Queues\");\n      printf(\"%-10s %-10s %-10s %-10s %-12s %-12s\\n\", 135069882, \"msqid\", \"owner\", \"perms\", \"used-bytes\", \"messages\");\nLABEL_10:\n      for ( i = 0; i <= v4; ++i )\n      {\n        result = msgctl(i, 11, (struct msqid_ds *)&buf.msg_perm.__unused2);\n        v6 = result;\n        if ( result >= 0 )\n        {\n          if ( a1 == 3 )\n          {\n            result = sub_807EB6D(result, &buf.msg_perm.__unused2);\n          }\n          else\n          {\n            v7 = getpwuid(buf.msg_stime);\n            if ( a1 == 4 )\n            {\n              if ( v7 )\n                printf(\"%-8d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-8d %-10d\", v6, buf.msg_stime);\n              v8 = \"Not set\";\n              if ( buf.msg_qbytes )\n                v8 = ctime((const time_t *)&buf.msg_qbytes) + 4;\n              printf(\" %-20.16s\", v8);\n              v9 = \"Not set\";\n              if ( buf.msg_lrpid )\n                v9 = ctime(&buf.msg_lrpid) + 4;\n              printf(\" %-20.16s\", v9);\n              v10 = \"Not set\";\n              if ( buf.__unused5 )\n                v10 = ctime((const time_t *)&buf.__unused5) + 4;\n              result = printf(\" %-20.16s\\n\", v10);\n            }\n            else if ( a1 == 5 )\n            {\n              if ( v7 )\n                printf(\"%-8d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-8d %-10d\", v6, buf.msg_stime);\n              result = printf(\"  %5d     %5d\\n\", v15, v16);\n            }\n            else\n            {\n              v11 = v7;\n              printf(\"0x%08x \", buf.msg_perm.__unused2);\n              if ( v11 )\n                printf(\"%-10d %-10.10s\", v6, v11->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, buf.msg_stime);\n              result = printf(\" %-10o %-12ld %-12ld\\n\", buf.msg_ctime & 0x1FF, v13, v14);\n            }\n          }\n        }\n      }\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_807EF34": [
        "0x807ef34",
        "int __usercall sub_807EF34@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // ebp\n  int i; // esi\n  int v6; // ebx\n  struct passwd *v7; // eax\n  const char *v8; // eax\n  const char *v9; // eax\n  const char *v10; // eax\n  const char *v11; // ecx\n  const char *v12; // edx\n  struct passwd *v13; // [esp+0h] [ebp-80h]\n  int v14; // [esp+4h] [ebp-7Ch]\n  int v15; // [esp+8h] [ebp-78h]\n  int v16; // [esp+Ch] [ebp-74h]\n  int v17; // [esp+10h] [ebp-70h]\n  int v18; // [esp+14h] [ebp-6Ch]\n  int v19; // [esp+18h] [ebp-68h]\n  __uid_t v20; // [esp+1Ch] [ebp-64h] BYREF\n  __uid_t uid; // [esp+20h] [ebp-60h]\n  int v22; // [esp+24h] [ebp-5Ch]\n  int v23; // [esp+2Ch] [ebp-54h]\n  int v24; // [esp+30h] [ebp-50h]\n  int v25; // [esp+40h] [ebp-40h]\n  time_t timer; // [esp+44h] [ebp-3Ch] BYREF\n  time_t v27; // [esp+4Ch] [ebp-34h] BYREF\n  time_t v28; // [esp+54h] [ebp-2Ch] BYREF\n  int v29; // [esp+5Ch] [ebp-24h]\n  int v30; // [esp+60h] [ebp-20h]\n  int v31; // [esp+64h] [ebp-1Ch]\n\n  v2 = shmctl();\n  if ( v2 < 0 )\n    return printf(\"kernel not configured for %s\\n\", \"shared memory\");\n  v4 = v2;\n  switch ( a1 )\n  {\n    case 1:\n      printf(\"------ Shared Memory %s --------\\n\", \"Limits\");\n      result = shmctl();\n      if ( result >= 0 )\n        return printf(\n                 \"max number of segments = %lu\\n\"\n                 \"max seg size (kbytes) = %lu\\n\"\n                 \"max total shared memory (pages) = %lu\\n\"\n                 \"min seg size (bytes) = %lu\\n\",\n                 v22,\n                 v20 >> 10,\n                 v23,\n                 uid);\n      return result;\n    case 2:\n      printf(\"------ Shared Memory %s --------\\n\", \"Status\");\n      return printf(\n               \"segments allocated %d\\n\"\n               \"pages allocated %lu\\n\"\n               \"pages resident  %lu\\n\"\n               \"pages swapped   %lu\\n\"\n               \"Swap performance: %lu attempts\\t%lu successes\\n\",\n               v14,\n               v15,\n               v16,\n               v17,\n               v18,\n               v19);\n    case 3:\n      printf(\"------ Shared Memory %s --------\\n\", \"Segment Creators/Owners\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s %-10s\\n\", \"shmid\", \"perms\", \"cuid\", \"cgid\", \"uid\", \"gid\");\n      goto LABEL_9;\n    case 4:\n      printf(\"------ Shared Memory %s --------\\n\", \"Attach/Detach/Change Times\");\n      printf(\"%-10s %-10s %-20s %-20s %-20s\\n\", \"shmid\", \"owner\", \"attached\", \"detached\", \"changed\");\n      goto LABEL_9;\n    case 5:\n      printf(\"------ Shared Memory %s --------\\n\", \"Creator/Last-op\");\n      printf(\"%-10s %-10s %-10s %-10s\\n\", \"shmid\", \"owner\", \"cpid\", \"lpid\");\n      goto LABEL_9;\n    default:\n      printf(\"------ Shared Memory %s --------\\n\", \"Segments\");\n      printf(\n        \"%-10s %-10s %-10s %-10s %-10s %-10s %-12s\\n\",\n        \"key\",\n        \"shmid\",\n        \"owner\",\n        \"perms\",\n        \"bytes\",\n        \"nattch\",\n        \"status\");\nLABEL_9:\n      for ( i = 0; i <= v4; ++i )\n      {\n        result = shmctl();\n        v6 = result;\n        if ( result >= 0 )\n        {\n          if ( a1 == 3 )\n          {\n            result = sub_807EB6D(result, &v20);\n          }\n          else\n          {\n            v7 = getpwuid(uid);\n            if ( a1 == 4 )\n            {\n              if ( v7 )\n                printf(\"%-10d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, uid);\n              v8 = \"Not set\";\n              if ( timer )\n                v8 = ctime(&timer) + 4;\n              printf(\" %-20.16s\", v8);\n              v9 = \"Not set\";\n              if ( v27 )\n                v9 = ctime(&v27) + 4;\n              printf(\" %-20.16s\", v9);\n              v10 = \"Not set\";\n              if ( v28 )\n                v10 = ctime(&v28) + 4;\n              result = printf(\" %-20.16s\\n\", v10);\n            }\n            else if ( a1 == 5 )\n            {\n              if ( v7 )\n                printf(\"%-10d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, uid);\n              result = printf(\" %-10d %-10d\\n\", v29, v30);\n            }\n            else\n            {\n              v13 = v7;\n              printf(\"0x%08x \", v20);\n              if ( v13 )\n                printf(\"%-10d %-10.10s\", v6, v13->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, uid);\n              v11 = \"password for %s is already %slocked\" + 29;\n              if ( (v24 & 0x400) == 0 )\n                v11 = \"        \" + 7;\n              v12 = \"dest\";\n              if ( (v24 & 0x200) == 0 )\n                v12 = \"        \" + 7;\n              result = printf(\" %-10o %-10lu %-10ld %-6s %-6s\\n\", v24 & 0x1FF, v25, v31, v12, v11);\n            }\n          }\n        }\n      }\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_807F294": [
        "0x807f294",
        "struct passwd *__usercall sub_807F294@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  struct passwd *result; // eax\n  int v4; // ebp\n  int i; // esi\n  struct passwd *v6; // ebx\n  char *v7; // eax\n  char *v8; // eax\n  struct passwd *v9; // [esp+0h] [ebp-7Ch]\n  char v10[4]; // [esp+4h] [ebp-78h] BYREF\n  int v11; // [esp+8h] [ebp-74h]\n  int v12; // [esp+Ch] [ebp-70h]\n  int v13; // [esp+14h] [ebp-68h]\n  int v14; // [esp+18h] [ebp-64h]\n  int v15; // [esp+20h] [ebp-5Ch]\n  int v16; // [esp+24h] [ebp-58h]\n  int v17; // [esp+28h] [ebp-54h]\n  __uid_t v18; // [esp+2Ch] [ebp-50h] BYREF\n  __uid_t uid; // [esp+30h] [ebp-4Ch]\n  int v20; // [esp+40h] [ebp-3Ch]\n  time_t timer; // [esp+50h] [ebp-2Ch] BYREF\n  time_t v22; // [esp+58h] [ebp-24h] BYREF\n  int v23; // [esp+60h] [ebp-1Ch]\n\n  v2 = semctl(0, 0, 19, v10);\n  if ( v2 < 0 )\n    return (struct passwd *)printf(\"kernel not configured for %s\\n\", \"semaphores\");\n  v4 = v2;\n  switch ( a1 )\n  {\n    case 1:\n      printf(\"------ Semaphore %s --------\\n\", \"Limits\");\n      result = (struct passwd *)semctl(0, 0, 3, v10);\n      if ( (int)result >= 0 )\n        return (struct passwd *)printf(\n                                  \"max number of arrays = %d\\n\"\n                                  \"max semaphores per array = %d\\n\"\n                                  \"max semaphores system wide = %d\\n\"\n                                  \"max ops per semop call = %d\\n\"\n                                  \"semaphore max value = %d\\n\",\n                                  v11,\n                                  v13,\n                                  v12,\n                                  v14,\n                                  v16);\n      return result;\n    case 2:\n      printf(\"------ Semaphore %s --------\\n\", \"Status\");\n      return (struct passwd *)printf(\"used arrays = %d\\nallocated semaphores = %d\\n\", v15, v17);\n    case 3:\n      printf(\"------ Semaphore %s --------\\n\", \"Arrays Creators/Owners\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s %-10s\\n\", \"semid\", \"perms\", \"cuid\", \"cgid\", \"uid\", \"gid\");\n      goto LABEL_9;\n    case 4:\n      printf(\"------ Shared Memory %s --------\\n\", \"Operation/Change Times\");\n      printf(\"%-8s %-10s %-26.24s %-26.24s\\n\", \"shmid\", \"owner\", \"last-op\", \"last-changed\");\n      goto LABEL_9;\n    case 5:\n      goto LABEL_9;\n    default:\n      printf(\"------ Semaphore %s --------\\n\", \"Arrays\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s\\n\", \"key\", \"semid\", \"owner\", \"perms\", \"nsems\");\nLABEL_9:\n      for ( i = 0; i <= v4; ++i )\n      {\n        result = (struct passwd *)semctl(i, 0, 18, &v18);\n        v6 = result;\n        if ( (int)result >= 0 )\n        {\n          if ( a1 == 3 )\n          {\n            result = (struct passwd *)sub_807EB6D((int)result, &v18);\n          }\n          else\n          {\n            result = getpwuid(uid);\n            if ( a1 == 4 )\n            {\n              if ( result )\n                printf(\"%-8d %-10.10s\", v6, result->pw_name);\n              else\n                printf(\"%-8d %-10d\", v6, uid);\n              v7 = \"Not set\";\n              if ( timer )\n                v7 = ctime(&timer);\n              printf(\"  %-26.24s\", v7);\n              v8 = \"Not set\";\n              if ( v22 )\n                v8 = ctime(&v22);\n              result = (struct passwd *)printf(\" %-26.24s\\n\", v8);\n            }\n            else if ( a1 != 5 )\n            {\n              v9 = result;\n              printf(\"0x%08x \", v18);\n              if ( v9 )\n                printf(\"%-10d %-10.9s\", v6, v9->pw_name);\n              else\n                printf(\"%-10d %-9d\", v6, uid);\n              result = (struct passwd *)printf(\" %-10o %-10ld\\n\", v20 & 0x1FF, v23);\n            }\n          }\n        }\n      }\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_807F510": [
        "0x807f510",
        "void __cdecl __noreturn sub_807F510(int a1, int a2)\n{\n  unsigned int v2; // edi\n  int v3; // ebx\n  int v4; // ebx\n  unsigned int v5; // esi\n  char *v6; // eax\n  char *v7; // eax\n  char *v8; // eax\n  char *v9; // eax\n  char *v10; // eax\n  int v11; // ebp\n  int v12; // eax\n  char *v13; // eax\n  char *v14; // eax\n  char *v15; // eax\n  int v16; // [esp+0h] [ebp-74h]\n  int v17; // [esp+4h] [ebp-70h]\n  int v18; // [esp+8h] [ebp-6Ch] BYREF\n  struct msqid_ds buf; // [esp+Ch] [ebp-68h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"i:aqsmtcplu\", &v18);\n  v3 = (v2 >> 3) & 4;\n  if ( (v2 & 0x40) != 0 )\n    v3 = 3;\n  if ( (v2 & 0x80) != 0 )\n    v3 = 5;\n  if ( (v2 & 0x100) != 0 )\n    v3 = 1;\n  if ( (v2 & 0x200) != 0 )\n    v3 = 2;\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = sub_80B4170();\n    v5 = v2 & 0x10;\n    if ( (v2 & 0x10) != 0 )\n    {\n      if ( shmctl() == -1 )\n      {\n        sub_804D3A5((int)\"shmctl\");\n      }\n      else\n      {\n        printf(\n          \"\\n\"\n          \"Shared memory Segment shmid=%d\\n\"\n          \"uid=%d\\tgid=%d\\tcuid=%d\\tcgid=%d\\n\"\n          \"mode=%#o\\taccess_perms=%#o\\n\"\n          \"bytes=%ld\\tlpid=%d\\tcpid=%d\\tnattch=%ld\\n\",\n          v4,\n          buf.msg_perm.uid,\n          buf.msg_perm.gid,\n          buf.msg_perm.cuid,\n          buf.msg_perm.cgid,\n          buf.msg_perm.mode,\n          buf.msg_perm.mode & 0x1FF,\n          buf.msg_stime,\n          buf.msg_qbytes,\n          buf.msg_qnum,\n          buf.msg_lspid);\n        v6 = \"Not set\";\n        if ( buf.__unused1 )\n          v6 = ctime((const time_t *)&buf.__unused1);\n        printf(\"att_time=%-26.24s\\n\", v6);\n        v7 = \"Not set\";\n        if ( buf.__unused2 )\n          v7 = ctime((const time_t *)&buf.__unused2);\n        printf(\"det_time=%-26.24s\\n\", v7);\n        v8 = ctime((const time_t *)&buf.__unused3);\n        printf(\"change_time=%-26.24s\\n\\n\", v8);\n      }\n      goto LABEL_18;\n    }\n    if ( (v2 & 8) != 0 )\n    {\n      if ( semctl(v4, 0, 2, &buf) )\n      {\n        sub_804D3A5((int)\"semctl\");\n        goto LABEL_18;\n      }\n      v9 = \"Not set\";\n      if ( buf.msg_stime )\n        v9 = ctime(&buf.msg_stime);\n      printf(\n        \"\\n\"\n        \"Semaphore Array semid=%d\\n\"\n        \"uid=%d\\t gid=%d\\t cuid=%d\\t cgid=%d\\n\"\n        \"mode=%#o, access_perms=%#o\\n\"\n        \"nsems = %ld\\n\"\n        \"otime = %-26.24s\\n\",\n        v4,\n        buf.msg_perm.uid,\n        buf.msg_perm.gid,\n        buf.msg_perm.cuid,\n        buf.msg_perm.cgid,\n        buf.msg_perm.mode,\n        buf.msg_perm.mode & 0x1FF,\n        buf.msg_ctime,\n        v9);\n      v10 = ctime(&buf.msg_rtime);\n      printf(\"ctime = %-26.24s\\n%-10s %-10s %-10s %-10s %-10s\\n\", v10, \"semnum\", \"value\", \"ncount\", \"zcount\", \"pid\");\n      while ( v5 < buf.msg_ctime )\n      {\n        v16 = semctl(v4, v5, 12, 0);\n        v17 = semctl(v4, v5, 14, 0);\n        v11 = semctl(v4, v5, 15, 0);\n        v12 = semctl(v4, v5, 11, 0);\n        if ( v11 < 0 || v16 < 0 || v17 < 0 || v12 < 0 )\n          sub_804D3C9((int)\"semctl\");\n        printf(\"%-10u %-10d %-10d %-10d %-10d\\n\", v5++, v16, v17, v11, v12);\n      }\n      goto LABEL_50;\n    }\n    if ( (v2 & 4) == 0 )\n      sub_804CDC2();\n    if ( msgctl(v4, 2, &buf) == -1 )\n    {\n      sub_804D3A5((int)\"msgctl\");\n    }\n    else\n    {\n      printf(\n        \"\\n\"\n        \"Message Queue msqid=%d\\n\"\n        \"uid=%d\\tgid=%d\\tcuid=%d\\tcgid=%d\\tmode=%#o\\n\"\n        \"cbytes=%ld\\tqbytes=%ld\\tqnum=%ld\\tlspid=%d\\tlrpid=%d\\n\",\n        v4,\n        buf.msg_perm.uid,\n        buf.msg_perm.gid,\n        buf.msg_perm.cuid,\n        buf.msg_perm.cgid,\n        buf.msg_perm.mode,\n        buf.__msg_cbytes,\n        buf.msg_qbytes,\n        buf.msg_qnum,\n        buf.msg_lspid,\n        buf.msg_lrpid);\n      v13 = \"Not set\";\n      if ( buf.msg_stime )\n        v13 = ctime(&buf.msg_stime);\n      printf(\"send_time=%-26.24s\\n\", v13);\n      v14 = \"Not set\";\n      if ( buf.msg_rtime )\n        v14 = ctime(&buf.msg_rtime);\n      printf(\"rcv_time=%-26.24s\\n\", v14);\n      v15 = \"Not set\";\n      if ( buf.msg_ctime )\n        v15 = ctime(&buf.msg_ctime);\n      printf(\"change_time=%-26.24s\\n\\n\", v15);\n    }\n  }\n  else\n  {\n    if ( (v2 & 2) != 0 || (v2 & 0x1C) == 0 )\n      LOBYTE(v2) = v2 | 0x1C;\n    sub_804DD98(10);\n    if ( (v2 & 4) != 0 )\n    {\n      sub_807EC1D(v3);\n      sub_804DD98(10);\n    }\n    if ( (v2 & 0x10) != 0 )\n    {\n      sub_807EF34(v3);\n      sub_804DD98(10);\n    }\n    if ( (v2 & 8) != 0 )\n    {\n      sub_807F294(v3);\nLABEL_50:\n      sub_804DD98(10);\n    }\n  }\nLABEL_18:\n  sub_80AB247();\n}\n"
    ],
    "sub_807F8AF": [
        "0x807f8af",
        "void __cdecl __noreturn sub_807F8AF(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // esi\n  unsigned int v4; // edx\n  unsigned int i; // edi\n  ssize_t v6; // eax\n  int v7; // eax\n  char *v8; // eax\n  int v9; // [esp+0h] [ebp-19Ch]\n  time_t timer; // [esp+8h] [ebp-194h] BYREF\n  int buf; // [esp+Ch] [ebp-190h] BYREF\n  char dest[36]; // [esp+14h] [ebp-188h] BYREF\n  char s1[32]; // [esp+38h] [ebp-164h] BYREF\n  char v14[264]; // [esp+58h] [ebp-144h] BYREF\n  time_t v15; // [esp+160h] [ebp-3Ch]\n\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v2 = sub_804DBE1(\"/var/log/wtmp\");\n  printf(\"%-10s %-14s %-18s %-12.12s %s\\n\", \"USER\", \"TTY\", \"HOST\", \"LOGIN\", \"TIME\");\n  sub_804DD09(0, 0, 2);\n  v3 = lseek64();\n  for ( i = v4; ; sub_804DD09(i, v3, 0) )\n  {\n    v6 = sub_804E5E3(v2, (char *)&buf, 0x180u);\n    if ( v6 <= 0 )\nLABEL_31:\n      sub_80AB247();\n    if ( v6 != 384 )\n      sub_804D3C9((int)\"short read\");\n    v9 = sub_804D222(\"~\", dest);\n    if ( v9 )\n    {\n      if ( !s1[0] || !strcmp(s1, \"LOGIN\") )\n        goto LABEL_30;\n      if ( (_WORD)buf != 8 && dest[0] )\n        LOWORD(buf) = 7;\n      if ( !strcmp(s1, \"date\") )\n      {\n        if ( v9 == 2 )\n        {\n          LOWORD(buf) = 4;\n        }\n        else if ( v9 == 1 )\n        {\n          LOWORD(buf) = 3;\n        }\n      }\n    }\n    else\n    {\n      v7 = sub_804D222(\"runlevel\", s1) + 1;\n      if ( v7 > 0 )\n      {\n        if ( v7 == 3 )\n          LOWORD(v7) = 254;\n        LOWORD(buf) = v7;\n      }\n    }\n    if ( (_WORD)buf == 7 )\n      goto LABEL_29;\n    if ( (__int16)buf > 4 )\n    {\n      if ( (_WORD)buf == 254 )\n        goto LABEL_30;\n      goto LABEL_29;\n    }\n    if ( (__int16)buf < 3 && (_WORD)buf != 1 )\n    {\n      if ( (_WORD)buf == 2 )\n        strcpy(dest, \"system boot\");\nLABEL_29:\n      timer = v15;\n      v8 = ctime(&timer);\n      printf(\"%-10s %-14s %-18s %-12.12s\\n\", s1, dest, v14, v8 + 4);\n    }\nLABEL_30:\n    i = (__PAIR64__(i, v3) - 384) >> 32;\n    v3 -= 384;\n    if ( __SPAIR64__(i, v3) <= 0 )\n      goto LABEL_31;\n  }\n}\n"
    ],
    "sub_807FA8F": [
        "0x807fa8f",
        "int __cdecl sub_807FA8F(int a1, int a2)\n{\n  unsigned int v2; // esi\n  const char **v3; // ebx\n  const char *v4; // eax\n  int i; // ebx\n  const char *v6; // eax\n  char *v7; // esi\n  int v8; // eax\n  int v9; // eax\n  int v10; // edx\n  int v12; // [esp+0h] [ebp-38h]\n  void *v13; // [esp+4h] [ebp-34h]\n  int v14; // [esp+8h] [ebp-30h] BYREF\n  char *v15; // [esp+Ch] [ebp-2Ch]\n  char s[39]; // [esp+11h] [ebp-27h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^do:far\", &v14);\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( !v2 )\n  {\n    if ( *v3 && !v3[1] )\n    {\n      v4 = (const char *)sub_80AFD97();\n      if ( v4 )\n      {\n        printf(\"%s: %s\\n\", *v3, v4);\n        return 0;\n      }\nLABEL_32:\n      sub_804D3FF(*v3);\n    }\n    goto LABEL_16;\n  }\n  if ( v2 == 1 )\n  {\n    if ( *v3 )\n    {\n      if ( !sub_80AFDF4() )\n        return 0;\n      goto LABEL_32;\n    }\nLABEL_16:\n    if ( (v2 & 4) != 0 )\n    {\n      v8 = 0;\n      while ( 1 )\n      {\n        v12 = v8 + 1;\n        sprintf(s, \"/dev/loop%u\", v8);\n        v13 = (void *)sub_80AFD97();\n        free(v13);\n        if ( !v13 )\n          break;\n        v8 = v12;\n        if ( v12 == 1024 )\n          sub_804D5E0(\"no free loop devices\");\n      }\n      if ( v2 == 4 && !*v3 )\n      {\n        puts(s);\n        return 0;\n      }\n    }\n    if ( !*v3 || (v2 & 4) == 0 && !v3[1] )\n      goto LABEL_33;\n    v15 = s;\n    if ( (v2 & 2) != 0 )\n    {\n      v9 = sub_80B3FAA();\n      if ( (v2 & 4) != 0 )\n        goto LABEL_30;\n    }\n    else\n    {\n      v9 = 0;\n      v10 = 0;\n      if ( (v2 & 4) != 0 )\n      {\nLABEL_31:\n        if ( (int)sub_80AFE28(v9, v10, (v2 >> 4) & 1) >= 0 )\n          return 0;\n        goto LABEL_32;\n      }\n    }\n    v15 = (char *)*v3++;\nLABEL_30:\n    if ( *v3 )\n      goto LABEL_31;\nLABEL_33:\n    sub_804CDC2();\n  }\n  if ( v2 != 8 )\n    goto LABEL_16;\n  for ( i = 0; i != 1023; ++i )\n  {\n    sprintf(s, \"/dev/loop%u\", i);\n    v6 = (const char *)sub_80AFD97();\n    v7 = (char *)v6;\n    if ( v6 )\n    {\n      printf(\"%s: %s\\n\", s, v6);\n      free(v7);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_807FC2B": [
        "0x807fc2b",
        "int __userpurge sub_807FC2B@<eax>(int a1@<eax>, int a2@<ecx>, int a3)\n{\n  void *v3; // ebx\n  int v4; // ecx\n  int v5; // ebp\n  char *v6; // ebx\n  char *v7; // edi\n  int v8; // ecx\n  int v9; // ecx\n  int v11; // [esp+0h] [ebp-34h]\n  int v12; // [esp+0h] [ebp-34h]\n  int v13; // [esp+0h] [ebp-34h]\n  int v14; // [esp+4h] [ebp-30h]\n  unsigned int v15; // [esp+8h] [ebp-2Ch]\n  int v16; // [esp+Ch] [ebp-28h]\n  int v17; // [esp+10h] [ebp-24h]\n  char *v18; // [esp+18h] [ebp-1Ch]\n  char *s1; // [esp+1Ch] [ebp-18h]\n  const char *v20; // [esp+20h] [ebp-14h]\n\n  v3 = (void *)sub_804D2D1(a1, \"/uevent\", a2);\n  sub_80B0511(v4, sub_80B3D37);\n  free(v3);\n  v16 = 0;\n  v17 = 0;\n  v5 = 0;\n  v14 = 0;\n  v15 = 0;\n  v6 = 0;\n  v7 = 0;\n  while ( sub_80B0560((char *)&unk_80D3C06) )\n  {\n    if ( !strcmp(v18, \"DRIVER\") )\n    {\n      v6 = sub_804DB46(s1);\n    }\n    else if ( !strcmp(v18, \"PCI_CLASS\") )\n    {\n      v15 = (unsigned int)sub_80B40AC(v11, 16) >> 8;\n    }\n    else if ( !strcmp(v18, \"PCI_ID\") )\n    {\n      v14 = sub_80B40AC(v12, 16);\n      v5 = sub_80B40AC(v8, 16);\n    }\n    else if ( !strcmp(v18, \"PCI_SUBSYS_ID\") )\n    {\n      v17 = sub_80B40AC(v13, 16);\n      v16 = sub_80B40AC(v9, 16);\n    }\n    else if ( !strcmp(v18, \"PCI_SLOT_NAME\") )\n    {\n      v7 = sub_804DB46(v20);\n    }\n  }\n  sub_80B0536();\n  if ( (dword_80DBB9C & 1) != 0 )\n    printf(\"%s \\\"Class %04x\\\" \\\"%04x\\\" \\\"%04x\\\" \\\"%04x\\\" \\\"%04x\\\"\", v7, v15, v14, v5, v17, v16);\n  else\n    printf(\"%s Class %04x: %04x:%04x\", v7, v15, v14, v5);\n  if ( (dword_80DBB9C & 2) != 0 && v6 )\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n      printf(\" \\\"%s\\\"\", v6);\n    else\n      printf(\" %s\", v6);\n  }\n  sub_804DD98(10);\n  free(v6);\n  free(v7);\n  return 1;\n}\n"
    ],
    "sub_807FE0C": [
        "0x807fe0c",
        "int __cdecl sub_807FE0C(int a1, int a2)\n{\n  sub_80ABEAC(a2, \"mknv\");\n  sub_80B2549(sub_807FC2B, 1, 0, 0, 0);\n  return 0;\n}\n"
    ],
    "sub_807FE39": [
        "0x807fe39",
        "int __userpurge sub_807FE39@<eax>(int a1@<eax>, int a2@<ecx>, int a3)\n{\n  void *v3; // ebx\n  int v4; // ecx\n  int v5; // ebp\n  char *v6; // edi\n  char *v7; // ebx\n  int v8; // edx\n  int v9; // ecx\n  int v10; // eax\n  int v11; // ecx\n  int v13; // [esp-4h] [ebp-30h]\n  int v14; // [esp+0h] [ebp-2Ch]\n  int v15; // [esp+0h] [ebp-2Ch]\n  int v16; // [esp+4h] [ebp-28h]\n  int v17; // [esp+8h] [ebp-24h]\n  char *v18; // [esp+Ch] [ebp-20h]\n  char *s1; // [esp+10h] [ebp-1Ch]\n\n  v3 = (void *)sub_804D2D1(a1, \"/uevent\", a2);\n  v5 = sub_80B0511(v4, sub_80B3D37);\n  free(v3);\n  v16 = 0;\n  v17 = 0;\n  v6 = 0;\n  v7 = 0;\n  while ( sub_80B0560(\"\\\\/=\") )\n  {\n    if ( *(_DWORD *)(v5 + 24) == 1 )\n    {\n      v10 = strcmp(v18, \"DEVTYPE\");\n      v8 = v13;\n      v9 = v14;\n      if ( !v10 )\n        break;\n    }\n    if ( !strcmp(v18, \"PRODUCT\") )\n    {\n      v17 = sub_80B40AC(v15, 16);\n      v16 = sub_80B40AC(v11, 16);\n    }\n    else if ( !strcmp(v18, \"BUSNUM\") )\n    {\n      v7 = sub_804DB46(s1);\n    }\n    else if ( !strcmp(v18, \"DEVNUM\") )\n    {\n      v6 = sub_804DB46(s1);\n    }\n  }\n  sub_80B0536(v9, v8);\n  if ( v7 )\n  {\n    printf(\"Bus %s Device %s: ID %04x:%04x\\n\", v7, v6, v17, v16);\n    free(v7);\n    free(v6);\n  }\n  return 1;\n}\n"
    ],
    "sub_807FF62": [
        "0x807ff62",
        "int sub_807FF62()\n{\n  sub_80B2549(sub_807FE39, 1, 0, 0, 0);\n  return 0;\n}\n"
    ],
    "sub_807FF7F": [
        "0x807ff7f",
        "int __stdcall sub_807FF7F(int a1)\n{\n  return (a1 > 2) + 1;\n}\n"
    ],
    "sub_807FF8D": [
        "0x807ff8d",
        "int sub_807FF8D()\n{\n  int result; // eax\n\n  result = 0;\n  memset(&stream, 0, 0x4Cu);\n  dword_80DB7A4 = -1;\n  pmatch[0].rm_so = 432;\n  return result;\n}\n"
    ],
    "sub_807FFB4": [
        "0x807ffb4",
        "int sub_807FFB4()\n{\n  int i; // ebx\n\n  free(MEMORY[0x80DB7B8]);\n  free((void *)n);\n  if ( BYTE1(stream) )\n    regfree(&preg);\n  free(dword_80DB7C0);\n  for ( i = dword_80DB7E4; i; i = *(_DWORD *)i )\n  {\n    free(*(void **)(i + 4));\n    regfree((regex_t *)(i + 8));\n  }\n  return sub_807FF8D();\n}\n"
    ],
    "sub_8080014": [
        "0x8080014",
        "__int64 sub_8080014()\n{\n  __int64 v1; // [esp-8h] [ebp-Ch]\n\n  umask(0x12u);\n  sub_80B00B9(4, 493);\n  umask(0);\n  return v1;\n}\n"
    ],
    "sub_808003A": [
        "0x808003a",
        "int __usercall sub_808003A@<eax>(char *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  size_t v4; // eax\n  char *v5; // ebx\n  int v6; // eax\n  int v7; // eax\n  char *v8; // eax\n  char *v9; // ecx\n  FILE ***v10; // edx\n  FILE **v11; // ebx\n  char *v12; // edi\n  int *v13; // eax\n  int *v14; // ebp\n  int v15; // ebx\n  char *v16; // eax\n  int v17; // edx\n  const char *v18; // esi\n  int v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  char *v22; // esi\n  char *v23; // ebx\n  int v24; // eax\n  int v25; // edx\n  int v26; // ecx\n  char *v27; // edx\n  FILE *i; // esi\n  char *v29; // eax\n  int v30; // eax\n  char *v31; // esi\n  size_t v32; // eax\n  int v33; // eax\n  FILE *v34; // eax\n  char *v35; // ebp\n  const char *v36; // edi\n  char v37; // al\n  bool v38; // zf\n  const char *v39; // esi\n  char *v40; // eax\n  int v41; // ecx\n  char *v42; // eax\n  int v43; // ecx\n  __dev_t v44; // rax\n  int result; // eax\n  int v46; // [esp-4h] [ebp-44h]\n  int v47; // [esp+0h] [ebp-40h]\n  int v48; // [esp+0h] [ebp-40h]\n  char flags; // [esp+Fh] [ebp-31h]\n  int v52; // [esp+10h] [ebp-30h]\n  char v53; // [esp+14h] [ebp-2Ch]\n  char *v54; // [esp+14h] [ebp-2Ch]\n  char *v55; // [esp+14h] [ebp-2Ch]\n  char *v56; // [esp+14h] [ebp-2Ch]\n  __int64 v57; // [esp+18h] [ebp-28h] BYREF\n  regmatch_t v58; // [esp+20h] [ebp-20h] BYREF\n  char *v59; // [esp+2Ch] [ebp-14h]\n\n  v4 = strlen(a2);\n  v5 = (char *)&a2[v4];\n  LODWORD(v57) = -1;\n  if ( !a3 )\n  {\n    strcpy((char *)&a2[v4], \"/dev\");\n    v6 = sub_804E632(0x7Fu, v5 + 1);\n    *v5 = 0;\n    if ( v6 > 0 )\n    {\n      if ( sscanf(v5 + 1, \"%u:%u\", &v57, (char *)&v57 + 4) == 2 )\n      {\n        if ( (_BYTE)unk_80DB780 )\n          sub_804D5F4(\"dev %u,%u\", (_DWORD)v57, HIDWORD(v57));\n      }\n      else\n      {\n        LODWORD(v57) = -1;\n      }\n    }\n  }\n  if ( !a1 )\n  {\n    strcpy(v5, \"/uevent\");\n    v7 = sub_804E632(0x7Fu, v5 + 1);\n    *v5 = 0;\n    if ( v7 < 0 )\n      v7 = 0;\n    v5[v7 + 1] = 0;\n    v8 = strstr(v5 + 1, \"\\nDEVNAME=\");\n    if ( v8 )\n    {\n      a1 = v8 + 9;\n      *(_BYTE *)strchrnul() = 0;\n    }\n    else\n    {\n      a1 = sub_804D315(a2);\n    }\n  }\n  if ( strstr(a2, \"/block/\") || qword_80DB784 && sub_804D210(qword_80DB784, \"block\") )\n    v52 = 24576;\n  else\n    v52 = 0x2000;\n  dword_80DB798 = 0;\n  do\n  {\n    while ( 1 )\n    {\nLABEL_19:\n      if ( !*(&unk_80DB78C + 1) && unk_80DB78C )\n      {\n        *(&unk_80DB78C + 1) = (char *)sub_80B0511(v9, sub_80B3D37);\n        unk_80DB78C = 0;\n      }\n      if ( unk_80DB794 )\n      {\n        v10 = (FILE ***)(unk_80DB794 + 4 * (_DWORD)dword_80DB798);\n        if ( *v10 )\n        {\n          ++dword_80DB798;\n          v11 = *v10;\n          goto LABEL_59;\n        }\n        sub_807FF8D();\n      }\n      else\n      {\n        sub_807FFB4();\n      }\n      if ( !*(&unk_80DB78C + 1) )\n        goto LABEL_28;\n      while ( sub_80B0560(\"# \\t\") )\n      {\n        LOBYTE(stream) = *(_BYTE *)v58.rm_so == 45;\n        v15 = (unsigned __int8)stream + v58.rm_so;\n        v14 = &dword_80DB7E4;\n        while ( 1 )\n        {\n          v16 = strchr((const char *)v15, 61);\n          v18 = v16;\n          if ( !v16 )\n            break;\n          if ( v16 != (char *)sub_80AB128(v46, v17) )\n            break;\n          v12 = strchr(v18, 59);\n          if ( !v12 )\n            break;\n          v13 = (int *)sub_804DB2E(0x28u);\n          *v14 = (int)v13;\n          v14 = v13;\n          v13[1] = (int)sub_804DB5D((_BYTE *)v15, (int)&v18[-v15]);\n          *v12 = 0;\n          sub_80B47BA(1, v18 + 1);\n          *v12 = 59;\n          v15 = (int)(v12 + 1);\n        }\n        if ( *(_BYTE *)v15 == 64 )\n        {\n          v19 = sscanf((const char *)v15, \"@%u,%u-%u\", &dword_80DB7A4, &qword_80DB7A8, &qword_80DB7A8 + 1);\n          if ( v19 <= 1 || dword_80DB7A4 < 0 )\n          {\n            sub_804D5F4(\"bad @maj,min on line %d\", *((_DWORD *)*(&unk_80DB78C + 1) + 6));\n            goto LABEL_36;\n          }\n          if ( v19 == 2 )\n            *(&qword_80DB7A8 + 1) = qword_80DB7A8;\n        }\n        else\n        {\n          v53 = *(_BYTE *)v15;\n          v22 = strchr((const char *)v15, 61);\n          if ( v53 == 36 )\n          {\n            if ( !v22 )\n            {\n              sub_804D5F4(\"bad $envvar=regex on line %d\", *((_DWORD *)*(&unk_80DB78C + 1) + 6));\n              goto LABEL_36;\n            }\n            MEMORY[0x80DB7B8] = sub_804DB5D((_BYTE *)(v15 + 1), (int)&v22[-v15 - 1]);\n            v15 = (int)(v22 + 1);\n          }\n          sub_80B47BA(1, v15);\n          BYTE1(stream) = 1;\n        }\n        if ( sub_80B47DD() )\n        {\n          pmatch[0].rm_so = sub_80B07AF();\n          v23 = v59;\n          if ( !v59 )\n            goto LABEL_57;\n          if ( strchr(\">=!\", (unsigned __int8)*v59) )\n          {\n            v24 = sub_80B2E9F();\n            n = (size_t)sub_804DB5D(v23, v24 - (_DWORD)v23);\n            v23 = (char *)sub_80B2E8C(v26, v25);\n            if ( !v23 )\n              goto LABEL_57;\n          }\n          if ( !*v23 )\n            goto LABEL_57;\n          if ( strchr(\"$@*\", (unsigned __int8)*v23) )\n          {\n            dword_80DB7C0 = sub_804DB46(v23);\n            goto LABEL_57;\n          }\n          sub_804D5F4(\"bad line %u\", *((_DWORD *)*(&unk_80DB78C + 1) + 6));\n        }\n        else\n        {\n          sub_804D5F4(\n            \"unknown user/group '%s' on line %d\",\n            (const char *)v58.rm_eo,\n            *((_DWORD *)*(&unk_80DB78C + 1) + 6));\n        }\nLABEL_36:\n        sub_807FFB4();\n      }\n      sub_80B0536(v21, v20);\n      *(&unk_80DB78C + 1) = 0;\nLABEL_57:\n      if ( unk_80DB794 )\n      {\n        v11 = (FILE **)sub_804DB8D(&stream, 0x4Cu);\n        unk_80DB794 = sub_80B4733(dword_80DB798, 1028);\n        v27 = dword_80DB798;\n        v9 = ++dword_80DB798;\n        *(_DWORD *)(unk_80DB794 + 4 * (_DWORD)v27) = v11;\n        goto LABEL_59;\n      }\nLABEL_28:\n      v11 = &stream;\nLABEL_59:\n      for ( i = v11[18]; i; i = (FILE *)i->_flags )\n      {\n        v29 = getenv(i->_IO_read_ptr);\n        if ( !v29 || regexec((const regex_t *)&i->_IO_read_end, v29, 0, 0, 0) )\n          goto LABEL_19;\n      }\n      v30 = (int)v11[2];\n      if ( v30 >= 0 )\n      {\n        if ( v30 == (_DWORD)v57 && (int)v11[3] <= SHIDWORD(v57) && SHIDWORD(v57) <= (int)v11[4] )\n        {\n          memset(&v58, 0, sizeof(v58));\n          break;\n        }\n        continue;\n      }\n      if ( v11[7] )\n      {\n        v31 = getenv((const char *)v11[7]);\n        if ( v31 )\n          goto LABEL_73;\n        continue;\n      }\n      v31 = a1;\nLABEL_73:\n      if ( !*((_BYTE *)v11 + 1) )\n        break;\n      if ( !regexec((const regex_t *)(v11 + 10), v31, 1u, &v58, 0) && !v58.rm_so )\n      {\n        v32 = strlen(v31);\n        if ( v58.rm_eo == v32 )\n          break;\n      }\n    }\n    if ( (char)unk_80DB780 > 1 )\n    {\n      v33 = -1;\n      if ( *(&unk_80DB78C + 1) )\n        v33 = *((_DWORD *)*(&unk_80DB78C + 1) + 6);\n      sub_804D5F4(\"rule matched, line %d\", v33);\n    }\n    v34 = v11[8];\n    v35 = 0;\n    if ( v34 )\n    {\n      flags = v34->_flags;\n      if ( LOBYTE(v34->_flags) == 33 )\n      {\n        LODWORD(v57) = -2;\n      }\n      else if ( (unsigned __int8)(flags - 61) <= 1u )\n      {\n        v35 = sub_804DB46((const char *)&v34->_flags + 1);\n      }\n    }\n    v36 = (const char *)v11[9];\n    if ( !v36 )\n      goto LABEL_96;\n    v37 = *v36;\n    if ( *v36 != 64 )\n    {\n      if ( v37 == 36 )\n        v38 = a3 == 1;\n      else\n        v38 = v37 == 42;\n      if ( v38 )\nLABEL_94:\n        ++v36;\n      else\n        v36 = 0;\nLABEL_96:\n      v39 = a1;\n      if ( v35 )\n      {\nLABEL_100:\n        v40 = strrchr(v35, 47);\n        v39 = v35;\n        if ( v40 )\n        {\n          *v40 = 0;\n          v54 = v40;\n          sub_8080014();\n          *v54 = 47;\n          if ( !v54[1] )\n          {\n            v39 = (const char *)sub_804D2D1((int)v35, a1, v41);\n            free(v35);\n            v35 = (char *)v39;\n          }\n        }\n      }\n      if ( a3 )\n      {\n        if ( !v36 )\n          goto LABEL_125;\n      }\n      else\n      {\n        if ( (int)v57 >= 0 )\n        {\n          v42 = strrchr(v39, 47);\n          v43 = v47;\n          if ( v42 )\n          {\n            *v42 = 0;\n            v55 = v42;\n            sub_8080014();\n            *v55 = 47;\n          }\n          if ( (_BYTE)unk_80DB780 )\n            sub_804D5F4(\"mknod %s (%d,%d) %o %u:%u\", v39, v57, (unsigned int)v11[1] | v52, v11[5], v11[6]);\n          v44 = sub_80B0220(v43, HIDWORD(v57));\n          if ( mknod(v39, (unsigned int)v11[1] | v52, v44) && *(_DWORD *)dword_80DBB7C != 17 )\n            sub_804D3A5((int)\"can't create '%s'\", v39);\n          chmod(v39, (__mode_t)v11[1]);\n          chown(v39, (__uid_t)v11[5], (__gid_t)v11[6]);\n          if ( qword_80DB778 == v57 )\n            symlink(v39, \"root\");\n          if ( flags == 62 && v35 )\n          {\n            if ( (_BYTE)unk_80DB780 )\n              sub_804D5F4(\"symlink: %s\", a1);\n            symlink(v39, a1);\n          }\n        }\n        if ( !v36 )\n          goto LABEL_135;\n      }\n      v56 = sub_804DDBF(\"%s=%s\", \"MDEV\", v39);\n      putenv(v56);\n      if ( (_BYTE)unk_80DB780 )\n        sub_804D5F4(\"running: %s\", v36);\n      if ( system(v36) == -1 )\n        sub_804D3A5((int)\"can't run '%s'\", v36);\n      sub_804DE4D(v56);\n      goto LABEL_125;\n    }\n    if ( !a3 )\n      goto LABEL_94;\n    v39 = a1;\n    if ( v35 )\n    {\n      v36 = 0;\n      goto LABEL_100;\n    }\nLABEL_125:\n    if ( a3 == 1 && (int)v57 >= -1 )\n    {\n      if ( flags == 62 && v35 )\n      {\n        if ( (_BYTE)unk_80DB780 )\n          sub_804D5F4(\"unlink: %s\", a1);\n        unlink(a1);\n      }\n      if ( (_BYTE)unk_80DB780 )\n        sub_804D5F4(\"unlink: %s\", v39);\n      unlink(v39);\n    }\nLABEL_135:\n    free(v35);\n    result = v48;\n  }\n  while ( *(_BYTE *)v11 );\n  return result;\n}\n"
    ],
    "sub_80807F2": [
        "0x80807f2",
        "int __userpurge sub_80807F2@<eax>(char *src@<ecx>, const char *a2@<eax>, int a3)\n{\n  size_t v5; // ebp\n  unsigned int v6; // edi\n  ssize_t v7; // eax\n  char *v8; // eax\n  char *v10; // [esp+4h] [ebp-1010h] BYREF\n\n  v5 = strlen(a2);\n  v6 = v5 - 4;\n  if ( strcmp(&a2[v5 - 4], \"/dev\") || v6 > 0xFDF )\n    return 0;\n  strcpy(src, a2);\n  src[v5 - 4] = 0;\n  strcpy((char *)&v10, src);\n  strcpy((char *)&v10 + v6, \"/subsystem\");\n  v7 = readlink((const char *)&v10, (char *)&v10, 0xFFFu);\n  if ( v7 > 0 )\n  {\n    *((_BYTE *)&v10 + v7) = 0;\n    free(qword_80DB784);\n    if ( *(&qword_80DB784 + 1) )\n    {\n      sub_804DE4D(*(&qword_80DB784 + 1));\n      *(&qword_80DB784 + 1) = 0;\n    }\n    v8 = strrchr((const char *)&v10, 47);\n    qword_80DB784 = v8;\n    if ( v8 )\n    {\n      qword_80DB784 = sub_804DB46(v8 + 1);\n      *(&qword_80DB784 + 1) = sub_804DDBF(\"%s=%s\", \"SUBSYSTEM\", qword_80DB784);\n      putenv(*(&qword_80DB784 + 1));\n    }\n  }\n  sub_808003A(0, src, 0);\n  return 1;\n}\n"
    ],
    "sub_80808ED": [
        "0x80808ed",
        "char *sub_80808ED()\n{\n  __suseconds_t tv_usec; // esi\n  char *v1; // eax\n  struct timeval tv; // [esp+0h] [ebp-10h] BYREF\n\n  gettimeofday(&tv, 0);\n  tv_usec = tv.tv_usec;\n  v1 = sub_804EB80(&tv.tv_sec, 0x10u, byte_80DB7E8, (time_t)&tv);\n  sprintf(v1, \".%06u\", tv_usec);\n  return byte_80DB7E8;\n}\n"
    ],
    "sub_808092A": [
        "0x808092a",
        "int __cdecl sub_808092A(int a1, int a2)\n{\n  const char *v2; // eax\n  char *v3; // esi\n  int v4; // eax\n  const char *v5; // eax\n  int v6; // ebx\n  int v7; // ebp\n  int v8; // esi\n  int v9; // eax\n  const char *v10; // eax\n  int v11; // ecx\n  unsigned int v12; // eax\n  char *v13; // eax\n  const char *v14; // edi\n  const char *v15; // esi\n  int v16; // ebp\n  char *v17; // eax\n  int v18; // ecx\n  char *v19; // eax\n  const char *v20; // eax\n  int v21; // ecx\n  int v22; // ecx\n  int v23; // ebx\n  const char *v24; // eax\n  char *v25; // eax\n  int v26; // eax\n  int v28; // [esp-4h] [ebp-A0h]\n  unsigned int v29; // [esp+4h] [ebp-98h]\n  char *signo; // [esp+8h] [ebp-94h]\n  char *v31; // [esp+Ch] [ebp-90h]\n  const char *s; // [esp+10h] [ebp-8Ch]\n  char *v33; // [esp+14h] [ebp-88h]\n  char *v34; // [esp+18h] [ebp-84h]\n  unsigned __int8 v35; // [esp+1Ch] [ebp-80h]\n  unsigned int v36; // [esp+20h] [ebp-7Ch]\n  _DWORD v37[2]; // [esp+24h] [ebp-78h] BYREF\n  unsigned __int64 v38[14]; // [esp+2Ch] [ebp-70h] BYREF\n\n  signo = (char *)sub_804DAFA(0x1080u);\n  unk_80DB78C = \"/etc/mdev.conf\";\n  sub_80B3CDB();\n  umask(0);\n  sub_804DF04(\"/dev\");\n  v2 = *(const char **)(a2 + 4);\n  if ( v2 && !strcmp(v2, \"-s\") )\n  {\n    unk_80DB794 = (size_t)sub_804DB2E(0x40u);\n    sub_804DFF3(\"/\");\n    LODWORD(qword_80DB778) = gnu_dev_major(v38[0]);\n    HIDWORD(qword_80DB778) = gnu_dev_minor(v38[0]);\n    putenv(\"ACTION=add\");\n    sub_80B2549(sub_80807F2, 3, sub_807FF7F, signo, 0);\n    return 0;\n  }\n  v31 = getenv(\"DEVNAME\");\n  qword_80DB784 = getenv(\"SUBSYSTEM\");\n  s = getenv(\"ACTION\");\n  v33 = getenv(\"DEVPATH\");\n  if ( !s || !v33 )\n    sub_804CDC2();\n  v34 = getenv(\"FIRMWARE\");\n  v3 = getenv(\"SEQNUM\");\n  v35 = sub_804D222(\"add\", s);\n  v36 = getpid();\n  v4 = open64();\n  if ( v4 >= 0 )\n  {\n    sub_804DC97(v4, 2);\n    LOBYTE(unk_80DB780) = 2;\n    v5 = v3;\n    if ( !v3 )\n      v5 = sub_804D6F7(v36);\n    ident = sub_804DDBF(\"%s[%s]\", ident, v5);\n  }\n  v6 = -1;\n  if ( v3 )\n  {\n    v29 = atoll(v3);\n    v37[0] = 0;\n    v37[1] = 0;\n    sigaddset((sigset_t *)v37, 17);\n    sigprocmask(0, (const sigset_t *)v37, 0);\n    v7 = 1;\n    v8 = 62;\n    while ( 1 )\n    {\n      if ( v6 == -1 )\n      {\n        v6 = open64();\n        if ( v6 < 0 )\n          goto LABEL_32;\n        sub_804D670();\n      }\n      v9 = pread64();\n      if ( v9 < 0 )\n      {\nLABEL_23:\n        close(v6);\n        v6 = -1;\n        goto LABEL_32;\n      }\n      *((_BYTE *)v38 + v9) = 0;\n      if ( !LOBYTE(v38[0]) || LOBYTE(v38[0]) == 10 )\n      {\n        v10 = sub_804D6F7(v29);\n        sub_804DCD4(v11, v10);\n        sub_804DD09(0, 0, 0);\n        if ( (char)unk_80DB780 > 1 )\n          sub_804D5F4(\"first seq written\");\n        goto LABEL_32;\n      }\n      v12 = atoll((const char *)v38);\n      if ( v29 == v12 )\n        goto LABEL_32;\n      if ( v29 < v12 )\n        goto LABEL_23;\n      if ( v7 && (char)unk_80DB780 > 1 )\n      {\n        v13 = sub_80808ED();\n        sub_804D5F4(\"%s mdev.seq='%s', need '%u'\", v13, (const char *)v38, v29);\n      }\n      if ( sigtimedwait((const sigset_t *)v37, 0, &timeout) < 0 && !--v8 )\n        break;\n      v7 = 0;\n    }\n    if ( (_BYTE)unk_80DB780 )\n      sub_804D5F4(\"%s mdev.seq='%s'\", \"timed out\", (const char *)v38);\nLABEL_32:\n    sigprocmask(1, (const sigset_t *)v37, 0);\n  }\n  if ( (_BYTE)unk_80DB780 )\n  {\n    if ( v34 )\n    {\n      v14 = v34;\n      v15 = \" FW:\";\n    }\n    else\n    {\n      v14 = &data;\n      v15 = &data;\n    }\n    v16 = qword_80DB784;\n    v17 = sub_80808ED();\n    sub_804D5F4(\"%s ACTION:%s SUBSYSTEM:%s DEVNAME:%s DEVPATH:%s%s%s\", v17, s, v16, v31, v33, v15, v14);\n  }\n  snprintf(signo, 0x1000u, \"/sys%s\", v33);\n  if ( v35 == 1 )\n  {\n    v18 = 1;\n    if ( v34 )\n      goto LABEL_43;\n  }\n  else\n  {\n    v18 = v35;\n  }\n  sub_808003A(v31, signo, v18);\nLABEL_43:\n  if ( (_BYTE)unk_80DB780 )\n  {\n    v19 = sub_80808ED();\n    sub_804D5F4(\"%s exiting\", v19);\n  }\n  if ( v6 >= 0 )\n  {\n    v20 = sub_804D6F7(v29 + 1);\n    sub_804DCD4(v21, v20);\n    while ( 1 )\n    {\n      v23 = sub_80B0EC0(v22, 128);\n      if ( !v23 )\n        break;\n      if ( v36 != *(_DWORD *)(v23 + 36) )\n      {\n        v24 = *(const char **)(v23 + 8);\n        if ( v24 )\n        {\n          v25 = sub_804D315(v24);\n          v26 = strcmp(v25, \"mdev\");\n          v22 = v28;\n          if ( !v26 )\n            kill(*(_DWORD *)(v23 + 36), 17);\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8080D40": [
        "0x8080d40",
        "int __cdecl sub_8080D40(int a1, int a2)\n{\n  char *v2; // eax\n  char v3; // bl\n  const char *v4; // edx\n  __mode_t v5; // edx\n  int v7; // [esp-8h] [ebp-6Ch]\n  int v8; // [esp-4h] [ebp-68h]\n  int v9; // [esp+10h] [ebp-54h]\n\n  v2 = *(char **)(a2 + 4);\n  if ( v2 )\n  {\n    if ( *(_DWORD *)(a2 + 8) || (v3 = *v2, *v2 != 121) && v3 != 110 )\n      sub_804CDC2();\n  }\n  else\n  {\n    v3 = 0;\n  }\n  if ( !isatty(0) )\n    sub_804D5E0(\"not a tty\");\n  sub_804E010(\"stdin\");\n  if ( v3 )\n  {\n    v5 = v9 & 0xFFFFFFED;\n    if ( v3 == 121 )\n      v5 = v9 | 0x10;\n    if ( fchmod(0, v5) )\n      sub_80B0A23(v8, v7);\n  }\n  else\n  {\n    v4 = \"is n\";\n    if ( (v9 & 0x12) != 0 )\n      v4 = \"is y\";\n    puts(v4);\n  }\n  return 0;\n}\n"
    ],
    "sub_8080DD4": [
        "0x8080dd4",
        "int __usercall sub_8080DD4@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int *v1; // edx\n\n  v1 = (unsigned int *)&unk_80B6598;\n  while ( *--v1 != a1 )\n  {\n    if ( *v1 < a1 )\n      return 0;\n  }\n  return 1;\n}\n"
    ],
    "sub_8080DEB": [
        "0x8080deb",
        "int __usercall sub_8080DEB@<eax>(char *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4)\n{\n  int result; // eax\n  unsigned int v6; // edx\n\n  result = 255;\n  memset(a1, 0, a2);\n  memset(a1, 255, a3 >> 3);\n  a1[a3 >> 3] = (1 << (a3 & 7)) - 1;\n  v6 = a2 - (a4 >> 3);\n  a1[v6 - 1] |= 32512 >> (a4 & 7);\n  memset(&a1[v6], 255, a4 >> 3);\n  return result;\n}\n"
    ],
    "sub_8080E44": [
        "0x8080e44",
        "void __usercall sub_8080E44(unsigned int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4)\n{\n  sub_804DD09(a2, a1, 0);\n  sub_804DCAD(a4, a3);\n}\n"
    ],
    "sub_8080E6C": [
        "0x8080e6c",
        "int __cdecl sub_8080E6C(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // eax\n  unsigned __int64 v4; // rax\n  unsigned int v5; // esi\n  unsigned int v6; // edi\n  unsigned int v7; // ebx\n  unsigned int v8; // ebp\n  unsigned __int64 v9; // rax\n  unsigned int v10; // edi\n  unsigned int v11; // esi\n  unsigned int v12; // ebx\n  unsigned int v13; // eax\n  int v14; // ecx\n  unsigned int v15; // ecx\n  int v16; // eax\n  int v17; // eax\n  int v18; // edx\n  int v19; // ebx\n  int v20; // edi\n  unsigned int j; // esi\n  const char *v22; // ecx\n  _DWORD *v23; // esi\n  unsigned __int16 v24; // ax\n  char *v25; // ebx\n  unsigned int *v26; // edi\n  int v27; // eax\n  int v28; // edx\n  unsigned int v29; // ecx\n  int v30; // eax\n  unsigned int *m; // esi\n  int n; // edi\n  unsigned __int64 v33; // rax\n  unsigned int v34; // eax\n  unsigned __int64 v35; // rax\n  int v36; // eax\n  unsigned __int64 v37; // rax\n  unsigned int ii; // edi\n  int v39; // eax\n  unsigned __int64 v40; // rax\n  int v42; // [esp+4h] [ebp-D4h]\n  unsigned int v43; // [esp+4h] [ebp-D4h]\n  unsigned int v44; // [esp+8h] [ebp-D0h]\n  unsigned int v45; // [esp+Ch] [ebp-CCh]\n  int v46; // [esp+10h] [ebp-C8h]\n  unsigned int *v47; // [esp+10h] [ebp-C8h]\n  unsigned int v48; // [esp+14h] [ebp-C4h]\n  unsigned int k; // [esp+14h] [ebp-C4h]\n  unsigned int v50; // [esp+18h] [ebp-C0h]\n  unsigned int v51; // [esp+1Ch] [ebp-BCh]\n  int i; // [esp+20h] [ebp-B8h]\n  time_t v53; // [esp+20h] [ebp-B8h]\n  unsigned int v54; // [esp+24h] [ebp-B4h]\n  int v55; // [esp+28h] [ebp-B0h]\n  unsigned __int64 v56; // [esp+28h] [ebp-B0h]\n  unsigned int v57; // [esp+30h] [ebp-A8h]\n  int v58; // [esp+34h] [ebp-A4h]\n  unsigned int v59; // [esp+38h] [ebp-A0h]\n  unsigned int v60; // [esp+38h] [ebp-A0h]\n  int v61; // [esp+3Ch] [ebp-9Ch]\n  int v62; // [esp+3Ch] [ebp-9Ch]\n  int v63; // [esp+40h] [ebp-98h]\n  int v64; // [esp+44h] [ebp-94h]\n  unsigned int v65; // [esp+48h] [ebp-90h]\n  unsigned int v66; // [esp+54h] [ebp-84h] BYREF\n  unsigned int v67; // [esp+58h] [ebp-80h] BYREF\n  unsigned int v68; // [esp+5Ch] [ebp-7Ch] BYREF\n  unsigned int v69; // [esp+60h] [ebp-78h] BYREF\n  const char *v70; // [esp+64h] [ebp-74h] BYREF\n  int v71; // [esp+78h] [ebp-60h]\n\n  v69 = 5;\n  v70 = &data;\n  sub_80ABEAC(\n    a2,\n    \"cl:b:+f:i:+I:+J:G:N:m:+o:g:L:M:O:r:E:T:U:jnqvFS\",\n    0,\n    &v66,\n    0,\n    &v67,\n    &v68,\n    0,\n    0,\n    0,\n    &v69,\n    0,\n    0,\n    &v70,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = sub_804DBE1(*v2);\n  sub_804DC97(v3, 3);\n  sub_804E010(*v2);\n  if ( (v71 & 0xF000) != 24576 && (dword_80DBB9C & 0x800000) == 0 )\n    sub_804D5E0(\"%s: not a block device\", *v2);\n  if ( sub_80AB375() )\n    sub_804D5E0(\"can't format mounted filesystem\");\n  v4 = sub_80AB8B7((((unsigned int)dword_80DBB9C >> 20) ^ 1) & 1);\n  v5 = v4 >> 10;\n  v6 = HIDWORD(v4) >> 10;\n  if ( v4 >> 10 > 0x7FFFF )\n  {\n    v7 = 0x4000;\n  }\n  else\n  {\n    v7 = 0x2000;\n    if ( v5 > 0xBFF )\n      v7 = 4096;\n  }\n  if ( (dword_80DBB9C & 0x10) != 0 )\n    v7 = v67;\n  if ( v6 || v5 > 0x7FFFF )\n  {\n    v45 = 256;\n    v8 = 4096;\n  }\n  else\n  {\n    v45 = 128;\n    v8 = 1024;\n  }\n  while ( HIDWORD(v4) >= v8 )\n    v8 *= 2;\n  if ( (dword_80DBB9C & 4) != 0 )\n    v8 = v66;\n  if ( v8 - 1024 > 0xFC00 || (v42 = v8 & (v8 - 1)) != 0 )\n    sub_804D5E0(\"blocksize %u is bad\", v8);\n  if ( (dword_80DBB9C & 0x20) != 0 )\n  {\n    if ( v68 <= 0x7F || v68 > v8 || (v68 & (v68 - 1)) != 0 )\n      sub_804D5F4(\"-%c is bad\", 73);\n    else\n      v45 = v68;\n  }\n  if ( v7 < v8 )\n    sub_804D5E0(\"-%c is bad\", 105);\n  v51 = v8 == 1024;\n  v54 = v8;\n  while ( 1 )\n  {\n    v54 >>= 1;\n    if ( !v54 )\n      break;\n    ++v42;\n  }\n  v46 = v42 - 10;\n  v9 = __PAIR64__(v6, v5) >> ((unsigned __int8)v42 - 10);\n  v10 = v9;\n  if ( HIDWORD(v9) )\n    sub_804D5E0(\"block count doesn't fit in 32 bits\");\n  if ( (unsigned int)v9 <= 0x3B )\n    sub_804D5E0(\"need >= 60 blocks\");\n  if ( v69 > 0x32 )\n    sub_804D5E0(\"-%c is bad\", 109);\n  v61 = sub_80B4B88((unsigned int)v9 * v69, ((unsigned int)v9 * (unsigned __int64)v69) >> 32, 100, 0);\n  v43 = 8 * v8;\n  v11 = v8 >> 5;\n  v12 = sub_80B4B88(v10 * v8, (v10 * (unsigned __int64)v8) >> 32, v7, 0);\n  if ( v12 < 0xC )\n    v12 = 12;\n  v58 = 16 >> v46;\n  if ( 16 >> v46 > 12 )\n    v58 = 12;\n  for ( i = v10; ; i -= v59 )\n  {\n    v57 = i - v51;\n    v59 = (i - v51) % v43;\n    v44 = (i - v51) / v43;\n    if ( i - v51 != v44 * v43 )\n      ++v44;\n    v55 = v44 / v11;\n    if ( v11 * (v44 / v11) != v44 )\n      ++v55;\n    v13 = v12 / v44;\n    if ( v12 / v44 * v44 != v12 )\n      ++v13;\n    v14 = 16;\n    if ( v13 > 0xF )\n    {\n      v14 = 8 * v8;\n      if ( v43 > v13 )\n        v14 = v13;\n    }\n    v15 = v45 * v14;\n    v16 = v15 / v8;\n    if ( v15 != v15 / v8 * v8 )\n      ++v16;\n    v48 = (v8 * v16 / v45) & 0xFFFFFFF8;\n    v50 = v48 * v45 / v8;\n    if ( v48 * v45 != v8 * v50 )\n      ++v50;\n    v17 = sub_8080DD4(v44 - 1);\n    v18 = 2;\n    if ( v17 )\n      v18 = v55 + 3;\n    if ( !v59 || v18 + v50 + 50 <= v59 )\n      break;\n  }\n  if ( v10 != i )\n    printf(\"warning: %u blocks unused\\n\\n\", v10 - i);\n  v19 = v44 * v48;\n  printf(\n    \"Filesystem label=%s\\n\"\n    \"OS type: Linux\\n\"\n    \"Block size=%u (log=%u)\\n\"\n    \"Fragment size=%u (log=%u)\\n\"\n    \"%u inodes, %u blocks\\n\"\n    \"%u blocks (%u%%) reserved for the super user\\n\"\n    \"First data block=%u\\n\"\n    \"Maximum filesystem blocks=%u\\n\"\n    \"%u block groups\\n\"\n    \"%u blocks per group, %u fragments per group\\n\"\n    \"%u inodes per group\",\n    v70,\n    v8,\n    v46,\n    v8,\n    v46,\n    v44 * v48,\n    i,\n    v61,\n    v69,\n    v51,\n    v55 * v11 * v43,\n    v44,\n    v43,\n    v43,\n    v48);\n  v20 = v8 == 1024;\n  for ( j = 1; j < v44; ++j )\n  {\n    v20 += v43;\n    if ( sub_8080DD4(j) )\n      printf(v22, v20);\n  }\n  sub_804DD98(10);\n  if ( (dword_80DBB9C & 0x100000) == 0 )\n  {\n    v23 = sub_804DB2E(0x400u);\n    v23[19] = 1;\n    *((_WORD *)v23 + 28) = -4269;\n    *((_WORD *)v23 + 44) = v45;\n    if ( v45 != 128 )\n      v23[87] = 1835036;\n    v23[21] = 11;\n    v23[6] = v46;\n    v23[7] = v46;\n    v23[5] = v51;\n    v23[8] = v43;\n    v23[9] = v43;\n    v23[1] = i;\n    v23[2] = v61;\n    v23[10] = v48;\n    *v23 = v19;\n    v23[4] = v19 - 11;\n    v53 = time(0);\n    v23[66] = v53;\n    v23[12] = v53;\n    v23[16] = v53;\n    v23[18] = 0;\n    v23[17] = 15552000;\n    *(_DWORD *)((char *)v23 + 58) = 65537;\n    v23[23] = 32;\n    v23[24] = 2;\n    v23[25] = 1;\n    v23[88] = 2;\n    sub_804E101((_BYTE *)v23 + 104);\n    *((_BYTE *)v23 + 252) = 1;\n    sub_804E101((_BYTE *)v23 + 236);\n    LOBYTE(v24) = *((_BYTE *)v23 + 119) / 0x14u;\n    HIBYTE(v24) = *((_BYTE *)v23 + 119) % 0x14u;\n    *((_WORD *)v23 + 27) = HIBYTE(v24) + 20;\n    sub_80B2C4E(16, v70);\n    v63 = v8 * v55;\n    v47 = (unsigned int *)sub_804DB2E(v8 * v55);\n    v25 = (char *)sub_804DAFA(v8);\n    v23[3] = 0;\n    v26 = v47;\n    v64 = v8 == 1024;\n    v60 = 0;\n    while ( v60 != v44 )\n    {\n      v27 = sub_8080DD4(v60);\n      v28 = 0;\n      if ( v27 )\n        v28 = v55 + 1;\n      *v26 = v28 + v64;\n      v26[1] = v28 + v64 + 1;\n      v26[2] = v28 + v64 + 2;\n      v29 = v28 + v50 + 2;\n      *((_WORD *)v26 + 7) = v48;\n      if ( !v60 )\n      {\n        v29 += v58 + 1;\n        *((_WORD *)v26 + 8) = 2;\n        *((_WORD *)v26 + 7) = v48 - 11;\n      }\n      v62 = 8 * v8;\n      if ( v43 > v57 )\n        v62 = v57;\n      v65 = v62 - v29;\n      sub_8080DEB(v25, v8, v29, v43 - v62);\n      sub_8080E44(*v26 * v8, (*v26 * (unsigned __int64)v8) >> 32, (int)v25, v8);\n      *((_WORD *)v26 + 6) = v65;\n      sub_8080DEB(v25, v8, v48 - *((unsigned __int16 *)v26 + 7), v43 - v48);\n      sub_804DCAD(v8, (int)v25);\n      v23[3] += v65;\n      ++v60;\n      v64 += v43;\n      v57 -= v43;\n      v26 += 8;\n    }\n    for ( k = 0; k != v44; ++k )\n    {\n      if ( sub_8080DD4(k) )\n      {\n        v56 = v8 * (unsigned __int64)v51;\n        if ( v8 == 1024 || (v30 = 1024, k) )\n          v30 = 0;\n        sub_8080E44(v56 + v30, (v56 + (unsigned int)v30) >> 32, (int)v23, 1024);\n        sub_8080E44(v8 + v56, (v8 + v56) >> 32, (int)v47, v63);\n      }\n      v51 += v43;\n    }\n    memset(v25, 0, v8);\n    for ( m = v47 + 2; &v47[8 * k + 2] != m; m += 8 )\n    {\n      for ( n = 0; n != v50; ++n )\n      {\n        v33 = v8 * (unsigned __int64)(n + *m);\n        sub_8080E44(v33, HIDWORD(v33), (int)v25, v8);\n      }\n    }\n    *(_WORD *)v25 = 16877;\n    *((_DWORD *)v25 + 4) = v53;\n    *((_DWORD *)v25 + 2) = v53;\n    *((_DWORD *)v25 + 3) = v53;\n    *((_DWORD *)v25 + 1) = v8;\n    *((_DWORD *)v25 + 7) = v8 >> 9;\n    *((_WORD *)v25 + 13) = 3;\n    v34 = v47[2];\n    *((_DWORD *)v25 + 10) = v34 + v50;\n    v35 = v45 + v8 * (unsigned __int64)v34;\n    sub_8080E44(v35, HIDWORD(v35), (int)v25, v45);\n    *((_WORD *)v25 + 13) = 2;\n    *((_DWORD *)v25 + 1) = v8 * v58;\n    *((_DWORD *)v25 + 7) = (v8 * v58) >> 9;\n    v36 = *((_DWORD *)v25 + 10) + 1;\n    while ( v58 != v54 )\n    {\n      *(_DWORD *)&v25[4 * v54 + 40] = v36 + v54;\n      ++v54;\n    }\n    v37 = 10 * v45 + v47[2] * (unsigned __int64)v8;\n    sub_8080E44(v37, HIDWORD(v37), (int)v25, v45);\n    memset(v25, 0, v8);\n    *((_WORD *)v25 + 2) = v8;\n    for ( ii = 1; ; ++ii )\n    {\n      v39 = v50 + v47[2] + 1;\n      if ( ii >= v54 )\n        break;\n      sub_8080E44(v8 * (ii + v39), (v8 * (unsigned __int64)(ii + v39)) >> 32, (int)v25, v8);\n    }\n    *(_DWORD *)v25 = 11;\n    *((_DWORD *)v25 + 1) = 33619980;\n    v25[8] = 46;\n    *((_DWORD *)v25 + 3) = 2;\n    *((_WORD *)v25 + 8) = v8 - 12;\n    *(_DWORD *)(v25 + 18) = 774767106;\n    sub_8080E44(v8 * v39, (v8 * (unsigned __int64)(unsigned int)v39) >> 32, (int)v25, v8);\n    *(_DWORD *)v25 = 2;\n    *((_WORD *)v25 + 8) = 12;\n    *((_DWORD *)v25 + 6) = 11;\n    *((_WORD *)v25 + 14) = v8 - 24;\n    *((_WORD *)v25 + 15) = 522;\n    strcpy(v25 + 32, \"lost+found\");\n    v40 = v8 * (unsigned __int64)(v47[2] + v50);\n    sub_8080E44(v40, HIDWORD(v40), (int)v25, v8);\n    sub_804DCF3(3);\n  }\n  return 0;\n}\n"
    ],
    "sub_8081719": [
        "0x8081719",
        "int __cdecl sub_8081719(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // eax\n  unsigned int v4; // ebp\n  unsigned __int64 v5; // kr00_8\n  int v6; // esi\n  unsigned __int8 v7; // di\n  unsigned int v8; // eax\n  unsigned __int64 v9; // rax\n  unsigned int v10; // ecx\n  char *v11; // ebx\n  char *v12; // eax\n  char *v13; // edi\n  unsigned int j; // esi\n  unsigned int k; // esi\n  int v16; // ebp\n  unsigned __int64 v18; // [esp+8h] [ebp-D0h]\n  int v19; // [esp+10h] [ebp-C8h]\n  unsigned int i; // [esp+14h] [ebp-C4h]\n  unsigned __int8 v21; // [esp+19h] [ebp-BFh]\n  unsigned __int16 v22; // [esp+1Ah] [ebp-BEh]\n  int fd; // [esp+1Ch] [ebp-BCh]\n  const char *v24; // [esp+24h] [ebp-B4h]\n  int v25; // [esp+24h] [ebp-B4h]\n  int v26; // [esp+28h] [ebp-B0h]\n  time_t v27; // [esp+2Ch] [ebp-ACh]\n  unsigned int v28; // [esp+30h] [ebp-A8h]\n  int v29; // [esp+30h] [ebp-A8h]\n  int v30; // [esp+34h] [ebp-A4h]\n  int v31; // [esp+3Ch] [ebp-9Ch]\n  char *v32; // [esp+40h] [ebp-98h] BYREF\n  unsigned __int8 v33; // [esp+44h] [ebp-94h] BYREF\n  unsigned __int8 v34; // [esp+45h] [ebp-93h]\n  char *src[7]; // [esp+4Ch] [ebp-8Ch] BYREF\n  int v36; // [esp+78h] [ebp-60h]\n\n  v32 = (char *)&data;\n  v30 = sub_80ABEAC(a2, \"^Ab:cCf:F:h:Ii:l:m:n:r:R:s:S:v\", 0, 0, 0, 0, 0, 0, 0, &v32, 0, 0, 0, 0);\n  v2 = a2 + 4 * optind;\n  v24 = *(const char **)v2;\n  v27 = time(0);\n  v19 = sub_804DBE1(v24);\n  sub_804E010(v24);\n  v3 = v36 & 0xF000;\n  if ( v3 == 24576 )\n  {\n    sub_804E0BE(v19, 0x1268u, (int)src, \"BLKSSZGET\");\n    v4 = 512;\n    if ( (int)src[0] > 512 )\n    {\n      v4 = (unsigned int)src[0];\n      sub_804D5F4(\"for this device sector size is %u\", src[0]);\n    }\n  }\n  else\n  {\n    if ( v3 != 0x8000 && !*(_DWORD *)(v2 + 4) )\n      sub_804D5E0(\"image size must be specified\");\n    v30 &= ~4u;\n    v4 = 512;\n  }\n  v5 = sub_80AB8B7(1);\n  v18 = sub_80B4B88(v5, HIDWORD(v5), v4, 0);\n  if ( ioctl(v19, 0x301u, &v33) || !v34 || (v21 = v33) == 0 )\n  {\n    if ( ioctl(v19, 0x801C0204, src) )\n    {\n      if ( v18 != 2400 )\n      {\n        if ( v18 <= 0x960 )\n        {\n          if ( v18 != 720 )\n          {\n            if ( v18 != 1440 )\n            {\nLABEL_17:\n              v21 = -1;\n              v22 = 63;\n              goto LABEL_18;\n            }\n            goto LABEL_25;\n          }\nLABEL_57:\n          v7 = -3;\n          goto LABEL_26;\n        }\n        if ( v18 != 2880 && v18 != 5760 )\n          goto LABEL_17;\n        goto LABEL_56;\n      }\n    }\n    else\n    {\n      v18 = (unsigned int)src[0];\n      if ( src[0] != (char *)1440 && src[0] != (char *)2400 )\n      {\n        if ( src[0] == (char *)720 )\n        {\n          v18 = 720LL;\n          goto LABEL_57;\n        }\nLABEL_56:\n        v7 = -16;\n        goto LABEL_26;\n      }\n    }\nLABEL_25:\n    v7 = -7;\nLABEL_26:\n    v22 = (unsigned int)v18 / 0xA0;\n    if ( v22 < 9u )\n      v22 = 9;\n    v21 = 2;\n    LOBYTE(v6) = 1;\n    goto LABEL_31;\n  }\n  v22 = v34;\nLABEL_18:\n  if ( v5 <= 0x103FFFFF )\n  {\n    LOBYTE(v6) = 1;\n  }\n  else\n  {\n    LOBYTE(v6) = 8;\n    if ( HIDWORD(v5) > 1 )\n      v6 = HIDWORD(v5) < 4 ? 16 : 32;\n  }\n  v7 = -8;\nLABEL_31:\n  if ( (__int64)(v18 - 6) <= 3 )\n    sub_804D5E0(\"the image is too small for FAT32\");\n  v28 = v4 >> 2;\n  v31 = (v4 >> 2) + 1;\n  for ( i = 1; ; i = (i >> 1) | 1 )\n  {\n    while ( 1 )\n    {\n      v9 = sub_80B4B88(v18 - 6 - 2 * i, (v18 - 6 - 2 * i) >> 32, (unsigned __int8)v6, 0);\n      v10 = v9;\n      v26 = v9;\n      if ( v9 > 0x80FFFFFF )\n        goto LABEL_39;\n      v8 = ((int)v9 + v31) / v28 - i;\n      if ( (int)((v10 + v31) / v28 - i) <= 0 )\n        break;\n      i += (v8 >> 1) | 1;\n    }\n    if ( v10 <= 0xFFFFFF0 )\n      break;\nLABEL_39:\n    if ( (_BYTE)v6 == 0x80 )\n      sub_804D5E0(\"can't make FAT32 with >128 sectors/cluster\");\n    LOBYTE(v6) = 2 * v6;\n  }\n  v29 = v7;\n  if ( (v30 & 0x10000) != 0 )\n    fprintf(\n      stderr,\n      \"Device '%s':\\n\"\n      \"heads:%u, sectors/track:%u, bytes/sector:%u\\n\"\n      \"media descriptor:%02x\\n\"\n      \"total sectors:%llu, clusters:%u, sectors/cluster:%u\\n\"\n      \"FATs:2, sectors/FAT:%u\\n\"\n      \"volumeID:%08x, label:'%s'\\n\",\n      v24,\n      v21,\n      v22,\n      v4,\n      v7,\n      v18,\n      v10,\n      (unsigned __int8)v6,\n      i,\n      v27,\n      v32);\n  v25 = (unsigned __int8)v6;\n  v11 = (char *)sub_804DB2E(v4 * ((unsigned __int8)v6 | 6));\n  fd = (int)&v11[v4];\n  strcpy(v11, &unk_80D41F6);\n  *(_WORD *)(v11 + 11) = v4;\n  v11[13] = v6;\n  *((_WORD *)v11 + 7) = 6;\n  v11[16] = 2;\n  if ( v18 <= 0xFFFF )\n    *(_WORD *)(v11 + 19) = v18;\n  v11[21] = v7;\n  *((_WORD *)v11 + 12) = v22;\n  *((_WORD *)v11 + 13) = v21;\n  *((_DWORD *)v11 + 8) = v18;\n  *((_DWORD *)v11 + 9) = i;\n  *((_DWORD *)v11 + 11) = 2;\n  *((_DWORD *)v11 + 12) = 196609;\n  v11[66] = 41;\n  *(_DWORD *)(v11 + 67) = v27;\n  *(_DWORD *)(v11 + 82) = 861159750;\n  *(_DWORD *)(v11 + 86) = 538976306;\n  strncpy(v11 + 71, v32, 0xBu);\n  qmemcpy(v11 + 90, &unk_80D4223, 0x3Bu);\n  *((_WORD *)v11 + 255) = -21931;\n  v12 = &v11[v4];\n  *(_DWORD *)v12 = 1096897106;\n  *((_DWORD *)v12 + 121) = 1631679090;\n  v13 = &v11[v4];\n  *((_DWORD *)v13 + 122) = v26 - 1;\n  *((_DWORD *)v13 + 123) = 2;\n  *((_WORD *)v13 + 255) = -21931;\n  sub_804DCAD(3 * v4, (int)v11);\n  sub_804DCAD(3 * v4, (int)v11);\n  memset(v11, 0, 2 * v4);\n  *(_DWORD *)v11 = v29 | 0xFFFFF00;\n  *((_DWORD *)v11 + 1) = -1;\n  *((_DWORD *)v11 + 2) = 268435448;\n  sub_804DCAD(v4, (int)v11);\n  for ( j = 1; i > j; ++j )\n    sub_804DCAD(v4, fd);\n  sub_804DCAD(v4, (int)v11);\n  for ( k = 1; i > k; ++k )\n    sub_804DCAD(v4, fd);\n  v16 = v25 * v4;\n  memset(v11, 0, v16);\n  if ( *v32 )\n  {\n    strncpy(v11, v32, 0xBu);\n    v11[11] = 8;\n  }\n  sub_804DCAD(v16, (int)v11);\n  return 0;\n}\n"
    ],
    "sub_8081C9E": [
        "0x8081c9e",
        "int __cdecl sub_8081C9E(int a1, int a2)\n{\n  int v2; // ebx\n  __int64 v3; // kr00_8\n  __int64 v4; // kr08_8\n  int v6; // [esp+4h] [ebp-1Ch]\n  const char *v7; // [esp+Ch] [ebp-14h] BYREF\n\n  v7 = &data;\n  sub_80ABEAC(a2, \"^L:\", &v7);\n  v2 = sub_804DBE1(*(const char **)(a2 + 4 * optind));\n  v3 = sub_80AB8B7(1);\n  v6 = getpagesize();\n  v4 = v3 - (unsigned int)v6;\n  printf(\"Setting up swapspace version 1, size = %llu bytes\\n\", v4);\n  sub_804DCAD(1024, (int)&qword_80DB778);\n  LODWORD(qword_80DB778) = 1;\n  HIDWORD(qword_80DB778) = sub_80B4B88(v4, HIDWORD(v4), v6, 0);\n  sub_80B2C4E(16, v7);\n  sub_804DCAD(516, (int)&qword_80DB778);\n  sub_804DD09(0, v6 - 10, 0);\n  sub_804DCAD(10, (int)\"SWAPSPACE2dflsu\");\n  fsync(v2);\n  return 0;\n}\n"
    ],
    "sub_8081D96": [
        "0x8081d96",
        "_BOOL4 sub_8081D96()\n{\n  _BOOL4 result; // eax\n\n  result = sub_804D878(qword_80DB778, (int *)&qword_80DB778 + 1, &unk_80DB780);\n  --unk_80DB780;\n  return result;\n}\n"
    ],
    "sub_8081DB1": [
        "0x8081db1",
        "void __fastcall __noreturn sub_8081DB1(int a1, int a2)\n{\n  sub_804D830(10, a2);\n  tcsetattr(qword_80DB778, 0, (const struct termios *)&qword_80DB784);\n  _exit(1);\n}\n"
    ],
    "sub_8081DD4": [
        "0x8081dd4",
        "int __cdecl sub_8081DD4(int a1, int a2)\n{\n  int v3; // ecx\n  int v4; // esi\n  FILE *v5; // ebp\n  unsigned int v6; // ebx\n  int v7; // edi\n  char *IO_write_base; // eax\n  int i; // ebx\n  char *v10; // eax\n  unsigned __int8 v11; // al\n  unsigned __int8 v12; // dl\n  unsigned int v13; // edx\n  _BYTE *v14; // edx\n  int v15; // [esp-4h] [ebp-8Ch]\n  int v16; // [esp+0h] [ebp-88h]\n  _DWORD *v17; // [esp+4h] [ebp-84h]\n  FILE *stream; // [esp+8h] [ebp-80h]\n  int v19; // [esp+Ch] [ebp-7Ch]\n  int v20; // [esp+14h] [ebp-74h]\n\n  sub_80ABEAC(a2, 135086754);\n  v17 = (_DWORD *)(a2 + 4 * optind);\n  if ( !isatty(1) )\n    return sub_80A98A4();\n  stream = (FILE *)sub_80B3D37();\n  if ( !stream )\n    return sub_80A98A4();\n  LODWORD(qword_80DB778) = fileno_unlocked(stream);\n  sub_804DA14(0, (struct termios *)&qword_80DB784, qword_80DB778);\n  sub_804E6C8(117503054, (void (*)(int))sub_8081DB1);\n  v3 = v15;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = stdin;\n    if ( !*v17 )\n      break;\n    v5 = (FILE *)sub_80B3D18(v3, \"r\");\n    if ( v5 )\n      break;\nLABEL_41:\n    if ( *v17 )\n    {\n      if ( *++v17 )\n        continue;\n    }\n    goto LABEL_43;\n  }\n  fileno_unlocked(v5);\n  fstat64();\n  sub_8081D96();\n  v19 = 0;\n  v6 = 0;\n  v7 = 0;\n  v20 = 0;\n  v16 = -1;\nLABEL_8:\n  if ( !v20 )\n  {\n    IO_write_base = v5->_IO_write_base;\n    if ( IO_write_base < v5->_IO_write_end )\n    {\n      v5->_IO_write_base = IO_write_base + 1;\n      v16 = (unsigned __int8)*IO_write_base;\n      goto LABEL_13;\n    }\n    v16 = __fgetc_unlocked();\n    if ( v16 != -1 )\n      goto LABEL_13;\n    fclose(v5);\n    sub_804DD8F();\n    goto LABEL_41;\n  }\n  --v20;\nLABEL_13:\n  while ( v4 == 114 || !v7 )\n  {\nLABEL_27:\n    if ( v16 == 9 )\n    {\n      v20 = ~(_BYTE)v6 & 7;\n      v16 = 32;\n    }\n    v13 = ++v6;\n    if ( v6 > HIDWORD(qword_80DB778) || v16 == 10 )\n    {\n      if ( ++v19 >= (unsigned int)unk_80DB780 || v4 == 10 )\n        v7 = 1;\n      v6 = 0;\n      if ( v16 != 10 && v13 > HIDWORD(qword_80DB778) )\n        continue;\n    }\n    v14 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v14 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v14 + 1;\n      *v14 = v16;\n    }\n    sub_804DD80();\n    goto LABEL_8;\n  }\n  for ( i = printf(\"--More-- \"); ; i = printf(\"(Enter:next line Space:next page Q:quit R:show the rest)\") )\n  {\n    sub_804DD8F();\n    v10 = stream->_IO_write_base;\n    if ( v10 >= stream->_IO_write_end )\n    {\n      v11 = __fgetc_unlocked();\n    }\n    else\n    {\n      stream->_IO_write_base = v10 + 1;\n      v11 = *v10;\n    }\n    v12 = v11;\n    if ( (unsigned __int8)(v11 - 65) <= 0x19u )\n      v12 = v11 + 32;\n    v4 = v12;\n    printf(\"\\r%*s\\r\", i, &data);\n    if ( v4 == 113 )\n      break;\n    if ( v4 == 32 || v4 == 10 || v4 == 114 )\n    {\n      sub_8081D96();\n      v19 = 0;\n      v6 = 0;\n      v7 = 0;\n      goto LABEL_27;\n    }\n  }\nLABEL_43:\n  tcsetattr(qword_80DB778, 0, (const struct termios *)&qword_80DB784);\n  return 0;\n}\n"
    ],
    "sub_80820C6": [
        "0x80820c6",
        "size_t __usercall sub_80820C6@<eax>(const char *a1@<eax>, const char **a2@<edx>)\n{\n  char *v4; // eax\n  char *v5; // esi\n  const char *v6; // edi\n  int v7; // edx\n  int v8; // eax\n  size_t v9; // edi\n  size_t v10; // eax\n  const char *v11; // eax\n  size_t v13; // [esp+4h] [ebp-1Ch]\n  char *v14; // [esp+4h] [ebp-1Ch]\n  size_t n; // [esp+8h] [ebp-18h]\n  int v16; // [esp+Ch] [ebp-14h]\n\n  n = 0x8000;\n  while ( 2 )\n  {\n    v4 = strchr(a1, 44);\n    v5 = v4;\n    if ( v4 )\n      *v4 = 0;\n    v6 = \"loop\";\n    v7 = 0;\n    do\n    {\n      v16 = v7;\n      v13 = strlen(v6);\n      if ( !strncasecmp(v6, a1, v13) && (!a1[v13] || v6[v13 - 1] == 61) )\n      {\n        v8 = dword_80B65E0[v16];\n        if ( v8 >= 0 )\n          n |= v8;\n        else\n          n &= v8;\n        goto LABEL_20;\n      }\n      v6 += v13 + 1;\n      v7 = v16 + 1;\n    }\n    while ( v16 != 43 );\n    if ( *a1 && a2 )\n    {\n      v14 = (char *)*a2;\n      v9 = 0;\n      if ( *a2 )\n        v9 = strlen(*a2);\n      v10 = strlen(a1);\n      v11 = (const char *)sub_804DB13(v14, v10 + v9 + 2);\n      *a2 = v11;\n      if ( v9 )\n        v11[v9++] = 44;\n      strcpy((char *)&v11[v9], a1);\n    }\nLABEL_20:\n    if ( v5 )\n    {\n      *v5 = 44;\n      a1 = v5 + 1;\n      continue;\n    }\n    return n;\n  }\n}\n"
    ],
    "sub_80821AC": [
        "0x80821ac",
        "const char *__usercall sub_80821AC@<eax>(void **a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  const char *v4; // ebx\n  _BYTE *v5; // eax\n  size_t v6; // edi\n  char *v7; // eax\n  const char *v8; // ebp\n  const char *i; // edx\n  char v10; // al\n  char *v11; // eax\n  char *v12; // ebp\n\n  v4 = a2;\n  v5 = *a1;\n  if ( v5 && *v5 )\n  {\n    while ( *v4 )\n    {\n      v6 = strlen(v4);\n      v7 = strchr(v4, 44);\n      if ( v7 )\n        v6 = v7 - v4;\n      v8 = (const char *)*a1;\n      for ( i = (const char *)*a1; ; i = v11 + 1 )\n      {\n        a3 = i;\n        if ( !strncmp(i, v4, v6) )\n        {\n          v10 = a3[v6];\n          if ( !v10 || v10 == 44 )\n            break;\n        }\n        v11 = strchr(a3, 44);\n        if ( !v11 )\n        {\n          v12 = sub_804DDBF(\"%s,%.*s\", v8, v6, v4);\n          free(*a1);\n          *a1 = v12;\n          break;\n        }\n      }\n      for ( v4 += v6; *v4 == 44; ++v4 )\n        ;\n    }\n  }\n  else\n  {\n    *a1 = sub_804DB46(a2);\n  }\n  return a3;\n}\n"
    ],
    "sub_8082260": [
        "0x8082260",
        "int __usercall sub_8082260@<eax>(void *data@<ecx>, const char **a2@<eax>, int a3@<edx>)\n{\n  unsigned int i; // ebx\n  int *v6; // ebp\n  int result; // eax\n  int v8; // edx\n\n  for ( i = a3 & 0x87FFFFFF; ; i |= 1u )\n  {\n    v6 = (int *)dword_80DBB7C;\n    *(_DWORD *)dword_80DBB7C = 0;\n    result = mount(*a2, a2[1], a2[2], i, data);\n    if ( !result )\n      break;\n    v8 = *v6;\n    if ( (i & 1) != 0 || v8 != 30 && v8 != 13 )\n    {\n      if ( v8 == 1 )\n        sub_804D5E0(\"permission denied (are you root?)\");\n      return result;\n    }\n    if ( (i & 0x8000) == 0 )\n      sub_804D5F4(\"%s is write-protected, mounting read-only\", *a2);\n  }\n  return result;\n}\n"
    ],
    "sub_80822D1": [
        "0x80822d1",
        "int __usercall sub_80822D1@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  char *v4; // esi\n  const char *v5; // edi\n  char v6; // al\n  const char *v7; // edi\n  size_t v8; // eax\n  const char *v9; // esi\n  int v10; // edx\n  char v11; // bp\n  size_t v12; // eax\n  char *v13; // edx\n  char *v14; // eax\n  int v15; // edi\n  const char *v16; // eax\n  char *v17; // eax\n  const char *v18; // ebp\n  char *v19; // esi\n  char *v20; // eax\n  int v21; // ecx\n  char *v22; // edi\n  const char *v23; // eax\n  const char *v24; // edx\n  char *v25; // eax\n  int v26; // eax\n  int v27; // edi\n  int v28; // esi\n  int v29; // ebx\n  const char *v30; // ebp\n  char *v31; // eax\n  int v32; // edx\n  int v33; // ecx\n  _BYTE *v34; // eax\n  _BYTE *v35; // ebp\n  char *v36; // eax\n  int v37; // ecx\n  _DWORD *v38; // ebp\n  int v40; // [esp-8h] [ebp-94h]\n  const char *v41; // [esp-8h] [ebp-94h]\n  int v42; // [esp-4h] [ebp-90h]\n  int v43; // [esp-4h] [ebp-90h]\n  int v44; // [esp+0h] [ebp-8Ch]\n  int v45; // [esp+0h] [ebp-8Ch]\n  const char *v46; // [esp+4h] [ebp-88h]\n  int v47; // [esp+4h] [ebp-88h]\n  int v48; // [esp+4h] [ebp-88h]\n  const char *v49; // [esp+Ch] [ebp-80h]\n  char *haystack; // [esp+14h] [ebp-78h] BYREF\n  int v52; // [esp+18h] [ebp-74h]\n  char v53[16]; // [esp+1Ch] [ebp-70h] BYREF\n  int v54; // [esp+2Ch] [ebp-60h]\n\n  haystack = 0;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v44 = sub_80820C6(a1[3], (const char **)&haystack);\n  v3 = a1[2];\n  if ( v3 && !strcmp(v3, \"auto\") )\n    a1[2] = 0;\n  v4 = (char *)a1[2];\n  if ( !v4 || !strcmp(v4, \"cifs\") )\n  {\n    v5 = *a1;\n    v6 = **a1;\n    if ( (v6 == 47 || v6 == 92) && v6 == v5[1] )\n    {\n      v7 = v5 + 2;\n      v8 = strcspn(v7, \"/\\\\\");\n      v9 = &v7[v8 + 1];\n      v10 = -1;\n      if ( v8 )\n      {\n        v11 = v7[v8];\n        if ( v11 )\n        {\n          if ( *v9 )\n          {\n            v7[v8] = 0;\n            v12 = strcspn(v9, \"/\\\\\");\n            v13 = \"unc=\\\\\\\\%s\\\\%.*s\";\n            if ( v9[v12] )\n              v13 = \"unc=\\\\\\\\%s\\\\%.*s,prefixpath=%s\";\n            v14 = sub_804DDBF(v13, v7, v12, v9, &v9[v12 + 1]);\n            sub_80820C6(v14, (const char **)&haystack);\n            v15 = sub_80B45B2();\n            *((_BYTE *)v9 - 1) = v11;\n            v10 = -1;\n            if ( v15 )\n            {\n              if ( !sub_804D210(haystack, \"ip=\") && !strstr(haystack, \",ip=\") )\n              {\n                v16 = (const char *)sub_80B46B6(v42, v40);\n                v17 = sub_804DDBF(\"ip=%s\", v16);\n                sub_80820C6(v17, (const char **)&haystack);\n              }\n              a1[2] = \"cifs\";\n              v10 = sub_8082260(haystack, a1, v44);\n            }\n          }\n        }\n      }\n      goto LABEL_77;\n    }\n    if ( !v4 )\n      goto LABEL_88;\n  }\n  if ( sub_804D210(v4, \"nfs\") )\n  {\nLABEL_88:\n    v18 = *a1;\n    if ( strchr(*a1, 58) )\n    {\n      if ( !a1[2] )\n        a1[2] = \"nfs\";\n      v19 = haystack;\n      v20 = strchr(v18, 93);\n      v21 = v43;\n      if ( !v20 || (v22 = v20 + 1, v20[1] != 58) )\n        v22 = strchr(v18, 58);\n      *v22 = 0;\n      sub_80B45BD(v21, 0);\n      *v22 = 58;\n      v23 = (const char *)((int (*)(void))sub_80B46B6)();\n      v24 = \"Linux User,,,\" + 12;\n      if ( !v19 )\n      {\n        v24 = &data;\n        v19 = (char *)&data;\n      }\n      v25 = sub_804DDBF(\"%s%saddr=%s\", v19, v24, v23);\n      v10 = sub_8082260(v25, a1, v44);\n      goto LABEL_77;\n    }\n  }\n  v41 = *a1;\n  if ( stat64() || (v44 & 0x3020) != 0 )\n    goto LABEL_44;\n  v26 = v54 & 0xF000;\n  if ( v26 != 0x8000 )\n  {\n    v27 = (int)a1[2];\n    if ( v26 == 0x4000 && !v27 )\n    {\n      v44 |= 0x1000u;\nLABEL_45:\n      v28 = -1;\nLABEL_46:\n      if ( a1[2] || (v44 & 0x3020) != 0 )\n      {\n        while ( 1 )\n        {\n          v30 = a1[2];\n          if ( v30 )\n          {\n            v31 = strchr(v30, 44);\n            v30 = v31;\n            if ( v31 )\n              *v31 = 0;\n          }\n          v10 = sub_8082260(haystack, a1, v44);\n          if ( !v10 )\n            break;\n          if ( !v30 )\n            goto LABEL_73;\n          a1[2] = v30 + 1;\n        }\nLABEL_52:\n        v10 = 0;\n      }\n      else\n      {\n        if ( !(_DWORD)qword_80DB778 )\n        {\n          v52 = 0;\n          v46 = \"/etc/filesystems\";\n          do\n          {\n            if ( sub_80B3D37() )\n            {\n              while ( 1 )\n              {\n                v34 = (_BYTE *)sub_80AB85A();\n                v35 = v34;\n                if ( !v34 )\n                  break;\n                if ( !sub_804D210(v34, \"nodev\") || v35[5] != 32 && (unsigned __int8)(v35[5] - 9) > 4u )\n                {\n                  v49 = (const char *)sub_80B2E8C(v33, v32);\n                  if ( *v49 != 42 && *v49 != 35 )\n                  {\n                    if ( *v49 )\n                    {\n                      v36 = sub_804DB46(v49);\n                      sub_80AFADF(v37, v36);\n                    }\n                  }\n                }\n                free(v35);\n              }\n            }\n            v46 += 18;\n          }\n          while ( v46 != (const char *)&unk_80B65C4 );\n          LODWORD(qword_80DB778) = v52;\n        }\n        v38 = (_DWORD *)qword_80DB778;\n        v10 = -1;\n        while ( v38 )\n        {\n          a1[2] = (const char *)v38[1];\n          v10 = sub_8082260(haystack, a1, v44);\n          if ( !v10 )\n            goto LABEL_52;\n          v38 = (_DWORD *)*v38;\n        }\nLABEL_73:\n        if ( v27 )\n        {\n          v47 = v10;\n          sub_80AFDF4();\n          v10 = v47;\n        }\n      }\n      if ( v28 != -1 )\n      {\n        v48 = v10;\n        close(v28);\n        v10 = v48;\n      }\nLABEL_77:\n      if ( *(_DWORD *)dword_80DBB7C == 16 )\n      {\n        if ( !a2 )\n          goto LABEL_82;\n      }\n      else if ( *(_DWORD *)dword_80DBB7C != 2 || (v44 & 0x10000000) == 0 )\n      {\nLABEL_82:\n        if ( v10 )\n        {\n          v45 = v10;\n          sub_804D3A5((int)\"mounting %s on %s failed\", *a1, a1[1]);\n          return v45;\n        }\n        return v10;\n      }\n      return 0;\n    }\nLABEL_44:\n    v27 = 0;\n    goto LABEL_45;\n  }\n  v27 = sub_80B2E23(v53, v41);\n  *a1 = 0;\n  v28 = sub_80AFE28(0, 0, v44 & 1 | 4);\n  if ( v28 >= 0 )\n    goto LABEL_46;\n  v29 = dword_80DBB7C;\n  if ( *(_DWORD *)dword_80DBB7C == 13 || *(_DWORD *)dword_80DBB7C == 1 )\n    sub_804D5F4(\"permission denied (are you root?)\");\n  else\n    sub_804D3A5((int)\"can't setup loop device\");\n  return *(_DWORD *)v29;\n}\n"
    ],
    "sub_8082740": [
        "0x8082740",
        "int __cdecl sub_8082740(int a1, int a2)\n{\n  const char *v2; // ecx\n  int *v3; // edi\n  int v4; // ebx\n  int v5; // edx\n  int v6; // edx\n  const char *v7; // ecx\n  char v8; // bl\n  const char *v9; // eax\n  const char *v10; // ecx\n  FILE *v11; // ebx\n  char *mnt_type; // esi\n  char *v13; // eax\n  struct mntent *v14; // eax\n  unsigned int v15; // eax\n  struct mntent *v16; // edi\n  struct mntent *v17; // ebx\n  char *i; // eax\n  bool v19; // zf\n  const char *v20; // esi\n  const char *mnt_fsname; // ebp\n  const char *mnt_dir; // ebp\n  char *v23; // ebp\n  int v24; // esi\n  size_t v25; // ebx\n  const char *j; // ecx\n  char v27; // al\n  char *v28; // eax\n  const char *v29; // ecx\n  char *s1; // [esp+0h] [ebp-74h]\n  const char *s1a; // [esp+0h] [ebp-74h]\n  int v33; // [esp+4h] [ebp-70h]\n  int v34; // [esp+8h] [ebp-6Ch]\n  int v35; // [esp+Ch] [ebp-68h]\n  char *mnt_opts; // [esp+10h] [ebp-64h]\n  FILE *stream; // [esp+14h] [ebp-60h]\n  _BYTE *v38; // [esp+18h] [ebp-5Ch]\n  char *s; // [esp+1Ch] [ebp-58h]\n  char *v40; // [esp+20h] [ebp-54h] BYREF\n  char *s2; // [esp+24h] [ebp-50h] BYREF\n  char *v42; // [esp+28h] [ebp-4Ch] BYREF\n  int v43; // [esp+2Ch] [ebp-48h] BYREF\n  char *file; // [esp+30h] [ebp-44h] BYREF\n  struct mntent result[2]; // [esp+34h] [ebp-40h] BYREF\n\n  v40 = (char *)sub_804DB2E(1u);\n  s2 = 0;\n  v42 = 0;\n  v43 = 0;\n  file = \"/etc/fstab\";\n  v33 = sub_80AFD54();\n  v3 = (int *)(a2 + 4);\n  v4 = 1;\n  while ( 1 )\n  {\n    v5 = *v3;\n    if ( !*v3 )\n      break;\n    if ( *(_BYTE *)v5 == 45 && *(_BYTE *)(v5 + 1) == 45 )\n      sub_80821AC((void **)&v40, (const char *)(v5 + 2), v2);\n    else\n      *(_DWORD *)(a2 + 4 * v4++) = v5;\n    ++v3;\n  }\n  *(_DWORD *)(a2 + 4 * v4) = 0;\n  v8 = sub_80ABEAC(a2, \"^o:*t:rwanfvsiO:T:\", &v43, &s2, &v42, &file);\n  while ( v43 )\n  {\n    v9 = (const char *)sub_80AFB01(s1);\n    sub_80821AC((void **)&v40, v9, v10);\n  }\n  if ( (v8 & 4) != 0 )\n    sub_80821AC((void **)&v40, \"ro\", v7);\n  if ( (v8 & 8) != 0 )\n    sub_80821AC((void **)&v40, \"rw\", v7);\n  v34 = a2 + 4 * optind;\n  s1a = *(const char **)v34;\n  if ( *(_DWORD *)v34 )\n  {\n    v13 = *(char **)(v34 + 4);\n    if ( v13 )\n    {\n      if ( !v33 )\n      {\n        result[0].mnt_fsname = *(char **)v34;\n        result[0].mnt_dir = v13;\n        result[0].mnt_type = s2;\n        result[0].mnt_opts = v40;\n        v14 = result;\n        return sub_80822D1((const char **)&v14->mnt_fsname, 0);\n      }\nLABEL_27:\n      sub_804D5E0(\"you must be root\");\n    }\n    s1a = (const char *)sub_80B2E23(v7, v6);\n  }\n  else if ( (v8 & 0x10) == 0 )\n  {\n    v11 = setmntent(\"/proc/mounts\", \"r\");\n    if ( !v11 )\n      sub_804D5E0(\"no %s\", \"/proc/mounts\");\n    while ( getmntent_r(v11, result, (char *)&qword_80DB778 + 4, 1020) )\n    {\n      mnt_type = result[0].mnt_type;\n      if ( !s2 || !strcmp(result[0].mnt_type, s2) )\n        printf(\"%s on %s type %s (%s)\\n\", result[0].mnt_fsname, result[0].mnt_dir, mnt_type, result[0].mnt_opts);\n    }\n    return 0;\n  }\n  v15 = sub_80820C6(v40, 0);\n  if ( v33 && (v15 & 0xFFFF7FFF) != 0 )\n    goto LABEL_27;\n  if ( (v15 & 0x1E0000) != 0 )\n  {\n    if ( mount(&data, *(const char **)v34, &data, v15, &data) )\n      sub_804D3FF(*(const char **)v34);\n    return 0;\n  }\n  if ( v33 )\n    file = \"/etc/fstab\";\n  if ( (v15 & 0x20) != 0 )\n    file = \"/proc/mounts\";\n  stream = setmntent(file, \"r\");\n  if ( !stream )\n    sub_804D3C9((int)\"can't read '%s'\", file);\n  memset(result, 0, sizeof(result));\n  v16 = result;\n  v35 = 0;\nLABEL_42:\n  v17 = &result[1];\n  for ( i = (char *)&dword_80DB978 + 2; ; i = (char *)&qword_80DB778 + 4 )\n  {\n    v19 = getmntent_r(stream, v16, i, 510) == 0;\n    v20 = *(const char **)v34;\n    if ( v19 )\n      break;\n    if ( v20 )\n    {\n      mnt_fsname = v16->mnt_fsname;\n      if ( !strcmp(v20, v16->mnt_fsname)\n        || !strcmp(s1a, mnt_fsname)\n        || (mnt_dir = v16->mnt_dir, !strcmp(v20, mnt_dir))\n        || !strcmp(s1a, mnt_dir) )\n      {\n        v16 = v17;\n      }\n    }\n    else\n    {\n      if ( v33 )\n        goto LABEL_27;\n      if ( sub_80B0232() && (sub_80820C6(v16->mnt_opts, 0) & 0x60000000) == 0 && strcasecmp(v16->mnt_type, \"swap\") )\n      {\n        v23 = v42;\n        mnt_opts = v16->mnt_opts;\n        if ( v42 )\n        {\n          while ( *v23 )\n          {\n            v24 = 0;\n            if ( *v23 == 110 && v23[1] == 111 )\n            {\n              v23 += 2;\n              v24 = 1;\n            }\n            v38 = (_BYTE *)strchrnul();\n            v25 = v38 - v23;\n            for ( j = mnt_opts; ; j = v28 + 1 )\n            {\n              s = (char *)j;\n              if ( !strncmp(j, v23, v25) )\n              {\n                v27 = s[v25];\n                if ( v27 == 44 || !v27 )\n                {\n                  if ( v24 )\n                    goto LABEL_49;\n                  goto LABEL_73;\n                }\n              }\n              v28 = strchr(s, 44);\n              if ( !v28 )\n                break;\n            }\n            if ( !v24 )\n              goto LABEL_49;\nLABEL_73:\n            if ( !*v38 )\n              break;\n            v23 = v38 + 1;\n          }\n        }\n        v16->mnt_opts = sub_804DB46(mnt_opts);\n        if ( !sub_80AB375() && sub_80822D1((const char **)&v16->mnt_fsname, 1) )\n          ++v35;\n        free(v16->mnt_opts);\n      }\n    }\nLABEL_49:\n    v17 = result;\n    if ( v16 == result )\n      goto LABEL_42;\n  }\n  if ( v20 )\n  {\n    if ( !v17->mnt_fsname )\n      sub_804D5E0(\"can't find %s in %s\", v20, file);\n    if ( !v33 || (sub_80820C6(v17->mnt_opts, 0) & 0x8000000) != 0 )\n    {\n      v17->mnt_opts = sub_804DB46(v17->mnt_opts);\n      sub_80821AC((void **)&v17->mnt_opts, v40, v29);\n      v14 = v17;\n      return sub_80822D1((const char **)&v14->mnt_fsname, 0);\n    }\n    goto LABEL_27;\n  }\n  return v35;\n}\n"
    ],
    "sub_8082BC5": [
        "0x8082bc5",
        "int __cdecl sub_8082BC5(int a1, int a2)\n{\n  char v2; // di\n  const char *v3; // esi\n  int v4; // ebx\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  const char *v7; // eax\n  char *v8; // ebp\n  int v9; // ecx\n  int v10; // edx\n  unsigned int v11; // ebp\n  unsigned int v12; // eax\n  const char *v13; // eax\n  unsigned __int64 v15; // [esp+10h] [ebp-70h]\n  __int16 v16; // [esp+20h] [ebp-60h]\n  unsigned __int64 dev; // [esp+30h] [ebp-50h]\n\n  v2 = sub_80ABEAC(a2, \"^qdxn\");\n  v3 = *(const char **)(a2 + 4 * optind);\n  if ( (v2 & 4) != 0 )\n  {\n    v4 = stat64();\n    if ( !v4 )\n    {\n      if ( (v16 & 0xF000) == 24576 )\n      {\n        v5 = gnu_dev_minor(dev);\n        v6 = gnu_dev_major(dev);\n        printf(\"%u:%u\\n\", v6, v5);\n        return v4;\n      }\n      *(_DWORD *)dword_80DBB7C = 0;\n      v7 = \"%s: not a block device\";\n      goto LABEL_21;\n    }\nLABEL_20:\n    v7 = \"\\r\\n%s\" + 2;\nLABEL_21:\n    v4 = v2 & 1;\n    if ( (v2 & 1) == 0 )\n    {\n      sub_804D3A5((int)v7, v3);\n      return 1;\n    }\n    return v4;\n  }\n  if ( lstat64() )\n    goto LABEL_20;\n  *(_DWORD *)dword_80DBB7C = 20;\n  if ( (v16 & 0xF000) != 0x4000 )\n    goto LABEL_20;\n  v8 = sub_804DDBF(\"%s/..\", v3);\n  if ( stat64() )\n  {\n    v3 = v8;\n    goto LABEL_20;\n  }\n  v9 = 0;\n  v10 = 0;\n  v4 = 0;\n  if ( (v2 & 2) != 0 )\n  {\n    v11 = gnu_dev_minor(v15);\n    v12 = gnu_dev_major(v15);\n    printf(\"%u:%u\\n\", v12, v11);\n  }\n  if ( (v2 & 8) != 0 )\n  {\n    v13 = (const char *)sub_80AB672(v9, v10);\n    if ( !v13 )\n      v13 = \"UNKNOWN\";\n    printf(\"%s %s\\n\", v13, v3);\n  }\n  if ( (v2 & 0xB) == 0 )\n    printf(\"%s is %sa mountpoint\\n\", v3, &data);\n  return v4;\n}\n"
    ],
    "sub_8082D9C": [
        "0x8082d9c",
        "int __cdecl sub_8082D9C(int a1, int a2)\n{\n  int v3; // [esp-8h] [ebp-8h]\n  int v4; // [esp-4h] [ebp-4h]\n\n  if ( a1 != 3 )\n    sub_804CDC2();\n  v4 = *(_DWORD *)(a2 + 8);\n  v3 = *(_DWORD *)(a2 + 4);\n  if ( pivot_root() < 0 )\n    sub_80B0A23(v4, v3);\n  return 0;\n}\n"
    ],
    "sub_8082DC5": [
        "0x8082dc5",
        "void __cdecl __noreturn sub_8082DC5(int a1)\n{\n  sub_804D5E0(\"timeout connecting to time server\");\n}\n"
    ],
    "sub_8082DCF": [
        "0x8082dcf",
        "int __cdecl sub_8082DCF(int a1, int a2)\n{\n  time_t v2; // ecx\n  int v3; // ebx\n  const char *v4; // esi\n  int v5; // eax\n  char *v6; // eax\n  time_t v8[2]; // [esp+0h] [ebp-Ch] BYREF\n\n  v8[0] = v2;\n  v3 = sub_80ABEAC(a2, \"^sp\");\n  v4 = *(const char **)(a2 + 4 * optind);\n  alarm(0xAu);\n  signal(14, (__sighandler_t)sub_8082DC5);\n  v5 = sub_80B4645();\n  if ( sub_804E5BC(4u, v8, v5) != 4 )\n    sub_804D5E0(\"%s: %s\", v4, \"short read\");\n  v8[0] = _byteswap_ulong(v8[0]) + 2085978496;\n  if ( (v3 & 2) != 0 )\n    goto LABEL_4;\n  if ( time(0) == v8[0] )\n  {\n    sub_804D5F4(\"current time matches remote time\");\n  }\n  else if ( stime(v8) < 0 )\n  {\n    sub_804D3C9((int)\"can't set time of day\");\n  }\n  if ( v3 != 1 )\n  {\nLABEL_4:\n    v6 = ctime(v8);\n    printf(\"%s\", v6);\n  }\n  return 0;\n}\n"
    ],
    "sub_8082E90": [
        "0x8082e90",
        "int __cdecl sub_8082E90(int a1, int a2)\n{\n  __int16 v2; // ax\n  int v3; // ebx\n  int v4; // edi\n  unsigned int *v5; // ecx\n  unsigned int v6; // eax\n  _DWORD *v7; // edx\n  int v8; // ebx\n  unsigned int *i; // eax\n  bool v10; // cl\n  unsigned int v11; // ebx\n  unsigned int v12; // esi\n  int v13; // esi\n  unsigned __int64 v14; // rax\n  long double v15; // fst7\n  unsigned __int64 v16; // rcx\n  unsigned int v17; // edi\n  unsigned int k; // esi\n  bool v20; // [esp+13h] [ebp-209h]\n  int v21; // [esp+24h] [ebp-1F8h]\n  __int64 v22; // [esp+24h] [ebp-1F8h]\n  unsigned __int64 v23; // [esp+24h] [ebp-1F8h]\n  unsigned int v24; // [esp+2Ch] [ebp-1F0h]\n  int j; // [esp+30h] [ebp-1ECh]\n  unsigned int v26; // [esp+34h] [ebp-1E8h]\n  unsigned int v27; // [esp+38h] [ebp-1E4h]\n  unsigned int *v28; // [esp+44h] [ebp-1D8h]\n  __int64 v29; // [esp+4Ch] [ebp-1D0h]\n  __int16 v30; // [esp+54h] [ebp-1C8h]\n  const char *v31; // [esp+64h] [ebp-1B8h] BYREF\n  const char *v32; // [esp+68h] [ebp-1B4h] BYREF\n  unsigned int v33; // [esp+6Ch] [ebp-1B0h]\n  int v34; // [esp+70h] [ebp-1ACh] BYREF\n  __int64 v35; // [esp+74h] [ebp-1A8h] BYREF\n  __int64 v36; // [esp+7Ch] [ebp-1A0h] BYREF\n  unsigned __int8 v37; // [esp+84h] [ebp-198h] BYREF\n  char v38[128]; // [esp+8Ch] [ebp-190h] BYREF\n  char v39[128]; // [esp+10Ch] [ebp-110h] BYREF\n  char v40[128]; // [esp+18Ch] [ebp-90h] BYREF\n  int *v41; // [esp+20Ch] [ebp-10h]\n\n  v41 = &a1;\n  v32 = \"/proc/profile\";\n  v31 = \"/boot/System.map\";\n  v34 = 0;\n  v2 = sub_80ABEAC(a2, \"M:+m:p:nabsirv\", &v34, &v31, &v32);\n  v30 = v2;\n  if ( (v2 & 0x101) != 0 )\n  {\n    v3 = (v2 & 1) == 0 ? 1 : 4;\n    v4 = sub_804DBE1(\"/proc/profile\");\n    sub_804DCAD(v3, (int)&v34);\n    close(v4);\n  }\n  else\n  {\n    v33 = 0x7FFFFFFF;\n    v28 = (unsigned int *)sub_80B2528();\n    v6 = v33;\n    v7 = (_DWORD *)(v33 >> 2);\n    v33 >>= 2;\n    if ( (v30 & 8) == 0 )\n    {\n      v7 = v28 + 1;\n      v5 = 0;\n      v8 = 0;\n      while ( v7 < (unsigned int *)((char *)v28 + (v6 & 0xFFFFFFFC)) )\n      {\n        v8 += (*v7 & 0xFFFF0000) != 0;\n        if ( (unsigned __int16)*v7 )\n          v5 = (unsigned int *)((char *)v5 + 1);\n        ++v7;\n      }\n      if ( v8 > (int)v5 )\n      {\n        sub_804D5F4(\"assuming reversed byte order, use -n to force native byte order\");\n        v5 = &v28[v33];\n        for ( i = v28; v5 > i; ++i )\n        {\n          v7 = (_DWORD *)_byteswap_ulong(*i);\n          *i = (unsigned int)v7;\n        }\n      }\n    }\n    v24 = *v28;\n    if ( (v30 & 0x80u) == 0 )\n    {\n      sub_80B3D45(v5, v7);\n      for ( j = 1; ; ++j )\n      {\n        if ( !fgets_unlocked() )\n          goto LABEL_20;\n        if ( sscanf(v40, \"%llx %s %s\", &v35, &v37, v38) != 3 )\nLABEL_26:\n          sub_804D5E0(\"%s(%i): wrong map line\", v31, j);\n        if ( !strcmp(v38, \"_stext\") )\n          break;\n      }\n      v29 = v35;\n      if ( !v35 )\nLABEL_20:\n        sub_804D5E0(\"can't find \\\"_stext\\\" in %s\", v31);\n      v26 = 0;\n      v27 = 1;\n      while ( fgets_unlocked() )\n      {\n        if ( sscanf(v40, \"%llx %s %s\", &v36, &v37, v39) != 3 )\n          goto LABEL_26;\n        if ( ((v37 - 63) & 0xFD) != 0 || v26 )\n        {\n          v10 = (v37 | 0x20) != 116 && (v37 | 0x20) != 119;\n          if ( v10 )\n            break;\n          if ( v27 >= v33 )\n            sub_804D5E0(\"profile address out of range. Wrong map file?\");\n          v21 = v24 * (v27 - 1);\n          v11 = 0;\n          while ( 1 )\n          {\n            v20 = v10;\n            v13 = v36;\n            v14 = sub_80B4B88((int)v36 - (int)v29, (unsigned __int64)(v36 - v29) >> 32, v24, 0);\n            v10 = v20;\n            if ( v27 >= v14 )\n              break;\n            v12 = v28[v27];\n            if ( (v30 & 0x20) != 0 && (v12 || (v30 & 0x10) != 0) )\n            {\n              if ( !v20 )\n                printf(\"%s:\\n\", v38);\n              printf(\"\\t%llx\\t%u\\n\", v29 + (unsigned int)v21, v12);\n              v10 = 1;\n            }\n            ++v27;\n            v11 += v12;\n            v21 += v24;\n          }\n          v26 += v11;\n          if ( (v30 & 0x20) != 0 )\n          {\n            if ( v11 | v30 & 0x200 )\n              printf(\"  total\\t\\t\\t\\t%u\\n\", v11);\n          }\n          else if ( (v11 || (v30 & 0x10) != 0) && v13 != (_DWORD)v35 )\n          {\n            v15 = (long double)v11 / (long double)(unsigned int)(v13 - v35);\n            if ( (v30 & 0x200) != 0 )\n              printf(\"%016llx %-40s %6u %8.4f\\n\", v35, v38, v11, (double)v15);\n            else\n              printf(\"%6u %-40s %8.4f\\n\", v11, v38, (double)v15);\n            if ( (v30 & 0x40) != 0 )\n            {\n              v22 = sub_80B4B88((int)v35 - (int)v29, (unsigned __int64)(v35 - v29) >> 32, v24, 0);\n              v16 = v22 + 1;\n              v17 = (v29 + (unsigned __int64)v24 * v22) >> 32;\n              for ( k = v29 + v24 * v22; ; k += v24 )\n              {\n                v23 = v16;\n                if ( sub_80B4B88((int)v36 - (int)v29, (unsigned __int64)(v36 - v29) >> 32, v24, 0) <= v16 )\n                  break;\n                printf(\"\\t%#llx\\t%s+%#llx\\t%u\\n\", __PAIR64__(v17, k), v38, __PAIR64__(v17, k) - v35, v28[(_DWORD)v23]);\n                v16 = v23 + 1;\n                v17 = (v24 + __PAIR64__(v17, k)) >> 32;\n              }\n            }\n          }\n          v35 = v36;\n          strcpy(v38, v39);\n          ++j;\n        }\n      }\n      printf(\"%6u *unknown*\\n\", v28[v33 - 1]);\n      if ( (v30 & 0x200) != 0 )\n        printf(\n          \"%016x %-40s %6u %8.4f\\n\",\n          0,\n          \"total\",\n          v26,\n          (double)((long double)v26 / (double)(unsigned __int64)(v35 - v29)));\n      else\n        printf(\"%6u %-40s %8.4f\\n\", v26, \"total\", (double)((long double)v26 / (double)(unsigned __int64)(v35 - v29)));\n    }\n    else\n    {\n      printf(\"Sampling_step: %u\\n\", v24);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8083613": [
        "0x8083613",
        "int __cdecl sub_8083613(int a1, int a2)\n{\n  _BYTE *v2; // eax\n  _BYTE *v3; // eax\n  int v4; // ebp\n  __priority_which_t v5; // edi\n  int v6; // esi\n  int v7; // ebx\n  char *v8; // eax\n  struct passwd *v9; // eax\n  int pw_uid; // edx\n  _DWORD *v11; // ebx\n  int v12; // eax\n  int v13; // eax\n  int *v15; // [esp+0h] [ebp-1Ch]\n  int v16; // [esp+4h] [ebp-18h]\n  id_t who; // [esp+8h] [ebp-14h]\n\n  v15 = (int *)(a2 + 4);\n  v2 = *(_BYTE **)(a2 + 4);\n  if ( !v2 )\n    goto LABEL_8;\n  if ( *v2 == 45 && v2[1] == 110 )\n  {\n    if ( v2[2] )\n    {\n      v3 = v2 + 2;\n    }\n    else\n    {\n      v15 = (int *)(a2 + 8);\n      v3 = *(_BYTE **)(a2 + 8);\n    }\n    if ( !v3 )\nLABEL_8:\n      sub_804CDC2();\n    v4 = 1;\n  }\n  else\n  {\n    v4 = 0;\n  }\n  v16 = sub_80B4160(0x3FFFFFFF, -1073741824);\n  v5 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    v7 = *++v15;\n    if ( !*v15 )\n      return v6;\n    if ( *(_BYTE *)v7 != 45 )\n      goto LABEL_18;\n    if ( !*(_BYTE *)(v7 + 1) )\n      goto LABEL_18;\n    v8 = strchr(\"pgu\", *(unsigned __int8 *)(v7 + 1));\n    if ( !v8 )\n      goto LABEL_18;\n    v5 = (unsigned __int8)v8[4];\n    if ( *(_BYTE *)(v7 + 2) )\n    {\n      v7 += 2;\nLABEL_18:\n      if ( v5 == 2 )\n      {\n        v9 = getpwnam((const char *)v7);\n        if ( !v9 )\n        {\n          sub_804D5F4(\"unknown user %s\", v7);\n          goto LABEL_32;\n        }\n        pw_uid = v9->pw_uid;\nLABEL_25:\n        if ( !v4 )\n        {\n          v13 = v16;\n          goto LABEL_30;\n        }\n        v11 = (_DWORD *)dword_80DBB7C;\n        *(_DWORD *)dword_80DBB7C = 0;\n        who = pw_uid;\n        v12 = getpriority(v5, pw_uid);\n        pw_uid = who;\n        if ( *v11 )\n        {\n          sub_804D3A5((int)\"%cetpriority\", 103);\n          v6 = v4;\n        }\n        else\n        {\n          v13 = v16 + v12;\nLABEL_30:\n          if ( setpriority(v5, pw_uid, v13) )\n          {\n            sub_804D3A5((int)\"%cetpriority\", 115);\n            goto LABEL_32;\n          }\n        }\n      }\n      else\n      {\n        pw_uid = sub_804ED6C(10, (const char *)v7, 0, v7);\n        if ( !*(_DWORD *)dword_80DBB7C )\n          goto LABEL_25;\n        sub_804D5F4(\"invalid number '%s'\", v7);\nLABEL_32:\n        v6 = 1;\n      }\n    }\n  }\n}\n"
    ],
    "sub_808376D": [
        "0x808376d",
        "void __cdecl __noreturn sub_808376D(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  char v4; // al\n  unsigned int v5; // esi\n  _DWORD *v6; // eax\n\n  v2 = a2;\n  if ( *ident == 115 )\n  {\n    v3 = *(_BYTE **)(a2 + 4);\n    if ( v3 )\n    {\n      if ( sub_804D210(v3, \"linux\") )\n      {\n        ident = *(char **)(a2 + 4);\n        v2 = a2 + 4;\n      }\n    }\n  }\n  v4 = ident[5];\n  if ( v4 == 54 )\n  {\n    v5 = 0;\n  }\n  else\n  {\n    if ( v4 != 51 )\n      sub_804CDC2();\n    v5 = 8;\n  }\n  if ( sub_80ABEAC(v2, &unk_80D478F) )\n    v5 |= 0x40000u;\n  if ( personality(v5) < 0 )\n    sub_804D3C9((int)\"personality(0x%lx)\", v5);\n  v6 = (_DWORD *)(v2 + 4 * optind);\n  if ( !*v6 )\n    *(v6 - 1) = 135104582;\n  sub_80AB1EC();\n}\n"
    ],
    "sub_8083804": [
        "0x8083804",
        "int __usercall sub_8083804@<eax>(const char *a1@<eax>)\n{\n  if ( *a1 != 43 && *a1 != 45 )\n    sub_804D5E0(\"invalid capability '%s'\", a1);\n  return sub_80A9AA8();\n}\n"
    ],
    "sub_8083821": [
        "0x8083821",
        "int __cdecl sub_8083821(int a1, int a2)\n{\n  int v2; // ebx\n  const char **v3; // esi\n  _DWORD *v4; // edi\n  int v5; // esi\n  int v6; // ebx\n  const char *v7; // eax\n  signed int v8; // ebx\n  const char *v9; // eax\n  unsigned int v10; // ebx\n  const char *v11; // esi\n  int v12; // eax\n  unsigned int v13; // ebx\n  const char *v14; // esi\n  int v15; // eax\n  char *v16; // ebp\n  char *i; // eax\n  const char *v18; // ebp\n  unsigned int v19; // ecx\n  int v20; // edx\n  int v21; // ecx\n  int v22; // eax\n  char *j; // eax\n  char *v24; // ebx\n  int v25; // eax\n  int v27; // [esp+0h] [ebp-5Ch]\n  char *s; // [esp+4h] [ebp-58h] BYREF\n  char *v29; // [esp+8h] [ebp-54h] BYREF\n  int v30; // [esp+Ch] [ebp-50h] BYREF\n  int v31; // [esp+10h] [ebp-4Ch] BYREF\n  char v32[4]; // [esp+14h] [ebp-48h] BYREF\n  int v33; // [esp+18h] [ebp-44h] BYREF\n  int v34; // [esp+1Ch] [ebp-40h] BYREF\n  char v35[4]; // [esp+20h] [ebp-3Ch] BYREF\n  int v36; // [esp+24h] [ebp-38h] BYREF\n  int v37[2]; // [esp+28h] [ebp-34h] BYREF\n  unsigned int v38; // [esp+30h] [ebp-2Ch]\n  int v39[8]; // [esp+3Ch] [ebp-20h]\n\n  v2 = sub_80ABEC2(a2, aD_10, \"dump\", &s, &v29);\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( (v2 & 1) == 0 )\n  {\n    if ( (v2 & 8) != 0 && prctl(38, 1, 0, 0, 0) )\n      sub_804D3C9((int)\"prctl: %s\", \"SET_NO_NEW_PRIVS\");\n    if ( (v2 & 2) != 0 )\n    {\n      v16 = s;\n      sub_80A9B19(v37);\n      for ( i = strtok(v16, \",\"); ; i = strtok(0, \",\") )\n      {\n        v18 = i;\n        if ( !i )\n          break;\n        v19 = sub_8083804(i);\n        if ( v19 >> 5 >= v38 )\n          sub_804D5E0(\"invalid capability '%s'\", v18);\n        v20 = 3 * (v19 >> 5);\n        v27 = v39[v20];\n        v21 = 1 << v19;\n        if ( *v18 == 43 )\n          v22 = v21 | v27;\n        else\n          v22 = ~v21 & v27;\n        v39[v20] = v22;\n      }\n      if ( capset() )\n        sub_804D3C9((int)\"capset\");\n    }\n    if ( (v2 & 4) != 0 )\n    {\n      for ( j = strtok(v29, \",\"); ; j = strtok(0, \",\") )\n      {\n        v24 = j;\n        if ( !j )\n          break;\n        v25 = sub_8083804(j);\n        if ( *v24 == 43 )\n        {\n          if ( prctl(47, 2, v25, 0, 0) < 0 )\n            sub_804D3A5((int)\"cap_ambient_raise\");\n        }\n        else if ( prctl(47, 3, v25, 0, 0) < 0 )\n        {\n          sub_804D3A5((int)\"cap_ambient_lower\");\n        }\n      }\n    }\n    if ( *v3 )\n      sub_80AB1EC(v3);\nLABEL_4:\n    sub_804CDC2();\n  }\n  if ( *v3 || v2 != 1 )\n    goto LABEL_4;\n  getresuid();\n  getresgid();\n  v36 = 0;\n  v4 = sub_80A991A(&v36, 0);\n  v5 = prctl(39, 0, 0, 0, 0, &v33, &v34, v35, &v30, &v31, v32);\n  if ( v5 < 0 )\n    sub_804D3C9((int)\"prctl: %s\", \"GET_NO_NEW_PRIVS\");\n  printf(\"uid: %u\\n\", v30);\n  printf(\"euid: %u\\n\", v31);\n  printf(\"gid: %u\\n\", v33);\n  printf(\"egid: %u\\n\", v34);\n  printf(\"Supplementary groups: \");\n  if ( v36 )\n  {\n    v6 = 0;\n    v7 = \"%u\";\n    while ( v6 < v36 )\n    {\n      printf(v7, v4[v6++]);\n      v7 = \"dev %u,%u\" + 6;\n    }\n  }\n  else\n  {\n    printf(\"[none]\");\n  }\n  printf(\"\\nno_new_privs: %d\\n\", v5);\n  sub_80A9B19(v37);\n  printf(\"Inheritable capabilities: \");\n  v8 = 0;\n  v9 = &data;\n  while ( v8 != 38 )\n  {\n    if ( v8 >> 5 >= v38 )\n    {\n      printf(\"\\nindex: %u u32s: %u capability: %u\\n\", v8 >> 5, v38, v8);\n      sub_804D5E0(\"unsupported capability\");\n    }\n    if ( ((1 << v8) & v39[3 * (v8 >> 5)]) != 0 )\n    {\n      sub_80A9AF5((int)v9, v8);\n      v9 = \"Linux User,,,\" + 12;\n    }\n    ++v8;\n  }\n  if ( !*v9 )\n    printf(\"[none]\");\n  printf(\"\\nAmbient capabilities: \");\n  v10 = 0;\n  v11 = &data;\n  while ( v10 != 38 )\n  {\n    v12 = prctl(47, 1, v10, 0, 0);\n    if ( v12 < 0 )\n      sub_804D3C9((int)\"prctl: %s\", \"CAP_AMBIENT_IS_SET\");\n    if ( v12 )\n    {\n      sub_80A9AF5((int)v11, v10);\n      v11 = \"Linux User,,,\" + 12;\n    }\n    ++v10;\n  }\n  if ( !*v11 )\n    printf(\"[none]\");\n  printf(\"\\nCapability bounding set: \");\n  v13 = 0;\n  v14 = &data;\n  while ( v13 != 38 )\n  {\n    v15 = prctl(23, v13, 0, 0, 0);\n    if ( v15 < 0 )\n      sub_804D3C9((int)\"prctl: %s\", \"CAPBSET_READ\");\n    if ( v15 )\n    {\n      sub_80A9AF5((int)v14, v13);\n      v14 = \"Linux User,,,\" + 12;\n    }\n    ++v13;\n  }\n  if ( !*v14 )\n    printf(\"[none]\");\n  sub_804DD98(10);\n  return 0;\n}\n"
    ],
    "sub_8083BCF": [
        "0x8083bcf",
        "int __cdecl sub_8083BCF(int a1, int a2)\n{\n  int v2; // esi\n\n  v2 = sub_80ABEAC(a2, &unk_80D4933);\n  if ( setsid() >= 0 )\n    goto LABEL_4;\n  if ( !sub_804E17C() )\n  {\n    setsid();\nLABEL_4:\n    if ( v2 )\n      ioctl(0, 0x540Eu, 1);\n    sub_80AB1EC();\n  }\n  return 0;\n}\n"
    ],
    "sub_8083C24": [
        "0x8083c24",
        "int __usercall sub_8083C24@<eax>(char *a1@<eax>)\n{\n  int v1; // eax\n  int v2; // ebx\n  int v3; // eax\n  char v4; // dl\n  char *path; // [esp+0h] [ebp-70h] BYREF\n  int v7; // [esp+14h] [ebp-5Ch]\n  __int64 v8; // [esp+30h] [ebp-40h]\n  __int64 v9; // [esp+3Ch] [ebp-34h]\n\n  path = a1;\n  sub_808487E(&path);\n  if ( ident[5] == 102 )\n  {\n    v1 = swapoff(path);\n    if ( (dword_80DBB9C & 1) != 0 && (*(_DWORD *)dword_80DBB7C == 2 || *(_DWORD *)dword_80DBB7C == 22) || !v1 )\n      return 0;\n    goto LABEL_20;\n  }\n  v2 = stat64();\n  if ( v2 )\n  {\n    v4 = 0;\n    goto LABEL_15;\n  }\n  if ( (v7 & 0xF000) != 0x8000 || v9 << 9 >= v8 )\n  {\n    v3 = swapon(path, 0);\n    if ( (dword_80DBB9C & 1) != 0 )\n      LOBYTE(v2) = *(_DWORD *)dword_80DBB7C == 16;\n    v4 = v2;\n    v2 = v3;\n    if ( !v3 )\n    {\n      v2 = 0;\nLABEL_18:\n      if ( v2 && (v4 & 1) == 0 )\n      {\nLABEL_20:\n        sub_804D3F1(path);\n        return 1;\n      }\n      return 0;\n    }\nLABEL_15:\n    if ( (dword_80DBB9C & 2) != 0 && *(_DWORD *)dword_80DBB7C == 2 )\n      return 0;\n    goto LABEL_18;\n  }\n  sub_804D5F4(\"%s: file has holes\", path);\n  return 1;\n}\n"
    ],
    "sub_8083D34": [
        "0x8083d34",
        "int __usercall sub_8083D34@<eax>(int a1@<ebx>, int a2, int a3)\n{\n  int v3; // edx\n  int v4; // ecx\n  char **v5; // edi\n  int v6; // ebx\n  char *v7; // eax\n  char *v8; // esi\n  int v9; // esi\n  struct mntent *v10; // eax\n  const struct mntent *v11; // ebp\n  int v12; // ebx\n  char *v13; // eax\n  FILE *v15; // [esp+0h] [ebp-14h]\n\n  sub_80ABEAC(a3, \"ae\", a1);\n  v5 = (char **)(a3 + 4 * optind);\n  if ( (dword_80DBB9C & 1) != 0 )\n  {\n    if ( ident[5] == 102 && sub_80B3D37() )\n    {\n      v6 = 0;\n      while ( 1 )\n      {\n        v7 = (char *)sub_80AB85A();\n        v8 = v7;\n        if ( !v7 )\n          break;\n        if ( *v7 == 47 )\n        {\n          *(_BYTE *)strchrnul() = 0;\n          v6 |= sub_8083C24(v8);\n        }\n        free(v8);\n      }\n    }\n    else\n    {\n      v6 = 0;\n    }\n    v15 = (FILE *)sub_80B3D45(v4, v3);\n    v9 = 0;\n    while ( 1 )\n    {\n      v10 = getmntent(v15);\n      v11 = v10;\n      if ( !v10 )\n        break;\n      if ( !strcmp(v10->mnt_type, \"swap\") && (ident[5] == 102 || !hasmntopt(v11, \"noauto\")) )\n        v9 |= sub_8083C24(v11->mnt_fsname);\n    }\n    v12 = v9 | v6;\n  }\n  else\n  {\n    if ( !*v5 )\n      sub_804CDC2();\n    v12 = 0;\n  }\n  dword_80DBB9C &= ~1u;\n  while ( 1 )\n  {\n    v13 = *v5;\n    if ( !*v5 )\n      break;\n    ++v5;\n    v12 |= sub_8083C24(v13);\n  }\n  return v12;\n}\n"
    ],
    "sub_8083E3D": [
        "0x8083e3d",
        "int __usercall sub_8083E3D@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  int v5; // ebx\n  int v6; // [esp+0h] [ebp-34h] BYREF\n  int v7; // [esp+4h] [ebp-30h] BYREF\n  char s[44]; // [esp+8h] [ebp-2Ch] BYREF\n\n  result = sub_804E632(0x1Fu, s);\n  if ( result >= 0 )\n  {\n    s[result] = 0;\n    if ( sscanf(s, \"%u %u\", &v6, &v7) != 2 )\n      sub_804D3C9((int)\"can't parse file '%s'\", a1);\n    if ( a2 > 31 )\n      v7 &= __ROL4__(-2, a2 - 32);\n    else\n      v6 &= __ROL4__(-2, a2);\n    v5 = sub_804DBE1(a1);\n    dprintf();\n    return close(v5);\n  }\n  return result;\n}\n"
    ],
    "sub_8083EDA": [
        "0x8083eda",
        "int __usercall sub_8083EDA@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int result; // eax\n  DIR *v7; // esi\n  _BYTE *v8; // eax\n  int v9; // ecx\n  void *v10; // ebp\n  int v11; // [esp-4h] [ebp-78h]\n  int v12; // [esp-4h] [ebp-78h]\n  int v13; // [esp+4h] [ebp-70h]\n  int v14; // [esp+8h] [ebp-6Ch]\n  __int16 v15; // [esp+14h] [ebp-60h]\n\n  result = lstat64();\n  if ( !result )\n  {\n    result = v13;\n    if ( v14 == a3 && v13 == a2 )\n    {\n      if ( (v15 & 0xF000) == 0x4000 )\n      {\n        v7 = opendir(a1);\n        result = v11;\n        if ( v7 )\n        {\n          while ( 1 )\n          {\n            v8 = (_BYTE *)readdir64();\n            if ( !v8 )\n              break;\n            if ( v8[19] == 46 )\n            {\n              LOBYTE(v9) = v8[20];\n              if ( !(_BYTE)v9 || (_BYTE)v9 == 46 && !v8[21] )\n                continue;\n            }\n            v10 = (void *)sub_804D2D1((int)a1, v8 + 19, v9);\n            ((void (__cdecl *)())sub_8083EDA)();\n            free(v10);\n          }\n          closedir(v7);\n          return rmdir(a1);\n        }\n      }\n      else\n      {\n        unlink(a1);\n        return v12;\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8083F8D": [
        "0x8083f8d",
        "int __cdecl sub_8083F8D(int a1, int a2)\n{\n  int v2; // ebx\n  char *i; // edi\n  int v4; // esi\n  int v5; // eax\n  const char **v6; // esi\n  int v7; // ebp\n  int v8; // eax\n  const char *v9; // eax\n  const char *v11; // [esp-4h] [ebp-D4h]\n  int v12; // [esp+0h] [ebp-D0h]\n  const char *v13; // [esp+8h] [ebp-C8h] BYREF\n  char *s; // [esp+Ch] [ebp-C4h] BYREF\n  int v15; // [esp+60h] [ebp-70h]\n  int v16; // [esp+64h] [ebp-6Ch]\n  int v17; // [esp+70h] [ebp-60h]\n  int v18[23]; // [esp+74h] [ebp-5Ch]\n\n  v13 = 0;\n  if ( *ident == 115 )\n  {\n    sub_80ABEAC(a2, \"^+c:\", &v13);\n    v2 = 0;\n  }\n  else\n  {\n    s = 0;\n    v2 = sub_80ABEAC(a2, \"^+c:d:n\", &v13, &s) >> 2;\n    if ( s )\n    {\n      for ( i = strtok(s, \",\"); ; i = strtok(0, \",\") )\n      {\n        if ( !i )\n          goto LABEL_15;\n        v4 = sub_80A9AA8();\n        sub_8083E3D(\"/proc/sys/kernel/usermodehelper/bset\", v4);\n        sub_8083E3D(\"/proc/sys/kernel/usermodehelper/inheritable\", v4);\n        v5 = prctl(23, v4, 0, 0, 0);\n        if ( v5 < 0 )\n          break;\n        if ( v5 == 1 && prctl(24, v4, 0, 0, 0) )\n        {\n          v11 = \"PR_CAPBSET_DROP\";\nLABEL_11:\n          sub_804D3C9((int)\"prctl: %s\", v11);\n        }\n        sub_80A9B19();\n        v18[3 * (v4 >> 5)] &= ~(1 << v4);\n        if ( capset() )\n          sub_804D3C9((int)\"capset\");\n        sub_804D5F4(\"dropped capability: %s\", i);\n      }\n      v11 = (const char *)&unk_80D49DD;\n      goto LABEL_11;\n    }\n  }\nLABEL_15:\n  v6 = (const char **)(a2 + 4 * optind);\n  sub_804DF04(*v6);\n  sub_804DFF3(\"/\");\n  v7 = v15;\n  v12 = v16;\n  sub_804DFF3(\".\");\n  if ( v16 == v12 && v15 == v7 || !v2 && getpid() != 1 )\n    sub_804CDC2();\n  if ( stat64() || (v17 & 0xF000) != 0x8000 )\n    sub_804D5E0(\"'%s' is not a regular file\", \"/init\");\n  statfs64();\n  if ( s != (char *)16914836 && s != (char *)-2054924042 )\n    sub_804D5E0(\"root filesystem is not ramfs/tmpfs\");\n  if ( !v2 )\n  {\n    sub_8083EDA(\"/\", v7, v12);\n    if ( mount(\".\", \"/\", 0, 0x2000u, 0) )\n      sub_804D3C9((int)&unk_80D4A58);\n  }\n  sub_804DF35(\".\");\n  if ( v13 )\n  {\n    v8 = sub_804DC14(v13);\n    if ( v8 >= 0 )\n    {\n      sub_804DC97(v8, 0);\n      sub_804DC7B(0, 1);\n      sub_804DC7B(0, 2);\n    }\n  }\n  v9 = v6[1];\n  if ( !v2 )\n  {\n    execv(v9, (char *const *)v6 + 1);\nLABEL_36:\n    sub_804D3C9((int)\"can't execute '%s'\", v6[1]);\n  }\n  if ( access(v9, 1) )\n    goto LABEL_36;\n  return 0;\n}\n"
    ],
    "sub_8084247": [
        "0x8084247",
        "void __cdecl __noreturn sub_8084247(int a1, int a2)\n{\n  int v2; // esi\n  char *v3; // eax\n  char *v4; // ebx\n  ssize_t v5; // eax\n  _BYTE *v6; // edx\n  const char *v7; // ebp\n  int v8; // edi\n  char *v9; // eax\n  int v10; // ecx\n  __int64 *v11; // edi\n  __int64 *i; // edx\n  char *v13; // edx\n  char *v14; // eax\n  const char *v15; // eax\n  __int64 *v16; // [esp+0h] [ebp-24h]\n  int v17; // [esp+4h] [ebp-20h]\n  struct siginfo::$0A533C95F56D7198FDCBF4ED772C5A43::$DDF278A5B88F81FEC3CBEE828E282CB3 addr[2]; // [esp+8h] [ebp-1Ch] BYREF\n\n  v17 = a2 + 4;\n  addr[0].si_pid = 16;\n  addr[0].si_uid = getpid();\n  addr[1].si_pid = 1;\n  v2 = sub_804DF99(15, 2, 16);\n  sub_804DFB3(0xCu, (struct sockaddr *)addr, v2);\n  sub_804D670();\n  sub_80B424A(0, 8);\n  sub_80B424A(0, 33);\n  while ( 1 )\n  {\n    v3 = (char *)mmap64();\n    v4 = v3;\n    if ( v3 == (char *)-1 )\n      break;\n    v5 = sub_804E5BC(0x3FFFu, v3, v2);\n    if ( v5 < 0 )\n      sub_804D3C9(135046626);\n    v16 = (__int64 *)&v4[v5];\n    v4[v5] = 0;\n    if ( !*(_DWORD *)(a2 + 4) )\n    {\n      v6 = *(_BYTE **)(_stdout + 16);\n      if ( (unsigned int)v6 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked();\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v6 + 1;\n        *v6 = 10;\n      }\n    }\n    v7 = v4;\n    v8 = 0;\n    while ( v7 < (const char *)v16 )\n    {\n      if ( !*(_DWORD *)(a2 + 4) )\n        puts(v7);\n      v9 = strchr(v7, 61);\n      v10 = 4 * v8;\n      if ( v8 <= 254 )\n      {\n        if ( v9 )\n        {\n          ++v8;\n          *(_DWORD *)((char *)&qword_80DB778 + v10) = v7;\n        }\n      }\n      v7 += strlen(v7) + 1;\n    }\n    *((_DWORD *)&qword_80DB778 + v8) = 0;\n    v11 = &qword_80DB778;\n    for ( i = &qword_80DB778; ; i = v16 )\n    {\n      v13 = (char *)i + 4;\n      v14 = (char *)*((_DWORD *)v13 - 1);\n      if ( !v14 )\n        break;\n      v16 = (__int64 *)v13;\n      putenv(v14);\n    }\n    if ( *(_DWORD *)(a2 + 4) )\n      sub_80B3C03(v16, v17, addr[0].si_pid, addr[0].si_uid, addr[1].si_pid, addr[1].si_uid);\n    while ( 1 )\n    {\n      v11 = (__int64 *)((char *)v11 + 4);\n      v15 = (const char *)*((_DWORD *)v11 - 1);\n      if ( !v15 )\n        break;\n      sub_804DDFA(v15);\n    }\n    munmap(v4, 0x4000u);\n  }\n  sub_804D3C9((int)\"mmap\");\n}\n"
    ],
    "sub_80843E2": [
        "0x80843e2",
        "int __cdecl sub_80843E2(int a1, int a2)\n{\n  FILE *v2; // eax\n  FILE *v3; // ebx\n  const char **v4; // edi\n  const char **v5; // esi\n  const char **i; // ebp\n  bool j; // zf\n  const char *v8; // ebx\n  char *v9; // esi\n  int v11; // [esp-8h] [ebp-48h]\n  int v12; // [esp-4h] [ebp-44h]\n  char v13; // [esp+0h] [ebp-40h]\n  const char **v14; // [esp+4h] [ebp-3Ch]\n  int v15; // [esp+8h] [ebp-38h]\n  int v16; // [esp+14h] [ebp-2Ch] BYREF\n  struct mntent result; // [esp+18h] [ebp-28h] BYREF\n\n  v16 = 0;\n  v13 = sub_80ABEAC(a2, \"fldnrat:cvi\", &v16);\n  v14 = (const char **)(a2 + 4 * optind);\n  v2 = setmntent(\"/proc/mounts\", \"r\");\n  if ( v2 )\n  {\n    v3 = v2;\n    v4 = 0;\n    while ( getmntent_r(v3, &result, (char *)&qword_80DB778, 1024) )\n    {\n      if ( sub_80B0232() )\n      {\n        v5 = (const char **)sub_804DB2E(0xCu);\n        v5[2] = (const char *)v4;\n        v5[1] = sub_804DB46(result.mnt_fsname);\n        *v5 = sub_804DB46(result.mnt_dir);\n        v4 = v5;\n      }\n    }\n    endmntent(v3);\n  }\n  else\n  {\n    if ( (v13 & 0x20) != 0 )\n      sub_804D5E0(\"can't open '%s'\", \"/proc/mounts\");\n    v4 = 0;\n  }\n  if ( (v13 & 0x20) != 0 )\n  {\n    i = v4;\n  }\n  else\n  {\n    i = 0;\n    if ( !*v14 )\n      sub_804CDC2();\n  }\n  v15 = 0;\n  while ( 1 )\n  {\n    v8 = *v14;\n    if ( i )\n    {\n      v9 = sub_804DB46(*i);\nLABEL_42:\n      v8 = *i;\n      goto LABEL_19;\n    }\n    if ( !v8 || (v13 & 0x20) != 0 )\n      return v15;\n    ++v14;\n    v9 = sub_804E29C(v8);\n    if ( v9 )\n    {\n      for ( i = v4; i; i = (const char **)i[2] )\n      {\n        if ( !strcmp(v9, *i) || !strcmp(v9, i[1]) )\n          goto LABEL_42;\n      }\n    }\nLABEL_19:\n    if ( umount2(v8, v13 & 3) )\n    {\n      if ( (v13 & 0x10) != 0 && *(_DWORD *)dword_80DBB7C == 16 && i )\n      {\n        if ( mount(i[1], v8, 0, 0x21u, 0) )\n        {\n          v15 = 1;\n          sub_804D5F4(\"can't remount %s read-only\", i[1]);\n        }\n        else\n        {\n          sub_804D5F4(\"%s busy - remounted read-only\", i[1]);\n        }\n        goto LABEL_39;\n      }\n      sub_804D3A5((int)\"can't unmount %s\", v8);\n      v15 = 1;\n    }\n    else if ( (v13 & 4) != 0 )\n    {\n      if ( i )\n      {\n        sub_80AFDF4(v11, v12);\n        goto LABEL_39;\n      }\n      goto LABEL_24;\n    }\n    for ( j = i == 0; !j; j = strcmp(v9, i[1]) == 0 )\n    {\nLABEL_39:\n      i = (const char **)i[2];\n      if ( !i || (v13 & 0x20) != 0 )\n        break;\n    }\nLABEL_24:\n    free(v9);\n  }\n}\n"
    ],
    "sub_8084630": [
        "0x8084630",
        "int __usercall sub_8084630@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n\n  v1 = dword_80DB720;\n  if ( !dword_80DB720 )\n  {\n    if ( a1 )\n      sub_80B2549(sub_80847AC, 1, 0, 0, 0);\n    return dword_80DB720;\n  }\n  return v1;\n}\n"
    ],
    "sub_8084661": [
        "0x8084661",
        "int __cdecl sub_8084661(int a1)\n{\n  int result; // eax\n  int i; // ebx\n  const char *v3; // eax\n\n  result = sub_8084630(a1);\n  for ( i = result; i; i = *(_DWORD *)i )\n  {\n    printf(\"%s:\", *(const char **)(i + 4));\n    v3 = *(const char **)(i + 8);\n    if ( *v3 )\n      printf(\" LABEL=\\\"%s\\\"\", v3);\n    if ( **(_BYTE **)(i + 12) )\n      printf(\" UUID=\\\"%s\\\"\", *(const char **)(i + 12));\n    result = sub_804DD98(10);\n  }\n  return result;\n}\n"
    ],
    "sub_80846BA": [
        "0x80846ba",
        "int __usercall sub_80846BA@<eax>(_BYTE *a1@<edi>, _BYTE *a2@<esi>, const char *a3)\n{\n  int v3; // eax\n  int v5; // ebp\n  int v6; // ebx\n  int v7; // ebp\n  char *v8; // ebx\n  _DWORD *v9; // ebp\n  _DWORD *v10; // eax\n  int v11; // [esp+0h] [ebp-18h] BYREF\n  int v12; // [esp+4h] [ebp-14h]\n\n  v3 = open64();\n  if ( v3 < 0 )\n    return 0;\n  v5 = v3;\n  v6 = sub_8084935();\n  if ( ioctl(v5, 0x80041272, &v11) )\n  {\n    v11 = 0;\n    v12 = 0;\n  }\n  v7 = sub_80848D5(v12, v11);\n  if ( !v7 && (*(_BYTE *)(v6 + 32) || *(_BYTE *)(v6 + 97)) )\n  {\n    a1 = sub_804DB5D((_BYTE *)(v6 + 32), 65);\n    a2 = sub_804DB5D((_BYTE *)(v6 + 97), 37);\n  }\n  else\n  {\n    v7 = 1;\n  }\n  sub_8084946();\n  if ( v7 )\n    return 0;\n  v8 = sub_804DB46(a3);\n  v9 = (_DWORD *)dword_80DB720;\n  if ( dword_80DB720 )\n  {\n    while ( *v9 )\n      v9 = (_DWORD *)*v9;\n    v10 = sub_804DB2E(0x10u);\n    *v9 = v10;\n  }\n  else\n  {\n    v10 = sub_804DB2E(0x10u);\n    dword_80DB720 = (int)v10;\n  }\n  v10[1] = v8;\n  v10[2] = a1;\n  v10[3] = a2;\n  return 1;\n}\n"
    ],
    "sub_80847AC": [
        "0x80847ac",
        "int __userpurge sub_80847AC@<eax>(const char *a1@<eax>, int a2@<edx>, _BYTE *a3@<edi>, int a4)\n{\n  int v6; // eax\n  char *v7; // eax\n\n  v6 = *(_DWORD *)(a2 + 16) & 0xF000;\n  if ( v6 == 24576 || v6 == 0x2000 && (v7 = sub_804D315(a1), !strncmp(v7, \"ubi\", 3u)) )\n  {\n    if ( gnu_dev_major(*(_QWORD *)(a2 + 32)) != 2 )\n      sub_80846BA(a3, (_BYTE *)a2, a1);\n  }\n  return 1;\n}\n"
    ],
    "sub_8084808": [
        "0x8084808",
        "char *__cdecl sub_8084808(char *s1)\n{\n  int i; // ebx\n\n  for ( i = sub_8084630(1); i; i = *(_DWORD *)i )\n  {\n    if ( **(_BYTE **)(i + 8) && !strcmp(s1, *(const char **)(i + 8)) )\n      return sub_804DB46(*(const char **)(i + 4));\n  }\n  return 0;\n}\n"
    ],
    "sub_8084846": [
        "0x8084846",
        "char *__cdecl sub_8084846(char *s1)\n{\n  int i; // ebx\n\n  for ( i = sub_8084630(1); i; i = *(_DWORD *)i )\n  {\n    if ( !strcasecmp(s1, *(const char **)(i + 12)) )\n      return sub_804DB46(*(const char **)(i + 4));\n  }\n  return 0;\n}\n"
    ],
    "sub_808487E": [
        "0x808487e",
        "int __cdecl sub_808487E(char **a1)\n{\n  char *v1; // esi\n  char *v2; // eax\n  int result; // eax\n\n  v1 = *a1;\n  if ( sub_804D210(*a1, \"UUID=\") )\n  {\n    v2 = sub_8084846(*a1 + 5);\n  }\n  else\n  {\n    if ( !sub_804D210(*a1, \"LABEL=\") )\n      goto LABEL_6;\n    v2 = sub_8084808(*a1 + 6);\n  }\n  v1 = v2;\nLABEL_6:\n  result = 0;\n  if ( *a1 != v1 )\n  {\n    result = 1;\n    if ( v1 )\n      *a1 = v1;\n  }\n  return result;\n}\n"
    ],
    "sub_80848D5": [
        "0x80848d5",
        "int __usercall sub_80848D5@<eax>(int a1@<eax>)\n{\n  int i; // esi\n\n  if ( sub_8084B80() && !*(_DWORD *)(a1 + 4) && sub_8084966() && !*(_DWORD *)(a1 + 4) )\n  {\n    sub_80851AF(a1, 0, 0, 69632);\n    for ( i = 0; i != 4; ++i )\n    {\n      if ( !funcs_808490F[i]() )\n        break;\n      if ( *(_DWORD *)(a1 + 4) )\n        break;\n    }\n  }\n  sub_808516C(a1);\n  return -*(_DWORD *)(a1 + 4);\n}\n"
    ],
    "sub_8084935": [
        "0x8084935",
        "_DWORD *__usercall sub_8084935@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x88u);\n  *result = a1;\n  return result;\n}\n"
    ],
    "sub_8084946": [
        "0x8084946",
        "void __usercall sub_8084946(int *a1@<eax>)\n{\n  if ( a1 )\n  {\n    close(*a1);\n    sub_808516C(a1);\n    free(a1);\n  }\n}\n"
    ],
    "sub_8084966": [
        "0x8084966",
        "int __usercall sub_8084966@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v3; // ebx\n  unsigned int v4; // edi\n  int v5; // esi\n  int v6; // ebx\n  _BYTE *v7; // eax\n  int v9; // [esp+0h] [ebp-20h]\n  unsigned __int64 v10; // [esp+4h] [ebp-1Ch]\n  _BYTE *v11; // [esp+Ch] [ebp-14h]\n\n  v2 = sub_80851AF(a1, 0, 0, 111);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  v9 = memcmp((const void *)(v2 + 3), \"EXFAT   \", 8u);\n  if ( v9 )\n    return -1;\n  v4 = ((unsigned int)((*(_DWORD *)(v3 + 96) - 2) * (1 << *(_BYTE *)(v3 + 108) << *(_BYTE *)(v3 + 109)))\n      + (unsigned __int64)(unsigned int)(*(_DWORD *)(v3 + 88) << *(_BYTE *)(v3 + 108))) >> 32;\n  v5 = (*(_DWORD *)(v3 + 96) - 2) * (1 << *(_BYTE *)(v3 + 108) << *(_BYTE *)(v3 + 109))\n     + (*(_DWORD *)(v3 + 88) << *(_BYTE *)(v3 + 108));\n  sub_808504A(a1, v3 + 100, 0);\n  v10 = __PAIR64__(v4, v5) + 3200;\n  v6 = 3;\n  do\n  {\n    v7 = (_BYTE *)sub_80851AF(a1, v5, v4, 32);\n    if ( !v7 || !*v7 )\n      break;\n    if ( *v7 == 0x83 )\n    {\n      v11 = v7;\n      sub_808502B(a1, v7 + 2, 0, 2 * (unsigned __int8)v7[1]);\n      v6 &= ~1u;\n      v7 = v11;\n    }\n    if ( *v7 == 0xA0 )\n    {\n      sub_808504A(a1, v7 + 6, 2);\n      v6 &= ~2u;\n    }\n    if ( !v6 )\n      break;\n    v4 = (__PAIR64__(v4, v5) + 32) >> 32;\n    v5 += 32;\n  }\n  while ( v10 != __PAIR64__(v4, v5) );\n  return v9;\n}\n"
    ],
    "sub_8084A79": [
        "0x8084a79",
        "int __usercall sub_8084A79@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v3; // ebx\n  int result; // eax\n\n  v2 = sub_80851AF(a1, 1024, 0, 512);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  result = -1;\n  if ( *(_WORD *)(v3 + 56) == 0xEF53 )\n  {\n    sub_8084FE4(a1, v3 + 120, 16);\n    sub_808504A(a1, v3 + 104, 2);\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8084AC8": [
        "0x8084ac8",
        "int __usercall sub_8084AC8@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v3; // ebx\n  int result; // eax\n\n  v2 = sub_80851AF(a1, 1024, 0, 1148);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  result = -1;\n  if ( *(_DWORD *)v3 == -218816496 )\n  {\n    if ( *(_WORD *)(v3 + 4) != 1 || (result = 0, *(_WORD *)(v3 + 6)) )\n    {\n      sub_808502B(a1, v3 + 124, 0, 64);\n      sub_808504A(a1, v3 + 108, 2);\n      return 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8084B29": [
        "0x8084b29",
        "int __usercall sub_8084B29@<eax>(int result@<eax>, int a2@<edx>)\n{\n  while ( 1 )\n  {\n    if ( --a2 == -1 || !*(_BYTE *)result )\n      return 0;\n    if ( *(_BYTE *)result != 0xE5 )\n      break;\n    result += 32;\n  }\nLABEL_6:\n  if ( (*(_BYTE *)(result + 11) & 0x3F) == 15\n    || (*(_BYTE *)(result + 11) & 0x18) != 8\n    || *(_WORD *)(result + 20)\n    || *(_WORD *)(result + 26) )\n  {\n    while ( 1 )\n    {\n      result += 32;\n      if ( --a2 == -1 || !*(_BYTE *)result )\n        return 0;\n      if ( *(_BYTE *)result != 0xE5 )\n        goto LABEL_6;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8084B80": [
        "0x8084b80",
        "int __usercall sub_8084B80@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v4; // ebx\n  int v6; // eax\n  unsigned __int8 v7; // al\n  unsigned int v8; // ecx\n  int v9; // eax\n  int v10; // edi\n  int v11; // ebp\n  unsigned int v12; // ebp\n  int v13; // eax\n  const void *v14; // edi\n  int v15; // ebx\n  int v16; // edi\n  __int64 v17; // rax\n  int v18; // eax\n  const void *v19; // ebp\n  _DWORD *v20; // eax\n  int v21; // ebx\n  unsigned int v22; // [esp+0h] [ebp-2Ch]\n  unsigned int v23; // [esp+4h] [ebp-28h]\n  int v24; // [esp+8h] [ebp-24h]\n  int v25; // [esp+8h] [ebp-24h]\n  int v26; // [esp+10h] [ebp-1Ch]\n  __int64 v27; // [esp+14h] [ebp-18h]\n\n  v2 = sub_80851AF(a1, 0, 0, 512);\n  if ( !v2 )\n    return -1;\n  v4 = v2;\n  if ( !memcmp((const void *)(v2 + 3), \"NTFS\", 4u) )\n    return -1;\n  if ( memcmp((const void *)(v4 + 82), \"MSWIN\", 5u)\n    && memcmp((const void *)(v4 + 82), \"FAT32   \", 8u)\n    && memcmp((const void *)(v4 + 54), \"FAT16   \", 8u)\n    && memcmp((const void *)(v4 + 54), \"MSDOS\", 5u)\n    && memcmp((const void *)(v4 + 54), \"FAT12   \", 8u) )\n  {\n    if ( !(*(_BYTE *)v4 == 0xEB ? *(_BYTE *)(v4 + 2) == 0x90 : *(_BYTE *)v4 == 0xE9) )\n      return -1;\n    if ( !*(_WORD *)(v4 + 26) )\n      return -1;\n    v6 = *(unsigned __int8 *)(v4 + 13);\n    if ( !(_BYTE)v6 )\n      return -1;\n    if ( (v6 & (v6 - 1)) != 0 )\n      return -1;\n    v7 = *(_BYTE *)(v4 + 21);\n    if ( v7 != 0xF0 && v7 <= 0xF7u )\n      return -1;\n    if ( *(_BYTE *)(v4 + 16) != 2 )\n      return -1;\n  }\n  v8 = *(unsigned __int16 *)(v4 + 11);\n  if ( (((_WORD)v8 - 2048) & 0xF7FF) != 0 && (((_WORD)v8 - 512) & 0xFDFF) != 0 )\n    return -1;\n  v10 = *(unsigned __int16 *)(v4 + 19);\n  if ( !*(_WORD *)(v4 + 19) )\n    v10 = *(_DWORD *)(v4 + 32);\n  v11 = *(unsigned __int16 *)(v4 + 22);\n  if ( !*(_WORD *)(v4 + 22) )\n    v11 = *(_DWORD *)(v4 + 36);\n  v24 = *(unsigned __int16 *)(v4 + 17);\n  v9 = *(unsigned __int16 *)(v4 + 14);\n  v12 = v9 + *(unsigned __int8 *)(v4 + 16) * v11;\n  if ( (v10 - (32 * v24 + v8 - 1) / v8 - v12) / *(unsigned __int8 *)(v4 + 13) > 0xFFF3 )\n  {\n    v22 = v8 * *(unsigned __int8 *)(v4 + 13);\n    v16 = *(_DWORD *)(v4 + 44);\n    v26 = v8 * v9;\n    v25 = 100;\n    v27 = v12;\n    v23 = *(unsigned __int16 *)(v4 + 11);\n    do\n    {\n      if ( !--v25 )\n        break;\n      v17 = v27 + *(unsigned __int8 *)(v4 + 13) * (unsigned __int64)(unsigned int)(v16 - 2);\n      v18 = sub_80851AF(a1, v23 * v17, HIDWORD(v17) * v23 + ((v23 * (unsigned __int64)(unsigned int)v17) >> 32), v22);\n      if ( !v18 )\n        return 0;\n      v19 = (const void *)sub_8084B29(v18, v22 >> 5);\n      if ( v19 )\n        goto LABEL_40;\n      v20 = (_DWORD *)sub_80851AF(a1, v26 + 4 * v16, 0, v22);\n      if ( !v20 )\n        return 0;\n      v16 = *v20 & 0xFFFFFFF;\n    }\n    while ( (unsigned int)(v16 - 2) <= 0xFFFFFF4 );\n    v19 = 0;\nLABEL_40:\n    v21 = sub_80851AF(a1, 0, 0, 512);\n    if ( v21 )\n    {\n      if ( !v19 || !memcmp(v19, \"NO NAME    \", 0xBu) )\n      {\n        if ( memcmp((const void *)(v21 + 71), \"NO NAME    \", 0xBu) )\n          sub_8084FE4(a1, v21 + 71, 11);\n      }\n      else\n      {\n        sub_8084FE4(a1, v19, 11);\n      }\n      sub_808504A(a1, v21 + 67, 0);\n      return 0;\n    }\n    return -1;\n  }\n  v13 = sub_80851AF(a1, v12 * v8, 0, 32 * v24);\n  if ( v13 )\n  {\n    v14 = (const void *)sub_8084B29(v13, v24);\n    v15 = sub_80851AF(a1, 0, 0, 512);\n    if ( v15 )\n    {\n      if ( v14 && memcmp(v14, \"NO NAME    \", 0xBu)\n        || (v14 = (const void *)(v15 + 43), memcmp((const void *)(v15 + 43), \"NO NAME    \", 0xBu)) )\n      {\n        sub_8084FE4(a1, v14, 11);\n      }\n      sub_808504A(a1, v15 + 39, 0);\n      return 0;\n    }\n    return -1;\n  }\n  return 0;\n}\n"
    ],
    "sub_8084EA3": [
        "0x8084ea3",
        "int __usercall sub_8084EA3@<eax>(int a1@<eax>)\n{\n  int v1; // eax\n  __int16 v2; // dx\n\n  v1 = sub_80851AF(a1, 1024, 0, 512);\n  if ( !v1 )\n    return -1;\n  v2 = *(_WORD *)(v1 + 16);\n  if ( ((v2 - 4991) & 0xFFEF) == 0 || (v2 & 0xFFEF) == 9320 )\n    return 0;\n  else\n    return -(*(_WORD *)(v1 + 24) != 19802);\n}\n"
    ],
    "sub_8084EED": [
        "0x8084eed",
        "int __usercall sub_8084EED@<eax>(int a1@<eax>)\n{\n  _DWORD *v2; // eax\n  _DWORD *v3; // edx\n  int result; // eax\n\n  v2 = (_DWORD *)sub_80851AF(a1, 0, 0, 128);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  result = -1;\n  if ( *v3 == 101718065 )\n  {\n    sub_808504A(a1, v3 + 27, 2);\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8084F2B": [
        "0x8084f2b",
        "unsigned int __cdecl sub_8084F2B(int a1, unsigned int a2, int a3, int a4, unsigned int a5)\n{\n  int v5; // edx\n  int v6; // edi\n  int v7; // esi\n  unsigned int v8; // eax\n  char v9; // di\n  unsigned int v11; // [esp+0h] [ebp-14h]\n\n  v5 = 0;\n  v11 = 0;\n  while ( 1 )\n  {\n    v11 += 2;\n    if ( v11 > a5 )\n      break;\n    v6 = *(unsigned __int8 *)(a3 + v11 - 2);\n    v7 = *(unsigned __int8 *)(a3 + v11 - 1);\n    v8 = a4 ? v7 | (v6 << 8) : v6 | (v7 << 8);\n    if ( !v8 || v5 + 1 >= a2 )\n      break;\n    if ( v8 > 0x7F )\n    {\n      if ( v5 + 2 >= a2 )\n        break;\n      if ( v8 <= 0x7FF )\n      {\n        v9 = -64;\n      }\n      else\n      {\n        if ( v5 + 3 >= a2 )\n          break;\n        *(_BYTE *)(a1 + v5++) = (v8 >> 12) | 0xE0;\n        v9 = 0x80;\n      }\n      *(_BYTE *)(a1 + v5) = v9 | (v8 >> 6) & 0x3F;\n      LOBYTE(v8) = v8 & 0x3F | 0x80;\n      ++v5;\n    }\n    *(_BYTE *)(a1 + v5++) = v8;\n  }\n  *(_BYTE *)(a1 + v5) = 0;\n  return v11;\n}\n"
    ],
    "sub_8084FE4": [
        "0x8084fe4",
        "int __cdecl sub_8084FE4(int a1, const void *a2, unsigned int a3)\n{\n  int result; // eax\n\n  qmemcpy((void *)(a1 + 32), a2, a3);\n  for ( result = strnlen();\n        result && ((unsigned __int8)(*(_BYTE *)(a1 + result + 31) - 9) <= 4u || *(_BYTE *)(a1 + result + 31) == 32);\n        --result )\n  {\n    ;\n  }\n  *(_BYTE *)(a1 + result + 32) = 0;\n  return result;\n}\n"
    ],
    "sub_808502B": [
        "0x808502b",
        "unsigned int __cdecl sub_808502B(int a1, int a2, int a3, unsigned int a4)\n{\n  return sub_8084F2B(a1 + 32, 0x41u, a2, a3, a4);\n}\n"
    ],
    "sub_808504A": [
        "0x808504a",
        "int __cdecl sub_808504A(int a1, unsigned __int8 *a2, int a3)\n{\n  int result; // eax\n  unsigned int v4; // edx\n  int i; // ebx\n\n  result = a1;\n  v4 = 36;\n  if ( a3 != 3 )\n    v4 = 4 << a3;\n  for ( i = 0; i != v4; ++i )\n  {\n    if ( a2[i] )\n    {\n      switch ( a3 )\n      {\n        case 1:\n          return sprintf(\n                   (char *)(a1 + 97),\n                   \"%02X%02X%02X%02X%02X%02X%02X%02X\",\n                   a2[7],\n                   a2[6],\n                   a2[5],\n                   a2[4],\n                   a2[3],\n                   a2[2],\n                   a2[1],\n                   *a2);\n        case 0:\n          return sprintf((char *)(a1 + 97), \"%02X%02X-%02X%02X\", a2[3], a2[2], a2[1], *a2);\n        case 2:\n          return sprintf(\n                   (char *)(a1 + 97),\n                   \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n                   *a2,\n                   a2[1],\n                   a2[2],\n                   a2[3],\n                   a2[4],\n                   a2[5],\n                   a2[6],\n                   a2[7],\n                   a2[8],\n                   a2[9],\n                   a2[10],\n                   a2[11],\n                   a2[12],\n                   a2[13],\n                   a2[14],\n                   a2[15]);\n        case 3:\n          qmemcpy((void *)(a1 + 97), a2, v4);\n          *(_BYTE *)(a1 + v4 + 97) = 0;\n          break;\n      }\n      return result;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_808516C": [
        "0x808516c",
        "__int64 __cdecl sub_808516C(int a1)\n{\n  __int64 v2; // [esp-8h] [ebp-Ch]\n\n  free(*(void **)(a1 + 16));\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_DWORD *)(a1 + 8) = 0;\n  free(*(void **)(a1 + 20));\n  *(_DWORD *)(a1 + 20) = 0;\n  *(_DWORD *)(a1 + 12) = 0;\n  *(_DWORD *)(a1 + 24) = 0;\n  *(_DWORD *)(a1 + 28) = 0;\n  return v2;\n}\n"
    ],
    "sub_80851AF": [
        "0x80851af",
        "char *__cdecl sub_80851AF(_DWORD *a1, unsigned __int64 a2, size_t a3)\n{\n  size_t v3; // edi\n  int v4; // ebp\n  char *v5; // esi\n  char *result; // eax\n  __int64 v7; // rax\n  unsigned __int64 v8; // [esp+0h] [ebp-20h]\n  __int64 v9; // [esp+8h] [ebp-18h]\n\n  v3 = a3;\n  v8 = a2 + a3;\n  if ( v8 > 0x11000 )\n  {\n    result = 0;\n    if ( a3 > 0x10000 )\n      return result;\n    v5 = (char *)a1[5];\n    LODWORD(v9) = a1[6];\n    if ( *((_QWORD *)a1 + 3) <= a2 )\n    {\n      HIDWORD(v9) = a1[7];\n      if ( v8 <= v9 + (unsigned __int64)(unsigned int)a1[3] )\n      {\n        v4 = a2 - v9;\n        return &v5[v4];\n      }\n    }\n    *((_QWORD *)a1 + 3) = a2;\n    a1[3] = a3;\n    v5 = (char *)sub_804DB13(v5, a3);\n    a1[5] = v5;\n    v4 = 0;\n  }\n  else\n  {\n    if ( !a1[4] )\n      a1[4] = sub_804DAFA(0x11000u);\n    v4 = a2;\n    v5 = (char *)a1[4];\n    v3 = a2 + a3;\n    if ( a1[2] >= (unsigned int)a2 + a3 )\n      return &v5[v4];\n    a1[2] = v3;\n    a2 = 0LL;\n  }\n  LODWORD(v7) = lseek64();\n  if ( v7 == a2 && sub_804E5E3(*a1, v5, v3) == v3 )\n    return &v5[v4];\n  if ( a2 <= 0xFFFF )\n    a1[1] = 1;\n  sub_808516C((int)a1);\n  return 0;\n}\n"
    ],
    "sub_80852F6": [
        "0x80852f6",
        "int __usercall sub_80852F6@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  char *v3; // eax\n\n  v2 = sub_80B028A();\n  v3 = ctime((const time_t *)(a1 + 28));\n  v3[16] = 32;\n  *(_DWORD *)(v3 + 17) = *((_DWORD *)v3 + 5);\n  v3[21] = 0;\n  return printf(\n           \"%s %u/%u%7llu %s %s\\n\",\n           (const char *)(v2 + 1),\n           *(_DWORD *)(a1 + 16),\n           *(_DWORD *)(a1 + 20),\n           *(_QWORD *)(a1 + 8),\n           v3 + 4,\n           *(const char **)a1);\n}\n"
    ],
    "sub_808533F": [
        "0x808533f",
        "int __usercall sub_808533F@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int result; // eax\n\n  v2 = *(_DWORD *)(a1 + 24);\n  if ( (*(_BYTE *)(a1 + 44) & 1) != 0 )\n  {\n    sub_804DCAD(1, 135081797);\n    ++*(_QWORD *)(a1 + 44);\n  }\n  if ( *(__int64 *)(v2 + 8) >= 0xFFFFFFFFLL )\n    sub_804D5E0(\"'%s' is bigger than ar can handle\", *(_DWORD *)v2);\n  result = dprintf();\n  *(_QWORD *)(a1 + 44) += 60LL;\n  return result;\n}\n"
    ],
    "sub_80853E0": [
        "0x80853e0",
        "__int64 __usercall sub_80853E0@<edx:eax>(int *a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // esi\n  __int64 result; // rax\n\n  v2 = a1[26];\n  v3 = a1[6];\n  *(_DWORD *)(v2 + 24) = v3;\n  sub_808533F(v2);\n  sub_804E51A(a1[1], *(_DWORD *)(v2 + 4), *(_QWORD *)(v3 + 8));\n  result = *(_QWORD *)(v3 + 8);\n  *(_QWORD *)(v2 + 44) += result;\n  return result;\n}\n"
    ],
    "sub_8085416": [
        "0x8085416",
        "bool __usercall sub_8085416@<al>(int a1@<eax>)\n{\n  return sub_808D85A(*(int ***)(a1 + 12), **(const char ***)(a1 + 24)) != 0;\n}\n"
    ],
    "sub_8085429": [
        "0x8085429",
        "int __cdecl sub_8085429(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  unsigned int v4; // eax\n  int v5; // edi\n  int v6; // esi\n  int *v7; // ebp\n  int v8; // ecx\n  int v9; // edx\n  int v10; // esi\n  const char *v11; // eax\n  const char *v12; // ebx\n  _DWORD *v13; // ecx\n  int v14; // edx\n  char *v15; // eax\n  int v16; // ebx\n  _DWORD v18[5]; // [esp+0h] [ebp-E4h] BYREF\n  __int64 v19; // [esp+40h] [ebp-A4h]\n  int v20; // [esp+84h] [ebp-60h]\n  int v21; // [esp+8Ch] [ebp-58h]\n  int v22; // [esp+90h] [ebp-54h]\n  __int64 v23; // [esp+A0h] [ebp-44h]\n  int v24; // [esp+BCh] [ebp-28h]\n\n  v2 = sub_808E331();\n  v3 = *(_BYTE **)(a2 + 4);\n  if ( v3 && *v3 && *v3 != 45 )\n    *(_DWORD *)(a2 + 4) = sub_804DDBF((char *)\"-%s\", *(const char **)(a2 + 4));\n  v4 = sub_80ABEAC(a2, \"^vocptxr\");\n  v5 = a2 + 4 * optind;\n  if ( ((v4 >> 3) & ((v4 >> 3) - 1)) != 0 )\n    sub_804CDC2();\n  if ( (v4 & 8) != 0 )\n    *(_DWORD *)(v2 + 36) = sub_8089994;\n  if ( (v4 & 0x10) != 0 )\n    *(_DWORD *)(v2 + 32) = sub_808E264;\n  if ( (v4 & 0x20) != 0 )\n    *(_DWORD *)(v2 + 36) = sub_8089512;\n  if ( (v4 & 2) != 0 )\n    *(_DWORD *)v2 |= 1u;\n  if ( (v4 & 1) != 0 )\n    *(_DWORD *)(v2 + 32) = sub_80852F6;\n  *(_DWORD *)(v2 + 100) = *(_DWORD *)v5;\n  v6 = v4 & 0x40;\n  v7 = (int *)(v5 + 4);\n  *(_DWORD *)(v2 + 4) = sub_804DBE1(*(const char **)v5);\n  if ( *(_DWORD *)(v5 + 4) )\n    *(_DWORD *)(v2 + 8) = sub_808D814;\n  while ( 1 )\n  {\n    v9 = *v7;\n    if ( !*v7 )\n      break;\n    ++v7;\n    sub_80AFADF(v8, v9);\n  }\n  if ( v6 )\n  {\n    sub_804E010(*(const char **)(v2 + 100));\n    v10 = v2;\n    if ( v19 )\n    {\n      v10 = sub_808E331();\n      sub_804DC28(*(const char **)(v2 + 100));\n      *(_DWORD *)(v10 + 4) = sub_804DBE1(*(const char **)(v2 + 100));\n      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v2 + 12);\n    }\n    *(_DWORD *)(v2 + 104) = v10;\n    sub_804DCAD(8, (int)\"!<arch>\\n\");\n    *(_QWORD *)(v10 + 44) += 8LL;\n    if ( v19 )\n    {\n      *(_DWORD *)(v2 + 8) = sub_8085416;\n      *(_DWORD *)(v2 + 36) = sub_80853E0;\n      sub_808EF94();\n    }\n    while ( 1 )\n    {\n      v11 = (const char *)sub_80AFB01(v18[0]);\n      v12 = v11;\n      if ( !v11 )\n        break;\n      sub_804DFF3(v11);\n      v13 = *(_DWORD **)(v10 + 24);\n      v13[7] = v24;\n      v13[4] = v21;\n      v13[5] = v22;\n      v13[6] = v20;\n      v14 = HIDWORD(v23);\n      v13[2] = v23;\n      v13[3] = v14;\n      *v13 = (char *)v18 + 3;\n      v15 = sub_804D315(v12);\n      sprintf((char *)v18 + 3, \"%.15s/\", v15);\n      sub_808533F(v10);\n      v16 = sub_804DBE1(v12);\n      sub_804E51A(v16, *(_DWORD *)(v10 + 4), v23);\n      close(v16);\n      *(_QWORD *)(v10 + 44) += v23;\n    }\n  }\n  else\n  {\n    sub_808EF94();\n  }\n  return 0;\n}\n"
    ],
    "sub_8085654": [
        "0x8085654",
        "const char *__usercall sub_8085654@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  char *v4; // eax\n  char *v5; // ebx\n\n  v4 = strrchr(a1, 46);\n  v5 = v4;\n  if ( v4 )\n  {\n    if ( !strcmp(v4 + 1, a2) )\n    {\n      *v5 = 0;\n      return a1;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v5;\n}\n"
    ],
    "sub_808568A": [
        "0x808568a",
        "char *__usercall sub_808568A@<eax>(const char *a1@<eax>)\n{\n  char *v2; // eax\n  char *v3; // ebx\n  const char *v4; // edi\n\n  v2 = strrchr(a1, 46);\n  v3 = v2;\n  if ( v2 )\n  {\n    v4 = v2 + 1;\n    if ( !strcmp(v2 + 1, \"gz\") )\n    {\n      *v3 = 0;\n      return (char *)a1;\n    }\n    else\n    {\n      v3 = 0;\n      if ( !strcmp(v4, \"tgz\") )\n      {\n        v3 = sub_804DB46(a1);\n        *((_WORD *)strrchr(v3, 46) + 1) = 29281;\n      }\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_80856EC": [
        "0x80856ec",
        "char *__usercall sub_80856EC@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  return sub_804DDBF(\"%s.%s\", a1, a2);\n}\n"
    ],
    "sub_80856FC": [
        "0x80856fc",
        "int __userpurge sub_80856FC@<eax>(int *a1@<eax>, __int64 (*a2)(void)@<edx>, int (*a3)(void)@<ecx>, int a4)\n{\n  char v5; // di\n  int v6; // esi\n  int v7; // eax\n  int v8; // eax\n  const char *v9; // eax\n  char *v10; // ebx\n  int v11; // eax\n  size_t v12; // eax\n  int v13; // eax\n  const char *v14; // eax\n  __int64 v16; // [esp+0h] [ebp-C8h]\n  size_t v17; // [esp+8h] [ebp-C0h]\n  struct timeval tvp; // [esp+14h] [ebp-B4h] BYREF\n  __time_t v21; // [esp+1Ch] [ebp-ACh]\n  int v22; // [esp+20h] [ebp-A8h]\n  int v23; // [esp+30h] [ebp-98h]\n  __time_t v24; // [esp+54h] [ebp-74h]\n  __int64 v25; // [esp+84h] [ebp-44h]\n\n  v5 = 0;\n  do\n  {\n    v6 = *a1;\n    if ( *a1 )\n    {\n      if ( *(_BYTE *)v6 == 45 && !*(_BYTE *)(v6 + 1) )\n      {\n        v6 = 0;\n      }\n      else\n      {\n        if ( stat64() )\n        {\n          sub_804D3F1((const char *)v6);\nLABEL_49:\n          v5 = 1;\n          v10 = 0;\nLABEL_50:\n          free(v10);\n          goto LABEL_51;\n        }\n        v7 = sub_804DBEB((const char *)v6);\n        if ( v7 < 0 )\n          goto LABEL_49;\n        sub_804DC97(v7, 0);\n      }\n    }\n    if ( (dword_80DBB9C & 0x41) != 0 )\n    {\n      if ( (dword_80DBB9C & 0x40) != 0 )\n      {\n        v8 = sub_804DBEB(\"/dev/null\");\n        if ( v8 < 0 )\n          sub_804D604();\n        sub_804DC97(v8, 1);\n      }\n      v6 = 0;\nLABEL_23:\n      v10 = 0;\n      goto LABEL_24;\n    }\n    if ( !v6 )\n      goto LABEL_23;\n    v9 = (const char *)a3();\n    v10 = (char *)v9;\n    if ( !v9 )\n    {\n      sub_804D5F4(\"%s: unknown suffix - ignored\", (const char *)v6);\n      v5 = 1;\n      goto LABEL_50;\n    }\n    if ( (dword_80DBB9C & 2) != 0 )\n      unlink(v9);\n    v11 = sub_804DBEB(v10);\n    if ( v11 < 0 )\n    {\n      v5 = 1;\n      goto LABEL_47;\n    }\n    sub_804DC97(v11, 1);\nLABEL_24:\n    if ( (dword_80DBB9C & 2) == 0 && isatty(0) )\n      sub_804D5E0(\"compressed data not read from terminal, use -f to force it\");\n    sub_808EE43();\n    v23 = 1;\n    v16 = a2();\n    if ( v16 < 0 )\n      v5 = 1;\n    if ( (dword_80DBB9C & 1) == 0 )\n      sub_804DCF3(1);\n    if ( !v6 )\n      goto LABEL_51;\n    if ( v16 < 0 )\n    {\n      if ( !v10 )\n        goto LABEL_50;\n      v14 = v10;\nLABEL_45:\n      sub_804DC28(v14);\n      goto LABEL_47;\n    }\n    if ( v24 )\n    {\n      tvp.tv_sec = v24;\n      v21 = v24;\n      tvp.tv_usec = 0;\n      v22 = 0;\n      utimes(v10, &tvp);\n    }\n    v12 = strlen(v10);\n    v17 = v12;\n    if ( v10 == (char *)v6 )\n      v10[v12] = 46;\n    if ( (dword_80DBB9C & 8) != 0 )\n    {\n      v13 = 0;\n      if ( v16 )\n        v13 = sub_80B4B88(100 * (int)v25, (unsigned __int64)(100 * v25) >> 32, v16, HIDWORD(v16));\n      fprintf(stderr, \"%s: %u%% - replaced with %.*s\\n\", (const char *)v6, 100 - v13, v17, v10);\n    }\n    v14 = (const char *)v6;\n    if ( (dword_80DBB9C & 4) == 0 )\n      goto LABEL_45;\nLABEL_47:\n    if ( (char *)v6 != v10 )\n      goto LABEL_50;\nLABEL_51:\n    if ( !*a1 )\n      break;\n    ++a1;\n  }\n  while ( *a1 );\n  if ( (dword_80DBB9C & 1) != 0 )\n    sub_804DCF3(1);\n  return v5;\n}\n"
    ],
    "sub_8085979": [
        "0x8085979",
        "int __cdecl sub_8085979(int a1, int a2)\n{\n  sub_80ABEC2(a2, \"cfkvqdtn\", \"stdout\");\n  if ( ident[1] == 99 )\n    dword_80DBB9C |= 1u;\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808B384, sub_808568A, 0);\n}\n"
    ],
    "sub_80859BF": [
        "0x80859bf",
        "int __cdecl sub_80859BF(int a1, int a2)\n{\n  sub_80ABEAC(a2, \"cfkvqdt\");\n  if ( ident[2] == 99 )\n    dword_80DBB9C |= 1u;\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808A1F9, (int (*)(void))sub_8085654, (int)\"bz2\");\n}\n"
    ],
    "sub_8085A02": [
        "0x8085a02",
        "int __cdecl sub_8085A02(int a1, int a2)\n{\n  char v2; // al\n  char v3; // dl\n\n  v2 = sub_80ABEAC(a2, \"cfkvqdt\");\n  v3 = ident[2];\n  if ( v3 == 109 )\n  {\n    if ( (v2 & 0x60) == 0 )\n      sub_804CDC2();\n  }\n  else if ( v3 == 99 )\n  {\n    dword_80DBB9C |= 1u;\n  }\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808B67C, (int (*)(void))sub_8085654, (int)\"lzma\");\n}\n"
    ],
    "sub_8085A55": [
        "0x8085a55",
        "int __cdecl sub_8085A55(int a1, int a2)\n{\n  char v2; // al\n  char v3; // dl\n\n  v2 = sub_80ABEAC(a2, \"cfkvqdt\");\n  v3 = ident[2];\n  if ( v3 )\n  {\n    if ( v3 == 99 )\n      dword_80DBB9C |= 1u;\n  }\n  else if ( (v2 & 0x60) == 0 )\n  {\n    sub_804CDC2();\n  }\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808CF10, (int (*)(void))sub_8085654, (int)\"xz\");\n}\n"
    ],
    "sub_8085AA7": [
        "0x8085aa7",
        "int __cdecl sub_8085AA7(int a1, int a2)\n{\n  int v2; // edi\n  int v3; // ecx\n  __int16 v4; // bx\n  _DWORD *v5; // esi\n  int v6; // eax\n  const char *v8; // [esp+0h] [ebp-14h] BYREF\n  int v9[4]; // [esp+4h] [ebp-10h] BYREF\n\n  qword_80DB778 = -1LL;\n  v2 = sub_808E331();\n  *(_DWORD *)v2 = 8;\n  v4 = sub_80ABEC2(a2, \"it0uvdmLF:R:\", \"extract\", &v8, v9);\n  v5 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v4 & 0x200) != 0 )\n  {\n    sub_80B48BE();\n    *(_QWORD *)(v2 + 84) = qword_80DB778;\n  }\n  if ( (v4 & 0x100) != 0 )\n  {\n    v6 = sub_804DBE1(v8);\n    sub_804DC97(v6, 0);\n  }\n  if ( (v4 & 3) == 0 )\n    sub_804CDC2();\n  if ( (v4 & 2) != 0 )\n  {\n    v4 &= ~1u;\n    *(_DWORD *)(v2 + 32) = sub_808E264;\n  }\n  if ( (v4 & 1) != 0 )\n  {\n    *(_DWORD *)(v2 + 36) = sub_8089512;\n    if ( (v4 & 0x800) != 0 )\n      *(_DWORD *)(v2 + 36) = sub_8089994;\n  }\n  if ( (v4 & 8) != 0 )\n    *(_DWORD *)v2 = *(_DWORD *)v2 & 0xFFFFFFF3 | 4;\n  if ( (v4 & 0x10) != 0 )\n  {\n    if ( *(int (**)())(v2 + 32) == sub_808E264 )\n      *(_DWORD *)(v2 + 32) = sub_808E26D;\n    else\n      *(_DWORD *)(v2 + 32) = sub_808E264;\n  }\n  if ( (v4 & 0x20) != 0 )\n    *(_DWORD *)v2 |= 2u;\n  if ( (v4 & 0x40) != 0 )\n    *(_DWORD *)v2 |= 1u;\n  while ( *v5 )\n  {\n    *(_DWORD *)(v2 + 8) = sub_808D814;\n    sub_80AFAC3(v3, *v5++);\n  }\n  *(_DWORD *)(v2 + 76) = -1;\n  *(_DWORD *)(v2 + 80) = -1;\n  while ( !(unsigned __int8)sub_808D8F8() )\n    ;\n  sub_808F0AE();\n  if ( (*(_DWORD *)(v2 + 80) != -1 || *(_DWORD *)(v2 + 76) != -1) && (v4 & 0x400) == 0 )\n    fprintf(stderr, \"%llu blocks\\n\", *(_QWORD *)(v2 + 76));\n  return 0;\n}\n"
    ],
    "sub_8085C14": [
        "0x8085c14",
        "int sub_8085C14()\n{\n  int result; // eax\n  int i; // edx\n  int j; // edx\n  int k; // edx\n\n  result = dword_80DBB80;\n  for ( i = 0; i != 286; ++i )\n    *(_WORD *)(result + 4 * i + 1156) = 0;\n  for ( j = 0; j != 30; ++j )\n    *(_WORD *)(result + 4 * j + 3448) = 0;\n  for ( k = 0; k != 19; ++k )\n    *(_WORD *)(result + 4 * k + 4964) = 0;\n  *(_WORD *)(result + 2180) = 1;\n  *(_DWORD *)(result + 7860) = 0;\n  *(_DWORD *)(result + 7856) = 0;\n  *(_DWORD *)(result + 7840) = 0;\n  *(_DWORD *)(result + 7844) = 0;\n  *(_DWORD *)(result + 7848) = 0;\n  *(_WORD *)(result + 7852) = 256;\n  return result;\n}\n"
    ],
    "sub_8085C97": [
        "0x8085c97",
        "unsigned __int16 __usercall sub_8085C97@<ax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ecx\n  int v4; // eax\n  unsigned __int16 *v5; // ebx\n  int v6; // esi\n  int v7; // ebx\n  unsigned __int16 v8; // dx\n  unsigned __int16 v9; // bx\n  unsigned __int16 result; // ax\n  int v11; // [esp+0h] [ebp-24h]\n  unsigned __int16 v12; // [esp+6h] [ebp-1Eh]\n  unsigned __int16 v13; // [esp+8h] [ebp-1Ch]\n  int v14; // [esp+Ch] [ebp-18h]\n  unsigned __int16 *v15; // [esp+10h] [ebp-14h]\n\n  v11 = a2;\n  v3 = dword_80DBB80;\n  v12 = *(_WORD *)(dword_80DBB80 + 2 * a2);\n  v4 = 2 * a2;\n  v14 = *(_DWORD *)(dword_80DBB80 + 1148);\n  v15 = (unsigned __int16 *)(a1 + 4 * v12);\n  while ( v14 >= v4 )\n  {\n    v5 = (unsigned __int16 *)(v3 + 2 * v4);\n    v6 = *v5;\n    if ( v14 > v4 )\n    {\n      v7 = v5[1];\n      v8 = *(_WORD *)(a1 + 4 * v6);\n      if ( *(_WORD *)(a1 + 4 * v7) < v8\n        || *(_WORD *)(a1 + 4 * v7) == v8 && *(_BYTE *)(v3 + v7 + 5236) <= *(_BYTE *)(v3 + v6 + 5236) )\n      {\n        ++v4;\n      }\n    }\n    v13 = *(_WORD *)(v3 + 2 * v4);\n    v9 = *(_WORD *)(a1 + 4 * v13);\n    if ( *v15 < v9 || *v15 == v9 && *(_BYTE *)(v3 + v12 + 5236) <= *(_BYTE *)(v3 + v13 + 5236) )\n      break;\n    *(_WORD *)(v3 + 2 * v11) = v13;\n    v11 = v4;\n    v4 *= 2;\n  }\n  result = v12;\n  *(_WORD *)(v3 + 2 * v11) = v12;\n  return result;\n}\n"
    ],
    "sub_8085D60": [
        "0x8085d60",
        "int __usercall sub_8085D60@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ecx\n  int v4; // ebx\n  int i; // edi\n  int v6; // esi\n  unsigned int v7; // ebx\n  int j; // ecx\n  int v9; // ecx\n  __int16 v10[24]; // [esp+0h] [ebp-30h]\n\n  v2 = dword_80DBB80;\n  v3 = 1;\n  v4 = 0;\n  do\n  {\n    LOWORD(v4) = *(_WORD *)(v2 + 2 * v3 + 5202) + v4;\n    v4 *= 2;\n    v10[v3++] = v4;\n  }\n  while ( v3 != 16 );\n  for ( i = 0; i <= a2; ++i )\n  {\n    v6 = *(unsigned __int16 *)(result + 4 * i + 2);\n    if ( *(_WORD *)(result + 4 * i + 2) )\n    {\n      v7 = (unsigned __int16)v10[v6];\n      v10[v6] = v7 + 1;\n      for ( j = 0; ; j = 2 * v9 )\n      {\n        v9 = v7 & 1 | j;\n        if ( !--v6 )\n          break;\n        v7 >>= 1;\n      }\n      *(_WORD *)(result + 4 * i) = v9;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8085DC5": [
        "0x8085dc5",
        "int __usercall sub_8085DC5@<eax>(int *a1@<eax>)\n{\n  int v2; // edx\n  int v3; // edi\n  int v4; // ecx\n  int i; // eax\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebp\n  int v9; // eax\n  int v10; // ebp\n  int v11; // ebp\n  unsigned __int16 v12; // bp\n  int v13; // eax\n  int v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  int v17; // edx\n  _WORD *v18; // ebp\n  unsigned __int8 v19; // dl\n  char v20; // al\n  __int16 v21; // ax\n  int v22; // ebp\n  int v23; // edx\n  int v24; // eax\n  int j; // ecx\n  int v26; // edi\n  int v27; // ecx\n  int v28; // edx\n  int v29; // ecx\n  int v31; // edx\n  int k; // edx\n  __int16 v33; // si\n  int v34; // ecx\n  int v35; // edx\n  unsigned __int16 *v36; // ecx\n  int v37; // esi\n  int v38; // [esp+0h] [ebp-38h]\n  int v39; // [esp+4h] [ebp-34h]\n  _WORD *v40; // [esp+8h] [ebp-30h]\n  int v41; // [esp+8h] [ebp-30h]\n  unsigned __int16 *v42; // [esp+Ch] [ebp-2Ch]\n  int v43; // [esp+10h] [ebp-28h]\n  int v44; // [esp+14h] [ebp-24h]\n  int v45; // [esp+18h] [ebp-20h]\n  int v46; // [esp+1Ch] [ebp-1Ch]\n  int v47; // [esp+20h] [ebp-18h]\n  int v48; // [esp+24h] [ebp-14h]\n\n  v38 = *a1;\n  v2 = a1[1];\n  v3 = a1[4];\n  v4 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 1148) = 0;\n  *(_DWORD *)(v4 + 1152) = 573;\n  v39 = -1;\n  for ( i = 0; i < v3; ++i )\n  {\n    if ( *(_WORD *)(v38 + 4 * i) )\n    {\n      v6 = *(_DWORD *)(v4 + 1148) + 1;\n      *(_DWORD *)(v4 + 1148) = v6;\n      *(_WORD *)(v4 + 2 * v6) = i;\n      *(_BYTE *)(v4 + i + 5236) = 0;\n      v39 = i;\n    }\n    else\n    {\n      *(_WORD *)(v38 + 4 * i + 2) = 0;\n    }\n  }\n  v7 = dword_80DBB80;\n  while ( 1 )\n  {\n    v8 = *(_DWORD *)(v7 + 1148);\n    if ( v8 > 1 )\n      break;\n    v9 = 0;\n    if ( v39 <= 1 )\n      v9 = (unsigned __int16)++v39;\n    v10 = v8 + 1;\n    *(_DWORD *)(v7 + 1148) = v10;\n    *(_WORD *)(v7 + 2 * v10) = v9;\n    *(_WORD *)(v38 + 4 * v9) = 1;\n    *(_BYTE *)(v7 + v9 + 5236) = 0;\n    --*(_DWORD *)(v7 + 7856);\n    if ( v2 )\n      *(_DWORD *)(v7 + 7860) -= *(unsigned __int16 *)(v2 + 4 * v9 + 2);\n  }\n  a1[6] = v39;\n  v11 = v8 >> 1;\n  do\n    sub_8085C97(v38, v11--);\n  while ( v11 );\n  do\n  {\n    v12 = *(_WORD *)(v7 + 2);\n    v13 = *(_DWORD *)(v7 + 1148);\n    *(_DWORD *)(v7 + 1148) = v13 - 1;\n    *(_WORD *)(v7 + 2) = *(_WORD *)(v7 + 2 * v13);\n    sub_8085C97(v38, 1);\n    v14 = *(unsigned __int16 *)(v7 + 2);\n    v15 = *(_DWORD *)(v7 + 1152);\n    v16 = v7 + 2 * v15;\n    *(_WORD *)(v16 - 2) = v12;\n    *(_DWORD *)(v7 + 1152) = v15 - 2;\n    *(_WORD *)(v16 - 4) = v14;\n    v17 = v12;\n    v40 = (_WORD *)(v38 + 4 * v12);\n    v18 = (_WORD *)(v38 + 4 * v14);\n    *(_WORD *)(v38 + 4 * v3) = *v40 + *v18;\n    v19 = *(_BYTE *)(v7 + v17 + 5236);\n    LOBYTE(v16) = *(_BYTE *)(v7 + v14 + 5236);\n    v20 = v16 + 1;\n    if ( v19 > (unsigned __int8)v16 )\n      v20 = v19 + 1;\n    *(_BYTE *)(v7 + v3 + 5236) = v20;\n    v21 = v3;\n    v18[1] = v3;\n    v40[1] = v3++;\n    *(_WORD *)(v7 + 2) = v21;\n    sub_8085C97(v38, 1);\n  }\n  while ( *(int *)(v7 + 1148) > 1 );\n  v22 = *(_DWORD *)(v7 + 1152);\n  *(_DWORD *)(v7 + 1152) = v22 - 1;\n  v23 = *(unsigned __int16 *)(v7 + 2);\n  *(_WORD *)(v7 + 2 * (v22 - 1)) = v23;\n  v41 = *a1;\n  v48 = a1[2];\n  v44 = a1[3];\n  v45 = a1[6];\n  v24 = a1[5];\n  v46 = a1[1];\n  for ( j = 0; j != 16; ++j )\n    *(_WORD *)(v7 + 2 * j + 5204) = 0;\n  *(_WORD *)(v41 + 4 * v23 + 2) = 0;\n  v26 = 0;\n  while ( v22 <= 572 )\n  {\n    v27 = *(unsigned __int16 *)(v7 + 2 * v22);\n    v47 = 4 * v27;\n    v42 = (unsigned __int16 *)(4 * v27 + v41);\n    v28 = *(unsigned __int16 *)(v41 + 4 * v42[1] + 2) + 1;\n    if ( v24 < v28 )\n    {\n      ++v26;\n      v28 = v24;\n    }\n    v42[1] = v28;\n    if ( v45 >= v27 )\n    {\n      ++*(_WORD *)(v7 + 2 * v28 + 5204);\n      v43 = 0;\n      if ( v44 <= v27 )\n        v43 = *(unsigned __int8 *)(v48 + v27 - v44);\n      v29 = *v42;\n      *(_DWORD *)(v7 + 7856) += v29 * (v43 + v28);\n      if ( v46 )\n        *(_DWORD *)(v7 + 7860) += v29 * (*(unsigned __int16 *)(v46 + v47 + 2) + v43);\n    }\n    ++v22;\n  }\n  if ( v26 )\n  {\n    do\n    {\n      for ( k = v24 - 1; ; --k )\n      {\n        v33 = *(_WORD *)(v7 + 2 * k + 5204);\n        if ( v33 )\n          break;\n      }\n      v31 = v7 + 2 * k;\n      *(_WORD *)(v31 + 5204) = v33 - 1;\n      *(_WORD *)(v31 + 5206) += 2;\n      --*(_WORD *)(v7 + 2 * v24 + 5204);\n      v26 -= 2;\n    }\n    while ( v26 > 0 );\n    while ( v24 )\n    {\n      v35 = *(unsigned __int16 *)(v7 + 2 * v24 + 5204);\n      while ( v35 )\n      {\n        --v22;\n        v34 = *(unsigned __int16 *)(v7 + 2 * v22);\n        if ( v45 >= v34 )\n        {\n          v36 = (unsigned __int16 *)(v41 + 4 * v34);\n          v37 = v36[1];\n          if ( v37 != v24 )\n          {\n            *(_DWORD *)(v7 + 7856) += *v36 * (v24 - v37);\n            v36[1] = v24;\n          }\n          --v35;\n        }\n      }\n      --v24;\n    }\n  }\n  return sub_8085D60(v38, v39);\n}\n"
    ],
    "sub_808610D": [
        "0x808610d",
        "int __usercall sub_808610D@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // edx\n  int v3; // edi\n  int v4; // ecx\n  int v5; // esi\n  int i; // ebp\n  int v7; // [esp+0h] [ebp-1Ch]\n  int v8; // [esp+4h] [ebp-18h]\n\n  v2 = *(unsigned __int16 *)(result + 2);\n  v3 = 4 - (v2 == 0);\n  v4 = v2 == 0 ? 138 : 7;\n  *(_WORD *)(result + 4 * a2 + 6) = -1;\n  v5 = 0;\n  v8 = -1;\n  for ( i = 0; i <= a2; ++i )\n  {\n    v7 = *(unsigned __int16 *)(result + 4 * i + 6);\n    if ( v4 <= ++v5 )\n      goto LABEL_7;\n    if ( v2 == *(unsigned __int16 *)(result + 4 * i + 6) )\n    {\n      v2 = v8;\n      goto LABEL_18;\n    }\n    if ( v3 <= v5 )\n    {\nLABEL_7:\n      if ( v2 )\n      {\n        if ( v8 != v2 )\n          ++*(_WORD *)(dword_80DBB80 + 4 * v2 + 4964);\n        ++*(_WORD *)(dword_80DBB80 + 5028);\n      }\n      else if ( v5 > 10 )\n      {\n        ++*(_WORD *)(dword_80DBB80 + 5036);\n      }\n      else\n      {\n        ++*(_WORD *)(dword_80DBB80 + 5032);\n      }\n    }\n    else\n    {\n      *(_WORD *)(dword_80DBB80 + 4 * v2 + 4964) += v5;\n    }\n    if ( v7 )\n    {\n      v3 = (v2 != v7) + 3;\n      v4 = (v2 != v7) + 6;\n      v5 = 0;\n    }\n    else\n    {\n      v5 = 0;\n      v3 = 3;\n      v4 = 138;\n    }\nLABEL_18:\n    v8 = v2;\n    v2 = v7;\n  }\n  return result;\n}\n"
    ],
    "sub_8086203": [
        "0x8086203",
        "_BOOL4 __usercall sub_8086203@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ecx\n  int v3; // esi\n  int v4; // ebx\n  int v5; // eax\n  int v6; // edx\n  int v7; // ebx\n  int v8; // edx\n  unsigned int v9; // edx\n  int v10; // eax\n  unsigned int v11; // eax\n  int i; // ebx\n  unsigned int v13; // ebx\n  _BOOL4 result; // eax\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 68);\n  v4 = *(_DWORD *)(dword_80DBB80 + 7840);\n  *(_DWORD *)(dword_80DBB80 + 7840) = v4 + 1;\n  *(_BYTE *)(v3 + v4) = a2;\n  if ( a1 )\n  {\n    v5 = a1 - 1;\n    ++*(_WORD *)(v2 + 4 * *(unsigned __int8 *)(v2 + a2 + 5809) + 2184);\n    if ( v5 > 255 )\n      v6 = *(unsigned __int8 *)(v2 + (v5 >> 7) + 6321);\n    else\n      v6 = *(unsigned __int8 *)(v2 + v5 + 6065);\n    ++*(_WORD *)(v2 + 4 * v6 + 3448);\n    v7 = *(_DWORD *)(v2 - 64);\n    v8 = *(_DWORD *)(v2 + 7844);\n    *(_DWORD *)(v2 + 7844) = v8 + 1;\n    *(_WORD *)(v7 + 2 * v8) = v5;\n    *(_BYTE *)(v2 + 7852) |= *(_BYTE *)(v2 + 7853);\n  }\n  else\n  {\n    ++*(_WORD *)(v2 + 4 * a2 + 1156);\n  }\n  *(_BYTE *)(v2 + 7853) *= 2;\n  v9 = *(_DWORD *)(v2 + 7840);\n  if ( (v9 & 7) == 0 )\n  {\n    v10 = *(_DWORD *)(v2 + 7848);\n    *(_DWORD *)(v2 + 7848) = v10 + 1;\n    *(_BYTE *)(v2 + v10 + 6816) = *(_BYTE *)(v2 + 7852);\n    *(_WORD *)(v2 + 7852) = 256;\n  }\n  if ( (v9 & 0xFFF) != 0 )\n    goto LABEL_14;\n  v11 = 8 * v9;\n  for ( i = 0; i != 30; ++i )\n    v11 += *(unsigned __int16 *)(v2 + 4 * i + 3448) * ((unsigned __int8)byte_80D4D27[i] + 5);\n  v13 = v11 >> 3;\n  if ( *(_DWORD *)(v2 + 7844) >= v9 >> 1\n    || (result = 1, (unsigned int)(*(_DWORD *)(v2 - 32) - *(_DWORD *)(v2 - 44)) >> 1 <= v13) )\n  {\nLABEL_14:\n    result = 1;\n    if ( v9 != 0x1FFF )\n      return *(_DWORD *)(v2 + 7844) == 0x2000;\n  }\n  return result;\n}\n"
    ],
    "sub_8086330": [
        "0x8086330",
        "ssize_t __usercall sub_8086330@<eax>(void *a1@<eax>, size_t a2@<edx>)\n{\n  ssize_t v2; // ebx\n  int v3; // esi\n\n  v2 = sub_804E5BC(a2, a1, 0);\n  if ( (unsigned int)(v2 - 1) <= 0xFFFFFFFD )\n  {\n    v3 = dword_80DBB80;\n    *(_DWORD *)(v3 - 48) = sub_80AA41E(dword_80DBB98);\n    *(_DWORD *)(v3 - 20) += v2;\n  }\n  return v2;\n}\n"
    ],
    "sub_808636C": [
        "0x808636c",
        "void sub_808636C()\n{\n  int v0; // ebx\n  unsigned int v1; // ebp\n  unsigned int v2; // eax\n  unsigned int v3; // ebp\n  size_t v4; // edx\n  int v5; // eax\n  int v6; // ecx\n  int i; // edx\n  int v8; // esi\n  int j; // edx\n  int v10; // esi\n  ssize_t v11; // eax\n\nLABEL_1:\n  v0 = dword_80DBB80;\n  while ( 1 )\n  {\n    v1 = *(_DWORD *)(v0 - 24);\n    if ( v1 > 0x105 || *(_BYTE *)(v0 - 12) )\n      break;\n    v2 = *(_DWORD *)(v0 - 32);\n    v3 = v2 + v1;\n    v4 = 0x10000 - v3;\n    if ( v3 == 65537 )\n    {\n      v4 = -2;\n    }\n    else if ( v2 > 0xFEF9 )\n    {\n      v5 = *(_DWORD *)(v0 - 56);\n      qmemcpy((void *)v5, (const void *)(v5 + 0x8000), 0x8000u);\n      *(_DWORD *)(v0 - 28) -= 0x8000;\n      *(_DWORD *)(v0 - 32) -= 0x8000;\n      *(_DWORD *)(v0 - 44) -= 0x8000;\n      v6 = *(_DWORD *)(v0 - 52);\n      for ( i = 0; i != 0x2000; ++i )\n      {\n        LOWORD(v5) = *(_WORD *)(v6 + 2 * i + 0x10000);\n        HIWORD(v8) = HIWORD(v5);\n        LOWORD(v8) = (__int16)v5 >> 15;\n        LOWORD(v5) = v5 + 0x8000;\n        v5 &= v8;\n        *(_WORD *)(v6 + 2 * i + 0x10000) = v5;\n      }\n      for ( j = 0; j != 0x8000; ++j )\n      {\n        LOWORD(v5) = *(_WORD *)(v6 + 2 * j);\n        HIWORD(v10) = HIWORD(v5);\n        LOWORD(v10) = (__int16)v5 >> 15;\n        LOWORD(v5) = v5 + 0x8000;\n        v5 &= v10;\n        *(_WORD *)(v6 + 2 * j) = v5;\n      }\n      v4 = 98304 - v3;\n    }\n    if ( !*(_BYTE *)(v0 - 12) )\n    {\n      v11 = sub_8086330((void *)(*(_DWORD *)(v0 - 56) + *(_DWORD *)(v0 - 32) + *(_DWORD *)(v0 - 24)), v4);\n      if ( (unsigned int)(v11 - 1) <= 0xFFFFFFFD )\n        *(_DWORD *)(v0 - 24) += v11;\n      else\n        *(_BYTE *)(v0 - 12) = 1;\n      goto LABEL_1;\n    }\n  }\n}\n"
    ],
    "sub_808645F": [
        "0x808645f",
        "void sub_808645F()\n{\n  int v0; // ebx\n  int v1; // ecx\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 - 16);\n  if ( v1 )\n  {\n    sub_804DCAD(v1, *(_DWORD *)(dword_80DBB80 - 60));\n    *(_DWORD *)(v0 - 16) = 0;\n  }\n}\n"
    ],
    "sub_8086483": [
        "0x8086483",
        "void __usercall sub_8086483(unsigned __int16 a1@<ax>)\n{\n  int v1; // ebx\n  unsigned int v2; // edx\n  _BYTE *v3; // ecx\n  __int16 v4; // si\n  unsigned int v5; // edx\n  int v6; // edx\n  int v7; // eax\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 - 16);\n  v3 = (_BYTE *)(v2 + *(_DWORD *)(dword_80DBB80 - 60));\n  if ( v2 > 0x1FFD )\n  {\n    *v3 = a1;\n    v4 = HIBYTE(a1);\n    v5 = v2 + 1;\n    *(_DWORD *)(v1 - 16) = v5;\n    if ( v5 == 0x2000 )\n      sub_808645F();\n    v6 = *(_DWORD *)(v1 - 60);\n    v7 = *(_DWORD *)(v1 - 16);\n    *(_DWORD *)(v1 - 16) = v7 + 1;\n    *(_BYTE *)(v6 + v7) = v4;\n    if ( *(_DWORD *)(v1 - 16) == 0x2000 )\n      sub_808645F();\n  }\n  else\n  {\n    *(_WORD *)v3 = a1;\n    *(_DWORD *)(v1 - 16) = v2 + 2;\n  }\n}\n"
    ],
    "sub_80864E3": [
        "0x80864e3",
        "void __usercall sub_80864E3(int a1@<eax>)\n{\n  unsigned __int16 v1; // ebx^2\n\n  v1 = HIWORD(a1);\n  sub_8086483(a1);\n  sub_8086483(v1);\n}\n"
    ],
    "sub_80864F9": [
        "0x80864f9",
        "void __usercall sub_80864F9(unsigned int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebp\n  int v3; // ecx\n  int v4; // edi\n  int v5; // ebx\n  int v6; // esi\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 4);\n  v4 = *(_DWORD *)(dword_80DBB80 - 8) | (a1 << v3);\n  v5 = v3 + a2;\n  if ( (unsigned int)(v3 + a2) > 0x1F )\n  {\n    v6 = a1 >> (32 - v3);\n    sub_80864E3(v4);\n    v5 -= 32;\n    v4 = v6;\n  }\n  *(_DWORD *)(v2 - 8) = v4;\n  *(_DWORD *)(v2 - 4) = v5;\n}\n"
    ],
    "sub_8086539": [
        "0x8086539",
        "int __usercall sub_8086539@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ecx\n  int result; // eax\n  int v5; // edi\n  int v6; // edx\n  int v7; // ebp\n  int v8; // ebx\n  int v9; // edi\n  int v10; // ecx\n  unsigned int v11; // eax\n  int v12; // edx\n  int v13; // [esp+0h] [ebp-20h]\n  int v16; // [esp+Ch] [ebp-14h]\n\n  v2 = *(unsigned __int16 *)(a1 + 2);\n  v3 = 4 - (v2 == 0);\n  result = v2 == 0 ? 138 : 7;\n  v5 = 0;\n  v6 = -1;\n  v13 = 0;\n  while ( v13 <= a2 )\n  {\n    v7 = *(unsigned __int16 *)(a1 + 4 * v13 + 6);\n    v8 = v5 + 1;\n    if ( result <= v5 + 1 )\n      goto LABEL_9;\n    if ( v2 == v7 )\n    {\n      v2 = v6;\n      goto LABEL_21;\n    }\n    if ( v3 <= v8 )\n    {\nLABEL_9:\n      v10 = dword_80DBB80;\n      if ( v2 )\n      {\n        if ( v6 != v2 )\n        {\n          v16 = dword_80DBB80;\n          sub_80864F9(\n            *(unsigned __int16 *)(dword_80DBB80 + 4 * v2 + 4964),\n            *(unsigned __int16 *)(dword_80DBB80 + 4 * v2 + 4966));\n          v8 = v5;\n          v10 = v16;\n        }\n        sub_80864F9(*(unsigned __int16 *)(v10 + 5028), *(unsigned __int16 *)(v10 + 5030));\n        v11 = v8 - 3;\n        v12 = 2;\n      }\n      else if ( v8 > 10 )\n      {\n        sub_80864F9(*(unsigned __int16 *)(dword_80DBB80 + 5036), *(unsigned __int16 *)(dword_80DBB80 + 5038));\n        v11 = v5 - 10;\n        v12 = 7;\n      }\n      else\n      {\n        sub_80864F9(*(unsigned __int16 *)(dword_80DBB80 + 5032), *(unsigned __int16 *)(dword_80DBB80 + 5034));\n        v11 = v5 - 2;\n        v12 = 3;\n      }\n      sub_80864F9(v11, v12);\n    }\n    else\n    {\n      v9 = dword_80DBB80 + 4 * v2;\n      do\n      {\n        sub_80864F9(*(unsigned __int16 *)(v9 + 4964), *(unsigned __int16 *)(v9 + 4966));\n        --v8;\n      }\n      while ( v8 );\n    }\n    if ( v7 )\n    {\n      v3 = (v2 != v7) + 3;\n      result = (v2 != v7) + 6;\n      v8 = 0;\n    }\n    else\n    {\n      v8 = 0;\n      v3 = 3;\n      result = 138;\n    }\nLABEL_21:\n    ++v13;\n    v5 = v8;\n    v6 = v2;\n    v2 = v7;\n  }\n  return result;\n}\n"
    ],
    "sub_8086688": [
        "0x8086688",
        "void __usercall sub_8086688(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebp\n  unsigned int i; // eax\n  int v5; // ebx\n  int v6; // esi\n  unsigned __int16 *v7; // eax\n  int v8; // edx\n  unsigned int v9; // eax\n  int v10; // edx\n  unsigned int v11; // esi\n  int v12; // ecx\n  int v13; // [esp+0h] [ebp-28h]\n  unsigned __int8 v14; // [esp+7h] [ebp-21h]\n  unsigned int v15; // [esp+8h] [ebp-20h]\n  int v16; // [esp+Ch] [ebp-1Ch]\n  int v18; // [esp+14h] [ebp-14h]\n\n  if ( *(_DWORD *)(dword_80DBB80 + 7840) )\n  {\n    v14 = 0;\n    v13 = 0;\n    v3 = 0;\n    for ( i = 0; ; i = v15 )\n    {\n      v5 = dword_80DBB80;\n      if ( (i & 7) == 0 )\n        v14 = *(_BYTE *)(dword_80DBB80 + v13++ + 6816);\n      v15 = i + 1;\n      v6 = *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB80 - 68) + i);\n      if ( (v14 & 1) == 0 )\n        break;\n      v16 = *(unsigned __int8 *)(dword_80DBB80 + v6 + 5809);\n      sub_80864F9(*(unsigned __int16 *)(a1 + 4 * v16 + 1028), *(unsigned __int16 *)(a1 + 4 * v16 + 1030));\n      v10 = (unsigned __int8)byte_80D4D45[v16];\n      if ( (_BYTE)v10 )\n        sub_80864F9(v6 - *(_DWORD *)(v5 + 4 * v16 + 6580), v10);\n      v11 = *(unsigned __int16 *)(*(_DWORD *)(v5 - 64) + 2 * v3);\n      if ( v11 > 0xFF )\n        v12 = *(unsigned __int8 *)(v5 + (v11 >> 7) + 6321);\n      else\n        v12 = *(unsigned __int8 *)(v5 + v11 + 6065);\n      v18 = v12;\n      sub_80864F9(*(unsigned __int16 *)(a2 + 4 * v12), *(unsigned __int16 *)(a2 + 4 * v12 + 2));\n      v8 = (unsigned __int8)byte_80D4D27[v18];\n      ++v3;\n      if ( (_BYTE)v8 )\n      {\n        v9 = v11 - *(_DWORD *)(v5 + 4 * v18 + 6696);\n        goto LABEL_14;\n      }\nLABEL_15:\n      v14 >>= 1;\n      if ( *(_DWORD *)(v5 + 7840) <= v15 )\n        goto LABEL_17;\n    }\n    v7 = (unsigned __int16 *)(a1 + 4 * v6);\n    v8 = v7[1];\n    v9 = *v7;\nLABEL_14:\n    sub_80864F9(v9, v8);\n    goto LABEL_15;\n  }\nLABEL_17:\n  sub_80864F9(*(unsigned __int16 *)(a1 + 1024), *(unsigned __int16 *)(a1 + 1026));\n}\n"
    ],
    "sub_80867CB": [
        "0x80867cb",
        "void sub_80867CB()\n{\n  int v0; // ebx\n  unsigned int v1; // edi\n  int i; // esi\n  int v3; // edx\n  int v4; // eax\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 - 8);\n  for ( i = *(_DWORD *)(dword_80DBB80 - 4); i > 0; i -= 8 )\n  {\n    v3 = *(_DWORD *)(v0 - 60);\n    v4 = *(_DWORD *)(v0 - 16);\n    *(_DWORD *)(v0 - 16) = v4 + 1;\n    *(_BYTE *)(v3 + v4) = v1;\n    if ( *(_DWORD *)(v0 - 16) == 0x2000 )\n      sub_808645F();\n    v1 >>= 8;\n  }\n  *(_DWORD *)(v0 - 8) = 0;\n  *(_DWORD *)(v0 - 4) = 0;\n}\n"
    ],
    "sub_8086817": [
        "0x8086817",
        "void __usercall sub_8086817(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)\n{\n  int *v5; // ebx\n  int i; // esi\n  int v7; // eax\n  unsigned int v8; // ecx\n  unsigned int v9; // eax\n  unsigned int v10; // edx\n  int v11; // edi\n  int v12; // ecx\n  int v13; // eax\n  int v14; // edx\n  int v15; // eax\n  unsigned int v16; // edi\n  int v17; // ebp\n  int v18; // ecx\n  int v20; // [esp+Ch] [ebp-14h]\n\n  v5 = (int *)dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + *(_DWORD *)(dword_80DBB80 + 7848) + 6816) = *(_BYTE *)(dword_80DBB80 + 7852);\n  sub_8085DC5(v5 + 1280);\n  sub_8085DC5(v5 + 1287);\n  sub_808610D((int)(v5 + 289), v5[1286]);\n  sub_808610D((int)(v5 + 862), v5[1293]);\n  sub_8085DC5(v5 + 1294);\n  for ( i = 18; i != 2; --i )\n  {\n    if ( HIWORD(v5[(unsigned __int8)byte_80D4D01[i] + 1241]) )\n      break;\n  }\n  v7 = 3 * (i + 1) + v5[1964] + 14;\n  v5[1964] = v7;\n  v8 = (unsigned int)(v7 + 10) >> 3;\n  v9 = (unsigned int)(v5[1965] + 10) >> 3;\n  v10 = v8;\n  if ( v8 > v9 )\n    v10 = (unsigned int)(v5[1965] + 10) >> 3;\n  if ( a2 + 4 <= v10 && a1 )\n  {\n    sub_80864F9(a3, 3);\n    sub_80867CB();\n    sub_80864E3((unsigned __int16)a2 | (~a2 << 16));\n    v11 = a1 + a2;\n    while ( a1 != v11 )\n    {\n      ++a1;\n      v12 = *(v5 - 15);\n      v13 = *(v5 - 4);\n      *(v5 - 4) = v13 + 1;\n      *(_BYTE *)(v12 + v13) = *(_BYTE *)(a1 - 1);\n      if ( *(v5 - 4) == 0x2000 )\n        sub_808645F();\n    }\n  }\n  else\n  {\n    if ( v8 < v9 )\n    {\n      sub_80864F9(a3 + 4, 3);\n      v16 = v5[1293];\n      v17 = v5[1286];\n      sub_80864F9(v17 - 256, 5);\n      sub_80864F9(v16, 5);\n      sub_80864F9(i - 3, 4);\n      v18 = 0;\n      do\n      {\n        v20 = v18;\n        sub_80864F9(HIWORD(v5[(unsigned __int8)byte_80D4D01[v18] + 1241]), 3);\n        v18 = v20 + 1;\n      }\n      while ( v20 + 1 <= i );\n      sub_8086539((int)(v5 + 289), v17);\n      sub_8086539((int)(v5 + 862), v16);\n      v14 = (int)(v5 + 862);\n      v15 = (int)(v5 + 289);\n    }\n    else\n    {\n      sub_80864F9(a3 + 2, 3);\n      v14 = (int)(v5 + 1211);\n      v15 = (int)(v5 + 923);\n    }\n    sub_8086688(v15, v14);\n  }\n  sub_8085C14();\n  if ( a3 )\n    sub_80867CB();\n}\n"
    ],
    "sub_8086A0A": [
        "0x8086a0a",
        "void sub_8086A0A()\n{\n  unsigned int v0; // esi\n  int v1; // ebx\n  unsigned int v2; // edi\n  int v3; // eax\n  _WORD *v4; // eax\n  _BYTE *v5; // ebp\n  int v6; // eax\n  _BYTE *v7; // esi\n  _BYTE *v8; // esi\n  _BYTE *v9; // eax\n  unsigned int v10; // eax\n  int v11; // esi\n  unsigned int v12; // edx\n  int v13; // eax\n  int v14; // edx\n  int v15; // ebp\n  int v16; // edx\n  int v17; // eax\n  _WORD *v18; // eax\n  int v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int v22; // edx\n  int v23; // ecx\n  int v24; // eax\n  int v25; // ecx\n  int v26; // eax\n  unsigned int v27; // [esp+0h] [ebp-40h]\n  int v28; // [esp+0h] [ebp-40h]\n  unsigned int v29; // [esp+4h] [ebp-3Ch]\n  _BOOL4 v30; // [esp+8h] [ebp-38h]\n  int v31; // [esp+Ch] [ebp-34h]\n  int v32; // [esp+10h] [ebp-30h]\n  int v33; // [esp+14h] [ebp-2Ch]\n  unsigned int v34; // [esp+1Ch] [ebp-24h]\n  unsigned int v35; // [esp+20h] [ebp-20h]\n  int v36; // [esp+24h] [ebp-1Ch]\n  unsigned int v37; // [esp+28h] [ebp-18h]\n  char v38; // [esp+2Dh] [ebp-13h]\n  char v39; // [esp+2Eh] [ebp-12h]\n\n  v0 = 2;\n  v30 = 0;\n  while ( 1 )\n  {\n    v1 = dword_80DBB80;\n    v34 = *(_DWORD *)(dword_80DBB80 - 24);\n    v2 = *(_DWORD *)(dword_80DBB80 - 32);\n    if ( !v34 )\n      break;\n    v31 = *(_DWORD *)(dword_80DBB80 - 56);\n    v3 = (*(unsigned __int8 *)(v31 + v2 + 2) ^ (unsigned __int16)(32 * *(_DWORD *)(dword_80DBB80 - 40))) & 0x1FFF;\n    *(_DWORD *)(dword_80DBB80 - 40) = v3;\n    v32 = *(_DWORD *)(v1 - 52);\n    v4 = (_WORD *)(v32 + 2 * v3 + 0x10000);\n    v27 = (unsigned __int16)*v4;\n    *(_WORD *)(v32 + 2 * (v2 & 0x7FFF)) = v27;\n    *v4 = v2;\n    *(_DWORD *)(v1 - 36) = v0;\n    v36 = *(_DWORD *)(v1 - 28);\n    if ( !v27 || v0 > 0x101 || v2 - v27 > 0x7EFA )\n      goto LABEL_41;\n    v5 = (_BYTE *)(v31 + v2);\n    v29 = v0;\n    v6 = v2;\n    if ( v2 < 0x7EFA )\n      v6 = 32506;\n    v37 = v6 - 32506;\n    v35 = v31 + v2 + 258;\n    v39 = v5[v0 - 1];\n    v38 = v5[v0];\n    v33 = v0 < 0x20 ? 4096 : 1024;\n    while ( 1 )\n    {\n      v7 = (_BYTE *)(v31 + v27);\n      if ( *(_BYTE *)(v31 + v27 + v29) != v38 || v7[v29 - 1] != v39 || *v7 != *v5 || v7[1] != v5[1] )\n        goto LABEL_33;\n      v8 = v7 + 2;\n      v9 = (_BYTE *)(v31 + v2 + 2);\n      while ( v9[1] == v8[1] )\n      {\n        if ( v9[2] != v8[2] )\n        {\n          v9 += 2;\n          goto LABEL_30;\n        }\n        if ( v9[3] != v8[3] )\n        {\n          v9 += 3;\n          goto LABEL_30;\n        }\n        if ( v9[4] != v8[4] )\n        {\n          v9 += 4;\n          goto LABEL_30;\n        }\n        if ( v9[5] != v8[5] )\n        {\n          v9 += 5;\n          goto LABEL_30;\n        }\n        if ( v9[6] != v8[6] )\n        {\n          v9 += 6;\n          goto LABEL_30;\n        }\n        if ( v9[7] != v8[7] )\n        {\n          v9 += 7;\n          goto LABEL_30;\n        }\n        v9 += 8;\n        v8 += 8;\n        if ( v35 <= (unsigned int)v9 || *v9 != *v8 )\n          goto LABEL_30;\n      }\n      ++v9;\nLABEL_30:\n      v10 = v35 - (_DWORD)v9;\n      v11 = 258 - v10;\n      if ( (int)v29 >= (int)(258 - v10) )\n        goto LABEL_33;\n      *(_DWORD *)(v1 - 28) = v27;\n      if ( v11 > 257 )\n        break;\n      v39 = v5[v11 - 1];\n      v38 = v5[v11];\n      v29 = 258 - v10;\nLABEL_33:\n      v27 = *(unsigned __int16 *)(v32 + 2 * (v27 & 0x7FFF));\n      if ( v37 < v27 )\n      {\n        if ( --v33 )\n          continue;\n      }\n      goto LABEL_37;\n    }\n    v29 = 258 - v10;\nLABEL_37:\n    v0 = v34;\n    if ( v34 > v29 )\n      v0 = v29;\n    if ( v0 == 3 && v2 - *(_DWORD *)(v1 - 28) > 0x1000 )\nLABEL_41:\n      v0 = 2;\n    v12 = *(_DWORD *)(v1 - 36);\n    v13 = *(_DWORD *)(v1 - 32);\n    if ( v12 <= 2 || v12 < v0 )\n    {\n      if ( v30 )\n      {\n        if ( sub_8086203(0, *(unsigned __int8 *)(*(_DWORD *)(v1 - 56) + v13 - 1)) )\n        {\n          v23 = *(_DWORD *)(v1 - 44);\n          v24 = 0;\n          if ( v23 >= 0 )\n            v24 = v23 + *(_DWORD *)(v1 - 56);\n          sub_8086817(v24, *(_DWORD *)(v1 - 32) - v23, 0);\n          *(_DWORD *)(v1 - 44) = *(_DWORD *)(v1 - 32);\n        }\n        ++*(_DWORD *)(v1 - 32);\n        --*(_DWORD *)(v1 - 24);\n      }\n      else\n      {\n        *(_DWORD *)(v1 - 32) = v13 + 1;\n        --*(_DWORD *)(v1 - 24);\n        v30 = 1;\n      }\n    }\n    else\n    {\n      v30 = sub_8086203(v13 - 1 - v36, v12 - 3);\n      v14 = *(_DWORD *)(v1 - 36);\n      *(_DWORD *)(v1 - 24) = *(_DWORD *)(v1 - 24) + 1 - v14;\n      *(_DWORD *)(v1 - 36) = v14 - 2;\n      v28 = *(_DWORD *)(v1 - 56);\n      v15 = *(_DWORD *)(v1 - 52);\n      do\n      {\n        v16 = *(_DWORD *)(v1 - 32);\n        *(_DWORD *)(v1 - 32) = v16 + 1;\n        v17 = ((unsigned __int16)(32 * *(_DWORD *)(v1 - 40)) ^ *(unsigned __int8 *)(v28 + v16 + 3)) & 0x1FFF;\n        *(_DWORD *)(v1 - 40) = v17;\n        v18 = (_WORD *)(v15 + 2 * v17 + 0x10000);\n        *(_WORD *)(v15 + 2 * (((_WORD)v16 + 1) & 0x7FFF)) = *v18;\n        *v18 = v16 + 1;\n        v19 = *(_DWORD *)(v1 - 36) - 1;\n        *(_DWORD *)(v1 - 36) = v19;\n      }\n      while ( v19 );\n      v20 = v16 + 2;\n      *(_DWORD *)(v1 - 32) = v20;\n      v0 = 2;\n      if ( v30 )\n      {\n        v21 = *(_DWORD *)(v1 - 44);\n        v22 = v20 - v21;\n        if ( v21 >= 0 )\n          v19 = v21 + v28;\n        sub_8086817(v19, v22, 0);\n        *(_DWORD *)(v1 - 44) = *(_DWORD *)(v1 - 32);\n        v0 = 2;\n        v30 = 0;\n      }\n    }\n    sub_808636C();\n  }\n  if ( v30 )\n    sub_8086203(0, *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB80 - 56) + v2 - 1));\n  v25 = *(_DWORD *)(v1 - 44);\n  v26 = 0;\n  if ( v25 >= 0 )\n    v26 = v25 + *(_DWORD *)(v1 - 56);\n  sub_8086817(v26, *(_DWORD *)(v1 - 32) - v25, 1u);\n}\n"
    ],
    "sub_8086DA8": [
        "0x8086da8",
        "__int64 sub_8086DA8()\n{\n  int v0; // ebx\n  int v1; // eax\n  int v2; // esi\n  int v3; // edx\n  int i; // ecx\n  int v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int j; // esi\n  int v9; // edx\n  int v10; // ecx\n  int k; // esi\n  int m; // eax\n  unsigned int n; // eax\n  unsigned int v14; // ecx\n  int v15; // esi\n  int ii; // edx\n  int v17; // edx\n  ssize_t v18; // eax\n  unsigned __int8 *v19; // edx\n  int v20; // eax\n\n  v0 = dword_80DBB80;\n  memset((void *)(dword_80DBB80 - 48), 0, 0x1EE8u);\n  *(_DWORD *)(v0 + 5120) = v0 + 1156;\n  *(_DWORD *)(v0 + 5124) = v0 + 3692;\n  *(_DWORD *)(v0 + 5128) = byte_80D4D45;\n  *(_DWORD *)(v0 + 5132) = 257;\n  *(_DWORD *)(v0 + 5136) = 286;\n  *(_DWORD *)(v0 + 5140) = 15;\n  *(_DWORD *)(v0 + 5148) = v0 + 3448;\n  *(_DWORD *)(v0 + 5152) = v0 + 4844;\n  *(_DWORD *)(v0 + 5156) = byte_80D4D27;\n  *(_DWORD *)(v0 + 5164) = 30;\n  *(_DWORD *)(v0 + 5168) = 15;\n  *(_DWORD *)(v0 + 5176) = v0 + 4964;\n  *(_DWORD *)(v0 + 5184) = &unk_80D4D14;\n  *(_DWORD *)(v0 + 5192) = 19;\n  *(_DWORD *)(v0 + 5196) = 7;\n  sub_80864E3(559903);\n  sub_80864E3(0);\n  *(_DWORD *)(v0 - 48) = -1;\n  v1 = 0;\n  v2 = 0;\n  do\n  {\n    *(_DWORD *)(v0 + 4 * v1 + 6580) = v2;\n    v3 = 1 << byte_80D4D45[v1];\n    for ( i = 0; i < v3; ++i )\n      *(_BYTE *)(v0 + v2 + i + 5809) = v1;\n    if ( v3 < 0 )\n      v3 = 0;\n    v2 += v3;\n    ++v1;\n  }\n  while ( v1 != 28 );\n  *(_BYTE *)(v0 + v2 + 5808) = 28;\n  v5 = 0;\n  v6 = 0;\n  do\n  {\n    *(_DWORD *)(v0 + 4 * v5 + 6696) = v6;\n    v7 = 1 << byte_80D4D27[v5];\n    for ( j = 0; j < v7; ++j )\n      *(_BYTE *)(v0 + v6 + j + 6065) = v5;\n    if ( v7 < 0 )\n      v7 = 0;\n    v6 += v7;\n    ++v5;\n  }\n  while ( v5 != 16 );\n  v9 = v6 >> 7;\n  do\n  {\n    *(_DWORD *)(v0 + 4 * v5 + 6696) = v9 << 7;\n    v10 = 1 << (byte_80D4D27[v5] - 7);\n    for ( k = 0; k < v10; ++k )\n      *(_BYTE *)(v0 + v9 + k + 6321) = v5;\n    if ( v10 < 0 )\n      v10 = 0;\n    v9 += v10;\n    ++v5;\n  }\n  while ( v5 != 30 );\n  for ( m = 0; m != 144; *(_WORD *)(v0 + 4 * m + 3690) = 8 )\n    ++m;\n  do\n  {\n    ++m;\n    *(_WORD *)(v0 + 4 * m + 3690) = 9;\n  }\n  while ( m != 256 );\n  do\n  {\n    ++m;\n    *(_WORD *)(v0 + 4 * m + 3690) = 7;\n  }\n  while ( m != 280 );\n  *(_WORD *)(v0 + 4814) = 8;\n  *(_WORD *)(v0 + 4818) = 8;\n  *(_WORD *)(v0 + 4822) = 8;\n  *(_WORD *)(v0 + 4826) = 8;\n  *(_WORD *)(v0 + 4830) = 8;\n  *(_WORD *)(v0 + 4834) = 8;\n  *(_WORD *)(v0 + 4838) = 8;\n  *(_WORD *)(v0 + 4842) = 8;\n  *(_DWORD *)(v0 + 5218) = 9961496;\n  *(_WORD *)(v0 + 5222) = 112;\n  sub_8085D60(v0 + 3692, 287);\n  for ( n = 0; n != 30; ++n )\n  {\n    *(_WORD *)(v0 + 4 * n + 4846) = 5;\n    v14 = n;\n    v15 = 5;\n    for ( ii = 0; ; ii = 2 * v17 )\n    {\n      v17 = v14 & 1 | ii;\n      if ( !--v15 )\n        break;\n      v14 >>= 1;\n    }\n    *(_WORD *)(v0 + 4 * n + 4844) = v17;\n  }\n  sub_8085C14();\n  memset((void *)(*(_DWORD *)(v0 - 52) + 0x10000), 0, 0x4000u);\n  v18 = sub_8086330(*(void **)(v0 - 56), 0x10000u);\n  *(_DWORD *)(v0 - 24) = v18;\n  if ( (unsigned int)(v18 - 1) <= 0xFFFFFFFD )\n  {\n    sub_808636C();\n    v19 = *(unsigned __int8 **)(v0 - 56);\n    v20 = (*v19 ^ (unsigned __int16)(32 * *(_DWORD *)(v0 - 40))) & 0x1FFF;\n    *(_DWORD *)(v0 - 40) = v20;\n    *(_DWORD *)(v0 - 40) = (v19[1] ^ (unsigned __int16)(32 * v20)) & 0x1FFF;\n  }\n  else\n  {\n    *(_BYTE *)(v0 - 12) = 1;\n    *(_DWORD *)(v0 - 24) = 0;\n  }\n  sub_8086483(0x302u);\n  sub_8086A0A();\n  sub_80864E3(~*(_DWORD *)(v0 - 48));\n  sub_80864E3(*(_DWORD *)(v0 - 20));\n  sub_808645F();\n  return 0LL;\n}\n"
    ],
    "sub_80870AC": [
        "0x80870ac",
        "int __cdecl sub_80870AC(int a1, int a2)\n{\n  char *v2; // ebx\n\n  v2 = (char *)sub_804DB2E(0x1EFCu) + 68;\n  dword_80DBB80 = (int)v2;\n  if ( (sub_80ABEAC(a2, \"cfkvqdtn123456789\") & 0x60) != 0 )\n    return sub_8085979(a1, a2);\n  dword_80DBB9C &= 0x1Fu;\n  *((_DWORD *)v2 - 17) = sub_804DB2E(0x2000u);\n  *((_DWORD *)v2 - 15) = sub_804DB2E(0x2000u);\n  *((_DWORD *)v2 - 16) = sub_804DB2E(0x4000u);\n  *((_DWORD *)v2 - 14) = sub_804DB2E(0x10000u);\n  *((_DWORD *)v2 - 13) = sub_804DB2E(0x20000u);\n  sub_80AA3E8();\n  return sub_80856FC((int *)(a2 + 4 * optind), sub_8086DA8, sub_80856EC, (int)\"gz\");\n}\n"
    ],
    "sub_8087158": [
        "0x8087158",
        "_BYTE *__usercall sub_8087158@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  char v3; // dl\n\n  *result = *a2;\n  if ( a3 == 1 )\n  {\n    v3 = *a2;\n    result[1] = v3;\n  }\n  else\n  {\n    result[1] = a2[1];\n    if ( a3 == 2 )\n      v3 = *a2;\n    else\n      v3 = a2[2];\n  }\n  result[2] = v3;\n  return result;\n}\n"
    ],
    "sub_8087180": [
        "0x8087180",
        "int __usercall sub_8087180@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned int v3; // esi\n  unsigned int v4; // eax\n  unsigned __int8 *v5; // edi\n  unsigned int v6; // ebx\n  int v7; // eax\n  unsigned __int8 *v8; // eax\n\n  v3 = (unsigned __int16)a1;\n  v4 = HIWORD(a1);\n  if ( !a2 )\n    return 1;\n  v5 = a2;\n  v6 = v4;\n  while ( a3 )\n  {\n    v7 = a3;\n    if ( a3 > 0x15B0 )\n      v7 = 5552;\n    a3 -= v7;\n    v8 = &v5[v7];\n    do\n    {\n      v3 += *v5++;\n      v6 += v3;\n    }\n    while ( v5 != v8 );\n    v3 %= 0xFFF1u;\n    v6 %= 0xFFF1u;\n  }\n  return v3 | (v6 << 16);\n}\n"
    ],
    "sub_80871E0": [
        "0x80871e0",
        "char *__usercall sub_80871E0@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  char *v2; // eax\n  char *v3; // esi\n\n  v1 = a1;\n  if ( (dword_80DBB9C & 0x20) == 0 )\n    return sub_804DDBF(\"%s.lzo\", a1);\n  v2 = strrchr(a1, 46);\n  v3 = v2;\n  if ( !v2 || strcmp(v2 + 1, \"lzo\") )\n    return sub_804DDBF(\"%s.out\", v1);\n  *v3 = 0;\n  return (char *)v1;\n}\n"
    ],
    "sub_8087232": [
        "0x8087232",
        "unsigned __int32 __usercall sub_8087232@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v2; // [esp+0h] [ebp-4h] BYREF\n\n  v2 = a1;\n  sub_80B24F6(4, &v2);\n  return _byteswap_ulong(v2);\n}\n"
    ],
    "sub_8087248": [
        "0x8087248",
        "int sub_8087248()\n{\n  return ~sub_80AA41E(dword_80DBB98);\n}\n"
    ],
    "sub_8087258": [
        "0x8087258",
        "int __usercall sub_8087258@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>)\n{\n  int result; // eax\n\n  LODWORD(qword_80DB778) = sub_8087180(qword_80DB778, a1, a2);\n  result = sub_8087248();\n  HIDWORD(qword_80DB778) = result;\n  return result;\n}\n"
    ],
    "sub_8087287": [
        "0x8087287",
        "int __usercall sub_8087287@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>)\n{\n  sub_80B24F6(a2, a1);\n  return sub_8087258(a1, a2);\n}\n"
    ],
    "sub_80872A3": [
        "0x80872a3",
        "int __usercall sub_80872A3@<eax>(unsigned int a1@<eax>)\n{\n  char *v1; // edi\n  unsigned __int32 v2; // eax\n  unsigned int v3; // esi\n  unsigned __int32 v4; // eax\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  size_t v7; // ebx\n  unsigned __int8 *v8; // ebx\n  size_t v11; // [esp+4h] [ebp-34h]\n  unsigned int v12; // [esp+8h] [ebp-30h]\n  unsigned __int32 v13; // [esp+Ch] [ebp-2Ch]\n  unsigned __int32 v14; // [esp+10h] [ebp-28h]\n  unsigned int v15; // [esp+14h] [ebp-24h]\n  unsigned __int32 v16; // [esp+18h] [ebp-20h]\n  unsigned int v17[5]; // [esp+24h] [ebp-14h] BYREF\n\n  v1 = 0;\n  v11 = 278595;\n  v15 = 0;\n  v16 = 0;\n  v14 = 1;\n  v13 = 1;\n  v12 = 0x40000;\n  while ( 1 )\n  {\n    v2 = sub_8087232(a1);\n    v3 = v2;\n    if ( !v2 )\n      break;\n    if ( v2 == -1 )\n      sub_804D5E0(\"this file is a split lzop file\");\n    if ( v2 > 0x4000000 || (v4 = sub_8087232(v2), v5 = v4, v3 < v4) || !v4 )\nLABEL_6:\n      sub_804D5E0(\"corrupted data\");\n    if ( v12 < v3 )\n    {\n      if ( v1 )\n        free(v1);\n      v11 = v3 + (v3 >> 4) + 67;\n      v12 = v3;\n      v1 = 0;\n    }\n    if ( (a1 & 1) != 0 )\n      v14 = sub_8087232(a1 & 1);\n    v6 = a1 & 0x100;\n    if ( (a1 & 0x100) != 0 )\n    {\n      v6 = sub_8087232(v6);\n      v15 = v6;\n    }\n    v7 = v11 - v5;\n    if ( v3 <= v5 )\n    {\n      if ( v1 )\n      {\n        v8 = (unsigned __int8 *)&v1[v7];\n        sub_80B24F6(v5, v8);\n        goto LABEL_33;\n      }\nLABEL_23:\n      v1 = (char *)sub_804DB2E(v11);\n      v8 = (unsigned __int8 *)&v1[v7];\n      sub_80B24F6(v5, v8);\n      if ( v3 <= v5 )\n        goto LABEL_33;\n      goto LABEL_24;\n    }\n    if ( (a1 & 2) != 0 )\n      v13 = sub_8087232(v6);\n    if ( (a1 & 0x200) != 0 )\n      v16 = sub_8087232(a1);\n    if ( !v1 )\n      goto LABEL_23;\n    v8 = (unsigned __int8 *)&v1[v7];\n    sub_80B24F6(v5, v8);\nLABEL_24:\n    v17[0] = v3;\n    if ( (dword_80DBB9C & 0x20000) == 0\n      && ((a1 & 2) != 0 && sub_8087180(1u, v8, v5) != v13 || (a1 & 0x200) != 0 && sub_8087248() != v16) )\n    {\nLABEL_27:\n      sub_804D5E0(\"checksum error\");\n    }\n    if ( sub_808EA8F(v8, v5, v1, v17) || v17[0] != v3 )\n      goto LABEL_6;\n    v8 = (unsigned __int8 *)v1;\nLABEL_33:\n    if ( (dword_80DBB9C & 0x20000) == 0\n      && ((a1 & 1) != 0 && v14 != sub_8087180(1u, v8, v3) || (a1 & 0x100) != 0 && v15 != sub_8087248()) )\n    {\n      goto LABEL_27;\n    }\n    sub_804DCAD(v3, (int)v8);\n  }\n  free(v1);\n  return 1;\n}\n"
    ],
    "sub_80874C0": [
        "0x80874c0",
        "int sub_80874C0()\n{\n  unsigned __int16 v0; // ax\n  unsigned __int16 v1; // ax\n  int v2; // eax\n  int v3; // eax\n  int v4; // ebx\n  int v5; // eax\n  unsigned __int32 v6; // ebx\n  int i; // esi\n  int v8; // ebx\n  unsigned int v10; // [esp+0h] [ebp-128h] BYREF\n  unsigned __int8 s1[6]; // [esp+4h] [ebp-124h] BYREF\n  char v12; // [esp+Ah] [ebp-11Eh]\n  char v13; // [esp+Bh] [ebp-11Dh]\n  int v14; // [esp+Ch] [ebp-11Ch]\n  unsigned __int8 v15; // [esp+1Ch] [ebp-10Ch]\n  unsigned __int8 v16[267]; // [esp+1Dh] [ebp-10Bh] BYREF\n\n  sub_80B24F6(9, s1);\n  if ( memcmp(s1, &unk_80D4E1C, 9u) )\n    sub_804D5E0(\"bad magic number\");\n  qword_80DB778 = 1LL;\n  sub_8087287(s1, 0x19u);\n  LOBYTE(v0) = s1[1];\n  HIBYTE(v0) = s1[0];\n  if ( v0 <= 0x93Fu )\n    goto LABEL_32;\n  LOBYTE(v1) = s1[5];\n  HIBYTE(v1) = s1[4];\n  if ( v1 > 0x1010u )\n  {\nLABEL_5:\n    v2 = 16;\n    goto LABEL_38;\n  }\n  if ( v1 <= 0x93Fu )\n    goto LABEL_32;\n  switch ( v12 )\n  {\n    case 0:\n      v2 = 14;\n      goto LABEL_38;\n    case 1:\n      if ( !v13 )\n        v13 = 3;\n      break;\n    case 2:\n      if ( !v13 )\n        v13 = 1;\n      break;\n    case 3:\n      if ( !v13 )\n        v13 = 9;\n      break;\n    default:\n      v2 = -1;\n      goto LABEL_38;\n  }\n  if ( (unsigned __int8)(v13 - 1) > 8u )\n  {\n    v2 = 15;\n    goto LABEL_38;\n  }\n  v3 = _byteswap_ulong(v14);\n  v14 = v3;\n  if ( (v3 & 0x800) != 0 )\n    goto LABEL_5;\n  if ( (v3 & 0xFC000) != 0 )\n  {\n    v2 = -13;\n    goto LABEL_38;\n  }\n  if ( v15 )\n    v3 = sub_8087287(v16, v15);\n  v4 = qword_80DB778;\n  if ( (v14 & 0x1000) != 0 )\n    v4 = HIDWORD(qword_80DB778);\n  if ( sub_8087232(v3) != v4 )\n  {\n    v2 = 2;\nLABEL_38:\n    sub_804D5E0(\"header_error %d\", v2);\n  }\n  if ( (v14 & 0x40) != 0 )\n  {\n    qword_80DB778 = 1LL;\n    v5 = sub_8087287((unsigned __int8 *)&v10, 4u);\n    v6 = _byteswap_ulong(v10);\n    for ( i = 0; i != v6; ++i )\n      v5 = sub_8087287((unsigned __int8 *)&v10, 1u);\n    v8 = qword_80DB778;\n    if ( (v14 & 0x1000) != 0 )\n      v8 = HIDWORD(qword_80DB778);\n    if ( sub_8087232(v5) != v8 )\n    {\nLABEL_32:\n      v2 = 3;\n      goto LABEL_38;\n    }\n  }\n  return sub_80872A3(v14);\n}\n"
    ],
    "sub_808768A": [
        "0x808768a",
        "int __usercall sub_808768A@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _DWORD *a4)\n{\n  _BYTE *v4; // ebp\n  int v5; // ebx\n  unsigned int v6; // ebx\n  _BYTE *v7; // edx\n  int m; // esi\n  _BYTE *v9; // ecx\n  unsigned __int8 *v10; // ebp\n  _BYTE *v11; // edi\n  unsigned __int8 *v12; // eax\n  int v13; // ecx\n  _BYTE *v14; // edx\n  _BYTE *v15; // ecx\n  int v16; // eax\n  _BYTE *v17; // esi\n  char v18; // dl\n  char v19; // al\n  int v20; // ecx\n  _BYTE *v21; // esi\n  int v22; // ebx\n  int j; // ecx\n  int v24; // edx\n  int v25; // ecx\n  int ii; // ebx\n  int v27; // edx\n  int v28; // edx\n  _BYTE *v29; // edx\n  int v30; // ebx\n  unsigned __int8 v31; // al\n  int k; // ecx\n  unsigned int v33; // edi\n  _BYTE *v34; // ecx\n  char v35; // al\n  int i; // edx\n  int v37; // ebx\n  int result; // eax\n  size_t n; // [esp+0h] [ebp-30h]\n  _BYTE *v40; // [esp+4h] [ebp-2Ch]\n  _BYTE *v41; // [esp+8h] [ebp-28h]\n  int v42; // [esp+8h] [ebp-28h]\n  _BYTE *v43; // [esp+Ch] [ebp-24h]\n  int v44; // [esp+Ch] [ebp-24h]\n  unsigned int v46; // [esp+14h] [ebp-1Ch]\n  _BYTE *v47; // [esp+18h] [ebp-18h]\n  unsigned int v48; // [esp+18h] [ebp-18h]\n  unsigned int v49; // [esp+18h] [ebp-18h]\n  unsigned int v50; // [esp+1Ch] [ebp-14h]\n\n  v4 = a1;\n  v46 = (unsigned int)&a1[a2];\n  v50 = (unsigned int)&a3[*a4];\n  *a4 = 0;\n  v5 = *a1;\n  if ( (unsigned __int8)v5 > 0x11u )\n  {\n    v4 = a1 + 1;\n    v6 = v5 - 17;\n    if ( (int)v6 > 3 )\n    {\n      v7 = a3;\n      n = 0;\n      v40 = 0;\n      goto LABEL_7;\n    }\n    v11 = a3;\n    n = 0;\n    v40 = 0;\n    goto LABEL_70;\n  }\n  v11 = a3;\n  n = 0;\n  v40 = 0;\nLABEL_24:\n  if ( (unsigned int)v4 >= v46 || (unsigned int)v11 > v50 )\n  {\nLABEL_90:\n    *a4 = v11 - a3;\n    return -7;\n  }\n  v12 = v4 + 1;\n  v6 = (unsigned __int8)*v4;\n  if ( v6 <= 0xF )\n  {\n    if ( !*v4 )\n    {\n      for ( i = 15; ; i += 255 )\n      {\n        v37 = *v12++;\n        if ( (_BYTE)v37 )\n          break;\n      }\n      v6 = i + v37;\n    }\n    n = v6 + 3;\n    v41 = v12;\n    goto LABEL_6;\n  }\n  while ( 1 )\n  {\nLABEL_27:\n    if ( v6 > 0x3F )\n    {\n      v4 = v12 + 1;\n      v20 = ~((v6 >> 2) & 7) - 8 * *v12;\n      v21 = &v11[v20];\n      v22 = (v6 >> 5) - 1;\n      v44 = v22;\n      if ( !v40 )\n        goto LABEL_63;\n      if ( v22 != 1 )\n        goto LABEL_63;\n      if ( (*(v12 - 1) & 3) != 0 )\n        goto LABEL_63;\n      if ( n <= 3 )\n        goto LABEL_63;\n      v6 = v12[1];\n      if ( (unsigned __int8)(v6 - 1) > 0xEu )\n        goto LABEL_63;\n      v48 = v6 + n;\n      if ( v6 + n + 3 > 0xF )\n        goto LABEL_63;\n      v41 = v12 + 2;\n      sub_8087158(v12 - 1, v21, -v20);\n      n = v48 + 6;\n      *v40 = v48 + 3;\n      *v11 = *v21;\n      v11[1] = v21[1];\n      v11[2] = v21[2];\n      v4 = v40;\n      goto LABEL_62;\n    }\n    if ( v6 <= 0x1F )\n      break;\n    v44 = v6 & 0x1F;\n    if ( (v6 & 0x1F) == 0 )\n    {\n      for ( j = 31; ; j += 255 )\n      {\n        v24 = *v12++;\n        if ( (_BYTE)v24 )\n          break;\n      }\n      v44 = v24 + j;\n    }\n    v4 = v12 + 2;\n    v21 = &v11[~(*v12 >> 2) - (v12[1] << 6)];\nLABEL_49:\n    if ( !v40 || v44 != 1 )\n    {\nLABEL_63:\n      v42 = -1;\nLABEL_64:\n      *v11 = *v21;\n      v29 = v11 + 2;\n      v11[1] = v21[1];\n      v30 = 0;\n      do\n      {\n        v29[v30] = v21[v30 + 2];\n        ++v30;\n      }\n      while ( v44 != v30 );\n      v11 = &v29[v44];\n      while ( 1 )\n      {\n        if ( v42 != -1 )\n          goto LABEL_24;\nLABEL_67:\n        v31 = *(v4 - 2) & 3;\n        v6 = v31;\n        v40 = v4 - 2;\n        n = v31;\n        if ( !v31 )\n        {\n          n = 0;\n          goto LABEL_24;\n        }\nLABEL_70:\n        for ( k = 0; ; ++k )\n        {\n          v11[k] = v4[k];\n          if ( v6 == k + 1 )\n            break;\n        }\n        v43 = &v11[k];\n        v47 = &v4[k];\n        v15 = &v4[v6];\n        v11 += v6;\n        v12 = v47 + 2;\n        v6 = (unsigned __int8)v4[v6];\n        if ( v46 <= (unsigned int)(v47 + 2) || v50 < (unsigned int)v11 )\n          goto LABEL_90;\n        if ( v6 > 0xF )\n          goto LABEL_27;\n        v4 = v15 + 2;\n        v16 = (v6 >> 2) + 4 * (unsigned __int8)v15[1];\n        v17 = &v43[-v16];\n        if ( !v40 )\n          goto LABEL_83;\n        v18 = v6 & 3;\n        if ( n != 1 || v18 )\n          break;\n        if ( v15[2] <= 0xFu )\n          goto LABEL_75;\n        *v40 |= 3u;\n        *v15 = *v17;\n        if ( v16 )\n          v19 = v17[1];\n        else\n          v19 = *v17;\n        v15[1] = v19;\n        v42 = 0;\n        n = 3;\nLABEL_22:\n        v43[1] = *v17;\n        v11 = v43 + 3;\n        v43[2] = v17[1];\n      }\n      if ( !v18 )\n      {\nLABEL_75:\n        v6 = (unsigned __int8)v15[2];\n        if ( (unsigned __int8)(v6 - 1) <= 0xEu )\n        {\n          v33 = v6 + n;\n          if ( v6 + n + 2 <= 0xF )\n          {\n            v41 = v15 + 3;\n            *v40 &= 0xFCu;\n            v34 = v47;\n            v47[2] = *v17;\n            if ( v16 )\n            {\n              v35 = v17[1];\n              v34 = v47;\n            }\n            else\n            {\n              v35 = *v17;\n            }\n            v34[3] = v35;\n            v4 = v40 + 2;\n            if ( n )\n              memmove(v40 + 3, v40 + 2, n);\n            n = v33 + 5;\n            v40[2] = v33 + 2;\n            v43[1] = *v17;\n            v11 = v43 + 3;\n            v43[2] = v17[1];\n            goto LABEL_6;\n          }\n        }\n      }\nLABEL_83:\n      v42 = -1;\n      goto LABEL_22;\n    }\n    if ( !n && (*(v4 - 2) & 3) == 0 && *v4 > 0xFu )\n    {\n      *v40 |= 3u;\n      sub_8087158(v4 - 3, v21, v11 - v21);\n      v42 = 0;\n      n = 3;\n      goto LABEL_64;\n    }\n    if ( n > 3 )\n      goto LABEL_63;\n    if ( (*(v4 - 2) & 3) != 0 )\n      goto LABEL_63;\n    v6 = (unsigned __int8)*v4;\n    if ( (unsigned __int8)(v6 - 1) > 0xEu )\n      goto LABEL_63;\n    v49 = v6 + n;\n    if ( v6 + n + 3 > 0xF )\n      goto LABEL_63;\n    v41 = v4 + 1;\n    *v40 &= 0xFCu;\n    sub_8087158(v4 - 2, v21, v11 - v21);\n    v4 = v40 + 2;\n    if ( n )\n      memmove(v40 + 3, v40 + 2, n);\n    n = v49 + 6;\n    v40[2] = v49 + 3;\n    *v11 = *v21;\n    v11[1] = v21[1];\n    v11[2] = v21[2];\nLABEL_62:\n    v11 += 3;\nLABEL_6:\n    *v11 = *v41;\n    v11[1] = v41[1];\n    v7 = v11 + 3;\n    v11[2] = v41[2];\n    v40 = v4;\n    v4 = v41 + 3;\nLABEL_7:\n    for ( m = 0; ; ++m )\n    {\n      v7[m] = v4[m];\n      if ( v6 == m + 1 )\n        break;\n    }\n    v9 = &v4[m];\n    v10 = &v4[v6];\n    v11 = &v7[v6];\n    v12 = v9 + 2;\n    v6 = *v10;\n    v13 = (unsigned __int8)v9[2];\n    if ( v6 <= 0xF )\n    {\n      v4 = v10 + 2;\n      v14 = &v7[-2048 - (v6 >> 2) - 4 * v13 + m];\n      *v11 = *v14;\n      v11[1] = v14[1];\n      v11[2] = v14[2];\n      v11 += 3;\n      goto LABEL_67;\n    }\n  }\n  v25 = ((_WORD)v6 << 11) & 0x4000;\n  v44 = v6 & 7;\n  if ( (v6 & 7) == 0 )\n  {\n    for ( ii = 7; ; ii += 255 )\n    {\n      v27 = *v12++;\n      if ( (_BYTE)v27 )\n        break;\n    }\n    v44 = v27 + ii;\n  }\n  v4 = v12 + 2;\n  v28 = (*v12 >> 2) + v25 + (v12[1] << 6);\n  if ( v11 != &v11[-v28] )\n  {\n    v21 = &v11[-v28 - 0x4000];\n    goto LABEL_49;\n  }\n  *a4 = v11 - a3;\n  result = 0;\n  if ( (_BYTE *)v46 != v4 )\n    return (unsigned int)v4 < v46 ? -8 : -4;\n  return result;\n}\n"
    ],
    "sub_8087C43": [
        "0x8087c43",
        "int __usercall sub_8087C43@<eax>(int a1@<eax>)\n{\n  char *v1; // ebp\n  size_t v2; // eax\n  ssize_t v3; // eax\n  unsigned int v4; // esi\n  unsigned __int32 v5; // ebx\n  int v6; // edi\n  int v7; // eax\n  int v8; // edi\n  unsigned __int32 *v9; // ebx\n  int v10; // ecx\n  int v11; // edx\n  unsigned __int8 *v13; // [esp+0h] [ebp-48h]\n  void *ptr; // [esp+8h] [ebp-40h]\n  int v16; // [esp+10h] [ebp-38h]\n  int v17; // [esp+14h] [ebp-34h]\n  unsigned int v18; // [esp+18h] [ebp-30h] BYREF\n  unsigned int v19; // [esp+1Ch] [ebp-2Ch] BYREF\n  unsigned __int32 v20; // [esp+20h] [ebp-28h] BYREF\n  unsigned __int32 v21; // [esp+24h] [ebp-24h]\n  unsigned __int32 v22; // [esp+28h] [ebp-20h] BYREF\n  char v23; // [esp+2Ch] [ebp-1Ch] BYREF\n\n  v1 = (char *)sub_804DB2E(0x40000u);\n  v13 = (unsigned __int8 *)sub_804DB2E(0x44043u);\n  if ( *(_BYTE *)(a1 + 6) == 1 )\n    v2 = 0x10000;\n  else\n    v2 = 0x20000;\n  ptr = sub_804DB2E(v2);\n  v17 = 0;\n  v16 = 1;\n  while ( 1 )\n  {\n    v3 = sub_804E5E3(0, v1, 0x40000u);\n    v4 = v3;\n    if ( v3 < 0 )\n      v4 = 0;\n    if ( v3 <= 0 )\n      break;\n    v5 = _byteswap_ulong(v4);\n    v20 = v5;\n    v6 = *(_DWORD *)(a1 + 8);\n    if ( (v6 & 1) != 0 )\n      v16 = sub_8087180(1u, (unsigned __int8 *)v1, v4);\n    if ( (v6 & 0x100) != 0 )\n      v17 = sub_8087248();\n    if ( *(_BYTE *)(a1 + 6) == 1 )\n      v7 = sub_808E648(v1, v4, v13, &v18, ptr);\n    else\n      v7 = sub_808E9D3(v1, v4, v13, &v18, ptr);\n    if ( v7 )\n      sub_804D5E0(\"%s: %s\", \"internal error\", \"compression\");\n    if ( v18 >= v4 )\n    {\n      v21 = v5;\n    }\n    else\n    {\n      if ( *(_BYTE *)(a1 + 6) == 3 )\n      {\n        v19 = v4;\n        if ( sub_808768A(v13, v18, v1, &v19) || v19 != v4 )\n          sub_804D5E0(\"%s: %s\", \"internal error\", \"optimization\");\n      }\n      v21 = _byteswap_ulong(v18);\n    }\n    v8 = *(_DWORD *)(a1 + 8);\n    v9 = &v22;\n    if ( (v8 & 1) != 0 )\n    {\n      v22 = _byteswap_ulong(v16);\n      v9 = (unsigned __int32 *)&v23;\n    }\n    if ( (v8 & 0x100) != 0 )\n      *v9++ = _byteswap_ulong(v17);\n    if ( v18 < v4 )\n    {\n      if ( (v8 & 2) != 0 )\n        *v9++ = _byteswap_ulong(sub_8087180(1u, v13, v18));\n      if ( (v8 & 0x200) != 0 )\n        *v9++ = _byteswap_ulong(sub_8087248());\n    }\n    sub_804DCAD((char *)v9 - (char *)&v20, (int)&v20);\n    v10 = v18;\n    v11 = (int)v13;\n    if ( v18 >= v4 )\n    {\n      v10 = v4;\n      v11 = (int)v1;\n    }\n    sub_804DCAD(v10, v11);\n  }\n  v20 = 0;\n  sub_804DCAD(4, (int)&v20);\n  free(ptr);\n  free(v1);\n  free(v13);\n  return 1;\n}\n"
    ],
    "sub_8087E6C": [
        "0x8087e6c",
        "int sub_8087E6C()\n{\n  char v0; // dl\n  unsigned int v1; // eax\n  unsigned __int32 v3; // [esp+0h] [ebp-128h] BYREF\n  int v4[73]; // [esp+4h] [ebp-124h] BYREF\n\n  memset(v4, 0, 0x11Cu);\n  BYTE2(v4[1]) = 1;\n  v0 = 5;\n  if ( (dword_80DBB9C & 0x80u) != 0 )\n  {\n    BYTE2(v4[1]) = 2;\n    v0 = 1;\n  }\n  if ( (dword_80DBB9C & 0xE000) != 0 )\n    sub_804D5E0(\"high compression not compiled in\");\n  HIBYTE(v4[1]) = v0;\n  v4[0] = 807407632;\n  LOWORD(v4[1]) = 16393;\n  v4[2] = 3;\n  if ( (dword_80DBB9C & 0x20000) == 0 )\n  {\n    v4[2] = 16777219;\n    if ( (dword_80DBB9C & 0x10000) != 0 )\n      v4[2] = 50331651;\n  }\n  sub_804DCAD(9, (int)&unk_80D4E1C);\n  qword_80DB778 = 1LL;\n  sub_804DCAD(25, (int)v4);\n  sub_8087258((unsigned __int8 *)v4, 0x19u);\n  v4[2] = _byteswap_ulong(v4[2]);\n  v1 = qword_80DB778;\n  if ( (v4[2] & 0x1000) != 0 )\n    v1 = HIDWORD(qword_80DB778);\n  v3 = _byteswap_ulong(v1);\n  sub_804DCAD(4, (int)&v3);\n  return sub_8087C43((int)v4);\n}\n"
    ],
    "sub_8087F6C": [
        "0x8087f6c",
        "__int64 sub_8087F6C()\n{\n  __int64 result; // rax\n\n  if ( (dword_80DBB9C & 0x20) != 0 )\n    LODWORD(result) = sub_80874C0();\n  else\n    LODWORD(result) = sub_8087E6C();\n  return (int)result;\n}\n"
    ],
    "sub_8087F89": [
        "0x8087f89",
        "int __cdecl sub_8087F89(int a1, int a2)\n{\n  int *v2; // ebx\n  int v3; // eax\n  char v4; // al\n\n  sub_80ABEAC(a2, \"cfUvqdt123456789CFk\");\n  v2 = (int *)(a2 + 4 * optind);\n  v3 = dword_80DBB9C;\n  dword_80DBB9C ^= 4u;\n  if ( (dword_80DBB9C & 0x40000) != 0 )\n    dword_80DBB9C = v3 | 4;\n  v4 = ident[4];\n  if ( v4 == 99 )\n  {\n    dword_80DBB9C |= 0x21u;\n  }\n  else if ( v4 == 111 )\n  {\n    dword_80DBB9C |= 0x20u;\n  }\n  sub_80AA3E8();\n  return sub_80856FC(v2, sub_8087F6C, (int (*)(void))sub_80871E0, 0);\n}\n"
    ],
    "sub_8087FFB": [
        "0x8087ffb",
        "int __usercall sub_8087FFB@<eax>(int a1@<eax>)\n{\n  FILE *v1; // esi\n  const char *v2; // eax\n  const char *v3; // ebx\n  const char *v4; // eax\n  int v5; // ecx\n  int v7; // [esp+0h] [ebp-10h]\n\n  v7 = a1;\n  while ( v7 )\n  {\n    sub_80AFB01(v7);\n    v1 = (FILE *)sub_80B3D9B();\n    while ( 1 )\n    {\n      v2 = (const char *)sub_80AB85A();\n      v3 = v2;\n      if ( !v2 )\n        break;\n      v4 = sub_804D378(v2, 47);\n      if ( v3 < v4 )\n        *v4 = 0;\n      sub_80AFADF(v5, v3);\n    }\n    fclose(v1);\n  }\n  return 0;\n}\n"
    ],
    "sub_808805F": [
        "0x808805f",
        "int __usercall sub_808805F@<eax>(int *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>)\n{\n  int v6; // ebp\n\n  sub_804E010(\"can't stat tar file\");\n  v6 = 0;\n  while ( a3 )\n  {\n    if ( !sub_80B2549(sub_808859C, a2, sub_808859C, a1, 0) )\n      v6 = 1;\n    a3 = (_DWORD *)*a3;\n  }\n  memset(&qword_80DB778, 0, 0x400u);\n  sub_804DCAD(1024, (int)&qword_80DB778);\n  close(*a1);\n  if ( v6 )\n    sub_804D5F4(\"error exit delayed from previous errors\");\n  return v6;\n}\n"
    ],
    "sub_80880DC": [
        "0x80880dc",
        "unsigned int __usercall sub_80880DC@<eax>(char *a1@<eax>, unsigned int a2@<edx>, __int64 a3)\n{\n  unsigned int result; // eax\n  char *v6; // esi\n  char s[41]; // [esp+3h] [ebp-29h] BYREF\n\n  result = sprintf(s, \"%0*llo\", a2, a3) - a2;\n  v6 = &s[result];\n  if ( s[result] == 48 )\n    ++v6;\n  qmemcpy(a1, v6, a2);\n  return result;\n}\n"
    ],
    "sub_808811A": [
        "0x808811a",
        "void __fastcall sub_808811A(int a1, int a2)\n{\n  int v3; // edx\n  int v4; // esi\n\n  strcpy((char *)(a2 + 257), \"ustar  \");\n  *(_DWORD *)(a2 + 148) = 538976288;\n  *(_DWORD *)(a2 + 152) = 538976288;\n  v3 = 0;\n  v4 = 0;\n  do\n    v4 += *(unsigned __int8 *)(a2 + v3++);\n  while ( v3 != 512 );\n  sub_80880DC((char *)(a2 + 148), 7u, v4);\n  sub_804DCAD(512, a2);\n}\n"
    ],
    "sub_8088184": [
        "0x8088184",
        "void __usercall sub_8088184(char *s@<ecx>, char a2@<dl>, int a3)\n{\n  signed int v3; // ebx\n  int v4; // ecx\n  int v5; // ebx\n  char dest[528]; // [esp+Ch] [ebp-210h] BYREF\n\n  v3 = strlen(s) + a3 + 1;\n  memset(dest, 0, 0x200u);\n  strcpy(dest, \"././@LongLink\");\n  qmemcpy(&dest[100], \"0000000\", 0x30u);\n  sub_80880DC(&dest[124], 0xCu, v3);\n  dest[156] = a2;\n  sub_808811A(v4, (int)dest);\n  sub_804DCAD(v3 - 2 * a3, (int)s);\n  sub_804DCAD(2 * a3, (int)\"/\");\n  v5 = -v3 & 0x1FF;\n  memset(dest, 0, v5);\n  sub_804DCAD(v5, (int)dest);\n}\n"
    ],
    "sub_8088255": [
        "0x8088255",
        "int __usercall sub_8088255@<eax>(_DWORD *a1@<eax>, char *a2@<edx>, const char *a3@<ecx>, int a4)\n{\n  int v6; // eax\n  int v7; // eax\n  int v8; // eax\n  char *v9; // ecx\n  int v10; // edi\n  char *v11; // edi\n  int v12; // eax\n  char *v13; // edi\n  int result; // eax\n  unsigned int v15; // eax\n  unsigned int v16; // eax\n  unsigned __int64 v17; // rax\n  char v18; // bp\n  FILE *v19; // edx\n  const char *v20; // ecx\n  char *v21; // [esp-4h] [ebp-218h]\n  char dest[528]; // [esp+4h] [ebp-210h] BYREF\n\n  memset(dest, 0, 0x200u);\n  strncpy(dest, a2, 0x64u);\n  sub_80880DC(&dest[100], 8u, *(_DWORD *)(a4 + 16) & 0xFFFLL);\n  sub_80880DC(&dest[108], 8u, *(unsigned int *)(a4 + 24));\n  sub_80880DC(&dest[116], 8u, *(unsigned int *)(a4 + 28));\n  memset(&dest[124], 48, 0xBu);\n  v6 = *(_DWORD *)(a4 + 72);\n  if ( v6 < 0 )\n    v6 = 0;\n  sub_80880DC(&dest[136], 0xCu, v6);\n  v7 = sub_80B0E79();\n  sub_80B2C4E(32, v7);\n  v8 = sub_80B0E8A();\n  sub_80B2C4E(32, v8);\n  v10 = a1[4];\n  if ( v10 )\n  {\n    dest[156] = 49;\n    v11 = (char *)(v10 + 20);\n    strncpy(&dest[157], v11, 0x64u);\n    if ( !dest[256] )\n      goto LABEL_30;\n    sub_8088184(v11, 75, 0);\n    goto LABEL_11;\n  }\n  v12 = *(_DWORD *)(a4 + 16) & 0xF000;\n  if ( v12 == 40960 )\n  {\n    v13 = (char *)sub_804E261(a3);\n    result = 0;\n    if ( !v13 )\n      return result;\n    dest[156] = 50;\n    strncpy(&dest[157], v13, 0x64u);\n    if ( dest[256] )\n      sub_8088184(v13, 75, 0);\n    free(v13);\nLABEL_11:\n    v9 = v21;\n    goto LABEL_30;\n  }\n  if ( v12 != 0x4000 )\n  {\n    if ( v12 == 0x2000 )\n    {\n      dest[156] = 51;\n    }\n    else\n    {\n      if ( v12 != 24576 )\n      {\n        if ( v12 == 4096 )\n        {\n          dest[156] = 54;\n        }\n        else\n        {\n          if ( v12 != 0x8000 )\n          {\n            sub_804D5F4(\"%s: unknown file type\", a3);\n            return 0;\n          }\n          v17 = *(_QWORD *)(a4 + 44);\n          if ( HIDWORD(v17) > 0xF )\n          {\n            v9 = &dest[136];\n            do\n            {\n              --v9;\n              v18 = v17;\n              *v9 = v17;\n              v17 >>= 8;\n            }\n            while ( v9 != &dest[124] );\n            dest[124] = v18 | 0x80;\n          }\n          else\n          {\n            sub_80880DC(&dest[124], 0xCu, *(_QWORD *)(a4 + 44));\n          }\n          dest[156] = 48;\n        }\nLABEL_30:\n        if ( !dest[99] )\n          goto LABEL_32;\n        goto LABEL_31;\n      }\n      dest[156] = 52;\n    }\n    v15 = gnu_dev_major(*(_QWORD *)(a4 + 32));\n    sub_80880DC(&dest[329], 8u, v15);\n    v16 = gnu_dev_minor(*(_QWORD *)(a4 + 32));\n    sub_80880DC(&dest[337], 8u, v16);\n    goto LABEL_30;\n  }\n  dest[156] = 53;\n  if ( !dest[99] )\n  {\n    dest[strlen(dest)] = 47;\n    goto LABEL_30;\n  }\nLABEL_31:\n  sub_8088184(a2, 76, (*(_DWORD *)(a4 + 16) & 0xF000) == 0x4000);\nLABEL_32:\n  sub_808811A((int)v9, (int)dest);\n  result = 1;\n  if ( a1[1] )\n  {\n    v19 = stdout;\n    if ( *a1 == 1 )\n      v19 = stderr;\n    v20 = &data;\n    if ( (*(_DWORD *)(a4 + 16) & 0xF000) == 0x4000 )\n      v20 = \"/\";\n    fprintf(v19, \"%s%s\\n\", a2, v20);\n    return 1;\n  }\n  return result;\n}\n"
    ],
    "sub_808859C": [
        "0x808859c",
        "int __userpurge sub_808859C@<eax>(const char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)\n{\n  char *v6; // eax\n  char *v7; // edi\n  int v8; // eax\n  _DWORD *i; // eax\n  size_t v11; // eax\n  void *v12; // eax\n  int v13; // ecx\n  int v14; // ecx\n  int j; // edx\n  const char *v16; // eax\n  int v17; // eax\n  const char *k; // ebp\n  int v19; // eax\n  int v20; // ebp\n  int v21; // edx\n  int v23; // [esp+4h] [ebp-14h]\n  int v24; // [esp+4h] [ebp-14h]\n\n  v6 = (char *)sub_808EFDF();\n  if ( !*v6 )\n    return 1;\n  v7 = v6;\n  v8 = *(_DWORD *)(a2 + 16) & 0xF000;\n  if ( v8 == 49152 )\n  {\n    sub_804D5F4(\"%s: socket ignored\");\n    return 1;\n  }\n  a3[4] = 0;\n  if ( v8 != 0x4000 && *(_DWORD *)(a2 + 20) > 1u )\n  {\n    for ( i = (_DWORD *)a3[3];\n          i\n       && (*(_DWORD *)(a2 + 92) != i[4]\n        || *(_DWORD *)(a2 + 88) != i[3]\n        || *(_DWORD *)(a2 + 4) != i[2]\n        || *(_DWORD *)a2 != i[1]);\n          i = (_DWORD *)*i )\n    {\n      ;\n    }\n    a3[4] = (int)i;\n    if ( !i )\n    {\n      v11 = strlen(v7);\n      v12 = sub_804DAFA(v11 + 24);\n      *(_DWORD *)v12 = a3[3];\n      a3[3] = (int)v12;\n      v13 = *(_DWORD *)(a2 + 4);\n      *((_DWORD *)v12 + 1) = *(_DWORD *)a2;\n      *((_DWORD *)v12 + 2) = v13;\n      v14 = *(_DWORD *)(a2 + 92);\n      *((_DWORD *)v12 + 3) = *(_DWORD *)(a2 + 88);\n      *((_DWORD *)v12 + 4) = v14;\n      strcpy((char *)v12 + 20, v7);\n    }\n  }\n  if ( a3[6] == *(_DWORD *)(a2 + 4)\n    && a3[5] == *(_DWORD *)a2\n    && a3[28] == *(_DWORD *)(a2 + 92)\n    && a3[27] == *(_DWORD *)(a2 + 88) )\n  {\n    sub_804D5F4(\"%s: file is the archive; skipping\");\n    return 1;\n  }\n  for ( j = a3[2]; j; j = *(_DWORD *)j )\n  {\n    v16 = *(const char **)(j + 4);\n    if ( *v16 == 47 )\n    {\n      v23 = j;\n      v17 = fnmatch(v16, v7, 9);\n      j = v23;\n      if ( !v17 )\n        return 2;\n    }\n    else\n    {\n      for ( k = v7; *k; ++k )\n      {\n        if ( (v7 == k || *(k - 1) == 47) && *k != 47 )\n        {\n          v24 = j;\n          v19 = fnmatch(*(const char **)(j + 4), k, 9);\n          j = v24;\n          if ( !v19 )\n            return 2;\n        }\n      }\n    }\n  }\n  if ( a3[4] || (*(_DWORD *)(a2 + 16) & 0xF000) != 0x8000 )\n  {\n    v20 = -1;\n  }\n  else\n  {\n    v20 = sub_804DC14(a1);\n    if ( v20 < 0 )\n      return 0;\n  }\n  if ( sub_8088255(a3, v7, a1, a2) )\n  {\n    if ( v20 != -1 )\n    {\n      sub_804E51A(v20, *a3, *(_QWORD *)(a2 + 44));\n      close(v20);\n      v21 = -*(_DWORD *)(a2 + 44) & 0x1FF;\n      memset(&qword_80DB778, 0, v21);\n      sub_804DCAD(v21, (int)&qword_80DB778);\n    }\n    return 1;\n  }\n  return 0;\n}\n"
    ],
    "sub_8088782": [
        "0x8088782",
        "int __cdecl sub_8088782(int a1, int a2)\n{\n  unsigned int *v2; // ebx\n  const char *v3; // ebp\n  int v4; // esi\n  char *v5; // eax\n  char v6; // dl\n  unsigned int v7; // esi\n  const char **v8; // edi\n  int v9; // eax\n  const char *v10; // eax\n  unsigned int v11; // eax\n  _DWORD *v12; // eax\n  char v13; // dl\n  _DWORD *v14; // ecx\n  const char *v15; // eax\n  int v16; // ecx\n  unsigned int v17; // eax\n  int v18; // ecx\n  int *v19; // eax\n  const char *v21; // [esp+0h] [ebp-20h] BYREF\n  const char *v22; // [esp+4h] [ebp-1Ch] BYREF\n  int v23; // [esp+8h] [ebp-18h] BYREF\n  int v24[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v21 = 0;\n  v22 = \"-\";\n  v23 = 0;\n  v24[0] = 0;\n  v2 = (unsigned int *)sub_808E331();\n  *v2 = 7;\n  if ( getuid() )\n    *v2 |= 0x20u;\n  v3 = *(const char **)(a2 + 4);\n  if ( v3 )\n  {\n    v4 = strcmp(v3, \"--version\");\n    if ( !v4 )\n    {\n      puts(\"tar (busybox) 1.29.2\");\n      return v4;\n    }\n    if ( *v3 && *v3 != 45 )\n    {\n      v5 = strchr(v3, 102);\n      if ( v5 )\n      {\n        while ( 1 )\n        {\n          v6 = v5[1];\n          if ( !v6 )\n            break;\n          *v5++ = v6;\n        }\n        *v5 = 102;\n      }\n      *(_DWORD *)(a2 + 4) = sub_804DDBF((char *)\"-%s\", *(const char **)(a2 + 4));\n    }\n  }\n  v7 = sub_80ABEC2(a2, &unk_80D4F1E, \"list\", &v21, &v22, v2 + 3, v2 + 4, v2 + 13, v2 + 17, v24, &v23, &v23);\n  v8 = (const char **)(a2 + 4 * optind);\n  v9 = v23;\n  if ( v23 )\n  {\n    v2[8] = (unsigned int)sub_808E26D;\n    if ( v9 == 1 )\n      v2[8] = (unsigned int)sub_808E264;\n  }\n  if ( (v7 & 2) != 0 )\n    v2[9] = (unsigned int)sub_8089512;\n  if ( (v7 & 0x10) != 0 )\n    v2[9] = (unsigned int)sub_8089994;\n  if ( (v7 & 0x8000) != 0 )\n  {\n    putenv(\"TAR_FILETYPE=f\");\n    signal(13, (__sighandler_t)1);\n    v2[9] = (unsigned int)sub_8089805;\n    v10 = (const char *)sub_80AB879();\n    v2[18] = (unsigned int)sub_804DB46(v10);\n  }\n  if ( (v7 & 0x100) != 0 )\n    *v2 &= ~4u;\n  if ( (v7 & 0x10000) != 0 )\n    *v2 |= 0x40u;\n  if ( (v7 & 0x20) != 0 )\n    *v2 |= 0x10u;\n  if ( (v7 & 0x20000) != 0 )\n    *v2 |= 0x20u;\n  if ( (v7 & 0x40000) != 0 )\n  {\n    v11 = *v2 & 0xFFFFFFFB;\n    LOBYTE(v11) = *(_BYTE *)v2 & 0x7B | 0x80;\n    *v2 = v11;\n  }\n  v2[4] = sub_8087FFB(v2[4]);\n  v12 = (_DWORD *)v24[0];\n  v13 = 0;\n  while ( v12 )\n  {\n    v14 = (_DWORD *)*v12;\n    *v12 = v2[4];\n    v2[4] = (unsigned int)v12;\n    v13 = 1;\n    v12 = v14;\n  }\n  if ( v13 )\n    v24[0] = 0;\n  v2[3] = sub_8087FFB(v2[3]);\n  while ( *v8 )\n  {\n    v15 = sub_804D378(*v8, 47);\n    if ( *v8 < v15 )\n      *v15 = 0;\n    sub_80AFADF(v16, *v8++);\n  }\n  v17 = v2[3];\n  if ( v17 || v2[4] )\n    v2[2] = (unsigned int)sub_808D827;\n  if ( (v7 & 0x200) != 0 )\n  {\n    if ( !v17 )\n      sub_804D5E0(\"empty archive\");\n    v18 = 1;\n  }\n  else\n  {\n    v18 = 0;\n  }\n  if ( *v22 != 45 || v22[1] )\n  {\n    v2[1] = sub_804DBE1(v22);\n  }\n  else\n  {\n    v2[1] = v18;\n    v2[10] = (unsigned int)sub_808EF81;\n  }\n  if ( v21 )\n    sub_804DF04(v21);\n  if ( (v7 & 0x200) != 0 )\n  {\n    v19 = (int *)sub_804DB2E(0x74u);\n    *v19 = v2[1];\n    v19[1] = v23;\n    v19[2] = v2[4];\n    return sub_808805F(v19, (v7 >> 9) & 2 | ((unsigned __int8)(v7 >> 14) ^ 1) & 1, (_DWORD *)v2[3]);\n  }\n  else\n  {\n    byte_80DBBA4 = 1;\n    while ( !(unsigned __int8)sub_808DCAD() )\n      byte_80DBBA4 = 0;\n    sub_808F0AE();\n    while ( v2[3] )\n    {\n      if ( !sub_808D85A() && !sub_808D85A() )\n        sub_804D5E0(\"%s: not found in archive\", *(const char **)(v2[3] + 4));\n      v2[3] = *(_DWORD *)v2[3];\n    }\n    return byte_80DBBA4;\n  }\n}\n"
    ],
    "sub_8088A8C": [
        "0x8088a8c",
        "int __usercall sub_8088A8C@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n  int v3; // [esp+10h] [ebp-54h]\n\n  result = lstat64();\n  if ( result != -1 )\n    return v3;\n  if ( *(_DWORD *)dword_80DBB7C != 2 )\n    sub_804D3C9((int)\"can't stat '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_8088ABF": [
        "0x8088abf",
        "int __usercall sub_8088ABF@<eax>(const char *a1@<eax>)\n{\n  char *v1; // ebx\n  int v3; // [esp-4h] [ebp-8h]\n\n  v1 = sub_804DB46(a1);\n  dirname(v1);\n  if ( sub_80B00B9(4, -1) )\n    sub_804D604();\n  free(v1);\n  return v3;\n}\n"
    ],
    "sub_8088AED": [
        "0x8088aed",
        "int __usercall sub_8088AED@<eax>(__int64 a1@<edx:eax>)\n{\n  __int64 v1; // kr00_8\n\n  if ( a1 )\n  {\n    v1 = a1;\n    LODWORD(a1) = lseek64();\n    if ( HIDWORD(a1) == -1 )\n    {\n      LODWORD(a1) = a1 + 1;\n      if ( !(_DWORD)a1 )\n        LODWORD(a1) = sub_804E51A(3, -1, v1);\n    }\n  }\n  return a1;\n}\n"
    ],
    "sub_8088B1F": [
        "0x8088b1f",
        "int sub_8088B1F()\n{\n  int result; // eax\n\n  sub_804DD8F();\n  result = fgets_unlocked();\n  if ( !result )\n    sub_804D3C9((int)\"can't read standard input\");\n  return result;\n}\n"
    ],
    "sub_8088B48": [
        "0x8088b48",
        "int __cdecl sub_8088B48(int argc, char **argv)\n{\n  const char *v2; // ebp\n  char *v3; // ebx\n  int v4; // eax\n  int v5; // ecx\n  size_t v6; // eax\n  char *v7; // edi\n  char *i; // esi\n  int v9; // eax\n  const char *v10; // eax\n  __int64 v11; // rax\n  signed int v12; // edi\n  unsigned int v13; // esi\n  char *v14; // ebp\n  unsigned int v15; // edx\n  unsigned int v16; // eax\n  int v17; // edx\n  _BYTE *v18; // ebx\n  int v19; // edi\n  unsigned int v20; // ebp\n  __int16 v21; // si\n  int v22; // ecx\n  unsigned int v23; // eax\n  unsigned int v24; // eax\n  int v25; // ecx\n  int v26; // eax\n  int v27; // eax\n  char *v28; // esi\n  int v29; // edx\n  __int64 v30; // rax\n  unsigned int v31; // eax\n  unsigned int v32; // eax\n  int v34; // [esp+4h] [ebp-E0h]\n  int v35; // [esp+8h] [ebp-DCh]\n  int fd; // [esp+Ch] [ebp-D8h]\n  char v37; // [esp+11h] [ebp-D3h]\n  __int16 v38; // [esp+12h] [ebp-D2h]\n  int v39; // [esp+14h] [ebp-D0h]\n  int v40; // [esp+1Ch] [ebp-C8h]\n  char dest[4]; // [esp+2Ch] [ebp-B8h] BYREF\n  char v42[4]; // [esp+30h] [ebp-B4h]\n  int v43; // [esp+34h] [ebp-B0h] BYREF\n  unsigned __int16 v44; // [esp+38h] [ebp-ACh]\n  unsigned __int16 v45; // [esp+3Ah] [ebp-AAh]\n  unsigned __int16 v46; // [esp+3Ch] [ebp-A8h]\n  __int64 v47; // [esp+3Eh] [ebp-A6h]\n  unsigned int v48; // [esp+46h] [ebp-9Eh]\n  unsigned __int16 v49; // [esp+4Ah] [ebp-9Ah]\n  unsigned __int16 v50; // [esp+4Ch] [ebp-98h]\n  _WORD v51[3]; // [esp+4Eh] [ebp-96h] BYREF\n  char s[4]; // [esp+58h] [ebp-8Ch]\n  __int64 v53; // [esp+5Ch] [ebp-88h]\n  unsigned int v54; // [esp+64h] [ebp-80h]\n  unsigned __int16 v55; // [esp+68h] [ebp-7Ch]\n  unsigned __int16 v56; // [esp+6Ah] [ebp-7Ah]\n  __int64 v57; // [esp+6Ch] [ebp-78h]\n  __int64 v58; // [esp+74h] [ebp-70h]\n  int v59; // [esp+7Ch] [ebp-68h]\n  char v60[96]; // [esp+84h] [ebp-60h] BYREF\n\n  v2 = 0;\n  v3 = 0;\n  v34 = -1;\n  v37 = 0;\n  v38 = 0;\n  v35 = 0;\n  while ( 1 )\n  {\n    v4 = getopt(argc, argv, \"-d:lnopqxjv\");\n    if ( v4 == -1 )\n      break;\n    if ( v4 == 110 )\n    {\n      v37 = 1;\n    }\n    else if ( v4 > 110 )\n    {\n      if ( v4 == 113 )\n        goto LABEL_20;\n      if ( v4 > 113 )\n      {\n        if ( v4 == 118 )\n        {\n          ++HIBYTE(v38);\n          goto LABEL_22;\n        }\n        if ( v4 != 120 )\n          goto LABEL_30;\n        v35 |= 2u;\n      }\n      else if ( v4 == 111 )\n      {\n        v37 = 2;\n      }\n      else\n      {\n        v34 = 1;\nLABEL_20:\n        LOBYTE(v38) = v38 + 1;\n      }\n    }\n    else if ( v4 == 100 )\n    {\n      v2 = optarg;\n    }\n    else if ( v4 > 100 )\n    {\n      if ( v4 == 106 )\n      {\n        v35 |= 4u;\n      }\n      else\n      {\n        if ( v4 != 108 )\n          goto LABEL_30;\nLABEL_22:\n        v35 |= 1u;\n      }\n    }\n    else\n    {\n      if ( v4 != 1 )\n        goto LABEL_30;\n      if ( v3 )\n      {\n        sub_80AFAC3(v5, optarg);\n      }\n      else\n      {\n        v6 = strlen(optarg);\n        v3 = (char *)sub_804DAFA(v6 + 5);\n        strcpy(v3, optarg);\n      }\n    }\n  }\n  if ( !v3 )\nLABEL_30:\n    sub_804CDC2();\n  if ( *v3 != 45 || v3[1] )\n  {\n    v7 = &v3[strlen(v3)];\n    for ( i = \".zip\"; ; i += 5 )\n    {\n      v9 = open64();\n      if ( v9 >= 0 )\n        break;\n      if ( \"can't remove old file %s\" == i )\n      {\n        *v7 = 0;\n        sub_804D5E0(\"can't open %s[.zip]\", v3);\n      }\n      strcpy(v7, i);\n    }\n    sub_804DC97(v9, 3);\n  }\n  else\n  {\n    sub_804DC7B(0, 3);\n    if ( !v37 )\n      v37 = 1;\n  }\n  if ( v2 )\n    sub_804DF04(v2);\n  if ( (char)v38 <= 1 )\n  {\n    if ( !(_BYTE)v38 )\n      printf(\"Archive:  %s\\n\", v3);\n    if ( (v35 & 1) != 0 )\n    {\n      v10 = \"  Length      Date    Time    Name\\n---------  ---------- -----   ----\";\n      if ( HIBYTE(v38) )\n        v10 = \" Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\\n\"\n              \"--------  ------  ------- ---- ---------- ----- --------  ----\";\n      puts(v10);\n    }\n  }\n  LODWORD(v11) = lseek64();\n  if ( HIDWORD(v11) != -1 || (fd = -1, (_DWORD)v11 != -1) )\n  {\n    v12 = (unsigned __int64)(v11 - 0x10000) >> 32;\n    v13 = v11 - 0x10000;\n    if ( v12 < 0 )\n    {\n      v13 = 0;\n      v12 = 0;\n    }\n    sub_804DD09(v12, v13, 0);\n    v14 = (char *)sub_804DB2E(0x10000u);\n    sub_804E5E3(3, v14, 0x10000u);\n    v15 = (unsigned int)v14;\n    fd = -1;\n    while ( v15 <= (unsigned int)(v14 + 65516) )\n    {\n      v16 = v15 + 1;\n      if ( *(_BYTE *)v15 == 80 && *(_BYTE *)(v15 + 1) == 75 )\n      {\n        v16 = v15 + 2;\n        if ( *(_BYTE *)(v15 + 2) == 5 )\n        {\n          v16 = v15 + 3;\n          if ( *(_BYTE *)(v15 + 3) == 6 )\n          {\n            v17 = *(_DWORD *)(v15 + 16);\n            if ( (unsigned int)v17 < (__int64)(__PAIR64__(v12, v13) + (int)(v16 - (_DWORD)v14)) )\n              fd = v17;\n          }\n        }\n      }\n      v15 = v16;\n    }\n    free(v14);\n  }\n  v18 = 0;\n  v40 = 0;\n  v19 = 0;\n  v20 = 0;\nLABEL_65:\n  if ( fd == -1 )\n  {\n    while ( 1 )\n    {\n      sub_80B24F6(4, &v51[1]);\n      if ( *(_DWORD *)&v51[1] == 33639248 )\n        goto LABEL_162;\n      if ( *(_DWORD *)&v51[1] != 134695760 )\n        break;\n      sub_8088AED(12LL);\n    }\n    if ( *(_DWORD *)&v51[1] != 67324752 )\n      sub_804D5E0(\"invalid zip magic %08X\", *(_DWORD *)&v51[1]);\n    sub_80B24F6(26, &v43);\n    if ( (v43 & 0x80000) != 0 )\n      sub_804D5E0(\"zip flag %s is not supported\", \"8 (streaming)\");\nLABEL_79:\n    v21 = 438;\n    v39 = 511;\n    goto LABEL_80;\n  }\n  sub_804DD09(0, fd, 0);\n  sub_80B24F6(4, &v43);\n  if ( v43 != 101010256 )\n  {\n    sub_80B24F6(42, &v51[1]);\n    fd += (unsigned __int16)v57 + v55 + v56 + 46;\n    if ( fd )\n    {\n      sub_804DD09(0, *(_DWORD *)((char *)&v58 + 2) + 4, 0);\n      sub_80B24F6(26, &v43);\n      if ( (v43 & 0x80000) != 0 )\n      {\n        v47 = v53;\n        v48 = v54;\n      }\n      if ( HIBYTE(v51[1]) != 3 )\n        goto LABEL_79;\n      v39 = (unsigned __int16)v58;\n      v21 = v58;\nLABEL_80:\n      if ( (v43 & 0x10000) != 0 )\n        sub_804D5E0(\"zip flag %s is not supported\", \"1 (encryption)\");\n      free(v18);\n      if ( v49 > 0xFFFu )\n        goto LABEL_83;\n      v18 = sub_804DB2E(v49 + 1);\n      sub_80B24F6(v49, v18);\n      sub_8088AED(v50);\n      sub_808EFDF();\n      sub_80B2C69(v22);\n      if ( sub_808D85A() )\n        goto LABEL_159;\n      if ( (v35 & 1) != 0 )\n      {\n        sprintf(\n          (char *)&v51[1],\n          \"%02u-%02u-%04u %02u:%02u\",\n          (v46 >> 5) & 0xF,\n          v46 & 0x1F,\n          (v46 >> 9) + 1980,\n          v45 >> 11,\n          (v45 >> 5) & 0x3F);\n        if ( HIBYTE(v38) )\n        {\n          sprintf(&dest[1], \"%6u\", v44);\n          if ( v44 )\n          {\n            if ( v44 == 8 )\n            {\n              strcpy(&dest[1], \"Defl:N\");\n              v42[2] = byte_80D5375[(HIWORD(v43) >> 1) & 3];\n            }\n          }\n          else\n          {\n            strcpy(&dest[1], \"Stored\");\n          }\n          v23 = v48 - HIDWORD(v47);\n          if ( (int)(v48 - HIDWORD(v47)) < 0 )\n            v23 = 0;\n          v24 = 100 * v23;\n          if ( v48 )\n            v24 /= v48;\n          printf(\n            \"%8u  %s%9u%4u%% %s %08x  %s\\n\",\n            v48,\n            &dest[1],\n            HIDWORD(v47),\n            v24,\n            (const char *)&v51[1],\n            (_DWORD)v47,\n            v18);\n          v19 += HIDWORD(v47);\n        }\n        else\n        {\n          printf(\"%9u  %s   %s\\n\", v48, (const char *)&v51[1], v18);\n        }\n        v20 += v48;\nLABEL_159:\n        sub_8088AED(HIDWORD(v47));\n        goto LABEL_161;\n      }\n      if ( v34 == 1 )\n      {\n        if ( !(_BYTE)v38 )\n          goto LABEL_131;\nLABEL_132:\n        if ( (v21 & 0xF000) != 40960 )\n          goto LABEL_138;\n        if ( v34 == 1 )\n          goto LABEL_161;\nLABEL_134:\n        if ( v48 <= 0xFFF )\n        {\n          if ( v44 )\n            sub_804D5E0(\"compressed symlink is not supported\");\n          v28 = (char *)sub_804DB2E(v48 + 1);\n          sub_80B24F6(v48, v28);\n          sub_808F044(v18, v28, 0);\n          free(v28);\n          goto LABEL_161;\n        }\nLABEL_83:\n        sub_804D5E0(\"bad archive\");\n      }\n      if ( (v35 & 4) != 0 )\n      {\n        sub_804D315(v18);\n        sub_80B2C69(v25);\n      }\n      if ( !*v18 )\n        goto LABEL_159;\n      if ( sub_804D378(v18, 47) )\n      {\n        v26 = sub_8088A8C(v18);\n        if ( v26 == -1 )\n        {\n          if ( !(_BYTE)v38 )\n            printf(\"   creating: %s\\n\", v18);\n          sub_8088ABF(v18);\n          if ( sub_80B00B9(0x80000000, v39) )\n            sub_804D604();\n        }\n        else if ( (v26 & 0xF000) != 0x4000 )\n        {\n          sub_804D5E0(\"'%s' exists but is not a %s\", v18, \"directory\");\n        }\n        goto LABEL_159;\n      }\n      while ( 1 )\n      {\n        v27 = sub_8088A8C(v18);\n        if ( v27 == -1 )\n          goto LABEL_127;\n        if ( v37 == 1 )\n          goto LABEL_159;\n        if ( (v27 & 0xF000) != 0x8000 )\n          goto LABEL_120;\n        if ( v37 == 2 )\n          goto LABEL_127;\n        printf(\"replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: \", v18);\n        sub_8088B1F();\n        if ( (sub_8088A8C(v18) & 0xF000) != 0x8000 )\nLABEL_120:\n          sub_804D5E0(\"'%s' exists but is not a %s\", v18, \"regular file\");\n        if ( v60[0] == 110 )\n          goto LABEL_159;\n        if ( v60[0] <= 0x6Eu )\n        {\n          if ( v60[0] == 65 )\n          {\n            v37 = 2;\nLABEL_127:\n            sub_8088ABF(v18);\n            if ( (v21 & 0xF000) == 40960 )\n            {\n              v34 = -1;\n              if ( !(_BYTE)v38 )\n              {\nLABEL_131:\n                printf(\"  inflating: %s\\n\", v18);\n                goto LABEL_132;\n              }\n              goto LABEL_134;\n            }\n            v34 = sub_804DBC2(v18);\n            if ( !(_BYTE)v38 )\n              goto LABEL_131;\nLABEL_138:\n            if ( !v44 )\n            {\n              if ( v48 )\n                sub_804E51A(3, v34, v48);\n              goto LABEL_157;\n            }\n            sub_808EE43();\n            v58 = HIDWORD(v47);\n            *(_DWORD *)s = 3;\n            LODWORD(v53) = v34;\n            if ( v44 == 8 )\n            {\n              sub_808B30F();\n              if ( v29 < 0 )\n                goto LABEL_143;\n              if ( (_DWORD)v47 != ~v59 )\n                sub_804D5E0(\"crc error\");\n            }\n            else\n            {\n              switch ( v44 )\n              {\n                case 0xCu:\n                  LODWORD(v30) = sub_808A1F9();\n                  break;\n                case 0xEu:\n                  v30 = sub_808B67C();\n                  break;\n                case 0x5Fu:\n                  LODWORD(v30) = sub_808CF10();\n                  break;\n                default:\n                  sub_804D5E0(\"unsupported method %u\", v44);\n              }\n              v57 = v30;\n              if ( v30 < 0 )\nLABEL_143:\n                sub_804D5E0(\"inflate error\");\n            }\n            if ( v57 != v48 )\n              sub_804D5F4(\"bad length\");\nLABEL_157:\n            if ( v34 != 1 )\n              close(v34);\nLABEL_161:\n            ++v40;\n            goto LABEL_65;\n          }\n          if ( v60[0] == 78 )\n          {\n            v37 = 1;\n            goto LABEL_159;\n          }\n        }\n        else\n        {\n          if ( v60[0] == 114 )\n          {\n            printf(\"new name: \");\n            sub_8088B1F();\n            free(v18);\n            v18 = sub_804DB46(v60);\n            sub_80A9BE3();\n            continue;\n          }\n          if ( v60[0] == 121 )\n            goto LABEL_127;\n        }\n        printf(\"error: invalid response [%c]\\n\", (unsigned __int8)v60[0]);\n      }\n    }\n  }\nLABEL_162:\n  sub_808F0AE();\n  if ( (char)v38 <= 1 && (v35 & 1) != 0 )\n  {\n    if ( HIBYTE(v38) )\n    {\n      v31 = v20 - v19;\n      if ( (int)(v20 - v19) < 0 )\n        v31 = 0;\n      v32 = 100 * v31;\n      if ( v20 )\n        v32 /= v20;\n      printf(\"--------          ------- ----%28s----\\n%8lu%17lu%4u%%%28s%u files\\n\", &data, v20, v19, v32, &data, v40);\n    }\n    else\n    {\n      printf(\" --------%21s-------\\n%9lu%21s%u files\\n\", &data, v20, &data, v40);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8089512": [
        "0x8089512",
        "int __usercall sub_8089512@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  char *v3; // ebp\n  char *v4; // ebx\n  bool i; // zf\n  char *v6; // eax\n  char *v7; // edx\n  struct timeval *p_tvp; // ecx\n  char *v9; // eax\n  char *v10; // eax\n  __mode_t v11; // ecx\n  int result; // eax\n  bool v13; // zf\n  int v14; // eax\n  unsigned int v15; // eax\n  int v16; // ebp\n  char *v17; // [esp-8h] [ebp-7Ch]\n  struct timeval *v18; // [esp-8h] [ebp-7Ch]\n  struct timeval *v19; // [esp-8h] [ebp-7Ch]\n  int v20; // [esp-8h] [ebp-7Ch]\n  struct timeval *v21; // [esp-4h] [ebp-78h]\n  int v22; // [esp+0h] [ebp-74h]\n  char *v23; // [esp+0h] [ebp-74h]\n  struct timeval tvp; // [esp+4h] [ebp-70h] BYREF\n  __time_t tv_sec; // [esp+Ch] [ebp-68h]\n  int v26; // [esp+10h] [ebp-64h]\n  int v27; // [esp+4Ch] [ebp-28h]\n\n  v2 = *(_DWORD *)(a1 + 24);\n  v3 = 0;\n  if ( (*(_DWORD *)(v2 + 24) & 0xF000) == 0x8000 && !*(_QWORD *)(v2 + 8) )\n    v3 = *(char **)(v2 + 4);\n  v4 = *(char **)v2;\n  v22 = *(_DWORD *)(a1 + 52);\n  for ( i = v22 == 0; !i; i = v22-- == 1 )\n  {\n    v6 = strchr(v4, 47);\n    v7 = v17;\n    p_tvp = v21;\n    if ( !v6 || !v6[1] )\n      return sub_80899AD(p_tvp, v7);\n    v4 = v6 + 1;\n    if ( v3 )\n    {\n      v9 = strchr(v3, 47);\n      p_tvp = v18;\n      if ( !v9 || !v9[1] )\n        return sub_80899AD(p_tvp, v7);\n      v3 = v9 + 1;\n    }\n  }\n  if ( (*(_BYTE *)a1 & 2) != 0 )\n  {\n    v10 = strrchr(v4, 47);\n    v23 = v10;\n    if ( v10 )\n    {\n      *v10 = 0;\n      sub_80B00B9(4, -1);\n      *v23 = 47;\n    }\n  }\n  if ( (*(_DWORD *)a1 & 4) != 0 )\n  {\n    v11 = *(_DWORD *)(v2 + 24);\n    if ( (v11 & 0xF000) == 0x4000 )\n    {\n      if ( v3 )\n        return sub_808F044(v4, v3, 1);\n      goto LABEL_47;\n    }\n    if ( v3 )\n    {\n      result = strcmp(v3, v4);\n      if ( !result )\n        return result;\n    }\n    if ( unlink(v4) == -1 )\n    {\n      v13 = *(_DWORD *)dword_80DBB7C == 2;\nLABEL_32:\n      if ( !v13 )\n        sub_804D3C9((int)\"can't remove old file %s\", v4);\n    }\nLABEL_34:\n    if ( v3 )\n      return sub_808F044(v4, v3, 1);\n    v11 = *(_DWORD *)(v2 + 24);\n    v15 = v11 & 0xF000;\n    if ( v15 != 24576 )\n    {\n      if ( v15 > 0x6000 )\n      {\n        if ( v15 == 40960 )\n        {\n          sub_808F044(v4, *(char **)(v2 + 4), 0);\nLABEL_54:\n          result = *(_DWORD *)(v2 + 24) & 0xF000;\n          if ( result != 40960 )\n          {\n            if ( (*(_BYTE *)a1 & 0x10) == 0 )\n              result = chown(v4, *(_DWORD *)(v2 + 16), *(_DWORD *)(v2 + 20));\n            if ( (*(_BYTE *)a1 & 0x20) == 0 )\n              result = chmod(v4, *(_DWORD *)(v2 + 24));\n            if ( (*(_BYTE *)a1 & 1) != 0 )\n            {\n              tvp.tv_sec = *(_DWORD *)(v2 + 28);\n              tv_sec = tvp.tv_sec;\n              tvp.tv_usec = 0;\n              v26 = 0;\n              utimes(v4, &tvp);\n              return v20;\n            }\n          }\n          return result;\n        }\n        if ( v15 != 49152 )\n        {\n          if ( v15 != 0x8000 )\n            goto LABEL_53;\n          v16 = sub_804DBC2(v4);\n          sub_804E51A(*(_DWORD *)(a1 + 4), v16, *(_QWORD *)(v2 + 8));\n          close(v16);\n          goto LABEL_54;\n        }\n      }\n      else if ( v15 != 0x2000 )\n      {\n        if ( v15 != 0x4000 )\n        {\n          if ( v15 != 4096 )\nLABEL_53:\n            sub_804D5E0(\"unrecognized file type\");\n          goto LABEL_51;\n        }\nLABEL_47:\n        if ( mkdir(v4, v11) && (*(_DWORD *)dword_80DBB7C & 0xFFFFFFFB) != 17 )\n          sub_804D3A5((int)\"can't make dir %s\", v4);\n        goto LABEL_54;\n      }\n    }\nLABEL_51:\n    if ( mknod(v4, v11, *(_QWORD *)(v2 + 32)) )\n      sub_804D3A5(135049007, v4);\n    goto LABEL_54;\n  }\n  if ( (*(_DWORD *)a1 & 8) == 0 )\n    goto LABEL_34;\n  v14 = lstat64();\n  v7 = v4;\n  p_tvp = &tvp;\n  if ( v14 == -1 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n      sub_804D3C9((int)\"can't stat old file\");\n    goto LABEL_34;\n  }\n  if ( v27 < *(_DWORD *)(v2 + 28) )\n  {\n    if ( unlink(v4) != -1 )\n      goto LABEL_34;\n    v13 = *(_DWORD *)dword_80DBB7C == 21;\n    goto LABEL_32;\n  }\n  if ( (*(_DWORD *)(v2 + 24) & 0xF000) != 0x4000 )\n  {\n    sub_804D5F4(\"%s not created: newer or same age file exists\", v4);\n    p_tvp = v19;\n  }\n  return sub_80899AD(p_tvp, v7);\n}\n"
    ],
    "sub_80897F4": [
        "0x80897f4",
        "int __usercall sub_80897F4@<eax>(char *a1@<eax>)\n{\n  int result; // eax\n  int v2; // ecx\n  int v3; // [esp-4h] [ebp-4h]\n\n  result = putenv(a1);\n  if ( result )\n    sub_804DAC9(v2, v3);\n  return result;\n}\n"
    ],
    "sub_8089805": [
        "0x8089805",
        "unsigned int __usercall sub_8089805@<eax>(unsigned int result@<eax>)\n{\n  const char **v1; // esi\n  unsigned int v2; // ebx\n  __pid_t v3; // ebp\n  char *v4; // eax\n  char *v5; // eax\n  char *v6; // eax\n  char *v7; // eax\n  char *v8; // eax\n  char *v9; // eax\n  int v10; // ecx\n  unsigned __int16 v11; // ax\n  int v12; // ecx\n  int v13; // [esp+0h] [ebp-30h] BYREF\n  int fd; // [esp+4h] [ebp-2Ch]\n  char v15[24]; // [esp+8h] [ebp-28h] BYREF\n\n  v1 = *(const char ***)(result + 24);\n  if ( ((unsigned int)v1[6] & 0xF000) == 0x8000 )\n  {\n    v2 = result;\n    memset(v15, 0, sizeof(v15));\n    sub_804DC65(&v13);\n    v3 = sub_804E17C();\n    if ( !v3 )\n    {\n      v4 = sub_804DDBF(\"TAR_%s=%lo\", \"MODE\", v1[6]);\n      sub_80897F4(v4);\n      v5 = sub_804DDBF(\"TAR_%s=%s\", \"FILENAME\", *v1);\n      sub_80897F4(v5);\n      v6 = sub_804DDBF(\"TAR_%s=%s\", \"REALNAME\", *v1);\n      sub_80897F4(v6);\n      v7 = sub_804DDBF(\"TAR_%s=%llu\", \"SIZE\", *((_QWORD *)v1 + 1));\n      sub_80897F4(v7);\n      v8 = sub_804DDBF(\"TAR_%s=%llu\", \"UID\", (unsigned __int64)(unsigned int)v1[4]);\n      sub_80897F4(v8);\n      v9 = sub_804DDBF(\"TAR_%s=%llu\", \"GID\", (unsigned __int64)(unsigned int)v1[5]);\n      sub_80897F4(v9);\n      close(fd);\n      sub_804DC7B(v13, 0);\n      signal(13, 0);\n      execl(*(const char **)(v2 + 72), *(const char **)(v2 + 72), \"-c\", *(_DWORD *)(v2 + 68), 0);\n      sub_804D3C9((int)\"can't execute '%s'\", *(const char **)(v2 + 72));\n    }\n    close(v13);\n    sub_804E51A(*(_DWORD *)(v2 + 4), fd, -*((_QWORD *)v1 + 1));\n    close(fd);\n    v11 = sub_804DAAC(v3, v10);\n    v12 = v11 & 0x7F;\n    if ( (v11 & 0x7F) == 0 && HIBYTE(v11) )\n      sub_804D5E0(\"'%s' returned status %d\", *(_DWORD *)(v2 + 68), HIBYTE(v11));\n    result = v11 - 1;\n    if ( result <= 0xFE )\n      sub_804D5E0(\"'%s' terminated by signal %d\", *(_DWORD *)(v2 + 68), v12);\n  }\n  return result;\n}\n"
    ],
    "sub_8089994": [
        "0x8089994",
        "__int64 __usercall sub_8089994@<edx:eax>(int a1@<eax>)\n{\n  return sub_804E51A(*(_DWORD *)(a1 + 4), 1, *(_QWORD *)(*(_DWORD *)(a1 + 24) + 8));\n}\n"
    ],
    "sub_80899AD": [
        "0x80899ad",
        "int __usercall sub_80899AD@<eax>(int a1@<eax>)\n{\n  return (*(int (__fastcall **)(_DWORD, _DWORD))(a1 + 40))(\n           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 12),\n           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8));\n}\n"
    ],
    "sub_80899C1": [
        "0x80899c1",
        "int __usercall sub_80899C1@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // esi\n  ssize_t v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // eax\n  int v9; // esi\n  int v11; // [esp+0h] [ebp-14h]\n\n  v4 = *(_DWORD *)a1;\n  v11 = 0;\n  while ( a2 > v4 )\n  {\n    if ( *(_DWORD *)(a1 + 20) == *(_DWORD *)(a1 + 16) )\n    {\n      v5 = read(*(_DWORD *)(a1 + 8), *(void **)(a1 + 24), 0x1000u);\n      *(_DWORD *)(a1 + 16) = v5;\n      if ( v5 <= 0 )\n        longjmp(*(struct __jmp_buf_tag **)(a1 + 68), -3);\n      *(_DWORD *)(a1 + 20) = 0;\n    }\n    v6 = *(_DWORD *)(a1 + 4);\n    if ( v4 > 23 )\n    {\n      a2 -= v4;\n      v11 = (v6 & ~(-1 << v4)) << a2;\n      v4 = 0;\n    }\n    v7 = *(_DWORD *)(a1 + 24);\n    v8 = *(_DWORD *)(a1 + 20);\n    *(_DWORD *)(a1 + 20) = v8 + 1;\n    *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v7 + v8) | (v6 << 8);\n    v4 += 8;\n  }\n  v9 = v4 - a2;\n  *(_DWORD *)a1 = v9;\n  return v11 | ((1 << a2) - 1) & (*(_DWORD *)(a1 + 4) >> v9);\n}\n"
    ],
    "sub_8089A66": [
        "0x8089a66",
        "int __usercall sub_8089A66@<eax>(int *a1@<eax>)\n{\n  int v2; // esi\n  int v3; // edi\n  int v4; // edx\n  int v5; // eax\n  __int16 v6; // di\n  int i; // esi\n  __int16 v8; // ax\n  int j; // eax\n  int v10; // edi\n  int v11; // esi\n  char v12; // al\n  _DWORD *v13; // esi\n  unsigned int v14; // edi\n  int v15; // ebp\n  int v16; // eax\n  _BYTE *v17; // edx\n  int v18; // eax\n  int v19; // ecx\n  int v20; // edx\n  int v21; // edi\n  int v22; // ecx\n  int v23; // edx\n  int v24; // edi\n  int v25; // edx\n  int v26; // edx\n  int k; // eax\n  unsigned int v28; // esi\n  unsigned int v29; // ebp\n  int v30; // eax\n  int v31; // eax\n  int v32; // edx\n  int v33; // ecx\n  int v34; // ecx\n  int v35; // eax\n  int v36; // edx\n  int m; // edi\n  int v38; // ecx\n  unsigned int v39; // eax\n  unsigned int v40; // ecx\n  int v41; // eax\n  int v42; // eax\n  unsigned int v43; // ecx\n  int v44; // eax\n  int v45; // edx\n  int n; // eax\n  int v47; // ecx\n  unsigned int ii; // eax\n  int v49; // ecx\n  int v50; // edx\n  unsigned int v51; // edx\n  signed int v53; // [esp+0h] [ebp-6A0h]\n  int v54; // [esp+4h] [ebp-69Ch]\n  int v55; // [esp+4h] [ebp-69Ch]\n  int v56; // [esp+8h] [ebp-698h]\n  unsigned int v57; // [esp+Ch] [ebp-694h]\n  int v58; // [esp+10h] [ebp-690h]\n  int v59; // [esp+10h] [ebp-690h]\n  int v60; // [esp+14h] [ebp-68Ch]\n  int v61; // [esp+14h] [ebp-68Ch]\n  int v62; // [esp+18h] [ebp-688h]\n  int v63; // [esp+1Ch] [ebp-684h]\n  unsigned int v64; // [esp+1Ch] [ebp-684h]\n  unsigned int v65; // [esp+20h] [ebp-680h]\n  int v66; // [esp+24h] [ebp-67Ch]\n  _DWORD *v67; // [esp+28h] [ebp-678h]\n  _DWORD *v68; // [esp+2Ch] [ebp-674h]\n  int v69; // [esp+2Ch] [ebp-674h]\n  int v70; // [esp+30h] [ebp-670h]\n  int v71; // [esp+34h] [ebp-66Ch]\n  int v72[85]; // [esp+3Ch] [ebp-664h]\n  char v73[256]; // [esp+190h] [ebp-510h]\n  _BYTE v74[1040]; // [esp+290h] [ebp-410h] BYREF\n\n  v56 = a1[15];\n  v67 = a1 + 274;\n  v2 = sub_80899C1((int)a1, 24);\n  v3 = sub_80899C1((int)a1, 24);\n  a1[12] = sub_80899C1((int)a1, 32);\n  if ( v2 == 1536581 )\n    return (v3 == 3690640) - 2;\n  if ( v3 != 2511705 || v2 != 3227993 )\n    return -2;\n  v5 = sub_80899C1((int)a1, 1);\n  v4 = -7;\n  if ( !v5 )\n  {\n    v65 = sub_80899C1((int)a1, 24);\n    if ( a1[16] < v65 )\n      return -5;\n    v6 = sub_80899C1((int)a1, 16);\n    v53 = 0;\n    for ( i = 0; i <= 255; i += 16 )\n    {\n      if ( (v6 & 0x8000) != 0 )\n      {\n        v8 = sub_80899C1((int)a1, 16);\n        while ( 1 )\n        {\n          if ( (v8 & 0x8000) != 0 )\n            *((_BYTE *)&v72[21] + v53++) = i;\n          v8 *= 2;\n          if ( (((_BYTE)i + 1) & 0xF) == 0 )\n            break;\n          ++i;\n        }\n        i -= 15;\n      }\n      v6 *= 2;\n    }\n    v58 = sub_80899C1((int)a1, 3);\n    if ( (unsigned int)(v58 - 2) > 4 )\n      return -5;\n    for ( j = 0; j != v58; ++j )\n      v73[j] = j;\n    v66 = sub_80899C1((int)a1, 15);\n    v10 = 0;\n    if ( !v66 )\n      return -5;\n    while ( v10 < v66 )\n    {\n      v11 = 0;\n      while ( sub_80899C1((int)a1, 1) )\n      {\n        if ( v11 == v58 )\n          return -5;\n        ++v11;\n      }\n      v12 = v73[v11];\n      while ( --v11 != -1 )\n        v73[v11 + 1] = v73[v11];\n      *((_BYTE *)v67 + v10) = v12;\n      v73[0] = v12;\n      ++v10;\n    }\n    v63 = v53 + 2;\n    v13 = a1 + 8465;\n    v62 = 0;\nLABEL_32:\n    if ( v62 != v58 )\n    {\n      v14 = sub_80899C1((int)a1, 5) - 1;\n      v15 = 1;\n      while ( v14 <= 0x13 )\n      {\n        v16 = sub_80899C1((int)a1, 2);\n        if ( v16 > 1 )\n        {\n          v14 = v14 + (((_BYTE)v16 + 1) & 2) - 1;\n        }\n        else\n        {\n          ++*a1;\n          v73[v15++ + 255] = v14 + 1;\n          if ( v53 + 3 == v15 )\n          {\n            v54 = v74[0];\n            v17 = v74;\n            v18 = v74[0];\n            do\n            {\n              v19 = (unsigned __int8)v17[1];\n              if ( v19 > v18 )\n              {\n                v18 = (unsigned __int8)v17[1];\n              }\n              else if ( v54 > v19 )\n              {\n                v54 = (unsigned __int8)v17[1];\n              }\n              ++v17;\n            }\n            while ( &v74[v53 + 1] != v17 );\n            v13[300] = v54;\n            v13[301] = v18;\n            v68 = v13 + 21;\n            v20 = v54;\n            v21 = 0;\n            while ( v20 <= v18 )\n            {\n              v13[v20] = 0;\n              v72[v20] = 0;\n              v22 = 0;\n              do\n              {\n                if ( (unsigned __int8)v74[v22] == v20 )\n                  v13[v21++ + 42] = v22;\n                ++v22;\n              }\n              while ( v63 > v22 );\n              ++v20;\n            }\n            v23 = 0;\n            do\n              ++v72[(unsigned __int8)v74[v23++]];\n            while ( v63 > v23 );\n            v60 = 0;\n            v24 = v54;\n            v25 = 0;\n            while ( v24 < v18 )\n            {\n              v26 = v72[v24] + v25;\n              v13[v24] = (v26 << (v18 - v24)) - 1;\n              v25 = 2 * v26;\n              v60 += v72[v24++];\n              v68[v24] = v25 - v60;\n            }\n            v13[v18] = v25 + v72[v18] - 1;\n            v13[v18 + 1] = 0x7FFFFFFF;\n            v68[v54] = 0;\n            ++v62;\n            v13 += 301;\n            goto LABEL_32;\n          }\n        }\n      }\n      return -5;\n    }\n    for ( k = 0; k != 256; ++k )\n    {\n      *(_DWORD *)&v74[4 * k] = 0;\n      v73[k] = k;\n    }\n    v28 = 0;\n    v29 = 0;\n    v59 = 0;\nLABEL_60:\n    if ( v59 >= v66 )\n      return -5;\n    v30 = *((unsigned __int8 *)v67 + v59++);\n    if ( v30 >= v62 )\n      return -5;\n    v55 = (int)&a1[301 * v30 + 8466];\n    v70 = (int)&a1[301 * v30 + 8486];\n    v71 = (int)&a1[301 * v30 + 8465];\n    v64 = v28;\n    v69 = 49;\n    while ( 1 )\n    {\n      v31 = *a1;\n      v32 = *(_DWORD *)(v55 + 1200);\n      v33 = *a1 - v32;\n      if ( v33 >= 0 )\n      {\n        *a1 = v33;\n        v35 = ((1 << v32) - 1) & ((unsigned int)a1[1] >> v33);\n      }\n      else\n      {\n        v34 = a1[5];\n        if ( v34 != a1[4] )\n        {\n          v36 = a1[1] << 8;\n          a1[5] = v34 + 1;\n          a1[1] = *(unsigned __int8 *)(a1[6] + v34) | v36;\n          *a1 = v31 + 8;\n          goto LABEL_67;\n        }\n        v35 = sub_80899C1((int)a1, v32);\n      }\n      v61 = *(_DWORD *)(v55 + 1196);\n      for ( m = 4 * v61; *(_DWORD *)(v71 + m) < v35; m += 4 )\n        ++v61;\n      v38 = *(_DWORD *)(v55 + 1200) - v61;\n      if ( v38 < 0 )\n        return -5;\n      *a1 += v38;\n      v39 = (v35 >> v38) - *(_DWORD *)(v70 + m);\n      if ( v39 > 0x101 )\n        return -5;\n      v40 = *(_DWORD *)(v55 + 4 * v39 + 164);\n      if ( v40 > 1 )\n      {\n        if ( v28 )\n        {\n          if ( v29 + v57 > a1[16] )\n            return -5;\n          v41 = *((unsigned __int8 *)&v72[21] + (unsigned __int8)v73[0]);\n          *(_DWORD *)&v74[4 * v41] += v57;\n          while ( (--v57 & 0x80000000) == 0 )\n          {\n            ++v29;\n            *(_DWORD *)(v56 + 4 * v29 - 4) = v41;\n          }\n        }\n        if ( v53 < (int)v40 )\n        {\n          v45 = 0;\n          for ( n = 0; n != 256; ++n )\n          {\n            v47 = v45 + *(_DWORD *)&v74[4 * n];\n            *(_DWORD *)&v74[4 * n] = v45;\n            v45 = v47;\n          }\n          for ( ii = 0; ii != v29; ++ii )\n          {\n            v49 = *(unsigned __int8 *)(v56 + 4 * ii);\n            v50 = *(_DWORD *)&v74[4 * v49];\n            *(_DWORD *)(v56 + 4 * v50) |= ii << 8;\n            *(_DWORD *)&v74[4 * v49] = v50 + 1;\n          }\n          if ( ii )\n          {\n            if ( ii > v65 )\n            {\n              v51 = *(_DWORD *)(v56 + 4 * v65);\n              a1[11] = (unsigned __int8)v51;\n              a1[8] = v51 >> 8;\n              a1[9] = 5;\n              goto LABEL_100;\n            }\n            return -5;\n          }\nLABEL_100:\n          a1[10] = ii;\n          return 0;\n        }\n        if ( a1[16] <= v29 )\n          return -5;\n        v42 = *((unsigned __int8 *)&v72[84] + v40 + 3);\n        v43 = v40 - 1;\n        do\n        {\n          --v43;\n          v73[v43 + 1] = v73[v43];\n        }\n        while ( v43 );\n        v73[0] = v42;\n        v44 = *((unsigned __int8 *)&v72[21] + v42);\n        ++*(_DWORD *)&v74[4 * v44];\n        *(_DWORD *)(v56 + 4 * v29) = v44;\n        v28 = 0;\n        ++v29;\n      }\n      else\n      {\n        if ( v28 )\n          v64 = v57;\n        else\n          v28 = 1;\n        v57 = v64 + (v28 << v40);\n        if ( a1[16] > v28 )\n          v28 *= 2;\n      }\n      if ( --v69 < 0 )\n        goto LABEL_60;\nLABEL_67:\n      v64 = v28;\n    }\n  }\n  return v4;\n}\n"
    ],
    "sub_808A042": [
        "0x808a042",
        "int __usercall sub_808A042@<eax>(int *a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  int result; // eax\n  int v6; // ecx\n  int v7; // edx\n  unsigned int v8; // eax\n  int v10; // ecx\n  int v11; // esi\n  int v13; // eax\n  int v14; // edx\n  int v16; // [esp+4h] [ebp-14h]\n\n  result = a1[10];\n  if ( result >= 0 )\n  {\n    v16 = a1[15];\n    v6 = a1[8];\n    v7 = a1[11];\n    v8 = a1[14];\n    if ( !a1[7] )\n      goto LABEL_14;\n    do\n    {\n      --a1[7];\nLABEL_4:\n      if ( --a3 < 0 )\n      {\n        a1[8] = v6;\n        a1[11] = v7;\n        a1[14] = v8;\n        ++a1[7];\n        return 0;\n      }\n      *a2 = v7;\n      v8 = a1[(v7 ^ HIBYTE(v8)) + 18] ^ (v8 << 8);\n      ++a2;\n    }\n    while ( a1[7] );\n    while ( 1 )\n    {\n      while ( --a1[10] >= 0 )\n      {\n        v10 = *(_DWORD *)(v16 + 4 * v6);\n        v11 = (unsigned __int8)v10;\n        v6 = v10 >> 8;\n        if ( a1[9]-- != 1 )\n        {\n          if ( v11 != v7 )\n          {\n            a1[9] = 4;\n            v7 = v11;\n          }\n          goto LABEL_4;\n        }\n        a1[7] = v11;\n        a1[9] = 5;\n        if ( v11 )\n        {\n          a1[7] = v11 - 1;\n          goto LABEL_4;\n        }\n      }\n      v13 = ~v8;\n      a1[14] = v13;\n      a1[13] = v13 ^ __ROL4__(a1[13], 1);\n      v14 = a1[12];\n      if ( v14 != v13 )\n      {\n        a1[13] = v14 + 1;\n        return -1;\n      }\nLABEL_14:\n      result = sub_8089A66(a1);\n      if ( result )\n        break;\n      v6 = a1[8];\n      v7 = a1[11];\n      v8 = -1;\n    }\n    a1[10] = result;\n    if ( result == -1 )\n      return a3;\n  }\n  return result;\n}\n"
    ],
    "sub_808A130": [
        "0x808a130",
        "int __userpurge sub_808A130@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, const void *a4, unsigned int a5)\n{\n  _DWORD *v7; // eax\n  _DWORD *v8; // ebx\n  void *v9; // eax\n  int v10; // eax\n  int v11; // eax\n  void *v12; // eax\n\n  v7 = sub_804DB2E(a3 != -1 ? 45184 : 41088);\n  v8 = v7;\n  *a2 = v7;\n  v7[17] = a1;\n  v7[2] = a3;\n  if ( a3 == -1 )\n  {\n    v7[6] = a4;\n  }\n  else\n  {\n    v9 = v7 + 10272;\n    v8[6] = v9;\n    qmemcpy(v9, a4, a5);\n  }\n  v8[4] = a5;\n  sub_80AA37D(0, 1);\n  v10 = sub_80899C1((int)v8, 16);\n  if ( (unsigned int)(v10 - 26673) > 8 )\n    return -2;\n  v11 = 100000 * v10 + 1627767296;\n  v8[16] = v11;\n  v12 = sub_804DAD3(4 * v11);\n  v8[15] = v12;\n  if ( !v12 )\n  {\n    free(v8);\n    sub_804D604();\n  }\n  return 0;\n}\n"
    ],
    "sub_808A1E4": [
        "0x808a1e4",
        "__int64 __usercall sub_808A1E4@<edx:eax>(void **a1@<eax>)\n{\n  __int64 v3; // [esp-8h] [ebp-Ch]\n\n  free(a1[15]);\n  free(a1);\n  return v3;\n}\n"
    ],
    "sub_808A1F9": [
        "0x808a1f9",
        "__int64 __usercall sub_808A1F9@<edx:eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int v2; // esi\n  int v3; // eax\n  int v4; // eax\n  int v5; // esi\n  __int64 v8; // [esp+4h] [ebp-40h]\n  _BYTE *ptr; // [esp+Ch] [ebp-38h]\n  unsigned int i; // [esp+10h] [ebp-34h]\n  unsigned int v11; // [esp+10h] [ebp-34h]\n  int *v12; // [esp+14h] [ebp-30h] BYREF\n  char v13[44]; // [esp+18h] [ebp-2Ch] BYREF\n\n  v8 = 0LL;\n  if ( sub_808EE53(a2, 23106) )\n    return -1LL;\n  ptr = sub_804DAFA(0x1000u);\n  for ( i = 0; ; i = v11 - 2 )\n  {\n    v2 = _setjmp((struct __jmp_buf_tag *)v13);\n    if ( !v2 )\n    {\n      v2 = sub_808A130((int)v13, &v12, *(_DWORD *)(a1 + 8), ptr + 2, i);\n      if ( !v2 )\n      {\n        while ( 1 )\n        {\n          v3 = sub_808A042(v12, ptr, 4096);\n          v2 = v3;\n          if ( v3 < 0 )\n            break;\n          v4 = 4096 - v3;\n          v2 = 4096 - v2;\n          if ( !v2 )\n            goto LABEL_10;\n          if ( v2 != sub_808EE9C(v4, ptr) )\n          {\n            v2 = -4;\n            goto LABEL_18;\n          }\n          v8 += v2;\n        }\n      }\n    }\n    if ( v2 != -1 )\n      break;\nLABEL_10:\n    if ( v12[12] != v12[13] )\n    {\n      sub_804D5F4(\"CRC error\");\n      goto LABEL_18;\n    }\n    v5 = v12[5];\n    v11 = v12[4] - v5;\n    qmemcpy(ptr, (const void *)(v12[6] + v5), v11);\n    if ( v11 <= 1 )\n    {\n      if ( 2 - v11 != sub_804E5BC(2 - v11, &ptr[v11], *(_DWORD *)(a1 + 8)) )\n        goto LABEL_17;\n      v11 = 2;\n    }\n    if ( *(_WORD *)ptr != 23106 )\n    {\nLABEL_17:\n      v2 = 0;\n      goto LABEL_18;\n    }\n    sub_808A1E4((void **)v12);\n  }\n  sub_804D5F4(\"bunzip error %d\", v2);\nLABEL_18:\n  sub_808A1E4((void **)v12);\n  free(ptr);\n  if ( v2 )\n    return v2;\n  return v8;\n}\n"
    ],
    "sub_808A386": [
        "0x808a386",
        "int __usercall sub_808A386@<eax>(int result@<eax>)\n{\n  int v1; // ebx\n  void *v2; // eax\n  int v3; // [esp-4h] [ebp-8h]\n\n  v1 = result;\n  while ( v1 )\n  {\n    v2 = (void *)(v1 - 8);\n    v1 = *(_DWORD *)(v1 - 4);\n    free(v2);\n    result = v3;\n  }\n  return result;\n}\n"
    ],
    "sub_808A39E": [
        "0x808a39e",
        "int __usercall sub_808A39E@<eax>(\n        int a1@<eax>,\n        unsigned int a2@<edx>,\n        unsigned int a3@<ecx>,\n        int a4,\n        int a5,\n        _DWORD *a6,\n        unsigned int *a7)\n{\n  int v8; // esi\n  _WORD *v9; // eax\n  int result; // eax\n  unsigned int i; // ecx\n  int v12; // edx\n  unsigned int v13; // eax\n  int v14; // edi\n  int v15; // eax\n  int v16; // eax\n  int k; // edx\n  int v18; // eax\n  int v19; // edx\n  int v20; // ecx\n  int v21; // ebx\n  char *v22; // edx\n  int v23; // ebp\n  int v24; // edi\n  int v25; // esi\n  unsigned int v26; // edx\n  unsigned int v27; // ebx\n  unsigned int v28; // eax\n  unsigned int v29; // eax\n  int *v30; // ecx\n  unsigned int v31; // eax\n  unsigned int v32; // ebp\n  char *v33; // eax\n  _DWORD *v34; // ecx\n  int v35; // ebx\n  unsigned int v36; // ecx\n  char v37; // si\n  int v38; // ecx\n  unsigned int m; // ecx\n  int v40; // eax\n  unsigned int n; // ecx\n  int v42; // esi\n  unsigned int j; // [esp+0h] [ebp-5D8h]\n  int v44; // [esp+4h] [ebp-5D4h]\n  int v45; // [esp+8h] [ebp-5D0h]\n  unsigned int v46; // [esp+Ch] [ebp-5CCh]\n  unsigned int v47; // [esp+10h] [ebp-5C8h]\n  unsigned int v48; // [esp+14h] [ebp-5C4h]\n  unsigned int v49; // [esp+18h] [ebp-5C0h]\n  char *v50; // [esp+1Ch] [ebp-5BCh]\n  int *v51; // [esp+20h] [ebp-5B8h]\n  int v53; // [esp+30h] [ebp-5A8h]\n  unsigned int v54; // [esp+34h] [ebp-5A4h]\n  int v55[16]; // [esp+38h] [ebp-5A0h]\n  int v56[17]; // [esp+78h] [ebp-560h] BYREF\n  int v57; // [esp+BCh] [ebp-51Ch]\n  int v58[16]; // [esp+C0h] [ebp-518h]\n  int v59; // [esp+100h] [ebp-4D8h]\n  int v60[16]; // [esp+104h] [ebp-4D4h]\n  int v61[293]; // [esp+144h] [ebp-494h] BYREF\n\n  v48 = 16;\n  if ( a2 > 0x100 )\n    v48 = *(_DWORD *)(a1 + 1024);\n  *a6 = 0;\n  memset(v56, 0, sizeof(v56));\n  v8 = 0;\n  do\n    ++v56[*(_DWORD *)(a1 + 4 * v8++)];\n  while ( v8 != a2 );\n  if ( v56[0] == v8 )\n  {\n    v9 = sub_804DB2E(0x18u);\n    v9[4] = 355;\n    v9[8] = 355;\n    *a6 = v9 + 4;\n    *a7 = 1;\n    return 0;\n  }\n  else\n  {\n    for ( i = 1; i != 17; ++i )\n    {\n      if ( v56[i] )\n        break;\n    }\n    v44 = i;\n    for ( j = 16; ; --j )\n    {\n      v12 = v56[j];\n      if ( v12 )\n        break;\n      if ( !j )\n      {\n        v12 = 0;\n        break;\n      }\n    }\n    v13 = i;\n    if ( *a7 >= i )\n    {\n      v13 = j;\n      if ( j > *a7 )\n        v13 = *a7;\n    }\n    *a7 = v13;\n    v14 = 1 << i;\n    while ( j > i )\n    {\n      v15 = v14 - v56[i];\n      if ( v15 < 0 )\n        return 2;\n      ++i;\n      v14 = 2 * v15;\n    }\n    result = 2;\n    v53 = v14 - v12;\n    if ( v14 - v12 >= 0 )\n    {\n      v56[j] = v14;\n      v60[0] = 0;\n      v16 = 0;\n      for ( k = 0; j != ++v16; v60[v16] = k )\n        k += v56[v16];\n      memset(v61, 255, 0x484u);\n      v18 = 0;\n      do\n      {\n        v19 = *(_DWORD *)(a1 + 4 * v18);\n        if ( v19 )\n        {\n          v20 = v60[v19 - 1];\n          v60[v19 - 1] = v20 + 1;\n          v61[v20] = v18;\n        }\n        ++v18;\n      }\n      while ( v8 != v18 );\n      v59 = 0;\n      v57 = 0;\n      v55[0] = 0;\n      v49 = 0;\n      LOBYTE(v21) = 0;\n      v22 = 0;\n      v51 = v61;\n      v46 = 0;\n      v23 = -1;\n      while ( v44 <= (int)j )\n      {\n        v47 = v56[v44];\n        v54 = 1 << (v44 - 1);\n        while ( v47 )\n        {\n          while ( 1 )\n          {\n            v24 = v23 + 1;\n            v25 = v58[v23];\n            if ( v25 >= v44 )\n              break;\n            v26 = *a7;\n            if ( *a7 > j - v25 )\n              v26 = j - v25;\n            v27 = v44 - v25;\n            v28 = 1 << (v44 - v25);\n            if ( v47 < v28 )\n            {\n              v29 = v28 - v47;\n              v30 = &v56[v44 - v27];\n              while ( v26 > ++v27 )\n              {\n                v31 = 2 * v29;\n                v32 = v30[v27];\n                if ( v32 >= v31 )\n                  break;\n                v29 = v31 - v32;\n              }\n            }\n            if ( v25 + v27 > v48 && v25 < v48 )\n              v27 = v48 - v25;\n            v49 = 1 << v27;\n            v58[v24] = v25 + v27;\n            v33 = (char *)sub_804DB2E(8 * (1 << v27) + 8);\n            v22 = v33 + 8;\n            *a6 = v33 + 8;\n            a6 = v33 + 4;\n            v55[v24] = (int)(v33 + 8);\n            if ( v24 )\n            {\n              v60[v24 - 1] = v46;\n              v50 = v33 + 8;\n              v34 = (_DWORD *)(v55[v24 - 1] + 8 * ((v46 & ((1 << v25) - 1)) >> LOBYTE(v56[v24 + 16])));\n              LOBYTE(v45) = v27 + 16;\n              v35 = v45;\n              BYTE1(v35) = v25 - LOBYTE(v56[v24 + 16]);\n              v45 = v35;\n              *v34 = v35;\n              v34[1] = v22;\n            }\n            LOBYTE(v21) = v25;\n            v23 = v24;\n          }\n          v36 = *v51;\n          v37 = 99;\n          if ( *v51 != -1 )\n          {\n            ++v51;\n            if ( v36 >= a3 )\n            {\n              v38 = v36 - a3;\n              v37 = *(_BYTE *)(a5 + v38);\n              LOWORD(v50) = *(_WORD *)(a4 + 2 * v38);\n            }\n            else\n            {\n              v37 = (v36 != 256) + 15;\n              LOWORD(v50) = v36;\n            }\n          }\n          for ( m = v46 >> v21; m < v49; m += 1 << (v44 - v21) )\n          {\n            LOBYTE(v45) = v37;\n            v40 = v45;\n            BYTE1(v40) = v44 - v21;\n            v45 = v40;\n            *(_DWORD *)&v22[8 * m] = v40;\n            *(_DWORD *)&v22[8 * m + 4] = v50;\n          }\n          for ( n = v54; ; n >>= 1 )\n          {\n            v42 = n & v46;\n            v46 ^= n;\n            if ( !v42 )\n              break;\n          }\n          --v47;\n          while ( (v46 & ((1 << v21) - 1)) != v60[v23 - 1] )\n            v21 = v58[--v23 - 1];\n        }\n        ++v44;\n      }\n      *a7 = v58[0];\n      return j != 1 && v53 != 0;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_808A7B6": [
        "0x808a7b6",
        "void __usercall __noreturn sub_808A7B6(int a1@<eax>)\n{\n  sub_808A386(*(_DWORD *)(a1 + 76));\n  sub_808A386(*(_DWORD *)(a1 + 80));\n  *(_DWORD *)(a1 + 76) = 0;\n  *(_DWORD *)(a1 + 80) = 0;\n  longjmp((struct __jmp_buf_tag *)(a1 + 124), 1);\n}\n"
    ],
    "sub_808A7E2": [
        "0x808a7e2",
        "int __usercall sub_808A7E2@<eax>(int *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)\n{\n  size_t v7; // ecx\n  ssize_t v8; // eax\n  int v9; // eax\n\n  while ( *a3 < a4 )\n  {\n    if ( a1[12] >= (unsigned int)a1[13] )\n    {\n      v7 = a1[10];\n      if ( *((_QWORD *)a1 + 5) > 0x3FFBuLL )\n        v7 = 16380;\n      v8 = sub_804E5BC(v7, (void *)(a1[9] + 4), a1[3]);\n      a1[13] = v8;\n      if ( v8 <= 0 )\n      {\n        a1[30] = (int)\"unexpected end of file\";\n        sub_808A7B6((int)a1);\n      }\n      if ( a1[11] >= 0 )\n        *((_QWORD *)a1 + 5) -= (unsigned int)v8;\n      a1[13] = v8 + 4;\n      a1[12] = 4;\n    }\n    v9 = a1[12];\n    a2 |= *(unsigned __int8 *)(a1[9] + v9) << *a3;\n    a1[12] = v9 + 1;\n    *a3 += 8;\n  }\n  return a2;\n}\n"
    ],
    "sub_808A88F": [
        "0x808a88f",
        "_BOOL4 __usercall sub_808A88F@<eax>(int a1@<eax>, signed int a2@<edx>)\n{\n  int v2; // ecx\n  signed int v3; // ebx\n  ssize_t v6; // eax\n  unsigned int v8; // ebx\n\n  v2 = *(_DWORD *)(a1 + 48);\n  v3 = *(_DWORD *)(a1 + 52) - v2;\n  if ( a2 <= v3 )\n    return 1;\n  memmove(*(void **)(a1 + 36), (const void *)(*(_DWORD *)(a1 + 36) + v2), v3);\n  *(_DWORD *)(a1 + 48) = 0;\n  v6 = sub_804E5E3(*(_DWORD *)(a1 + 12), (char *)(v3 + *(_DWORD *)(a1 + 36)), 0x4000 - v3);\n  *(_DWORD *)(a1 + 52) = v6;\n  if ( v6 >= 0 )\n  {\n    v8 = v6 + v3;\n    *(_DWORD *)(a1 + 52) = v8;\n    return v8 >= a2;\n  }\n  else\n  {\n    sub_804D5F4(\"read error\");\n    return 0;\n  }\n}\n"
    ],
    "sub_808A8FA": [
        "0x808a8fa",
        "int __usercall sub_808A8FA@<eax>(int a1@<eax>, _BYTE *a2@<edx>)\n{\n  int v4; // edx\n  unsigned int v5; // eax\n  unsigned int v6; // eax\n  unsigned int v7; // edx\n  unsigned __int8 v8; // si\n  int v9; // eax\n  int v10; // ecx\n  unsigned int v11; // eax\n  __int16 v12; // si\n  unsigned int v13; // eax\n  int v14; // edx\n  int i; // eax\n  int j; // eax\n  unsigned int v18; // eax\n  unsigned int v19; // edx\n  unsigned int v20; // eax\n  unsigned int v21; // eax\n  unsigned int v22; // eax\n  int v23; // edi\n  int v24; // esi\n  int v25; // edi\n  int v26; // ebp\n  unsigned int v27; // eax\n  unsigned int v28; // ebp\n  unsigned int v29; // edi\n  unsigned int k; // esi\n  unsigned int v31; // eax\n  int v32; // edx\n  int v33; // ecx\n  unsigned int v34; // edx\n  unsigned int v35; // eax\n  unsigned int v36; // eax\n  int v37; // edx\n  int v38; // edx\n  int *v39; // esi\n  int v40; // ecx\n  unsigned int v41; // eax\n  int v42; // edx\n  int v43; // edx\n  int *v44; // esi\n  int v45; // ecx\n  unsigned int v46; // eax\n  int v47; // ecx\n  int v48; // ecx\n  int *v49; // esi\n  int v50; // edx\n  unsigned int v51; // eax\n  unsigned int v52; // edx\n  int v53; // [esp+0h] [ebp-528h]\n  unsigned int v54; // [esp+4h] [ebp-524h]\n  unsigned int v55; // [esp+8h] [ebp-520h]\n  int v56; // [esp+10h] [ebp-518h]\n  unsigned int v57; // [esp+14h] [ebp-514h] BYREF\n  int v58; // [esp+18h] [ebp-510h] BYREF\n  unsigned int v59; // [esp+1Ch] [ebp-50Ch] BYREF\n  unsigned int v60; // [esp+20h] [ebp-508h] BYREF\n  unsigned int v61; // [esp+24h] [ebp-504h] BYREF\n  int v62[320]; // [esp+28h] [ebp-500h] BYREF\n\n  v4 = *(_DWORD *)(a1 + 28);\n  v57 = *(unsigned __int8 *)(a1 + 32);\n  v5 = sub_808A7E2((int *)a1, v4, &v57, 1u);\n  *a2 = v5 & 1;\n  --v57;\n  v6 = sub_808A7E2((int *)a1, v5 >> 1, &v57, 2u);\n  v7 = v6 >> 2;\n  v57 -= 2;\n  v8 = v57;\n  *(_DWORD *)(a1 + 28) = v6 >> 2;\n  *(_BYTE *)(a1 + 32) = v8;\n  v9 = v6 & 3;\n  if ( v9 == 1 )\n  {\n    for ( i = 0; i != 144; ++i )\n      v62[i] = 8;\n    do\n      v62[i++] = 9;\n    while ( i != 256 );\n    do\n      v62[i++] = 7;\n    while ( i != 280 );\n    v62[280] = 8;\n    v62[281] = 8;\n    v62[282] = 8;\n    v62[283] = 8;\n    v62[284] = 8;\n    v62[285] = 8;\n    v62[286] = 8;\n    v62[287] = 8;\n    v60 = 7;\n    sub_808A39E((int)v62, 0x120u, 0x101u, (int)&unk_80B85B8, (int)&unk_80D54DE, (_DWORD *)(a1 + 76), &v60);\n    for ( j = 0; j != 30; ++j )\n      v62[j] = 5;\n    v61 = 5;\n    sub_808A39E((int)v62, 0x1Eu, 0, (int)&unk_80B857C, (int)&unk_80D54C0, (_DWORD *)(a1 + 80), &v61);\n    v18 = v61;\n    v19 = v60;\n    *(_DWORD *)(a1 + 84) = v60;\n    *(_DWORD *)(a1 + 88) = v18;\n    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 28);\n    *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a1 + 32);\n    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a1 + 16);\n    *(_DWORD *)(a1 + 56) = (unsigned __int16)word_80B85F6[v19];\n    *(_DWORD *)(a1 + 60) = (unsigned __int16)word_80B85F6[v18];\n    return -2;\n  }\n  if ( !v9 )\n  {\n    v10 = v8 & 7;\n    v58 = v8 - v10;\n    v11 = sub_808A7E2((int *)a1, v7 >> v10, (unsigned int *)&v58, 0x10u);\n    v12 = v11;\n    v58 -= 16;\n    v13 = sub_808A7E2((int *)a1, HIWORD(v11), (unsigned int *)&v58, 0x10u);\n    if ( v12 == ~(_WORD)v13 )\n    {\n      v14 = v58 - 16;\n      *(_DWORD *)(a1 + 104) = (unsigned __int16)~(_WORD)v13;\n      *(_DWORD *)(a1 + 108) = HIWORD(v13);\n      *(_DWORD *)(a1 + 112) = v14;\n      *(_DWORD *)(a1 + 116) = *(_DWORD *)(a1 + 16);\n      return -1;\n    }\nLABEL_44:\n    sub_808A7B6(a1);\n  }\n  if ( v9 != 2 )\n    goto LABEL_44;\n  v61 = v8;\n  v20 = sub_808A7E2((int *)a1, v7, &v61, 5u);\n  v54 = (v20 & 0x1F) + 257;\n  v61 -= 5;\n  v21 = sub_808A7E2((int *)a1, v20 >> 5, &v61, 5u);\n  v55 = (v21 & 0x1F) + 1;\n  v61 -= 5;\n  v22 = sub_808A7E2((int *)a1, v21 >> 5, &v61, 4u);\n  v23 = v22 & 0xF;\n  v24 = v23 + 4;\n  v53 = v22 >> 4;\n  v61 -= 4;\n  if ( v55 > 0x1E )\n    goto LABEL_44;\n  if ( v54 > 0x11E )\n    goto LABEL_44;\n  v25 = v23 + 5;\n  v26 = 1;\n  do\n  {\n    v27 = sub_808A7E2((int *)a1, v53, &v61, 3u);\n    v62[(unsigned __int8)byte_80D54AC[v26]] = v27 & 7;\n    v53 = v27 >> 3;\n    v61 -= 3;\n    ++v26;\n  }\n  while ( v26 != v25 );\n  while ( v24 != 19 )\n    v62[(unsigned __int8)byte_80D54AD[v24++]] = 0;\n  v59 = 7;\n  if ( sub_808A39E((int)v62, 0x13u, 0x13u, 0, 0, (_DWORD *)(a1 + 76), &v59) )\n    goto LABEL_44;\n  v28 = v55 + v54;\n  v56 = (unsigned __int16)word_80B85F6[v59];\n  v29 = 0;\n  for ( k = 0; ; k = v35 )\n  {\n    v31 = sub_808A7E2((int *)a1, v53, &v61, v59);\n    v32 = *(_DWORD *)(a1 + 76) + 8 * (v31 & v56);\n    v33 = *(unsigned __int8 *)(v32 + 1);\n    v53 = v31 >> v33;\n    v61 -= v33;\n    v34 = *(unsigned __int16 *)(v32 + 4);\n    if ( v34 > 0xF )\n    {\n      if ( v34 == 16 )\n      {\n        v36 = sub_808A7E2((int *)a1, v53, &v61, 2u);\n        v37 = v36 & 3;\n        v53 = v36 >> 2;\n        v61 -= 2;\n        v35 = v37 + k + 3;\n        if ( v35 > v28 )\n          goto LABEL_44;\n        v38 = v37 + 3;\n        v39 = &v62[k];\n        v40 = 0;\n        do\n          v39[v40++] = v29;\n        while ( v40 != v38 );\n      }\n      else\n      {\n        if ( v34 == 17 )\n        {\n          v41 = sub_808A7E2((int *)a1, v53, &v61, 3u);\n          v42 = v41 & 7;\n          v53 = v41 >> 3;\n          v61 -= 3;\n          v35 = v42 + k + 3;\n          if ( v35 > v28 )\n            goto LABEL_44;\n          v43 = v42 + 3;\n          v44 = &v62[k];\n          v45 = 0;\n          do\n            v44[v45++] = 0;\n          while ( v45 != v43 );\n        }\n        else\n        {\n          v46 = sub_808A7E2((int *)a1, v53, &v61, 7u);\n          v47 = v46 & 0x7F;\n          v53 = v46 >> 7;\n          v61 -= 7;\n          v35 = v47 + k + 11;\n          if ( v35 > v28 )\n            goto LABEL_44;\n          v48 = v47 + 11;\n          v49 = &v62[k];\n          v50 = 0;\n          do\n            v49[v50++] = 0;\n          while ( v48 != v50 );\n        }\n        v29 = 0;\n      }\n    }\n    else\n    {\n      v35 = k + 1;\n      v62[k] = v34;\n      v29 = v34;\n    }\n    if ( v35 >= v28 )\n      break;\n  }\n  sub_808A386(*(_DWORD *)(a1 + 76));\n  *(_DWORD *)(a1 + 28) = v53;\n  *(_BYTE *)(a1 + 32) = v61;\n  v59 = 9;\n  if ( sub_808A39E((int)v62, v54, 0x101u, (int)&unk_80B85B8, (int)&unk_80D54DE, (_DWORD *)(a1 + 76), &v59) )\n    goto LABEL_44;\n  v60 = 6;\n  if ( sub_808A39E((int)&v62[v54], v55, 0, (int)&unk_80B857C, (int)&unk_80D54C0, (_DWORD *)(a1 + 80), &v60) )\n    goto LABEL_44;\n  v51 = v60;\n  v52 = v59;\n  *(_DWORD *)(a1 + 84) = v59;\n  *(_DWORD *)(a1 + 88) = v51;\n  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 28);\n  *(_DWORD *)(a1 + 68) = *(unsigned __int8 *)(a1 + 32);\n  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a1 + 16);\n  *(_DWORD *)(a1 + 56) = (unsigned __int16)word_80B85F6[v52];\n  *(_DWORD *)(a1 + 60) = (unsigned __int16)word_80B85F6[v51];\n  return -2;\n}\n"
    ],
    "sub_808AE3F": [
        "0x808ae3f",
        "int __usercall sub_808AE3F@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  unsigned __int8 *i; // ebp\n  unsigned int v4; // esi\n  int v5; // eax\n  int v6; // edx\n  unsigned int v7; // esi\n  int v8; // eax\n  int v9; // eax\n  int v10; // edx\n  int v11; // eax\n  int v12; // ecx\n  int v13; // edx\n  int v14; // eax\n  unsigned int v15; // eax\n  int v16; // eax\n  unsigned __int8 *v17; // ebp\n  unsigned int j; // esi\n  int v19; // eax\n  int v20; // edx\n  unsigned int v21; // esi\n  int v22; // eax\n  int v23; // eax\n  int v24; // edx\n  unsigned int v25; // eax\n  unsigned int v26; // esi\n  unsigned int v27; // edi\n  unsigned int v28; // eax\n  unsigned int v29; // ebp\n  unsigned int v30; // ecx\n  unsigned int v31; // edx\n  unsigned int v32; // eax\n  int v33; // edx\n  const void *v34; // esi\n  void *v35; // edx\n  int v36; // ebp\n  int v37; // esi\n  int v38; // edx\n  int v39; // eax\n\n  if ( !*(_BYTE *)(a1 + 100) )\n    goto LABEL_2;\n  do\n  {\nLABEL_16:\n    v26 = *(_DWORD *)(a1 + 96) & 0x7FFF;\n    *(_DWORD *)(a1 + 96) = v26;\n    v27 = *(_DWORD *)(a1 + 72);\n    v28 = v26;\n    if ( v26 < v27 )\n      v28 = *(_DWORD *)(a1 + 72);\n    v29 = 0x8000 - v28;\n    v30 = v26 - v27;\n    if ( v26 < v27 )\n      v30 = v27 - v26;\n    v31 = *(_DWORD *)(a1 + 92);\n    v32 = v31;\n    if ( v31 > v29 )\n      v32 = v29;\n    *(_DWORD *)(a1 + 92) = v31 - v32;\n    v33 = *(_DWORD *)(a1 + 20);\n    v34 = (const void *)(v33 + v26);\n    v35 = (void *)(v27 + v33);\n    if ( v30 < v32 )\n    {\n      do\n      {\n        v36 = *(_DWORD *)(a1 + 20);\n        v37 = *(_DWORD *)(a1 + 96);\n        *(_DWORD *)(a1 + 96) = v37 + 1;\n        v38 = *(_DWORD *)(a1 + 72);\n        *(_DWORD *)(a1 + 72) = v38 + 1;\n        *(_BYTE *)(v36 + v38) = *(_BYTE *)(v36 + v37);\n        --v32;\n      }\n      while ( v32 );\n    }\n    else\n    {\n      qmemcpy(v35, v34, v32);\n      *(_DWORD *)(a1 + 72) += v32;\n      *(_DWORD *)(a1 + 96) += v32;\n    }\n    v39 = *(_DWORD *)(a1 + 92);\n    if ( *(_DWORD *)(a1 + 72) == 0x8000 )\n    {\n      *(_DWORD *)(a1 + 16) = 0x8000;\n      *(_BYTE *)(a1 + 100) = v39 != 0;\nLABEL_27:\n      *(_DWORD *)(a1 + 72) = 0;\n      return 1;\n    }\n  }\n  while ( v39 );\n  *(_BYTE *)(a1 + 100) = 0;\nLABEL_2:\n  while ( 1 )\n  {\n    v2 = sub_808A7E2((int *)a1, *(_DWORD *)(a1 + 64), (unsigned int *)(a1 + 68), *(_DWORD *)(a1 + 84));\n    *(_DWORD *)(a1 + 64) = v2;\n    for ( i = (unsigned __int8 *)(*(_DWORD *)(a1 + 76) + 8 * (*(_DWORD *)(a1 + 56) & v2));\n          ;\n          i = (unsigned __int8 *)(*((_DWORD *)i + 1) + 8 * (unsigned __int16)(word_80B85F6[v7] & v8)) )\n    {\n      v4 = *i;\n      if ( v4 <= 0x10 )\n        break;\n      if ( v4 == 99 )\n        goto LABEL_5;\n      v5 = i[1];\n      v6 = *(_DWORD *)(a1 + 64) >> i[1];\n      *(_DWORD *)(a1 + 64) = v6;\n      *(_DWORD *)(a1 + 68) -= v5;\n      v7 = v4 - 16;\n      v8 = sub_808A7E2((int *)a1, v6, (unsigned int *)(a1 + 68), v7);\n      *(_DWORD *)(a1 + 64) = v8;\n    }\n    v9 = i[1];\n    v10 = *(_DWORD *)(a1 + 64) >> i[1];\n    *(_DWORD *)(a1 + 64) = v10;\n    v11 = *(_DWORD *)(a1 + 68) - v9;\n    *(_DWORD *)(a1 + 68) = v11;\n    if ( v4 != 16 )\n      break;\n    v12 = *((_DWORD *)i + 1);\n    v13 = *(_DWORD *)(a1 + 20);\n    v14 = *(_DWORD *)(a1 + 72);\n    *(_DWORD *)(a1 + 72) = v14 + 1;\n    *(_BYTE *)(v13 + v14) = v12;\n    if ( *(_DWORD *)(a1 + 72) == 0x8000 )\n    {\n      *(_DWORD *)(a1 + 16) = 0x8000;\n      goto LABEL_27;\n    }\n  }\n  if ( v4 != 15 )\n  {\n    v15 = sub_808A7E2((int *)a1, v10, (unsigned int *)(a1 + 68), v4);\n    *(_DWORD *)(a1 + 92) = *((unsigned __int16 *)i + 2) + (v15 & (unsigned __int16)word_80B85F6[v4]);\n    *(_DWORD *)(a1 + 64) = v15 >> v4;\n    *(_DWORD *)(a1 + 68) -= v4;\n    v16 = sub_808A7E2((int *)a1, v15 >> v4, (unsigned int *)(a1 + 68), *(_DWORD *)(a1 + 88));\n    *(_DWORD *)(a1 + 64) = v16;\n    v17 = (unsigned __int8 *)(*(_DWORD *)(a1 + 80) + 8 * (*(_DWORD *)(a1 + 60) & v16));\n    for ( j = *v17; ; j = *v17 )\n    {\n      if ( j <= 0x10 )\n      {\n        v23 = v17[1];\n        v24 = *(_DWORD *)(a1 + 64) >> v17[1];\n        *(_DWORD *)(a1 + 64) = v24;\n        *(_DWORD *)(a1 + 68) -= v23;\n        v25 = sub_808A7E2((int *)a1, v24, (unsigned int *)(a1 + 68), j);\n        *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 72)\n                             - *((unsigned __int16 *)v17 + 2)\n                             - (v25 & (unsigned __int16)word_80B85F6[j]);\n        *(_DWORD *)(a1 + 64) = v25 >> j;\n        *(_DWORD *)(a1 + 68) -= j;\n        goto LABEL_16;\n      }\n      if ( j == 99 )\n        break;\n      v19 = v17[1];\n      v20 = *(_DWORD *)(a1 + 64) >> v17[1];\n      *(_DWORD *)(a1 + 64) = v20;\n      *(_DWORD *)(a1 + 68) -= v19;\n      v21 = j - 16;\n      v22 = sub_808A7E2((int *)a1, v20, (unsigned int *)(a1 + 68), v21);\n      *(_DWORD *)(a1 + 64) = v22;\n      v17 = (unsigned __int8 *)(*((_DWORD *)v17 + 1) + 8 * (unsigned __int16)(word_80B85F6[v21] & v22));\n    }\nLABEL_5:\n    sub_808A7B6(a1);\n  }\n  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 72);\n  *(_DWORD *)(a1 + 28) = v10;\n  *(_BYTE *)(a1 + 32) = v11;\n  sub_808A386(*(_DWORD *)(a1 + 76));\n  sub_808A386(*(_DWORD *)(a1 + 80));\n  *(_DWORD *)(a1 + 76) = 0;\n  *(_DWORD *)(a1 + 80) = 0;\n  return 0;\n}\n"
    ],
    "sub_808B0B3": [
        "0x808b0b3",
        "__int64 __usercall sub_808B0B3@<edx:eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  char v3; // al\n  int v4; // eax\n  int v5; // edx\n  int v6; // eax\n  int v7; // ecx\n  int v8; // edx\n  int v9; // eax\n  int v10; // eax\n  __int64 v13; // [esp+4h] [ebp-18h]\n\n  v13 = 0LL;\n  *(_DWORD *)(a1 + 20) = sub_804DAFA(0x8000u);\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_DWORD *)a1 = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 8);\n  *(_WORD *)(a1 + 100) = -256;\n  *(_BYTE *)(a1 + 102) = 1;\n  *(_BYTE *)(a1 + 32) = 0;\n  *(_DWORD *)(a1 + 28) = 0;\n  *(_DWORD *)(a1 + 24) = sub_80AA3DF();\n  *(_DWORD *)(a1 + 8) = -1;\n  *(_DWORD *)(a1 + 120) = \"corrupted data\";\n  if ( _setjmp((struct __jmp_buf_tag *)(a1 + 124)) )\n  {\n    sub_804D5F4(*(char **)(a1 + 120));\nLABEL_3:\n    v13 = -1LL;\n    goto LABEL_25;\n  }\n  do\n  {\n    *(_DWORD *)(a1 + 16) = 0;\n    while ( 1 )\n    {\n      if ( *(_BYTE *)(a1 + 102) )\n      {\n        if ( *(_BYTE *)(a1 + 103) )\n        {\n          *(_DWORD *)(a1 + 8) = sub_80AA41E(*(_DWORD *)(a1 + 24));\n          *(_QWORD *)a1 += *(unsigned int *)(a1 + 16);\n          *(_BYTE *)(a1 + 103) = 0;\n          v2 = 0;\n          goto LABEL_21;\n        }\n        *(_BYTE *)(a1 + 101) = sub_808A8FA(a1, (_BYTE *)(a1 + 103));\n        *(_BYTE *)(a1 + 102) = 0;\n      }\n      v3 = *(_BYTE *)(a1 + 101);\n      if ( v3 == -2 )\n        break;\n      if ( v3 != -1 )\n        sub_808A7B6(a1);\n      while ( 1 )\n      {\n        v4 = *(_DWORD *)(a1 + 104);\n        *(_DWORD *)(a1 + 104) = v4 - 1;\n        v5 = *(_DWORD *)(a1 + 108);\n        if ( !v4 )\n          break;\n        v6 = sub_808A7E2((int *)a1, v5, (unsigned int *)(a1 + 112), 8u);\n        *(_DWORD *)(a1 + 108) = v6;\n        v7 = *(_DWORD *)(a1 + 20);\n        v8 = *(_DWORD *)(a1 + 116);\n        *(_DWORD *)(a1 + 116) = v8 + 1;\n        *(_BYTE *)(v7 + v8) = v6;\n        if ( *(_DWORD *)(a1 + 116) == 0x8000 )\n        {\n          *(_DWORD *)(a1 + 16) = 0x8000;\n          *(_DWORD *)(a1 + 116) = 0;\n          *(_DWORD *)(a1 + 108) >>= 8;\n          *(_DWORD *)(a1 + 112) -= 8;\n          goto LABEL_19;\n        }\n        *(_DWORD *)(a1 + 108) >>= 8;\n        *(_DWORD *)(a1 + 112) -= 8;\n      }\n      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 116);\n      *(_DWORD *)(a1 + 28) = v5;\n      *(_BYTE *)(a1 + 32) = *(_DWORD *)(a1 + 112);\nLABEL_20:\n      *(_BYTE *)(a1 + 102) = 1;\n    }\n    if ( sub_808AE3F(a1) != 1 )\n      goto LABEL_20;\nLABEL_19:\n    *(_DWORD *)(a1 + 8) = sub_80AA41E(*(_DWORD *)(a1 + 24));\n    *(_QWORD *)a1 += *(unsigned int *)(a1 + 16);\n    v2 = 1;\nLABEL_21:\n    v9 = sub_808EE9C(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));\n    if ( v9 == -1 )\n      goto LABEL_3;\n    v13 += v9;\n  }\n  while ( v2 );\n  if ( *(_BYTE *)(a1 + 32) > 7u )\n  {\n    v10 = *(_DWORD *)(a1 + 48);\n    *(_DWORD *)(a1 + 48) = v10 - 1;\n    *(_BYTE *)(*(_DWORD *)(a1 + 36) + v10 - 1) = *(_DWORD *)(a1 + 28);\n    *(_DWORD *)(a1 + 28) >>= 8;\n    *(_BYTE *)(a1 + 32) -= 8;\n  }\nLABEL_25:\n  free(*(void **)(a1 + 20));\n  free(*(void **)(a1 + 24));\n  return v13;\n}\n"
    ],
    "sub_808B30F": [
        "0x808b30f",
        "__int64 __usercall sub_808B30F@<edx:eax>(_DWORD *a1@<eax>)\n{\n  void *v2; // esi\n  int v3; // edx\n  int v4; // edx\n  __int64 v6; // [esp+0h] [ebp-14h]\n\n  v2 = sub_804DB2E(0xA0u);\n  v3 = a1[10];\n  *((_DWORD *)v2 + 10) = a1[9];\n  *((_DWORD *)v2 + 11) = v3;\n  *((_DWORD *)v2 + 12) = 4;\n  *((_DWORD *)v2 + 9) = sub_804DAFA(0x4000u);\n  v6 = sub_808B0B3((int)v2, (int)a1);\n  free(*((void **)v2 + 9));\n  a1[11] = *((_DWORD *)v2 + 2);\n  v4 = *((_DWORD *)v2 + 1);\n  a1[7] = *(_DWORD *)v2;\n  a1[8] = v4;\n  free(v2);\n  return v6;\n}\n"
    ],
    "sub_808B384": [
        "0x808b384",
        "int __usercall sub_808B384@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  void *v2; // ebx\n  int v3; // esi\n  int v4; // ecx\n  size_t v5; // eax\n  int v6; // eax\n  int v7; // edx\n  unsigned int v8; // ecx\n  int v9; // eax\n  unsigned __int16 v10; // dx\n  _BOOL4 v11; // eax\n  _BOOL4 v12; // eax\n  int v13; // eax\n  __int64 v14; // rax\n  int v15; // ecx\n  int v16; // eax\n  int v17; // edx\n  int v18; // edx\n  int v19; // eax\n  int v21; // [esp+4h] [ebp-20h]\n  int v22; // [esp+8h] [ebp-1Ch]\n  unsigned int v23; // [esp+Ch] [ebp-18h]\n  unsigned int v24; // [esp+10h] [ebp-14h]\n  int v25; // [esp+10h] [ebp-14h]\n\n  if ( sub_808EE53(a2, 35615) )\n    return -1;\n  v2 = sub_804DB2E(0xA0u);\n  *((_DWORD *)v2 + 10) = -1;\n  *((_DWORD *)v2 + 11) = -1;\n  *((_DWORD *)v2 + 9) = sub_804DAFA(0x4000u);\n  *((_DWORD *)v2 + 3) = *(_DWORD *)(a1 + 8);\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = *((_DWORD *)v2 + 12);\n    v5 = *((_DWORD *)v2 + 13) - v4;\n    *((_DWORD *)v2 + 13) = v5;\n    memmove(*((void **)v2 + 9), (const void *)(*((_DWORD *)v2 + 9) + v4), v5);\n    *((_DWORD *)v2 + 12) = 0;\n    if ( !sub_808A88F((int)v2, 8) )\n      goto LABEL_19;\n    v6 = *((_DWORD *)v2 + 12);\n    v7 = *((_DWORD *)v2 + 9);\n    v24 = *(_DWORD *)(v7 + v6);\n    v21 = *(_DWORD *)(v7 + v6 + 4);\n    v8 = v24;\n    *((_DWORD *)v2 + 12) = v6 + 8;\n    if ( (_BYTE)v24 != 8 )\n      goto LABEL_19;\n    if ( (v24 & 0x400) != 0 )\n    {\n      if ( !sub_808A88F((int)v2, 2) )\n        goto LABEL_19;\n      v9 = *((_DWORD *)v2 + 12);\n      v10 = *(_WORD *)(*((_DWORD *)v2 + 9) + v9);\n      *((_DWORD *)v2 + 12) = v9 + 2;\n      v22 = v10;\n      v11 = sub_808A88F((int)v2, v10);\n      v8 = v24;\n      if ( !v11 )\n        goto LABEL_19;\n      *((_DWORD *)v2 + 12) += v22;\n    }\n    if ( (v24 & 0x1800) != 0 )\n    {\n      while ( 1 )\n      {\n        v23 = v8;\n        v12 = sub_808A88F((int)v2, 1);\n        v8 = v23;\n        if ( !v12 )\n          break;\n        v13 = *((_DWORD *)v2 + 12);\n        *((_DWORD *)v2 + 12) = v13 + 1;\n        if ( !*(_BYTE *)(*((_DWORD *)v2 + 9) + v13) )\n        {\n          if ( (BYTE1(v23) & 0x18) != 24 )\n            goto LABEL_14;\n          BYTE1(v8) = BYTE1(v23) & 0xE7;\n        }\n      }\nLABEL_19:\n      sub_804D5F4(\"corrupted data\");\n      goto LABEL_28;\n    }\nLABEL_14:\n    *(_DWORD *)(a1 + 48) = (v21 << 16) | HIWORD(v24);\n    if ( (v8 & 0x200) != 0 )\n    {\n      if ( !sub_808A88F((int)v2, 2) )\n        goto LABEL_19;\n      *((_DWORD *)v2 + 12) += 2;\n    }\n    v14 = sub_808B0B3((int)v2, a1);\n    if ( v14 < 0 )\n      goto LABEL_28;\n    v3 += v14;\n    if ( !sub_808A88F((int)v2, 8) )\n      goto LABEL_19;\n    v15 = *((_DWORD *)v2 + 9);\n    v16 = *((_DWORD *)v2 + 12);\n    v25 = *(_DWORD *)(v15 + v16);\n    *((_DWORD *)v2 + 12) = v16 + 4;\n    if ( ~*((_DWORD *)v2 + 2) != v25 )\n      break;\n    v17 = *(_DWORD *)(v15 + v16 + 4);\n    *((_DWORD *)v2 + 12) = v16 + 8;\n    if ( *(_DWORD *)v2 != v17 )\n    {\n      sub_804D5F4(aIncorrectLengt);\n      v3 = -1;\n    }\n    if ( !sub_808A88F((int)v2, 2) )\n      goto LABEL_29;\n    v18 = *((_DWORD *)v2 + 9);\n    v19 = *((_DWORD *)v2 + 12);\n    if ( *(_BYTE *)(v18 + v19) != 31 || *(_BYTE *)(v18 + v19 + 1) != 0x8B )\n      goto LABEL_29;\n    *((_DWORD *)v2 + 12) = v19 + 2;\n  }\n  sub_804D5F4(\"crc error\");\nLABEL_28:\n  v3 = -1;\nLABEL_29:\n  free(*((void **)v2 + 9));\n  free(v2);\n  return v3;\n}\n"
    ],
    "sub_808B5C4": [
        "0x808b5c4",
        "int __usercall sub_808B5C4@<eax>(int *a1@<eax>)\n{\n  ssize_t v2; // eax\n  int v3; // edx\n  unsigned __int8 *v4; // eax\n  int result; // eax\n\n  if ( a1[1] >= (unsigned int)a1[2] )\n  {\n    v2 = sub_804E5BC(0x10000u, a1 + 6, *a1);\n    if ( v2 <= 0 )\n      sub_804D5E0(\"unexpected EOF\");\n    a1[2] = (int)a1 + v2 + 24;\n    a1[1] = (int)(a1 + 6);\n  }\n  a1[4] <<= 8;\n  v3 = a1[3] << 8;\n  v4 = (unsigned __int8 *)a1[1];\n  a1[1] = (int)(v4 + 1);\n  result = v3 | *v4;\n  a1[3] = result;\n  return result;\n}\n"
    ],
    "sub_808B617": [
        "0x808b617",
        "int __usercall sub_808B617@<eax>(int *a1@<eax>, _WORD *a2@<edx>)\n{\n  int v4; // edi\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  unsigned int v7; // ecx\n\n  if ( (unsigned int)a1[4] <= 0xFFFFFF )\n    sub_808B5C4(a1);\n  v4 = (unsigned __int16)*a2;\n  v5 = a1[4];\n  v6 = v4 * (v5 >> 11);\n  a1[5] = v6;\n  v7 = a1[3];\n  if ( v6 <= v7 )\n  {\n    a1[4] = v5 - v6;\n    a1[3] = v7 - v6;\n    *a2 = v4 - ((unsigned __int16)v4 >> 5);\n    return 1;\n  }\n  else\n  {\n    a1[4] = v6;\n    *a2 = v4 + ((2048 - v4) >> 5);\n    return 0;\n  }\n}\n"
    ],
    "sub_808B67C": [
        "0x808b67c",
        "int __usercall sub_808B67C@<eax>(int a1@<eax>)\n{\n  int v1; // esi\n  __int16 v2; // bx\n  int v3; // ebx\n  int v4; // eax\n  int v5; // ebx\n  unsigned int v6; // ecx\n  int v7; // edi\n  int v8; // esi\n  int v9; // edi\n  unsigned int v10; // eax\n  int v11; // esi\n  int v12; // eax\n  unsigned int v13; // eax\n  int v14; // esi\n  int v15; // eax\n  _WORD *v16; // esi\n  bool v17; // zf\n  int v18; // eax\n  int v19; // eax\n  int v20; // ebx\n  int v21; // ecx\n  int v22; // esi\n  int v23; // edi\n  int v24; // eax\n  int v25; // eax\n  int v26; // edi\n  int v27; // esi\n  int i; // ebx\n  int v29; // eax\n  int v30; // ebx\n  int v31; // edi\n  int v32; // ebx\n  int v33; // ecx\n  int v34; // ebx\n  unsigned int v35; // eax\n  unsigned int v36; // edx\n  int v37; // ecx\n  int v38; // esi\n  int v39; // esi\n  int v40; // eax\n  size_t v41; // eax\n  int v42; // eax\n  int v44; // [esp+0h] [ebp-68h]\n  int v45; // [esp+0h] [ebp-68h]\n  int v46; // [esp+4h] [ebp-64h]\n  int v47; // [esp+8h] [ebp-60h]\n  int v48; // [esp+Ch] [ebp-5Ch]\n  int v49; // [esp+10h] [ebp-58h]\n  int v50; // [esp+14h] [ebp-54h]\n  char v51; // [esp+1Ch] [ebp-4Ch]\n  size_t v52; // [esp+20h] [ebp-48h]\n  int v54; // [esp+28h] [ebp-40h]\n  int v55; // [esp+28h] [ebp-40h]\n  _BYTE *v56; // [esp+2Ch] [ebp-3Ch]\n  int v57; // [esp+30h] [ebp-38h]\n  int v58; // [esp+34h] [ebp-34h]\n  int j; // [esp+34h] [ebp-34h]\n  int v60; // [esp+38h] [ebp-30h]\n  _WORD *v61; // [esp+3Ch] [ebp-2Ch]\n  unsigned int v62; // [esp+40h] [ebp-28h]\n  int v63; // [esp+44h] [ebp-24h]\n  int *ptr; // [esp+48h] [ebp-20h]\n  unsigned __int8 buf; // [esp+4Fh] [ebp-19h] BYREF\n  unsigned int v66; // [esp+50h] [ebp-18h]\n  unsigned __int64 v67; // [esp+54h] [ebp-14h]\n\n  if ( sub_804E5E3(*(_DWORD *)(a1 + 8), (char *)&buf, 0xDu) == 13 && buf <= 0xE0u )\n  {\n    v51 = buf % 9u;\n    v2 = (unsigned __int8)(buf / 9u) % 5;\n    v47 = (1 << ((unsigned __int8)(buf / 9u) / 5)) - 1;\n    v46 = (1 << v2) - 1;\n    if ( !v66 )\n      v66 = 1;\n    v52 = v66;\n    if ( v66 > v67 )\n      v52 = v67;\n    v56 = sub_804DAFA(v52);\n    v3 = (768 << (v51 + v2)) + 1846;\n    v61 = sub_804DAFA(2 * v3);\n    v4 = 0;\n    do\n      v61[v4++] = 1024;\n    while ( v3 > v4 );\n    v5 = *(_DWORD *)(a1 + 8);\n    ptr = (int *)sub_804DB2E(0x10018u);\n    *ptr = v5;\n    sub_808B5C4(ptr);\n    sub_808B5C4(ptr);\n    sub_808B5C4(ptr);\n    sub_808B5C4(ptr);\n    sub_808B5C4(ptr);\n    ptr[4] = -1;\n    v54 = 1;\n    v57 = 1;\n    v60 = 1;\n    v58 = 1;\n    v63 = 0;\n    v49 = 0;\n    v62 = 0;\n    LOBYTE(v5) = 0;\n    v50 = 0;\nLABEL_11:\n    v6 = v49 + v62;\n    if ( v6 >= v67 )\n    {\nLABEL_76:\n      v1 = v50 + v62;\n      if ( sub_808EE9C(v62, v56) == v62 )\n        goto LABEL_91;\n      goto LABEL_68;\n    }\n    v7 = v6 & v47;\n    v8 = (v6 & v47) + 16 * v63;\n    if ( !sub_808B617(ptr, &v61[v8]) )\n    {\n      v9 = (int)&v61[768 * ((int)(unsigned __int8)v5 >> (8 - v51)) + 1846 + 768 * ((v46 & (v49 + v62)) << v51)];\n      if ( v63 <= 6 )\n      {\n        v5 = 1;\n      }\n      else\n      {\n        v10 = v62 - v58;\n        if ( (int)(v62 - v58) < 0 )\n          v10 += v66;\n        v11 = (unsigned __int8)v56[v10];\n        v5 = 1;\n        while ( 1 )\n        {\n          v11 *= 2;\n          v12 = sub_808B617(ptr, (_WORD *)(v9 + 2 * (v5 + (v11 & 0x100) + 256)));\n          v5 = v12 + 2 * v5;\n          if ( (v11 & 0x100) != v12 << 8 )\n            break;\n          if ( v5 > 255 )\n            goto LABEL_24;\n        }\n      }\n      while ( v5 <= 255 )\n        v5 = sub_808B617(ptr, (_WORD *)(v9 + 2 * v5)) + 2 * v5;\nLABEL_24:\n      v63 = (unsigned __int8)byte_80B7ECC[v63];\n      v13 = v62;\n      v14 = 1;\n      goto LABEL_83;\n    }\n    v15 = sub_808B617(ptr, &v61[v63 + 192]);\n    if ( v15 )\n    {\n      if ( sub_808B617(ptr, &v61[v63 + 204]) )\n      {\n        if ( sub_808B617(ptr, &v61[v63 + 216]) )\n        {\n          v17 = sub_808B617(ptr, &v61[v63 + 228]) == 0;\n          v18 = v60;\n          if ( v17 )\n          {\n            v60 = v57;\n          }\n          else\n          {\n            v60 = v54;\n            v54 = v57;\n          }\n          v57 = v18;\n        }\n      }\n      else\n      {\n        if ( !sub_808B617(ptr, &v61[v8 + 240]) )\n        {\n          v14 = 1;\n          if ( v63 > 6 )\n            v63 = 11;\n          else\n            v63 = 9;\nLABEL_80:\n          while ( 1 )\n          {\n            v41 = v62 - v58;\n            if ( (int)(v62 - v58) < 0 )\n            {\n              v41 += v66;\n              if ( v52 <= v41 )\n                goto LABEL_68;\n            }\n            LOBYTE(v5) = v56[v41];\n            v13 = v62;\nLABEL_83:\n            ++v62;\n            v56[v13] = v5;\n            if ( v66 == v62 )\n            {\n              v49 += v62;\n              v42 = sub_808EE9C(v62, v56);\n              if ( v42 != v66 )\n                goto LABEL_68;\n              v50 += v42;\n              v62 = 0;\n            }\n            if ( !--v14 || v62 >= v67 )\n              goto LABEL_11;\n          }\n        }\n        v19 = v60;\n        v60 = v58;\n        v58 = v19;\n      }\n      if ( v63 > 6 )\n        v63 = 11;\n      else\n        v63 = 8;\n      v16 = v61 + 1332;\n      v48 = v58;\n      v58 = v60;\n      v60 = v57;\n      v57 = v54;\n    }\n    else\n    {\n      if ( v63 > 6 )\n        v15 = 3;\n      v16 = v61 + 818;\n      v48 = v58;\n      v63 = v15;\n    }\n    v20 = sub_808B617(ptr, v16);\n    if ( v20 )\n    {\n      if ( sub_808B617(ptr, v16 + 1) )\n      {\n        v21 = (int)(v16 + 258);\n        v20 = 16;\n        v22 = 8;\nLABEL_49:\n        v23 = v22;\n        v24 = 1;\n        while ( --v23 != -1 )\n        {\n          v44 = v21;\n          v24 = 2 * v24 + sub_808B617(ptr, (_WORD *)(v21 + 2 * v24));\n          v21 = v44;\n        }\n        v25 = v20 + v24 - (1 << v22);\n        v55 = v25;\n        if ( v63 > 3 )\n          goto LABEL_78;\n        v63 += 7;\n        if ( v25 > 3 )\n          v25 = 3;\n        v26 = (v25 << 7) + 864;\n        v27 = 7;\n        for ( i = 1; --v27; i = sub_808B617(ptr, (_WORD *)((char *)&v61[i] + v26)) + 2 * i )\n          ;\n        v29 = i - 64;\n        v30 = v29;\n        if ( v29 <= 3 )\n        {\nLABEL_75:\n          v58 = v30 + 1;\n          if ( v30 == -1 )\n            goto LABEL_76;\nLABEL_78:\n          v14 = v55 + 2;\n          v54 = v57;\n          v57 = v60;\n          v60 = v48;\n          goto LABEL_80;\n        }\n        v31 = (v29 >> 1) - 1;\n        v32 = v29 & 1 | 2;\n        if ( v29 <= 13 )\n        {\n          v30 = v32 << v31;\n          v33 = (int)&v61[v30 - v29 + 687];\n          goto LABEL_70;\n        }\n        while ( v31 != 4 )\n        {\n          v34 = 2 * v32;\n          if ( (unsigned int)ptr[4] <= 0xFFFFFF )\n            sub_808B5C4(ptr);\n          v35 = (unsigned int)ptr[4] >> 1;\n          ptr[4] = v35;\n          v36 = ptr[3];\n          v37 = 0;\n          if ( v35 <= v36 )\n          {\n            ptr[3] = v36 - v35;\n            v37 = 1;\n          }\n          v32 = v37 | v34;\n          --v31;\n        }\n        v30 = 16 * v32;\n        if ( v30 >= 0 )\n        {\n          v33 = (int)(v61 + 802);\nLABEL_70:\n          v38 = 1;\n          for ( j = 1; --v31 != -1; j *= 2 )\n          {\n            v39 = 2 * v38;\n            v45 = v33;\n            v40 = sub_808B617(ptr, (_WORD *)(v33 + v39));\n            v38 = v40 + v39;\n            v33 = v45;\n            if ( v40 )\n              v30 |= j;\n          }\n          goto LABEL_75;\n        }\nLABEL_68:\n        sub_804D5F4(\"corrupted data\");\n        v1 = -1;\nLABEL_91:\n        free(ptr);\n        free(v61);\n        free(v56);\n        return v1;\n      }\n      v21 = (int)&v16[8 * v7 + 130];\n      v20 = 8;\n    }\n    else\n    {\n      v21 = (int)&v16[8 * v7 + 2];\n    }\n    v22 = 3;\n    goto LABEL_49;\n  }\n  sub_804D5F4(\"bad lzma header\");\n  return -1;\n}\n"
    ],
    "sub_808BC63": [
        "0x808bc63",
        "char __usercall sub_808BC63@<al>(int *a1@<eax>, unsigned int *a2@<edx>, unsigned int a3@<ecx>)\n{\n  char result; // al\n  unsigned int v5; // esi\n  unsigned int v6; // edx\n  unsigned int v7; // eax\n  int v8; // edi\n  int v9; // ecx\n  unsigned int v10; // edx\n\n  if ( a1[3] <= a3 )\n    return 0;\n  result = 0;\n  if ( a1[6] > a3 )\n  {\n    v5 = a1[4] - a1[2];\n    if ( v5 > *a2 )\n      v5 = *a2;\n    *a2 -= v5;\n    v6 = a1[2];\n    v7 = v6 + ~a3;\n    if ( v6 <= a3 )\n      v7 += a1[5];\n    do\n    {\n      v8 = *a1;\n      v9 = a1[2];\n      a1[2] = v9 + 1;\n      *(_BYTE *)(v8 + v9) = *(_BYTE *)(v8 + v7++);\n      if ( a1[5] == v7 )\n        v7 = 0;\n      --v5;\n    }\n    while ( v5 );\n    v10 = a1[2];\n    result = 1;\n    if ( a1[3] < v10 )\n      a1[3] = v10;\n  }\n  return result;\n}\n"
    ],
    "sub_808BCC8": [
        "0x808bcc8",
        "_DWORD *__usercall sub_808BCC8@<eax>(_DWORD *result@<eax>, unsigned __int16 *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // esi\n  int v4; // ebx\n  int v5; // ecx\n  int v6; // ebp\n  unsigned int v7; // edi\n  unsigned int v8; // ebx\n  unsigned int v9; // ecx\n  unsigned int v10; // ebx\n  int v11; // esi\n  int v12; // ecx\n  int v13; // ebp\n  unsigned int v14; // ebx\n  unsigned int v15; // esi\n  unsigned int v16; // ebp\n  unsigned int v17; // edx\n  int v18; // ecx\n  int v19; // esi\n  int v20; // ebx\n  int v21; // ecx\n  unsigned int v22; // ebx\n  unsigned int v23; // esi\n  int v25; // [esp+0h] [ebp-1Ch]\n  _WORD *v26; // [esp+4h] [ebp-18h]\n\n  v3 = result[1];\n  if ( *result <= 0xFFFFFFu )\n  {\n    *result <<= 8;\n    v4 = result[3];\n    v5 = result[4];\n    result[4] = v5 + 1;\n    result[1] = *(unsigned __int8 *)(v4 + v5) + (v3 << 8);\n  }\n  v6 = *a2;\n  v7 = v6 * (*result >> 11);\n  v8 = result[1];\n  if ( v7 <= v8 )\n  {\n    v9 = *result - v7;\n    *result = v9;\n    v10 = v8 - v7;\n    result[1] = v10;\n    *a2 = v6 - ((unsigned __int16)v6 >> 5);\n    if ( v9 <= 0xFFFFFF )\n    {\n      *result = v9 << 8;\n      v11 = result[3];\n      v12 = result[4];\n      result[4] = v12 + 1;\n      result[1] = *(unsigned __int8 *)(v11 + v12) + (v10 << 8);\n    }\n    v13 = a2[1];\n    v14 = v13 * (*result >> 11);\n    v15 = result[1];\n    if ( v14 <= v15 )\n    {\n      *result -= v14;\n      result[1] = v15 - v14;\n      a2[1] = v13 - ((unsigned __int16)v13 >> 5);\n      v25 = (int)(a2 + 258);\n      result[26] = 18;\n      v16 = 256;\n      goto LABEL_11;\n    }\n    *result = v14;\n    a2[1] = ((2048 - v13) >> 5) + v13;\n    v25 = (int)&a2[8 * a3 + 130];\n    result[26] = 10;\n  }\n  else\n  {\n    *result = v7;\n    *a2 = ((2048 - v6) >> 5) + v6;\n    v25 = (int)&a2[8 * a3 + 2];\n    result[26] = 2;\n  }\n  v16 = 8;\nLABEL_11:\n  v17 = 1;\n  do\n  {\n    v26 = (_WORD *)(v25 + 2 * v17);\n    v18 = result[1];\n    if ( *result <= 0xFFFFFFu )\n    {\n      *result <<= 8;\n      v19 = result[3];\n      v20 = result[4];\n      result[4] = v20 + 1;\n      result[1] = *(unsigned __int8 *)(v19 + v20) + (v18 << 8);\n    }\n    v21 = (unsigned __int16)*v26;\n    v22 = v21 * (*result >> 11);\n    v23 = result[1];\n    v17 *= 2;\n    if ( v22 <= v23 )\n    {\n      *result -= v22;\n      result[1] = v23 - v22;\n      *v26 = v21 - ((unsigned __int16)v21 >> 5);\n      ++v17;\n    }\n    else\n    {\n      *result = v22;\n      *v26 = ((2048 - v21) >> 5) + v21;\n    }\n  }\n  while ( v16 > v17 );\n  result[26] = result[26] - v16 + v17;\n  return result;\n}\n"
    ],
    "sub_808BE8A": [
        "0x808be8a",
        "char __usercall sub_808BE8A@<al>(int a1@<eax>)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // eax\n  unsigned int v5; // edx\n  int v6; // ecx\n  int v7; // esi\n  int v8; // ebp\n  int v9; // esi\n  unsigned int v10; // edi\n  unsigned int v11; // ecx\n  int v12; // ecx\n  int v13; // ebp\n  unsigned int v14; // esi\n  unsigned int v15; // ebp\n  _WORD *v16; // ecx\n  int v17; // eax\n  int v18; // esi\n  int v19; // edx\n  int v20; // eax\n  unsigned int v21; // edx\n  unsigned int v22; // esi\n  int v23; // edx\n  int v24; // eax\n  unsigned int v25; // eax\n  unsigned int v26; // eax\n  unsigned int v27; // eax\n  unsigned int v28; // esi\n  unsigned int v29; // ecx\n  unsigned int v30; // edx\n  int v31; // eax\n  int v32; // edi\n  int v33; // eax\n  int v34; // ecx\n  int v35; // edx\n  int v36; // eax\n  unsigned int v37; // edx\n  unsigned int v38; // ecx\n  unsigned int v39; // eax\n  unsigned int v40; // edx\n  unsigned int v41; // ecx\n  int v42; // edx\n  int v43; // eax\n  unsigned __int16 *v44; // eax\n  int v45; // esi\n  unsigned int v46; // edi\n  unsigned int v47; // ecx\n  unsigned int v48; // eax\n  unsigned int v49; // eax\n  _WORD *v50; // edx\n  int v51; // ecx\n  int v52; // edi\n  int v53; // esi\n  int v54; // ecx\n  unsigned int v55; // esi\n  unsigned int v56; // edi\n  unsigned int v57; // eax\n  int v58; // edx\n  int v59; // edx\n  int v60; // ebp\n  _WORD *v61; // edi\n  int v62; // eax\n  int v63; // ecx\n  int v64; // edx\n  int v65; // eax\n  unsigned int v66; // edx\n  int v67; // ecx\n  int v68; // edx\n  int v69; // eax\n  int v70; // eax\n  int v71; // edx\n  int v72; // eax\n  int v73; // eax\n  _WORD *v74; // ebp\n  int v75; // edx\n  int v76; // esi\n  int v77; // ecx\n  int v78; // edx\n  unsigned int v79; // ecx\n  unsigned int v80; // edx\n  unsigned int v81; // ecx\n  int v82; // esi\n  int v83; // edx\n  int v84; // edi\n  unsigned int v85; // ecx\n  unsigned int v86; // edx\n  int v87; // ecx\n  int v88; // eax\n  unsigned int v89; // esi\n  unsigned int v90; // edx\n  int v91; // esi\n  int v92; // ecx\n  int v93; // edi\n  unsigned int v94; // edx\n  unsigned int v95; // ecx\n  int v96; // ebp\n  unsigned int v97; // edi\n  unsigned int v98; // ecx\n  unsigned int v99; // ecx\n  int v100; // esi\n  int v101; // edx\n  int v102; // edx\n  unsigned int v103; // ecx\n  unsigned int v104; // esi\n  int v105; // ebp\n  int v106; // eax\n  char result; // al\n  unsigned int v108; // [esp+0h] [ebp-2Ch]\n  int v109; // [esp+0h] [ebp-2Ch]\n  unsigned int v110; // [esp+0h] [ebp-2Ch]\n  int v111; // [esp+0h] [ebp-2Ch]\n  int v112; // [esp+0h] [ebp-2Ch]\n  int v113; // [esp+4h] [ebp-28h]\n  int v114; // [esp+4h] [ebp-28h]\n  int v115; // [esp+4h] [ebp-28h]\n  unsigned int v116; // [esp+4h] [ebp-28h]\n  unsigned int v117; // [esp+4h] [ebp-28h]\n  _WORD *v118; // [esp+8h] [ebp-24h]\n  unsigned int v119; // [esp+8h] [ebp-24h]\n  unsigned int v120; // [esp+8h] [ebp-24h]\n  int v121; // [esp+Ch] [ebp-20h]\n  int v122; // [esp+10h] [ebp-1Ch]\n  int v123; // [esp+14h] [ebp-18h]\n  int v124; // [esp+18h] [ebp-14h]\n\n  if ( *(_DWORD *)(a1 + 40) > *(_DWORD *)(a1 + 32) )\n  {\n    if ( *(_DWORD *)(a1 + 104) )\n      sub_808BC63((int *)(a1 + 24), (unsigned int *)(a1 + 104), *(_DWORD *)(a1 + 84));\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v27 = *(_DWORD *)(a1 + 32);\n        v28 = *(_DWORD *)a1;\n        if ( v27 >= *(_DWORD *)(a1 + 40) )\n          goto LABEL_2;\n        v5 = *(_DWORD *)(a1 + 16);\n        if ( v5 > *(_DWORD *)(a1 + 20) )\n          goto LABEL_2;\n        v113 = v27 & *(_DWORD *)(a1 + 116);\n        v108 = *(_DWORD *)(a1 + 100);\n        v6 = *(_DWORD *)(a1 + 4);\n        if ( v28 <= 0xFFFFFF )\n        {\n          *(_DWORD *)a1 = v28 << 8;\n          v7 = *(_DWORD *)(a1 + 12);\n          *(_DWORD *)(a1 + 16) = v5 + 1;\n          *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v7 + v5) + (v6 << 8);\n        }\n        v8 = a1 + 2 * (v113 + 16 * v108);\n        v9 = *(unsigned __int16 *)(v8 + 120);\n        v10 = v9 * (*(_DWORD *)a1 >> 11);\n        v11 = *(_DWORD *)(a1 + 4);\n        if ( v10 <= v11 )\n          break;\n        *(_DWORD *)a1 = v10;\n        *(_WORD *)(v8 + 120) = ((2048 - v9) >> 5) + v9;\n        v12 = v27 - 1;\n        if ( !v27 )\n          v12 = *(_DWORD *)(a1 + 44) - 1;\n        v13 = *(_DWORD *)(a1 + 36);\n        v14 = 0;\n        if ( v13 )\n          v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 24) + v12);\n        v121 = a1\n             + 1536 * (((v27 & *(_DWORD *)(a1 + 112)) << *(_BYTE *)(a1 + 108)) + (v14 >> (8 - *(_BYTE *)(a1 + 108))))\n             + 3812;\n        if ( v108 > 6 )\n        {\n          v29 = *(_DWORD *)(a1 + 84);\n          v30 = v27 - 1 - v29;\n          if ( v27 <= v29 )\n            v30 += *(_DWORD *)(a1 + 44);\n          v31 = 0;\n          if ( v13 )\n            v31 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 24) + v30);\n          v109 = 2 * v31;\n          v32 = 256;\n          v15 = 1;\n          do\n          {\n            v114 = v32 & v109;\n            v109 *= 2;\n            v118 = (_WORD *)(v121 + 2 * (v114 + v32 + v15));\n            v33 = *(_DWORD *)(a1 + 4);\n            if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n            {\n              *(_DWORD *)a1 <<= 8;\n              v34 = *(_DWORD *)(a1 + 12);\n              v35 = *(_DWORD *)(a1 + 16);\n              *(_DWORD *)(a1 + 16) = v35 + 1;\n              *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v34 + v35) + (v33 << 8);\n            }\n            v36 = (unsigned __int16)*v118;\n            v37 = v36 * (*(_DWORD *)a1 >> 11);\n            v38 = *(_DWORD *)(a1 + 4);\n            v15 *= 2;\n            if ( v37 <= v38 )\n            {\n              *(_DWORD *)a1 -= v37;\n              *(_DWORD *)(a1 + 4) = v38 - v37;\n              *v118 = v36 - ((unsigned __int16)v36 >> 5);\n              ++v15;\n              v32 = v114;\n            }\n            else\n            {\n              *(_DWORD *)a1 = v37;\n              *v118 = ((2048 - v36) >> 5) + v36;\n              v32 &= ~v114;\n            }\n          }\n          while ( v15 <= 0xFF );\n        }\n        else\n        {\n          v15 = 1;\n          do\n          {\n            v16 = (_WORD *)(v121 + 2 * v15);\n            v17 = *(_DWORD *)(a1 + 4);\n            if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n            {\n              *(_DWORD *)a1 <<= 8;\n              v18 = *(_DWORD *)(a1 + 12);\n              v19 = *(_DWORD *)(a1 + 16);\n              *(_DWORD *)(a1 + 16) = v19 + 1;\n              *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v18 + v19) + (v17 << 8);\n            }\n            v20 = (unsigned __int16)*v16;\n            v21 = v20 * (*(_DWORD *)a1 >> 11);\n            v22 = *(_DWORD *)(a1 + 4);\n            v15 *= 2;\n            if ( v21 <= v22 )\n            {\n              *(_DWORD *)a1 -= v21;\n              *(_DWORD *)(a1 + 4) = v22 - v21;\n              *v16 = v20 - ((unsigned __int16)v20 >> 5);\n              ++v15;\n            }\n            else\n            {\n              *(_DWORD *)a1 = v21;\n              *v16 = ((2048 - v20) >> 5) + v20;\n            }\n          }\n          while ( v15 <= 0xFF );\n        }\n        v23 = *(_DWORD *)(a1 + 24);\n        v24 = *(_DWORD *)(a1 + 32);\n        *(_DWORD *)(a1 + 32) = v24 + 1;\n        *(_BYTE *)(v23 + v24) = v15;\n        v25 = *(_DWORD *)(a1 + 32);\n        if ( *(_DWORD *)(a1 + 36) < v25 )\n          *(_DWORD *)(a1 + 36) = v25;\n        v26 = *(_DWORD *)(a1 + 100);\n        if ( v26 > 3 )\n        {\n          if ( v26 > 9 )\n            v39 = v26 - 6;\n          else\n            v39 = v26 - 3;\n          *(_DWORD *)(a1 + 100) = v39;\n        }\n        else\n        {\n          *(_DWORD *)(a1 + 100) = 0;\n        }\n      }\n      v40 = *(_DWORD *)a1 - v10;\n      *(_DWORD *)a1 = v40;\n      v41 = v11 - v10;\n      *(_DWORD *)(a1 + 4) = v41;\n      *(_WORD *)(v8 + 120) = v9 - ((unsigned __int16)v9 >> 5);\n      if ( v40 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = v40 << 8;\n        v42 = *(_DWORD *)(a1 + 12);\n        v43 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v43 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v42 + v43) + (v41 << 8);\n      }\n      v44 = (unsigned __int16 *)(a1 + 2 * v108);\n      v45 = v44[252];\n      v46 = v45 * (*(_DWORD *)a1 >> 11);\n      v47 = *(_DWORD *)(a1 + 4);\n      if ( v46 > v47 )\n      {\n        *(_DWORD *)a1 = v46;\n        v44[252] = ((2048 - v45) >> 5) + v45;\n        *(_DWORD *)(a1 + 100) = v108 < 7 ? 7 : 10;\n        *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 92);\n        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 88);\n        *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 84);\n        sub_808BCC8((_DWORD *)a1, (unsigned __int16 *)(a1 + 1756), v113);\n        v48 = *(_DWORD *)(a1 + 104);\n        if ( v48 > 5 )\n          v48 = 5;\n        v115 = (v48 << 7) + 728;\n        v49 = 1;\n        do\n        {\n          v50 = (_WORD *)(a1 + v115 + 2 * v49);\n          v51 = *(_DWORD *)(a1 + 4);\n          if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n          {\n            *(_DWORD *)a1 <<= 8;\n            v52 = *(_DWORD *)(a1 + 12);\n            v53 = *(_DWORD *)(a1 + 16);\n            *(_DWORD *)(a1 + 16) = v53 + 1;\n            *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v52 + v53) + (v51 << 8);\n          }\n          v54 = (unsigned __int16)*v50;\n          v55 = v54 * (*(_DWORD *)a1 >> 11);\n          v56 = *(_DWORD *)(a1 + 4);\n          v49 *= 2;\n          if ( v55 <= v56 )\n          {\n            *(_DWORD *)a1 -= v55;\n            *(_DWORD *)(a1 + 4) = v56 - v55;\n            *v50 = v54 - ((unsigned __int16)v54 >> 5);\n            ++v49;\n          }\n          else\n          {\n            *(_DWORD *)a1 = v55;\n            *v50 = ((2048 - v54) >> 5) + v54;\n          }\n        }\n        while ( v49 <= 0x3F );\n        v57 = v49 - 64;\n        if ( v57 > 3 )\n        {\n          v116 = (v57 >> 1) - 1;\n          v58 = (v57 & 1) + 2;\n          *(_DWORD *)(a1 + 84) = v58;\n          if ( v57 > 0xD )\n          {\n            v111 = (v57 >> 1) - 5;\n            do\n            {\n              v67 = *(_DWORD *)(a1 + 4);\n              if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n              {\n                *(_DWORD *)a1 <<= 8;\n                v68 = *(_DWORD *)(a1 + 12);\n                v69 = *(_DWORD *)(a1 + 16);\n                *(_DWORD *)(a1 + 16) = v69 + 1;\n                *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v68 + v69) + (v67 << 8);\n              }\n              v70 = *(_DWORD *)a1 >> 1;\n              *(_DWORD *)a1 = v70;\n              v71 = (*(_DWORD *)(a1 + 4) - v70) >> 31;\n              *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) - v70 + (v71 & v70);\n              v72 = v71 + 2 * *(_DWORD *)(a1 + 84) + 1;\n              *(_DWORD *)(a1 + 84) = v72;\n              --v111;\n            }\n            while ( v111 );\n            *(_DWORD *)(a1 + 84) = 16 * v72;\n            v73 = 1;\n            do\n            {\n              v74 = (_WORD *)(a1 + 1724 + 2 * v73);\n              v75 = *(_DWORD *)(a1 + 4);\n              if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n              {\n                *(_DWORD *)a1 <<= 8;\n                v76 = *(_DWORD *)(a1 + 12);\n                v77 = *(_DWORD *)(a1 + 16);\n                *(_DWORD *)(a1 + 16) = v77 + 1;\n                *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v76 + v77) + (v75 << 8);\n              }\n              v78 = (unsigned __int16)*v74;\n              v79 = v78 * (*(_DWORD *)a1 >> 11);\n              v117 = *(_DWORD *)(a1 + 4);\n              v73 *= 2;\n              v122 = *(_DWORD *)(a1 + 84);\n              if ( v79 <= v117 )\n              {\n                *(_DWORD *)a1 -= v79;\n                *(_DWORD *)(a1 + 4) = v117 - v79;\n                *v74 = v78 - ((unsigned __int16)v78 >> 5);\n                ++v73;\n                *(_DWORD *)(a1 + 84) = v122 + (1 << v111);\n              }\n              else\n              {\n                *(_DWORD *)a1 = v79;\n                *v74 = ((2048 - v78) >> 5) + v78;\n              }\n              ++v111;\n            }\n            while ( v111 != 4 );\n          }\n          else\n          {\n            v59 = v58 << v116;\n            *(_DWORD *)(a1 + 84) = v59;\n            v124 = 2 * (v59 - v57 + 0x7FFFFFFF);\n            v110 = 0;\n            v60 = 1;\n            do\n            {\n              v61 = (_WORD *)(v124 + 2 * v60 + a1 + 1496);\n              v62 = *(_DWORD *)(a1 + 4);\n              if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n              {\n                *(_DWORD *)a1 <<= 8;\n                v63 = *(_DWORD *)(a1 + 12);\n                v64 = *(_DWORD *)(a1 + 16);\n                *(_DWORD *)(a1 + 16) = v64 + 1;\n                *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v63 + v64) + (v62 << 8);\n              }\n              v65 = (unsigned __int16)*v61;\n              v66 = v65 * (*(_DWORD *)a1 >> 11);\n              v119 = *(_DWORD *)(a1 + 4);\n              v60 *= 2;\n              v123 = *(_DWORD *)(a1 + 84);\n              if ( v66 <= v119 )\n              {\n                *(_DWORD *)a1 -= v66;\n                *(_DWORD *)(a1 + 4) = v119 - v66;\n                *v61 = v65 - ((unsigned __int16)v65 >> 5);\n                ++v60;\n                *(_DWORD *)(a1 + 84) = (1 << v110) + v123;\n              }\n              else\n              {\n                *(_DWORD *)a1 = v66;\n                *v61 = ((2048 - v65) >> 5) + v65;\n              }\n              ++v110;\n            }\n            while ( v116 > v110 );\n          }\n        }\n        else\n        {\n          *(_DWORD *)(a1 + 84) = v57;\n        }\n        goto LABEL_99;\n      }\n      v80 = *(_DWORD *)a1 - v46;\n      *(_DWORD *)a1 = v80;\n      v81 = v47 - v46;\n      *(_DWORD *)(a1 + 4) = v81;\n      v44[252] = v45 - ((unsigned __int16)v45 >> 5);\n      if ( v80 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = v80 << 8;\n        v82 = *(_DWORD *)(a1 + 12);\n        v83 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v83 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v82 + v83) + (v81 << 8);\n      }\n      v84 = v44[264];\n      v85 = v84 * (*(_DWORD *)a1 >> 11);\n      v86 = *(_DWORD *)(a1 + 4);\n      if ( v85 <= v86 )\n        break;\n      *(_DWORD *)a1 = v85;\n      v44[264] = v84 + ((2048 - v84) >> 5);\n      if ( v85 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = v85 << 8;\n        v87 = *(_DWORD *)(a1 + 12);\n        v88 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v88 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v87 + v88) + (v86 << 8);\n      }\n      v93 = *(unsigned __int16 *)(v8 + 600);\n      v94 = v93 * (*(_DWORD *)a1 >> 11);\n      v95 = *(_DWORD *)(a1 + 4);\n      if ( v94 <= v95 )\n      {\n        *(_DWORD *)a1 -= v94;\n        *(_DWORD *)(a1 + 4) = v95 - v94;\n        *(_WORD *)(v8 + 600) = v93 - ((unsigned __int16)v93 >> 5);\nLABEL_98:\n        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 100) < 7u ? 8 : 11;\n        sub_808BCC8((_DWORD *)a1, (unsigned __int16 *)(a1 + 2784), v113);\n        goto LABEL_99;\n      }\n      *(_DWORD *)a1 = v94;\n      *(_WORD *)(v8 + 600) = ((2048 - v93) >> 5) + v93;\n      *(_DWORD *)(a1 + 100) = v108 < 7 ? 9 : 11;\n      *(_DWORD *)(a1 + 104) = 1;\nLABEL_99:\n      result = sub_808BC63((int *)(a1 + 24), (unsigned int *)(a1 + 104), *(_DWORD *)(a1 + 84));\n      if ( !result )\n        return result;\n    }\n    v89 = *(_DWORD *)a1 - v85;\n    *(_DWORD *)a1 = v89;\n    v90 = v86 - v85;\n    *(_DWORD *)(a1 + 4) = v90;\n    v44[264] = v84 - ((unsigned __int16)v84 >> 5);\n    if ( v89 <= 0xFFFFFF )\n    {\n      *(_DWORD *)a1 = v89 << 8;\n      v91 = *(_DWORD *)(a1 + 12);\n      v92 = *(_DWORD *)(a1 + 16);\n      *(_DWORD *)(a1 + 16) = v92 + 1;\n      *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v91 + v92) + (v90 << 8);\n    }\n    v120 = *(_DWORD *)a1;\n    v96 = v44[276];\n    v97 = v96 * (*(_DWORD *)a1 >> 11);\n    v98 = *(_DWORD *)(a1 + 4);\n    v112 = *(_DWORD *)(a1 + 88);\n    if ( v97 <= v98 )\n    {\n      *(_DWORD *)a1 = v120 - v97;\n      v99 = v98 - v97;\n      *(_DWORD *)(a1 + 4) = v99;\n      v44[276] = v96 - ((unsigned __int16)v96 >> 5);\n      if ( v120 - v97 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = (v120 - v97) << 8;\n        v100 = *(_DWORD *)(a1 + 12);\n        v101 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v101 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v100 + v101) + (v99 << 8);\n      }\n      v102 = v44[288];\n      v103 = v102 * (*(_DWORD *)a1 >> 11);\n      v104 = *(_DWORD *)(a1 + 4);\n      v105 = *(_DWORD *)(a1 + 92);\n      if ( v103 <= v104 )\n      {\n        *(_DWORD *)a1 -= v103;\n        *(_DWORD *)(a1 + 4) = v104 - v103;\n        v44[288] = v102 - ((unsigned __int16)v102 >> 5);\n        v106 = *(_DWORD *)(a1 + 96);\n        *(_DWORD *)(a1 + 96) = v105;\n        v105 = v106;\n      }\n      else\n      {\n        *(_DWORD *)a1 = v103;\n        v44[288] = ((2048 - v102) >> 5) + v102;\n      }\n      *(_DWORD *)(a1 + 92) = v112;\n      v112 = v105;\n    }\n    else\n    {\n      *(_DWORD *)a1 = v97;\n      v44[276] = ((2048 - v96) >> 5) + v96;\n    }\n    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 84);\n    *(_DWORD *)(a1 + 84) = v112;\n    goto LABEL_98;\n  }\nLABEL_2:\n  if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n  {\n    *(_DWORD *)a1 <<= 8;\n    v2 = *(_DWORD *)(a1 + 4) << 8;\n    v3 = *(_DWORD *)(a1 + 12);\n    v4 = *(_DWORD *)(a1 + 16);\n    *(_DWORD *)(a1 + 16) = v4 + 1;\n    *(_DWORD *)(a1 + 4) = v2 + *(unsigned __int8 *)(v3 + v4);\n  }\n  return 1;\n}\n"
    ],
    "sub_808C75B": [
        "0x808c75b",
        "int __userpurge sub_808C75B@<eax>(_DWORD *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)\n{\n  char v5; // dl\n  int v6; // ebp\n  int v7; // edi\n  int v8; // esi\n  unsigned int v9; // ecx\n\n  if ( !a1[1] )\n  {\n    a1[2] = 0;\n    a1[3] = 0;\n  }\n  while ( 1 )\n  {\n    v9 = *a3;\n    if ( *a3 >= a4 )\n      return 0;\n    v5 = *(_BYTE *)(a2 + v9);\n    *a3 = v9 + 1;\n    v6 = a1[1];\n    v7 = (unsigned __int64)(v5 & 0x7F) << v6 >> 32;\n    v8 = (v5 & 0x7F) << v6;\n    if ( (v6 & 0x20) != 0 )\n    {\n      v7 = (v5 & 0x7F) << v6;\n      v8 = 0;\n    }\n    a1[2] |= v8;\n    a1[3] |= v7;\n    if ( v5 >= 0 )\n      break;\n    a1[1] = v6 + 7;\n    if ( v6 == 56 )\n      return 7;\n  }\n  if ( v6 && !v5 )\n    return 7;\n  a1[1] = 0;\n  return 1;\n}\n"
    ],
    "sub_808C7FD": [
        "0x808c7fd",
        "int __usercall sub_808C7FD@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v2; // ebp\n  int v3; // esi\n  int v4; // ecx\n  int v5; // ebx\n  unsigned int v6; // ecx\n\n  v2 = a2[2];\n  while ( 1 )\n  {\n    v3 = a2[1];\n    if ( v3 == v2 )\n      return 0;\n    v4 = *(_DWORD *)(a1 + 4);\n    v5 = *(_DWORD *)(a1 + 24) >> v4;\n    a2[1] = v3 + 1;\n    if ( *(_BYTE *)(*a2 + v3) != (_BYTE)v5 )\n      break;\n    v6 = v4 + 8;\n    *(_DWORD *)(a1 + 4) = v6;\n    if ( v6 > 0x1F )\n    {\n      *(_DWORD *)(a1 + 24) = 0;\n      *(_DWORD *)(a1 + 4) = 0;\n      return 1;\n    }\n  }\n  return 7;\n}\n"
    ],
    "sub_808C84E": [
        "0x808c84e",
        "int __usercall sub_808C84E@<eax>(int a1@<eax>)\n{\n  void *v2; // ebx\n  int result; // eax\n\n  *(_DWORD *)a1 = 0;\n  *(_BYTE *)(a1 + 36) = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  *(_DWORD *)(a1 + 24) = 0;\n  v2 = (void *)(a1 + 60);\n  result = 0;\n  memset(v2, 0, 0x2Cu);\n  memset((void *)(a1 + 104), 0, 0x28u);\n  *(_DWORD *)(a1 + 144) = 0;\n  *(_DWORD *)(a1 + 148) = 12;\n  return result;\n}\n"
    ],
    "sub_808C89B": [
        "0x808c89b",
        "int sub_808C89B()\n{\n  return ~sub_80AA41E(dword_80DBB98);\n}\n"
    ],
    "sub_808C8B5": [
        "0x808c8b5",
        "int __usercall sub_808C8B5@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  *(_QWORD *)(a1 + 108) += (unsigned int)(*(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 16));\n  result = sub_808C89B();\n  *(_DWORD *)(a1 + 24) = result;\n  return result;\n}\n"
    ],
    "sub_808C8DF": [
        "0x808c8df",
        "char __usercall sub_808C8DF@<al>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v3; // edi\n  int v4; // esi\n  unsigned int v5; // eax\n  unsigned int v6; // edx\n  char result; // al\n\n  v3 = *(_DWORD *)(a1 + 144);\n  v4 = a2[1];\n  v5 = *(_DWORD *)(a1 + 148) - v3;\n  if ( v5 > a2[2] - v4 )\n    v5 = a2[2] - v4;\n  qmemcpy((void *)(a1 + v3 + 152), (const void *)(*a2 + v4), v5);\n  a2[1] += v5;\n  v6 = *(_DWORD *)(a1 + 144) + v5;\n  *(_DWORD *)(a1 + 144) = v6;\n  result = 0;\n  if ( v6 == *(_DWORD *)(a1 + 148) )\n  {\n    *(_DWORD *)(a1 + 144) = 0;\n    return 1;\n  }\n  return result;\n}\n"
    ],
    "sub_808C93C": [
        "0x808c93c",
        "int __usercall sub_808C93C@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  unsigned int v4; // edx\n  unsigned int v5; // eax\n  int v6; // ecx\n  int v7; // eax\n  unsigned int v8; // eax\n  int i; // eax\n  int v11; // eax\n  int v12; // eax\n  int v13; // eax\n  int v14; // eax\n  int v15; // ecx\n  unsigned __int8 v16; // dl\n  int v17; // ecx\n  int v18; // ecx\n  int j; // edx\n  unsigned int v20; // edi\n  int v21; // edx\n  int v22; // ecx\n  unsigned int v23; // edx\n  int v24; // ecx\n  int v25; // esi\n  unsigned int v26; // eax\n  int v27; // ecx\n  int v28; // edx\n  unsigned int v29; // edx\n  int v30; // eax\n  unsigned int v31; // esi\n  unsigned int v32; // eax\n  unsigned int v33; // ecx\n  size_t v34; // ecx\n  int v35; // edx\n  int v36; // eax\n  int v37; // ecx\n  int v38; // edx\n  unsigned int v39; // ecx\n  unsigned int v40; // eax\n  int v41; // esi\n  unsigned int v42; // edx\n  unsigned int v43; // eax\n  int v44; // esi\n  unsigned int v45; // eax\n  unsigned int v46; // edx\n  unsigned int v47; // edi\n  unsigned int v48; // esi\n  unsigned int v49; // ecx\n  int v50; // edi\n  unsigned int v51; // eax\n  unsigned int v52; // ecx\n  unsigned int v53; // edx\n  unsigned int v54; // edx\n  char *destb; // [esp+0h] [ebp-18h]\n  char *dest; // [esp+0h] [ebp-18h]\n  void *desta; // [esp+0h] [ebp-18h]\n  unsigned int v58; // [esp+4h] [ebp-14h]\n  unsigned int v59; // [esp+4h] [ebp-14h]\n\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      v4 = a2[1];\n      v5 = a2[2];\n      v6 = *(_DWORD *)(a1 + 64);\nLABEL_2:\n      if ( v4 < v5 )\n        break;\n      if ( v6 != 7 )\n        return 0;\nLABEL_41:\n      v23 = a2[5] - a2[4];\n      if ( v23 > *(_DWORD *)(a1 + 72) )\n        v23 = *(_DWORD *)(a1 + 72);\n      v24 = *(_DWORD *)(a1 + 32);\n      if ( v23 < *(_DWORD *)(a1 + 44) - v24 )\n        *(_DWORD *)(a1 + 40) = v24 + v23;\n      else\n        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);\n      v25 = a2[1];\n      v26 = v5 - v25;\n      v27 = *(_DWORD *)(a1 + 28388);\n      v28 = *(_DWORD *)(a1 + 76);\n      if ( v27 || !v28 )\n      {\n        v29 = v28 - v27;\n        if ( v29 > 42 - v27 )\n          v29 = 42 - v27;\n        if ( v29 > v26 )\n          v29 = v26;\n        dest = (char *)(a1 + 28392);\n        qmemcpy((void *)(v27 + a1 + 28392), (const void *)(*a2 + v25), v29);\n        v30 = *(_DWORD *)(a1 + 28388);\n        v31 = v29 + v30;\n        if ( v29 + v30 == *(_DWORD *)(a1 + 76) )\n        {\n          memset(&dest[v31], 0, 63 - v30 - v29);\n          *(_DWORD *)(a1 + 20) = v29 + *(_DWORD *)(a1 + 28388);\n        }\n        else\n        {\n          if ( v31 <= 0x14 )\n          {\n            *(_DWORD *)(a1 + 28388) = v31;\n            a2[1] += v29;\n            goto LABEL_73;\n          }\n          *(_DWORD *)(a1 + 20) = v31 - 21;\n        }\n        v58 = v29;\n        *(_DWORD *)(a1 + 12) = a1 + 28392;\n        *(_DWORD *)(a1 + 16) = 0;\n        if ( !sub_808BE8A(a1) )\n          return 7;\n        v32 = *(_DWORD *)(a1 + 16);\n        v33 = *(_DWORD *)(a1 + 28388);\n        if ( v32 > v33 + v58 )\n          return 7;\n        *(_DWORD *)(a1 + 76) -= v32;\n        if ( v32 < v33 )\n        {\n          v34 = v33 - v32;\n          *(_DWORD *)(a1 + 28388) = v34;\n          memmove(dest, &dest[v32], v34);\n          goto LABEL_73;\n        }\n        a2[1] = a2[1] + v32 - v33;\n        *(_DWORD *)(a1 + 28388) = 0;\n      }\n      v35 = a2[2];\n      v36 = a2[1];\n      if ( (unsigned int)(v35 - v36) > 0x14 )\n      {\n        *(_DWORD *)(a1 + 12) = *a2;\n        *(_DWORD *)(a1 + 16) = v36;\n        v37 = *(_DWORD *)(a1 + 76);\n        if ( v35 - v36 < (unsigned int)(v37 + 21) )\n          *(_DWORD *)(a1 + 20) = v35 - 21;\n        else\n          *(_DWORD *)(a1 + 20) = v37 + v36;\n        if ( !sub_808BE8A(a1) )\n          return 7;\n        v38 = *(_DWORD *)(a1 + 16);\n        v39 = v38 - a2[1];\n        v40 = *(_DWORD *)(a1 + 76);\n        if ( v39 > v40 )\n          return 7;\n        *(_DWORD *)(a1 + 76) = v40 - v39;\n        a2[1] = v38;\n      }\n      v41 = a2[1];\n      v42 = a2[2] - v41;\n      if ( v42 <= 0x14 )\n      {\n        v43 = *(_DWORD *)(a1 + 76);\n        if ( v43 > v42 )\n          v43 = a2[2] - v41;\n        qmemcpy((void *)(a1 + 28392), (const void *)(*a2 + v41), v43);\n        *(_DWORD *)(a1 + 28388) = v43;\n        a2[1] += v43;\n      }\nLABEL_73:\n      v44 = *(_DWORD *)(a1 + 28);\n      v45 = *(_DWORD *)(a1 + 32) - v44;\n      if ( *(_DWORD *)(a1 + 32) == *(_DWORD *)(a1 + 44) )\n        *(_DWORD *)(a1 + 32) = 0;\n      qmemcpy((void *)(a2[3] + a2[4]), (const void *)(*(_DWORD *)(a1 + 24) + v44), v45);\n      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 32);\n      v46 = v45 + a2[4];\n      a2[4] = v46;\n      v47 = *(_DWORD *)(a1 + 72) - v45;\n      *(_DWORD *)(a1 + 72) = v47;\n      if ( v47 )\n      {\n        if ( a2[5] == v46 || a2[1] == a2[2] && *(_DWORD *)(a1 + 28388) < *(_DWORD *)(a1 + 76) )\n          return 0;\n      }\n      else\n      {\n        if ( *(_DWORD *)(a1 + 76) || *(_DWORD *)(a1 + 104) || *(_DWORD *)(a1 + 4) )\n          return 7;\n        *(_DWORD *)a1 = -1;\n        *(_DWORD *)(a1 + 8) = 5;\nLABEL_101:\n        *(_DWORD *)(a1 + 64) = 0;\n      }\n    }\n    switch ( v6 )\n    {\n      case 0:\n        v7 = *a2;\n        a2[1] = v4 + 1;\n        v8 = *(unsigned __int8 *)(v7 + v4);\n        if ( !v8 )\n          return 1;\n        if ( v8 > 0xDF || v8 == 1 )\n        {\n          *(_BYTE *)(a1 + 81) = 1;\n          *(_BYTE *)(a1 + 80) = 0;\n          *(_DWORD *)(a1 + 28) = 0;\n          *(_DWORD *)(a1 + 32) = 0;\n          *(_DWORD *)(a1 + 40) = 0;\n          *(_DWORD *)(a1 + 36) = 0;\n        }\n        else if ( *(_BYTE *)(a1 + 80) )\n        {\n          return 7;\n        }\n        if ( v8 <= 0x7F )\n        {\n          if ( v8 > 2 )\n            return 7;\n          *(_DWORD *)(a1 + 64) = 3;\n          *(_DWORD *)(a1 + 68) = 8;\n        }\n        else\n        {\n          *(_DWORD *)(a1 + 72) = (v8 << 16) & 0x1F0000;\n          *(_DWORD *)(a1 + 64) = 1;\n          if ( v8 <= 0xBF )\n          {\n            if ( *(_BYTE *)(a1 + 81) )\n              return 7;\n            *(_DWORD *)(a1 + 68) = 6;\n            if ( v8 > 0x9F )\n            {\n              *(_DWORD *)(a1 + 100) = 0;\n              *(_DWORD *)(a1 + 84) = 0;\n              *(_DWORD *)(a1 + 88) = 0;\n              *(_DWORD *)(a1 + 92) = 0;\n              *(_DWORD *)(a1 + 96) = 0;\n              for ( i = 0; i != 14134; ++i )\n                *(_WORD *)(a1 + 120 + 2 * i) = 1024;\n              *(_DWORD *)a1 = -1;\n              *(_DWORD *)(a1 + 4) = 0;\n              *(_DWORD *)(a1 + 8) = 5;\n            }\n          }\n          else\n          {\n            *(_BYTE *)(a1 + 81) = 0;\n            *(_DWORD *)(a1 + 68) = 5;\n          }\n        }\n        continue;\n      case 1:\n        v11 = *a2;\n        a2[1] = v4 + 1;\n        *(_DWORD *)(a1 + 72) += *(unsigned __int8 *)(v11 + v4) << 8;\n        *(_DWORD *)(a1 + 64) = 2;\n        continue;\n      case 2:\n        v12 = *a2;\n        a2[1] = v4 + 1;\n        *(_DWORD *)(a1 + 72) += *(unsigned __int8 *)(v12 + v4) + 1;\n        *(_DWORD *)(a1 + 64) = 3;\n        continue;\n      case 3:\n        v13 = *a2;\n        a2[1] = v4 + 1;\n        *(_DWORD *)(a1 + 76) = *(unsigned __int8 *)(v13 + v4) << 8;\n        *(_DWORD *)(a1 + 64) = 4;\n        continue;\n      case 4:\n        v14 = *a2;\n        a2[1] = v4 + 1;\n        *(_DWORD *)(a1 + 76) += *(unsigned __int8 *)(v14 + v4) + 1;\n        *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 68);\n        continue;\n      case 5:\n        v15 = *a2;\n        a2[1] = v4 + 1;\n        v16 = *(_BYTE *)(v15 + v4);\n        if ( v16 > 0xE0u )\n          return 7;\n        for ( *(_DWORD *)(a1 + 116) = 0; ; *(_DWORD *)(a1 + 116) = v17 + 1 )\n        {\n          v17 = *(_DWORD *)(a1 + 116);\n          if ( v16 <= 0x2Cu )\n            break;\n          v16 -= 45;\n        }\n        *(_DWORD *)(a1 + 116) = (1 << v17) - 1;\n        for ( *(_DWORD *)(a1 + 112) = 0; ; *(_DWORD *)(a1 + 112) = v18 + 1 )\n        {\n          v18 = *(_DWORD *)(a1 + 112);\n          if ( v16 <= 8u )\n            break;\n          v16 -= 9;\n        }\n        *(_DWORD *)(a1 + 108) = v16;\n        if ( v18 + (unsigned int)v16 > 4 )\n          return 7;\n        *(_DWORD *)(a1 + 112) = (1 << v18) - 1;\n        *(_DWORD *)(a1 + 100) = 0;\n        *(_DWORD *)(a1 + 84) = 0;\n        *(_DWORD *)(a1 + 88) = 0;\n        *(_DWORD *)(a1 + 92) = 0;\n        *(_DWORD *)(a1 + 96) = 0;\n        for ( j = 0; j != 14134; ++j )\n          *(_WORD *)(a1 + 120 + 2 * j) = 1024;\n        *(_DWORD *)a1 = -1;\n        *(_DWORD *)(a1 + 4) = 0;\n        *(_DWORD *)(a1 + 8) = 5;\n        *(_DWORD *)(a1 + 64) = 6;\n        goto LABEL_35;\n      case 6:\nLABEL_35:\n        v20 = *(_DWORD *)(a1 + 76);\n        if ( v20 <= 4 )\n          return 7;\n        while ( 2 )\n        {\n          v21 = *(_DWORD *)(a1 + 8);\n          v22 = a2[1];\n          if ( !v21 )\n          {\n            *(_DWORD *)(a1 + 76) = v20 - 5;\n            *(_DWORD *)(a1 + 64) = 7;\n            goto LABEL_41;\n          }\n          if ( v5 != v22 )\n          {\n            destb = (char *)(*(_DWORD *)(a1 + 4) << 8);\n            a2[1] = v22 + 1;\n            *(_DWORD *)(a1 + 4) = &destb[*(unsigned __int8 *)(*a2 + v22)];\n            *(_DWORD *)(a1 + 8) = v21 - 1;\n            continue;\n          }\n          return 0;\n        }\n      case 7:\n        goto LABEL_41;\n      case 8:\n        while ( 2 )\n        {\n          v54 = *(_DWORD *)(a1 + 76);\n          v59 = a2[2];\n          desta = (void *)a2[1];\n          if ( !v54 )\n            goto LABEL_101;\n          if ( a2[1] < v59 )\n          {\n            v48 = a2[4];\n            v49 = a2[5];\n            if ( v49 > v48 )\n            {\n              v50 = *(_DWORD *)(a1 + 32);\n              v51 = *(_DWORD *)(a1 + 44) - v50;\n              if ( v51 > v54 )\n                v51 = *(_DWORD *)(a1 + 76);\n              v52 = v49 - v48;\n              if ( v51 > v52 )\n                v51 = v52;\n              if ( v51 > v59 - (unsigned int)desta )\n                v51 = v59 - (_DWORD)desta;\n              *(_DWORD *)(a1 + 76) = v54 - v51;\n              qmemcpy((void *)(*(_DWORD *)(a1 + 24) + v50), (const void *)(*a2 + a2[1]), v51);\n              v53 = v51 + *(_DWORD *)(a1 + 32);\n              *(_DWORD *)(a1 + 32) = v53;\n              if ( v53 > *(_DWORD *)(a1 + 36) )\n                *(_DWORD *)(a1 + 36) = v53;\n              if ( v53 == *(_DWORD *)(a1 + 44) )\n                *(_DWORD *)(a1 + 32) = 0;\n              qmemcpy((void *)(a2[3] + a2[4]), (const void *)(*a2 + a2[1]), v51);\n              *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 32);\n              a2[4] += v51;\n              a2[1] += v51;\n              continue;\n            }\n          }\n          return 0;\n        }\n      default:\n        goto LABEL_2;\n    }\n  }\n}\n"
    ],
    "sub_808CF10": [
        "0x808cf10",
        "__int64 __usercall sub_808CF10@<edx:eax>(int a1@<eax>)\n{\n  _DWORD *v1; // eax\n  _DWORD *v2; // ebx\n  _DWORD *v3; // eax\n  unsigned int v4; // esi\n  ssize_t v5; // eax\n  unsigned int v6; // eax\n  char v7; // dl\n  unsigned int v8; // eax\n  int v9; // edx\n  int v10; // eax\n  int v11; // eax\n  int v12; // eax\n  unsigned int v13; // edx\n  char v14; // al\n  int v15; // edx\n  int v16; // edx\n  int v17; // ecx\n  int v18; // eax\n  int v19; // edx\n  unsigned __int8 v20; // cl\n  int v21; // esi\n  unsigned int v22; // eax\n  void *v23; // eax\n  unsigned int v24; // edx\n  unsigned int v25; // eax\n  unsigned __int64 v26; // rax\n  int v27; // eax\n  int v28; // edx\n  __int64 v29; // rax\n  int v30; // esi\n  __int64 v31; // rax\n  int v32; // ecx\n  int v33; // eax\n  unsigned int v34; // esi\n  int v35; // eax\n  int v36; // edi\n  char i; // cl\n  unsigned int v38; // edx\n  int v39; // eax\n  int v40; // eax\n  int v41; // edx\n  int v42; // ecx\n  int v43; // eax\n  void **v44; // esi\n  int v46; // [esp+0h] [ebp-48h]\n  int v47; // [esp+8h] [ebp-40h]\n  unsigned __int64 v48; // [esp+Ch] [ebp-3Ch]\n  __int64 v49; // [esp+Ch] [ebp-3Ch]\n  int v50; // [esp+Ch] [ebp-3Ch]\n  int v51; // [esp+Ch] [ebp-3Ch]\n  __int64 v53; // [esp+18h] [ebp-30h]\n  char *dest; // [esp+20h] [ebp-28h]\n  int v55[9]; // [esp+24h] [ebp-24h] BYREF\n\n  if ( !dword_80DBB98 )\n    sub_80AA3E8();\n  memset(v55, 0, 0x18u);\n  dest = (char *)sub_804DAFA(0x2000u);\n  v55[0] = (int)dest;\n  v55[3] = (int)(dest + 4096);\n  v55[5] = 4096;\n  if ( !a1 || *(_BYTE *)a1 )\n  {\n    strcpy(dest, &unk_80D551C);\n    v55[2] = 6;\n  }\n  v1 = malloc(0x49Cu);\n  v2 = v1;\n  if ( v1 )\n  {\n    v1[8] = 2;\n    v3 = malloc(0x6F28u);\n    if ( v3 )\n    {\n      v3[15] = 2;\n      v3[13] = 0x4000000;\n      v3[6] = 0;\n      v3[14] = 0;\n      v2[294] = v3;\n      sub_808C84E((int)v2);\n    }\n    else\n    {\n      free(v2);\n      v2 = 0;\n    }\n  }\n  v53 = 0LL;\n  v4 = 1;\n  while ( v55[1] != v55[2] )\n  {\nLABEL_17:\n    v6 = v55[1];\n    if ( v4 == 1 )\n    {\n      v7 = 0;\n      while ( !dest[v6] )\n      {\n        ++v6;\n        v7 = 1;\n        if ( v6 >= v55[2] )\n        {\n          v55[1] = v6;\n          goto LABEL_25;\n        }\n      }\n      if ( v7 )\n        v55[1] = v6;\n      sub_808C84E((int)v2);\n    }\nLABEL_25:\n    v47 = v55[1];\n    v46 = v55[4];\n    v2[4] = v55[1];\n    while ( 2 )\n    {\n      switch ( *v2 )\n      {\n        case 0:\n          if ( !sub_808C8DF((int)v2, v55) )\n            goto LABEL_128;\n          *v2 = 1;\n          if ( memcmp(v2 + 38, &unk_80D551C, 6u) )\n          {\n            v4 = 5;\n            goto LABEL_135;\n          }\n          if ( sub_808C89B() != v2[40] )\n            goto LABEL_30;\n          if ( *((_BYTE *)v2 + 158) )\n            goto LABEL_32;\n          v8 = *((unsigned __int8 *)v2 + 159);\n          v2[7] = v8;\n          if ( v8 > 0xF )\n            goto LABEL_32;\n          if ( v8 > 1 )\n          {\n            v4 = 2;\n            goto LABEL_135;\n          }\nLABEL_35:\n          v9 = v55[1];\n          if ( v55[1] == v55[2] )\n            goto LABEL_128;\n          v10 = *(unsigned __int8 *)(v55[0] + v55[1]);\n          if ( (_BYTE)v10 )\n          {\n            v11 = 4 * v10 + 4;\n            v2[14] = v11;\n            v2[37] = v11;\n            v2[36] = 0;\n            *v2 = 2;\nLABEL_39:\n            if ( !sub_808C8DF((int)v2, v55) )\n              goto LABEL_128;\n            v2[37] -= 4;\n            v12 = sub_808C89B();\n            v13 = v2[37];\n            if ( v12 != *(_DWORD *)((char *)v2 + v13 + 152) )\n              goto LABEL_30;\n            v2[36] = 2;\n            v14 = *((_BYTE *)v2 + 153);\n            if ( (v14 & 0x3F) != 0 )\n              goto LABEL_32;\n            if ( (v14 & 0x40) != 0 )\n            {\n              if ( sub_808C75B(v2, (int)(v2 + 38), v2 + 36, v13) != 1 )\n                goto LABEL_30;\n              v15 = v2[3];\n              v2[10] = v2[2];\n              v2[11] = v15;\n            }\n            else\n            {\n              v2[10] = -1;\n              v2[11] = -1;\n            }\n            if ( *((char *)v2 + 153) >= 0 )\n            {\n              v2[12] = -1;\n              v2[13] = -1;\n            }\n            else\n            {\n              if ( sub_808C75B(v2, (int)(v2 + 38), v2 + 36, v2[37]) != 1 )\n                goto LABEL_30;\n              v16 = v2[3];\n              v2[12] = v2[2];\n              v2[13] = v16;\n            }\n            v17 = v2[37];\n            v18 = v2[36];\n            if ( (unsigned int)(v17 - v18) <= 1 )\n              goto LABEL_30;\n            v2[36] = v18 + 1;\n            if ( *((_BYTE *)v2 + v18 + 152) != 33 )\n              goto LABEL_32;\n            v19 = v18 + 2;\n            v2[36] = v18 + 2;\n            if ( *((_BYTE *)v2 + v18 + 153) != 1 )\n              goto LABEL_32;\n            if ( v17 == v19 )\n              goto LABEL_30;\n            v2[36] = v18 + 3;\n            v20 = *((_BYTE *)v2 + v19 + 152);\n            v21 = v2[294];\n            if ( v20 > 0x27u )\n            {\nLABEL_32:\n              v4 = 6;\n              goto LABEL_135;\n            }\n            v22 = ((v20 & 1) + 2) << ((v20 >> 1) + 11);\n            *(_DWORD *)(v21 + 48) = v22;\n            if ( v22 > *(_DWORD *)(v21 + 52) )\n            {\n              v4 = 4;\n              goto LABEL_135;\n            }\n            *(_DWORD *)(v21 + 44) = v22;\n            if ( *(_DWORD *)(v21 + 60) == 2 && v22 > *(_DWORD *)(v21 + 56) )\n            {\n              free(*(void **)(v21 + 24));\n              v23 = malloc(*(_DWORD *)(v21 + 48));\n              *(_DWORD *)(v21 + 24) = v23;\n              if ( !v23 )\n              {\n                *(_DWORD *)(v21 + 56) = 0;\n                v4 = 3;\n                goto LABEL_135;\n              }\n            }\n            *(_DWORD *)(v21 + 104) = 0;\n            *(_DWORD *)(v21 + 64) = 0;\n            *(_BYTE *)(v21 + 80) = 1;\n            *(_DWORD *)(v21 + 28388) = 0;\n            v24 = v2[37];\n            while ( 1 )\n            {\n              v25 = v2[36];\n              if ( v25 >= v24 )\n                break;\n              v2[36] = v25 + 1;\n              if ( *((_BYTE *)v2 + v25 + 152) )\n                goto LABEL_32;\n            }\n            v2[36] = 0;\n            v2[15] = 0;\n            v2[16] = 0;\n            v2[17] = 0;\n            v2[18] = 0;\n            *v2 = 3;\nLABEL_65:\n            v2[4] = v55[1];\n            v2[5] = v55[4];\n            v4 = sub_808C93C(v2[294], v55);\n            v48 = *(_QWORD *)(v2 + 15) + (unsigned int)(v55[1] - v2[4]);\n            *(_QWORD *)(v2 + 15) = v48;\n            v26 = *(_QWORD *)(v2 + 17) + (unsigned int)(v55[4] - v2[5]);\n            *(_QWORD *)(v2 + 17) = v26;\n            if ( v48 > *((_QWORD *)v2 + 5) || v26 > *((_QWORD *)v2 + 6) )\n              goto LABEL_30;\n            if ( v2[7] == 1 )\n              v2[6] = sub_808C89B();\n            if ( v4 != 1 )\n              goto LABEL_127;\n            v27 = v2[10];\n            v28 = v2[11];\n            if ( (v28 != -1 || v27 != -1) && (v28 != v2[16] || v27 != v2[15]) )\n              goto LABEL_30;\n            v29 = *((_QWORD *)v2 + 6);\n            v49 = *(_QWORD *)(v2 + 17);\n            if ( v29 != -1 && v29 != v49 )\n              goto LABEL_30;\n            *(_QWORD *)(v2 + 21) += (unsigned int)v2[14] + *(_QWORD *)(v2 + 15) + (unsigned __int8)byte_80B7F24[v2[7]];\n            *(_QWORD *)(v2 + 23) += v49;\n            v2[25] = sub_808C89B();\n            ++*(_QWORD *)(v2 + 19);\n            *v2 = 4;\nLABEL_77:\n            v50 = v55[2];\n            v30 = v55[0];\n            while ( 1 )\n            {\n              v31 = *(_QWORD *)(v2 + 15);\n              if ( (v31 & 3) == 0 )\n                break;\n              v32 = v55[1];\n              if ( v55[1] == v50 )\n                goto LABEL_128;\n              ++v55[1];\n              if ( *(_BYTE *)(v30 + v32) )\n                goto LABEL_30;\n              *(_QWORD *)(v2 + 15) = v31 + 1;\n            }\n            *v2 = 5;\nLABEL_83:\n            v33 = v2[7];\n            if ( v33 == 1 )\n            {\n              v4 = sub_808C7FD((int)v2, v55);\n              if ( v4 != 1 )\n                goto LABEL_127;\n            }\n            else\n            {\n              v34 = (unsigned __int8)byte_80B7F24[v33];\n              v35 = v55[1];\n              v36 = v55[2];\n              for ( i = 0; ; i = 1 )\n              {\n                v38 = v2[1];\n                if ( v38 >= v34 )\n                  break;\n                if ( v35 == v36 )\n                {\n                  if ( i )\n                    v55[1] = v35;\n                  goto LABEL_128;\n                }\n                ++v35;\n                v2[1] = v38 + 1;\n              }\n              if ( i )\n                v55[1] = v35;\n              v2[1] = 0;\n            }\n            *v2 = 1;\n          }\n          else\n          {\n            ++v55[1];\n            v2[4] = v9;\n            *v2 = 6;\n          }\n          continue;\n        case 1:\n          goto LABEL_35;\n        case 2:\n          goto LABEL_39;\n        case 3:\n          goto LABEL_65;\n        case 4:\n          goto LABEL_77;\n        case 5:\n          goto LABEL_83;\n        case 6:\n          goto LABEL_97;\n        case 7:\n          goto LABEL_110;\n        case 8:\n          goto LABEL_118;\n        case 9:\n          goto LABEL_120;\n        default:\n          continue;\n      }\n    }\n    do\n    {\nLABEL_97:\n      v4 = sub_808C75B(v2, v55[0], (unsigned int *)&v55[1], v55[2]);\n      if ( v4 != 1 )\n      {\n        sub_808C8B5((int)v2, (int)v55);\n        goto LABEL_127;\n      }\n      v39 = v2[26];\n      if ( v39 == 1 )\n      {\n        *(_QWORD *)(v2 + 31) += *((_QWORD *)v2 + 1);\n        v2[26] = 2;\n      }\n      else\n      {\n        if ( v39 )\n        {\n          if ( v39 != 2 )\n            continue;\n          *(_QWORD *)(v2 + 33) += *((_QWORD *)v2 + 1);\n          v2[35] = sub_808C89B();\n          --*(_QWORD *)(v2 + 29);\n        }\n        else\n        {\n          v40 = v2[2];\n          v41 = v2[3];\n          v2[29] = v40;\n          v2[30] = v41;\n          if ( v41 != v2[20] || v40 != v2[19] )\n            goto LABEL_30;\n        }\n        v2[26] = 1;\n      }\n    }\n    while ( *(_QWORD *)(v2 + 29) );\n    *v2 = 7;\nLABEL_110:\n    v51 = v2[27];\n    v42 = v2[4];\n    while ( 1 )\n    {\n      v43 = v55[1];\n      if ( (((_BYTE)v51 + LOBYTE(v55[1]) - (_BYTE)v42) & 3) == 0 )\n        break;\n      if ( v55[2] == v55[1] )\n      {\n        sub_808C8B5((int)v2, (int)v55);\n        goto LABEL_128;\n      }\n      ++v55[1];\n      if ( *(_BYTE *)(v55[0] + v43) )\n        goto LABEL_30;\n    }\n    sub_808C8B5((int)v2, (int)v55);\n    if ( memcmp(v2 + 21, v2 + 31, 0x14u) )\n    {\nLABEL_30:\n      v4 = 7;\n      goto LABEL_135;\n    }\n    *v2 = 8;\nLABEL_118:\n    v4 = sub_808C7FD((int)v2, v55);\n    if ( v4 != 1 )\n    {\nLABEL_127:\n      if ( !v4 )\n        goto LABEL_128;\n      goto LABEL_135;\n    }\n    v2[37] = 12;\n    *v2 = 9;\nLABEL_120:\n    if ( !sub_808C8DF((int)v2, v55) )\n    {\nLABEL_128:\n      if ( v47 != v55[1] || v46 != v55[4] )\n      {\n        v4 = 0;\n        goto LABEL_135;\n      }\n      v4 = *((_BYTE *)v2 + 36) != 0 ? 8 : 0;\n      *((_BYTE *)v2 + 36) = 1;\n      goto LABEL_136;\n    }\n    if ( memcmp((char *)v2 + 162, &MEMORY[0x80D5522], 2u) )\n      goto LABEL_30;\n    if ( sub_808C89B() != v2[38] )\n      goto LABEL_30;\n    if ( *(_QWORD *)(v2 + 27) >> 2 != v2[39] )\n      goto LABEL_30;\n    if ( *((_BYTE *)v2 + 160) )\n      goto LABEL_30;\n    v4 = 1;\n    if ( *((unsigned __int8 *)v2 + 161) != v2[7] )\n      goto LABEL_30;\nLABEL_135:\n    *((_BYTE *)v2 + 36) = 0;\nLABEL_136:\n    if ( v55[4] )\n    {\n      sub_808EF24(v55[4], v55[3]);\n      v53 += (unsigned int)v55[4];\n      v55[4] = 0;\n    }\n    if ( v4 >= 3 )\n    {\n      sub_804D5F4(\"corrupted data\");\n      v53 = -1LL;\n      goto LABEL_141;\n    }\n  }\n  v5 = sub_804E5BC(0x1000u, dest, *(_DWORD *)(a1 + 8));\n  if ( v5 >= 0 )\n  {\n    if ( v4 == 1 && !v5 )\n      goto LABEL_140;\n    v55[2] = v5;\n    v55[1] = 0;\n    goto LABEL_17;\n  }\n  sub_804D5F4(\"read error\");\n  v53 = -1LL;\nLABEL_140:\n  if ( v2 )\n  {\nLABEL_141:\n    v44 = (void **)v2[294];\n    free(v44[6]);\n    free(v44);\n    free(v2);\n  }\n  free(dest);\n  return v53;\n}\n"
    ],
    "sub_808D814": [
        "0x808d814",
        "bool __usercall sub_808D814@<al>(int a1@<eax>, int a2@<ecx>)\n{\n  return sub_808D85A(a2, **(_DWORD **)(a1 + 24)) == 0;\n}\n"
    ],
    "sub_808D827": [
        "0x808d827",
        "bool __usercall sub_808D827@<al>(int a1@<eax>, int a2@<ecx>)\n{\n  int v3; // esi\n  int v4; // eax\n  int v5; // ecx\n  char v6; // dl\n\n  v3 = **(_DWORD **)(a1 + 24);\n  v4 = sub_808D87F(a2, v3);\n  v6 = 1;\n  if ( !v4 )\n  {\n    v6 = 0;\n    if ( *(_DWORD *)(a1 + 12) )\n      return sub_808D87F(v5, v3) == 0;\n  }\n  return v6;\n}\n"
    ],
    "sub_808D85A": [
        "0x808d85a",
        "int **__usercall sub_808D85A@<eax>(int **a1@<eax>, const char *a2@<edx>)\n{\n  while ( a1 && fnmatch((const char *)a1[1], a2, 0) )\n    a1 = (int **)*a1;\n  return a1;\n}\n"
    ],
    "sub_808D87F": [
        "0x808d87f",
        "int **__usercall sub_808D87F@<eax>(int **a1@<eax>, int a2@<edx>)\n{\n  char *v4; // edx\n  int v5; // ecx\n  char v6; // al\n  int i; // eax\n  char *v8; // ebp\n  char v9; // dl\n  char v11[4095]; // [esp+0h] [ebp-1010h] BYREF\n  char v12; // [esp+FFFh] [ebp-11h] BYREF\n\n  while ( a1 )\n  {\n    v4 = (char *)a1[1];\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = *v4;\n      if ( !*v4 )\n        break;\n      ++v4;\n      if ( v6 == 47 )\n        ++v5;\n    }\n    for ( i = 0; ; v11[i++] = v9 )\n    {\n      v8 = &v11[i];\n      v9 = *(_BYTE *)(a2 + i);\n      if ( !v9 )\n        break;\n      if ( i == 4095 )\n      {\n        v8 = &v12;\n        break;\n      }\n      if ( v9 == 47 && --v5 == -1 )\n        break;\n    }\n    *v8 = 0;\n    if ( !fnmatch((const char *)a1[1], v11, 0) )\n      break;\n    a1 = (int **)*a1;\n  }\n  return a1;\n}\n"
    ],
    "sub_808D8F8": [
        "0x808d8f8",
        "int __usercall sub_808D8F8@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int v3; // esi\n  ssize_t v4; // eax\n  void *v5; // eax\n  int v6; // ecx\n  _BYTE *v7; // edx\n  int v8; // eax\n  int v9; // ecx\n  int v10; // eax\n  void *v11; // eax\n  void *v12; // ebp\n  _DWORD *v14; // ebp\n  _DWORD *i; // eax\n  _DWORD *v16; // eax\n  int v17; // [esp-8h] [ebp-B0h]\n  int v18; // [esp+0h] [ebp-A8h] BYREF\n  int v19; // [esp+4h] [ebp-A4h] BYREF\n  int v20; // [esp+8h] [ebp-A0h] BYREF\n  int v21; // [esp+Ch] [ebp-9Ch] BYREF\n  int v22; // [esp+10h] [ebp-98h] BYREF\n  int v23; // [esp+14h] [ebp-94h] BYREF\n  ssize_t v24; // [esp+18h] [ebp-90h] BYREF\n  int v25; // [esp+1Ch] [ebp-8Ch] BYREF\n  int v26; // [esp+20h] [ebp-88h] BYREF\n  int v27; // [esp+24h] [ebp-84h] BYREF\n  char buf[6]; // [esp+2Ah] [ebp-7Eh] BYREF\n  char s[120]; // [esp+30h] [ebp-78h] BYREF\n\n  v3 = *(_DWORD *)(a1 + 24);\n  sub_808F10D(a2, 4);\n  v4 = sub_804E5E3(*(_DWORD *)(a1 + 4), buf, 0x6Eu);\n  v24 = v4;\n  if ( v4 )\n  {\n    if ( v4 != 110 )\n      sub_804D5E0(\"short read\");\n    *(_QWORD *)(a1 + 44) += 110LL;\n    if ( !sub_804D210(buf, \"07070\") || (unsigned __int8)(buf[5] - 49) > 1u )\n      sub_804D5E0(\"unsupported cpio format, use newc or crc\");\n    if ( sscanf(s, \"%8x%8x%8x%8x%8x%8x%8x%*16c%8x%8x%8x\", &v23, &v22, &v25, &v26, &v21, &v27, &v24, &v19, &v20, &v18) != 10 )\n      sub_804D5E0(\"damaged cpio file\");\n    *(_DWORD *)(v3 + 24) = v22;\n    if ( *(_DWORD *)(a1 + 84) != -1 )\n      v25 = *(_DWORD *)(a1 + 84);\n    if ( *(_DWORD *)(a1 + 88) != -1 )\n      v26 = *(_DWORD *)(a1 + 88);\n    *(_DWORD *)(v3 + 16) = v25;\n    *(_DWORD *)(v3 + 20) = v26;\n    *(_DWORD *)(v3 + 28) = v27;\n    *(_DWORD *)(v3 + 8) = v24;\n    *(_DWORD *)(v3 + 12) = 0;\n    v18 &= 0x1FFFu;\n    v5 = sub_804DB2E(v18 + 1);\n    *(_DWORD *)v3 = v5;\n    sub_80B24F6(v18, v5);\n    if ( **(_BYTE **)v3 == 47 )\n    {\n      v7 = *(_BYTE **)v3;\n      do\n        ++v7;\n      while ( *v7 == 47 );\n      sub_80B2C69(v6);\n    }\n    *(_QWORD *)(a1 + 44) += v18;\n    sub_808F10D(v6, 4);\n    v8 = strcmp(*(const char **)v3, \"TRAILER!!!\");\n    v9 = v17;\n    if ( !v8 )\n    {\n      *(_QWORD *)(a1 + 76) = (unsigned __int64)(*(_QWORD *)(a1 + 44) + 511LL) >> 9;\n      goto LABEL_31;\n    }\n    *(_DWORD *)(v3 + 4) = 0;\n    if ( (*(_DWORD *)(v3 + 24) & 0xF000) == 40960 )\n    {\n      v10 = *(_DWORD *)(v3 + 8) & 0x1FFF;\n      *(_DWORD *)(v3 + 8) = v10;\n      *(_DWORD *)(v3 + 12) = 0;\n      v11 = sub_804DB2E(v10 + 1);\n      *(_DWORD *)(v3 + 4) = v11;\n      sub_80B24F6(*(_DWORD *)(v3 + 8), v11);\n      *(_QWORD *)(a1 + 44) += *(_QWORD *)(v3 + 8);\n      *(_DWORD *)(v3 + 8) = 0;\n      *(_DWORD *)(v3 + 12) = 0;\n    }\n    if ( v21 > 1 && (*(_DWORD *)(v3 + 24) & 0xF000) == 0x8000 )\n    {\n      v12 = sub_804DAFA(v18 + 28);\n      *((_DWORD *)v12 + 1) = v23;\n      *((_DWORD *)v12 + 2) = v22;\n      *((_DWORD *)v12 + 3) = v27;\n      *((_DWORD *)v12 + 4) = v25;\n      *((_DWORD *)v12 + 5) = v26;\n      strcpy((char *)v12 + 24, *(const char **)v3);\n      if ( !v24 )\n      {\n        *(_DWORD *)v12 = *(_DWORD *)(a1 + 92);\n        *(_DWORD *)(a1 + 92) = v12;\n        return 0;\n      }\n      *(_DWORD *)v12 = *(_DWORD *)(a1 + 96);\n      *(_DWORD *)(a1 + 96) = v12;\n    }\n    *(_QWORD *)(v3 + 32) = sub_80B0220(v9, v20);\n    if ( (*(unsigned __int8 (**)(void))(a1 + 8))() )\n    {\n      sub_80899AD(a1);\n    }\n    else\n    {\n      (*(void (**)(void))(a1 + 36))();\n      (*(void (**)(void))(a1 + 32))();\n    }\n    *(_QWORD *)(a1 + 44) += *(_QWORD *)(v3 + 8);\n    free(*(void **)(v3 + 4));\n    free(*(void **)v3);\n    *(_DWORD *)(v3 + 4) = 0;\n    *(_DWORD *)v3 = 0;\n    return 0;\n  }\nLABEL_31:\n  free(*(void **)(v3 + 4));\n  free(*(void **)v3);\nLABEL_32:\n  while ( 1 )\n  {\n    v14 = *(_DWORD **)(a1 + 92);\n    if ( !v14 )\n      break;\n    *(_DWORD *)(a1 + 92) = *v14;\n    memset((void *)v3, 0, 0x28u);\n    *(_DWORD *)(v3 + 28) = v14[3];\n    *(_DWORD *)v3 = v14 + 6;\n    *(_DWORD *)(v3 + 24) = v14[2];\n    *(_DWORD *)(v3 + 16) = v14[4];\n    *(_DWORD *)(v3 + 20) = v14[5];\n    for ( i = *(_DWORD **)(a1 + 96); i; i = (_DWORD *)*i )\n    {\n      if ( i[1] == v14[1] )\n      {\n        *(_DWORD *)(v3 + 4) = i + 6;\n        if ( !(*(unsigned __int8 (**)(void))(a1 + 8))() )\n          (*(void (**)(void))(a1 + 36))();\n        free(v14);\n        goto LABEL_32;\n      }\n    }\n    if ( !(*(unsigned __int8 (**)(void))(a1 + 8))() )\n      (*(void (**)(void))(a1 + 36))();\n    *v14 = *(_DWORD *)(a1 + 96);\n    *(_DWORD *)(a1 + 96) = v14;\n  }\n  while ( 1 )\n  {\n    v16 = *(_DWORD **)(a1 + 96);\n    if ( !v16 )\n      break;\n    *(_DWORD *)(a1 + 96) = *v16;\n    free(v16);\n  }\n  return 1;\n}\n"
    ],
    "sub_808DC48": [
        "0x808dc48",
        "unsigned __int64 __usercall sub_808DC48@<edx:eax>(const char *a1@<eax>, int a2@<edx>, char *a3@<ecx>)\n{\n  char *v3; // esi\n  unsigned __int64 result; // rax\n  char *v6; // edi\n  char *v7; // [esp+0h] [ebp-10h] BYREF\n\n  v7 = a3;\n  v3 = (char *)a1;\n  a1[a2] = 0;\n  result = strtoull(a1, &v7, 8);\n  if ( (*v7 & 0xDF) != 0 )\n  {\n    if ( *v3 >= 0 )\n      sub_804D5E0(\"corrupted octal value in tar header\");\n    result = (char)(2 * *v3) >> 1;\n    v6 = &v3[a2];\n    while ( ++v3 != v6 )\n      result = (unsigned __int8)*v3 + (result << 8);\n  }\n  return result;\n}\n"
    ],
    "sub_808DCAD": [
        "0x808dcad",
        "char __usercall sub_808DCAD@<al>(int a1@<eax>, int a2@<ecx>)\n{\n  char **v3; // ebp\n  ssize_t v4; // eax\n  char result; // al\n  char *v6; // ecx\n  int v7; // edi\n  int i; // eax\n  int j; // eax\n  int v10; // esi\n  char *v11; // ecx\n  int v12; // edi\n  char *v13; // ecx\n  int v14; // ecx\n  char *v15; // ecx\n  char *v16; // ecx\n  char *v17; // ecx\n  char *v18; // ecx\n  int v19; // ecx\n  char *v20; // eax\n  void *v21; // edx\n  unsigned int v22; // edi\n  int v23; // eax\n  char *v24; // edi\n  unsigned __int64 v25; // rax\n  unsigned int v26; // esi\n  unsigned int v27; // edi\n  char *v28; // eax\n  char *v29; // eax\n  int v30; // ecx\n  const char *v31; // esi\n  int v32; // ecx\n  char v33; // [esp+0h] [ebp-22Ch]\n  char *v34; // [esp+0h] [ebp-22Ch]\n  char *ptr; // [esp+4h] [ebp-228h]\n  const char *v36; // [esp+10h] [ebp-21Ch]\n  char *v37; // [esp+18h] [ebp-214h] BYREF\n  int buf[25]; // [esp+1Ch] [ebp-210h] BYREF\n  char v39[8]; // [esp+80h] [ebp-1ACh] BYREF\n  char v40[8]; // [esp+88h] [ebp-1A4h] BYREF\n  char v41[8]; // [esp+90h] [ebp-19Ch] BYREF\n  char v42[12]; // [esp+98h] [ebp-194h] BYREF\n  char v43[12]; // [esp+A4h] [ebp-188h] BYREF\n  char v44[9]; // [esp+B0h] [ebp-17Ch] BYREF\n  char v45[100]; // [esp+B9h] [ebp-173h] BYREF\n  char v46[72]; // [esp+11Dh] [ebp-10Fh] BYREF\n  char v47[8]; // [esp+165h] [ebp-C7h] BYREF\n  char v48[8]; // [esp+16Dh] [ebp-BFh] BYREF\n  char v49[183]; // [esp+175h] [ebp-B7h] BYREF\n\n  v3 = *(char ***)(a1 + 24);\nLABEL_2:\n  sub_808F10D(a2, 512);\n  while ( 1 )\n  {\n    buf[0] = 0;\n    v4 = sub_804E5E3(*(_DWORD *)(a1 + 4), (char *)buf, 0x200u);\n    if ( !v4 )\n    {\n      if ( !*(_QWORD *)(a1 + 44) )\n        sub_804D5F4(\"short read\");\n      return 1;\n    }\n    if ( v4 != 512 )\n      sub_804D5E0(\"short read\");\n    *(_QWORD *)(a1 + 44) += 512LL;\n    if ( !LOBYTE(buf[0]) )\n    {\n      result = v49[0];\n      if ( !v49[0] && !*(_DWORD *)(a1 + 60) )\n      {\n        if ( *(_BYTE *)(a1 + 56) )\n        {\n          while ( sub_804E5E3(*(_DWORD *)(a1 + 4), (char *)buf, 0x200u) == 512 )\n            ;\n          return 1;\n        }\n        else\n        {\n          *(_BYTE *)(a1 + 56) = 1;\n        }\n        return result;\n      }\n    }\n    *(_BYTE *)(a1 + 56) = 0;\n    if ( !sub_804D210(v46, \"ustar\") )\n      sub_804D5E0(\"invalid tar magic\");\n    v7 = 256;\n    for ( i = 0; i != 148; ++i )\n      v7 += *((unsigned __int8 *)buf + i);\n    for ( j = 156; j != 512; ++j )\n      v7 += *((unsigned __int8 *)buf + j);\n    v10 = (unsigned __int8)v44[8];\n    if ( v7 != (unsigned int)sub_808DC48(v44, 8, v6) )\n      sub_804D5E0(\"invalid tar header checksum\");\n    if ( v47[0] )\n    {\n      LOBYTE(v11) = v49[0];\n      v33 = v49[0];\n      v12 = sub_808DC48(v48, 8, v11);\n      sub_808DC48(v47, 8, v13);\n      *((_QWORD *)v3 + 4) = sub_80B0220(v14, v12);\n      LOBYTE(v11) = v33;\n      v49[0] = v33;\n    }\n    if ( !v10 )\n      v10 = 48;\n    v3[1] = 0;\n    if ( !*(_DWORD *)(a1 + 64) && (unsigned int)(v10 - 48) <= 7 && v45[0] )\n      v3[1] = sub_804DB5D(v45, 100);\n    v3[7] = (char *)sub_808DC48(v43, 12, v11);\n    *((_QWORD *)v3 + 1) = sub_808DC48(v42, 12, v15);\n    v3[5] = (char *)sub_808DC48(v41, 8, v16);\n    v3[4] = (char *)sub_808DC48(v40, 8, v17);\n    v3[6] = (char *)(sub_808DC48(v39, 8, v18) & 0xFFF);\n    *v3 = 0;\n    if ( !*(_DWORD *)(a1 + 60) && (unsigned int)(v10 - 48) <= 7 )\n    {\n      v39[0] = 0;\n      if ( v49[0] )\n      {\n        v49[155] = 0;\n        v20 = (char *)sub_804D2D1((int)v49, buf, v19);\n      }\n      else\n      {\n        v20 = sub_804DB46((const char *)buf);\n      }\n      *v3 = v20;\n    }\n    if ( v10 == 53 )\n    {\n      v3[6] = (char *)((unsigned int)v3[6] | 0x4000);\n      goto LABEL_58;\n    }\n    if ( v10 <= 53 )\n      break;\n    if ( v10 == 75 )\n    {\n      free(*(void **)(a1 + 64));\n      v21 = sub_804DB2E((size_t)(v3[2] + 1));\n      *(_DWORD *)(a1 + 64) = v21;\nLABEL_77:\n      sub_80B24F6(v3[2], v21);\n      *(_QWORD *)(a1 + 44) += *((_QWORD *)v3 + 1);\n      goto LABEL_2;\n    }\n    if ( v10 <= 75 )\n    {\n      if ( v10 != 54 )\n      {\n        if ( v10 != 55 )\n          goto LABEL_82;\n        goto LABEL_56;\n      }\n      v3[6] = (char *)((unsigned int)v3[6] | 0x1000);\n      goto LABEL_58;\n    }\n    if ( v10 != 103 && v10 != 120 )\n    {\n      if ( v10 != 76 )\n        goto LABEL_82;\n      free(*(void **)(a1 + 60));\n      v21 = sub_804DB2E((size_t)(v3[2] + 1));\n      *(_DWORD *)(a1 + 60) = v21;\n      goto LABEL_77;\n    }\n    if ( *((_QWORD *)v3 + 1) > 0xFFFFFuLL )\n    {\n      sub_804D5F4(\"warning: skipping header '%c'\", v10);\n      v25 = __PAIR64__((unsigned __int64)(*((_QWORD *)v3 + 1) + 511LL) >> 32, (unsigned int)(v3[2] + 511) & 0xFFFFFE00);\n      *(_QWORD *)(a1 + 44) += __PAIR64__(\n                                (unsigned __int64)(*((_QWORD *)v3 + 1) + 511LL) >> 32,\n                                (unsigned int)(v3[2] + 511) & 0xFFFFFE00);\n      v26 = v25 >> 9;\n      v27 = SHIDWORD(v25) >> 9;\n      while ( 1 )\n      {\n        v27 = (__PAIR64__(v27, v26--) - 1) >> 32;\n        if ( __PAIR64__(v27, v26) == -1LL )\n          break;\n        sub_80B24F6(512, buf);\n      }\n    }\n    else\n    {\n      v34 = v3[2];\n      v22 = (unsigned int)(v34 + 511) & 0xFFFFFE00;\n      ptr = (char *)sub_804DAFA(v22 + 1);\n      sub_80B24F6(v22, ptr);\n      *(_QWORD *)(a1 + 44) += v22;\n      v34[(_DWORD)ptr] = 0;\n      v36 = ptr;\n      while ( v34 )\n      {\n        v23 = sub_804ED6C(10, v36, &v37, a1);\n        v36 += v23;\n        v34 -= v23;\n        if ( ((v23 | (unsigned int)v34) & 0x80000000) != 0\n          || !v23\n          || *(_DWORD *)dword_80DBB7C != 22\n          || (v24 = v37, *v37 != 32) )\n        {\n          sub_804D5F4(\"malformed extended header, skipped\");\n          break;\n        }\n        *((_BYTE *)v36 - 1) = 0;\n        if ( v10 != 103 )\n        {\n          if ( sub_804D210(v24 + 1, \"path=\") )\n          {\n            free(*(void **)(a1 + 60));\n            *(_DWORD *)(a1 + 60) = sub_804DB46(v24 + 6);\n          }\n          else if ( sub_804D210(v24 + 1, byte_80D5605) )\n          {\n            free(*(void **)(a1 + 64));\n            *(_DWORD *)(a1 + 64) = sub_804DB46(v24 + 10);\n          }\n        }\n      }\n      free(ptr);\n    }\n  }\n  if ( v10 == 50 )\n  {\n    v3[6] = (char *)((unsigned int)v3[6] | 0xA000);\n    goto LABEL_58;\n  }\n  if ( v10 > 50 )\n  {\n    if ( v10 == 51 )\n      v3[6] = (char *)((unsigned int)v3[6] | 0x2000);\n    else\n      v3[6] = (char *)((unsigned int)v3[6] | 0x6000);\nLABEL_58:\n    v3[2] = 0;\n    v3[3] = 0;\n    goto LABEL_83;\n  }\n  if ( v10 != 48 )\n  {\n    if ( v10 == 49 )\n    {\n      v3[6] = (char *)((unsigned int)v3[6] | 0x8000);\n      goto LABEL_58;\n    }\nLABEL_82:\n    sub_804D5E0(\"unknown typeflag: 0x%x\", v10);\n  }\nLABEL_56:\n  v3[6] = (char *)((unsigned int)v3[6] | 0x8000);\nLABEL_83:\n  v28 = *(char **)(a1 + 60);\n  if ( v28 )\n  {\n    *v3 = v28;\n    *(_DWORD *)(a1 + 60) = 0;\n  }\n  v29 = *(char **)(a1 + 64);\n  if ( v29 )\n  {\n    v3[1] = v29;\n    *(_DWORD *)(a1 + 64) = 0;\n  }\n  sub_808EFDF();\n  sub_80B2C69(v30);\n  v31 = sub_804D378(*v3, 47);\n  if ( (*(unsigned __int8 (**)(void))(a1 + 8))() )\n  {\n    sub_80899AD(a1);\n    free(*v3);\n  }\n  else\n  {\n    (*(void (**)(void))(a1 + 32))();\n    if ( v31 )\n      *v31 = 0;\n    (*(void (**)(void))(a1 + 36))();\n    if ( *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 16) || (*(_DWORD *)a1 & 0x100) != 0 )\n      sub_80AFAC3(v32, *v3);\n    else\n      free(*v3);\n  }\n  *(_QWORD *)(a1 + 44) += *((_QWORD *)v3 + 1);\n  free(v3[1]);\n  return 0;\n}\n"
    ],
    "sub_808E264": [
        "0x808e264",
        "int __usercall sub_808E264@<eax>(const char **a1@<eax>)\n{\n  int v2; // [esp-4h] [ebp-4h]\n\n  puts(*a1);\n  return v2;\n}\n"
    ],
    "sub_808E26D": [
        "0x808e26d",
        "int __usercall sub_808E26D@<eax>(int a1@<eax>)\n{\n  int tm_min; // ebp\n  int tm_hour; // edi\n  int v4; // esi\n  const char *v5; // eax\n  int tm_mday; // [esp+0h] [ebp-5Ch]\n  int v8; // [esp+4h] [ebp-58h]\n  int v9; // [esp+8h] [ebp-54h]\n  __int64 v10; // [esp+Ch] [ebp-50h]\n  int v11; // [esp+14h] [ebp-48h]\n  int tm_sec; // [esp+18h] [ebp-44h]\n  const char *v13; // [esp+1Ch] [ebp-40h]\n  struct tm tp; // [esp+20h] [ebp-3Ch] BYREF\n\n  localtime_r((const time_t *)(a1 + 28), &tp);\n  v13 = *(const char **)a1;\n  tm_sec = tp.tm_sec;\n  tm_min = tp.tm_min;\n  tm_hour = tp.tm_hour;\n  tm_mday = tp.tm_mday;\n  v8 = tp.tm_mon + 1;\n  v9 = tp.tm_year + 1900;\n  v10 = *(_QWORD *)(a1 + 8);\n  v11 = *(_DWORD *)(a1 + 20);\n  v4 = *(_DWORD *)(a1 + 16);\n  v5 = (const char *)sub_80B028A();\n  printf(\n    \"%s %u/%u %9llu %4u-%02u-%02u %02u:%02u:%02u %s\",\n    v5,\n    v4,\n    v11,\n    v10,\n    v9,\n    v8,\n    tm_mday,\n    tm_hour,\n    tm_min,\n    tm_sec,\n    v13);\n  if ( *(_DWORD *)(a1 + 4) )\n    printf(\" -> %s\", *(const char **)(a1 + 4));\n  return sub_804DD98(10);\n}\n"
    ],
    "sub_808E331": [
        "0x808e331",
        "_DWORD *sub_808E331()\n{\n  _DWORD *v0; // ebx\n\n  v0 = sub_804DB2E(0x6Cu);\n  v0[6] = sub_804DB2E(0x28u);\n  v0[8] = nullsub_7;\n  v0[9] = sub_80899AD;\n  v0[2] = sub_808F154;\n  v0[10] = sub_808EF39;\n  v0[21] = -1;\n  v0[22] = -1;\n  return v0;\n}\n"
    ],
    "sub_808E379": [
        "0x808e379",
        "unsigned int __usercall sub_808E379@<eax>(unsigned int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _DWORD *a4, int a5)\n{\n  unsigned __int8 *v5; // ecx\n  unsigned __int8 *v6; // ebp\n  _BYTE *v7; // edx\n  unsigned int v8; // ebx\n  int v9; // edi\n  _BYTE *v10; // esi\n  unsigned int v11; // eax\n  unsigned __int8 *v12; // ebx\n  unsigned int v13; // ebx\n  _BYTE *v14; // edi\n  unsigned int v15; // eax\n  int v16; // edi\n  char v17; // cl\n  char v18; // cl\n  _BYTE *v19; // esi\n  unsigned int v20; // eax\n  unsigned int v21; // edi\n  char v22; // cl\n  _BYTE *i; // esi\n  unsigned int v24; // ecx\n  unsigned int v25; // ebp\n  unsigned int v27; // [esp+0h] [ebp-28h]\n  unsigned __int8 v29; // [esp+8h] [ebp-20h]\n  unsigned __int8 v30; // [esp+9h] [ebp-1Fh]\n  unsigned __int8 v31; // [esp+Ah] [ebp-1Eh]\n  unsigned int v32; // [esp+Ch] [ebp-1Ch]\n  unsigned int v33; // [esp+10h] [ebp-18h]\n\n  v32 = a2 + a1;\n  v33 = a1 + a2 - 13;\n  v5 = (unsigned __int8 *)(a1 + 4);\n  v6 = (unsigned __int8 *)a1;\n  v7 = a3;\n  while ( 1 )\n  {\n    v29 = v5[3];\n    v30 = v5[2];\n    v31 = v5[1];\n    v8 = (unsigned int)(33 * (*v5 ^ (32 * (v31 ^ (32 * (v30 ^ (v29 << 6))))))) >> 5;\n    v9 = v8 & 0x3FFF;\n    v27 = (unsigned int)&v5[-*(_DWORD *)(a5 + 4 * v9)];\n    v10 = *(_BYTE **)(a5 + 4 * v9);\n    if ( v27 - 1 > 0xBFFE )\n      break;\n    if ( (unsigned int)v10 < a1 )\n      break;\n    if ( v27 > 0x800 && v29 != v10[3] )\n    {\n      v9 = v8 & 0x7FF ^ 0x201F;\n      v11 = (unsigned int)&v5[-*(_DWORD *)(a5 + 4 * v9)];\n      v27 = v11;\n      v10 = *(_BYTE **)(a5 + 4 * v9);\n      if ( v11 - 1 > 0xBFFE || (unsigned int)v10 < a1 || v11 > 0x800 && v29 != v10[3] )\n        break;\n    }\n    if ( *v5 != *v10 || v31 != v10[1] || v30 != v10[2] )\n      break;\n    *(_DWORD *)(a5 + 4 * v9) = v5;\n    if ( v5 != v6 )\n    {\n      v13 = v5 - v6;\n      v14 = v7 + 1;\n      if ( (unsigned int)(v5 - v6) > 3 )\n      {\n        if ( v13 > 0x12 )\n        {\n          v15 = v13 - 18;\n          *v7 = 0;\n          while ( 1 )\n          {\n            v7 = v14 + 1;\n            if ( v15 <= 0xFF )\n              break;\n            v15 -= 255;\n            *v14++ = 0;\n          }\n          *v14 = v15;\n        }\n        else\n        {\n          *v7++ = v13 - 3;\n        }\n      }\n      else\n      {\n        *(v7 - 2) |= v13;\n      }\n      v16 = 0;\n      do\n      {\n        v7[v16] = v6[v16];\n        ++v16;\n      }\n      while ( v13 != v16 );\n      v7 += v13;\n      v6 = v5;\n    }\n    v12 = v5 + 4;\n    if ( v10[3] == v5[3] )\n    {\n      v12 = v5 + 5;\n      if ( v10[4] == v5[4] )\n      {\n        v12 = v5 + 6;\n        if ( v10[5] == v5[5] )\n        {\n          v12 = v5 + 7;\n          if ( v10[6] == v5[6] )\n          {\n            v12 = v5 + 8;\n            if ( v10[7] == v5[7] )\n            {\n              v12 = v5 + 9;\n              if ( v10[8] == v5[8] )\n              {\n                for ( i = v10 + 9; (unsigned int)v12 < v32 && *i == *v12; ++i )\n                  ++v12;\n                v24 = v12 - v6;\n                v19 = v7 + 1;\n                if ( v27 <= 0x4000 )\n                {\n                  v20 = v27 - 1;\n                  if ( v24 <= 0x21 )\n                  {\n                    v18 = v24 - 2;\nLABEL_47:\n                    v22 = v18 | 0x20;\nLABEL_39:\n                    *v7 = v22;\nLABEL_55:\n                    *v19 = 4 * v20;\n                    v7 = v19 + 2;\n                    v19[1] = v20 >> 6;\n                    goto LABEL_56;\n                  }\n                  v25 = v24 - 33;\n                  *v7 = 32;\nLABEL_52:\n                  while ( v25 > 0xFF )\n                  {\n                    v25 -= 255;\n                    *v19++ = 0;\n                  }\n                  *v19++ = v25;\n                  goto LABEL_55;\n                }\n                v20 = v27 - 0x4000;\n                v21 = ((v27 - 0x4000) >> 11) & 8 | 0x10;\n                if ( v24 > 9 )\n                {\n                  v25 = v24 - 9;\n                  *v7 = v21;\n                  goto LABEL_52;\n                }\n                v18 = v24 - 2;\nLABEL_38:\n                v22 = v21 | v18;\n                goto LABEL_39;\n              }\n            }\n          }\n        }\n      }\n    }\n    v17 = (_BYTE)--v12 - (_BYTE)v6;\n    if ( v27 > 0x800 )\n    {\n      v18 = v17 - 2;\n      v19 = v7 + 1;\n      if ( v27 <= 0x4000 )\n      {\n        v20 = v27 - 1;\n        goto LABEL_47;\n      }\n      v20 = v27 - 0x4000;\n      v21 = ((v27 - 0x4000) >> 11) & 8 | 0x10;\n      goto LABEL_38;\n    }\n    *v7 = (4 * (v27 - 1)) & 0x1C | (32 * (v17 - 1));\n    v7[1] = (v27 - 1) >> 3;\n    v7 += 2;\nLABEL_56:\n    if ( (unsigned int)v12 >= v33 )\n      goto LABEL_59;\n    v6 = v12;\nLABEL_14:\n    v5 = v12;\n  }\n  *(_DWORD *)(a5 + 4 * v9) = v5;\n  v12 = v5 + 1;\n  if ( v33 > (unsigned int)(v5 + 1) )\n    goto LABEL_14;\n  v12 = v6;\nLABEL_59:\n  *a4 = v7 - a3;\n  return v32 - (_DWORD)v12;\n}\n"
    ],
    "sub_808E648": [
        "0x808e648",
        "int __cdecl sub_808E648(unsigned int a1, unsigned int a2, _BYTE *a3, _DWORD *a4, int a5)\n{\n  unsigned int v5; // edi\n  unsigned int v6; // eax\n  _BYTE *v7; // edx\n  _BYTE *v8; // ecx\n  char v9; // bl\n  unsigned int v10; // ebx\n  int i; // ebx\n\n  v5 = a1;\n  if ( a2 <= 0xD )\n  {\n    if ( !a2 )\n    {\n      v7 = a3;\n      goto LABEL_22;\n    }\n    v6 = a2;\n    v7 = a3;\n  }\n  else\n  {\n    v6 = sub_808E379(a1, a2, a3, a4, a5);\n    v7 = &a3[*a4];\n    if ( !v6 )\n      goto LABEL_22;\n    v5 = a2 - v6 + a1;\n    if ( a3 != v7 )\n    {\n      if ( v6 <= 3 )\n      {\n        *(v7 - 2) |= v6;\n        goto LABEL_18;\n      }\n      goto LABEL_11;\n    }\n  }\n  v8 = v7 + 1;\n  v9 = v6 + 17;\n  if ( v6 > 0xEE )\n  {\nLABEL_11:\n    v8 = v7 + 1;\n    if ( v6 > 0x12 )\n    {\n      v10 = v6 - 18;\n      *v7 = 0;\n      while ( 1 )\n      {\n        v7 = v8 + 1;\n        if ( v10 <= 0xFF )\n          break;\n        v10 -= 255;\n        *v8++ = 0;\n      }\n      *v8 = v10;\n      goto LABEL_18;\n    }\n    v9 = v6 - 3;\n  }\n  *v7 = v9;\n  v7 = v8;\nLABEL_18:\n  for ( i = 0; i != v6; ++i )\n    v7[i] = *(_BYTE *)(v5 + i);\n  v7 += v6;\nLABEL_22:\n  *(_WORD *)v7 = 17;\n  v7[2] = 0;\n  *a4 = v7 + 3 - a3;\n  return 0;\n}\n"
    ],
    "sub_808E704": [
        "0x808e704",
        "unsigned int __usercall sub_808E704@<eax>(unsigned int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _DWORD *a4, int a5)\n{\n  unsigned __int8 *v5; // ecx\n  unsigned __int8 *v6; // ebp\n  _BYTE *v7; // edx\n  unsigned int v8; // ebx\n  int v9; // edi\n  _BYTE *v10; // esi\n  unsigned int v11; // eax\n  unsigned __int8 *v12; // ebx\n  unsigned int v13; // ebx\n  _BYTE *v14; // edi\n  unsigned int v15; // eax\n  int v16; // edi\n  char v17; // cl\n  char v18; // cl\n  _BYTE *v19; // esi\n  unsigned int v20; // eax\n  unsigned int v21; // edi\n  char v22; // cl\n  _BYTE *i; // esi\n  unsigned int v24; // ecx\n  unsigned int v25; // ebp\n  unsigned int v27; // [esp+0h] [ebp-28h]\n  unsigned __int8 v29; // [esp+8h] [ebp-20h]\n  unsigned __int8 v30; // [esp+9h] [ebp-1Fh]\n  unsigned __int8 v31; // [esp+Ah] [ebp-1Eh]\n  unsigned int v32; // [esp+Ch] [ebp-1Ch]\n  unsigned int v33; // [esp+10h] [ebp-18h]\n\n  v32 = a2 + a1;\n  v33 = a1 + a2 - 13;\n  v5 = (unsigned __int8 *)(a1 + 4);\n  v6 = (unsigned __int8 *)a1;\n  v7 = a3;\n  while ( 1 )\n  {\n    v29 = v5[3];\n    v30 = v5[2];\n    v31 = v5[1];\n    v8 = (unsigned int)(33 * (*v5 ^ (32 * (v31 ^ (32 * (v30 ^ (v29 << 6))))))) >> 5;\n    v9 = v8 & 0x7FFF;\n    v27 = (unsigned int)&v5[-*(_DWORD *)(a5 + 4 * v9)];\n    v10 = *(_BYTE **)(a5 + 4 * v9);\n    if ( v27 - 1 > 0xBFFE )\n      break;\n    if ( (unsigned int)v10 < a1 )\n      break;\n    if ( v27 > 0x800 && v29 != v10[3] )\n    {\n      v9 = v8 & 0x7FF ^ 0x401F;\n      v11 = (unsigned int)&v5[-*(_DWORD *)(a5 + 4 * v9)];\n      v27 = v11;\n      v10 = *(_BYTE **)(a5 + 4 * v9);\n      if ( v11 - 1 > 0xBFFE || (unsigned int)v10 < a1 || v11 > 0x800 && v29 != v10[3] )\n        break;\n    }\n    if ( *v5 != *v10 || v31 != v10[1] || v30 != v10[2] )\n      break;\n    *(_DWORD *)(a5 + 4 * v9) = v5;\n    if ( v5 != v6 )\n    {\n      v13 = v5 - v6;\n      v14 = v7 + 1;\n      if ( (unsigned int)(v5 - v6) > 3 )\n      {\n        if ( v13 > 0x12 )\n        {\n          v15 = v13 - 18;\n          *v7 = 0;\n          while ( 1 )\n          {\n            v7 = v14 + 1;\n            if ( v15 <= 0xFF )\n              break;\n            v15 -= 255;\n            *v14++ = 0;\n          }\n          *v14 = v15;\n        }\n        else\n        {\n          *v7++ = v13 - 3;\n        }\n      }\n      else\n      {\n        *(v7 - 2) |= v13;\n      }\n      v16 = 0;\n      do\n      {\n        v7[v16] = v6[v16];\n        ++v16;\n      }\n      while ( v13 != v16 );\n      v7 += v13;\n      v6 = v5;\n    }\n    v12 = v5 + 4;\n    if ( v10[3] == v5[3] )\n    {\n      v12 = v5 + 5;\n      if ( v10[4] == v5[4] )\n      {\n        v12 = v5 + 6;\n        if ( v10[5] == v5[5] )\n        {\n          v12 = v5 + 7;\n          if ( v10[6] == v5[6] )\n          {\n            v12 = v5 + 8;\n            if ( v10[7] == v5[7] )\n            {\n              v12 = v5 + 9;\n              if ( v10[8] == v5[8] )\n              {\n                for ( i = v10 + 9; (unsigned int)v12 < v32 && *i == *v12; ++i )\n                  ++v12;\n                v24 = v12 - v6;\n                v19 = v7 + 1;\n                if ( v27 <= 0x4000 )\n                {\n                  v20 = v27 - 1;\n                  if ( v24 <= 0x21 )\n                  {\n                    v18 = v24 - 2;\nLABEL_47:\n                    v22 = v18 | 0x20;\nLABEL_39:\n                    *v7 = v22;\nLABEL_55:\n                    *v19 = 4 * v20;\n                    v7 = v19 + 2;\n                    v19[1] = v20 >> 6;\n                    goto LABEL_56;\n                  }\n                  v25 = v24 - 33;\n                  *v7 = 32;\nLABEL_52:\n                  while ( v25 > 0xFF )\n                  {\n                    v25 -= 255;\n                    *v19++ = 0;\n                  }\n                  *v19++ = v25;\n                  goto LABEL_55;\n                }\n                v20 = v27 - 0x4000;\n                v21 = ((v27 - 0x4000) >> 11) & 8 | 0x10;\n                if ( v24 > 9 )\n                {\n                  v25 = v24 - 9;\n                  *v7 = v21;\n                  goto LABEL_52;\n                }\n                v18 = v24 - 2;\nLABEL_38:\n                v22 = v21 | v18;\n                goto LABEL_39;\n              }\n            }\n          }\n        }\n      }\n    }\n    v17 = (_BYTE)--v12 - (_BYTE)v6;\n    if ( v27 > 0x800 )\n    {\n      v18 = v17 - 2;\n      v19 = v7 + 1;\n      if ( v27 <= 0x4000 )\n      {\n        v20 = v27 - 1;\n        goto LABEL_47;\n      }\n      v20 = v27 - 0x4000;\n      v21 = ((v27 - 0x4000) >> 11) & 8 | 0x10;\n      goto LABEL_38;\n    }\n    *v7 = (4 * (v27 - 1)) & 0x1C | (32 * (v17 - 1));\n    v7[1] = (v27 - 1) >> 3;\n    v7 += 2;\nLABEL_56:\n    if ( (unsigned int)v12 >= v33 )\n      goto LABEL_59;\n    v6 = v12;\nLABEL_14:\n    v5 = v12;\n  }\n  *(_DWORD *)(a5 + 4 * v9) = v5;\n  v12 = v5 + 1;\n  if ( v33 > (unsigned int)(v5 + 1) )\n    goto LABEL_14;\n  v12 = v6;\nLABEL_59:\n  *a4 = v7 - a3;\n  return v32 - (_DWORD)v12;\n}\n"
    ],
    "sub_808E9D3": [
        "0x808e9d3",
        "int __cdecl sub_808E9D3(unsigned int a1, unsigned int a2, _BYTE *a3, _DWORD *a4, int a5)\n{\n  unsigned int v5; // edi\n  unsigned int v6; // eax\n  _BYTE *v7; // edx\n  _BYTE *v8; // ecx\n  char v9; // bl\n  unsigned int v10; // ebx\n  int i; // ebx\n\n  v5 = a1;\n  if ( a2 <= 0xD )\n  {\n    if ( !a2 )\n    {\n      v7 = a3;\n      goto LABEL_22;\n    }\n    v6 = a2;\n    v7 = a3;\n  }\n  else\n  {\n    v6 = sub_808E704(a1, a2, a3, a4, a5);\n    v7 = &a3[*a4];\n    if ( !v6 )\n      goto LABEL_22;\n    v5 = a2 - v6 + a1;\n    if ( a3 != v7 )\n    {\n      if ( v6 <= 3 )\n      {\n        *(v7 - 2) |= v6;\n        goto LABEL_18;\n      }\n      goto LABEL_11;\n    }\n  }\n  v8 = v7 + 1;\n  v9 = v6 + 17;\n  if ( v6 > 0xEE )\n  {\nLABEL_11:\n    v8 = v7 + 1;\n    if ( v6 > 0x12 )\n    {\n      v10 = v6 - 18;\n      *v7 = 0;\n      while ( 1 )\n      {\n        v7 = v8 + 1;\n        if ( v10 <= 0xFF )\n          break;\n        v10 -= 255;\n        *v8++ = 0;\n      }\n      *v8 = v10;\n      goto LABEL_18;\n    }\n    v9 = v6 - 3;\n  }\n  *v7 = v9;\n  v7 = v8;\nLABEL_18:\n  for ( i = 0; i != v6; ++i )\n    v7[i] = *(_BYTE *)(v5 + i);\n  v7 += v6;\nLABEL_22:\n  *(_WORD *)v7 = 17;\n  v7[2] = 0;\n  *a4 = v7 + 3 - a3;\n  return 0;\n}\n"
    ],
    "sub_808EA8F": [
        "0x808ea8f",
        "int __cdecl sub_808EA8F(unsigned __int8 *a1, int a2, unsigned int a3, unsigned int *a4)\n{\n  unsigned int v4; // ebp\n  int v5; // eax\n  unsigned __int8 *v6; // edi\n  unsigned int v7; // edx\n  unsigned int v8; // ebx\n  int v9; // eax\n  unsigned __int8 *v10; // ecx\n  _BYTE *v11; // eax\n  unsigned __int8 *v12; // edx\n  unsigned int v13; // ebx\n  _BYTE *v14; // edx\n  int v15; // ecx\n  unsigned int v16; // edx\n  unsigned int v17; // ebx\n  bool v18; // cf\n  _BYTE *v19; // ecx\n  unsigned int v20; // ebp\n  unsigned int v21; // edx\n  int v22; // ecx\n  int v23; // ebp\n  int v24; // ecx\n  _BYTE *v25; // ecx\n  int v26; // ebx\n  _BYTE *v27; // ebx\n  _BYTE *v28; // edx\n  int v29; // eax\n  unsigned __int8 v30; // dl\n  _BYTE *v31; // edx\n  unsigned __int8 *v32; // ebp\n  int v33; // ecx\n  unsigned __int8 *v34; // ecx\n  _BYTE *v35; // edi\n  int v36; // eax\n  int result; // eax\n  unsigned int v38; // [esp+0h] [ebp-18h]\n  unsigned int v39; // [esp+4h] [ebp-14h]\n\n  v38 = (unsigned int)&a1[a2];\n  v4 = *a4;\n  v39 = a3 + *a4;\n  *a4 = 0;\n  v5 = *a1;\n  if ( (unsigned __int8)v5 <= 0x11u )\n  {\n    v6 = a1;\n    v11 = (_BYTE *)a3;\n    goto LABEL_14;\n  }\n  v6 = a1 + 1;\n  v7 = v5 - 17;\n  v8 = v5 - 17;\n  if ( v5 - 17 <= 3 )\n  {\n    v31 = (_BYTE *)a3;\n    goto LABEL_51;\n  }\n  if ( v4 < v7 )\n  {\n    v11 = (_BYTE *)a3;\n    goto LABEL_77;\n  }\n  if ( a2 - 1 < (unsigned int)(v5 - 16) )\n  {\n    v11 = (_BYTE *)a3;\n    goto LABEL_74;\n  }\n  v9 = 0;\n  do\n  {\n    *(_BYTE *)(a3 + v9) = a1[v9 + 1];\n    ++v9;\n  }\n  while ( v7 != v9 );\n  v10 = &v6[v7];\n  v11 = (_BYTE *)(a3 + v7);\n  while ( 2 )\n  {\n    v12 = v10 + 1;\n    v13 = *v10;\n    if ( v13 <= 0xF )\n    {\n      v6 = v10 + 2;\n      v14 = &v11[-2049 - (v13 >> 2) - 4 * v10[1]];\n      if ( a3 > (unsigned int)v14 || v11 <= v14 )\n      {\nLABEL_78:\n        *a4 = (unsigned int)&v11[-a3];\n        return -6;\n      }\n      if ( v39 - (unsigned int)v11 > 2 )\n      {\n        *v11 = *v14;\n        v11[1] = v14[1];\n        v11[2] = v14[2];\n        v11 += 3;\n        goto LABEL_48;\n      }\nLABEL_77:\n      *a4 = (unsigned int)&v11[-a3];\n      return -5;\n    }\n    do\n    {\n      while ( 1 )\n      {\n        if ( v13 > 0x3F )\n        {\n          v6 = v12 + 1;\n          v15 = ~((v13 >> 2) & 7) - 8 * *v12;\n          v16 = v13 >> 5;\n          v17 = (v13 >> 5) - 1;\n          v18 = __CFADD__(v11, v15);\n          v19 = &v11[v15];\n          if ( !v18 || a3 > (unsigned int)v19 )\n            goto LABEL_78;\n          v20 = v39 - (_DWORD)v11;\n          v21 = v16 + 1;\nLABEL_44:\n          if ( v20 < v21 )\n            goto LABEL_77;\n          *v11 = *v19;\n          v28 = v11 + 2;\n          v11[1] = v19[1];\n          v29 = 0;\n          do\n          {\n            v28[v29] = v19[v29 + 2];\n            ++v29;\n          }\n          while ( v17 != v29 );\n          v11 = &v28[v17];\n          goto LABEL_48;\n        }\n        if ( v13 > 0x1F )\n        {\n          v17 = v13 & 0x1F;\n          if ( !v17 )\n          {\n            while ( v12 != (unsigned __int8 *)v38 )\n            {\n              v22 = *v12;\n              if ( (_BYTE)v22 )\n              {\n                if ( v17 > 0xFFFFFE01 )\n                  goto LABEL_74;\n                ++v12;\n                v17 += v22 + 31;\n                goto LABEL_27;\n              }\n              v17 += 255;\n              ++v12;\n            }\n            goto LABEL_74;\n          }\nLABEL_27:\n          v19 = &v11[~((v12[1] << 6) + (*v12 >> 2))];\n          v6 = v12 + 2;\nLABEL_41:\n          if ( v11 <= v19 || (unsigned int)v19 < a3 )\n            goto LABEL_78;\n          v20 = v39 - (_DWORD)v11;\n          v21 = v17 + 2;\n          goto LABEL_44;\n        }\n        if ( v13 > 0xF )\n        {\n          v23 = ((_WORD)v13 << 11) & 0x4000;\n          v17 = v13 & 7;\n          if ( !v17 )\n          {\n            while ( v12 != (unsigned __int8 *)v38 )\n            {\n              v24 = *v12;\n              if ( (_BYTE)v24 )\n              {\n                if ( v17 > 0xFFFFFE01 )\n                  goto LABEL_74;\n                ++v12;\n                v17 += v24 + 7;\n                goto LABEL_35;\n              }\n              v17 += 255;\n              ++v12;\n            }\n            goto LABEL_74;\n          }\nLABEL_35:\n          v25 = &v11[-v23 - (*v12 >> 2) + -64 * v12[1]];\n          v6 = v12 + 2;\n          if ( v11 == v25 )\n          {\n            *a4 = (unsigned int)&v11[-a3];\n            result = 0;\n            if ( (unsigned __int8 *)v38 != v6 )\n              return (unsigned int)v6 < v38 ? -8 : -4;\n            return result;\n          }\n          v19 = v25 - 0x4000;\n          goto LABEL_41;\n        }\n        v6 = v12 + 1;\n        v26 = ~(v13 >> 2) - 4 * *v12;\n        v18 = __CFADD__(v11, v26);\n        v27 = &v11[v26];\n        if ( !v18 || a3 > (unsigned int)v27 )\n          goto LABEL_78;\n        if ( v39 - (unsigned int)v11 <= 1 )\n          goto LABEL_77;\n        *v11 = *v27;\n        v11[1] = v27[1];\n        v11 += 2;\nLABEL_48:\n        v30 = *(v6 - 2) & 3;\n        v8 = v30;\n        if ( !v30 )\n          break;\n        v31 = v11;\nLABEL_51:\n        if ( v39 - (unsigned int)v31 < v8 )\n        {\n          v11 = v31;\n          goto LABEL_77;\n        }\n        if ( v38 - (unsigned int)v6 < v8 + 1 )\n        {\n          v11 = v31;\n          goto LABEL_74;\n        }\n        v32 = v6 + 1;\n        v11 = v31 + 1;\n        *v31 = *v6;\n        if ( v8 > 1 )\n        {\n          v32 = v6 + 2;\n          v11 = v31 + 2;\n          v31[1] = v6[1];\n          if ( v8 == 3 )\n          {\n            v32 = v6 + 3;\n            v11 = v31 + 3;\n            v31[2] = v6[2];\n          }\n        }\n        v12 = v32 + 1;\n        v13 = *v32;\n        if ( v38 <= (unsigned int)(v32 + 1) )\n        {\nLABEL_69:\n          *a4 = (unsigned int)&v11[-a3];\n          return -7;\n        }\n      }\nLABEL_14:\n      if ( (unsigned int)v6 >= v38 )\n        goto LABEL_69;\n      v12 = v6 + 1;\n      v13 = *v6;\n    }\n    while ( v13 > 0xF );\n    if ( *v6 )\n    {\nLABEL_64:\n      if ( v39 - (unsigned int)v11 < v13 + 3 )\n        goto LABEL_77;\n      if ( v38 - (unsigned int)v12 >= v13 + 4 )\n      {\n        *v11 = *v12;\n        v11[1] = v12[1];\n        v34 = v12 + 3;\n        v35 = v11 + 3;\n        v11[2] = v12[2];\n        v36 = 0;\n        do\n        {\n          v35[v36] = v34[v36];\n          ++v36;\n        }\n        while ( v13 != v36 );\n        v10 = &v34[v13];\n        v11 = &v35[v13];\n        continue;\n      }\n    }\n    else\n    {\n      while ( v12 != (unsigned __int8 *)v38 )\n      {\n        v33 = *v12;\n        if ( (_BYTE)v33 )\n        {\n          if ( v13 > 0xFFFFFE01 )\n            goto LABEL_74;\n          ++v12;\n          v13 += v33 + 15;\n          goto LABEL_64;\n        }\n        v13 += 255;\n        ++v12;\n      }\n    }\n    break;\n  }\nLABEL_74:\n  *a4 = (unsigned int)&v11[-a3];\n  return -4;\n}\n"
    ],
    "sub_808EE43": [
        "0x808ee43",
        "int __usercall sub_808EE43@<eax>(void *a1@<eax>)\n{\n  int result; // eax\n\n  result = 0;\n  memset(a1, 0, 0x34u);\n  return result;\n}\n"
    ],
    "sub_808EE53": [
        "0x808ee53",
        "int __usercall sub_808EE53@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ebx>)\n{\n  unsigned __int16 v6; // [esp+0h] [ebp-Ah] BYREF\n  int v7; // [esp+2h] [ebp-8h]\n\n  if ( *(_BYTE *)a1 )\n    return 0;\n  v7 = a3;\n  v6 = HIWORD(a3);\n  if ( sub_804E5E3(*(_DWORD *)(a1 + 8), (char *)&v6, 2u) == 2 && v6 == a2 )\n  {\n    *(_BYTE *)a1 = 2;\n    return 0;\n  }\n  else\n  {\n    sub_804D5F4(\"invalid magic\");\n    return -1;\n  }\n}\n"
    ],
    "sub_808EE9C": [
        "0x808ee9c",
        "int __usercall sub_808EE9C@<eax>(int a1@<eax>, void *a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned int v5; // edx\n  int v6; // edi\n  int v7; // ebp\n  void *v8; // eax\n  char *v9; // eax\n  int result; // eax\n\n  v5 = *(_DWORD *)(a1 + 16);\n  if ( v5 )\n  {\n    v6 = *(_DWORD *)(a1 + 20);\n    v7 = a3 + v6;\n    *(_DWORD *)(a1 + 20) = a3 + v6;\n    v8 = *(void **)(a1 + 24);\n    if ( v5 >= a3 + v6 )\n    {\n      v9 = (char *)sub_804DB13(v8, v7 + 1);\n      *(_DWORD *)(a1 + 24) = v9;\n      qmemcpy(&v9[v6], a2, a3);\n      *(_BYTE *)(*(_DWORD *)(a1 + 24) + v7) = 0;\n      return a3;\n    }\n    free(*(void **)(a1 + 24));\n    *(_DWORD *)(a1 + 24) = 0;\n    sub_804D3A5((int)\"buffer %u too small\", *(_DWORD *)(a1 + 16));\n  }\n  else\n  {\n    result = sub_804E586(a3, (char *)a2);\n    if ( a3 == result )\n      return result;\n    sub_804D3A5((int)\"write\");\n  }\n  return -1;\n}\n"
    ],
    "sub_808EF24": [
        "0x808ef24",
        "unsigned int __usercall sub_808EF24@<eax>(int a1@<eax>, void *a2@<edx>, unsigned int a3@<ecx>)\n{\n  if ( a3 != sub_808EE9C(a1, a2, a3) )\n    sub_804D604();\n  return a3;\n}\n"
    ],
    "sub_808EF39": [
        "0x808ef39",
        "int __usercall sub_808EF39@<eax>(int result@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)\n{\n  int v5; // edx\n\n  if ( __PAIR64__(a3, a2) )\n  {\n    result = lseek64();\n    if ( v5 == -1 && !++result )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 29 )\n        sub_804D3C9((int)\"seek failure\");\n      return sub_808EF81(a3, a2);\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_808EF81": [
        "0x808ef81",
        "int __usercall sub_808EF81@<eax>(int result@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)\n{\n  if ( __PAIR64__(a3, a2) )\n    return sub_804E51A(result, -1, __SPAIR64__(a3, a2));\n  return result;\n}\n"
    ],
    "sub_808EF94": [
        "0x808ef94",
        "int __usercall sub_808EF94@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  char v3[11]; // [esp+1h] [ebp-Bh] BYREF\n\n  sub_80B24F6(7, v3);\n  if ( !sub_804D210(v3, \"!<arch>\") )\n    sub_804D5E0(\"invalid ar magic\");\n  *(_QWORD *)(a1 + 44) += 7LL;\n  do\n    result = sub_808F17B();\n  while ( !(_BYTE)result );\n  return result;\n}\n"
    ],
    "sub_808EFDF": [
        "0x808efdf",
        "char *__usercall sub_808EFDF@<eax>(const char *a1@<eax>)\n{\n  char *i; // ebx\n  char *v3; // eax\n\n  for ( i = (char *)a1; ; i = v3 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *i == 47 )\n        ++i;\n      if ( !sub_804D210(i, \"../\") )\n        break;\n      i += 3;\n    }\n    v3 = strstr(i, \"/../\");\n    if ( !v3 )\n      break;\n  }\n  if ( i != a1 && !byte_80DB770 )\n  {\n    byte_80DB770 = 1;\n    sub_804D5F4(\"removing leading '%.*s' from member names\", i - a1, a1);\n  }\n  return i;\n}\n"
    ],
    "sub_808F044": [
        "0x808f044",
        "int __fastcall sub_808F044(char *to, char *from, int a3)\n{\n  char *v5; // eax\n  int v6; // ecx\n  int result; // eax\n\n  if ( a3 || *from == 47 || strstr(from, \"..\") )\n  {\n    v5 = sub_804DDBF(\"%c%s%c%s\", a3, to, 0, from);\n    return sub_80AFADF(v6, v5);\n  }\n  else\n  {\n    result = symlink(from, to);\n    if ( result )\n      sub_804D3C9((int)\"can't create %slink '%s' to '%s'\", \"sym\", to, from);\n  }\n  return result;\n}\n"
    ],
    "sub_808F0AE": [
        "0x808f0ae",
        "int __usercall sub_808F0AE@<eax>(int result@<eax>)\n{\n  _DWORD *i; // ebx\n  int v2; // esi\n  const char *v3; // edi\n  int (*v4)(const char *, const char *); // eax\n  int v5; // edx\n  const char *v6; // eax\n\n  for ( i = (_DWORD *)result; i; i = (_DWORD *)*i )\n  {\n    v2 = i[1];\n    v3 = (const char *)(v2 + strlen((const char *)(v2 + 1)) + 2);\n    v4 = link;\n    if ( !*(_BYTE *)v2 )\n      v4 = symlink;\n    result = v4(v3, (const char *)(v2 + 1));\n    if ( result )\n    {\n      v5 = i[1];\n      v6 = \"hard\";\n      if ( !*(_BYTE *)v5 )\n        v6 = \"sym\";\n      sub_804D5E0(\"can't create %slink '%s' to '%s'\", v6, (const char *)(v5 + 1), v3);\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_808F10D": [
        "0x808f10d",
        "int __usercall sub_808F10D@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  __int64 v4; // rax\n  unsigned int v5; // esi\n  int result; // eax\n\n  v4 = sub_80B4A4A(*(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48), a2, 0);\n  v5 = sub_80B4A4A(a2 - (unsigned int)v4, ((unsigned __int64)a2 - v4) >> 32, a2, 0);\n  result = (*(int (__fastcall **)(_DWORD, unsigned int))(a1 + 40))(0, v5);\n  *(_QWORD *)(a1 + 44) += v5;\n  return result;\n}\n"
    ],
    "sub_808F154": [
        "0x808f154",
        "bool __usercall sub_808F154@<al>(int a1@<eax>)\n{\n  return **(_DWORD **)(a1 + 24) == 0;\n}\n"
    ],
    "sub_808F15E": [
        "0x808f15e",
        "int __usercall sub_808F15E@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>)\n{\n  int result; // eax\n\n  a1[a3] = 0;\n  result = sub_804ED6C(a2, a1, 0, a4);\n  if ( result == -1 )\n    sub_804D5E0(\"invalid ar header\");\n  return result;\n}\n"
    ],
    "sub_808F17B": [
        "0x808f17b",
        "char __usercall sub_808F17B@<al>(int a1@<eax>)\n{\n  const char **v2; // esi\n  int v3; // edi\n  const char *v5; // edi\n  int v6; // [esp-8h] [ebp-54h]\n  int v7; // [esp-4h] [ebp-50h]\n  char buf; // [esp+0h] [ebp-4Ch] BYREF\n  char src[15]; // [esp+1h] [ebp-4Bh] BYREF\n  char v10[12]; // [esp+10h] [ebp-3Ch] BYREF\n  char v11[6]; // [esp+1Ch] [ebp-30h] BYREF\n  char v12[6]; // [esp+22h] [ebp-2Ah] BYREF\n  char v13[8]; // [esp+28h] [ebp-24h] BYREF\n  char v14[11]; // [esp+30h] [ebp-1Ch] BYREF\n  char v15; // [esp+3Bh] [ebp-11h]\n\n  v2 = *(const char ***)(a1 + 24);\n  if ( read(*(_DWORD *)(a1 + 4), &buf, 0x3Cu) != 60 )\n    return 1;\n  if ( buf == 10 )\n  {\n    memmove(&buf, src, 0x3Bu);\n    v15 = sub_80B2513();\n    ++*(_QWORD *)(a1 + 44);\n  }\n  *(_QWORD *)(a1 + 44) += 60LL;\n  if ( v14[10] != 96 || v15 != 10 )\n    sub_804D5E0(\"invalid ar header\");\n  v3 = sub_808F15E(v14, 10, 10, a1);\n  v2[2] = (const char *)v3;\n  v2[3] = 0;\n  if ( buf == 47 )\n  {\n    if ( src[0] != 32 )\n      sub_804D5E0(\"long filenames not supported\");\n    sub_80899AD(a1);\n    *(_QWORD *)(a1 + 44) += (unsigned int)v3;\n    return sub_808F17B();\n  }\n  else\n  {\n    v2[6] = (const char *)sub_808F15E(v13, 8, 8, a1);\n    v2[5] = (const char *)sub_808F15E(v12, 10, 6, a1);\n    v2[4] = (const char *)sub_808F15E(v11, 10, 6, a1);\n    v2[7] = (const char *)sub_808F15E(v10, 10, 12, a1);\n    v5 = sub_804DB5D(&buf, 16);\n    *v2 = v5;\n    v5[strcspn(v5, \" /\")] = 0;\n    if ( (*(unsigned __int8 (__fastcall **)(int, int))(a1 + 8))(v7, v6) )\n    {\n      sub_80899AD(a1);\n    }\n    else\n    {\n      (*(void (**)(void))(a1 + 32))();\n      (*(void (**)(void))(a1 + 36))();\n    }\n    *(_QWORD *)(a1 + 44) += *((_QWORD *)v2 + 1);\n    lseek64();\n    return 0;\n  }\n}\n"
    ],
    "nullsub_7": [
        "0x808f2fe",
        "void nullsub_7()\n{\n  ;\n}\n"
    ],
    "sub_808F2FF": [
        "0x808f2ff",
        "int sub_808F2FF()\n{\n  sub_80B2E5A();\n  sub_80B40CC(63, 1);\n  sub_80AB6D3();\n  sub_80AB77C();\n  return 0;\n}\n"
    ],
    "sub_808F32A": [
        "0x808f32a",
        "_BOOL4 sub_808F32A()\n{\n  return sub_804D846(\"\\x1B[H\\x1B[J\") != 6;\n}\n"
    ],
    "sub_808F33E": [
        "0x808f33e",
        "int __cdecl sub_808F33E(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // eax\n\n  if ( *(_DWORD *)(a2 + 4) )\n  {\n    if ( *(_DWORD *)(a2 + 8) )\n      sub_804CDC2();\n    v2 = sub_80B40CC(63, 1);\n  }\n  else\n  {\n    v2 = 0;\n  }\n  v3 = sub_80AB6D3();\n  sub_804E0BE(v3, 0x5608u, v2, \"VT_DISALLOCATE\");\n  return 0;\n}\n"
    ],
    "sub_808F384": [
        "0x808f384",
        "int __cdecl sub_808F384(int a1, int a2)\n{\n  int v2; // ecx\n  int v3; // ebp\n  int i; // ebx\n  int j; // esi\n  int v7; // [esp+0h] [ebp-14h] BYREF\n\n  v7 = v2;\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v3 = sub_80AB6D3(v7);\n  qmemcpy(&qword_80DB778, &unk_80D5770, 0x15u);\n  write(1, &qword_80DB778, 0x107u);\n  for ( i = 0; i != 13; ++i )\n  {\n    if ( *(_BYTE *)(i + 135116671) )\n    {\n      for ( j = 0; j != 128; ++j )\n      {\n        BYTE1(v7) = j;\n        LOBYTE(v7) = i;\n        if ( !sub_804E062(v3, 0x4B46u, (int)&v7, \"ioctl(KDGKBENT{%d,%d}) failed\", j, i) )\n          write(1, (char *)&v7 + 2, 2u);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_808F41E": [
        "0x808f41e",
        "int __cdecl sub_808F41E(int a1, int a2)\n{\n  int v2; // eax\n  _BYTE *v3; // ebx\n  unsigned __int8 v4; // al\n  char *v5; // esi\n  int v6; // ebp\n  int v7; // eax\n  char *v8; // eax\n  void *v9; // ebx\n  int i; // edx\n  int v11; // ebx\n  int v12; // edi\n  int v13; // esi\n  unsigned __int8 *v14; // ebp\n  unsigned __int16 v15; // ax\n  int v16; // ecx\n  int v17; // edx\n  unsigned __int8 v18; // si\n  int v20; // [esp-8h] [ebp-68h]\n  int v21; // [esp+0h] [ebp-60h]\n  unsigned __int8 *v22; // [esp+4h] [ebp-5Ch]\n  int v23; // [esp+8h] [ebp-58h]\n  char *j; // [esp+8h] [ebp-58h]\n  int v25; // [esp+Ch] [ebp-54h]\n  unsigned int v26; // [esp+10h] [ebp-50h]\n  int v27; // [esp+10h] [ebp-50h]\n  int v28; // [esp+14h] [ebp-4Ch]\n  _BYTE *v29; // [esp+18h] [ebp-48h]\n  char *v30; // [esp+18h] [ebp-48h]\n  int v31; // [esp+1Ch] [ebp-44h]\n  int v32; // [esp+20h] [ebp-40h]\n  int v33; // [esp+24h] [ebp-3Ch]\n  int v34; // [esp+32h] [ebp-2Eh] BYREF\n  __int16 v35; // [esp+36h] [ebp-2Ah]\n  int v36; // [esp+38h] [ebp-28h] BYREF\n  char *v37; // [esp+3Ch] [ebp-24h]\n  int v38; // [esp+40h] [ebp-20h]\n  int v39; // [esp+44h] [ebp-1Ch]\n  int v40; // [esp+48h] [ebp-18h]\n  void *v41; // [esp+4Ch] [ebp-14h]\n\n  sub_80ABEAC(a2, \"^\");\n  v2 = sub_80B2402(v20);\n  if ( !v2 )\n    sub_804D3C9((int)\"error reading input font\");\n  v3 = (_BYTE *)v2;\n  v28 = sub_80AB6D3();\n  if ( *v3 == 54 && v3[1] == 4 )\n  {\n    v4 = v3[2];\n    if ( v4 > 5u )\n      sub_804D5E0(\"unsupported psf file mode\");\n    v21 = (v4 & 1) == 0 ? 256 : 512;\n    v25 = (v4 & 2) != 0;\n    v23 = (unsigned __int8)v3[3];\n    v5 = v3 + 4;\n    v26 = v23;\n    goto LABEL_13;\n  }\n  if ( *(_DWORD *)v3 != -2041924238 )\n  {\n    v23 = 512;\n    v5 = v3;\n    v26 = 512;\n    v25 = 0;\n    v21 = 256;\nLABEL_13:\n    v6 = 8;\n    goto LABEL_14;\n  }\n  if ( *((_DWORD *)v3 + 1) )\n    sub_804D5E0(\"unsupported psf file version\");\n  v21 = *((_DWORD *)v3 + 4);\n  v25 = -(v3[12] & 1) & 2;\n  v26 = *((_DWORD *)v3 + 5);\n  v23 = *((_DWORD *)v3 + 6);\n  v6 = *((_DWORD *)v3 + 7);\n  v5 = &v3[*((_DWORD *)v3 + 2)];\nLABEL_14:\n  v22 = (unsigned __int8 *)&v5[v21 * v26];\n  v29 = v3 + 0x20000;\n  if ( v22 > v3 + 0x20000 || v22 != v3 + 0x20000 && !v25 )\n    sub_804D5E0(\"input file: bad length\");\n  v31 = 32 * ((v6 + 7) / 8);\n  if ( (unsigned int)(v23 - 1) > 0x1F || (unsigned int)(v6 - 1) > 0x1F )\n    sub_804D5E0(\"bad character size %dx%d\", v23, v6);\n  v7 = v21;\n  if ( v21 < 128 )\n    v7 = 128;\n  v8 = (char *)sub_804DB2E(v31 * v7);\n  v9 = v8;\n  for ( i = 0; v21 > i; ++i )\n  {\n    qmemcpy(v8, v5, v26);\n    v5 += v26;\n    v8 += v31;\n  }\n  v36 = 0;\n  v37 = 0;\n  v38 = v6;\n  v39 = v23;\n  v40 = v21;\n  v41 = v9;\n  sub_804E0BE(v28, 0x4B72u, (int)&v36, \"KDFONTOP\");\n  free(v9);\n  if ( v25 )\n  {\n    v11 = v29 - v22;\n    v30 = (char *)sub_804DAFA(4 * (v29 - v22));\n    v27 = 0;\n    v12 = 0;\n    while ( v21 > v27 )\n    {\n      for ( j = &v30[4 * v12]; ; j += 4 )\n      {\n        v13 = v11;\n        v14 = v22;\n        if ( v11 <= 0 )\n          break;\n        v15 = *v22;\n        if ( v25 == 1 )\n        {\n          v15 += v22[1] << 8;\n          v11 -= 2;\n          v22 += 2;\n          if ( v15 == 0xFFFF )\n            break;\n        }\n        else\n        {\n          --v11;\n          ++v22;\n          if ( v15 == 255 )\n            break;\n          if ( v15 == 254 )\n            sub_804D5E0(\"unicode sequences not implemented\");\n          if ( v15 > 0xBFu )\n          {\n            if ( v15 <= 0xFBu )\n            {\n              if ( v15 <= 0xF7u )\n              {\n                if ( v15 <= 0xEFu )\n                {\n                  if ( v15 <= 0xDFu )\n                  {\n                    v15 &= 0x1Fu;\n                    v16 = 1;\n                  }\n                  else\n                  {\n                    v15 &= 0xFu;\n                    v16 = 2;\n                  }\n                }\n                else\n                {\n                  v15 &= 7u;\n                  v16 = 3;\n                }\n              }\n              else\n              {\n                v15 &= 3u;\n                v16 = 4;\n              }\n            }\n            else\n            {\n              v15 &= 1u;\n              v16 = 5;\n            }\n            v32 = v13 - 1;\n            v17 = 0;\n            v33 = v13 - 2;\n            while ( v32 != v17 )\n            {\n              v18 = v14[v17 + 1];\n              if ( (unsigned __int8)(v18 + 0x80) > 0x3Fu )\n                break;\n              v11 = v33 - v17;\n              v22 = &v14[v17 + 2];\n              v15 = (v18 & 0x3F) + (v15 << 6);\n              if ( v16 == ++v17 )\n                goto LABEL_54;\n            }\nLABEL_50:\n            sub_804D5E0(\"illegal UTF-8 character\");\n          }\n          if ( v15 > 0x7Fu )\n            goto LABEL_50;\n        }\nLABEL_54:\n        *(_WORD *)j = v15;\n        *((_WORD *)j + 1) = v27;\n        ++v12;\n      }\n      ++v27;\n    }\n    v34 = 0;\n    v35 = 0;\n    sub_804E0BE(v28, 0x4B68u, (int)&v34, \"PIO_UNIMAPCLR\");\n    LOWORD(v36) = v12;\n    v37 = v30;\n    sub_804E0BE(v28, 0x4B67u, (int)&v36, \"PIO_UNIMAP\");\n  }\n  return 0;\n}\n"
    ],
    "sub_808F819": [
        "0x808f819",
        "int __cdecl sub_808F819(int a1, int a2)\n{\n  _BYTE *v2; // edi\n  int v3; // ebp\n  int i; // ebx\n  int j; // esi\n  char v7[2]; // [esp+0h] [ebp-114h] BYREF\n  __int16 v8; // [esp+2h] [ebp-112h]\n  __int16 v9[136]; // [esp+4h] [ebp-110h] BYREF\n\n  v2 = sub_804DAFA(0x100u);\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v3 = sub_80AB6D3();\n  sub_80B24F6(7, v2);\n  if ( !sub_804D210(v2, \"bkeymap\") )\n    sub_804D5E0(\"not a valid binary keymap\");\n  sub_80B24F6(256, v2);\n  for ( i = 0; i != 256; ++i )\n  {\n    if ( v2[i] == 1 )\n    {\n      sub_80B24F6(256, v9);\n      for ( j = 0; j != 128; ++j )\n      {\n        v7[1] = j;\n        v7[0] = i;\n        v8 = v9[j];\n        ioctl(v3, 0x4B47u, v7);\n      }\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_808F8D9": [
        "0x808f8d9",
        "void __spoils<edx,ecx> sub_808F8D9()\n{\n  int v0; // [esp-Ch] [ebp-10h]\n  int v1; // [esp-8h] [ebp-Ch]\n  int v2; // [esp-4h] [ebp-8h]\n\n  if ( !vfork() )\n  {\n    setsid();\n    ioctl(0, 0x540Eu, 0);\n    sub_80AB1EC(v0, v1, v2);\n  }\n}\n"
    ],
    "sub_808F904": [
        "0x808f904",
        "int __cdecl sub_808F904(int a1, int a2)\n{\n  char v2; // si\n  _DWORD *v3; // edi\n  int v4; // ebx\n  int v5; // ebx\n  int v7; // [esp+4h] [ebp-34h] BYREF\n  __int16 v8[3]; // [esp+Ah] [ebp-2Eh] BYREF\n  int s[10]; // [esp+10h] [ebp-28h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"+c:wslfv\", &v7);\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  v4 = v2 & 1;\n  if ( (v2 & 1) != 0 )\n  {\n    v5 = sub_80B40CC(63, 1);\n  }\n  else\n  {\n    while ( ioctl(v4, 0x5603u, s) )\n    {\n      if ( ++v4 == 3 )\n      {\n        v4 = open64();\n        if ( v4 < 0 || ioctl(v4, 0x5603u, s) )\n          sub_804D5E0(\"can't find open VT\");\n        break;\n      }\n    }\n    *(_DWORD *)dword_80DBB7C = 0;\n    if ( ioctl(v4, 0x5600u, s) || (v5 = s[0], s[0] <= 0) )\n      sub_804D3C9((int)\"can't find open VT\");\n  }\n  sprintf((char *)s, \"/dev/tty%d\", v5);\n  sub_80B3C0D();\n  close(0);\n  sub_804DBE1((const char *)s);\n  sub_804E0BE(0, 0x5603u, (int)v8, \"VT_GETSTATE\");\n  if ( (v2 & 4) != 0 )\n    sub_80AB77C();\n  if ( !*v3 )\n    *(v3 - 1) = sub_80AB879();\n  sub_804DC7B(0, 1);\n  sub_804DC7B(0, 2);\n  sub_808F8D9();\n  if ( (v2 & 2) != 0 )\n  {\n    sub_804DA34(0, 0, -1);\n    if ( (v2 & 4) != 0 )\n    {\n      sub_80AB77C();\n      sub_804E0BE(0, 0x5608u, v5, \"VT_DISALLOCATE\");\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_808FA92": [
        "0x808fa92",
        "int sub_808FA92()\n{\n  if ( !isatty(1) )\n    return 0;\n  printf(\"\\x1Bc\\x1B(B\\x1B[m\\x1B[J\\x1B[?25h\");\n  return sub_8097F70(2, off_80B7F34);\n}\n"
    ],
    "sub_808FAC1": [
        "0x808fac1",
        "void __noreturn sub_808FAC1()\n{\n  tcsetattr(2, 0, (const struct termios *)&qword_80DB778);\n  _exit(1);\n}\n"
    ],
    "sub_808FAD6": [
        "0x808fad6",
        "int sub_808FAD6()\n{\n  int v0; // esi\n  int v2[2]; // [esp+0h] [ebp-4Ch] BYREF\n  struct termios termios_p; // [esp+8h] [ebp-44h] BYREF\n\n  v2[0] = 0;\n  v2[1] = 0;\n  tcgetattr(2, (struct termios *)&qword_80DB778);\n  qmemcpy(&termios_p, &qword_80DB778, sizeof(termios_p));\n  termios_p.c_cflag |= 0x880u;\n  termios_p.c_lflag &= 0xFFFFFFE4;\n  sub_804E6C8(49164, (void (*)(int))sub_808FAC1);\n  tcsetattr(2, 0, &termios_p);\n  fputs(\"\\x1B7\\x1B[r\\x1B[999;999H\\x1B[6n\", stderr);\n  alarm(3u);\n  scanf(\"\\x1B[%hu;%huR\", v2, (char *)v2 + 2);\n  fputs(\"\\x1B8\", stderr);\n  v0 = ioctl(2, 0x5414u, v2);\n  tcsetattr(2, 0, (const struct termios *)&qword_80DB778);\n  printf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\", HIWORD(v2[0]), LOWORD(v2[0]));\n  return v0;\n}\n"
    ],
    "sub_808FBAA": [
        "0x808fbaa",
        "int __cdecl sub_808FBAA(int a1, int a2)\n{\n  int v2; // eax\n  const char *v3; // ecx\n  int v4; // eax\n\n  v2 = sub_80ABEAC(a2, \"^r\");\n  v3 = *(const char **)(a2 + 4 * v2 + 4);\n  if ( !v3 )\n  {\n    v3 = \"/dev/tty\";\n    if ( v2 )\n      v3 = \"/dev/console\";\n  }\n  v4 = sub_804DBE1(v3);\n  sub_804E0BE(v4, 0x541Du, 0, \"TIOCCONS\");\n  return 0;\n}\n"
    ],
    "sub_808FBF3": [
        "0x808fbf3",
        "int __cdecl sub_808FBF3(int a1, int a2)\n{\n  int v3; // edi\n  int result; // eax\n  int v5; // eax\n  int v6; // ebx\n  int v7; // [esp+4h] [ebp-14h] BYREF\n  int v8; // [esp+8h] [ebp-10h]\n\n  if ( a1 <= 1 || (a1 & 1) == 0 )\n    sub_804CDC2();\n  v3 = sub_80AB6D3();\n  while ( 1 )\n  {\n    result = *(_DWORD *)(a2 + 4);\n    if ( !result )\n      break;\n    v5 = sub_80B4093(57471);\n    v6 = v5;\n    if ( v5 > 57343 )\n      v6 = v5 - 57216;\n    v7 = v6;\n    v8 = sub_80B40CC(255, 0);\n    sub_804E029(v3, 0x4B4Du, (int)&v7, \"can't set SCANCODE %x to KEYCODE %d\", v6, v8);\n    a2 += 8;\n  }\n  return result;\n}\n"
    ],
    "sub_808FC79": [
        "0x808fc79",
        "int __cdecl sub_808FC79(int a1, int a2)\n{\n  char *v2; // eax\n  int v3; // eax\n  __int16 v5; // [esp+0h] [ebp-2h] BYREF\n\n  v5 = 11;\n  if ( *(_DWORD *)(a2 + 4) )\n    HIBYTE(v5) = sub_80B40CC(63, 0);\n  v2 = sub_804DDBF(\"/dev/tty%u\", HIBYTE(v5));\n  v3 = sub_804DBE1(v2);\n  sub_804E0BE(v3, 0x541Cu, (int)&v5, \"TIOCLINUX\");\n  return 0;\n}\n"
    ],
    "sub_808FCCC": [
        "0x808fccc",
        "_BOOL4 __cdecl sub_808FCCC(int a1, int a2)\n{\n  int v2; // ecx\n  int v3; // ebx\n  const char *v4; // eax\n  const char *v5; // eax\n  char *v6; // edi\n  size_t v7; // esi\n  const char *v8; // ebp\n  size_t v9; // eax\n  size_t v10; // ebx\n\n  v3 = a2;\n  v4 = *(const char **)(a2 + 4);\n  if ( v4 && !strcmp(v4, \"--\") )\n    v3 = a2 + 4;\n  v5 = *(const char **)(v3 + 4);\n  if ( !v5 )\nLABEL_5:\n    sub_804CDC2();\n  v6 = sub_804D34F(v5, v2);\n  v7 = strlen(v6);\n  v8 = *(const char **)(v3 + 8);\n  if ( v8 )\n  {\n    if ( *(_DWORD *)(v3 + 12) )\n      goto LABEL_5;\n    v9 = strlen(*(const char **)(v3 + 8));\n    if ( v7 > v9 )\n    {\n      v10 = v7 - v9;\n      if ( !strcmp(&v6[v7 - v9], v8) )\n        v7 = v10;\n    }\n  }\n  v6[v7] = 10;\n  return v7 + 1 != sub_804E586(v7 + 1, v6);\n}\n"
    ],
    "sub_808FD5B": [
        "0x808fd5b",
        "int __cdecl sub_808FD5B(int a1, int a2)\n{\n  unsigned int v2; // edi\n  _DWORD *v3; // ebx\n  int i; // esi\n  int v6; // [esp+8h] [ebp-3Ch]\n  int fd; // [esp+Ch] [ebp-38h]\n  ssize_t v8; // [esp+10h] [ebp-34h]\n  bool v9; // [esp+17h] [ebp-2Dh]\n  int v10; // [esp+18h] [ebp-2Ch]\n  int v11[5]; // [esp+1Ch] [ebp-28h] BYREF\n  char v12; // [esp+30h] [ebp-14h]\n  char v13; // [esp+31h] [ebp-13h]\n\n  v2 = sub_80ABEAC(a2, \"^etvAnbu\");\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v3 )\n    *--v3 = \"-\";\n  if ( (v2 & 7) != 0 )\n  {\n    v9 = (v2 & 0x30) != 0;\n    v10 = 0;\n    do\n    {\n      fd = sub_80B3DAA();\n      if ( fd >= 0 )\n      {\n        while ( 1 )\n        {\n          v8 = read(fd, &qword_80DB778, 0x400u);\n          if ( v8 <= 0 )\n            break;\n          for ( i = 0; i != v8; ++i )\n          {\n            v6 = *((unsigned __int8 *)&qword_80DB778 + i);\n            if ( v9 && ((v2 & 0x20) == 0 ? 256 : 10) != *((unsigned __int8 *)&qword_80DB778 + i) )\n              printf(\"%6u  \", ++v10);\n            v9 = ((v2 & 0x30) == 0 ? 256 : 10) == v6;\n            sub_80B0C15(v2, v11);\n            fputs_unlocked();\n          }\n        }\n      }\n      ++v3;\n    }\n    while ( *v3 );\nLABEL_18:\n    sub_80AB247();\n  }\n  if ( ((v2 >> 4) & 3) != 0 )\n  {\n    v11[0] = 6;\n    v11[1] = 1;\n    v11[2] = 1;\n    v11[3] = 135040267;\n    v11[4] = 135081797;\n    v12 = ((v2 >> 5) ^ 1) & 1;\n    v13 = (v2 >> 4) & 2;\n    do\n    {\n      sub_80B0B1C((int)v11);\n      ++v3;\n    }\n    while ( *v3 );\n    goto LABEL_18;\n  }\n  return sub_80A98A4();\n}\n"
    ],
    "sub_808FEFD": [
        "0x808fefd",
        "int __cdecl sub_808FEFD(int a1, const char **a2)\n{\n  const char **v2; // ebx\n\n  v2 = a2;\n  while ( *++v2 )\n  {\n    if ( **v2 != 45 )\n    {\n      *v2 = sub_804DDBF(\":%s\", *v2);\n      return sub_80900EA(a1, a2);\n    }\n  }\n  return sub_80900EA(a1, a2);\n}\n"
    ],
    "sub_808FF37": [
        "0x808ff37",
        "int __userpurge sub_808FF37@<eax>(const char *a1@<eax>, int a2@<edx>, const char *a3@<ecx>, int a4)\n{\n  __mode_t v7; // eax\n  __mode_t v8; // ebx\n  int v9; // eax\n  int v10; // ebx\n  int v12; // [esp-8h] [ebp-18h]\n  int v13; // [esp-4h] [ebp-14h]\n\n  if ( a4 )\n  {\n    if ( (*(_DWORD *)(a2 + 16) & 0xF000) == 40960 )\n      return 1;\n  }\n  else if ( stat64() )\n  {\n    goto LABEL_13;\n  }\n  v7 = sub_80B07AF();\n  v8 = v7;\n  if ( v7 == -1 )\n    sub_804D5E0(\"invalid mode '%s'\", a3);\n  if ( !chmod(a1, v7) )\n  {\n    if ( (dword_80DBB9C & 2) != 0 || (dword_80DBB9C & 4) != 0 && *(_DWORD *)(a2 + 16) != v8 )\n    {\n      v9 = sub_80B028A(v13, v12);\n      printf(\"mode of '%s' changed to %04o (%s)\\n\", a1, v8 & 0xFFF, (const char *)(v9 + 1));\n    }\n    return 1;\n  }\nLABEL_13:\n  v10 = 0;\n  if ( (dword_80DBB9C & 8) == 0 )\n    sub_804D3F1(a1);\n  return v10;\n}\n"
    ],
    "sub_808FFE1": [
        "0x808ffe1",
        "int __cdecl sub_808FFE1(int a1, _BYTE **a2)\n{\n  _BYTE **v2; // edi\n  _BYTE *v3; // ebx\n  int *v4; // eax\n  _DWORD *v5; // ebx\n  int v6; // edi\n  int v7; // esi\n\n  v2 = a2;\n  while ( 1 )\n  {\n    v3 = *++v2;\n    if ( !*v2 )\n      break;\n    if ( *v3 != 45 )\n    {\n      v3 = 0;\n      break;\n    }\n    if ( v3[1] && !strchr(\"-Rvcf\", (unsigned __int8)v3[1]) )\n    {\n      *v3 = 97;\n      break;\n    }\n  }\n  sub_80ABEAC(a2, \"^Rvcf\");\n  v4 = (int *)&a2[optind];\n  if ( v3 )\n    *v3 = 45;\n  v5 = v4 + 1;\n  v6 = *v4;\n  v7 = 0;\n  do\n  {\n    if ( !sub_80B2549(sub_808FF37, dword_80DBB9C & 1, sub_808FF37, v6, 0) )\n      v7 = 1;\n    ++v5;\n  }\n  while ( *v5 );\n  return v7;\n}\n"
    ],
    "sub_809006F": [
        "0x809006f",
        "int __userpurge sub_809006F@<eax>(const char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)\n{\n  int v6; // ebx\n  int v7; // esi\n  int v8; // edx\n\n  v6 = *a3;\n  if ( *a3 == -1 )\n    v6 = *(_DWORD *)(a2 + 24);\n  v7 = a3[1];\n  if ( v7 == -1 )\n    v7 = *(_DWORD *)(a2 + 28);\n  if ( ((int (__cdecl *)(const char *, int, int))a3[2])(a1, v6, v7) )\n  {\n    v8 = 0;\n    if ( (dword_80DBB9C & 0x10) == 0 )\n    {\n      sub_804D3F1(a1);\n      return 0;\n    }\n  }\n  else if ( (dword_80DBB9C & 4) != 0\n         || (v8 = 1, (dword_80DBB9C & 8) != 0) && (*(_DWORD *)(a2 + 24) != v6 || *(_DWORD *)(a2 + 28) != v7) )\n  {\n    printf(\"changed ownership of '%s' to %u:%u\\n\", a1, v6, v7);\n    return 1;\n  }\n  return v8;\n}\n"
    ],
    "sub_80900EA": [
        "0x80900ea",
        "int __cdecl sub_80900EA(int a1, int a2)\n{\n  char v2; // al\n  _DWORD *v3; // esi\n  int v4; // ebx\n  int v5; // edi\n  int v7; // [esp-4h] [ebp-20h]\n  int v8; // [esp+0h] [ebp-1Ch] BYREF\n  int (*v9)(const char *, __uid_t, __gid_t); // [esp+8h] [ebp-14h]\n\n  v2 = sub_80ABEAC(a2, \"^RhvcfLHP\");\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  v9 = chown;\n  if ( (v2 & 2) != 0 || (v2 & 0x61) == 1 )\n    v9 = lchown;\n  v4 = 9 - ((v2 & 1) == 0);\n  if ( (v2 & 0x60) != 0 )\n    v4 |= 4u;\n  if ( (v2 & 0x20) != 0 )\n    v4 |= 2u;\n  sub_80B48BE(v7, *v3);\n  v5 = 0;\n  while ( *++v3 )\n  {\n    if ( !sub_80B2549(sub_809006F, v4, sub_809006F, &v8, 0) )\n      v5 = 1;\n  }\n  return v5;\n}\n"
    ],
    "sub_8090181": [
        "0x8090181",
        "void __cdecl __noreturn sub_8090181(int a1, const char **a2)\n{\n  const char *v2; // eax\n  const char **v3; // eax\n\n  v2 = a2[1];\n  if ( !v2 )\n    sub_804CDC2();\n  sub_804DF35(v2);\n  v3 = a2 + 2;\n  if ( !a2[2] )\n  {\n    *a2 = sub_80AB879();\n    a2[1] = \"pec not supported for -W and -i\" + 29;\n    v3 = a2;\n  }\n  sub_80AB1EC(v3);\n}\n"
    ],
    "sub_80901B5": [
        "0x80901b5",
        "void __thiscall __noreturn sub_80901B5(void *this, int a2, int a3)\n{\n  _DWORD *v3; // ebx\n  int v4; // esi\n  ssize_t v5; // eax\n  unsigned __int64 v6; // rdi\n  int v7; // eax\n  int v8; // eax\n  int v9; // ebp\n  const char *v10; // eax\n  __int64 v11; // [esp+4h] [ebp-20h]\n  int v12; // [esp+10h] [ebp-14h]\n\n  v12 = sub_80AA37D(this, 1);\n  sub_80ABEAC(a3, &data);\n  v3 = (_DWORD *)(a3 + 4 * optind);\n  while ( 1 )\n  {\n    v4 = sub_80B3DAA();\n    if ( v4 >= 0 )\n    {\n      v11 = 0LL;\n      do\n      {\n        v5 = sub_804E5BC(0x400u, &qword_80DB778, v4);\n        if ( v5 <= 0 )\n        {\n          close(v4);\n          v6 = __PAIR64__(v11, HIDWORD(v11));\n          v7 = 0;\n          while ( v6 )\n          {\n            byte_80DB777[++v7] = BYTE4(v6);\n            HIDWORD(v6) = __PAIR64__(v6, HIDWORD(v6)) >> 8;\n            LODWORD(v6) = (unsigned int)v6 >> 8;\n          }\n          v4 = -1;\n        }\n        else\n        {\n          v11 += v5;\n        }\n        v8 = sub_80AA3F3(v12);\n      }\n      while ( v4 != -1 );\n      v9 = ~v8;\n      v10 = \"%u %llu %s\\n\";\n      if ( !*v3 )\n        v10 = \"%u %llu\\n\";\n      printf(v10, v9, v11, *v3);\n    }\n    if ( *v3 )\n    {\n      if ( *++v3 )\n        continue;\n    }\n    sub_80AB247();\n  }\n}\n"
    ],
    "sub_80902C9": [
        "0x80902c9",
        "int __cdecl sub_80902C9(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // edx\n  const char **v4; // esi\n  const char *v5; // edi\n  int (*v6)(); // ecx\n  int v7; // eax\n  int v8; // ecx\n  char *v9; // ebp\n  int v10; // ebx\n  char *v11; // eax\n  int v12; // ecx\n  int v14; // [esp+0h] [ebp-D8h]\n  int v15; // [esp+4h] [ebp-D4h]\n  int v16; // [esp+4h] [ebp-D4h]\n  char v17[96]; // [esp+8h] [ebp-D0h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^pdRfilsLHarPvuT\");\n  v3 = a1 - optind;\n  v4 = (const char **)(a2 + 4 * optind);\n  v14 = v2 ^ 2;\n  if ( ((v2 ^ 2) & 0x80) != 0 )\n    v14 = v2 | 2;\n  v5 = v4[v3 - 1];\n  if ( v3 == 2 )\n  {\n    v6 = stat64;\n    if ( (v14 & 2) == 0 )\n      v6 = lstat64;\n    v15 = sub_809A567(v6, v17);\n    if ( v15 < 0 )\n      return 1;\n    v7 = sub_809A5B0();\n    if ( v7 < 0 )\n      return 1;\n    v8 = v14 & 0x4000;\n    if ( (v14 & 0x4000) != 0 && (v15 & 2) == 0 && (v7 & 2) != 0 )\n      sub_804D5E0(\"'%s' is a directory\", v5);\n    v9 = (char *)v5;\n    v10 = ((unsigned __int8)v7 | (unsigned __int8)v15) & 2;\n    if ( (((unsigned __int8)v7 | (unsigned __int8)v15) & 2) == 0 )\n      goto LABEL_21;\n    if ( (v14 & 4) != 0 && (v15 & 2) != 0 && !v7 || (v14 & 0x4000) != 0 )\n    {\n      v9 = (char *)v5;\n      v10 = 0;\n      goto LABEL_21;\n    }\n  }\n  else\n  {\n    v8 = v14 & 0x4000;\n    if ( (v14 & 0x4000) != 0 )\n      sub_804D5E0(\"too many arguments\");\n  }\n  while ( 1 )\n  {\n    v16 = v8;\n    v11 = sub_804D34F(*v4, v8);\n    v9 = (char *)sub_804D2D1((int)v5, v11, v12);\n    v10 = v16;\nLABEL_21:\n    if ( sub_80A9C77(v14) < 0 )\n      v10 = 1;\n    if ( v4[1] == v5 )\n      break;\n    free(v9);\n    v8 = v10;\n    ++v4;\n  }\n  return v10;\n}\n"
    ],
    "sub_809040F": [
        "0x809040f",
        "int __cdecl sub_809040F(_DWORD *a1, _DWORD *a2)\n{\n  return *a1 - *a2;\n}\n"
    ],
    "sub_809041C": [
        "0x809041c",
        "void __cdecl __noreturn sub_809041C(int a1, int a2)\n{\n  char v2; // al\n  int *v3; // ebx\n  char *v4; // eax\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // edi\n  int v9; // eax\n  int v10; // esi\n  int v11; // eax\n  int *v12; // eax\n  char *v13; // eax\n  char v14; // si\n  int v15; // edi\n  signed int v16; // esi\n  int v17; // eax\n  char *v18; // edx\n  unsigned int v19; // ebp\n  char *v20; // ecx\n  int v21; // eax\n  int v22; // edx\n  int v23; // ecx\n  char *v24; // ebp\n  int v25; // edi\n  int v26; // esi\n  unsigned __int8 *v27; // edx\n  int v28; // eax\n  _BYTE *v29; // edx\n  int v30; // [esp-4h] [ebp-40h]\n  int v31; // [esp+0h] [ebp-3Ch]\n  int nmemb; // [esp+4h] [ebp-38h]\n  unsigned __int8 v33; // [esp+Bh] [ebp-31h]\n  _DWORD *v34; // [esp+Ch] [ebp-30h]\n  _BYTE *ptr; // [esp+10h] [ebp-2Ch]\n  char *s; // [esp+14h] [ebp-28h]\n  int i; // [esp+18h] [ebp-24h]\n  signed int v38; // [esp+1Ch] [ebp-20h]\n  int v39; // [esp+1Ch] [ebp-20h]\n  int v40; // [esp+2Ch] [ebp-10h]\n  char delim[2]; // [esp+36h] [ebp-6h] BYREF\n  char *stringp; // [esp+38h] [ebp-4h] BYREF\n  char *v43; // [esp+3Ch] [ebp+0h] BYREF\n  char *v44; // [esp+40h] [ebp+4h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^b:c:f:d:sn\", &stringp, &stringp, &stringp);\n  v34 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v2 & 7) == 0 )\n    sub_804D5E0(\"expected a list of bytes, characters, or fields\");\n  if ( (v2 & 8) != 0 )\n  {\n    v33 = *v43;\n    if ( *v43 && v43[1] )\n      sub_804D5E0(\"the delimiter must be a single character\");\n  }\n  else\n  {\n    v33 = 9;\n  }\n  if ( (v2 & 4) != 0 )\n  {\n    nmemb = 0;\n  }\n  else\n  {\n    nmemb = v2 & 0x10;\n    if ( (v2 & 0x10) != 0 )\n      sub_804D5E0(\"suppressing non-delimited lines makes sense%s\", \" only when operating on fields\");\n    if ( v33 != 9 )\n      sub_804D5E0(\"a delimiter may be specified%s\", \" only when operating on fields\");\n  }\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = strsep(&stringp, \",\");\n    v43 = v4;\n    if ( !v4 )\n      break;\n    if ( *v4 )\n    {\n      v5 = strsep(&v43, \"-\");\n      v6 = v30;\n      v7 = v31;\n      if ( *v5 && (v9 = sub_80B4187(v31, v30)) != 0 )\n        v8 = v9 - 1;\n      else\n        v8 = 0;\n      if ( !v43 )\n        goto LABEL_22;\n      v10 = 0x7FFFFFFF;\n      if ( *v43 )\n      {\n        v11 = sub_80B4187(v7, v6);\n        if ( !v11 )\n          v11 = 0x7FFFFFFF;\n        v10 = v11 - 1;\n        if ( v8 == v11 - 1 )\nLABEL_22:\n          v10 = -1;\n      }\n      v3 = (int *)sub_80B4733(nmemb, 2052);\n      v12 = &v3[2 * nmemb];\n      *v12 = v8;\n      v12[1] = v10;\n      ++nmemb;\n    }\n  }\n  if ( !nmemb )\n    sub_804D5E0(\"missing list of positions\");\n  qsort(v3, nmemb, 8u, (__compar_fn_t)sub_809040F);\n  if ( !*v34 )\n    *--v34 = \"-\";\n  while ( !sub_80B3D76(nmemb) )\n  {\nLABEL_80:\n    if ( !*++v34 )\n      sub_80AB247();\n  }\n  for ( i = 0; ; ++i )\n  {\n    v13 = (char *)sub_80AB85A();\n    v44 = v13;\n    if ( !v13 )\n    {\n      sub_80AB218();\n      goto LABEL_80;\n    }\n    v38 = strlen(v13);\n    ptr = sub_804DB2E(v38 + 1);\n    s = v44;\n    v14 = dword_80DBB9C;\n    if ( (dword_80DBB9C & 3) != 0 )\n    {\n      v15 = 0;\n      do\n      {\n        v16 = v3[2 * v15];\n        do\n        {\n          v17 = _stdout;\n          v18 = *(char **)(_stdout + 16);\n          v19 = *(_DWORD *)(_stdout + 28);\n          if ( v38 <= v16 )\n            break;\n          if ( !ptr[v16] )\n          {\n            ptr[v16] = 88;\n            v20 = &v44[v16];\n            if ( (unsigned int)v18 >= v19 )\n            {\n              __fputc_unlocked();\n            }\n            else\n            {\n              *(_DWORD *)(v17 + 16) = v18 + 1;\n              *v18 = *v20;\n            }\n          }\n          ++v16;\n        }\n        while ( v16 <= v3[2 * v15 + 1] );\n        ++v15;\n      }\n      while ( v15 != nmemb );\n    }\n    else\n    {\n      if ( v33 == 10 )\n      {\n        v21 = *v3;\n        v22 = 0;\n        if ( *v3 > i )\n          goto LABEL_78;\n        while ( i > v21 )\n        {\n          ++v21;\n          v23 = v3[2 * v22 + 1];\n          if ( v23 == -1 || v21 > v23 )\n          {\n            if ( ++v22 == nmemb )\n              goto LABEL_78;\n            v21 = v3[2 * v22];\n            if ( i < v21 )\n              goto LABEL_78;\n          }\n        }\nLABEL_56:\n        puts(s);\n        goto LABEL_78;\n      }\n      delim[0] = v33;\n      delim[1] = 0;\n      if ( !strchr(v44, v33) )\n      {\n        if ( (v14 & 0x10) != 0 )\n          goto LABEL_78;\n        goto LABEL_56;\n      }\n      v24 = 0;\n      v40 = 0;\n      v25 = -1;\n      v26 = 0;\n      do\n      {\n        if ( !v44 )\n          break;\n        v39 = v3[2 * v26];\n        do\n        {\n          while ( v44 && v25 < v39 )\n          {\n            v24 = strsep(&v44, delim);\n            ++v25;\n          }\n          if ( v25 == v39 && v24 && !ptr[v25] )\n          {\n            if ( v40 )\n            {\n              v27 = *(unsigned __int8 **)(_stdout + 16);\n              if ( (unsigned int)v27 >= *(_DWORD *)(_stdout + 28) )\n              {\n                __fputc_unlocked();\n              }\n              else\n              {\n                *(_DWORD *)(_stdout + 16) = v27 + 1;\n                *v27 = v33;\n              }\n            }\n            fputs_unlocked();\n            ptr[v25] = 88;\n            ++v40;\n          }\n          ++v39;\n          v28 = v3[2 * v26 + 1];\n        }\n        while ( v39 <= v28 && v44 && v28 != -1 );\n        ++v26;\n      }\n      while ( v26 != nmemb );\n    }\n    v29 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v29 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v29 + 1;\n      *v29 = 10;\n    }\nLABEL_78:\n    free(ptr);\n    free(s);\n  }\n}\n"
    ],
    "sub_80907FB": [
        "0x80907fb",
        "int __cdecl sub_80907FB(int a1, int a2)\n{\n  char *v2; // ebp\n  char *v3; // ebx\n  size_t v4; // eax\n  char v5; // dl\n  unsigned int v6; // edx\n  int v7; // edi\n  int v8; // eax\n  int v9; // ecx\n  char v11; // [esp+0h] [ebp-C0h]\n  int v12; // [esp+4h] [ebp-BCh]\n  char **v13; // [esp+8h] [ebp-B8h]\n  char *v14; // [esp+Ch] [ebp-B4h] BYREF\n  int v15; // [esp+10h] [ebp-B0h] BYREF\n  const char *v16; // [esp+14h] [ebp-ACh] BYREF\n  const char *v17; // [esp+18h] [ebp-A8h] BYREF\n  time_t timer[2]; // [esp+1Ch] [ebp-A4h] BYREF\n  struct tm tp; // [esp+24h] [ebp-9Ch] BYREF\n  char dest[72]; // [esp+50h] [ebp-70h] BYREF\n  time_t v21; // [esp+98h] [ebp-28h]\n\n  v17 = 0;\n  v11 = sub_80ABEC2(a2, \"^Rs:ud:r:I::D:\", \"rfc-822\", &v14, &v14, &v16, &v17, &v15);\n  v13 = (char **)(a2 + 4 * optind);\n  if ( (v11 & 4) != 0 )\n    putenv(\"TZ=UTC0\");\n  if ( (v11 & 0x20) != 0 )\n  {\n    if ( v17 )\n    {\n      v12 = sub_804D254(\"date\", v17);\n      if ( v12 < 0 )\n        goto LABEL_6;\n    }\n    else\n    {\n      v12 = 0;\n    }\n  }\n  else\n  {\n    v12 = -1;\n  }\n  v2 = *v13;\n  if ( *v13 )\n  {\n    if ( *v2 == 43 )\n    {\n      ++v2;\n      ++v13;\n    }\n    else\n    {\n      v2 = 0;\n    }\n  }\n  v3 = *v13;\n  if ( (v11 & 0xA) == 0 )\n  {\n    v11 |= 2u;\n    v14 = *v13;\n    if ( v3 )\n    {\n      v4 = strspn(v3, \"0123456789\");\n      v5 = v3[v4];\n      if ( !v5\n        || v5 == 46\n        && (unsigned __int8)(v3[v4 + 1] - 48) <= 9u\n        && (unsigned __int8)(v3[v4 + 2] - 48) <= 9u\n        && !v3[v4 + 3] )\n      {\n        v6 = v4 - 8;\n        if ( v4 - 8 > 4 || (v6 & 1) != 0 )\n          sub_804D5E0(\"invalid date '%s'\", v3);\n        if ( v4 != 8 )\n        {\n          qmemcpy(dest, v3 + 8, v6);\n          v7 = *((_DWORD *)v3 + 1);\n          *(_DWORD *)&v3[v4 - 8] = *(_DWORD *)v3;\n          *(_DWORD *)&v3[v4 - 4] = v7;\n          qmemcpy(v14, dest, v6);\n        }\n      }\n      ++v13;\n    }\n  }\n  if ( *v13 )\nLABEL_6:\n    sub_804CDC2();\n  if ( (v11 & 0x10) != 0 )\n  {\n    sub_804DFF3(v16);\n    timer[0] = v21;\n  }\n  else\n  {\n    time(timer);\n  }\n  localtime_r(timer, &tp);\n  if ( v14 )\n  {\n    memset(&tp, 0, 12);\n    if ( (v11 & 0x40) != 0 )\n    {\n      if ( !strptime() )\n        sub_804D5E0(\"invalid date '%s'\", v14);\n    }\n    else\n    {\n      sub_804E7FD(v14, &tp);\n    }\n    if ( *v14 != 64 )\n      tp.tm_isdst = -1;\n    timer[0] = sub_804EB64(v14, &tp);\n    if ( (v11 & 2) != 0 && stime(timer) < 0 )\n      sub_804D3A5((int)&unk_80D5BE9);\n  }\n  if ( !v2 )\n  {\n    if ( v12 != -1 )\n    {\n      strcpy(dest, \"%Y-%m-%dT%H:%M:%S\");\n      v8 = 3 * v12 + 8;\n      if ( !v12 )\n      {\nLABEL_44:\n        dest[v8] = 0;\n        v2 = dest;\n        goto LABEL_47;\n      }\nLABEL_43:\n      v9 = v8 + 1;\n      dest[v8] = 37;\n      v8 += 2;\n      dest[v9] = (v11 & 4) == 0 ? 122 : 90;\n      goto LABEL_44;\n    }\n    v2 = \"%a %b %e %H:%M:%S %Z %Y\";\n    if ( (v11 & 1) != 0 )\n    {\n      strcpy(dest, \"%a, %d %b %Y %H:%M:%S \");\n      v8 = 22;\n      goto LABEL_43;\n    }\n  }\nLABEL_47:\n  if ( *v2 )\n  {\n    if ( sub_804D210(v2, \"%f\") )\n      v2 = \"%Y.%m.%d-%H:%M:%S\";\n    strftime((char *)&qword_80DB778, 0x400u, v2, &tp);\n  }\n  else\n  {\n    LOBYTE(qword_80DB778) = 0;\n  }\n  puts((const char *)&qword_80DB778);\n  return 0;\n}\n"
    ],
    "sub_8090AD5": [
        "0x8090ad5",
        "int __usercall sub_8090AD5@<eax>(const char *a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  int v5; // edi\n  char *v6; // eax\n  char *v7; // ebx\n  int v8; // eax\n\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = strchr(a1, 44);\n    v7 = v6;\n    if ( v6 )\n      *v6 = 0;\n    v8 = sub_804D222(a2, a1);\n    if ( v8 < 0 )\n      sub_804D5E0(\"invalid argument '%s' to '%s'\", a1, a3);\n    v5 |= 1 << v8;\n    if ( !v7 )\n      break;\n    *v7 = 44;\n    a1 = v7 + 1;\n  }\n  return v5;\n}\n"
    ],
    "sub_8090B2F": [
        "0x8090b2f",
        "char __usercall sub_8090B2F@<al>(char *a1@<eax>, size_t a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  int v6; // eax\n  char v7; // dl\n\n  v6 = sub_804E586(a2, a1);\n  if ( v6 >= 0 )\n  {\n    if ( v6 == a3 )\n    {\n      ++qword_80DB778;\n    }\n    else\n    {\n      v7 = 1;\n      if ( v6 != a2 )\n        return v7;\n      ++*(_QWORD *)&unk_80DB780;\n    }\n    return 0;\n  }\n  sub_804D3A5((int)\"writing '%s'\", a4);\n  return 1;\n}\n"
    ],
    "sub_8090B8A": [
        "0x8090b8a",
        "int sub_8090B8A()\n{\n  return fprintf(\n           stderr,\n           \"%llu+%llu records in\\n%llu+%llu records out\\n\",\n           *(_QWORD *)&MEMORY[0x80DB788],\n           *((_QWORD *)&MEMORY[0x80DB788] + 1),\n           qword_80DB778,\n           *(_QWORD *)&unk_80DB780);\n}\n"
    ],
    "sub_8090BCE": [
        "0x8090bce",
        "int __cdecl sub_8090BCE(int a1, int a2)\n{\n  int *v2; // esi\n  int v3; // edi\n  char *v4; // eax\n  char *v5; // ebx\n  int v6; // eax\n  const char *v7; // ebx\n  size_t v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  __int64 v12; // kr00_8\n  int v13; // eax\n  size_t v14; // ebx\n  int v15; // edx\n  ssize_t v16; // eax\n  const char *v17; // eax\n  int v18; // edx\n  ssize_t v19; // eax\n  signed int v20; // ebp\n  char v21; // dl\n  int i; // eax\n  char *v23; // esi\n  int v24; // ebx\n  unsigned int v25; // edx\n  char v26; // bl\n  size_t v28; // [esp+4h] [ebp-B0h]\n  size_t v29; // [esp+8h] [ebp-ACh]\n  char *nbytes; // [esp+Ch] [ebp-A8h]\n  char *buf; // [esp+10h] [ebp-A4h]\n  __int64 v32[5]; // [esp+1Ch] [ebp-98h] BYREF\n  int v33; // [esp+54h] [ebp-60h]\n\n  memset(v32, 0, sizeof(v32));\n  memset(&qword_80DB778, 0, 0x24u);\n  v2 = (int *)(a2 + 4);\n  v28 = 512;\n  v29 = 512;\n  while ( 1 )\n  {\n    v3 = *v2;\n    if ( !*v2 )\n      break;\n    if ( *(_BYTE *)v3 != 45 || *(_BYTE *)(v3 + 1) != 45 || *(_BYTE *)(v3 + 2) )\n    {\n      v4 = strchr((const char *)v3, 61);\n      v5 = v4;\n      if ( !v4 || (*v4 = 0, v6 = sub_804D222(\"bs\", (const char *)v3), v6 < 0) )\n        sub_804CDC2();\n      v7 = v5 + 1;\n      switch ( v6 )\n      {\n        case 7:\n          v29 = sub_80B40B8(&unk_80B7500);\n          break;\n        case 8:\n          v8 = sub_80B40B8(&unk_80B7500);\nLABEL_20:\n          v28 = v8;\n          break;\n        case 9:\n          v9 = sub_8090AD5(v7, \"notrunc\", \"conv\");\nLABEL_17:\n          dword_80DB798 = (char *)(v9 | (unsigned int)dword_80DB798);\n          break;\n        case 10:\n          v9 = 32 * sub_8090AD5(v7, \"skip_bytes\", \"iflag\");\n          goto LABEL_17;\n        case 0:\n          v8 = sub_80B40B8(&unk_80B7500);\n          v29 = v8;\n          goto LABEL_20;\n        case 1:\n          dword_80DB798 = (char *)((unsigned int)dword_80DB798 | 0x100);\n          v32[1] = sub_80B3F8E();\n          break;\n        case 2:\n          v32[2] = sub_80B3F8E();\n          break;\n        case 3:\n          v32[3] = sub_80B3F8E();\n          break;\n        case 4:\n          LODWORD(v32[4]) = v7;\n          break;\n        case 5:\n          HIDWORD(v32[4]) = v7;\n          break;\n        case 6:\n          v10 = sub_804D222(\"none\", v7);\n          if ( v10 < 0 )\n            sub_804D5E0(\"invalid argument '%s' to '%s'\", v7, \"status\");\n          dword_80DB798 = (char *)((512 << v10) | (unsigned int)dword_80DB798);\n          break;\n      }\n    }\n    ++v2;\n  }\n  nbytes = (char *)sub_804DAFA(v29);\n  buf = nbytes;\n  if ( v29 != v28 )\n  {\n    dword_80DB798 = (char *)((unsigned int)dword_80DB798 | 0x80);\n    buf = (char *)sub_804DAFA(v28);\n  }\n  sub_804E782(10, (int)sub_8090B8A);\n  if ( LODWORD(v32[4]) )\n  {\n    v11 = sub_804DBE1((const char *)v32[4]);\n    sub_804DC97(v11, 0);\n  }\n  else\n  {\n    LODWORD(v32[4]) = \"standard input\";\n  }\n  if ( HIDWORD(v32[4]) )\n  {\n    v12 = v32[2];\n    v13 = sub_804DBE1((const char *)HIDWORD(v32[4]));\n    sub_804DC97(v13, 1);\n    if ( !v12\n      || ((unsigned __int8)dword_80DB798 & 1) != 0\n      || ftruncate64() >= 0\n      || fstat64() >= 0 && (((v33 & 0xF000) - 0x4000) & 0xFFFFB000) != 0 )\n    {\n      goto LABEL_49;\n    }\nLABEL_99:\n    v17 = (const char *)HIDWORD(v32[4]);\nLABEL_100:\n    sub_804D3FF(v17);\n  }\n  HIDWORD(v32[4]) = \"standard output\";\nLABEL_49:\n  if ( v32[3] )\n  {\n    v14 = v29;\n    if ( ((unsigned __int8)dword_80DB798 & 0x20) != 0 )\n      v14 = 1;\n    lseek64();\n    if ( v15 < 0 )\n    {\n      while ( 1 )\n      {\n        v16 = ((unsigned __int8)dword_80DB798 & 0x40) != 0 ? sub_804E5E3(0, nbytes, v14) : sub_804E5BC(v14, nbytes, 0);\n        if ( v16 < 0 )\n          goto LABEL_57;\n        if ( v16 )\n        {\n          if ( --v32[3] )\n            continue;\n        }\n        break;\n      }\n    }\n  }\n  if ( v32[2] )\n  {\n    lseek64();\n    if ( v18 < 0 )\n      goto LABEL_99;\n  }\n  while ( ((unsigned __int16)dword_80DB798 & 0x100) == 0\n       || *(_QWORD *)&MEMORY[0x80DB788] + *((_QWORD *)&MEMORY[0x80DB788] + 1) != v32[1] )\n  {\n    v19 = ((unsigned __int8)dword_80DB798 & 0x40) != 0 ? sub_804E5E3(0, nbytes, v29) : sub_804E5BC(v29, nbytes, 0);\n    v20 = v19;\n    if ( !v19 )\n      break;\n    if ( v19 < 0 )\n    {\n      if ( ((unsigned __int8)dword_80DB798 & 4) == 0 )\n        goto LABEL_57;\n      sub_804D3F1((const char *)v32[4]);\n      sub_804DD09(0, v29, 1);\n      v20 = 0;\n    }\n    v21 = (char)dword_80DB798;\n    if ( ((unsigned __int8)dword_80DB798 & 0x10) != 0 )\n    {\n      if ( (v32[0] & 0x100000000LL) != 0 )\n        sub_804D5E0(\"can't swab %lu byte buffer\", HIDWORD(v32[0]));\n      HIDWORD(v32[0]) = v20;\n      for ( i = 0; v20 >> 1 != i; ++i )\n        *(_WORD *)&nbytes[2 * i] = __ROL2__(*(_WORD *)&nbytes[2 * i], 8);\n    }\n    if ( v20 == v29 )\n    {\n      ++*(_QWORD *)&MEMORY[0x80DB788];\n    }\n    else\n    {\n      ++*((_QWORD *)&MEMORY[0x80DB788] + 1);\n      if ( (v21 & 2) != 0 )\n      {\n        memset(&nbytes[v20], 0, v29 - v20);\n        v20 = v29;\n      }\n    }\n    if ( (v21 & 0x80) != 0 )\n    {\n      v23 = nbytes;\n      while ( v20 )\n      {\n        v24 = v32[0];\n        v25 = v20;\n        if ( v20 > v28 - LODWORD(v32[0]) )\n          v25 = v28 - LODWORD(v32[0]);\n        qmemcpy(&buf[LODWORD(v32[0])], v23, v25);\n        v23 += v25;\n        v20 -= v25;\n        LODWORD(v32[0]) = v24 + v25;\n        if ( v24 + v25 == v28 )\n        {\n          if ( sub_8090B2F(buf, v28, v28, (const char *)HIDWORD(v32[4])) )\n            goto LABEL_101;\n          LODWORD(v32[0]) = 0;\n        }\n      }\n    }\n    else if ( sub_8090B2F(nbytes, v20, v28, (const char *)HIDWORD(v32[4])) )\n    {\n      goto LABEL_101;\n    }\n  }\n  if ( ((unsigned __int8)dword_80DB798 & 8) != 0 && fsync(1) < 0 )\n    goto LABEL_99;\n  if ( LODWORD(v32[0]) && sub_8090B2F(buf, v32[0], v28, (const char *)HIDWORD(v32[4])) )\n  {\nLABEL_101:\n    v26 = 1;\n  }\n  else\n  {\n    if ( close(0) < 0 )\n    {\nLABEL_57:\n      v17 = (const char *)v32[4];\n      goto LABEL_100;\n    }\n    v26 = 0;\n    if ( close(1) < 0 )\n      goto LABEL_99;\n  }\n  if ( (BYTE1(dword_80DB798) & 2) == 0 )\n    sub_8090B8A();\n  return v26;\n}\n"
    ],
    "sub_809117B": [
        "0x809117b",
        "int __cdecl sub_809117B(int a1, int a2)\n{\n  char v2; // di\n  int v3; // esi\n  const char *v4; // eax\n  char *v5; // eax\n  const char *v6; // ecx\n  const char *v7; // edx\n  const char **v8; // ebp\n  FILE *v9; // edi\n  struct mntent *v10; // edx\n  const char **v11; // ebx\n  const char *v12; // ebp\n  unsigned __int64 v13; // rcx\n  const char *v14; // eax\n  const char *v15; // eax\n  const char *v16; // eax\n  struct mntent *v18; // [esp+0h] [ebp-90h]\n  unsigned __int64 v19; // [esp+0h] [ebp-90h]\n  unsigned int v20; // [esp+0h] [ebp-90h]\n  const char *mnt_dir; // [esp+8h] [ebp-88h]\n  int v22; // [esp+Ch] [ebp-84h]\n  int v23; // [esp+10h] [ebp-80h]\n  char *s1; // [esp+14h] [ebp-7Ch]\n  int v25; // [esp+18h] [ebp-78h]\n  const char *mnt_type; // [esp+1Ch] [ebp-74h]\n  int v27; // [esp+20h] [ebp-70h]\n  int v28; // [esp+24h] [ebp-6Ch]\n  __int64 v29; // [esp+28h] [ebp-68h]\n  __int64 v30; // [esp+30h] [ebp-60h]\n  __int64 v31; // [esp+38h] [ebp-58h]\n\n  v2 = sub_80ABEAC(a2, \"^kPThm\");\n  v3 = (v2 & 0x10) == 0 ? 1024 : 0x100000;\n  if ( getenv(\"POSIXLY_CORRECT\") )\n    v3 = 512;\n  v22 = v2 & 2;\n  if ( (v2 & 8) != 0 )\n  {\n    v3 = 0;\n    v5 = \"     Size\";\n  }\n  else\n  {\n    v4 = (const char *)sub_80AD07E((v2 & 2) != 0);\n    v5 = sub_804DDBF(\"%s-blocks\", v4);\n  }\n  v6 = \"Use%\";\n  if ( (v2 & 2) != 0 )\n    v6 = \"Capacity\";\n  v7 = &data;\n  v25 = v2 & 4;\n  if ( (v2 & 4) != 0 )\n    v7 = \"Type       \";\n  printf(\"Filesystem           %s%-15sUsed Available %s Mounted on\\n\", v7, v5, v6);\n  v8 = (const char **)(a2 + 4 * optind);\n  if ( *v8 )\n  {\n    v9 = 0;\n  }\n  else\n  {\n    v9 = setmntent(\"/proc/mounts\", \"r\");\n    if ( !v9 )\n      sub_804D3C9((int)\"/proc/mounts\");\n  }\n  v23 = 0;\n  while ( v9 )\n  {\n    v10 = getmntent(v9);\n    if ( !v10 )\n    {\n      endmntent(v9);\n      return v23;\n    }\nLABEL_23:\n    v18 = v10;\n    s1 = v10->mnt_fsname;\n    if ( strcmp(v10->mnt_fsname, \"rootfs\") )\n    {\n      mnt_dir = v18->mnt_dir;\n      mnt_type = v18->mnt_type;\n      if ( statvfs64() )\n      {\n        sub_804D3F1(mnt_dir);\n        v23 = 1;\n      }\n      else\n      {\n        if ( !v28 )\n          v28 = v27;\n        if ( v29 || !v9 )\n        {\n          v19 = v29 - v30;\n          v13 = v31 + v29 - v30;\n          if ( v13 )\n          {\n            while ( v13 > 0x1446F85 )\n            {\n              v13 >>= 1;\n              v19 >>= 1;\n            }\n            v20 = (((unsigned int)v13 >> 1) + 100 * (_DWORD)v19) / (unsigned int)v13;\n          }\n          else\n          {\n            v20 = 0;\n          }\n          if ( printf(\"%-20s\", s1) > 20 && !v22 )\n            printf(\"\\n%-20s\", &data);\n          if ( v25 && printf(\" %-10s\", mnt_type) > 11 && !v22 )\n            printf(\"\\n%-30s\", &data);\n          v14 = (const char *)sub_80AD07E(v3);\n          printf(\" %9s \", v14);\n          v15 = (const char *)sub_80AD07E(v3);\n          printf(\"%9s \", v15);\n          v16 = (const char *)sub_80AD07E(v3);\n          printf(\"%9s %3u%% %s\\n\", v16, v20, mnt_dir);\n        }\n      }\n    }\n  }\n  while ( 1 )\n  {\n    v11 = v8 + 1;\n    v12 = *v8;\n    if ( !v12 )\n      return v23;\n    v10 = (struct mntent *)sub_80AB375();\n    if ( v10 )\n    {\n      v8 = v11;\n      goto LABEL_23;\n    }\n    sub_804D5F4(\"%s: can't find mount point\", v12);\n    v8 = v11;\n    v23 = 1;\n  }\n}\n"
    ],
    "sub_809147D": [
        "0x809147d",
        "int sub_809147D()\n{\n  char *v0; // eax\n  char *v1; // eax\n\n  v0 = (char *)sub_80B2E5A();\n  v1 = dirname(v0);\n  puts(v1);\n  return sub_804DD8F();\n}\n"
    ],
    "sub_8091499": [
        "0x8091499",
        "int __usercall sub_8091499@<eax>(char *a1@<edi>, int a2, int a3)\n{\n  int v3; // esi\n  const char **v4; // ebp\n  FILE *v5; // esi\n  FILE *v6; // ebx\n  int v7; // edx\n  int v8; // ecx\n  const char *v9; // eax\n  int v10; // ebx\n  int v11; // edx\n  char *IO_write_base; // eax\n  char *v13; // eax\n  char *v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  char *name; // [esp+0h] [ebp-80h]\n  const char *v19; // [esp+4h] [ebp-7Ch]\n  int v20; // [esp+8h] [ebp-78h]\n  __mode_t mode; // [esp+20h] [ebp-60h]\n  __uid_t owner; // [esp+28h] [ebp-58h]\n  __gid_t group; // [esp+2Ch] [ebp-54h]\n\n  v3 = (*ident == 100) + 1;\n  v20 = sub_80ABEAC(a3, \"^du\");\n  if ( !v20 )\n    v20 = v3;\n  v4 = (const char **)(a3 + 4 * optind);\n  do\n  {\n    v19 = *v4;\n    v5 = stdin;\n    v6 = stdout;\n    if ( !*v4 )\n      goto LABEL_13;\n    a1 = sub_804E1D0(*v4);\n    if ( !a1 )\n    {\n      v9 = v19;\n      goto LABEL_9;\n    }\n    v5 = (FILE *)sub_80B3D45(v8, v7);\n    fileno_unlocked(v5);\n    sub_804E010(a1);\n    name = sub_804DDBF(\"%sXXXXXX\", a1);\n    v10 = sub_804DD54(name);\n    if ( fchmod(v10, mode) == -1 )\n    {\n      v9 = name;\nLABEL_9:\n      sub_804D3FF(v9);\n    }\n    fchown(v10, owner, group);\n    v6 = (FILE *)sub_80B3D6E();\n    while ( 1 )\n    {\nLABEL_13:\n      IO_write_base = v5->_IO_write_base;\n      if ( IO_write_base < v5->_IO_write_end )\n      {\n        v5->_IO_write_base = IO_write_base + 1;\n        v11 = (unsigned __int8)*IO_write_base;\n        goto LABEL_12;\n      }\n      v11 = __fgetc_unlocked();\n      if ( v11 == -1 )\n        break;\nLABEL_12:\n      if ( v11 != 13 )\n      {\n        v13 = v6->_IO_write_base;\n        if ( v11 == 10 && v20 == 1 )\n        {\n          if ( v6->_IO_buf_base <= v13 )\n          {\n            __fputc_unlocked();\n            LOBYTE(v11) = 10;\n          }\n          else\n          {\n            v6->_IO_write_base = v13 + 1;\n            *v13 = 13;\n          }\n        }\n        v14 = v6->_IO_write_base;\n        if ( v14 >= v6->_IO_buf_base )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          v6->_IO_write_base = v14 + 1;\n          *v14 = v11;\n        }\n      }\n    }\n    if ( v19 )\n    {\n      if ( fclose(v5) < 0 || fclose(v6) < 0 )\n      {\n        unlink(name);\n        sub_80B0A23(v16, v15);\n      }\n      sub_804DC43(name, a1);\n      free(name);\n      free(a1);\n    }\n    if ( !*v4 )\n      break;\n    ++v4;\n  }\n  while ( *v4 );\n  return 0;\n}\n"
    ],
    "sub_8091641": [
        "0x8091641",
        "int __fastcall sub_8091641(const char *a1)\n{\n  const char *v2; // eax\n\n  v2 = (const char *)sub_80AD07E(qword_80DB778);\n  return printf(\"%s\\t%s\\n\", v2, a1);\n}\n"
    ],
    "sub_809167A": [
        "0x809167a",
        "int __usercall sub_809167A@<eax>(const char *a1@<eax>)\n{\n  int v2; // eax\n  const char *v3; // edx\n  __int64 *v4; // ecx\n  int v5; // esi\n  int v6; // edi\n  int v7; // eax\n  unsigned __int64 v8; // kr00_8\n  void *ptr; // [esp+0h] [ebp-74h]\n  DIR *dirp; // [esp+4h] [ebp-70h]\n  __int64 v13; // [esp+8h] [ebp-6Ch] BYREF\n  int v14; // [esp+18h] [ebp-5Ch]\n  unsigned int v15; // [esp+1Ch] [ebp-58h]\n  int v16; // [esp+40h] [ebp-34h]\n  int v17; // [esp+44h] [ebp-30h]\n\n  v2 = lstat64();\n  v3 = a1;\n  v4 = &v13;\n  if ( v2 )\n    goto LABEL_2;\n  if ( (dword_80DBB9C & 0x20) != 0 )\n  {\n    v3 = (const char *)HIDWORD(v13);\n    if ( MEMORY[0x80DB788] )\n    {\n      if ( *(_QWORD *)(&MEMORY[0x80DB788] + 1) != v13 )\n        return 0;\n    }\n    else\n    {\n      *(_QWORD *)(&MEMORY[0x80DB788] + 1) = v13;\n    }\n  }\n  v5 = v16;\n  v6 = v17;\n  if ( (v14 & 0xF000) == 40960 && *(&unk_80DB780 + 1) > (int)MEMORY[0x80DB788] )\n  {\n    if ( stat64() )\n    {\nLABEL_2:\n      sub_804D3F1(a1);\n      LOBYTE(unk_80DB780) = 1;\n      return 0;\n    }\n    v5 = v16;\n    v6 = v17;\n    if ( *(&unk_80DB780 + 1) == 1 )\n      *(&unk_80DB780 + 1) = 0x7FFFFFFF;\n  }\n  if ( (dword_80DBB9C & 0x80u) == 0 && v15 > 1 )\n  {\n    if ( sub_80AD709(v4, v3) )\n      return 0;\n    sub_80AD771();\n  }\n  if ( (v14 & 0xF000) == 0x4000 )\n  {\n    dirp = sub_804DF59(a1);\n    if ( !dirp )\n    {\n      LOBYTE(unk_80DB780) = 1;\n      return v5;\n    }\n    while ( readdir64() )\n    {\n      v7 = sub_80A9BF5();\n      if ( v7 )\n      {\n        ++MEMORY[0x80DB788];\n        ptr = (void *)v7;\n        v8 = sub_809167A() + __PAIR64__(v6, v5);\n        v6 = HIDWORD(v8);\n        v5 = v8;\n        --MEMORY[0x80DB788];\n        free(ptr);\n      }\n    }\n    closedir(dirp);\n  }\n  else if ( (dword_80DBB9C & 1) == 0 && MEMORY[0x80DB788] )\n  {\n    return v5;\n  }\n  if ( (int)MEMORY[0x80DB788] <= SHIDWORD(qword_80DB778) )\n    sub_8091641(a1);\n  return v5;\n}\n"
    ],
    "sub_80917F7": [
        "0x80917f7",
        "void __usercall __noreturn sub_80917F7(int a1@<eax>, int a2, int a3)\n{\n  __int16 v3; // bx\n  _DWORD *v4; // eax\n  const char **v5; // ebp\n  time_t v6; // ecx\n  int v7; // esi\n  time_t v9; // [esp+0h] [ebp-14h]\n\n  LODWORD(qword_80DB778) = 1024;\n  if ( getenv(\"POSIXLY_CORRECT\") )\n    LODWORD(qword_80DB778) = 512;\n  HIDWORD(qword_80DB778) = 0x7FFFFFFF;\n  v3 = sub_80ABEAC(a3, \"^aHkLsxd:+lchm\", (char *)&qword_80DB778 + 4, a1);\n  v4 = (_DWORD *)(a3 + 4 * optind);\n  if ( (v3 & 0x200) != 0 )\n    LODWORD(qword_80DB778) = 0;\n  if ( (v3 & 0x400) != 0 )\n    LODWORD(qword_80DB778) = 0x100000;\n  if ( (v3 & 4) != 0 )\n    LODWORD(qword_80DB778) = 1024;\n  if ( (v3 & 2) != 0 )\n    *(&unk_80DB780 + 1) = 1;\n  if ( (v3 & 8) != 0 )\n    *(&unk_80DB780 + 1) = 0x7FFFFFFF;\n  if ( (v3 & 0x10) != 0 )\n    HIDWORD(qword_80DB778) = 0;\n  v5 = (const char **)(a3 + 4 * optind);\n  if ( !*v4 )\n  {\n    v5 = (const char **)(v4 - 1);\n    *(v4 - 1) = 135072092;\n    if ( *(&unk_80DB780 + 1) == 1 )\n      *(&unk_80DB780 + 1) = 0;\n  }\n  v6 = *(&unk_80DB780 + 1);\n  v7 = 0;\n  do\n  {\n    v9 = v6;\n    v7 += sub_809167A(*v5);\n    sub_80AD7FC();\n    v6 = v9;\n    *(&unk_80DB780 + 1) = v9;\n    ++v5;\n  }\n  while ( *v5 );\n  if ( (v3 & 0x100) != 0 )\n    sub_8091641(\"total\");\n  sub_80AB247();\n}\n"
    ],
    "sub_809191A": [
        "0x809191a",
        "int __cdecl sub_809191A(int a1, const char **a2)\n{\n  _BYTE *v3; // eax\n  char *v4; // eax\n  char v5; // bl\n  char v6; // cl\n  char v7; // dl\n  const char **v8; // ebp\n  int v9; // ebx\n  char *v10; // edi\n  char *j; // ebx\n  unsigned __int8 *v12; // edx\n  unsigned __int8 *v13; // ebp\n  char v14; // al\n  unsigned __int8 v15; // al\n  int *v16; // esi\n  int result; // eax\n  char v18; // [esp+2h] [ebp-16h]\n  char i; // [esp+3h] [ebp-15h]\n\n  v18 = 0;\n  for ( i = 1; ; i = v6 )\n  {\n    v3 = *++a2;\n    if ( !*a2 || *v3 != 45 )\n      break;\n    v4 = v3 + 1;\n    v5 = v18;\n    v6 = i;\n    do\n    {\n      v7 = *v4;\n      if ( *v4 == 110 )\n      {\n        v6 = 0;\n      }\n      else if ( v7 == 101 )\n      {\n        v5 = 92;\n      }\n      else if ( v7 != 69 )\n      {\n        goto LABEL_13;\n      }\n      ++v4;\n    }\n    while ( *v4 );\n    v18 = v5;\n  }\nLABEL_13:\n  v8 = a2;\n  v9 = 0;\n  while ( *v8 )\n    v9 += strlen(*v8++) + 1;\n  v10 = (char *)sub_804DAFA(v9 + 1);\n  for ( j = v10; ; ++j )\n  {\n    v12 = (unsigned __int8 *)*a2;\n    if ( !*a2 )\n      break;\n    if ( v18 )\n    {\n      while ( 1 )\n      {\n        v13 = v12 + 1;\n        v14 = *v12;\n        if ( !*v12 )\n          break;\n        if ( v14 == v18 )\n        {\n          v15 = v12[1];\n          if ( v15 == 99 )\n            goto LABEL_33;\n          if ( v15 == 48 && (unsigned __int8)(v12[2] - 48) <= 7u )\n            v13 = v12 + 2;\n          v14 = sub_80B0CB3(*v12);\n        }\n        *j++ = v14;\n        v12 = v13;\n      }\n    }\n    else\n    {\n      j = (char *)stpcpy();\n    }\n    if ( !*++a2 )\n      break;\n    *j = 32;\n  }\n  if ( i )\n    *j++ = 10;\nLABEL_33:\n  v16 = (int *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  sub_804E586(j - v10, v10);\n  free(v10);\n  result = *v16;\n  if ( *v16 )\n  {\n    sub_804D3A5((int)\"write error\");\n    return 1;\n  }\n  return result;\n}\n"
    ],
    "sub_8091A52": [
        "0x8091a52",
        "void __cdecl __noreturn sub_8091A52(int a1, int a2)\n{\n  char v2; // al\n  char **v3; // ebx\n  char *v4; // edx\n  char *v5; // eax\n  char *v6; // esi\n  const char **v7; // ebx\n  int v8[3]; // [esp+0h] [ebp-Ch] BYREF\n\n  v8[0] = 0;\n  v2 = sub_80ABEC2(a2, \"+iu:*\", \"ignore-environment\", v8);\n  v3 = (char **)(a2 + 4 * optind);\n  v4 = *v3;\n  if ( *v3 && *v4 == 45 && !v4[1] )\n  {\n    v2 |= 1u;\n    ++v3;\n  }\n  if ( (v2 & 1) != 0 )\n    clearenv();\n  while ( v8[0] )\n  {\n    v5 = (char *)sub_80AFB01(v8[0]);\n    putenv(v5);\n  }\n  while ( 1 )\n  {\n    v6 = *v3;\n    if ( !*v3 )\n      break;\n    if ( !strchr(v6, 61) )\n      sub_80AB1EC(v8[0], v8[1], v8[2]);\n    if ( putenv(v6) < 0 )\n      sub_804D3C9((int)\"putenv\");\n    ++v3;\n  }\n  v7 = (const char **)environ;\n  if ( environ )\n  {\n    while ( *v7 )\n      puts(*v7++);\n  }\n  sub_80AB247();\n}\n"
    ],
    "sub_8091B09": [
        "0x8091b09",
        "_BOOL4 __usercall sub_8091B09@<eax>(int a1@<eax>)\n{\n  _BYTE *v1; // edx\n  _BOOL4 result; // eax\n\n  v1 = *(_BYTE **)(a1 + 4);\n  if ( !*(_BYTE *)a1 )\n    return *(_QWORD *)(a1 + 4) == 0LL;\n  result = 1;\n  if ( *v1 )\n  {\n    result = 0;\n    if ( *v1 == 48 )\n      return v1[1] == 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8091B33": [
        "0x8091b33",
        "char *__usercall sub_8091B33@<eax>(char *result@<eax>)\n{\n  char *v1; // ebx\n\n  if ( !*result )\n  {\n    v1 = result;\n    result = sub_804DDBF(\"%lld\", *(_QWORD *)(result + 4));\n    *((_DWORD *)v1 + 1) = result;\n    *v1 = 1;\n  }\n  return result;\n}\n"
    ],
    "sub_8091B57": [
        "0x8091b57",
        "_DWORD *__usercall sub_8091B57@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v2; // ebx\n\n  v2 = sub_804DB2E(0xCu);\n  *(_BYTE *)v2 = 1;\n  v2[1] = sub_804DB46(a1);\n  return v2;\n}\n"
    ],
    "sub_8091B79": [
        "0x8091b79",
        "char __usercall sub_8091B79@<al>(int a1@<eax>)\n{\n  __int64 v2; // rax\n  char *v3; // ecx\n  __int64 v5; // [esp+0h] [ebp-14h]\n  char *v6; // [esp+8h] [ebp-Ch] BYREF\n\n  if ( *(_BYTE *)a1 != 1 )\n    return 1;\n  v2 = strtoll((const char *)*(_DWORD *)(a1 + 4), &v6, 10);\n  v3 = *(char **)(a1 + 4);\n  if ( v3 == v6 || *v6 )\n    return 0;\n  v5 = v2;\n  free(v3);\n  *(_QWORD *)(a1 + 4) = v5;\n  *(_BYTE *)a1 = 0;\n  return 1;\n}\n"
    ],
    "sub_8091BD7": [
        "0x8091bd7",
        "int __usercall sub_8091BD7@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  __int64 v7; // [esp+0h] [ebp-1Ch]\n  __int64 v8; // [esp+8h] [ebp-14h]\n\n  if ( !sub_8091B79(a1) || !sub_8091B79(a2) )\n    sub_804D5E0(\"non-numeric argument\");\n  v7 = *(_QWORD *)(a1 + 4);\n  v8 = *(_QWORD *)(a2 + 4);\n  switch ( a3 )\n  {\n    case '+':\n      return v8 + v7;\n    case '-':\n      return v7 - v8;\n    case '*':\n      return v8 * v7;\n  }\n  if ( !v8 )\n    sub_804D5E0(\"division by zero\");\n  if ( a3 == 47 )\n    return sub_80B492D(v7, HIDWORD(v7), v8, HIDWORD(v8));\n  else\n    return sub_80B4A4A(v7, HIDWORD(v7), v8, HIDWORD(v8));\n}\n"
    ],
    "sub_8091CA5": [
        "0x8091ca5",
        "int __usercall sub_8091CA5@<eax>(void **a1@<eax>)\n{\n  int v3; // [esp-4h] [ebp-8h]\n\n  if ( *(_BYTE *)a1 == 1 )\n    free(a1[1]);\n  free(a1);\n  return v3;\n}\n"
    ],
    "sub_8091CBF": [
        "0x8091cbf",
        "int __usercall sub_8091CBF@<eax>(const char *a1@<eax>)\n{\n  int v2; // eax\n  int v3; // edx\n\n  if ( !*(_DWORD *)qword_80DB778 )\n    return 0;\n  v2 = strcmp(*(const char **)qword_80DB778, a1);\n  v3 = 0;\n  if ( !v2 )\n    return *((unsigned __int8 *)a1 + 1) + *(unsigned __int8 *)a1;\n  return v3;\n}\n"
    ],
    "sub_8091CF1": [
        "0x8091cf1",
        "_DWORD *__usercall sub_8091CF1@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  const char *v4; // eax\n  regoff_t rm_eo; // esi\n  regoff_t v6; // edi\n  _DWORD *v7; // eax\n  _DWORD *v9; // [esp+0h] [ebp-44h]\n  regmatch_t v10[2]; // [esp+4h] [ebp-40h] BYREF\n  regex_t preg; // [esp+14h] [ebp-30h] BYREF\n\n  sub_8091B33((char *)a1);\n  sub_8091B33((char *)a2);\n  if ( **(_BYTE **)(a2 + 4) == 94 )\n    sub_804D5F4(\n      \"warning: '%s': using '^' as the first character\\nof a basic regular expression is not portable; it is ignored\",\n      *(const char **)(a2 + 4));\n  memset(&preg, 0, sizeof(preg));\n  memset(v10, 0, sizeof(v10));\n  sub_80B47BA(0, *(_DWORD *)(a2 + 4));\n  if ( regexec(&preg, *(const char **)(a1 + 4), 2u, v10, 0) == 1 || v10[0].rm_so )\n  {\n    if ( !preg.re_nsub )\n    {\n      v7 = sub_804DB2E(0xCu);\n      v7[1] = 0;\n      v7[2] = 0;\n      goto LABEL_13;\n    }\n    v4 = &data;\n    goto LABEL_11;\n  }\n  if ( preg.re_nsub && v10[1].rm_so >= 0 )\n  {\n    *(_BYTE *)(*(_DWORD *)(a1 + 4) + v10[1].rm_eo) = 0;\n    v4 = (const char *)(*(_DWORD *)(a1 + 4) + v10[1].rm_so);\nLABEL_11:\n    v7 = sub_8091B57(v4);\n    goto LABEL_13;\n  }\n  rm_eo = v10[0].rm_eo;\n  v6 = v10[0].rm_eo >> 31;\n  v7 = sub_804DB2E(0xCu);\n  v7[1] = rm_eo;\n  v7[2] = v6;\nLABEL_13:\n  v9 = v7;\n  regfree(&preg);\n  return v9;\n}\n"
    ],
    "sub_8091DDE": [
        "0x8091dde",
        "void **sub_8091DDE()\n{\n  void **v0; // ebx\n  void **v1; // esi\n  void **v2; // edi\n\n  v0 = (void **)sub_809214F();\n  while ( sub_8091CBF(\":\") )\n  {\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v1 = (void **)sub_809214F();\n    v2 = (void **)sub_8091CF1((int)v0, (int)v1);\n    sub_8091CA5(v0);\n    sub_8091CA5(v1);\n    v0 = v2;\n  }\n  return v0;\n}\n"
    ],
    "sub_8091E27": [
        "0x8091e27",
        "void **sub_8091E27()\n{\n  void **i; // ebx\n  int v1; // esi\n  void **v2; // ebp\n  int v3; // esi\n  void *v4; // edx\n  void *v5; // edi\n\n  for ( i = sub_8091DDE(); ; i[2] = v5 )\n  {\n    v1 = sub_8091CBF(\"*\");\n    if ( !v1 )\n    {\n      v1 = sub_8091CBF(\"/\");\n      if ( !v1 )\n      {\n        v1 = sub_8091CBF(\"%\");\n        if ( !v1 )\n          break;\n      }\n    }\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v2 = sub_8091DDE();\n    v3 = sub_8091BD7((int)i, (int)v2, v1);\n    v5 = v4;\n    sub_8091CA5(i);\n    sub_8091CA5(v2);\n    i = (void **)sub_804DB2E(0xCu);\n    i[1] = (void *)v3;\n  }\n  return i;\n}\n"
    ],
    "sub_8091EA8": [
        "0x8091ea8",
        "void **sub_8091EA8()\n{\n  void **i; // ebx\n  int v1; // esi\n  void **v2; // ebp\n  int v3; // esi\n  void *v4; // edx\n  void *v5; // edi\n\n  for ( i = sub_8091E27(); ; i[2] = v5 )\n  {\n    v1 = sub_8091CBF(\"+\");\n    if ( !v1 )\n    {\n      v1 = sub_8091CBF(\"-\");\n      if ( !v1 )\n        break;\n    }\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v2 = sub_8091E27();\n    v3 = sub_8091BD7((int)i, (int)v2, v1);\n    v5 = v4;\n    sub_8091CA5(i);\n    sub_8091CA5(v2);\n    i = (void **)sub_804DB2E(0xCu);\n    i[1] = (void *)v3;\n  }\n  return i;\n}\n"
    ],
    "sub_8091F19": [
        "0x8091f19",
        "char *sub_8091F19()\n{\n  char *i; // ebx\n  int v1; // edi\n  void **v2; // esi\n  __int64 v3; // rax\n  void *v4; // ecx\n  void *v5; // ebp\n  int v6; // edi\n  bool v7; // al\n  bool v8; // zf\n\n  for ( i = (char *)sub_8091EA8(); ; *(_QWORD *)(i + 4) = v6 )\n  {\n    v1 = sub_8091CBF(\"<\");\n    if ( !v1 )\n    {\n      v1 = sub_8091CBF(\"<=\");\n      if ( !v1 )\n      {\n        v1 = sub_8091CBF(\"=\");\n        if ( !v1 )\n        {\n          v1 = sub_8091CBF(\"==\");\n          if ( !v1 )\n          {\n            v1 = sub_8091CBF(\"!=\");\n            if ( !v1 )\n            {\n              v1 = sub_8091CBF(\">=\");\n              if ( !v1 )\n              {\n                v1 = sub_8091CBF(\">\");\n                if ( !v1 )\n                  break;\n              }\n            }\n          }\n        }\n      }\n    }\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v2 = sub_8091EA8();\n    sub_8091B79((int)i);\n    sub_8091B79((int)v2);\n    v3 = *(_QWORD *)(i + 4);\n    v4 = v2[1];\n    v5 = v2[2];\n    if ( *i == 1 || *(_BYTE *)v2 == 1 )\n    {\n      sub_8091B33(i);\n      sub_8091B33((char *)v2);\n      v3 = strcmp(*((const char **)i + 1), (const char *)v2[1]);\n      v4 = 0;\n      v5 = 0;\n    }\n    switch ( v1 )\n    {\n      case '<':\n        v6 = 1;\n        if ( v3 < __SPAIR64__((unsigned int)v5, (unsigned int)v4) )\n          goto LABEL_29;\n        break;\n      case 'y':\n        v6 = 1;\n        if ( v3 <= __SPAIR64__((unsigned int)v5, (unsigned int)v4) )\n          goto LABEL_29;\n        break;\n      case 'z':\n      case '=':\n        v7 = __PAIR64__((unsigned int)v4, HIDWORD(v3)) == __PAIR64__(v3, (unsigned int)v5);\nLABEL_23:\n        v6 = v7;\n        goto LABEL_29;\n      case '^':\n        v7 = __PAIR64__((unsigned int)v4, HIDWORD(v3)) != __PAIR64__(v3, (unsigned int)v5);\n        goto LABEL_23;\n      default:\n        v8 = v1 == 62;\n        v6 = 1;\n        if ( v8 )\n        {\n          if ( v3 > __SPAIR64__((unsigned int)v5, (unsigned int)v4) )\n            goto LABEL_29;\n        }\n        else if ( v3 >= __SPAIR64__((unsigned int)v5, (unsigned int)v4) )\n        {\n          goto LABEL_29;\n        }\n        break;\n    }\n    v6 = 0;\nLABEL_29:\n    sub_8091CA5((void **)i);\n    sub_8091CA5(v2);\n    i = (char *)sub_804DB2E(0xCu);\n  }\n  return i;\n}\n"
    ],
    "sub_8092091": [
        "0x8092091",
        "void **sub_8092091()\n{\n  void **v0; // ebx\n  char *v1; // esi\n\n  v0 = (void **)sub_8091F19();\n  while ( sub_8091CBF(\"&\") )\n  {\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v1 = sub_8091F19();\n    if ( sub_8091B09((int)v0) || sub_8091B09((int)v1) )\n    {\n      sub_8091CA5(v0);\n      sub_8091CA5((void **)v1);\n      v0 = (void **)sub_804DB2E(0xCu);\n      v0[1] = 0;\n      v0[2] = 0;\n    }\n    else\n    {\n      sub_8091CA5((void **)v1);\n    }\n  }\n  return v0;\n}\n"
    ],
    "sub_8092104": [
        "0x8092104",
        "void **sub_8092104()\n{\n  void **v0; // ebx\n  void **v1; // esi\n\n  v0 = sub_8092091();\n  while ( sub_8091CBF(\"|\") )\n  {\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v1 = sub_8092091();\n    if ( sub_8091B09((int)v0) )\n    {\n      sub_8091CA5(v0);\n    }\n    else\n    {\n      sub_8091CA5(v1);\n      v1 = v0;\n    }\n    v0 = v1;\n  }\n  return v0;\n}\n"
    ],
    "sub_809214F": [
        "0x809214f",
        "_DWORD *__usercall sub_809214F@<eax>(_DWORD *a1@<esi>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // edi\n  int v5; // edx\n  const char *v6; // eax\n  int v7; // ebx\n  size_t v8; // edi\n  void **v9; // eax\n  int v10; // ebx\n  int v11; // edi\n  int v12; // ebp\n  unsigned int v13; // esi\n  unsigned int v14; // edi\n  int v15; // [esp+0h] [ebp-18h]\n  int v16; // [esp+0h] [ebp-18h]\n  size_t v17; // [esp+4h] [ebp-14h]\n\n  if ( !*(_DWORD *)qword_80DB778 || (v2 = sub_804D222(\"quote\", *(const char **)qword_80DB778), v3 = v2 + 1, v2 == -1) )\n  {\n    v1 = (const char **)qword_80DB778;\n    if ( !*(_DWORD *)qword_80DB778 )\n      goto LABEL_6;\n    if ( !sub_8091CBF(\"(\") )\n    {\n      if ( !sub_8091CBF(\")\") )\n      {\n        LODWORD(qword_80DB778) = v1 + 1;\n        return sub_8091B57(*v1);\n      }\n      goto LABEL_6;\n    }\n    LODWORD(qword_80DB778) = v1 + 1;\n    a1 = sub_8092104();\n    if ( !sub_8091CBF(\")\") )\n      goto LABEL_6;\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n  }\n  else\n  {\n    v5 = qword_80DB778;\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    if ( !v2 )\n    {\n      v6 = *(const char **)(v5 + 4);\n      if ( v6 )\n      {\n        LODWORD(qword_80DB778) = v5 + 8;\n        return sub_8091B57(v6);\n      }\nLABEL_6:\n      sub_804D5E0(\"syntax error\");\n    }\n    if ( v2 == 1 )\n    {\n      v7 = sub_809214F();\n      sub_8091B33((char *)v7);\n      v8 = strlen(*(const char **)(v7 + 4));\n      a1 = sub_804DB2E(0xCu);\n      a1[1] = v8;\n      a1[2] = 0;\n      v9 = (void **)v7;\nLABEL_32:\n      sub_8091CA5(v9);\n      return a1;\n    }\n    v10 = sub_809214F();\n    switch ( v3 )\n    {\n      case 3:\n        v11 = sub_809214F();\n        a1 = sub_8091CF1(v10, v11);\n        sub_8091CA5((void **)v10);\n        v9 = (void **)v11;\n        goto LABEL_32;\n      case 4:\n        v15 = sub_809214F();\n        sub_8091B33((char *)v10);\n        sub_8091B33((char *)v15);\n        v17 = strcspn(*(const char **)(v10 + 4), *(const char **)(v15 + 4)) + 1;\n        a1 = sub_804DB2E(0xCu);\n        a1[1] = v17;\n        a1[2] = 0;\n        if ( strlen(*(const char **)(v10 + 4)) + 1LL == v17 )\n        {\n          a1[1] = 0;\n          a1[2] = 0;\n        }\n        sub_8091CA5((void **)v10);\n        v9 = (void **)v15;\n        goto LABEL_32;\n      case 5:\n        v16 = sub_809214F();\n        v12 = sub_809214F();\n        sub_8091B33((char *)v10);\n        if ( sub_8091B79(v16)\n          && sub_8091B79(v12)\n          && (v13 = *(_DWORD *)(v16 + 4),\n              v14 = *(_DWORD *)(v16 + 8),\n              __SPAIR64__(v14, v13) <= strlen(*(const char **)(v10 + 4)))\n          && ((((__PAIR64__(v14, v13) - 1) >> 32) | v14) & 0x80000000) == 0LL\n          && *(__int64 *)(v12 + 4) > 0 )\n        {\n          a1 = sub_804DAFA(0xCu);\n          *(_BYTE *)a1 = 1;\n          a1[1] = sub_804DB5D((_BYTE *)(*(_DWORD *)(v10 + 4) + *(_DWORD *)(v16 + 4) - 1), *(_DWORD *)(v12 + 4));\n        }\n        else\n        {\n          a1 = sub_8091B57(&data);\n        }\n        sub_8091CA5((void **)v10);\n        sub_8091CA5((void **)v16);\n        v9 = (void **)v12;\n        goto LABEL_32;\n    }\n  }\n  return a1;\n}\n"
    ],
    "sub_80923B4": [
        "0x80923b4",
        "void __cdecl __noreturn sub_80923B4(int a1, int a2)\n{\n  void **v2; // ebx\n\n  byte_80DB560 = 2;\n  LODWORD(qword_80DB778) = a2 + 4;\n  if ( !*(_DWORD *)(a2 + 4) )\n    sub_804D5E0(\"too few arguments\");\n  v2 = sub_8092104();\n  if ( *(_DWORD *)qword_80DB778 )\n    sub_804D5E0(\"syntax error\");\n  if ( *(_BYTE *)v2 )\n    puts((const char *)v2[1]);\n  else\n    printf(\"%lld\\n\", *(_QWORD *)(v2 + 1));\n  sub_8091B09((int)v2);\n  sub_80AB247();\n}\n"
    ],
    "sub_809252E": [
        "0x809252e",
        "// positive sp value has been detected, the output may be wrong!\nint __usercall sub_809252E@<eax>(const char *a1@<eax>, int a2@<ebx>, int a3@<ebp>)\n{\n  unsigned int v3; // esi\n  int v4; // ebx\n  unsigned int v5; // ecx\n  unsigned int v6; // eax\n  unsigned int v7; // edx\n  int v8; // eax\n  __int64 v10; // rax\n  unsigned int v11; // edi\n  unsigned int v12; // esi\n  int v13; // ecx\n  unsigned int v14; // eax\n  int v15; // esi\n  int v16; // [esp-2Ch] [ebp-34h]\n  unsigned int v17; // [esp-28h] [ebp-30h]\n  unsigned int v18; // [esp-24h] [ebp-2Ch]\n  __int64 v19; // [esp-20h] [ebp-28h] BYREF\n  int v20; // [esp-14h] [ebp-1Ch]\n  int v21; // [esp-10h] [ebp-18h]\n  void **v22; // [esp-Ch] [ebp-14h]\n  int v23; // [esp-8h] [ebp-10h]\n  int v24; // [esp-4h] [ebp-Ch]\n  int v25; // [esp+4h] [ebp-4h]\n  void *retaddr; // [esp+8h] [ebp+0h] BYREF\n\n  if ( *a1 == 43 )\n    ++a1;\n  v10 = sub_804EC9E(a1, 0, 10);\n  v11 = HIDWORD(v10);\n  v12 = v10;\n  if ( *(_DWORD *)dword_80DBB7C )\n    sub_804CDC2();\n  printf(\"%llu:\", v10);\n  v14 = v12;\n  v15 = v24;\n  v24 = v25;\n  v23 = a3;\n  v22 = &retaddr;\n  v21 = v15;\n  v20 = a2;\n  v3 = v14;\n  if ( __PAIR64__(v11, v14) > 3 )\n  {\n    while ( (v3 & 1) == 0 )\n    {\n      printf(\" 2\");\n      v3 = __PAIR64__(v11, v3) >> 1;\n      v11 >>= 1;\n      v13 = v16;\n    }\n    v18 = (((int (__fastcall *)(int, unsigned int))sub_80AD876)(v13, v11) - 1) | 1;\n    v4 = 913;\n    v5 = 3;\n    while ( 1 )\n    {\n      v17 = v5;\n      v6 = sub_80B4D6F(v3, v11, v5, 0, &v19);\n      v5 = v17;\n      if ( v19 )\n        break;\n      v3 = v6;\n      v11 = v7;\n      printf(\" %u\", v17);\n      v18 = (sub_80AD876() - 1) | 1;\n      v8 = v4;\n      v5 = v17;\nLABEL_11:\n      v4 = v8;\n    }\n    while ( v5 < v18 )\n    {\n      v5 += 2;\n      v8 = v4 + 137;\n      if ( ((v4 + 137) & 0x844) == 0 )\n        goto LABEL_11;\n      if ( (((_BYTE)v4 - 119) & 4) != 0 )\n        v8 = v4 + 134;\n      if ( (v8 & 0x40) != 0 )\n        v8 -= 40;\n      if ( (v8 & 0x800) != 0 )\n        v8 -= 896;\n      v4 = v8;\n    }\n  }\n  if ( v11 || v3 > 1 )\n    printf(\" %llu\", __PAIR64__(v11, v3));\n  return sub_804DD98(10);\n}\n"
    ],
    "sub_809256F": [
        "0x809256f",
        "int __usercall sub_809256F@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebp>, int a4, int a5)\n{\n  int v5; // edx\n  int v6; // ecx\n  void *v7; // esi\n  const char *v8; // edi\n  _BYTE *v9; // eax\n  int v10; // ebx\n  _DWORD *v11; // ebx\n  const char *v12; // eax\n\n  if ( *(_DWORD *)(a5 + 4) )\n  {\n    v11 = (_DWORD *)(a5 + 4);\n    do\n    {\n      v12 = (const char *)sub_80B2E8C(a2, a1);\n      sub_809252E(v12, (int)v11++, a3);\n    }\n    while ( *v11 );\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v7 = (void *)sub_80AB85A();\n      if ( !v7 )\n        break;\n      while ( 1 )\n      {\n        v8 = (const char *)sub_80B2E8C(v6, v5);\n        if ( !*v8 )\n          break;\n        v9 = (_BYTE *)sub_80B2E9F();\n        v10 = (int)v9;\n        if ( *v9 )\n        {\n          *v9 = 0;\n          v10 = (int)(v9 + 1);\n        }\n        sub_809252E(v8, v10, a3);\n      }\n      free(v7);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_80925DB": [
        "0x80925db",
        "int sub_80925DB()\n{\n  return 1;\n}\n"
    ],
    "sub_80925E1": [
        "0x80925e1",
        "unsigned int __usercall sub_80925E1@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int v2; // ecx\n  int v4; // eax\n\n  v2 = dword_80DBB9C & 1;\n  if ( (dword_80DBB9C & 1) != 0 )\n    return a1 + 1;\n  switch ( a2 )\n  {\n    case 9:\n      return (a1 & 0xFFFFFFF8) + 8;\n    case 8:\n      v4 = a1 - 1;\n      if ( v4 >= 0 )\n        return v4;\n      break;\n    case 13:\n      break;\n    default:\n      return a1 + 1;\n  }\n  return v2;\n}\n"
    ],
    "sub_8092611": [
        "0x8092611",
        "size_t __usercall sub_8092611@<eax>(const void *a1@<eax>, size_t a2@<edx>)\n{\n  return fwrite(a1, 1u, a2, stdout);\n}\n"
    ],
    "sub_8092624": [
        "0x8092624",
        "void __cdecl __noreturn sub_8092624(int a1, int a2)\n{\n  char **i; // ebx\n  char *v3; // eax\n  char v4; // dl\n  const char **v5; // ebp\n  char *v6; // esi\n  size_t v7; // ebx\n  unsigned int v8; // edi\n  unsigned __int8 *v9; // eax\n  int v10; // edi\n  char v11; // al\n  size_t v12; // edi\n  _BYTE *v13; // edx\n  char *v14; // ecx\n  int v15; // [esp+0h] [ebp-30h]\n  int v16; // [esp+4h] [ebp-2Ch]\n  unsigned int v17; // [esp+Ch] [ebp-24h]\n  char *v18; // [esp+18h] [ebp-18h]\n  const char *v19; // [esp+1Ch] [ebp-14h] BYREF\n\n  v19 = \"80\";\n  for ( i = (char **)(a2 + 4); ; ++i )\n  {\n    v3 = *i;\n    if ( !*i )\n      break;\n    if ( *v3 == 45 )\n    {\n      v4 = v3[1];\n      if ( v4 == 45 && !v3[2] )\n        break;\n      if ( (unsigned __int8)(v4 - 48) <= 9u )\n        *i = sub_804DDBF(\"-w%s\", v3 + 1);\n    }\n  }\n  sub_80ABEAC(a2, \"bsw:\", &v19);\n  v17 = sub_80B40CC(10000, 1);\n  v5 = (const char **)(a2 + 4 * optind);\n  if ( !*v5 )\n    *--v5 = \"-\";\n  v6 = 0;\nLABEL_12:\n  v15 = sub_80B3D76(v15);\n  if ( !v15 )\n    goto LABEL_40;\nLABEL_13:\n  v7 = 0;\n  v8 = 0;\n  while ( 1 )\n  {\n    v9 = *(unsigned __int8 **)(v15 + 16);\n    if ( (unsigned int)v9 >= *(_DWORD *)(v15 + 24) )\n    {\n      v16 = __fgetc_unlocked();\n      if ( v16 == -1 )\n      {\n        if ( v7 )\n          sub_8092611(v6, v7);\n        if ( sub_80AB218() )\n          sub_804D3F1(*v5);\nLABEL_40:\n        if ( !*++v5 )\n          sub_80AB247();\n        goto LABEL_12;\n      }\n    }\n    else\n    {\n      *(_DWORD *)(v15 + 16) = v9 + 1;\n      v16 = *v9;\n    }\n    if ( (v7 & 0xFFF) == 0 )\n      v6 = (char *)sub_804DB13(v6, v7 + 4096);\n    while ( 1 )\n    {\n      v6[v7] = v16;\n      if ( v16 == 10 )\n      {\n        sub_8092611(v6, v7 + 1);\n        goto LABEL_13;\n      }\n      v8 = sub_80925E1(v8, v16);\n      if ( v8 <= v17 || !v7 )\n        break;\n      v10 = v7 - 1;\n      if ( (dword_80DBB9C & 2) != 0 )\n      {\n        while ( 1 )\n        {\n          if ( v10 < 0 )\n            goto LABEL_34;\n          v11 = v6[v10];\n          if ( v11 == 32 || v11 == 9 )\n            break;\n          --v10;\n        }\n        v12 = v10 + 1;\n        sub_8092611(v6, v12);\n        v13 = *(_BYTE **)(_stdout + 16);\n        if ( (unsigned int)v13 >= *(_DWORD *)(_stdout + 28) )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(_stdout + 16) = v13 + 1;\n          *v13 = 10;\n        }\n        v7 -= v12;\n        memmove(v6, &v6[v12], v7);\n        v14 = v6;\n        v8 = 0;\n        while ( v14 != &v6[v7] )\n        {\n          v18 = v14;\n          v8 = sub_80925E1(v8, *v14);\n          v14 = v18 + 1;\n        }\n      }\n      else\n      {\nLABEL_34:\n        v6[v7] = 10;\n        sub_8092611(v6, v7 + 1);\n        v7 = 0;\n        v8 = 0;\n      }\n    }\n    ++v7;\n  }\n}\n"
    ],
    "sub_809283F": [
        "0x809283f",
        "void __cdecl __noreturn sub_809283F(int a1, char *const *a2)\n{\n  int v2; // ebx\n  char *const *v3; // esi\n  _BYTE *v4; // eax\n  char *v5; // eax\n  int v6; // eax\n  int v7; // ebx\n  const char **v8; // ebp\n  const char *v9; // esi\n  FILE *v10; // eax\n  FILE *v11; // ebx\n  char *v12; // edi\n  char *IO_write_base; // eax\n  int v14; // esi\n  char *v15; // ecx\n  char *v16; // eax\n  _DWORD *v17; // esi\n  int v18; // edi\n  int v19; // eax\n  int v20; // edi\n  int v21; // eax\n  void *v22; // edx\n  int v23; // edi\n  unsigned int v24; // esi\n  char *v25; // eax\n  int v26; // eax\n  _BYTE *v27; // ecx\n  void *v28; // [esp-8h] [ebp-3Ch]\n  FILE *v29; // [esp-4h] [ebp-38h]\n  int v30; // [esp+0h] [ebp-34h]\n  unsigned int v31; // [esp+4h] [ebp-30h]\n  size_t v32; // [esp+8h] [ebp-2Ch]\n  char v33; // [esp+Eh] [ebp-26h]\n  char v34; // [esp+Fh] [ebp-25h]\n  int v35; // [esp+10h] [ebp-24h]\n  void **v36; // [esp+10h] [ebp-24h]\n  char ptr; // [esp+18h] [ebp-1Ch]\n  void *ptra; // [esp+18h] [ebp-1Ch]\n  void *ptrb; // [esp+18h] [ebp-1Ch]\n\n  v2 = a1;\n  v3 = a2;\n  v4 = (_BYTE *)*((_DWORD *)a2 + 1);\n  if ( !v4 || *v4 != 45 || (unsigned __int8)(v4[1] - 48) > 9u )\n  {\n    v34 = 0;\n    v33 = 0;\n    v30 = 1;\n    v31 = 10;\n    goto LABEL_13;\n  }\n  v2 = a1 - 1;\n  v3 = a2 + 1;\n  v5 = v4 + 1;\n  v34 = 0;\n  v33 = 0;\n  v30 = 1;\n  while ( 1 )\n  {\n    if ( *v5 == 45 )\n      v34 = 1;\n    v31 = sub_80B40DC();\n    while ( 1 )\n    {\nLABEL_13:\n      v6 = getopt(v2, v3, \"n:c:qv\");\n      if ( v6 <= 0 )\n      {\n        v7 = v2 - optind;\n        v8 = (const char **)&v3[optind];\n        if ( !*v8 )\n          *--v8 = \"-\";\n        if ( v30 >= v7 )\n          v30 = 0;\n        if ( v31 > 0x1FFFFFFE && v34 )\n          sub_804D5F4(\"count is too big: %lu\", v31);\n        v32 = v31 + 1;\n        v9 = \"==> %s <==\\n\";\n        while ( 1 )\n        {\n          v10 = (FILE *)sub_80B3D76(v30);\n          v11 = v10;\n          if ( v10 )\n          {\n            if ( stdin == v10 )\n              *v8 = \"standard input\";\n            if ( v30 )\n              printf(v9);\n            if ( v34 )\n            {\n              if ( v33 )\n              {\n                v12 = (char *)sub_804DAFA(v32);\n                v35 = 0;\n                while ( 1 )\n                {\n                  IO_write_base = v11->_IO_write_base;\n                  if ( IO_write_base >= v11->_IO_write_end )\n                  {\n                    IO_write_base = (char *)__fgetc_unlocked();\n                    if ( IO_write_base == (char *)-1 )\n                    {\nLABEL_51:\n                      free(v12);\n                      goto LABEL_73;\n                    }\n                  }\n                  else\n                  {\n                    v11->_IO_write_base = IO_write_base + 1;\n                    LOBYTE(IO_write_base) = *IO_write_base;\n                  }\n                  v12[v35++] = (char)IO_write_base;\n                  if ( v35 == v32 )\n                  {\n                    while ( 1 )\n                    {\n                      v14 = 0;\n                      do\n                      {\n                        v15 = *(char **)(_stdout + 16);\n                        ptr = v12[v14];\n                        if ( (unsigned int)v15 >= *(_DWORD *)(_stdout + 28) )\n                        {\n                          __fputc_unlocked();\n                        }\n                        else\n                        {\n                          *(_DWORD *)(_stdout + 16) = v15 + 1;\n                          *v15 = ptr;\n                        }\n                        v16 = v11->_IO_write_base;\n                        if ( v16 >= v11->_IO_write_end )\n                        {\n                          v16 = (char *)__fgetc_unlocked();\n                          if ( v16 == (char *)-1 )\n                            goto LABEL_51;\n                        }\n                        else\n                        {\n                          v11->_IO_write_base = v16 + 1;\n                          LOBYTE(v16) = *v16;\n                        }\n                        v12[v14++] = (char)v16;\n                      }\n                      while ( v35 != v14 );\n                    }\n                  }\n                }\n              }\n              v17 = sub_804DB2E(4 * (v31 + 1));\n              v18 = 0;\n              do\n              {\n                v19 = ((int (*)(void))sub_80AB850)();\n                if ( !v19 )\n                  goto LABEL_59;\n                v17[v18++] = v19;\n              }\n              while ( v32 != v18 );\nLABEL_55:\n              v20 = 0;\n              while ( 1 )\n              {\n                v36 = (void **)&v17[v20];\n                v29 = stdout;\n                v28 = *v36;\n                ptra = *v36;\n                fputs_unlocked();\n                v21 = sub_80AB850(v28, v29);\n                v22 = ptra;\n                if ( !v21 )\n                  break;\n                ptrb = (void *)v21;\n                free(v22);\n                ++v20;\n                *v36 = ptrb;\n                if ( v32 == v20 )\n                  goto LABEL_55;\n              }\nLABEL_59:\n              v23 = 0;\n              do\n                free((void *)v17[v23++]);\n              while ( v32 != v23 );\n              free(v17);\n              goto LABEL_73;\n            }\n            v24 = v31;\n            while ( v24 )\n            {\n              v25 = v11->_IO_write_base;\n              if ( v25 >= v11->_IO_write_end )\n              {\n                v26 = __fgetc_unlocked();\n                if ( v26 == -1 )\n                  break;\n              }\n              else\n              {\n                v11->_IO_write_base = v25 + 1;\n                v26 = (unsigned __int8)*v25;\n              }\n              if ( v26 == 10 || v33 )\n                --v24;\n              v27 = *(_BYTE **)(_stdout + 16);\n              if ( (unsigned int)v27 >= *(_DWORD *)(_stdout + 28) )\n              {\n                __fputc_unlocked();\n              }\n              else\n              {\n                *(_DWORD *)(_stdout + 16) = v27 + 1;\n                *v27 = v26;\n              }\n            }\nLABEL_73:\n            sub_804DD80();\n            if ( sub_80AB218() )\n              sub_804D3F1(*v8);\n          }\n          ++v8;\n          v9 = (const char *)&unk_80D5F92;\n          if ( !*v8 )\n            sub_80AB247();\n        }\n      }\n      if ( v6 == 110 )\n        goto LABEL_19;\n      if ( v6 <= 110 )\n        break;\n      if ( v6 == 113 )\n      {\n        v30 = 0x7FFFFFFF;\n      }\n      else\n      {\n        if ( v6 != 118 )\n          goto LABEL_20;\n        v30 = -1;\n      }\n    }\n    if ( v6 != 99 )\nLABEL_20:\n      sub_804CDC2();\n    v33 = 1;\nLABEL_19:\n    v5 = optarg;\n  }\n}\n"
    ],
    "sub_8092B79": [
        "0x8092b79",
        "int __cdecl sub_8092B79(int a1, int a2)\n{\n  int v2; // eax\n\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v2 = gethostid();\n  printf(\"%08x\\n\", v2);\n  return sub_804DD8F();\n}\n"
    ],
    "sub_8092B9F": [
        "0x8092b9f",
        "int __usercall sub_8092B9F@<eax>(__gid_t list[]@<ecx>, __gid_t group@<edx>, const char *a3@<eax>, int *ngroups)\n{\n  int result; // eax\n\n  if ( a3 )\n  {\n    result = getgrouplist(a3, group, list, ngroups);\n    if ( *ngroups < 0 )\n      return 0;\n  }\n  else\n  {\n    result = getgroups(*ngroups, list);\n    *ngroups = result;\n    if ( result < 0 )\n    {\n      if ( *(_DWORD *)dword_80DBB7C == 22 )\n        *ngroups = getgroups(0, list);\n      return ~*ngroups >> 31;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8092C66": [
        "0x8092c66",
        "int __usercall sub_8092C66@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ebx\n  const char *v4; // eax\n  int v8; // eax\n  const char *v9; // ecx\n\n  v8 = sub_80A99F5();\n  v9 = a2;\n  v2 = a1;\n  v3 = v8;\n  if ( v9 )\n    printf(\"%s\", v9);\n  if ( (dword_80DBB9C & 2) == 0 || !v3 )\n    printf(\"%u\", v2);\n  if ( !dword_80DBB9C )\n  {\n    if ( !v3 )\n      return 0;\n    v4 = \"(%s)\";\nLABEL_13:\n    printf(v4);\n    return 0;\n  }\n  if ( (dword_80DBB9C & 2) == 0 )\n    return 0;\n  if ( v3 )\n  {\n    v4 = \"\\r\\n%s\" + 2;\n    goto LABEL_13;\n  }\n  sub_804D5F4(\"unknown ID %u\", v2);\n  return 1;\n}\n"
    ],
    "sub_8092C7E": [
        "0x8092c7e",
        "int __usercall sub_8092C7E@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ebx\n  const char *v4; // eax\n  int v8; // eax\n  const char *v9; // ecx\n\n  v8 = sub_80A9A06();\n  v9 = a2;\n  v2 = a1;\n  v3 = v8;\n  if ( v9 )\n    printf(\"%s\", v9);\n  if ( (dword_80DBB9C & 2) == 0 || !v3 )\n    printf(\"%u\", v2);\n  if ( !dword_80DBB9C )\n  {\n    if ( !v3 )\n      return 0;\n    v4 = \"(%s)\";\nLABEL_13:\n    printf(v4);\n    return 0;\n  }\n  if ( (dword_80DBB9C & 2) == 0 )\n    return 0;\n  if ( v3 )\n  {\n    v4 = \"\\r\\n%s\" + 2;\n    goto LABEL_13;\n  }\n  sub_804D5F4(\"unknown ID %u\", v2);\n  return 1;\n}\n"
    ],
    "sub_8092C96": [
        "0x8092c96",
        "void __cdecl __noreturn sub_8092C96(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // ebp\n  __gid_t v4; // esi\n  int v5; // edi\n  int v6; // eax\n  int v7; // ebx\n  int v8; // ebx\n  const char *v9; // edx\n  void *v10; // ebp\n  const char *v11; // edx\n  int i; // ecx\n  int v13; // eax\n  int v14; // ebx\n  int v15; // [esp+0h] [ebp-20h]\n  int v16; // [esp+4h] [ebp-1Ch]\n  const char *v17; // [esp+8h] [ebp-18h]\n  int v18; // [esp+8h] [ebp-18h]\n  int ngroups[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v15 = sub_80ABEAC(a2, \"^rnugG\");\n  v17 = *(const char **)(a2 + 4 * optind);\n  if ( v17 )\n  {\n    v2 = sub_80A999C();\n    v3 = *(_DWORD *)(v2 + 8);\n    v4 = *(_DWORD *)(v2 + 12);\n    if ( !v15 )\n    {\n      v14 = sub_8092C66(v3, \"uid=\");\n      v8 = sub_8092C7E(v4, \" gid=\") | v14;\n      v5 = v4;\n      v16 = v3;\n      goto LABEL_14;\n    }\n    v5 = *(_DWORD *)(v2 + 12);\n    v16 = *(_DWORD *)(v2 + 8);\n  }\n  else\n  {\n    v5 = getegid();\n    v4 = getgid();\n    v16 = geteuid();\n    v6 = getuid();\n    v3 = v6;\n    if ( !v15 )\n    {\n      v7 = sub_8092C66(v6, \"uid=\");\n      v8 = sub_8092C7E(v4, \" gid=\") | v7;\n      if ( v16 != v3 )\n        v8 |= sub_8092C66(v16, \" euid=\");\n      v9 = \" egid=\";\n      if ( v5 == v4 )\n        goto LABEL_14;\n      goto LABEL_13;\n    }\n  }\n  if ( (v15 & 0x10) == 0 )\n  {\n    if ( (v15 & 1) != 0 )\n      goto LABEL_29;\n    goto LABEL_28;\n  }\n  v8 = sub_8092C7E(v4, 0);\n  if ( v5 == v4 )\n    goto LABEL_14;\n  v9 = \"        \" + 7;\nLABEL_13:\n  v8 |= sub_8092C7E(v5, v9);\nLABEL_14:\n  v10 = sub_804DAFA(0x100u);\n  ngroups[0] = 64;\n  if ( sub_8092B9F((__gid_t *)v10, v4, v17, ngroups) < 0 )\n  {\n    v10 = sub_804DB13(v10, 4 * ngroups[0]);\n    sub_8092B9F((__gid_t *)v10, v4, v17, ngroups);\n  }\n  if ( ngroups[0] <= 0 )\n  {\n    if ( ngroups[0] )\n      sub_804D5E0(\"can't get groups\");\nLABEL_28:\n    v4 = v5;\n    v3 = v16;\nLABEL_29:\n    if ( (v15 & 4) != 0 )\n    {\n      sub_8092C66(v3, 0);\n    }\n    else if ( (v15 & 8) != 0 )\n    {\n      sub_8092C7E(v4, 0);\n    }\n    sub_804DD98(10);\n    sub_80AB247();\n  }\n  v11 = \" groups=\";\n  for ( i = 0; ; ++i )\n  {\n    if ( ngroups[0] <= i )\n      goto LABEL_28;\n    v13 = *((_DWORD *)v10 + i);\n    if ( !v15 )\n      goto LABEL_23;\n    if ( v13 != v4 && v13 != v5 )\n      break;\nLABEL_24:\n    ;\n  }\n  v11 = \"        \" + 7;\nLABEL_23:\n  v18 = i;\n  v8 |= sub_8092C7E(v13, v11);\n  v11 = \"Linux User,,,\" + 12;\n  i = v18;\n  goto LABEL_24;\n}\n"
    ],
    "sub_8092E75": [
        "0x8092e75",
        "int __cdecl sub_8092E75(int a1, int a2)\n{\n  __int16 v2; // bp\n  int v3; // ebx\n  int v4; // edi\n  __uid_t v5; // eax\n  __gid_t v6; // eax\n  const char **v7; // edx\n  int v8; // eax\n  int v9; // esi\n  const char *v10; // ebx\n  char *v11; // eax\n  char *v12; // eax\n  int v13; // ecx\n  char *file; // [esp+0h] [ebp-B4h]\n  int v16; // [esp+4h] [ebp-B0h]\n  int v17; // [esp+8h] [ebp-ACh]\n  int v18; // [esp+Ch] [ebp-A8h]\n  char *ptr; // [esp+10h] [ebp-A4h]\n  int mode; // [esp+14h] [ebp-A0h]\n  __uid_t owner; // [esp+18h] [ebp-9Ch]\n  __gid_t group; // [esp+1Ch] [ebp-98h]\n  const char *v23; // [esp+24h] [ebp-90h] BYREF\n  int v24; // [esp+28h] [ebp-8Ch] BYREF\n  int v25; // [esp+2Ch] [ebp-88h] BYREF\n  int v26[5]; // [esp+30h] [ebp-84h] BYREF\n  int v27; // [esp+54h] [ebp-60h]\n\n  v2 = sub_80ABEC2(a2, \"^cvbDdpsg:m:o:t:\", \"verbose\", &v24, v26, &v25, &v23);\n  v3 = a1 - optind;\n  v18 = a2 + 4 * optind;\n  v4 = (v2 & 2) == 0 ? 10 : 4106;\n  v16 = (v2 & 2) == 0 ? 4 : 4100;\n  if ( (v2 & 0x20) != 0 )\n    v4 |= 1u;\n  mode = 493;\n  if ( (v2 & 0x100) != 0 )\n    mode = sub_80B07AF();\n  if ( (v2 & 0x200) != 0 )\n    v5 = sub_80A9A55();\n  else\n    v5 = getuid();\n  owner = v5;\n  if ( (v2 & 0x80) != 0 )\n    v6 = sub_80A9A55();\n  else\n    v6 = getgid();\n  group = v6;\n  v17 = v2 & 0x410;\n  if ( (v2 & 0x410) != 0 )\n  {\n    v8 = v2 & 0x400;\n    goto LABEL_15;\n  }\n  --v3;\n  v7 = (const char **)(v18 + 4 * v3);\n  v23 = *v7;\n  *v7 = 0;\n  if ( stat64() >= 0 )\n  {\n    v8 = (v27 & 0xF000) == 0x4000;\nLABEL_15:\n    v17 = v8;\n  }\n  if ( v3 <= 0 )\n    sub_804CDC2();\n  v9 = 0;\n  while ( 1 )\n  {\n    v18 += 4;\n    file = *(char **)(v18 - 4);\n    if ( !file )\n      return v9;\n    if ( (v2 & 0x10) != 0 )\n    {\n      if ( sub_80B00B9(v16, 493) )\n        goto LABEL_38;\n      v10 = file;\n      goto LABEL_33;\n    }\n    v10 = v23;\n    if ( (v2 & 8) != 0 )\n    {\n      v11 = sub_804DB46(v23);\n      ptr = v11;\n      if ( (v2 & 0x400) == 0 )\n        dirname(v11);\n      sub_80B00B9(v16, 493);\n      free(ptr);\n    }\n    if ( v17 )\n    {\n      v12 = sub_804D315(file);\n      v10 = (const char *)sub_804D2D1((int)v23, v12, v13);\n    }\n    if ( sub_80A9C77(v4) )\n    {\nLABEL_38:\n      v9 = 1;\n    }\n    else\n    {\n      if ( (v2 & 0x40) != 0 )\n      {\n        v26[1] = (int)\"strip\";\n        v26[2] = (int)\"-p\";\n        v26[3] = (int)v10;\n        v26[4] = 0;\n        if ( sub_80B3C03(file, v16, v17, v18, ptr, mode) )\n        {\n          sub_804D3A5((int)\"strip\");\n          v9 = 1;\n        }\n      }\nLABEL_33:\n      if ( chmod(v10, mode) == -1 )\n      {\n        sub_804D3A5((int)\"can't change %s of %s\", \"permissions\", v10);\n        v9 = 1;\n      }\n      if ( (v2 & 0x280) != 0 && lchown(v10, owner, group) == -1 )\n      {\n        sub_804D3A5((int)\"can't change %s of %s\", \"ownership\", v10);\n        goto LABEL_38;\n      }\n    }\n  }\n}\n"
    ],
    "sub_8093127": [
        "0x8093127",
        "int __cdecl sub_8093127(int a1, int a2)\n{\n  const char **v2; // ebx\n\n  sub_80ABEAC(a2, &unk_80D60E5);\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( link(*v2, v2[1]) )\n    sub_804D3C9((int)\"can't create %slink '%s' to '%s'\", \"hard\", v2[1], *v2);\n  return 0;\n}\n"
    ],
    "sub_8093168": [
        "0x8093168",
        "int __cdecl sub_8093168(int a1, int a2)\n{\n  char *v2; // edi\n  const char **v3; // ebx\n  char *v4; // eax\n  int v5; // ecx\n  char *v6; // esi\n  int v7; // ecx\n  char *v8; // eax\n  int v9; // ecx\n  char *v10; // ebp\n  const char *v11; // esi\n  char v13; // [esp+0h] [ebp-90h]\n  int ptr; // [esp+4h] [ebp-8Ch]\n  int (*v15)(const char *, const char *); // [esp+Ch] [ebp-84h]\n  char *v16; // [esp+18h] [ebp-78h]\n  const char *v17; // [esp+1Ch] [ebp-74h] BYREF\n  int v18; // [esp+30h] [ebp-60h]\n\n  v17 = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\" + 31;\n  v13 = sub_80ABEAC(a2, \"^sfnbS:vT\", &v17);\n  v2 = *(char **)(a2 + 4 * a1 - 4);\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( a1 - optind > 2 && (v13 & 0x40) != 0 )\n    sub_804D5E0(\"-T accepts 2 args max\");\n  if ( !v3[1] )\n  {\n    *(v3 - 1) = v2;\n    v4 = sub_804DB46(v2);\n    v2 = sub_804D34F(v4, v5);\n    --v3;\n  }\n  v15 = link;\n  if ( (v13 & 1) != 0 )\n    v15 = symlink;\n  ptr = 0;\n  do\n  {\n    if ( sub_80AD83E() )\n    {\n      if ( (v13 & 0x40) != 0 )\n        sub_804D5E0(\"'%s' is a directory\", v2);\n      v6 = sub_804DB46(*v3);\n      v8 = sub_804D34F(v6, v7);\n      v10 = (char *)sub_804D2D1((int)v2, v8, v9);\n      free(v6);\n      v11 = v10;\n    }\n    else\n    {\n      v11 = v2;\n      v10 = 0;\n    }\n    if ( (v13 & 1) == 0 && stat64() && (lstat64() || (v18 & 0xF000) != 40960) )\n    {\n      sub_804D3F1(*v3);\n      free(v10);\nLABEL_23:\n      ptr = 1;\n      goto LABEL_32;\n    }\n    if ( (v13 & 8) != 0 )\n    {\n      v16 = sub_804DDBF(\"%s%s\", v11, v17);\n      if ( rename(v11, v16) < 0 && *(_DWORD *)dword_80DBB7C != 2 )\n      {\n        sub_804D3F1(v11);\n        free(v16);\n        goto LABEL_23;\n      }\n      free(v16);\n      unlink(v11);\n    }\n    else if ( (v13 & 2) != 0 )\n    {\n      unlink(v11);\n    }\n    if ( (v13 & 0x20) != 0 )\n      printf(\"'%s' -> '%s'\\n\", v11, *v3);\n    if ( v15(*v3, v11) )\n    {\n      sub_804D3F1(v11);\n      ptr = 1;\n    }\n    free(v10);\nLABEL_32:\n    ++v3;\n  }\n  while ( v3[1] );\n  return ptr;\n}\n"
    ],
    "sub_8093370": [
        "0x8093370",
        "int __cdecl sub_8093370(int a1, int a2)\n{\n  char name[68]; // [esp+0h] [ebp-44h] BYREF\n\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  if ( getlogin_r(name, 0x40u) )\n    sub_804D3C9((int)\"getlogin\");\n  puts(name);\n  return sub_804DD8F();\n}\n"
    ],
    "sub_80933AF": [
        "0x80933af",
        "char __usercall sub_80933AF@<al>(unsigned __int16 a1@<ax>)\n{\n  int v2; // ecx\n  char result; // al\n\n  if ( (dword_80DBB9C & 0x3000) == 0 )\n    return 0;\n  v2 = a1 & 0xF000;\n  result = 47;\n  if ( v2 != 0x4000 )\n  {\n    result = 0;\n    if ( (dword_80DBB9C & 0x1000) != 0 )\n    {\n      if ( v2 != 0x8000 )\n        return byte_80D6124[a1 >> 12];\n      result = 42;\n      if ( (a1 & 0x49) == 0 )\n        return byte_80D6124[a1 >> 12];\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80933F8": [
        "0x80933f8",
        "int __usercall sub_80933F8@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebx\n  int v4; // ecx\n  int v5; // esi\n  _BYTE *v6; // esi\n  char v7; // al\n\n  if ( !a1 )\n    return 0;\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = *(_DWORD *)(a1 + 4 * v3);\n    if ( !v5 )\n      break;\n    ++v3;\n    if ( (*(_DWORD *)(v5 + 24) & 0xF000) == 0x4000 )\n    {\n      v6 = *(_BYTE **)v5;\n      if ( a2 != 2 || *v6 != 46 || (v7 = v6[1]) != 0 && (v7 != 46 || v6[2]) )\n        ++v4;\n    }\n  }\n  if ( !a2 )\n    return v3 - v4;\n  return v4;\n}\n"
    ],
    "sub_8093451": [
        "0x8093451",
        "void *__usercall sub_8093451@<eax>(int a1@<eax>)\n{\n  if ( a1 )\n    return sub_804DB2E(4 * a1 + 4);\n  else\n    return 0;\n}\n"
    ],
    "sub_8093464": [
        "0x8093464",
        "int *__usercall sub_8093464@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int *v2; // ebx\n  int v4; // eax\n  _DWORD *v5; // edi\n  int v6; // edx\n  int v7; // ecx\n  _BYTE *v8; // ebp\n  char v9; // al\n\n  v2 = (int *)a1;\n  if ( a1 )\n  {\n    v4 = sub_80933F8(a1, a2);\n    v5 = sub_8093451(v4);\n    v6 = 0;\n    while ( 1 )\n    {\n      v7 = *v2;\n      if ( !*v2 )\n        return v5;\n      if ( (*(_DWORD *)(v7 + 24) & 0xF000) != 0x4000 )\n        break;\n      if ( a2 )\n      {\n        v8 = *(_BYTE **)v7;\n        if ( a2 == 1 )\n          goto LABEL_13;\n        if ( *v8 != 46 )\n          goto LABEL_13;\n        v9 = v8[1];\n        if ( v9 )\n        {\n          if ( v9 != 46 || v8[2] )\n            goto LABEL_13;\n        }\n      }\nLABEL_14:\n      ++v2;\n    }\n    if ( a2 )\n      goto LABEL_14;\nLABEL_13:\n    v5[v6++] = v7;\n    goto LABEL_14;\n  }\n  return v2;\n}\n"
    ],
    "sub_80934CD": [
        "0x80934cd",
        "_DWORD *__usercall sub_80934CD@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  _DWORD *v6; // ebx\n  int v7; // eax\n  int v9; // [esp+10h] [ebp-60h]\n  int v10; // [esp+14h] [ebp-5Ch]\n  int v11; // [esp+18h] [ebp-58h]\n  int v12; // [esp+1Ch] [ebp-54h]\n  unsigned __int64 dev; // [esp+20h] [ebp-50h]\n  int v14; // [esp+2Ch] [ebp-44h]\n  int v15; // [esp+30h] [ebp-40h]\n  int v16; // [esp+38h] [ebp-38h]\n  int v17; // [esp+3Ch] [ebp-34h]\n  int v18; // [esp+40h] [ebp-30h]\n  int v19; // [esp+48h] [ebp-28h]\n  int v20; // [esp+50h] [ebp-20h]\n  int v21; // [esp+58h] [ebp-18h]\n  int v22; // [esp+5Ch] [ebp-14h]\n\n  v6 = sub_804DB2E(0x4Cu);\n  v6[1] = a1;\n  *v6 = a2;\n  if ( !(a3 | dword_80DBB9C & 0x800000) )\n  {\n    if ( !lstat64() )\n    {\n      v6[4] = v9;\n      goto LABEL_7;\n    }\nLABEL_5:\n    sub_804D3F1(a1);\n    BYTE1(qword_80DB778) = 1;\n    free(v6);\n    return 0;\n  }\n  if ( stat64() )\n    goto LABEL_5;\n  v6[5] = v9;\nLABEL_7:\n  v6[6] = v9;\n  v6[7] = v14;\n  v6[8] = v15;\n  v6[9] = v19;\n  v7 = dword_80DBB9C;\n  if ( (dword_80DBB9C & 0x40000) != 0 )\n    v6[9] = v18;\n  if ( (v7 & 0x10000) != 0 )\n    v6[9] = v20;\n  v6[10] = v21;\n  v6[11] = v22;\n  v6[12] = v16;\n  v6[13] = v17;\n  v6[14] = v10;\n  v6[15] = v11;\n  v6[16] = v12;\n  v6[17] = gnu_dev_major(dev);\n  v6[18] = gnu_dev_minor(dev);\n  return v6;\n}\n"
    ],
    "sub_80935D5": [
        "0x80935d5",
        "int __usercall sub_80935D5@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  char *v2; // esi\n  int v3; // ebx\n  _BYTE *v4; // edx\n  char *v5; // edx\n  char v6; // cl\n  _BYTE *v7; // edx\n  unsigned int v8; // edi\n  int v10; // [esp+8h] [ebp-10h]\n\n  v2 = (char *)sub_80B0C58(a2, a1);\n  if ( (dword_80DBB9C & 0x8000) != 0 )\n  {\n    v3 = v10 + 2;\n    v4 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v4 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v4 + 1;\n      *v4 = 34;\n    }\n    while ( 1 )\n    {\n      v6 = *v2;\n      v7 = *(_BYTE **)(_stdout + 16);\n      v8 = *(_DWORD *)(_stdout + 28);\n      if ( !*v2 )\n        break;\n      if ( v6 == 34 || v6 == 92 )\n      {\n        if ( (unsigned int)v7 >= v8 )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(_stdout + 16) = v7 + 1;\n          *v7 = 92;\n        }\n        ++v3;\n      }\n      v5 = *(char **)(_stdout + 16);\n      if ( (unsigned int)v5 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked();\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v5 + 1;\n        *v5 = *v2;\n      }\n      ++v2;\n    }\n    if ( (unsigned int)v7 >= v8 )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v7 + 1;\n      *v7 = 34;\n    }\n  }\n  else\n  {\n    fputs_unlocked();\n    return v10;\n  }\n  return v3;\n}\n"
    ],
    "sub_80936B0": [
        "0x80936b0",
        "void __usercall sub_80936B0(void *a1@<eax>, size_t a2@<edx>)\n{\n  qsort(a1, a2, 4u, sub_80936C2);\n}\n"
    ],
    "sub_80936C2": [
        "0x80936c2",
        "int __cdecl sub_80936C2(int *a1, int *a2)\n{\n  int v2; // ebx\n  int v3; // esi\n  int v4; // edi\n  int result; // eax\n  __int64 v6; // rax\n  const char *v7; // eax\n  const char *v8; // [esp+0h] [ebp-14h]\n\n  v2 = *a1;\n  v3 = *a2;\n  v4 = dword_80DBB9C;\n  if ( (dword_80DBB9C & 0x20000000) != 0 )\n  {\n    result = ((*(_DWORD *)(v3 + 24) & 0xF000) == 0x4000) - ((*(_DWORD *)(v2 + 24) & 0xF000) == 0x4000);\n    if ( ((*(_DWORD *)(v3 + 24) & 0xF000) == 0x4000) != ((*(_DWORD *)(v2 + 24) & 0xF000) == 0x4000) )\n      goto LABEL_15;\n  }\n  if ( (dword_80DBB9C & 0x80000) != 0 )\n  {\n    v6 = *(_QWORD *)(v3 + 28) - *(_QWORD *)(v2 + 28);\n  }\n  else\n  {\n    if ( (dword_80DBB9C & 0x20000) != 0 )\n    {\n      LODWORD(v6) = *(_DWORD *)(v3 + 36) - *(_DWORD *)(v2 + 36);\n    }\n    else if ( (dword_80DBB9C & 0x400000) != 0 )\n    {\n      LODWORD(v6) = strverscmp();\n    }\n    else\n    {\n      if ( (dword_80DBB9C & 0x100000) == 0 )\n      {\nLABEL_13:\n        result = strcmp(*(const char **)v2, *(const char **)v3);\n        goto LABEL_15;\n      }\n      v8 = (const char *)strchrnul();\n      v7 = (const char *)strchrnul();\n      LODWORD(v6) = strcmp(v7, v8);\n    }\n    v6 = (int)v6;\n  }\n  if ( !v6 )\n    goto LABEL_13;\n  result = HIDWORD(v6) | 1;\nLABEL_15:\n  if ( (v4 & 0x200000) != 0 )\n    return -result;\n  return result;\n}\n"
    ],
    "sub_8093791": [
        "0x8093791",
        "int __usercall sub_8093791@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // edx\n  int v4; // ecx\n  int v5; // edi\n  int v6; // ebp\n  int v7; // esi\n  const char *v8; // eax\n  int v9; // ebp\n  int v10; // esi\n  int v11; // eax\n  int v12; // eax\n  int v13; // esi\n  int v14; // ebp\n  int v15; // eax\n  const char *v16; // eax\n  int v17; // esi\n  struct tm *v18; // eax\n  char *v19; // ebp\n  int v20; // ebp\n  int v21; // edx\n  int v22; // eax\n  int v23; // edx\n  int v24; // esi\n  int v25; // edi\n  int v26; // ecx\n  int v27; // ebp\n  int v28; // edx\n  int v29; // eax\n  int v30; // edx\n  char *v31; // edx\n  int v33; // [esp-8h] [ebp-84h]\n  int v34; // [esp-4h] [ebp-80h]\n  void *ptr; // [esp+0h] [ebp-7Ch]\n  char v36; // [esp+7h] [ebp-75h]\n  char s[16]; // [esp+Ch] [ebp-70h] BYREF\n  int v38; // [esp+1Ch] [ebp-60h]\n\n  v2 = *(_DWORD *)(a1 + 24);\n  v36 = sub_80933AF(v2);\n  v5 = dword_80DBB9C;\n  ptr = 0;\n  v6 = dword_80DBB9C & 0x20;\n  if ( (dword_80DBB9C & 0x20) != 0 && (v2 & 0xF000) == 40960 )\n    ptr = sub_804E261(*(const char **)(a1 + 4));\n  v7 = 0;\n  if ( (v5 & 8) != 0 )\n    v7 = printf(\"%7llu \", *(_QWORD *)(a1 + 40));\n  if ( (v5 & 0x100) != 0 )\n    v7 += printf(\"%6llu \", *(__int64 *)(a1 + 48) >> 1);\n  if ( v6 )\n  {\n    v8 = (const char *)sub_80B028A(v4, v3);\n    v9 = printf(\"%-10s \", v8);\n    v10 = printf(\"%4lu \", *(_DWORD *)(a1 + 56)) + v9 + v7;\n    if ( (v5 & 0x80) != 0 )\n    {\n      if ( (v5 & 0x40) != 0 )\n      {\n        v11 = printf(\"%-8u \", *(_DWORD *)(a1 + 64));\nLABEL_15:\n        v13 = v11 + v10;\n        goto LABEL_18;\n      }\n      v12 = printf(\"%-8u %-8u \", *(_DWORD *)(a1 + 60), *(_DWORD *)(a1 + 64));\n    }\n    else\n    {\n      if ( (v5 & 0x40) != 0 )\n      {\n        v34 = sub_80B0E8A();\n        v11 = printf(\"%-8.8s \", v34);\n        goto LABEL_15;\n      }\n      v14 = sub_80B0E8A();\n      v33 = sub_80B0E79();\n      v12 = printf(\"%-8.8s %-8.8s \", v33, v14);\n    }\n    v13 = v12 + v10;\nLABEL_18:\n    if ( (*(_DWORD *)(a1 + 24) & 0xB000) == 0x2000 )\n    {\n      v15 = printf(\"%4u, %3u \", *(_DWORD *)(a1 + 68), *(_DWORD *)(a1 + 72));\n    }\n    else\n    {\n      if ( (v5 & 0x2000000) != 0 )\n      {\n        v16 = (const char *)sub_80AD07E(0);\n        v17 = printf(\"%7s \", v16) + v13;\n        goto LABEL_24;\n      }\n      v15 = printf(\"%9llu \", *(_QWORD *)(a1 + 28));\n    }\n    v17 = v15 + v13;\nLABEL_24:\n    if ( (v5 & 0x10000000) != 0 )\n    {\n      v18 = localtime((const time_t *)(a1 + 36));\n      strftime(s, 0x1Du, \"%Y-%m-%d %H:%M:%S %z\", v18);\n      v7 = printf(\"%s \", s) + v17;\n    }\n    else\n    {\n      v19 = ctime((const time_t *)(a1 + 36));\n      if ( (unsigned int)(unk_80DB780 - *(_DWORD *)(a1 + 36) + 899) > 0xF09D42 )\n      {\n        *strchr(v19 + 20, 10) = 32;\n        printf(\"%.7s%6s\", v19 + 4, v19 + 20);\n      }\n      else\n      {\n        printf(\"%.12s \", v19 + 4);\n      }\n      v7 = v17 + 13;\n    }\n  }\n  if ( (_BYTE)qword_80DB778 )\n  {\n    v20 = *(_DWORD *)(a1 + 16);\n    if ( !v20 && !lstat64() )\n      LOWORD(v20) = v38;\n    v21 = v20 & 0xF000;\n    if ( v21 != 0x8000 || (v22 = 32, (v20 & 0x49) == 0) )\n      v22 = (unsigned __int8)byte_80D6135[(unsigned __int16)v20 >> 12];\n    if ( v21 != 0x8000 || (v23 = 1, (v20 & 0x49) == 0) )\n      v23 = (unsigned __int8)byte_80D6146[(unsigned __int16)v20 >> 12];\n    printf(\"\\x1B[%u;%um\", v23, v22);\n  }\n  v24 = sub_80935D5(*(_DWORD *)a1, v4) + v7;\n  if ( (_BYTE)qword_80DB778 )\n    printf(\"\\x1B[m\");\n  v25 = v5 & 0x3000;\n  if ( ptr )\n  {\n    printf(\" -> \");\n    if ( v25 || (_BYTE)qword_80DB778 )\n    {\n      v27 = *(_DWORD *)(a1 + 20);\n      if ( !v27 && !stat64() )\n        LOWORD(v27) = v38;\n      v36 = sub_80933AF(v27);\n      if ( (_BYTE)qword_80DB778 )\n      {\n        v28 = v27 & 0xF000;\n        if ( v28 != 0x8000 || (v29 = 32, (v27 & 0x49) == 0) )\n          v29 = (unsigned __int8)byte_80D6135[(unsigned __int16)v27 >> 12];\n        if ( v28 != 0x8000 || (v30 = 1, (v27 & 0x49) == 0) )\n          v30 = (unsigned __int8)byte_80D6146[(unsigned __int16)v27 >> 12];\n        printf(\"\\x1B[%u;%um\", v30, v29);\n      }\n    }\n    v24 += sub_80935D5((int)ptr, v26) + 4;\n    free(ptr);\n    if ( (_BYTE)qword_80DB778 )\n      printf(\"\\x1B[m\");\n  }\n  if ( v25 && v36 )\n  {\n    v31 = *(char **)(_stdout + 16);\n    if ( (unsigned int)v31 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v31 + 1;\n      *v31 = v36;\n    }\n    ++v24;\n  }\n  return v24;\n}\n"
    ],
    "sub_8093B52": [
        "0x8093b52",
        "unsigned int __usercall sub_8093B52@<eax>(unsigned int result@<eax>, unsigned int a2@<edx>, int a3@<ecx>)\n{\n  _DWORD **v3; // esi\n  unsigned int v4; // ebx\n  _BYTE *v5; // eax\n  unsigned int v6; // edx\n  unsigned int v7; // ebx\n  int v8; // esi\n  int v9; // ebp\n  unsigned int i; // edi\n  int v11; // edx\n  unsigned int v12; // ecx\n  _BYTE *v13; // edx\n  unsigned int v15; // [esp+4h] [ebp-34h]\n  unsigned int v16; // [esp+8h] [ebp-30h]\n  unsigned int v17; // [esp+Ch] [ebp-2Ch]\n  unsigned int v18; // [esp+10h] [ebp-28h]\n  unsigned int v19; // [esp+14h] [ebp-24h]\n  unsigned int v20; // [esp+18h] [ebp-20h]\n  unsigned int v21; // [esp+24h] [ebp-14h]\n\n  v19 = result;\n  if ( (dword_80DBB9C & 0x30) != 0 )\n  {\n    v8 = a2;\n    v16 = 0;\nLABEL_19:\n    v7 = 1;\n    goto LABEL_20;\n  }\n  v3 = (_DWORD **)result;\n  v4 = 0;\n  while ( *v3 )\n  {\n    v5 = (_BYTE *)sub_80B0C58(a3, **v3);\n    v6 = v21;\n    if ( (dword_80DBB9C & 0x8000) != 0 )\n    {\n      v6 = v21 + 2;\n      while ( 1 )\n      {\n        LOBYTE(a3) = *v5;\n        if ( !*v5 )\n          break;\n        if ( (_BYTE)a3 == 92 || (_BYTE)a3 == 34 )\n          ++v6;\n        ++v5;\n      }\n    }\n    if ( v4 < v6 )\n      v4 = v6;\n    ++v3;\n  }\n  v16 = v4 + ((dword_80DBB9C << 23 >> 31) & 5) + (dword_80DBB9C & 8) + 2;\n  result = HIDWORD(qword_80DB778) / v16;\n  v7 = HIDWORD(qword_80DB778) / v16;\n  if ( HIDWORD(qword_80DB778) / v16 <= 1 )\n  {\n    v8 = a2;\n    goto LABEL_19;\n  }\n  v8 = a2 / v7;\n  result = a2 / v7 * v7;\n  if ( result < a2 )\n    ++v8;\nLABEL_20:\n  v15 = v7;\n  v9 = 0;\n  for ( i = 0; v8 != i; ++i )\n  {\n    v17 = v15 - v7;\n    v18 = i;\n    v11 = 0;\n    do\n    {\n      v12 = v18;\n      if ( (dword_80DBB9C & 0x200) != 0 )\n        v12 = v17;\n      if ( v12 < a2 )\n      {\n        if ( v11 )\n        {\n          v20 = v12;\n          printf(\"%*s\", v9 - v11, &data);\n          v11 = v9;\n          v12 = v20;\n        }\n        v9 = v11 + v16;\n        v11 += sub_8093791(*(_DWORD *)(v19 + 4 * v12));\n      }\n      ++v17;\n      v18 += v8;\n    }\n    while ( v15 != v17 );\n    result = _stdout;\n    v13 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v13 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked();\n      result = 10;\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v13 + 1;\n      *v13 = 10;\n    }\n    v15 += v7;\n  }\n  return result;\n}\n"
    ],
    "sub_8093CC9": [
        "0x8093cc9",
        "void __usercall sub_8093CC9(int a1@<eax>, int a2@<edx>)\n{\n  DIR *v3; // ebp\n  size_t v4; // ebx\n  _DWORD *v5; // esi\n  int v6; // eax\n  int v7; // ecx\n  char *v8; // eax\n  _DWORD *v9; // eax\n  DIR *v10; // eax\n  DIR *v11; // ecx\n  int v12; // ecx\n  int *v13; // ebx\n  int v14; // eax\n  DIR *v15; // ebx\n  int v16; // esi\n  char *ptr; // [esp+0h] [ebp-20h]\n  unsigned __int64 ptra; // [esp+0h] [ebp-20h]\n  const char *v19; // [esp+8h] [ebp-18h]\n\n  while ( *(_DWORD *)a1 )\n  {\n    if ( BYTE2(qword_80DB778) || (dword_80DBB9C & 0x4000) != 0 )\n    {\n      if ( !a2 )\n        sub_804DD98(10);\n      printf(\"%s:\\n\", *(const char **)(*(_DWORD *)a1 + 4));\n      a2 = 0;\n    }\n    v19 = *(const char **)(*(_DWORD *)a1 + 4);\n    v3 = sub_804DF59(v19);\n    if ( v3 )\n    {\n      v4 = 0;\n      v5 = 0;\n      while ( 1 )\n      {\n        v6 = readdir64();\n        if ( !v6 )\n          break;\n        if ( *(_BYTE *)(v6 + 19) != 46\n          || (dword_80DBB9C & 0x402) != 0\n          && ((dword_80DBB9C & 2) != 0 || *(_BYTE *)(v6 + 20) && *(_WORD *)(v6 + 20) != 46) )\n        {\n          ptr = (char *)sub_804D2D1((int)v19, (_BYTE *)(v6 + 19), v7);\n          v8 = sub_804D315(ptr);\n          v9 = sub_80934CD(ptr, (int)v8, 0);\n          if ( v9 )\n          {\n            *((_BYTE *)v9 + 12) = 1;\n            v9[2] = v5;\n            ++v4;\n            v5 = v9;\n          }\n          else\n          {\n            free(ptr);\n          }\n        }\n      }\n      closedir(v3);\n      if ( v5 )\n      {\n        v10 = (DIR *)sub_8093451(v4);\n        v3 = v10;\n        do\n        {\n          *(_DWORD *)v10 = v5;\n          v5 = (_DWORD *)v5[2];\n          v10 = (DIR *)((char *)v10 + 4);\n        }\n        while ( v5 );\n      }\n      else\n      {\n        v4 = 0;\n        v3 = 0;\n      }\n    }\n    else\n    {\n      BYTE1(qword_80DB778) = 1;\n      v4 = 0;\n    }\n    if ( (dword_80DBB9C & 0x120) != 0 )\n    {\n      if ( v3 )\n      {\n        v11 = v3;\n        ptra = 1LL;\n        while ( *(_DWORD *)v11 )\n        {\n          ptra += *(_QWORD *)(*(_DWORD *)v11 + 48);\n          v11 = (DIR *)((char *)v11 + 4);\n        }\n      }\n      else\n      {\n        ptra = 1LL;\n      }\n      printf(\"total %llu\\n\", ptra >> 1);\n    }\n    if ( v4 )\n    {\n      sub_80936B0(v3, v4);\n      sub_8093B52((unsigned int)v3, v4, v12);\n      if ( (dword_80DBB9C & 0x4000) != 0 )\n      {\n        v13 = sub_8093464((int)v3, 2);\n        v14 = sub_80933F8((int)v3, 2);\n        if ( v14 )\n        {\n          sub_80936B0(v13, v14);\n          sub_8093CC9();\n          free(v13);\n        }\n      }\n      v15 = v3;\n      if ( v3 )\n      {\n        while ( 1 )\n        {\n          v16 = *(_DWORD *)v15;\n          if ( !*(_DWORD *)v15 )\n            break;\n          if ( *(_BYTE *)(v16 + 12) )\n            free(*(void **)(v16 + 4));\n          free((void *)v16);\n          v15 = (DIR *)((char *)v15 + 4);\n        }\n        free(v3);\n      }\n    }\n    a1 += 4;\n  }\n}\n"
    ],
    "sub_8093ED1": [
        "0x8093ed1",
        "int __cdecl sub_8093ED1(int a1, int a2)\n{\n  int v2; // edx\n  int v3; // ebx\n  char *v4; // eax\n  int v5; // eax\n  int v6; // eax\n  int v7; // esi\n  size_t v8; // ebx\n  _DWORD *v9; // edi\n  int v10; // ecx\n  _DWORD *v11; // eax\n  _DWORD *v12; // eax\n  void *v13; // ebp\n  int v14; // ecx\n  int *v15; // esi\n  int *v16; // edi\n  int v17; // ebp\n  size_t v18; // ebx\n  int v19; // ecx\n  const char *v21; // [esp+0h] [ebp-14h] BYREF\n\n  v21 = \"always\";\n  memset(&qword_80DB778, 0, 0xCu);\n  HIDWORD(qword_80DB778) = 80;\n  time(&unk_80DB780);\n  HIDWORD(qword_80DB778) = sub_804D986(0, v2) - 1;\n  v3 = sub_80ABEC2(a2, \"^Cadi1lgnsxAkFpRQctuSXrvLHhT:w:\", \"full-time\", 0, (char *)&qword_80DB778 + 4, &v21);\n  if ( isatty(1) )\n  {\n    v4 = getenv(\"LS_COLORS\");\n    if ( !v4 || *v4 && strcmp(v4, \"none\") )\n      LOBYTE(qword_80DB778) = 1;\n  }\n  if ( (v3 & 0x40000000) != 0 )\n  {\n    if ( *v21 == 110 )\n    {\n      LOBYTE(qword_80DB778) = 0;\n    }\n    else\n    {\n      v5 = sub_804D254(\"always\", v21);\n      if ( v5 >= 0 && (v5 <= 2 || v5 <= 5 && isatty(1)) )\n        LOBYTE(qword_80DB778) = 1;\n    }\n  }\n  v6 = dword_80DBB9C;\n  if ( (v3 & 4) != 0 )\n  {\n    BYTE1(v6) = BYTE1(dword_80DBB9C) & 0xBF;\n    dword_80DBB9C = v6;\n  }\n  if ( (v3 & 0x20) == 0 && (v3 & 0x50000) != 0 )\n    dword_80DBB9C |= 0x20000u;\n  if ( (dword_80DBB9C & 0x231) == 0 )\n    dword_80DBB9C |= isatty(1) == 0 ? 16 : 1;\n  v7 = a2 + 4 * optind;\n  if ( !*(_DWORD *)v7 )\n  {\n    *(_DWORD *)(v7 - 4) = 135072092;\n    v7 -= 4;\n  }\n  if ( *(_DWORD *)(v7 + 4) )\n    BYTE2(qword_80DB778) = 1;\n  v8 = 0;\n  v9 = 0;\n  do\n  {\n    v10 = 1;\n    if ( (dword_80DBB9C & 0x1120) != 0 )\n      v10 = HIBYTE(dword_80DBB9C) & 1;\n    v11 = sub_80934CD(*(const char **)v7, *(_DWORD *)v7, v10);\n    v7 += 4;\n    if ( v11 )\n    {\n      v11[2] = v9;\n      ++v8;\n      v9 = v11;\n    }\n  }\n  while ( *(_DWORD *)v7 );\n  if ( v8 )\n  {\n    v12 = sub_8093451(v8);\n    v13 = v12;\n    do\n    {\n      *v12 = v9;\n      v9 = (_DWORD *)v9[2];\n      ++v12;\n    }\n    while ( v9 );\n    if ( (dword_80DBB9C & 4) != 0 )\n    {\n      sub_80936B0(v13, v8);\n      sub_8093B52((unsigned int)v13, v8, v14);\n    }\n    else\n    {\n      v15 = sub_8093464((int)v13, 1);\n      v16 = sub_8093464((int)v13, 0);\n      v17 = sub_80933F8((int)v13, 1);\n      v18 = v8 - v17;\n      if ( v18 )\n      {\n        sub_80936B0(v16, v18);\n        sub_8093B52((unsigned int)v16, v18, v19);\n      }\n      if ( v17 )\n      {\n        sub_80936B0(v15, v17);\n        sub_8093CC9((int)v15, v18 == 0);\n      }\n    }\n  }\n  return SBYTE1(qword_80DB778);\n}\n"
    ],
    "sub_80940F8": [
        "0x80940f8",
        "void *__usercall sub_80940F8@<eax>(const char *a1@<eax>, unsigned int a2@<edx>)\n{\n  int v3; // eax\n  int v4; // ebp\n  char v5; // al\n  void (*v6)(void); // esi\n  int (*v7)(); // edi\n  int v8; // ebx\n  ssize_t v9; // eax\n  void *v10; // esi\n  void *ptr; // [esp+0h] [ebp-E8h]\n\n  v3 = sub_80B3DAA();\n  if ( v3 < 0 )\n    return 0;\n  v4 = v3;\n  v5 = ident[3];\n  switch ( v5 )\n  {\n    case 's':\n      sub_80ACCF3();\n      v6 = (void (*)(void))sub_80ACD79;\n      v7 = (int (*)())sub_80ACD25;\n      v8 = 16;\n      break;\n    case '1':\n      sub_80ACD9C();\n      v6 = (void (*)(void))sub_80ACEAA;\n      v7 = (int (*)())sub_80ACD25;\n      v8 = 20;\n      break;\n    case '2':\n      sub_80ACDD5();\n      v6 = (void (*)(void))sub_80ACEAA;\n      v7 = (int (*)())sub_80ACD25;\n      v8 = 32;\n      break;\n    case '5':\n      sub_80ACDF2();\n      v6 = (void (*)(void))sub_80ACEEC;\n      v7 = sub_80ACE29;\n      v8 = 64;\n      break;\n    case '3':\n      sub_80ACFB1();\n      if ( a2 - 1 > 0x31E || (a2 & 0x1F) != 0 )\n        sub_804D5E0(\"bad -a%u\", a2);\n      v8 = a2 >> 3;\n      v6 = (void (*)(void))sub_80AD028;\n      v7 = (int (*)())&sub_80ACFCB;\n      break;\n    default:\n      sub_804D604();\n  }\n  for ( ptr = sub_804DAFA(0x1000u); ; ((void (__fastcall *)(ssize_t, void *))v7)(v9, ptr) )\n  {\n    v9 = sub_804E5BC(0x1000u, ptr, v4);\n    if ( v9 <= 0 )\n      break;\n  }\n  if ( v9 )\n  {\n    sub_804D3A5((int)\"can't read '%s'\", a1);\n    v10 = 0;\n  }\n  else\n  {\n    v6();\n    v10 = sub_804DB2E(2 * v8 + 1);\n    sub_804D727((int)v10, (int)ptr, v8);\n  }\n  free(ptr);\n  if ( v4 )\n    close(v4);\n  return v10;\n}\n"
    ],
    "sub_8094272": [
        "0x8094272",
        "int __cdecl sub_8094272(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // ebp\n  int v4; // esi\n  const char *v5; // eax\n  char *v6; // edi\n  char *v7; // eax\n  int v8; // edx\n  int v9; // eax\n  const char *v10; // eax\n  char *v11; // esi\n  char v13; // [esp+0h] [ebp-2Ch]\n  int i; // [esp+4h] [ebp-28h]\n  const char *v15; // [esp+8h] [ebp-24h]\n  char *s1; // [esp+Ch] [ebp-20h]\n  unsigned int v17[5]; // [esp+18h] [ebp-14h] BYREF\n\n  v17[0] = 224;\n  if ( ident[3] == 51 )\n    v13 = sub_80ABEAC(a2, \"^scwbta:+\", v17);\n  else\n    v13 = sub_80ABEAC(a2, \"^scwbt\");\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( !*v2 )\n    *--v2 = \"-\";\n  v3 = 0;\n  do\n  {\n    if ( (v13 & 2) != 0 )\n    {\n      sub_80B3D9B();\n      v4 = 0;\n      for ( i = 0; ; ++i )\n      {\n        v5 = (const char *)sub_80AB85A();\n        v6 = (char *)v5;\n        if ( !v5 )\n          break;\n        v7 = strstr(v5, \"  \");\n        if ( v7 || (v7 = strstr(v6, \" *\")) != 0 )\n        {\n          *v7 = 0;\n          v15 = v7 + 2;\n          s1 = (char *)sub_80940F8(v7 + 2, v17[0]);\n          v8 = v13 & 1;\n          if ( !s1 || (v9 = strcmp(s1, v6), v8 = v13 & 1, v9) )\n          {\n            if ( !v8 )\n              printf(\"%s: FAILED\\n\", v15);\n            ++v4;\n            v3 = 1;\n          }\n          else if ( (v13 & 1) == 0 )\n          {\n            printf(\"%s: OK\\n\", v15);\n          }\n          free(s1);\n          free(v6);\n        }\n        else\n        {\n          if ( (v13 & 4) != 0 )\n            sub_804D5F4(\"invalid format\");\n          ++v4;\n          free(v6);\n          v3 = 1;\n        }\n      }\n      if ( v4 && (v13 & 1) == 0 )\n        sub_804D5F4(\"WARNING: %d of %d computed checksums did NOT match\", v4, i);\n      if ( !i )\n      {\n        sub_804D5F4(\"%s: no checksum lines found\", *v2);\n        v3 = 1;\n      }\n      sub_80AB218();\n    }\n    else\n    {\n      v10 = (const char *)sub_80940F8(*v2, v17[0]);\n      v11 = (char *)v10;\n      if ( v10 )\n      {\n        printf(\"%s  %s\\n\", v10, *v2);\n        free(v11);\n      }\n      else\n      {\n        v3 = 1;\n      }\n    }\n    ++v2;\n  }\n  while ( *v2 );\n  return v3;\n}\n"
    ],
    "sub_809444D": [
        "0x809444d",
        "int __cdecl sub_809444D(int a1, int a2)\n{\n  const char *v2; // ecx\n  char v3; // bl\n  int v4; // edi\n  int v5; // esi\n  _DWORD *v6; // ebx\n  int v7; // ebp\n  const char *v9; // [esp+0h] [ebp-14h] BYREF\n\n  v9 = v2;\n  v3 = sub_80ABEC2(a2, \"m:pv\", \"mode\", &v9);\n  if ( (v3 & 1) != 0 )\n  {\n    v4 = sub_80B07AF();\n    if ( v4 == -1 )\n      sub_804D5E0(\"invalid mode '%s'\", v9);\n  }\n  else\n  {\n    v4 = -1;\n  }\n  v5 = (2 * v3) & 4;\n  if ( (v3 & 4) != 0 )\n    v5 |= 0x1000u;\n  v6 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v6 )\n    sub_804CDC2();\n  v7 = 0;\n  do\n  {\n    if ( sub_80B00B9(v5, v4) )\n      v7 = 1;\n    ++v6;\n  }\n  while ( *v6 );\n  return v7;\n}\n"
    ],
    "sub_80944DE": [
        "0x80944de",
        "int __cdecl sub_80944DE(int a1, int a2)\n{\n  __mode_t v2; // edi\n  const char **v3; // ebx\n  int v4; // esi\n\n  v2 = sub_809A5BA();\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( !*v3 )\n    sub_804CDC2();\n  v4 = 0;\n  do\n  {\n    if ( mkfifo(*v3, v2) < 0 )\n    {\n      sub_804D3F1(*v3);\n      v4 = 1;\n    }\n    ++v3;\n  }\n  while ( *v3 );\n  return v4;\n}\n"
    ],
    "sub_809452A": [
        "0x809452a",
        "int __cdecl sub_809452A(int a1, int a2)\n{\n  int v2; // esi\n  int v3; // ebx\n  unsigned __int8 *v4; // eax\n  char *v5; // eax\n  int v6; // esi\n  int v7; // ecx\n  unsigned int v8; // eax\n  int v9; // edi\n  unsigned int v10; // eax\n  int v11; // ecx\n  __dev_t v12; // rax\n\n  v2 = sub_809A5BA();\n  v3 = a2 + 4 * optind;\n  if ( !*(_DWORD *)v3 )\n    goto LABEL_3;\n  v4 = *(unsigned __int8 **)(v3 + 4);\n  if ( !v4 )\n    goto LABEL_3;\n  v5 = strchr(\"pcub\", *v4);\n  if ( !v5 )\n    goto LABEL_3;\n  v6 = dword_80B7F40[(unsigned __int8)v5[4]] | v2;\n  v7 = *(_DWORD *)(v3 + 8);\n  if ( *v5 != 112 )\n  {\n    if ( v7 && *(_DWORD *)(v3 + 12) )\n    {\n      v8 = gnu_dev_minor(0xFFFFFFFFuLL);\n      v9 = sub_80B40CC(v8, 0);\n      v10 = gnu_dev_major(0xFFFFFFFFuLL);\n      sub_80B40CC(v10, 0);\n      v12 = sub_80B0220(v11, v9);\n      v7 = *(_DWORD *)(v3 + 16);\n      goto LABEL_10;\n    }\nLABEL_3:\n    sub_804CDC2();\n  }\n  v12 = 0LL;\nLABEL_10:\n  if ( v7 )\n    goto LABEL_3;\n  if ( mknod(*(const char **)v3, v6, v12) )\n    sub_804D3FF(*(const char **)v3);\n  return 0;\n}\n"
    ],
    "sub_80945E6": [
        "0x80945e6",
        "int __cdecl sub_80945E6(int a1, int a2)\n{\n  char *v2; // eax\n  int v3; // ecx\n  char v4; // si\n  char *v5; // ebx\n  char *v6; // edx\n  int v7; // ecx\n  bool v8; // zf\n  char *v9; // eax\n  int v10; // eax\n  int v12; // [esp-4h] [ebp-10h]\n  const char *v13; // [esp+0h] [ebp-Ch] BYREF\n\n  v2 = getenv(\"TMPDIR\");\n  v13 = v2;\n  if ( !v2 || !*v2 )\n    v13 = \"/tmp\";\n  v4 = sub_80ABEAC(a2, \"^dqtp:u\", &v13);\n  v5 = *(char **)(a2 + 4 * optind);\n  if ( !v5 )\n  {\n    v5 = sub_804DB46(\"tmp.XXXXXX\");\n    v4 |= 4u;\n  }\n  if ( (v4 & 0xC) != 0 )\n    v5 = (char *)sub_804D2D1((int)v13, v5, v3);\n  if ( (v4 & 0x10) != 0 )\n  {\n    v5 = mktemp(v5);\n    v8 = *v5 == 0;\n    goto LABEL_12;\n  }\n  if ( (v4 & 1) != 0 )\n  {\n    v9 = mkdtemp(v5);\n    v7 = v12;\n    v8 = v9 == 0;\nLABEL_12:\n    if ( !v8 )\n      goto LABEL_15;\n    goto LABEL_16;\n  }\n  v10 = mkstemp64();\n  v6 = v5;\n  if ( v10 >= 0 )\n  {\nLABEL_15:\n    puts(v5);\n    return 0;\n  }\nLABEL_16:\n  if ( (v4 & 2) == 0 )\n    sub_80B0A23(v7, v6);\n  return 1;\n}\n"
    ],
    "sub_80946A0": [
        "0x80946a0",
        "int __cdecl sub_80946A0(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // ecx\n  int v4; // eax\n  int v5; // edi\n  int v6; // ebp\n  char *v7; // esi\n  char *v8; // eax\n  int v9; // ecx\n  int v10; // eax\n  char *newa; // [esp+0h] [ebp-D8h]\n  char v13; // [esp+4h] [ebp-D4h]\n  char v14[112]; // [esp+68h] [ebp-70h] BYREF\n\n  v13 = sub_80ABEC2(a2, \"^finv\", \"interactive\");\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = (int)v2[a1 - optind - 1];\n  newa = (char *)v3;\n  if ( a1 - optind != 2 )\n  {\nLABEL_4:\n    v6 = 0;\n    while ( 1 )\n    {\n      v8 = sub_804D34F(*v2, v3);\n      v7 = (char *)sub_804D2D1((int)newa, v8, v9);\n      v5 = sub_809A5B0();\n      if ( v5 < 0 )\n        goto LABEL_38;\nLABEL_6:\n      if ( v5 )\n      {\n        if ( (v13 & 4) != 0 )\n          goto LABEL_8;\n        if ( (v13 & 1) == 0 && (access(v7, 2) < 0 && isatty(0) || (v13 & 2) != 0) )\n        {\n          if ( fprintf(stderr, \"mv: overwrite '%s'? \", v7) < 0 )\n            goto LABEL_38;\n          if ( !sub_80A96FD() )\n            goto LABEL_8;\n        }\n      }\n      if ( rename(*v2, v7) >= 0 )\n        goto LABEL_8;\n      if ( *(_DWORD *)dword_80DBB7C != 18 )\n        break;\n      v10 = sub_809A567(lstat64, v14);\n      if ( v10 <= 0 )\n        break;\n      if ( v5 )\n      {\n        if ( v5 == 3 )\n        {\n          if ( v10 != 3 )\n          {\n            sub_804D5F4(\"can't overwrite %sdirectory with %sdirectory\", &data, \"non-\");\n            goto LABEL_38;\n          }\n        }\n        else if ( v10 == 3 )\n        {\n          sub_804D5F4(\"can't overwrite %sdirectory with %sdirectory\", \"non-\", &data);\n          goto LABEL_38;\n        }\n        if ( unlink(v7) < 0 )\n        {\n          sub_804D3A5((int)\"can't remove '%s'\", v7);\n          goto LABEL_38;\n        }\n      }\n      if ( sub_80A9C77(5) < 0 || sub_80B2709() < 0 )\n        goto LABEL_38;\nLABEL_8:\n      if ( (v13 & 8) != 0 )\n        printf(\"'%s' -> '%s'\\n\", *v2, v7);\n      if ( v7 != newa )\n        free(v7);\n      v3 = (int)newa;\n      if ( v2[1] == newa )\n        return v6;\n      ++v2;\n    }\n    sub_804D3A5((int)\"can't rename '%s'\", *v2);\nLABEL_38:\n    v6 = 1;\n    goto LABEL_8;\n  }\n  v4 = sub_809A5B0();\n  v5 = v4;\n  v6 = 1;\n  if ( v4 >= 0 )\n  {\n    v6 = v4 & 2;\n    if ( (v4 & 2) == 0 )\n    {\n      v7 = newa;\n      goto LABEL_6;\n    }\n    goto LABEL_4;\n  }\n  return v6;\n}\n"
    ],
    "sub_809489A": [
        "0x809489a",
        "void __cdecl __noreturn sub_809489A(int a1, int a2)\n{\n  int v2; // esi\n  _BYTE *v3; // edx\n  int v4; // ebx\n  _BYTE *v5; // eax\n  int v6; // eax\n  int v7; // esi\n  int v8; // [esp-8h] [ebp-14h]\n  int v9; // [esp-4h] [ebp-10h]\n  int v10; // [esp+0h] [ebp-Ch]\n  int v11; // [esp+4h] [ebp-8h]\n  int v12; // [esp+8h] [ebp-4h]\n\n  v2 = getpriority(0, 0);\n  v3 = *(_BYTE **)(a2 + 4);\n  if ( !v3 )\n  {\n    printf(\"%d\\n\", v2);\n    sub_80AB247(v8, v9);\n  }\n  v4 = a2 + 4;\n  if ( *v3 != 45 )\n  {\n    v6 = 10;\n    goto LABEL_12;\n  }\n  v5 = v3 + 1;\n  if ( v3[1] == 110 )\n  {\n    if ( v3[2] )\n    {\nLABEL_8:\n      if ( !*(_DWORD *)(v4 + 4) )\nLABEL_9:\n        sub_804CDC2();\n      v6 = sub_80B4160(0x3FFFFFFF, -1073741824);\nLABEL_12:\n      v7 = v6 + v2;\n      if ( setpriority(0, 0, v7) < 0 )\n        sub_804D3C9((int)\"setpriority(%d)\", v7);\n      sub_80AB1EC(v10, v11, v12);\n    }\n    v4 = a2 + 8;\n    v5 = *(_BYTE **)(a2 + 8);\n  }\n  if ( !v5 )\n    goto LABEL_9;\n  goto LABEL_8;\n}\n"
    ],
    "sub_8094934": [
        "0x8094934",
        "void __cdecl __noreturn sub_8094934(int a1, int a2)\n{\n  size_t v2; // eax\n  _DWORD *v3; // ebx\n  char *v4; // [esp+4h] [ebp-24h] BYREF\n  int v5; // [esp+8h] [ebp-20h] BYREF\n  int v6; // [esp+Ch] [ebp-1Ch] BYREF\n  int v7; // [esp+10h] [ebp-18h] BYREF\n  char *v8[2]; // [esp+14h] [ebp-14h] BYREF\n  bool s; // [esp+1Ch] [ebp-Ch]\n  bool s_1; // [esp+1Dh] [ebp-Bh]\n\n  v4 = \"t\";\n  v5 = 6;\n  v6 = 1;\n  v7 = 1;\n  v8[0] = (_BYTE *)(\"Capabilities:\\n\\t\" + 14);\n  sub_80ABEC2(a2, \"pw:+s:v:+i:+b:\", \"body-numbering\", &v5, v8, &v6, &v7, &v4);\n  s = *v4 == 97;\n  s_1 = *v4 == 116;\n  v2 = strlen(v8[0]);\n  v8[1] = sub_804DDBF((char *)\"%*s\\n\", v5 + v2, &data);\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v3 )\n    *--v3 = \"-\";\n  do\n  {\n    sub_80B0B1C((int)&v5);\n    ++v3;\n  }\n  while ( *v3 );\n  sub_80AB247(v4, v5);\n}\n"
    ],
    "sub_80949F5": [
        "0x80949f5",
        "void __cdecl __noreturn sub_80949F5(int a1, int a2)\n{\n  const char *v2; // esi\n  char *v3; // eax\n  int v4; // ecx\n  int v5; // [esp-8h] [ebp-10h]\n  int v6; // [esp-4h] [ebp-Ch]\n  int v7; // [esp+0h] [ebp-8h]\n\n  byte_80DB560 = 127;\n  if ( !*(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  if ( isatty(0) )\n  {\n    close(0);\n    sub_804DBE1(\"/dev/null\");\n  }\n  if ( isatty(1) )\n  {\n    close(1);\n    v2 = \"nohup.out\";\n    if ( open64() < 0 )\n    {\n      v3 = getenv(\"HOME\");\n      if ( v3 )\n      {\n        v2 = (const char *)sub_804D2D1((int)v3, \"nohup.out\", v4);\n        sub_804DBC2(v2);\n      }\n      else\n      {\n        sub_804DBE1(\"/dev/null\");\n      }\n    }\n    sub_804D5F4(\"appending output to %s\", v2);\n  }\n  if ( isatty(2) )\n    dup2(1, 2);\n  signal(1, (__sighandler_t)1);\n  sub_80AB1EC(v5, v6, v7);\n}\n"
    ],
    "sub_8094ACA": [
        "0x8094aca",
        "int sub_8094ACA()\n{\n  int v0; // eax\n  int v1; // edx\n  unsigned int i; // ecx\n  int v4[1025]; // [esp+0h] [ebp-1004h]\n\n  v0 = sched_getaffinity();\n  v1 = 1;\n  if ( !v0 )\n  {\n    v1 = 0;\n    do\n    {\n      for ( i = v4[v0]; i; i >>= 1 )\n        v1 += (i & 1) != 0;\n      ++v0;\n    }\n    while ( v0 != 1024 );\n    if ( !v1 )\n      v1 = 1;\n  }\n  printf(\"%u\\n\", v1);\n  return 0;\n}\n"
    ],
    "nullsub_8": [
        "0x8094b27",
        "void nullsub_8()\n{\n  ;\n}\n"
    ],
    "sub_8094B28": [
        "0x8094b28",
        "int sub_8094B28()\n{\n  int v0; // edi\n  int i; // ebp\n  int v2; // eax\n  unsigned int v3; // esi\n  unsigned int v4; // ecx\n  int v5; // edx\n\n  v0 = 1;\n  for ( i = 0; unk_80DB780 != i; ++i )\n  {\n    v2 = *(_DWORD *)(*(&unk_80DB780 + 1) + 24 * i + 4);\n    v3 = byte_80D67C7[v2];\n    v4 = v0;\n    while ( v3 )\n    {\n      v5 = v4 % v3;\n      v4 = v3;\n      v3 = v5;\n    }\n    if ( v4 )\n      v4 = v0 * byte_80D67C7[v2] / v4;\n    v0 = v4;\n  }\n  return v0;\n}\n"
    ],
    "sub_8094B84": [
        "0x8094b84",
        "_BOOL4 __usercall sub_8094B84@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // ebx\n  _BOOL4 result; // eax\n  char *v5; // eax\n  char *v6; // edi\n  int v7; // edx\n  char v8; // [esp+1h] [ebp-Dh]\n\n  v2 = a1;\n  if ( *a1 == 43 )\n    v2 = a1 + 1;\n  result = 0;\n  if ( (unsigned __int8)(*v2 - 48) <= 9u )\n  {\n    v8 = *v2;\n    v5 = strchr(v2, 46);\n    v6 = v5;\n    if ( v5 )\n    {\n      *v5 = 0;\n      v7 = 10;\n    }\n    else\n    {\n      v7 = 8;\n      if ( v8 == 48 )\n        v7 = 8 * ((v2[1] & 0xDF) == 88) + 8;\n    }\n    *(_QWORD *)a2 = sub_80B3F3E(&unk_80B7FD4, v7);\n    if ( v6 )\n      *v6 = 46;\n    return *(_DWORD *)(a2 + 4) >= 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8094C03": [
        "0x8094c03",
        "int __cdecl sub_8094C03(char *format, int a2, char a3)\n{\n  LOBYTE(qword_80DB7A8) = a3;\n  return printf((_BYTE *)&pmatch[0].rm_so + 2, format, a2);\n}\n"
    ],
    "sub_8094CD6": [
        "0x8094cd6",
        "unsigned int __cdecl sub_8094CD6(unsigned int a1, _DWORD *a2, char *format)\n{\n  unsigned int result; // eax\n  unsigned int v5; // ebx\n\n  result = a1 / 0xC;\n  v5 = a1 / 0xC;\n  while ( --v5 != -1 )\n  {\n    result = printf(format, *a2, a2[1], a2[2]);\n    a2 += 3;\n  }\n  return result;\n}\n"
    ],
    "sub_8094D0D": [
        "0x8094d0d",
        "int __cdecl sub_8094D0D(int a1, _DWORD *a2, const char *a3)\n{\n  _DWORD *v3; // esi\n  const char *v4; // edi\n  _DWORD *v5; // ebx\n  int result; // eax\n  int *v7; // [esp-4h] [ebp-10h]\n\n  v7 = &a1;\n  v3 = a2;\n  v4 = a3;\n  v5 = (_DWORD *)((char *)a2 + (a1 & 0xFFFFFFF8));\n  while ( v3 != v5 )\n  {\n    result = printf(v4, *v3, v3[1], v7);\n    v3 += 2;\n  }\n  return result;\n}\n"
    ],
    "sub_8094D4E": [
        "0x8094d4e",
        "int __cdecl sub_8094D4E(int a1, float *a2, const char *a3)\n{\n  float *v3; // esi\n  const char *v4; // edi\n  float *v5; // ebx\n  int result; // eax\n  int *v7; // [esp+8h] [ebp-10h]\n\n  v7 = &a1;\n  v3 = a2;\n  v4 = a3;\n  v5 = (float *)((char *)a2 + (a1 & 0xFFFFFFFC));\n  while ( v3 != v5 )\n    result = printf(v4, *v3++, v7);\n  return result;\n}\n"
    ],
    "sub_8094D91": [
        "0x8094d91",
        "int __cdecl sub_8094D91(int a1, _DWORD *a2, char *format)\n{\n  _DWORD *i; // esi\n  int result; // eax\n\n  for ( i = a2; i != (_DWORD *)((char *)a2 + (a1 & 0xFFFFFFF8)); i += 2 )\n    result = printf(format, *i, i[1]);\n  return result;\n}\n"
    ],
    "sub_8094DBD": [
        "0x8094dbd",
        "__int64 __cdecl sub_8094DBD(int a1, _DWORD *a2, char *format)\n{\n  _DWORD *i; // esi\n  __int64 result; // rax\n  __int64 v5; // [esp-8h] [ebp-10h]\n\n  for ( i = a2; i != (_DWORD *)((char *)a2 + (a1 & 0xFFFFFFFC)); ++i )\n  {\n    printf(format, *i);\n    result = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_8094DE5": [
        "0x8094de5",
        "__int64 __cdecl sub_8094DE5(int a1, unsigned __int16 *a2, char *format)\n{\n  unsigned __int16 *i; // esi\n  __int64 result; // rax\n  __int64 v5; // [esp-8h] [ebp-10h]\n\n  for ( i = a2; i != (unsigned __int16 *)((char *)a2 + (a1 & 0xFFFFFFFE)); ++i )\n  {\n    printf(format, *i);\n    result = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_8094E0F": [
        "0x8094e0f",
        "__int64 __cdecl sub_8094E0F(int a1, __int16 *a2, char *format)\n{\n  __int16 *i; // esi\n  __int64 result; // rax\n  __int64 v5; // [esp-8h] [ebp-10h]\n\n  for ( i = a2; i != (__int16 *)((char *)a2 + (a1 & 0xFFFFFFFE)); ++i )\n  {\n    printf(format, *i);\n    result = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_8094E39": [
        "0x8094e39",
        "__int64 __cdecl sub_8094E39(int a1, unsigned __int8 *a2, char *format)\n{\n  unsigned __int8 *i; // ebx\n  __int64 result; // rax\n  __int64 v5; // [esp-8h] [ebp-10h]\n\n  for ( i = a2; i != &a2[a1]; ++i )\n  {\n    printf(format, *i);\n    result = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_8094E5E": [
        "0x8094e5e",
        "__int64 __cdecl sub_8094E5E(int a1, char *a2, char *format)\n{\n  char *i; // ebx\n  __int64 result; // rax\n  __int64 v5; // [esp-8h] [ebp-10h]\n\n  for ( i = a2; i != &a2[a1]; ++i )\n  {\n    printf(format, *i);\n    result = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_8094E83": [
        "0x8094e83",
        "void __cdecl sub_8094E83(int a1, unsigned __int8 *a2)\n{\n  unsigned __int8 *v2; // ebx\n  unsigned int v3; // edx\n  char v4; // al\n  char v5[28]; // [esp+4h] [ebp-1Ch] BYREF\n\n  v2 = a2;\n  qmemcpy(v5, \"   x\", 0xBu);\n  v5[11] = 0;\n  while ( &a2[a1] != v2 )\n  {\n    v3 = *v2++;\n    v4 = *(v2 - 1);\n    if ( v3 - 32 > 0x5E )\n    {\n      switch ( (char)v3 )\n      {\n        case 0:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n          break;\n        default:\n          v5[6] = (*(v2 - 1) >> 6) + 48;\n          v5[7] = ((v3 >> 3) & 7) + 48;\n          v5[8] = (v4 & 7) + 48;\n          break;\n      }\n    }\n    else\n    {\n      v5[3] = *(v2 - 1);\n    }\n    fputs_unlocked();\n  }\n}\n"
    ],
    "sub_8094F5A": [
        "0x8094f5a",
        "char *__cdecl sub_8094F5A(int a1, _BYTE *a2)\n{\n  _BYTE *v2; // ebx\n  unsigned __int8 v3; // dl\n  char *v4; // edx\n  char *result; // eax\n  char *v6; // [esp-8h] [ebp-20h]\n  char v7[24]; // [esp+0h] [ebp-18h] BYREF\n\n  v2 = a2;\n  qmemcpy(v7, \"   x\", 0xBu);\n  v7[11] = 0;\n  while ( &a2[a1] != v2 )\n  {\n    v3 = *v2++ & 0x7F;\n    if ( v3 == 127 )\n    {\n      v6 = \" del\";\n    }\n    else if ( v3 <= 0x20u )\n    {\n      v4 = &byte_80D66CA[3 * v3];\n      v7[6] = *v4;\n      v7[7] = v4[1];\n      v7[8] = v4[2];\n      v6 = &v7[5];\n    }\n    else\n    {\n      v7[3] = *(v2 - 1) & 0x7F;\n      v6 = v7;\n    }\n    fputs_unlocked();\n    result = v6;\n  }\n  return result;\n}\n"
    ],
    "sub_8094FE4": [
        "0x8094fe4",
        "char *__usercall sub_8094FE4@<eax>(const char *a1@<eax>, unsigned __int8 *a2@<edx>, int *a3@<ecx>)\n{\n  int v4; // edi\n  unsigned __int8 v5; // al\n  const char *v6; // ebx\n  char *v7; // esi\n  int v8; // ebp\n  int (*v9)(); // edx\n  char *v10; // eax\n  int v11; // edi\n  char *v12; // eax\n  unsigned int v13; // ecx\n  int v14; // ebx\n  int v15; // eax\n  char *v16; // ecx\n  char *v17; // edx\n  char *v18; // eax\n  unsigned int v19; // eax\n  bool v20; // zf\n  unsigned __int8 v23; // [esp+7h] [ebp-19h]\n  char v24; // [esp+7h] [ebp-19h]\n  unsigned __int8 v25; // [esp+7h] [ebp-19h]\n  unsigned int v27; // [esp+8h] [ebp-18h]\n  char *v29[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v4 = *a2;\n  v5 = *a2;\n  v6 = (const char *)(a2 + 1);\n  if ( *a2 == 102 )\n  {\n    v7 = (char *)(a2 + 1);\n    v25 = a2[1];\n    v18 = strchr(\"FDL\", v25);\n    if ( v18 && *v18 )\n    {\n      v19 = (unsigned __int8)byte_80D672D[v18 - \"FDL\"];\n      v7 = (char *)(a2 + 2);\n    }\n    else if ( (unsigned __int8)(v25 - 48) > 9u )\n    {\n      v19 = 8;\n    }\n    else\n    {\n      v19 = sub_804ED6C(0, v6, v29, (int)v6);\n      if ( *(_DWORD *)dword_80DBB7C == 34 || v19 > 0xC || !byte_80D67B1[v19] )\n        sub_804D5E0(\"invalid type string '%s'; %u-byte %s type is not supported\", a1, v19, \"floating point\");\n      v7 = v29[0];\n    }\n    v14 = (unsigned __int8)byte_80D67B1[v19];\n    if ( (_BYTE)v14 == 6 )\n    {\n      v10 = sub_804DDBF(\" %%%d.%de\", 15, 7);\n      v8 = 15;\n      v9 = (int (*)())sub_8094D4E;\n      v11 = 4;\n      v14 = 6;\n    }\n    else if ( (_BYTE)v14 == 7 )\n    {\n      v10 = sub_804DDBF(\" %%%d.%de\", 23, 15);\n      v8 = 23;\n      v9 = sub_8094D0D;\n      v11 = 4;\n      v14 = 7;\n    }\n    else\n    {\n      v10 = sub_804DDBF(\" %%%d.%dLe\", 23, 15);\n      v8 = 23;\n      v9 = (int (*)())sub_8094CD6;\n      v11 = 4;\n    }\n  }\n  else\n  {\n    if ( v5 > 0x66u )\n    {\n      if ( v5 != 117 && v5 != 120 && v5 != 111 )\n        goto LABEL_51;\n    }\n    else\n    {\n      if ( v5 == 99 )\n      {\n        v7 = (char *)(a2 + 1);\n        v8 = 3;\n        v9 = (int (*)())sub_8094E83;\n        v10 = 0;\n        v11 = 6;\n        goto LABEL_50;\n      }\n      if ( v5 != 100 )\n      {\n        if ( v5 == 97 )\n        {\n          v7 = (char *)(a2 + 1);\n          v8 = 3;\n          v9 = (int (*)())sub_8094F5A;\n          v10 = 0;\n          v11 = 5;\nLABEL_50:\n          v14 = 1;\n          goto LABEL_54;\n        }\nLABEL_51:\n        sub_804D5E0(\"invalid character '%c' in type string '%s'\", v4, a1);\n      }\n    }\n    v7 = (char *)(a2 + 1);\n    v23 = a2[1];\n    v12 = strchr(\"CSIL\", v23);\n    if ( v12 && *v12 )\n    {\n      v13 = (unsigned __int8)byte_80B7FD0[v12 - \"CSIL\"];\n      v7 = (char *)(a2 + 2);\n    }\n    else if ( (unsigned __int8)(v23 - 48) > 9u )\n    {\n      v13 = 4;\n    }\n    else\n    {\n      v13 = sub_804ED6C(0, v6, v29, (int)v6);\n      if ( *(_DWORD *)dword_80DBB7C == 34 || v13 > 8 || !byte_80D67BE[v13] )\n        sub_804D5E0(\"invalid type string '%s'; %u-byte %s type is not supported\", a1, v13, \"integral\");\n      v7 = v29[0];\n    }\n    v14 = (unsigned __int8)byte_80D67BE[v13];\n    v27 = v13;\n    v24 = byte_80D67BE[v13];\n    v15 = strchr(\"doux\", v4) - \"doux\";\n    v11 = dword_80B7FC0[v15];\n    v8 = *((unsigned __int8 *)*(&off_80B7FB0 + v15) + v27);\n    v16 = (char *)&unk_80B7FA0 + 4 * v15;\n    v17 = v16 + 2;\n    if ( v14 == 4 )\n    {\n      v17 = v16 + 1;\n    }\n    else if ( v14 == 5 )\n    {\n      v17 = (char *)&unk_80B7FA0 + 4 * v15;\n    }\n    v10 = sub_804DDBF((char *)(9 * v15 + 134964960), v8, v17);\n    if ( v24 == 2 )\n    {\n      v9 = (int (*)())sub_8094E0F;\n      if ( v11 )\n        v9 = (int (*)())sub_8094DE5;\n      v14 = 2;\n    }\n    else\n    {\n      if ( (unsigned __int8)v24 > 2u )\n      {\n        v9 = (int (*)())sub_8094DBD;\n        if ( (unsigned __int8)v24 <= 4u )\n          goto LABEL_54;\n      }\n      else if ( v24 == 1 )\n      {\n        v9 = (int (*)())sub_8094E5E;\n        if ( v11 )\n          v9 = (int (*)())sub_8094E39;\n        goto LABEL_50;\n      }\n      v9 = (int (*)())sub_8094D91;\n    }\n  }\nLABEL_54:\n  a3[1] = v14;\n  *a3 = v11;\n  a3[2] = (int)v9;\n  a3[3] = (int)v10;\n  a3[5] = v8;\n  v20 = *v7 == 122;\n  a3[4] = v20;\n  if ( v20 )\n    ++v7;\n  return v7;\n}\n"
    ],
    "sub_80952E6": [
        "0x80952e6",
        "char *__usercall sub_80952E6@<eax>(char *result@<eax>)\n{\n  const char *v1; // ebp\n  unsigned __int8 *v2; // ebx\n  int v3[10]; // [esp+0h] [ebp-28h] BYREF\n\n  v1 = result;\n  v2 = (unsigned __int8 *)result;\n  while ( *v2 )\n  {\n    v2 = (unsigned __int8 *)sub_8094FE4(v1, v2, v3);\n    *(&unk_80DB780 + 1) = sub_80B4733(unk_80DB780, 6148);\n    result = (char *)(24 * unk_80DB780 + *(&unk_80DB780 + 1));\n    qmemcpy(result, v3, 0x18u);\n    ++unk_80DB780;\n  }\n  return result;\n}\n"
    ],
    "sub_8095341": [
        "0x8095341",
        "FILE *sub_8095341()\n{\n  FILE *result; // eax\n  int v1; // [esp-8h] [ebp-8h]\n\n  while ( 1 )\n  {\n    result = (FILE *)dword_80DB798;\n    if ( !*(_DWORD *)dword_80DB798 )\n      break;\n    dword_80DB798 += 4;\n    result = sub_80B3D76(result->_flags);\n    stream = result;\n    if ( result )\n    {\n      if ( (dword_80DBB9C & 0x10002) == 2 )\n      {\n        setbuf(result, 0);\n        return (FILE *)v1;\n      }\n      return result;\n    }\n    LOBYTE(qword_80DB778) = 1;\n  }\n  return result;\n}\n"
    ],
    "sub_8095389": [
        "0x8095389",
        "FILE *sub_8095389()\n{\n  FILE *result; // eax\n\n  if ( stream )\n  {\n    if ( (stream->_flags & 8) != 0 )\n    {\n      sub_804D5F4(\"%s: read error\");\n      LOBYTE(qword_80DB778) = 1;\n    }\n    sub_80AB218();\n    stream = 0;\n  }\n  result = stdout;\n  if ( (stdout->_flags & 8) != 0 )\n    sub_804D5E0(\"write error\");\n  return result;\n}\n"
    ],
    "sub_80953E9": [
        "0x80953e9",
        "int __usercall sub_80953E9@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  __int64 v3; // rdi\n  size_t v4; // ebx\n  size_t v5; // eax\n  __int16 v6; // [esp+10h] [ebp-45Ch]\n  __int64 v7; // [esp+2Ch] [ebp-440h]\n  char ptr[1036]; // [esp+60h] [ebp-40Ch] BYREF\n\n  HIDWORD(v3) = a1;\n  result = a1 | a2;\n  LODWORD(v3) = a2;\n  if ( result )\n  {\n    while ( 1 )\n    {\n      if ( !stream )\n        sub_804D5E0(\"can't skip past end of combined input\");\n      fileno_unlocked(stream);\n      if ( fstat64() || (v6 & 0xF000) != 0x8000 || v7 <= 0 )\n      {\n        v4 = 1024;\n        do\n        {\n          if ( (int)v3 <= 0 && ((int)v3 < 0 || !HIDWORD(v3)) )\n            break;\n          if ( (int)v3 <= 0 && v4 > HIDWORD(v3) )\n            v4 = HIDWORD(v3);\n          v5 = fread(ptr, 1u, v4, stream);\n          LODWORD(v3) = (__PAIR64__(v3, HIDWORD(v3)) - v5) >> 32;\n          HIDWORD(v3) -= v5;\n        }\n        while ( v4 == v5 );\n        result = HIDWORD(v3) | v3;\n        if ( !v3 )\n          return result;\n      }\n      else\n      {\n        if ( v7 >= __SPAIR64__(v3, HIDWORD(v3)) )\n        {\n          result = fseeko64();\n          if ( result )\n            LOBYTE(qword_80DB778) = 1;\n          return result;\n        }\n        LODWORD(v3) = (__PAIR64__(v3, HIDWORD(v3)) - v7) >> 32;\n        HIDWORD(v3) -= v7;\n      }\n      sub_8095389();\n      sub_8095341();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80954E2": [
        "0x80954e2",
        "size_t __usercall sub_80954E2@<eax>(size_t result@<eax>, int a2@<edx>, _DWORD *a3@<ecx>)\n{\n  size_t v3; // esi\n  size_t v6; // ebp\n\n  *a3 = 0;\n  if ( result )\n  {\n    v3 = result;\n    while ( stream )\n    {\n      v6 = v3 - *a3;\n      result = fread((void *)(a2 + *a3), 1u, v6, stream);\n      *a3 += result;\n      if ( v6 == result )\n        break;\n      sub_8095389();\n      result = sub_8095341();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_809552D": [
        "0x809552d",
        "int __usercall sub_809552D@<eax>(int result@<eax>, int a2@<edx>, char *a3@<ecx>, void *s1, char *s2)\n{\n  unsigned int i; // ebx\n  _DWORD *v7; // edi\n  int v8; // eax\n  _BYTE *v9; // ecx\n  _BYTE *v10; // edx\n  _BYTE *v11; // edx\n  unsigned __int8 *v12; // [esp+0h] [ebp-20h]\n  int v13; // [esp+8h] [ebp-18h]\n\n  v13 = result;\n  if ( (dword_80DBB9C & 0x2000) != 0\n    || !LOBYTE(pmatch[0].rm_so)\n    || (result = (int)*(&MEMORY[0x80DB788] + 3), *(&MEMORY[0x80DB788] + 3) != a3)\n    || (result = memcmp(s1, s2, (size_t)*(&MEMORY[0x80DB788] + 3))) != 0 )\n  {\n    LOWORD(pmatch[0].rm_so) = 1;\n    for ( i = 0; unk_80DB780 > i; ++i )\n    {\n      if ( i )\n        printf(\"%*s\", dword_80DB7A4 - 48, &data);\n      else\n        ((void (__cdecl *)(int, int, _DWORD))MEMORY[0x80DB788])(v13, a2, 0);\n      (*(void (__cdecl **)(char *, char *, _DWORD))(24 * i + *(&unk_80DB780 + 1) + 8))(\n        a3,\n        s2,\n        *(_DWORD *)(24 * i + *(&unk_80DB780 + 1) + 12));\n      v7 = (_DWORD *)(*(&unk_80DB780 + 1) + 24 * i);\n      if ( v7[4] )\n      {\n        printf(\"%*s\", (v7[5] + 1) * ((*(&MEMORY[0x80DB788] + 3) - a3) / (unsigned int)byte_80D67C7[v7[1]]), &data);\n        fputs_unlocked();\n        v12 = (unsigned __int8 *)s2;\n        while ( v12 != (unsigned __int8 *)&a3[(_DWORD)s2] )\n        {\n          v8 = *v12++;\n          if ( (unsigned int)(v8 - 32) > 0x5E )\n            LOBYTE(v8) = 46;\n          v9 = *(_BYTE **)(_stdout + 16);\n          if ( (unsigned int)v9 >= *(_DWORD *)(_stdout + 28) )\n          {\n            __fputc_unlocked();\n          }\n          else\n          {\n            *(_DWORD *)(_stdout + 16) = v9 + 1;\n            *v9 = v8;\n          }\n        }\n        v10 = *(_BYTE **)(_stdout + 16);\n        if ( (unsigned int)v10 >= *(_DWORD *)(_stdout + 28) )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(_stdout + 16) = v10 + 1;\n          *v10 = 60;\n        }\n      }\n      result = _stdout;\n      v11 = *(_BYTE **)(_stdout + 16);\n      if ( (unsigned int)v11 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked();\n        result = 10;\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v11 + 1;\n        *v11 = 10;\n      }\n    }\n  }\n  else if ( !BYTE1(pmatch[0].rm_so) )\n  {\n    result = puts(\"*\");\n    BYTE1(pmatch[0].rm_so) = 1;\n  }\n  return result;\n}\n"
    ],
    "sub_80956E8": [
        "0x80956e8",
        "int __cdecl sub_80956E8(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // esi\n  int v4; // edi\n  char *v5; // eax\n  int v6; // eax\n  unsigned int v7; // edi\n  unsigned int v8; // ebp\n  __int64 v9; // kr00_8\n  char *v10; // eax\n  char *v11; // eax\n  __int64 v12; // rax\n  int v13; // eax\n  char *v14; // esi\n  size_t v15; // ebp\n  char *v16; // ebx\n  unsigned int v17; // esi\n  int v18; // eax\n  char *IO_write_base; // edx\n  char *i; // esi\n  char v21; // dl\n  _BYTE *v22; // ecx\n  _BYTE *v23; // edx\n  void *v24; // ebp\n  int v25; // ebx\n  size_t v26; // eax\n  char *v27; // esi\n  int v28; // esi\n  unsigned int v29; // eax\n  signed __int64 v31; // [esp+0h] [ebp-48h]\n  signed __int64 v32; // [esp+8h] [ebp-40h]\n  char *s2; // [esp+10h] [ebp-38h]\n  unsigned __int8 *v34; // [esp+14h] [ebp-34h] BYREF\n  int v35; // [esp+18h] [ebp-30h] BYREF\n  int v36; // [esp+1Ch] [ebp-2Ch] BYREF\n  char *v37; // [esp+20h] [ebp-28h] BYREF\n  int v38; // [esp+24h] [ebp-24h] BYREF\n  __int64 v39; // [esp+28h] [ebp-20h] BYREF\n  __int64 s1[3]; // [esp+30h] [ebp-18h] BYREF\n\n  v37 = \"3\";\n  v38 = 0;\n  *(&MEMORY[0x80DB788] + 3) = (char *)32;\n  strcpy((char *)&pmatch[0].rm_so + 2, \"%0nllxc\");\n  MEMORY[0x80DB788] = (char *)sub_8094C03;\n  *(&dword_80DB7A4 + 3) = 111;\n  dword_80DB7A4 = 55;\n  v2 = sub_80ABEC2(\n         a2,\n         \"A:N:abcdfhij:lot:*vxsS:w:+:\",\n         \"skip-bytes\",\n         &v34,\n         &v35,\n         &v36,\n         &v38,\n         &v37,\n         &MEMORY[0x80DB788] + 3);\n  v3 = a2 + 4 * optind;\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = *v34;\n    v5 = strchr(\"doxn\", v4);\n    if ( !v5 )\n      sub_804D5E0(\"bad output address radix '%c' (must be [doxn])\", v4);\n    v6 = v5 - \"doxn\";\n    if ( v6 == 3 )\n      MEMORY[0x80DB788] = (char *)nullsub_8;\n    *(&dword_80DB7A4 + 3) = byte_80D6741[v6];\n    dword_80DB7A4 = byte_80D673E[v6];\n  }\n  v7 = 0;\n  v8 = 0;\n  if ( (v2 & 2) != 0 )\n  {\n    v9 = sub_80B3F3E(&unk_80B7580, 0);\n    v8 = HIDWORD(v9);\n    v7 = v9;\n  }\n  if ( (v2 & 4) != 0 )\n    sub_80952E6((char *)\"a\");\n  if ( (v2 & 8) != 0 )\n    sub_80952E6(\"oC\");\n  if ( (v2 & 0x10) != 0 )\n    sub_80952E6(\"c\");\n  if ( (v2 & 0x20) != 0 )\n    sub_80952E6(\"u2\");\n  if ( (v2 & 0x40) != 0 )\n    sub_80952E6(\"fF\");\n  if ( (v2 & 0x80u) != 0 )\n    sub_80952E6(\"x2\");\n  if ( (v2 & 0x100) != 0 )\n    sub_80952E6(\"d2\");\n  v31 = 0LL;\n  if ( (v2 & 0x200) != 0 )\n    v31 = sub_80B3F3E(&unk_80B7580, 0);\n  if ( (v2 & 0x400) != 0 )\n    sub_80952E6(\"d4\");\n  v10 = \"o2\";\n  if ( (v2 & 0x800) != 0 )\n    goto LABEL_30;\n  while ( v38 )\n  {\n    v10 = (char *)sub_80AFB01(v31);\nLABEL_30:\n    sub_80952E6(v10);\n  }\n  if ( (v2 & 0x4000) != 0 )\n    sub_80952E6(\"x2\");\n  if ( (v2 & 0x8000) != 0 )\n    sub_80952E6(\"d2\");\n  if ( (v2 & 0x10000) != 0 )\n    HIDWORD(qword_80DB778) = sub_80B40A1(&unk_80B7580, 0);\n  if ( (v2 & 0x40000) != 0 )\n  {\n    v11 = *(char **)v3;\n    if ( *(_DWORD *)v3 )\n    {\n      if ( !*(_DWORD *)(v3 + 4) )\n      {\n        if ( sub_8094B84(v11, (int)&v39) )\n        {\n          v31 = v39;\n          v3 += 4;\n        }\n        goto LABEL_60;\n      }\n      if ( *(_DWORD *)(v3 + 8) )\n      {\n        if ( *(_DWORD *)(v3 + 12) )\n          sub_804D5E0(\"too many arguments\");\n        if ( !sub_8094B84(*(char **)(v3 + 4), (int)&v39) || !sub_8094B84(*(char **)(v3 + 8), (int)s1) )\n          sub_804D5E0(\"the last two arguments must be offsets\");\n        v31 = v39;\n        v12 = s1[0];\n        *(_DWORD *)(v3 + 4) = 0;\n        goto LABEL_55;\n      }\n      if ( sub_8094B84(v11, (int)&v39) && sub_8094B84(*(char **)(v3 + 4), (int)s1) )\n      {\n        v31 = v39;\n        v12 = s1[0];\n        v3 += 8;\nLABEL_55:\n        if ( v12 >= 0 )\n        {\n          if ( MEMORY[0x80DB788] == (char *)nullsub_8 )\n          {\n            *(&dword_80DB7A4 + 3) = 111;\n            dword_80DB7A4 = 55;\n            MEMORY[0x80DB788] = (char *)loc_8094C29;\n          }\n          else\n          {\n            MEMORY[0x80DB788] = (char *)loc_8094C98;\n          }\n          *(_QWORD *)(&MEMORY[0x80DB788] + 1) = v12 - v31;\n        }\n        goto LABEL_60;\n      }\n      if ( !sub_8094B84(*(char **)(v3 + 4), (int)s1) )\n        sub_804D5E0(\"invalid second argument '%s'\", *(_DWORD *)(v3 + 4));\n      v31 = s1[0];\n      *(_DWORD *)(v3 + 4) = 0;\n    }\n  }\nLABEL_60:\n  if ( (dword_80DBB9C & 2) != 0 )\n  {\n    v32 = v31 + __PAIR64__(v8, v7);\n    if ( v31 > (__int64)(v31 + __PAIR64__(v8, v7)) )\n      sub_804D5E0(\"SKIP + SIZE is too large\");\n  }\n  else\n  {\n    v32 = 0LL;\n  }\n  if ( !unk_80DB780 )\n    sub_80952E6(\"o2\");\n  dword_80DB798 = (char *)&off_80B8488;\n  if ( *(_DWORD *)v3 )\n    dword_80DB798 = (char *)v3;\n  sub_8095341();\n  sub_80953E9(v31, SHIDWORD(v31));\n  if ( !stream )\n    return 1;\n  v13 = sub_8094B28();\n  v14 = (char *)v13;\n  if ( (v2 & 0x20000) != 0 )\n  {\n    if ( !*(&MEMORY[0x80DB788] + 3) || (unsigned int)*(&MEMORY[0x80DB788] + 3) % v13 )\n    {\n      sub_804D5F4(\"warning: invalid width %u; using %d instead\", *(&MEMORY[0x80DB788] + 3), v13);\n      *(&MEMORY[0x80DB788] + 3) = v14;\n    }\n  }\n  else\n  {\n    *(&MEMORY[0x80DB788] + 3) = (char *)v13;\n    if ( v13 <= 15 )\n      *(&MEMORY[0x80DB788] + 3) = (char *)(v13 * (16 / v13));\n  }\n  if ( (dword_80DBB9C & 0x10000) != 0 )\n  {\n    v15 = HIDWORD(qword_80DB778);\n    if ( HIDWORD(qword_80DB778) < 0x64 )\n      v15 = 100;\n    v16 = (char *)sub_804DAFA(v15);\n    while ( 1 )\n    {\nLABEL_79:\n      if ( (dword_80DBB9C & 2) != 0 && v32 - HIDWORD(qword_80DB778) <= v31 )\n      {\n        sub_8095389();\n        goto LABEL_107;\n      }\n      v17 = 0;\nLABEL_82:\n      if ( (dword_80DBB9C & 2) == 0 || v32 > v31 )\n        break;\nLABEL_94:\n      if ( v17 >= HIDWORD(qword_80DB778) )\n      {\n        v16[v17] = 0;\n        ((void (__cdecl *)(_DWORD, _DWORD, int))MEMORY[0x80DB788])(\n          v31 - v17 - 1,\n          (v31 - (unsigned __int64)v17 - 1) >> 32,\n          32);\n        for ( i = v16; ; ++i )\n        {\n          v21 = *i;\n          if ( !*i )\n            break;\n          switch ( *i )\n          {\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n              fputs_unlocked();\n              break;\n            default:\n              v22 = *(_BYTE **)(_stdout + 16);\n              if ( (unsigned int)v22 >= *(_DWORD *)(_stdout + 28) )\n              {\n                __fputc_unlocked();\n              }\n              else\n              {\n                *(_DWORD *)(_stdout + 16) = v22 + 1;\n                *v22 = v21;\n              }\n              break;\n          }\n        }\n        v23 = *(_BYTE **)(_stdout + 16);\n        if ( (unsigned int)v23 >= *(_DWORD *)(_stdout + 28) )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(_stdout + 16) = v23 + 1;\n          *v23 = 10;\n        }\n      }\n    }\n    if ( v15 == v17 )\n    {\n      v15 += v15 >> 3;\n      v16 = (char *)sub_804DB13(v16, v15);\n    }\n    while ( stream )\n    {\n      IO_write_base = stream->_IO_write_base;\n      if ( IO_write_base < stream->_IO_write_end )\n      {\n        stream->_IO_write_base = IO_write_base + 1;\n        v18 = (unsigned __int8)*IO_write_base;\nLABEL_90:\n        ++v31;\n        if ( !v18 )\n          goto LABEL_94;\n        if ( (unsigned int)(v18 - 32) <= 0x5E )\n        {\n          v16[v17++] = v18;\n          goto LABEL_82;\n        }\n        goto LABEL_79;\n      }\n      v18 = __fgetc_unlocked();\n      if ( v18 != -1 )\n        goto LABEL_90;\n      sub_8095389();\n      sub_8095341();\n    }\nLABEL_107:\n    free(v16);\n  }\n  else\n  {\n    v24 = sub_804DAFA(2 * (_DWORD)*(&MEMORY[0x80DB788] + 3));\n    LODWORD(s1[0]) = v24;\n    HIDWORD(s1[0]) = &(*(&MEMORY[0x80DB788] + 3))[(_DWORD)v24];\n    v25 = 0;\n    if ( (dword_80DBB9C & 2) != 0 )\n    {\n      while ( v32 > v31 )\n      {\n        s2 = (char *)*((_DWORD *)s1 + v25);\n        v26 = (size_t)*(&MEMORY[0x80DB788] + 3);\n        if ( (unsigned int)*(&MEMORY[0x80DB788] + 3) > v32 - v31 )\n          v26 = v32 - v31;\n        sub_80954E2(v26, (int)s2, &v39);\n        if ( (unsigned int)*(&MEMORY[0x80DB788] + 3) > (unsigned int)v39 )\n          goto LABEL_117;\n        v25 ^= 1u;\n        sub_809552D(v31, SHIDWORD(v31), (char *)v39, *((void **)s1 + v25), s2);\n        v31 += (unsigned int)v39;\n      }\n      LODWORD(v39) = 0;\n    }\n    else\n    {\n      while ( 1 )\n      {\n        v27 = (char *)*((_DWORD *)s1 + v25);\n        sub_80954E2((size_t)*(&MEMORY[0x80DB788] + 3), (int)v27, &v39);\n        if ( (unsigned int)*(&MEMORY[0x80DB788] + 3) > (unsigned int)v39 )\n          break;\n        v25 ^= 1u;\n        sub_809552D(v31, SHIDWORD(v31), (char *)v39, *((void **)s1 + v25), v27);\n        v31 += (unsigned int)v39;\n      }\n    }\nLABEL_117:\n    v28 = v39;\n    if ( (_DWORD)v39 )\n    {\n      v29 = sub_8094B28();\n      memset((void *)(*((_DWORD *)s1 + v25) + v28), 0, v29 * ((v28 + v29 - 1) / v29) - v28);\n      sub_809552D(\n        v31,\n        SHIDWORD(v31),\n        (char *)(v29 * ((v28 + v29 - 1) / v29)),\n        *((void **)s1 + (v25 ^ 1)),\n        *((char **)s1 + v25));\n      v31 += (unsigned int)v39;\n    }\n    ((void (__cdecl *)(_DWORD, _DWORD, int))MEMORY[0x80DB788])(v31, HIDWORD(v31), 10);\n    if ( (dword_80DBB9C & 2) != 0 && v32 <= v31 )\n      sub_8095389();\n    free(v24);\n  }\n  if ( fclose(stdin) )\n    sub_804D3C9((int)\"standard input\");\n  return (char)qword_80DB778;\n}\n"
    ],
    "sub_8095ECB": [
        "0x8095ecb",
        "void __cdecl __noreturn sub_8095ECB(int a1, int a2)\n{\n  char v2; // di\n  _DWORD *v3; // ebx\n  int i; // esi\n  int v5; // eax\n  void *v6; // ebp\n  int v7; // esi\n  int v8; // edi\n  int v9; // edx\n  char v10; // al\n  char *IO_write_base; // ecx\n  int j; // edi\n  void *v13; // ebp\n  int v14; // edx\n  char v15; // al\n  char *v16; // ecx\n  int v17; // [esp+0h] [ebp-24h]\n  int v18; // [esp+4h] [ebp-20h]\n  int v19; // [esp+8h] [ebp-1Ch]\n  _BYTE *v20; // [esp+Ch] [ebp-18h]\n  int v21[5]; // [esp+10h] [ebp-14h] BYREF\n\n  v21[0] = 135040267;\n  v2 = sub_80ABEAC(a2, &unk_80D6814, v21);\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v2 & 1) != 0 )\n  {\n    if ( !*(_BYTE *)v21[0] )\n      sub_804D5E0(\"-d '' is not supported\");\n    v18 = sub_80B0D53() - v21[0];\n  }\n  else\n  {\n    v18 = 1;\n  }\n  if ( !*v3 )\n    *--v3 = \"-\";\n  for ( i = 0; v3[i]; ++i )\n  {\n    v5 = sub_80B3D76(v17);\n    v3[i] = v5;\n    if ( !v5 )\n      sub_804D604();\n  }\n  v20 = (_BYTE *)v21[0];\n  if ( (v2 & 2) != 0 )\n  {\n    while ( *v3 )\n    {\n      v6 = 0;\n      v7 = 0;\n      while ( 1 )\n      {\n        v8 = sub_80AB85A();\n        if ( !v8 )\n          break;\n        if ( v6 )\n        {\n          fputs_unlocked();\n          free(v6);\n          v9 = v7 + 1;\n          v10 = v20[v7];\n          v7 = 0;\n          if ( v18 != v9 )\n            v7 = v9;\n          if ( v10 )\n          {\n            IO_write_base = stdout->_IO_write_base;\n            if ( IO_write_base >= stdout->_IO_buf_base )\n            {\n              __fputc_unlocked();\n            }\n            else\n            {\n              stdout->_IO_write_base = IO_write_base + 1;\n              *IO_write_base = v10;\n            }\n          }\n        }\n        v6 = (void *)v8;\n      }\n      if ( v6 )\n      {\n        printf(\"%s\\n\", (const char *)v6);\n        free(v6);\n      }\n      sub_80AB218();\n      ++v3;\n    }\n    goto LABEL_45;\n  }\n  v19 = i;\nLABEL_29:\n  if ( v19 <= 0 )\nLABEL_45:\n    sub_80AB247(v17, v18);\n  v17 = 0;\n  for ( j = 0; ; ++j )\n  {\n    if ( i == j )\n      goto LABEL_29;\n    if ( v3[j] )\n    {\n      v13 = (void *)sub_80AB85A();\n      if ( !v13 )\n      {\n        sub_80AB218();\n        v3[j] = 0;\n        --v19;\n        continue;\n      }\n      fputs_unlocked();\n      free(v13);\n      if ( j == i - 1 )\n      {\n        v15 = 10;\nLABEL_41:\n        v16 = stdout->_IO_write_base;\n        if ( v16 >= stdout->_IO_buf_base )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          stdout->_IO_write_base = v16 + 1;\n          *v16 = v15;\n        }\n        continue;\n      }\n      v14 = v17 + 1;\n      v15 = v20[v17];\n      v17 = 0;\n      if ( v18 != v14 )\n        v17 = v14;\n      if ( v15 )\n        goto LABEL_41;\n    }\n  }\n}\n"
    ],
    "sub_80960C1": [
        "0x80960c1",
        "void __cdecl __noreturn sub_80960C1(int a1, int a2)\n{\n  const char **v2; // ebx\n  const char **v3; // ebx\n  const char *v4; // eax\n  char *v5; // eax\n  int v6; // [esp+0h] [ebp-8h]\n  int v7; // [esp+4h] [ebp-4h]\n\n  v2 = (const char **)a2;\n  if ( *(_DWORD *)(a2 + 4) )\n  {\n    while ( *++v2 )\n    {\n      v5 = getenv(*v2);\n      if ( v5 )\n        puts(v5);\n    }\n  }\n  else\n  {\n    v3 = (const char **)environ;\n    if ( environ )\n    {\n      while ( 1 )\n      {\n        v4 = *v3;\n        if ( !*v3 )\n          break;\n        ++v3;\n        puts(v4);\n      }\n    }\n  }\n  sub_80AB247(v6, v7);\n}\n"
    ],
    "sub_809611A": [
        "0x809611a",
        "int __usercall sub_809611A@<eax>(char *a1@<eax>)\n{\n  int result; // eax\n\n  result = sub_804EDC5(10, a1, 0, (int)a1);\n  if ( *(_DWORD *)dword_80DBB7C )\n  {\n    sub_804D5F4(\"invalid number '%s'\", a1);\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8096145": [
        "0x8096145",
        "__int64 __usercall sub_8096145@<edx:eax>(char *a1@<eax>, __int64 *a2@<edx>)\n{\n  __int64 result; // rax\n\n  result = sub_804ED01(a1, 0, 0);\n  *a2 = result;\n  return result;\n}\n"
    ],
    "sub_8096158": [
        "0x8096158",
        "int __usercall sub_8096158@<eax>(_BYTE *a1@<eax>, void (*a2)(void)@<ecx>)\n{\n  _BYTE *v2; // ebx\n  char v4; // al\n  int *v5; // esi\n  int result; // eax\n\n  v2 = a1;\n  v4 = *a1;\n  if ( v4 == 34 || v4 == 39 )\n    v2 = sub_804D6F7((unsigned __int8)v2[1]);\n  v5 = (int *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  a2();\n  result = *v5;\n  if ( *v5 )\n  {\n    sub_804D5F4(\"invalid number '%s'\", v2);\n    return 1;\n  }\n  return result;\n}\n"
    ],
    "sub_80961A8": [
        "0x80961a8",
        "char __usercall sub_80961A8@<al>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        unsigned int a5,\n        unsigned __int8 *a6)\n{\n  char *v7; // edi\n  char v8; // al\n  bool v9; // zf\n  void (*v10)(void); // ecx\n  char result; // al\n  double v12; // [esp+0h] [ebp-38h]\n  double v13; // [esp+0h] [ebp-38h]\n  char v15; // [esp+Fh] [ebp-29h]\n  char *v16; // [esp+10h] [ebp-28h]\n  char *v17; // [esp+14h] [ebp-24h]\n  double v19; // [esp+20h] [ebp-18h]\n\n  v16 = (char *)&a1[a2];\n  v15 = a1[a2];\n  a1[a2] = 0;\n  v7 = strstr(a1, \".*\");\n  v17 = strchr(a1, 42);\n  if ( v7 == v17 - 1 )\n    v17 = 0;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v8 = a1[a2 - 1];\n  if ( (unsigned __int8)v8 > 0x67u )\n  {\n    if ( v8 == 115 )\n    {\n      if ( v17 )\n      {\n        if ( v7 )\n        {\n          v13 = COERCE_DOUBLE(__PAIR64__((unsigned int)a6, a5));\n        }\n        else\n        {\n          HIDWORD(v13) = a6;\n          LODWORD(v13) = a6;\n        }\n        goto LABEL_47;\n      }\n      if ( !v7 )\n      {\n        printf(a1, a6, a6, a6);\n        goto LABEL_49;\n      }\n      HIDWORD(v12) = a6;\n      LODWORD(v12) = a6;\n      goto LABEL_37;\n    }\n    if ( (unsigned __int8)v8 > 0x73u )\n    {\n      if ( v8 == 117 )\n      {\nLABEL_32:\n        v10 = (void (*)(void))sub_809635D;\n        goto LABEL_23;\n      }\n      v9 = v8 == 120;\n    }\n    else\n    {\n      if ( v8 == 105 )\n      {\nLABEL_22:\n        v10 = (void (*)(void))sub_8096145;\nLABEL_23:\n        if ( sub_8096158(a6, v10) )\n          v19 = 0.0;\n        if ( v17 )\n        {\n          if ( !v7 )\n          {\n            v13 = v19;\nLABEL_47:\n            printf(a1, a3, v13);\n            goto LABEL_49;\n          }\nLABEL_48:\n          printf(a1, a3, a5, v19);\n          goto LABEL_49;\n        }\n        if ( !v7 )\n        {\n          printf(a1, v19);\n          goto LABEL_49;\n        }\n        v12 = v19;\nLABEL_37:\n        printf(a1, a5, v12);\n        goto LABEL_49;\n      }\n      v9 = v8 == 111;\n    }\n    if ( !v9 )\n      goto LABEL_49;\n    goto LABEL_32;\n  }\n  if ( (unsigned __int8)v8 >= 0x65u )\n    goto LABEL_41;\n  if ( v8 == 88 )\n    goto LABEL_32;\n  if ( (unsigned __int8)v8 > 0x58u )\n  {\n    if ( v8 == 99 )\n    {\n      printf(a1, *a6);\n      goto LABEL_49;\n    }\n    if ( v8 != 100 )\n      goto LABEL_49;\n    goto LABEL_22;\n  }\n  if ( v8 == 69 || v8 == 71 )\n  {\nLABEL_41:\n    sub_8096158(a6, (void (*)(void))&sub_809638E);\n    if ( !v17 )\n    {\n      if ( !v7 )\n      {\n        printf(a1);\n        goto LABEL_49;\n      }\n      v12 = v19;\n      goto LABEL_37;\n    }\n    if ( !v7 )\n    {\n      v13 = v19;\n      goto LABEL_47;\n    }\n    goto LABEL_48;\n  }\nLABEL_49:\n  result = v15;\n  *v16 = v15;\n  return result;\n}\n"
    ],
    "sub_809635D": [
        "0x809635d",
        "int __usercall sub_809635D@<eax>(char *a1@<eax>, __int64 *a2@<edx>)\n{\n  __int64 v4; // rax\n\n  *a2 = sub_804EC9E(a1, 0, 0);\n  LODWORD(v4) = dword_80DBB7C;\n  if ( *(_DWORD *)dword_80DBB7C )\n  {\n    v4 = sub_804ED01(a1, 0, 0);\n    *a2 = v4;\n  }\n  return v4;\n}\n"
    ],
    "sub_809638E": [
        "0x809638e",
        "char *__usercall sub_809638E@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  char *result; // eax\n  char *endptr; // [esp+4h] [ebp-Ch] BYREF\n\n  *(double *)a2 = strtod(a1, &endptr);\n  result = endptr;\n  if ( *endptr )\n  {\n    result = (char *)dword_80DBB7C;\n    *(_DWORD *)dword_80DBB7C = 34;\n    *(_DWORD *)a2 = 0;\n    *(_DWORD *)(a2 + 4) = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80963DC": [
        "0x80963dc",
        "int __cdecl sub_80963DC(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  char **v5; // ebx\n  unsigned __int8 *v6; // esi\n  unsigned __int8 v7; // al\n  unsigned int v8; // ecx\n  unsigned __int8 v9; // al\n  char *v10; // edx\n  unsigned __int8 v11; // al\n  char *v12; // esi\n  char v13; // al\n  int v14; // ebp\n  char *v15; // eax\n  unsigned __int8 *v16; // eax\n  char *v17; // eax\n  char *v18; // eax\n  int v19; // edx\n  void *v20; // ebp\n  unsigned int v21; // eax\n  unsigned __int8 v22; // al\n  unsigned __int8 *v23; // edx\n  unsigned int v24; // [esp-8h] [ebp-3Ch]\n  unsigned __int8 *v25; // [esp+0h] [ebp-34h]\n  char **v26; // [esp+4h] [ebp-30h]\n  int v27; // [esp+8h] [ebp-2Ch]\n  int v28; // [esp+Ch] [ebp-28h]\n  unsigned __int8 *v29; // [esp+10h] [ebp-24h]\n  int v30; // [esp+14h] [ebp-20h]\n  unsigned __int8 v31; // [esp+18h] [ebp-1Ch]\n  unsigned __int8 *v32; // [esp+1Ch] [ebp-18h]\n  unsigned __int8 *v33; // [esp+1Ch] [ebp-18h]\n\n  v2 = a2;\n  if ( fcntl64() == -1 )\n    return 1;\n  v3 = *(_BYTE **)(a2 + 4);\n  if ( v3 && *v3 == 45 && v3[1] == 45 && !v3[2] )\n    v2 = a2 + 4;\n  v29 = *(unsigned __int8 **)(v2 + 4);\n  if ( !v29 )\n  {\n    if ( *ident == 112 )\n      sub_804CDC2();\n    sub_804D5F4(\"usage: printf FORMAT [ARGUMENT...]\");\n    return 2;\n  }\n  v26 = (char **)(v2 + 8);\n  v30 = 0;\n  while ( 2 )\n  {\n    v32 = v29;\n    v5 = v26;\n    while ( 1 )\n    {\n      v6 = v32;\n      v7 = *v32;\n      if ( !*v32 )\n        break;\n      v8 = v7;\n      if ( v7 != 37 )\n      {\n        if ( v7 == 92 )\n        {\n          v33 = v32 + 1;\n          if ( v6[1] == 99 )\n          {\nLABEL_70:\n            v5 = v26;\n            return v5 < v26 || v30 != 0;\n          }\n          v22 = sub_80B0CB3(v7);\n          sub_804DD98(v22);\n          v32 = v33 - 1;\n        }\n        else\n        {\n          v23 = *(unsigned __int8 **)(_stdout + 16);\n          if ( (unsigned int)v23 >= *(_DWORD *)(_stdout + 28) )\n          {\n            __fputc_unlocked();\n          }\n          else\n          {\n            *(_DWORD *)(_stdout + 16) = v23 + 1;\n            *v23 = *v32;\n          }\n        }\n        goto LABEL_66;\n      }\n      ++v32;\n      v9 = v6[1];\n      if ( v9 == 37 )\n      {\n        sub_804DD98(37);\n        goto LABEL_66;\n      }\n      if ( v9 == 98 )\n      {\n        v10 = *v5;\n        if ( *v5 )\n        {\n          while ( 1 )\n          {\n            v11 = *v10;\n            if ( !*v10 )\n              break;\n            v12 = v10 + 1;\n            if ( v11 == 92 )\n            {\n              v13 = v10[1];\n              if ( v13 == 48 )\n              {\n                if ( (unsigned __int8)(v10[2] - 48) <= 7u )\n                  v12 = v10 + 2;\n              }\n              else if ( v13 == 99 )\n              {\n                goto LABEL_70;\n              }\n              v11 = sub_80B0CB3(v8);\n            }\n            v8 = *(_DWORD *)(_stdout + 16);\n            if ( v8 >= *(_DWORD *)(_stdout + 28) )\n            {\n              v24 = v11;\n              __fputc_unlocked();\n              v8 = v24;\n            }\n            else\n            {\n              *(_DWORD *)(_stdout + 16) = v8 + 1;\n              *(_BYTE *)v8 = v11;\n            }\n            v10 = v12;\n          }\n          ++v5;\n        }\n        goto LABEL_66;\n      }\n      v14 = 1;\n      if ( v9 && strchr(\"-+ #\", v6[1]) )\n      {\n        v32 = v6 + 2;\n        v14 = 2;\n      }\n      if ( *v32 == 42 )\n      {\n        ++v32;\n        ++v14;\n        v15 = *v5;\n        v28 = 0;\n        if ( *v5 )\n        {\n          ++v5;\n          v28 = sub_809611A(v15);\n        }\n      }\n      else\n      {\n        while ( (unsigned __int8)(*v32 - 48) <= 9u )\n        {\n          ++v32;\n          ++v14;\n        }\n        v28 = 0;\n      }\n      v16 = v32;\n      if ( *v32 == 46 )\n      {\n        ++v32;\n        v25 = (unsigned __int8 *)(v14 + 1);\n        if ( v16[1] == 42 )\n        {\n          v32 = v16 + 2;\n          v25 = (unsigned __int8 *)(v14 + 2);\n          v17 = *v5;\n          v27 = 0;\n          if ( *v5 )\n          {\n            ++v5;\n            v27 = sub_809611A(v17);\n          }\n          goto LABEL_49;\n        }\n        while ( (unsigned __int8)(*v32 - 48) <= 9u )\n        {\n          ++v32;\n          ++v25;\n        }\n      }\n      else\n      {\n        v25 = (unsigned __int8 *)v14;\n      }\n      v27 = 0;\nLABEL_49:\n      while ( 1 )\n      {\n        LOBYTE(v8) = *v32 == 104;\n        if ( !((unsigned __int8)v8 | (*v32 == 122)) )\n        {\n          LOBYTE(v8) = *v32;\n          v8 |= 0x20u;\n          if ( (_BYTE)v8 != 108 )\n            break;\n        }\n        sub_80B2C69(v8);\n      }\n      v31 = *v32;\n      v18 = strchr(\"diouxXfeEgGcs\", *v32);\n      if ( !v18 || !v31 )\n      {\n        sub_804D5F4(\"%s: invalid format\", v6);\n        v5 = v26 - 1;\n        break;\n      }\n      v19 = (int)(v25 + 1);\n      v20 = 0;\n      if ( v18 - \"diouxXfeEgGcs\" <= 5 )\n      {\n        v20 = sub_804DAFA((size_t)(v25 + 4));\n        qmemcpy(v20, v6, (unsigned int)(v25 + 1));\n        v25[(_DWORD)v20 + 2] = v25[(_DWORD)v20];\n        v25[(_DWORD)v20] = 108;\n        v25[(_DWORD)v20 + 1] = 108;\n        v19 = (int)(v25 + 3);\n        v6 = (unsigned __int8 *)v20;\n      }\n      v21 = (unsigned int)*v5;\n      if ( *v5 )\n      {\n        ++v5;\n        sub_80961A8((const char *)v6, v19, v28, v27, v21, v25);\n      }\n      else\n      {\n        sub_80961A8((const char *)v6, v19, v28, v27, (unsigned int)&data, v25);\n      }\n      v30 |= *(_DWORD *)dword_80DBB7C;\n      free(v20);\nLABEL_66:\n      ++v32;\n    }\n    if ( v26 < v5 && *v5 )\n    {\n      v26 = v5;\n      continue;\n    }\n    return v5 < v26 || v30 != 0;\n  }\n}\n"
    ],
    "sub_8096762": [
        "0x8096762",
        "int __cdecl sub_8096762(int a1, int a2)\n{\n  char v2; // al\n  int *v3; // edx\n  int v4; // ecx\n  char *v5; // ebx\n  char *v6; // eax\n  char *v7; // esi\n  int v8; // eax\n  int v9; // eax\n  int result; // eax\n  char *v11; // ebx\n  int *v12; // [esp-8h] [ebp-D0h]\n  int v13; // [esp-4h] [ebp-CCh]\n  int v14; // [esp+0h] [ebp-C8h]\n  int v15; // [esp+4h] [ebp-C4h]\n  int v16; // [esp+58h] [ebp-70h]\n  int v17; // [esp+5Ch] [ebp-6Ch]\n  int v18; // [esp+60h] [ebp-68h] BYREF\n  int v19; // [esp+64h] [ebp-64h]\n  int v20; // [esp+B8h] [ebp-10h]\n  int v21; // [esp+BCh] [ebp-Ch]\n\n  v2 = sub_80ABEAC(a2, \"LP\");\n  v3 = v12;\n  v4 = v13;\n  if ( (v2 & 1) == 0 )\n    goto LABEL_19;\n  v5 = getenv(\"PWD\");\n  if ( !v5 )\n    goto LABEL_19;\n  v6 = v5;\n  if ( *v5 != 47 )\n    goto LABEL_19;\n  while ( *v6 )\n  {\n    v7 = v6 + 1;\n    LOBYTE(v4) = v6[1];\n    if ( *v6 == 47 && (_BYTE)v4 == 46 )\n    {\n      v7 = v6 + 2;\n      LOBYTE(v3) = v6[2];\n      if ( (_BYTE)v3 == 46 )\n      {\n        v7 = v6 + 3;\n        LOBYTE(v3) = v6[3];\n      }\n      if ( !(_BYTE)v3 || (_BYTE)v3 == 47 )\n        goto LABEL_19;\n    }\n    v6 = v7;\n  }\n  v8 = stat64();\n  v4 = (int)v5;\n  if ( !v8\n    && (v9 = stat64(), v3 = &v18, !v9)\n    && (v4 = v21, v17 == v21)\n    && v16 == v20\n    && (v4 = v19, v15 == v19)\n    && v14 == v18 )\n  {\n    puts(v5);\n    return sub_804DD8F();\n  }\n  else\n  {\nLABEL_19:\n    v11 = (char *)sub_80B46C0(v4, v3);\n    result = 1;\n    if ( v11 )\n    {\n      puts(v11);\n      free(v11);\n      return sub_804DD8F();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8096864": [
        "0x8096864",
        "int __cdecl sub_8096864(int a1, int a2)\n{\n  char v2; // si\n  const char *v3; // eax\n  void *v4; // eax\n  void *v5; // ebx\n  const char *v6; // eax\n  int v8; // [esp-Ch] [ebp-14h]\n  int v9; // [esp-8h] [ebp-10h]\n\n  v2 = sub_80ABEAC(a2, \"^fnvsq\");\n  v3 = *(const char **)(a2 + 4 * optind);\n  if ( (v2 & 4) == 0 )\n    byte_80DB561 = 0;\n  if ( (v2 & 1) != 0 )\n    v4 = sub_804E2A7(v3);\n  else\n    v4 = sub_804E261(v3);\n  v5 = v4;\n  if ( v4 )\n  {\n    v6 = \"%s\";\n    if ( (v2 & 2) == 0 )\n      v6 = \"\\t%s\\n\" + 1;\n    printf(v6, v5);\n    free(v5);\n    sub_80AB247(v8, v9);\n  }\n  return 1;\n}\n"
    ],
    "sub_80968D5": [
        "0x80968d5",
        "void __cdecl __noreturn sub_80968D5(int a1, int a2)\n{\n  const char **v2; // ebx\n  const char *v3; // eax\n  char *v4; // esi\n  int v5; // [esp+0h] [ebp-Ch]\n  int v6; // [esp+4h] [ebp-8h]\n\n  if ( !*(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v2 = (const char **)(a2 + 4);\n  while ( 1 )\n  {\n    v3 = sub_804E2A7(*v2);\n    v4 = (char *)v3;\n    if ( v3 )\n    {\n      puts(v3);\n      free(v4);\n    }\n    else\n    {\n      sub_804D3F1(*v2);\n    }\n    if ( !*++v2 )\n      sub_80AB247(v5, v6);\n  }\n}\n"
    ],
    "sub_8096924": [
        "0x8096924",
        "int __cdecl sub_8096924(int a1, int a2)\n{\n  char v2; // al\n  const char **v3; // esi\n  int v4; // ecx\n  int v5; // ebx\n  int v6; // edi\n  char *v7; // eax\n  char v8; // dl\n  int v10; // [esp-4h] [ebp-10h]\n\n  v2 = sub_80ABEAC(a2, \"^fiRrv\");\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = v10;\n  v5 = -(v2 & 1) & 8;\n  if ( (v2 & 2) != 0 )\n    LOBYTE(v5) = v5 | 0x10;\n  if ( (v2 & 0xC) != 0 )\n    LOBYTE(v5) = v5 | 4;\n  if ( *v3 )\n  {\n    v6 = 0;\n    while ( 1 )\n    {\n      v7 = sub_804D34F(*v3, v4);\n      if ( *v7 == 46 )\n      {\n        v8 = v7[1];\n        if ( !v8 || v8 == 46 && !v7[2] )\n          break;\n      }\n      if ( sub_80B2709() < 0 )\n        goto LABEL_13;\nLABEL_14:\n      if ( !*++v3 )\n        return v6;\n    }\n    sub_804D5F4(\"can't remove '.' or '..'\");\nLABEL_13:\n    v6 = 1;\n    goto LABEL_14;\n  }\n  if ( (v5 & 8) == 0 )\n    sub_804CDC2();\n  return 0;\n}\n"
    ],
    "sub_80969C0": [
        "0x80969c0",
        "int __cdecl sub_80969C0(int a1, int a2)\n{\n  char v2; // di\n  char **v3; // esi\n  int v4; // ebp\n  char *v5; // ebx\n\n  v2 = sub_80ABEC2(a2, 135095121, \"parents\");\n  v3 = (char **)(a2 + 4 * optind);\n  if ( !*v3 )\n    sub_804CDC2();\n  v4 = 0;\n  do\n  {\n    v5 = *v3;\n    while ( 1 )\n    {\n      if ( (v2 & 2) != 0 )\n        printf(\"rmdir: removing directory, '%s'\\n\", v5);\n      if ( rmdir(v5) < 0 )\n        break;\n      if ( (v2 & 1) != 0 )\n      {\n        v5 = dirname(v5);\n        if ( *v5 != 46 || v5[1] )\n          continue;\n      }\n      goto LABEL_14;\n    }\n    if ( (v2 & 4) == 0 || *(_DWORD *)dword_80DBB7C != 39 )\n    {\n      sub_804D3A5((int)\"'%s'\", v5);\n      v4 = 1;\n    }\nLABEL_14:\n    ++v3;\n  }\n  while ( *v3 );\n  return v4;\n}\n"
    ],
    "sub_8096A64": [
        "0x8096a64",
        "int __cdecl sub_8096A64(int a1, int a2)\n{\n  int v2; // edi\n  int v3; // ebx\n  int v4; // edi\n  int v5; // ebx\n  _DWORD *v6; // esi\n  long double v7; // fst7\n  size_t v8; // edx\n  unsigned int v9; // edi\n  const char *v10; // esi\n  const char *v11; // eax\n  unsigned int v12; // esi\n  size_t v13; // eax\n  size_t v14; // esi\n  long double v15; // fst6\n  const char *v16; // edx\n  unsigned int i; // ebx\n  char v18; // fps^1\n  char v19; // fps^1\n  long double v20; // rt0\n  long double v21; // fst6\n  long double v22; // fst7\n  bool v23; // c0\n  char v24; // c2\n  bool v25; // c3\n  char v26; // ah\n  bool v27; // c0\n  char v28; // c2\n  bool v29; // c3\n  long double v30; // rt1\n  int v31; // eax\n  size_t v33; // [esp+14h] [ebp-3Ch]\n  char v34; // [esp+18h] [ebp-38h]\n  double v35; // [esp+20h] [ebp-30h]\n  double v36; // [esp+28h] [ebp-28h]\n  const char *v37; // [esp+38h] [ebp-18h] BYREF\n  char *v38[2]; // [esp+3Ch] [ebp-14h] BYREF\n\n  v38[1] = (char *)&a1;\n  v2 = a1;\n  v3 = a2;\n  v37 = \"\\n\";\n  v34 = sub_80ABEAC(a2, \"+ws:\", &v37);\n  v4 = v2 - optind;\n  v5 = v3 + 4 * optind;\n  v6 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  if ( v4 == 2 )\n  {\n    v36 = 1.0;\n    goto LABEL_7;\n  }\n  if ( v4 == 3 )\n  {\n    v36 = strtod((const char *)*(_DWORD *)(v5 + 4), v38);\n    *v6 |= (unsigned __int8)*v38[0];\nLABEL_7:\n    v35 = strtod((const char *)*(_DWORD *)v5, v38);\n    *v6 |= (unsigned __int8)*v38[0];\n    goto LABEL_8;\n  }\n  if ( v4 != 1 )\n    goto LABEL_10;\n  v36 = 1.0;\n  v35 = 1.0;\nLABEL_8:\n  v7 = strtod((const char *)*(_DWORD *)(v5 + 4 * v4 - 4), v38);\n  if ( *v6 || *v38[0] )\nLABEL_10:\n    sub_804CDC2();\n  v8 = 0;\n  v9 = 0;\n  while ( 1 )\n  {\n    v33 = v8;\n    v10 = *(const char **)v5;\n    v11 = (const char *)strchrnul();\n    v12 = v11 - v10;\n    v13 = strlen(v11);\n    v8 = v33;\n    v7 = (double)v7;\n    if ( v9 < v12 )\n      v9 = v12;\n    v5 += 4;\n    if ( !*(_DWORD *)v5 )\n      break;\n    if ( v33 < v13 )\n      v8 = v13;\n  }\n  v14 = 0;\n  if ( v33 )\n  {\n    v14 = v33 - 1;\n    if ( v33 != 1 )\n      v9 += v33;\n  }\n  if ( (v34 & 1) == 0 )\n    v9 = 0;\n  v15 = v35;\n  v16 = &data;\n  for ( i = 0; ; v15 = (long double)i * v36 + v35 )\n  {\n    if ( v36 < 0.0 )\n    {\n      v27 = v15 < v7;\n      v28 = 0;\n      v29 = v15 == v7;\n      v26 = v18;\n      v30 = v15;\n      v21 = v7;\n      v22 = v30;\n    }\n    else\n    {\n      v20 = v15;\n      v21 = v7;\n      v22 = v20;\n      v23 = v21 < v20;\n      v24 = 0;\n      v25 = v21 == v20;\n      v26 = v19;\n    }\n    if ( (v26 & 1) != 0 )\n      break;\n    v31 = printf(\"%s%0*.*f\", v16, v9, v14, (double)v22);\n    v7 = (double)v21;\n    if ( v31 < 0 )\n      break;\n    v16 = v37;\n    ++i;\n  }\n  if ( i )\n    sub_804DD98(10);\n  return sub_804DD8F();\n}\n"
    ],
    "sub_8096C22": [
        "0x8096c22",
        "int __cdecl sub_8096C22(int a1, int a2)\n{\n  _DWORD *v2; // edi\n  int v3; // ebx\n  const char *v4; // esi\n  unsigned int i; // ebp\n  __int64 v7; // [esp+0h] [ebp-88h]\n  char v8; // [esp+8h] [ebp-80h]\n  int v9; // [esp+Ch] [ebp-7Ch]\n  int v10; // [esp+10h] [ebp-78h]\n  unsigned int v11; // [esp+14h] [ebp-74h] BYREF\n  __int64 v12; // [esp+44h] [ebp-44h]\n\n  v11 = 3;\n  v8 = sub_80ABEAC(a2, \"fuzn:+vx\", &v11);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  v10 = sub_804DBE1(\"/dev/zero\");\n  if ( v11 )\n    v9 = sub_804DBE1(\"/dev/urandom\");\n  if ( !*v2 )\n    sub_804CDC2();\n  while ( 1 )\n  {\n    v4 = (const char *)*v2++;\n    if ( !v4 )\n      return 0;\n    if ( (v8 & 1) == 0 )\n      goto LABEL_6;\n    v3 = open64();\n    if ( v3 < 0 )\n    {\n      chmod(v4, 0x1B6u);\nLABEL_6:\n      v3 = sub_804DBE1(v4);\n    }\n    if ( !fstat64() )\n    {\n      v7 = v12;\n      if ( v12 > 0 )\n      {\n        for ( i = 0; v11 > i; ++i )\n        {\n          sub_804E4ED(v9, v3, v7);\n          fdatasync(v3);\n          sub_804DD09(0, 0, 0);\n        }\n        if ( (v8 & 4) != 0 )\n        {\n          sub_804E4ED(v10, v3, v7);\n          fdatasync(v3);\n        }\n        if ( (v8 & 2) != 0 )\n        {\n          ftruncate64();\n          sub_804DC28(v4);\n        }\n        sub_804DCF3(v3);\n      }\n    }\n  }\n}\n"
    ],
    "sub_8096D7F": [
        "0x8096d7f",
        "int __cdecl sub_8096D7F(char a1, int a2)\n{\n  const char **v2; // edi\n  long double v3; // fst7\n  const char *v4; // esi\n  char *v5; // ebx\n  int v6; // ecx\n  long double v7; // fst7\n  int v9; // [esp-4h] [ebp-4Ch]\n  double v10; // [esp+8h] [ebp-40h]\n  double v11; // [esp+10h] [ebp-38h]\n  char v12; // [esp+10h] [ebp-38h]\n  char v13; // [esp+18h] [ebp-30h]\n  struct timespec remaining; // [esp+30h] [ebp-18h] BYREF\n  char *v15; // [esp+38h] [ebp-10h]\n\n  v15 = &a1;\n  if ( !*(_DWORD *)(a2 + 4) )\nLABEL_2:\n    sub_804CDC2();\n  v2 = (const char **)(a2 + 4);\n  v3 = 0.0;\n  do\n  {\n    v4 = *v2;\n    v11 = v3;\n    if ( strchr(*v2, 46) )\n    {\n      v5 = (char *)&v4[strspn(v4, \"0123456789.\")];\n      v13 = *v5;\n      *v5 = 0;\n      *(_DWORD *)dword_80DBB7C = 0;\n      v7 = strtod(v4, (char **)&remaining);\n      if ( *(_DWORD *)dword_80DBB7C || *(_BYTE *)remaining.tv_sec )\n        goto LABEL_2;\n      v10 = v11;\n      *v5 = v13;\n      LOBYTE(v6) = *(v5 - 1);\n      v12 = v6;\n      *(v5 - 1) = 49;\n      v3 = (long double)(unsigned int)sub_80B40DC(v6, &unk_80B6720) * (double)v7 + v10;\n      *(v5 - 1) = v12;\n    }\n    else\n    {\n      v3 = (long double)(unsigned int)sub_80B40DC(v9, &unk_80B6720) + (double)v3;\n    }\n    ++v2;\n  }\n  while ( *v2 );\n  remaining.tv_sec = 0x7FFFFFFF;\n  remaining.tv_nsec = 0;\n  if ( v3 >= 0.0 && v3 < 2147483647.0 )\n  {\n    remaining.tv_sec = (int)v3;\n    remaining.tv_nsec = (int)((v3 - (long double)(int)v3) * 1000000000.0);\n  }\n  do\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    nanosleep(&remaining, &remaining);\n  }\n  while ( *(_DWORD *)dword_80DBB7C == 4 );\n  return 0;\n}\n"
    ],
    "sub_8096F11": [
        "0x8096f11",
        "unsigned int __usercall sub_8096F11@<eax>(const char **a1@<eax>)\n{\n  unsigned int result; // eax\n\n  if ( (unsigned __int8)(**a1 - 48) > 9u || (result = strtoul(*a1, (char **)a1, 10)) == 0 )\n    sub_804D5E0(\"bad field specification\");\n  return result;\n}\n"
    ],
    "sub_8096F38": [
        "0x8096f38",
        "const char *__usercall sub_8096F38@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4@<esi>)\n{\n  const char *v4; // ebx\n  int v6; // edx\n  char v7; // al\n  unsigned int v8; // edi\n  int v9; // ecx\n  char v10; // dl\n  char v11; // dl\n  int v12; // edx\n  const char *v13; // eax\n  char *v14; // edi\n  int v15; // edx\n  char v16; // al\n  const char *v17; // ecx\n  int v18; // edx\n  unsigned __int8 v19; // al\n  char *v20; // edi\n  char *v21; // edx\n  char v22; // al\n  signed int v24; // [esp+0h] [ebp-2Ch]\n  int i; // [esp+4h] [ebp-28h]\n  int v27; // [esp+Ch] [ebp-20h]\n  signed int v28; // [esp+10h] [ebp-1Ch]\n  unsigned int v29; // [esp+18h] [ebp-14h]\n\n  v4 = a1;\n  v27 = a2[2];\n  v28 = a2[4];\n  if ( a2[1] == 1 && !v27 && !a2[3] && !v28 && (a3 & 0x80000E80) == 0 )\n    return v4;\n  v24 = strlen(a1);\n  for ( i = 0; ; i = 1 )\n  {\n    v6 = a2[2 * i + 1];\n    if ( v6 )\n      break;\n    v9 = v24;\n    if ( i )\n      goto LABEL_29;\n    a4 = v24;\nLABEL_27:\n    ;\n  }\n  v7 = 0;\n  v8 = 1;\n  v9 = 0;\n  v29 = i + v6;\n  while ( v29 > v8 )\n  {\n    if ( byte_80DB771 )\n    {\n      do\n      {\n        v10 = v4[v9];\n        v7 = v10;\n        if ( !v10 )\n          break;\n        ++v9;\n      }\n      while ( byte_80DB771 != v10 );\n    }\n    else\n    {\n      while ( (unsigned __int8)(v4[v9] - 9) <= 4u || v4[v9] == 32 )\n        ++v9;\n      while ( 1 )\n      {\n        v11 = v4[v9];\n        if ( (v11 & 0xDF) == 0 || (unsigned __int8)(v11 - 9) <= 4u )\n          break;\n        ++v9;\n      }\n    }\n    ++v8;\n  }\n  if ( !i )\n  {\n    a4 = v9;\n    goto LABEL_27;\n  }\n  if ( v7 )\n    --v9;\nLABEL_29:\n  if ( (a3 & 0x80) != 0 )\n  {\n    while ( v4[a4] == 32 || (unsigned __int8)(v4[a4] - 9) <= 4u )\n      ++a4;\n  }\n  if ( a3 < 0 )\n  {\n    while ( a4 < v9 && ((unsigned __int8)(v4[v9 - 1] - 9) <= 4u || v4[v9 - 1] == 32) )\n      --v9;\n  }\n  if ( v28 )\n  {\n    v9 = v28;\n    if ( v28 > v24 )\n      v9 = v24;\n  }\n  if ( v27 )\n  {\n    a4 = a4 + v27 - 1;\n    if ( a4 > v24 )\n      a4 = v24;\n  }\n  v12 = a4;\n  if ( a4 < v9 )\n    v12 = v9;\n  v13 = sub_804DB5D(&v4[a4], v12 - a4);\n  v4 = v13;\n  if ( (a3 & 0x200) != 0 )\n  {\n    v14 = (char *)v13;\n    v15 = 0;\n    while ( 1 )\n    {\n      v16 = *v14;\n      if ( !*v14 )\n        break;\n      if ( v16 == 32\n        || (unsigned __int8)(v16 - 9) <= 4u\n        || (unsigned __int8)(v16 - 48) <= 9u\n        || (unsigned __int8)((v16 | 0x20) - 97) <= 0x19u )\n      {\n        v4[v15++] = v16;\n      }\n      ++v14;\n    }\n    v4[v15] = 0;\n  }\n  if ( (a3 & 0x800) != 0 )\n  {\n    v17 = v4;\n    v18 = 0;\n    while ( 1 )\n    {\n      v19 = *v17;\n      v20 = (char *)&v4[v18];\n      if ( !*v17 )\n        break;\n      if ( (unsigned int)v19 - 32 <= 0x5E )\n      {\n        ++v18;\n        *v20 = v19;\n      }\n      ++v17;\n    }\n    *v20 = 0;\n  }\n  v21 = (char *)v4;\n  if ( (a3 & 0x400) != 0 )\n  {\n    while ( 1 )\n    {\n      v22 = *v21;\n      if ( !*v21 )\n        break;\n      if ( (unsigned __int8)(v22 - 97) <= 0x19u )\n        v22 -= 32;\n      *v21++ = v22;\n    }\n  }\n  return v4;\n}\n"
    ],
    "sub_8097139": [
        "0x8097139",
        "int __cdecl sub_8097139(const char **a1, const char **a2)\n{\n  int v2; // esi\n  char *v3; // edi\n  const char *v4; // eax\n  char *v5; // ebx\n  int v6; // edx\n  int v7; // edx\n  long double v8; // fst7\n  bool v9; // zf\n  long double v10; // fst5\n  bool v11; // dl\n  long double v12; // fst6\n  char v13; // fps^1\n  bool v14; // c0\n  char v15; // c2\n  bool v16; // c3\n  char v17; // ah\n  int v18; // eax\n  long double v19; // fst7\n  char v20; // fps^1\n  bool v21; // c0\n  char v22; // c2\n  bool v23; // c3\n  const char *v24; // edi\n  size_t v25; // ebx\n  double v27; // [esp+Ch] [ebp-58h]\n  int v28; // [esp+Ch] [ebp-58h]\n  double v29; // [esp+Ch] [ebp-58h]\n  int v30; // [esp+Ch] [ebp-58h]\n  int v31; // [esp+Ch] [ebp-58h]\n  int v32; // [esp+14h] [ebp-50h]\n  const char **v33; // [esp+18h] [ebp-4Ch]\n  const char **v34; // [esp+1Ch] [ebp-48h]\n  _DWORD *v35; // [esp+20h] [ebp-44h]\n  const char *v36; // [esp+20h] [ebp-44h]\n  char *v37; // [esp+24h] [ebp-40h] BYREF\n  char *v38; // [esp+28h] [ebp-3Ch] BYREF\n  int v39; // [esp+38h] [ebp-2Ch]\n  const void **v40; // [esp+54h] [ebp-10h]\n\n  v40 = (const void **)&a1;\n  v34 = a1;\n  v33 = a2;\n  LOWORD(v2) = dword_80DBB9C;\n  v35 = (_DWORD *)dword_80DB724;\n  while ( v35 )\n  {\n    v2 = dword_80DBB9C;\n    if ( v35[5] )\n      v2 = v35[5];\n    v3 = (char *)sub_8096F38(*v34, v35, v2, v2);\n    v4 = sub_8096F38(*v33, v35, v2, v2);\n    v5 = (char *)v4;\n    v6 = v2 & 7;\n    if ( v6 == 1 )\n    {\n      v29 = atof(v3);\n      v19 = atof(v5);\n      v7 = 1;\n      if ( v29 <= v19 )\n      {\n        v21 = v19 < v29;\n        v22 = 0;\n        v23 = v19 == v29;\n        v17 = v20;\n        goto LABEL_35;\n      }\n    }\n    else\n    {\n      if ( (v2 & 7u) <= 1 )\n      {\n        if ( (v2 & 7) != 0 )\n          goto LABEL_11;\n        v7 = strcmp(v3, v4);\n        goto LABEL_37;\n      }\n      if ( v6 != 2 )\n      {\n        if ( v6 != 4 )\nLABEL_11:\n          sub_804D5E0(\"unknown sort type\");\n        v32 = strptime();\n        v28 = v39;\n        v18 = strptime();\n        if ( v32 )\n        {\n          v7 = 1;\n          if ( v18 )\n            v7 = v28 - v39;\n          goto LABEL_37;\n        }\n        v9 = v18 == 0;\n        goto LABEL_30;\n      }\n      v27 = strtod(v3, &v37);\n      v8 = strtod(v5, &v38);\n      if ( v37 == v3 )\n      {\n        v9 = v38 == v5;\nLABEL_30:\n        v11 = !v9;\n        goto LABEL_36;\n      }\n      v7 = 1;\n      if ( v38 != v5 )\n      {\n        v10 = 1.0 / v8;\n        if ( 1.0 / v27 == 0.0 )\n        {\n          if ( v27 >= 0.0 )\n          {\n            v7 = v10 != 0.0 || v8 <= 0.0;\n            goto LABEL_37;\n          }\n          if ( v10 == 0.0 )\n          {\n            v11 = v8 >= 0.0;\nLABEL_36:\n            v7 = -v11;\n            goto LABEL_37;\n          }\n          v7 = -1;\n        }\n        else if ( v10 == 0.0 )\n        {\n          v7 = 2 * (v8 < 0.0) - 1;\n        }\n        else\n        {\n          v12 = v27;\n          v7 = 1;\n          if ( v27 <= v8 )\n          {\n            v14 = v8 < v12;\n            v15 = 0;\n            v16 = v8 == v12;\n            v17 = v13;\nLABEL_35:\n            v11 = (v17 & 1) == 0 && (v17 & 0x40) == 0;\n            goto LABEL_36;\n          }\n        }\n      }\n    }\nLABEL_37:\n    if ( *v34 != v3 )\n    {\n      v30 = v7;\n      free(v3);\n      v7 = v30;\n    }\n    if ( *v33 != v5 )\n    {\n      v31 = v7;\n      free(v5);\n      v7 = v31;\n    }\n    v35 = (_DWORD *)*v35;\n    if ( v7 )\n      goto LABEL_45;\n  }\n  if ( (dword_80DBB9C & 0x20) != 0 )\n  {\n    v24 = *v34;\n    v25 = strlen(*v34);\n    v36 = *v33;\n    v7 = *(_DWORD *)&v36[(strlen(*v33) + 4) & 0xFFFFFFFC] < *(_DWORD *)&v24[(v25 + 4) & 0xFFFFFFFC] ? 1 : -1;\n  }\n  else\n  {\n    v7 = 0;\n    if ( (dword_80DBB9C & 0x40000000) == 0 )\n    {\n      LOWORD(v2) = dword_80DBB9C;\n      v7 = strcmp(*v34, *v33);\n    }\n  }\nLABEL_45:\n  if ( (v2 & 0x100) != 0 )\n    return -v7;\n  return v7;\n}\n"
    ],
    "sub_8097445": [
        "0x8097445",
        "int __cdecl sub_8097445(int a1, int a2)\n{\n  int v2; // eax\n  _DWORD *v3; // esi\n  int v4; // ebx\n  char *v5; // ebp\n  const char *v6; // ebp\n  char *v7; // eax\n  int *v8; // eax\n  int *v9; // ebx\n  char *v10; // ecx\n  int v11; // eax\n  _DWORD *v12; // edi\n  signed int v13; // esi\n  const char **v14; // ebx\n  int v15; // eax\n  const char *v16; // ebp\n  int n; // ebp\n  int v19; // ebp\n  int k; // edi\n  int j; // ebp\n  size_t v22; // edi\n  const char *v23; // eax\n  int v24; // eax\n  int v25; // ebp\n  int m; // edi\n  int v27; // [esp+0h] [ebp-2Ch]\n  char *v28; // [esp+0h] [ebp-2Ch]\n  int v29; // [esp+0h] [ebp-2Ch]\n  int i; // [esp+4h] [ebp-28h]\n  char v31[4]; // [esp+8h] [ebp-24h] BYREF\n  const char *v32; // [esp+Ch] [ebp-20h] BYREF\n  char *v33; // [esp+10h] [ebp-1Ch] BYREF\n  int v34; // [esp+14h] [ebp-18h] BYREF\n  const char *v35[5]; // [esp+18h] [ebp-14h] BYREF\n\n  v34 = 0;\n  byte_80DB560 = 2;\n  v2 = sub_80ABEAC(a2, \"^ngMucszbrdfimS:T:o:k:*t:\", v31, v31, &v32, &v34, &v33);\n  if ( (v2 & 0x80u) != 0 )\n    dword_80DBB9C |= 0x80000000;\n  if ( (v2 & 0x20000) != 0 )\n  {\n    if ( !*v33 || v33[1] )\n      sub_804D5E0(\"bad -t parameter\");\n    byte_80DB771 = *v33;\n  }\n  while ( v34 )\n  {\n    v8 = (int *)dword_80DB724;\n    v9 = &dword_80DB724;\n    while ( v8 )\n    {\n      v9 = v8;\n      v8 = (int *)*v8;\n    }\n    v3 = sub_804DB2E(0x18u);\n    *v9 = (int)v3;\n    v35[0] = (const char *)sub_80AFB01(v27);\n    v4 = 0;\nLABEL_9:\n    while ( *v35[0] )\n    {\n      v5 = (char *)&v3[2 * v4];\n      *((_DWORD *)v5 + 1) = sub_8096F11(v35);\n      if ( *v35[0] == 46 )\n      {\n        ++v35[0];\n        *((_DWORD *)v5 + 2) = sub_8096F11(v35);\n      }\n      while ( *v35[0] )\n      {\n        v6 = v35[0] + 1;\n        if ( *v35[0] == 44 )\n        {\n          if ( !v4 )\n          {\n            ++v35[0];\n            v4 = 1;\n            goto LABEL_9;\n          }\n          ++v4;\n        }\n        v7 = strchr(\"ngMucszbrdfimS:T:o:k:*t:\", (unsigned __int8)*v35[0]);\n        if ( !v7 )\n          sub_804D5E0(\"unknown key option\");\n        v10 = v7 - 135096721;\n        v11 = 1 << ((_BYTE)v7 + 111);\n        if ( (v11 & 0xFFFFF078) != 0 )\n          sub_804D5E0(\"unknown sort type\");\n        if ( v10 == (char *)7 )\n        {\n          if ( v4 )\n            v11 = 0x80000000;\n        }\n        v3[5] |= v11;\n        v35[0] = v6;\n      }\n    }\n  }\n  v12 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v12 )\n    *--v12 = \"-\";\n  v13 = 0;\n  v14 = 0;\n  do\n  {\n    v28 = (char *)sub_80B3D9B();\n    for ( i = v13; ; ++i )\n    {\n      v15 = (dword_80DBB9C & 0x40) != 0 ? sub_80AB7A9() : sub_80AB85A();\n      v16 = (const char *)v15;\n      if ( !v15 )\n        break;\n      v14 = (const char **)sub_80B4733(v13++, 1030);\n      v14[i] = v16;\n    }\n    sub_80AB218();\n    ++v12;\n  }\n  while ( *v12 );\n  if ( !dword_80DB724 )\n  {\n    dword_80DB724 = (int)sub_804DB2E(0x18u);\n    *(_DWORD *)(dword_80DB724 + 4) = 1;\n  }\n  if ( (dword_80DBB9C & 0x10) == 0 )\n  {\n    if ( (dword_80DBB9C & 0x20) != 0 )\n    {\n      for ( j = 0; j != v13; ++j )\n      {\n        v28 = (char *)v14[j];\n        v22 = (strlen(v28) + 4) & 0xFFFFFFFC;\n        v23 = (const char *)sub_804DB13(v28, v22 + 4);\n        v14[j] = v23;\n        *(_DWORD *)&v23[v22] = j;\n      }\n    }\n    qsort(v14, v13, 4u, (__compar_fn_t)sub_8097139);\n    if ( (dword_80DBB9C & 8) != 0 )\n    {\n      dword_80DBB9C |= 0x40000000u;\n      v19 = 0;\n      for ( k = 1; k < v13; ++k )\n      {\n        v28 = (char *)(4 * v19);\n        if ( sub_8097139(&v14[v19], &v14[k]) )\n        {\n          ++v19;\n          *(_DWORD *)&v28[(_DWORD)v14 + 4] = v14[k];\n        }\n        else\n        {\n          free((void *)v14[k]);\n        }\n      }\n      if ( v13 )\n        v13 = v19 + 1;\n    }\n    if ( (dword_80DBB9C & 0x8000) != 0 )\n    {\n      v24 = sub_804DBE1(v32);\n      sub_804DC97(v24, 1);\n    }\n    v25 = (dword_80DBB9C & 0x40) == 0 ? 0xA : 0;\n    for ( m = 0; m != v13; ++m )\n      printf(\"%s%c\", v14[m], v25);\n    sub_80AB247(v28, i * 4);\n  }\n  v29 = dword_80DBB9C << 28 >> 31;\n  for ( n = 1; n < v13; ++n )\n  {\n    if ( sub_8097139(v14, v14 + 1) > v29 )\n    {\n      fprintf(stderr, \"Check line %u\\n\", n);\n      return 1;\n    }\n    ++v14;\n  }\n  return 0;\n}\n"
    ],
    "sub_8097799": [
        "0x8097799",
        "unsigned int __usercall sub_8097799@<eax>(unsigned int result@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)\n{\n  unsigned int v3; // ebx\n  int *v4; // ebx\n  int v5; // ecx\n  int v6; // ecx\n  unsigned int v7; // eax\n  unsigned int v8; // eax\n  unsigned int v9; // ebx\n  unsigned int v10; // ebx\n  int i; // eax\n  unsigned int v12; // edx\n  int *v13; // ebx\n  int v14; // edx\n  int v15; // edx\n  unsigned int v16; // eax\n  unsigned int v17; // eax\n  unsigned int v18; // ebx\n  unsigned int v19; // ebx\n  unsigned int v20; // eax\n  unsigned int v21; // ebx\n  unsigned int v22; // esi\n  unsigned int v23; // ebx\n  unsigned int v24; // eax\n  unsigned int v25; // esi\n  unsigned int v26; // ebx\n\n  v3 = *(unsigned __int8 *)result;\n  if ( v3 <= 3 )\n  {\n    v4 = (int *)((char *)a3 + (unsigned __int8)byte_80D6B85[v3]);\n    if ( v4 )\n    {\n      v5 = *v4 & ~*(unsigned __int16 *)(result + 2);\n      result = *(_DWORD *)(result + 4);\n      if ( a2 )\n      {\n        result = ~result;\n        v6 = result & v5;\n      }\n      else\n      {\n        v6 = result | v5;\n      }\n      *v4 = v6;\n      return result;\n    }\n  }\n  if ( (char *)result == &byte_80B6780 || (_UNKNOWN *)result == &unk_80B6788 )\n  {\n    v7 = a3[2];\n    if ( !a2 )\n    {\n      result = v7 & 0xFFFFFCCF | 0x120;\nLABEL_11:\n      a3[2] = result;\n      return result;\n    }\nLABEL_14:\n    result = v7 & 0xFFFFFECF | 0x30;\n    goto LABEL_11;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B6790 )\n  {\n    v7 = a3[2];\n    if ( !a2 )\n    {\n      result = v7 & 0xFFFFFCCF | 0x320;\n      goto LABEL_11;\n    }\n    goto LABEL_14;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B6798 )\n  {\n    v8 = a3[1];\n    v9 = *a3;\n    if ( a2 )\n    {\n      v10 = v9 & 0xFFFFFE3F;\n      BYTE1(v10) |= 1u;\n      *a3 = v10;\n      result = v8 & 0xFFFFFFD3 | 4;\n    }\n    else\n    {\n      BYTE1(v9) &= ~1u;\n      *a3 = v9;\n      result = v8 & 0xFFFFFFFB;\n    }\nLABEL_72:\n    a3[1] = result;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67A0 )\n  {\n    *(_WORD *)((char *)a3 + 19) = 5503;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67A8 )\n  {\n    for ( i = 0; i != 34; i += 2 )\n      *((_BYTE *)a3 + (unsigned __int8)byte_80B8619[i] + 17) = byte_80B8618[i];\n    result = (unsigned int)&byte_80B6780;\n    while ( 1 )\n    {\n      v12 = *(unsigned __int8 *)result;\n      if ( v12 > 3 )\n        goto LABEL_33;\n      v13 = (int *)((char *)a3 + (unsigned __int8)byte_80D6B85[v12]);\n      if ( !v13 )\n        goto LABEL_33;\n      v14 = *v13 & ~*(unsigned __int16 *)(result + 2);\n      if ( (*(_BYTE *)(result + 1) & 1) != 0 )\n        break;\n      if ( (*(_BYTE *)(result + 1) & 2) != 0 )\n      {\n        v15 = ~*(_DWORD *)(result + 4) & v14;\n        goto LABEL_32;\n      }\nLABEL_33:\n      result += 8;\n      if ( &byte_80B6A40 == (char *)result )\n        return result;\n    }\n    v15 = *(_DWORD *)(result + 4) | v14;\nLABEL_32:\n    *v13 = v15;\n    goto LABEL_33;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67D0 )\n  {\n    v16 = a3[3];\n    if ( a2 )\n      result = v16 | 2;\n    else\n      result = v16 & 0xFFFFFFFD;\n    a3[3] = result;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67C0 )\n  {\n    v17 = a3[2] & 0xFFFFFECF;\n    v18 = *a3;\n    if ( a2 )\n    {\n      result = v17 | 0x120;\n      a3[2] = result;\n      v19 = v18 | 0x20;\n    }\n    else\n    {\n      result = v17 | 0x30;\n      a3[2] = result;\n      v19 = v18 & 0xFFFFFFDF;\n    }\n    *a3 = v19;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67C8 )\n  {\n    v20 = a3[2] & 0xFFFFFECF;\n    v21 = a3[1];\n    v22 = *a3;\n    if ( a2 )\n    {\n      result = v20 | 0x120;\n      a3[2] = result;\n      *a3 = v22 | 0x20;\n      v23 = v21 | 1;\n    }\n    else\n    {\n      result = v20 | 0x30;\n      a3[2] = result;\n      *a3 = v22 & 0xFFFFFFDF;\n      v23 = v21 & 0xFFFFFFFE;\n    }\n    a3[1] = v23;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67B8 )\n  {\n    if ( a2 )\n    {\nLABEL_56:\n      *a3 |= 0x526u;\n      a3[1] |= 1u;\n      a3[3] |= 3u;\n      return result;\n    }\nLABEL_57:\n    *a3 = 0;\n    a3[1] &= ~1u;\n    a3[3] &= 0xFFFFFFF8;\n    *((_WORD *)a3 + 11) = 256;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67B0 )\n  {\n    if ( !a2 )\n      goto LABEL_56;\n    goto LABEL_57;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67E8 )\n  {\n    result = *a3;\n    if ( a2 )\n      BYTE1(result) |= 8u;\n    else\n      BYTE1(result) &= ~8u;\n    *a3 = result;\n  }\n  else\n  {\n    if ( (_UNKNOWN *)result == &unk_80B67F0 )\n    {\n      result = a3[1];\n      if ( a2 )\n        BYTE1(result) |= 0x18u;\n      else\n        BYTE1(result) &= 0xE7u;\n      goto LABEL_72;\n    }\n    if ( (_UNKNOWN *)result == &unk_80B67F8 || (_UNKNOWN *)result == &unk_80B6800 )\n    {\n      v24 = a3[1];\n      v25 = a3[3];\n      v26 = *a3;\n      if ( a2 )\n      {\n        a3[3] = v25 & 0xFFFFFFFB;\n        BYTE1(v26) &= ~2u;\n        *a3 = v26;\n        result = v24 & 0xFFFFFFFD;\n      }\n      else\n      {\n        a3[3] = v25 | 4;\n        BYTE1(v26) |= 2u;\n        *a3 = v26;\n        result = v24 | 2;\n      }\n      goto LABEL_72;\n    }\n    if ( (_UNKNOWN *)result == &unk_80B67D8 )\n    {\n      a3[3] |= 0xA10u;\n    }\n    else if ( (_UNKNOWN *)result == &unk_80B67E0 )\n    {\n      *((_BYTE *)a3 + 17) = 3;\n      *(_WORD *)((char *)a3 + 19) = 5503;\n      a3[3] |= 0xA10u;\n      *a3 &= ~0x800u;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_8097A48": [
        "0x8097a48",
        "int __cdecl sub_8097A48(_DWORD *a1)\n{\n  int i; // esi\n\n  printf(\"%lx:%lx:%lx:%lx\", *a1, a1[1], a1[2], a1[3]);\n  for ( i = 0; i != 32; ++i )\n    printf(\":%x\", *((unsigned __int8 *)a1 + i + 17));\n  return sub_804DD98(10);\n}\n"
    ],
    "sub_8097A8C": [
        "0x8097a8c",
        "char *sub_8097A8C(char *format, ...)\n{\n  char *result; // eax\n  char *v2; // esi\n  char *v3; // ebx\n  time_t v4; // eax\n  int v5; // eax\n  char v6; // [esp-1h] [ebp-8Dh]\n  char s[140]; // [esp+0h] [ebp-8Ch] BYREF\n  va_list __varargs; // [esp+94h] [ebp+8h] BYREF\n\n  va_start(__varargs, format);\n  result = (char *)vsnprintf(s, 0x80u, format, __varargs);\n  v2 = result - 1;\n  if ( (unsigned int)(result - 1) <= 0x7E )\n  {\n    v3 = result;\n    if ( unk_80DB780 )\n    {\n      v4 = ++unk_80DB780;\n      if ( s[0] != 10 )\n      {\n        if ( (unsigned int)&v3[v4] < HIDWORD(qword_80DB778) )\n        {\n          v5 = 32;\n        }\n        else\n        {\n          unk_80DB780 = 0;\n          v5 = 10;\n        }\n        sub_804DD98(v5);\n      }\n    }\n    v6 = HIBYTE(stdout);\n    fputs_unlocked();\n    unk_80DB780 += (time_t)v3;\n    result = s;\n    if ( s[(_DWORD)v2] == 10 )\n      unk_80DB780 = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_8097B22": [
        "0x8097b22",
        "int sub_8097B22()\n{\n  int result; // eax\n  int v1; // [esp-4h] [ebp-4h]\n\n  if ( unk_80DB780 )\n  {\n    sub_8097A8C((char *)\"\\n\");\n    return v1;\n  }\n  return result;\n}\n"
    ],
    "sub_8097B37": [
        "0x8097b37",
        "char *__usercall sub_8097B37@<eax>(const char *a1@<eax>)\n{\n  int v1; // eax\n\n  v1 = sub_804D222(\"evenp\", a1);\n  if ( v1 < 0 )\n    return 0;\n  else\n    return &byte_80B6780[8 * v1];\n}\n"
    ],
    "sub_8097B52": [
        "0x8097b52",
        "char __usercall sub_8097B52@<al>(const char *a1@<eax>)\n{\n  int v1; // edx\n  char result; // al\n\n  v1 = sub_804D222(\"line\", a1);\n  result = v1 + 1;\n  if ( v1 != -1 && (unsigned int)(v1 - 4) > 1 )\n    return result | 0x80;\n  return result;\n}\n"
    ],
    "sub_8097B6E": [
        "0x8097b6e",
        "int __usercall sub_8097B6E@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4@<ebx>)\n{\n  char v7; // dl\n  char v8; // bp\n\n  if ( (_UNKNOWN *)a1 == &unk_80B8636 || (_UNKNOWN *)a1 == &unk_80B8638 )\n  {\nLABEL_3:\n    v7 = sub_80B40B8(&unk_80B6760);\n    goto LABEL_12;\n  }\n  v7 = *a2;\n  if ( v7 )\n  {\n    v8 = a2[1];\n    if ( v8 )\n    {\n      HIBYTE(a4) = v7;\n      if ( !strcmp(a2, \"^-\") || !strcmp(a2, \"undef\") )\n      {\n        v7 = 0;\n        goto LABEL_12;\n      }\n      if ( HIBYTE(a4) != 94 )\n        goto LABEL_3;\n      v7 = v8 & 0x1F;\n      if ( v8 == 63 )\n        v7 = 127;\n    }\n  }\nLABEL_12:\n  *(_BYTE *)(a3 + *(unsigned __int8 *)(a1 + 1) + 17) = v7;\n  return a4;\n}\n"
    ],
    "sub_8097BFB": [
        "0x8097bfb",
        "char *__usercall sub_8097BFB@<eax>(int a1@<eax>)\n{\n  char *result; // eax\n  char *v3; // eax\n  int v4; // [esp+0h] [ebp-Ch] BYREF\n  int v5; // [esp+4h] [ebp-8h] BYREF\n\n  if ( sub_804D878(0, &v4, &v5) )\n  {\n    if ( *(_DWORD *)dword_80DBB7C == 22 )\n    {\n      result = \"\";\n      if ( a1 )\n        return result;\n    }\n    else\n    {\n      result = \"%s\";\n    }\n    return (char *)sub_804D3A5((int)result);\n  }\n  v3 = \"rows %u; columns %u;\";\n  if ( !a1 )\n    v3 = \"%u %u\\n\";\n  return sub_8097A8C(v3, v5, v4);\n}\n"
    ],
    "sub_8097C61": [
        "0x8097c61",
        "char *__usercall sub_8097C61@<eax>(const struct termios *a1@<eax>, int a2@<edx>)\n{\n  speed_t v4; // esi\n  speed_t v5; // eax\n  char *v6; // ebx\n  int v7; // edi\n  int v8; // edx\n  int v9; // ecx\n  int v10; // eax\n  int v12; // [esp-8h] [ebp-14h]\n  int v13; // [esp-4h] [ebp-10h]\n\n  v4 = cfgetispeed(a1);\n  v5 = cfgetospeed(a1);\n  if ( !v4 || (v6 = \"%lu %lu\\n\", v4 == v5) )\n    v6 = \"%lu\\n\";\n  if ( a2 )\n    v6 += 9;\n  v7 = sub_80B2EC7(v13, v12);\n  v10 = sub_80B2EC7(v9, v8);\n  return sub_8097A8C(v6, v10, v7);\n}\n"
    ],
    "sub_8097CB0": [
        "0x8097cb0",
        "int __cdecl sub_8097CB0(const struct termios *a1, int a2)\n{\n  int i; // ebx\n  const char *v3; // eax\n  unsigned int v4; // eax\n  int v5; // ebx\n  char v6; // di\n  unsigned int v7; // ebp\n  _DWORD *v8; // edx\n  unsigned __int16 v9; // cx\n  int v10; // eax\n  const char *v12; // [esp-4h] [ebp-24h]\n  const char *v13; // [esp-4h] [ebp-24h]\n  char dest[26]; // [esp+6h] [ebp-1Ah] BYREF\n\n  sub_8097C61(a1, 1);\n  if ( a2 )\n    sub_8097BFB(1);\n  sub_8097A8C(\"line = %u;\\n\", a1->c_line);\n  for ( i = 0; i != 15; ++i )\n  {\n    if ( a1->c_cc[(unsigned __int8)byte_80B8619[2 * i]] )\n      sub_80B0C15(0, dest);\n    else\n      strcpy(dest, \"<undef>\");\n    v3 = sub_804D2B4(\"intr\", i);\n    sub_8097A8C(\"%s = %s;\", v3, dest);\n  }\n  sub_8097A8C(\"min = %u; time = %u;\", a1->c_cc[6], a1->c_cc[5]);\n  sub_8097B22();\n  v4 = 0;\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = byte_80B6781[8 * v5];\n    v7 = v4;\n    if ( (v6 & 8) != 0 )\n      goto LABEL_25;\n    v7 = (unsigned __int8)byte_80B6780[8 * v5];\n    if ( v7 != v4 )\n      sub_8097B22();\n    v8 = 0;\n    if ( v7 <= 3 )\n      v8 = (tcflag_t *)((char *)&a1->c_iflag + (unsigned __int8)byte_80D6B85[v7]);\n    v9 = word_80B6782[4 * v5];\n    v10 = dword_80B6784[2 * v5];\n    if ( v9 )\n      v10 = v9;\n    if ( (*v8 & v10) == dword_80B6784[2 * v5] )\n    {\n      if ( a2 || (v6 & 2) != 0 )\n      {\n        v12 = sub_804D2B4(\"evenp\", v5);\n        sub_8097A8C((char *)\"%s\", v12);\n      }\n    }\n    else\n    {\n      if ( !a2 )\n      {\n        if ( (v6 & 5) != 5 )\n          goto LABEL_25;\nLABEL_24:\n        v13 = sub_804D2B4(\"evenp\", v5);\n        sub_8097A8C((char *)\"-%s\", v13);\n        goto LABEL_25;\n      }\n      if ( (v6 & 4) != 0 )\n        goto LABEL_24;\n    }\nLABEL_25:\n    if ( ++v5 == 88 )\n      return sub_8097B22();\n    v4 = v7;\n  }\n}\n"
    ],
    "sub_8097E1B": [
        "0x8097e1b",
        "_BOOL4 __usercall sub_8097E1B@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>)\n{\n  const char *v5; // ebx\n  int v6; // edi\n  int v7; // [esp+0h] [ebp-24h] BYREF\n  int v8; // [esp+4h] [ebp-20h] BYREF\n  int v9; // [esp+8h] [ebp-1Ch] BYREF\n  int v10; // [esp+Ch] [ebp-18h] BYREF\n  int v11; // [esp+10h] [ebp-14h] BYREF\n  int v12; // [esp+14h] [ebp-10h] BYREF\n\n  if ( sscanf(a1, \"%lx:%lx:%lx:%lx%n\", &v9, &v10, &v11, &v12, &v7) == 4 )\n  {\n    *a2 = v9;\n    a2[1] = v10;\n    a2[2] = v11;\n    a2[3] = v12;\n    v5 = &a1[v7];\n    v6 = 0;\n    while ( sscanf(v5, \":%x%n\", &v8, &v7) == 1 )\n    {\n      *((_BYTE *)a2 + v6 + 17) = v8;\n      v5 += v7;\n      if ( ++v6 == 32 )\n        return *v5 == 0;\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_8097EA8": [
        "0x8097ea8",
        "int __usercall sub_8097EA8@<eax>(struct termios *termios_p@<ecx>, int a2@<eax>)\n{\n  int v4; // eax\n  speed_t v5; // edi\n  int result; // eax\n  int v7; // [esp-8h] [ebp-14h]\n\n  sub_80B40EC();\n  v4 = sub_80B2EFA();\n  v5 = v4;\n  if ( a2 == 1 )\n    return cfsetospeed(termios_p, v5);\n  cfsetispeed(termios_p, v4);\n  result = v7;\n  if ( a2 )\n    return cfsetospeed(termios_p, v5);\n  return result;\n}\n"
    ],
    "sub_8097EDE": [
        "0x8097ede",
        "void __usercall __noreturn sub_8097EDE(int a1@<eax>)\n{\n  sub_804D3C9(a1, (_DWORD)qword_80DB778);\n}\n"
    ],
    "sub_8097EEA": [
        "0x8097eea",
        "int __usercall sub_8097EEA@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  int v5[6]; // [esp+0h] [ebp-18h] BYREF\n\n  v5[0] = 0;\n  v5[1] = 0;\n  if ( ioctl(0, 0x5413u, v5) )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 22 )\n      return sub_804D3A5(135062126, (const char *)qword_80DB778);\n    memset(v5, 0, 8u);\n  }\n  if ( a1 >= 0 )\n    LOWORD(v5[0]) = a1;\n  if ( a2 >= 0 )\n    HIWORD(v5[0]) = a2;\n  result = ioctl(0, 0x5414u, v5);\n  if ( result )\n    return sub_804D3A5(135062126, (const char *)qword_80DB778);\n  return result;\n}\n"
    ],
    "sub_8097F70": [
        "0x8097f70",
        "int __cdecl sub_8097F70(int a1, int a2)\n{\n  const char *v2; // ebp\n  int v3; // edi\n  const char *v4; // ebx\n  char *v5; // esi\n  char *v6; // eax\n  bool v7; // zf\n  int v8; // ecx\n  char v9; // al\n  int i; // eax\n  int v11; // eax\n  int v12; // eax\n  int v13; // eax\n  int v14; // eax\n  int v15; // eax\n  int v16; // edx\n  const char *v17; // eax\n  int v18; // ebx\n  int v19; // ebp\n  const char *v20; // esi\n  char *v21; // edi\n  char *v22; // eax\n  int v23; // edx\n  int v24; // eax\n  int v25; // eax\n  int v26; // ecx\n  int v27; // edx\n  int v28; // eax\n  int v29; // eax\n  const char *v31; // [esp-4h] [ebp-9Ch]\n  int v32; // [esp+0h] [ebp-98h]\n  int v33; // [esp+4h] [ebp-94h]\n  int v34; // [esp+4h] [ebp-94h]\n  void (__cdecl *v35)(struct termios *, int); // [esp+8h] [ebp-90h]\n  int v36; // [esp+Ch] [ebp-8Ch]\n  struct termios termios_p; // [esp+10h] [ebp-88h] BYREF\n  struct termios s2; // [esp+4Ch] [ebp-4Ch] BYREF\n\n  LODWORD(qword_80DB778) = \"standard input\";\n  HIDWORD(qword_80DB778) = 80;\n  unk_80DB780 = 0;\n  v33 = 0;\n  v32 = 16;\n  v36 = 0;\n  v2 = 0;\n  v35 = (void (__cdecl *)(struct termios *, int))sub_8097CB0;\n  while ( 1 )\n  {\n    v3 = v33 + 1;\n    v4 = *(const char **)(a2 + 4 * (v33 + 1));\n    if ( !v4 )\n      break;\n    v5 = *(char **)(a2 + 4 * (v33 + 1) + 4);\n    if ( *v4 == 45 )\n    {\n      v34 = 4 * (v33 + 1);\n      v6 = sub_8097B37(v4 + 1);\n      if ( v6 )\n      {\n        v7 = (v6[1] & 4) == 0;\n        goto LABEL_44;\n      }\n      v8 = 0;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v9 = v4[++v8];\n          if ( !v9 )\n            goto LABEL_47;\n          if ( v9 != 97 )\n            break;\n          v32 |= 4u;\n          v36 = 1;\n          v35 = (void (__cdecl *)(struct termios *, int))sub_8097CB0;\n        }\n        if ( v9 != 103 )\n          break;\n        v32 |= 8u;\n        v35 = (void (__cdecl *)(struct termios *, int))sub_8097A48;\n      }\n      if ( v9 != 70 )\nLABEL_45:\n        sub_804D5E0(\"invalid argument '%s'\", v4);\n      if ( v2 )\n        sub_804D5E0(\"only one device may be specified\");\n      v2 = &v4[v8 + 1];\n      if ( !*v2 )\n      {\n        if ( !v5 )\n        {\n          v31 = \"-F\";\n          goto LABEL_27;\n        }\n        for ( i = a2 + v34 - 4; ; *(_DWORD *)(i + 4) = *(_DWORD *)(i + 8) )\n        {\n          i += 4;\n          if ( !*(_DWORD *)(i + 4) )\n            break;\n        }\n        v2 = v5;\n      }\n    }\n    else\n    {\n      if ( sub_8097B37(*(const char **)(a2 + 4 * (v33 + 1))) )\n        goto LABEL_46;\n      v11 = sub_804D222(\"intr\", v4);\n      if ( v11 < 0 )\n      {\n        LOBYTE(v13) = sub_8097B52(v4);\n        if ( (v13 & 0x80u) != 0 )\n        {\n          if ( !v5 )\n          {\nLABEL_26:\n            v31 = v4;\nLABEL_27:\n            sub_804D5E0(\"%s requires an argument\", v31);\n          }\n          v3 = v33 + 2;\n        }\n        if ( v13 > 132 )\n        {\n          if ( v13 == 135 )\n          {\n            v14 = 0;\n          }\n          else\n          {\n            if ( v13 != 136 )\n              goto LABEL_42;\n            v14 = 1;\n          }\n          sub_8097EA8(&termios_p, v14);\n        }\n        else if ( v13 >= 129 )\n        {\n          sub_80B40B8(&unk_80B6760);\n        }\n        else\n        {\n          if ( (unsigned int)(v13 - 5) <= 1 )\n            goto LABEL_46;\nLABEL_42:\n          if ( !sub_8097E1B(v4, &termios_p) )\n          {\n            sub_80B40EC();\n            v7 = sub_80B2EFA() == -1;\nLABEL_44:\n            if ( v7 )\n              goto LABEL_45;\n          }\n        }\nLABEL_46:\n        v32 &= ~0x10u;\n        goto LABEL_47;\n      }\n      v12 = 2 * v11 + 134972952;\n      if ( !v5 )\n        goto LABEL_26;\n      sub_8097B6E(v12, v5, (int)&termios_p, (int)v4);\n      v32 &= ~0x10u;\n      v3 = v33 + 2;\n    }\nLABEL_47:\n    v33 = v3;\n  }\n  if ( (v32 & 0xC) == 12 )\n    sub_804D5E0(\"-a and -g are mutually exclusive\");\n  if ( (v32 & 0xC) != 0 && (v32 & 0x10) == 0 )\n    sub_804D5E0(\"modes may not be set when -a or -g is used\");\n  if ( v2 )\n  {\n    LODWORD(qword_80DB778) = v2;\n    v15 = sub_804DC1E(v2);\n    sub_804DC97(v15, 0);\n    sub_804D646();\n  }\n  memset(&termios_p, 0, sizeof(termios_p));\n  if ( tcgetattr(0, &termios_p) )\n    goto LABEL_56;\n  if ( v32 )\n  {\n    HIDWORD(qword_80DB778) = sub_804D986(1, v16);\n    v35(&termios_p, v36);\n    return 0;\n  }\n  v18 = 0;\n  while ( 2 )\n  {\n    v19 = v32 + 1;\n    v20 = *(const char **)(a2 + 4 * (v32 + 1));\n    if ( v20 )\n    {\n      v21 = *(char **)(a2 + 4 * (v32 + 1) + 4);\n      if ( *v20 == 45 )\n      {\n        v22 = sub_8097B37(v20 + 1);\n        if ( v22 )\n        {\n          v23 = 1;\n          goto LABEL_66;\n        }\nLABEL_92:\n        v32 = v19;\n        continue;\n      }\n      v22 = sub_8097B37(*(const char **)(a2 + 4 * (v32 + 1)));\n      if ( v22 )\n      {\n        v23 = 0;\nLABEL_66:\n        sub_8097799((unsigned int)v22, v23, &termios_p.c_iflag);\n        goto LABEL_84;\n      }\n      v24 = sub_804D222(\"intr\", v20);\n      if ( v24 >= 0 )\n      {\n        v19 = v32 + 2;\n        sub_8097B6E(2 * v24 + 134972952, v21, (int)&termios_p, v18);\nLABEL_84:\n        v18 |= 1u;\n        goto LABEL_92;\n      }\n      LOBYTE(v25) = sub_8097B52(v20);\n      if ( (v25 & 0x80u) != 0 )\n        v19 = v32 + 2;\n      if ( v25 == 130 )\n      {\n        v28 = sub_80B40DC(v26, &unk_80B6760);\n        v27 = -1;\n      }\n      else\n      {\n        if ( v25 <= 130 )\n        {\n          switch ( v25 )\n          {\n            case 6:\n              sub_8097C61(&termios_p, 0);\n              goto LABEL_92;\n            case 129:\n              termios_p.c_line = sub_80B40DC(v26, &unk_80B6760);\n              goto LABEL_84;\n            case 5:\n              sub_8097BFB(0);\n              goto LABEL_92;\n          }\nLABEL_89:\n          if ( sub_8097E1B(v20, &termios_p) )\n            goto LABEL_84;\n          v29 = 2;\n          goto LABEL_91;\n        }\n        if ( v25 == 135 )\n        {\n          v29 = 0;\n          goto LABEL_91;\n        }\n        if ( v25 > 135 )\n        {\n          if ( v25 != 136 )\n            goto LABEL_89;\n          v29 = 1;\nLABEL_91:\n          sub_8097EA8(&termios_p, v29);\n          v18 = 3;\n          goto LABEL_92;\n        }\n        if ( v25 > 132 )\n          goto LABEL_89;\n        v27 = sub_80B40DC(v26, &unk_80B6760);\n        v28 = -1;\n      }\n      sub_8097EEA(v28, v27);\n      goto LABEL_92;\n    }\n    break;\n  }\n  if ( (v18 & 1) == 0 )\n    return 0;\n  if ( tcsetattr(0, 1, &termios_p) || (memset(&s2, 0, sizeof(s2)), tcgetattr(0, &s2)) )\n  {\nLABEL_56:\n    v17 = \"\\r\\n%s\" + 2;\n    goto LABEL_98;\n  }\n  if ( memcmp(&termios_p, &s2, 0x3Cu) )\n  {\n    v17 = \"%s: cannot perform all requested operations\";\nLABEL_98:\n    sub_8097EDE((int)v17);\n  }\n  return 0;\n}\n"
    ],
    "sub_80983F8": [
        "0x80983f8",
        "int sub_80983F8()\n{\n  sub_80B3CE5();\n  sync();\n  return 0;\n}\n"
    ],
    "sub_809840C": [
        "0x809840c",
        "int __usercall sub_809840C@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)\n{\n  if ( *a1 == 43 )\n    LOBYTE(qword_80DB778) = 1;\n  return sub_80B40DC(a2, &unk_80B7580);\n}\n"
    ],
    "sub_809842D": [
        "0x809842d",
        "int __cdecl sub_809842D(int a1, int a2)\n{\n  int v2; // esi\n  int v3; // edi\n  _BYTE *v4; // eax\n  int v5; // ebx\n  char v6; // cl\n  char v7; // cl\n  int v8; // esi\n  int v9; // edi\n  int v10; // eax\n  int v11; // edx\n  int v12; // eax\n  char *v13; // edi\n  int v14; // edx\n  int v15; // ecx\n  __int64 v16; // rax\n  __int64 v17; // rax\n  unsigned int v18; // ecx\n  __int64 v19; // rax\n  unsigned int v20; // ecx\n  char *v21; // ebp\n  signed int v22; // esi\n  ssize_t v23; // eax\n  int v24; // ecx\n  char *v25; // edx\n  int v26; // ecx\n  ssize_t v27; // edx\n  _BOOL4 v28; // ebp\n  int v29; // edx\n  char *v30; // ecx\n  void *v31; // ebp\n  int v32; // esi\n  const char *v33; // edi\n  int v34; // ebx\n  int v35; // eax\n  const char *v36; // edx\n  __int64 v37; // rax\n  ssize_t v38; // eax\n  int v39; // eax\n  char v41; // [esp+0h] [ebp-118h]\n  size_t v42; // [esp+4h] [ebp-114h]\n  int v43; // [esp+4h] [ebp-114h]\n  int v44; // [esp+4h] [ebp-114h]\n  unsigned int v45; // [esp+8h] [ebp-110h]\n  _DWORD *v46; // [esp+Ch] [ebp-10Ch]\n  int v47; // [esp+10h] [ebp-108h]\n  void *buf; // [esp+14h] [ebp-104h]\n  char *bufa; // [esp+14h] [ebp-104h]\n  unsigned int v50; // [esp+18h] [ebp-100h]\n  unsigned int v51; // [esp+1Ch] [ebp-FCh]\n  int v52; // [esp+1Ch] [ebp-FCh]\n  _DWORD *v53; // [esp+20h] [ebp-F8h]\n  int v54; // [esp+24h] [ebp-F4h]\n  __int64 v55; // [esp+34h] [ebp-E4h]\n  unsigned int seconds; // [esp+3Ch] [ebp-DCh] BYREF\n  _BYTE *v57; // [esp+40h] [ebp-D8h] BYREF\n  _BYTE *v58[29]; // [esp+44h] [ebp-D4h] BYREF\n  int v59; // [esp+B8h] [ebp-60h]\n  __int64 v60; // [esp+D4h] [ebp-44h]\n  _BYTE *v61; // [esp+100h] [ebp-18h]\n  _BYTE *v62; // [esp+104h] [ebp-14h]\n\n  v2 = a1;\n  v3 = a2;\n  seconds = 1;\n  v4 = *(_BYTE **)(a2 + 4);\n  v5 = 10;\n  if ( v4 )\n  {\n    if ( ((*v4 - 43) & 0xFD) == 0 )\n    {\n      v6 = v4[1];\n      if ( (unsigned __int8)(v6 - 48) <= 9u )\n      {\n        v5 = sub_809840C(v4, v6);\n        v3 = a2 + 4;\n        v2 = a1 - 1;\n      }\n    }\n  }\n  v41 = sub_80ABEAC(v3, \"^fc:n:qs:+vF\", &v57, v58, &seconds);\n  if ( (v41 & 2) != 0 )\n    v5 = sub_809840C(v57, v7);\n  if ( (v41 & 4) != 0 )\n    v5 = sub_809840C(v58[0], v7);\n  v50 = (v41 & 8) == 0 ? 1 : -1;\n  if ( (v41 & 0x20) != 0 )\n    v50 = 0;\n  v8 = v2 - optind;\n  v46 = (_DWORD *)(v3 + 4 * optind);\n  v53 = sub_804DAFA(4 * v8 + 4);\n  if ( !*v46 )\n  {\n    if ( !fstat64() && (v59 & 0xF000) == 4096 )\n      v41 &= ~1u;\n    *v46 = \"standard input\";\n  }\n  v9 = 0;\n  v45 = 0;\n  do\n  {\n    v10 = sub_80B3DAA();\n    if ( v10 >= 0 || (v41 & 0x40) != 0 )\n    {\n      v11 = v45;\n      v53[v45++] = v10;\n      v46[v11] = v46[v9];\n    }\n    else\n    {\n      BYTE1(qword_80DB778) = 1;\n    }\n    ++v9;\n  }\n  while ( v8 > v9 );\n  if ( !v45 )\n    sub_804D5E0(\"no files\");\n  v42 = 4096;\n  if ( !(_BYTE)qword_80DB778 && (v41 & 2) != 0 )\n  {\n    v42 = v5 + 4096;\n    if ( (unsigned int)v5 >= 0xFFFFF000 )\n      v42 = 4096;\n  }\n  v12 = v5 | 0xF;\n  if ( (v5 | 0xFu) > 0x7FFF )\n    v12 = 0x7FFF;\n  v55 = (unsigned int)(v12 << 16);\n  v47 = 0;\n  v13 = 0;\n  do\n  {\n    buf = (void *)v53[v47];\n    if ( (int)buf < 0 )\n      goto LABEL_85;\n    if ( v50 < v45 && dprintf() < 0 )\nLABEL_34:\n      sub_80B0A23(v15, v14);\n    if ( !(_BYTE)qword_80DB778 )\n    {\n      LODWORD(v16) = lseek64();\n      if ( v16 > 0 )\n      {\n        if ( (v41 & 2) != 0 )\n        {\n          if ( v5 )\n          {\n            v17 = v16 - (unsigned int)v5;\n            v18 = HIDWORD(v17);\n            if ( v17 < 0 )\n            {\n              LODWORD(v17) = 0;\n              v18 = 0;\n            }\n            sub_804DD09(v18, v17, 0);\n            sub_804E4ED((int)buf, 1, (unsigned int)v5);\n          }\n          goto LABEL_85;\n        }\n        v19 = v16 - v55;\n        v20 = HIDWORD(v19);\n        if ( v19 < 0 )\n        {\n          LODWORD(v19) = 0;\n          v20 = 0;\n        }\n        sub_804DD09(v20, v19, 0);\n      }\n    }\n    if ( !v13 )\n      v13 = (char *)sub_804DAFA(v42);\n    v21 = v13;\n    v51 = 1;\n    v54 = 0;\n    v22 = 0;\nLABEL_48:\n    while ( 1 )\n    {\n      v23 = sub_804E5E3((int)buf, v21, v42 - v22);\n      if ( v23 < 0 )\n        break;\n      if ( !v23 )\n        goto LABEL_83;\n      if ( (_BYTE)qword_80DB778 )\n      {\n        if ( v5 <= v51 )\n        {\n          v24 = v23;\n          goto LABEL_63;\n        }\n        if ( (v41 & 2) != 0 )\n        {\n          v24 = v23 + v51 - v5;\n          v51 += v23;\n        }\n        else\n        {\n          v25 = v21;\n          v24 = v23;\n          while ( 1 )\n          {\n            --v24;\n            if ( *v25++ == 10 && v5 == ++v51 )\n              break;\n            if ( !v24 )\n              goto LABEL_48;\n          }\n        }\n        if ( v24 > 0 )\nLABEL_63:\n          sub_804DCAD(v24, (int)&v21[v23 - v24]);\n      }\n      else if ( v5 )\n      {\n        v26 = v41 & 2;\n        if ( (v41 & 2) != 0 )\n        {\n          v22 += v23;\n          if ( v22 > v5 )\n          {\n            memmove(v13, &v13[v22 - v5], v5);\n            v22 = v5;\n          }\n        }\n        else\n        {\n          v27 = v23;\n          do\n          {\n            if ( v21[--v27] == 10 )\n              ++v26;\n          }\n          while ( v27 );\n          v54 += v26;\n          if ( v54 >= v5 )\n          {\n            v28 = v21[v23 - 1] != 10;\n            v29 = v28 + v54 - v5;\n            v30 = v13;\n            while ( v29 )\n            {\n              if ( *v30 == 10 )\n                --v29;\n              ++v30;\n            }\n            v22 += v23 - (v30 - v13);\n            memmove(v13, v30, v22);\n            v54 = v5 - v28;\n          }\n          else\n          {\n            v22 += v23;\n          }\n          if ( v22 + 4096 > v42 )\n          {\n            v42 = v22 + 4096;\n            v13 = (char *)sub_804DB13(v13, v22 + 4096);\n          }\n        }\n        v21 = &v13[v22];\n      }\n    }\n    sub_804D3A5((int)\"read error\");\n    BYTE1(qword_80DB778) = 1;\nLABEL_83:\n    if ( !(_BYTE)qword_80DB778 )\n      sub_804DCAD(v22, (int)v13);\nLABEL_85:\n    ++v47;\n  }\n  while ( v47 != v45 );\n  v43 = v53[v47 - 1];\n  bufa = (char *)sub_804DB13(v13, 0x1000u);\n  if ( (v41 & 1) != 0 )\n  {\n    v31 = 0;\n    while ( 2 )\n    {\n      sleep(seconds);\n      v32 = 0;\nLABEL_89:\n      v33 = (const char *)v46[v32];\n      v34 = v53[v32];\n      if ( (v41 & 0x40) != 0 )\n      {\n        if ( v34 < 0 )\n          goto LABEL_98;\n        if ( fstat64() < 0 || stat64() < 0 || v58[26] != v58[2] || v58[25] != v58[1] || v62 != v58[24] || v61 != v58[23] )\n        {\n          close(v34);\nLABEL_98:\n          v35 = open64();\n          if ( v35 < 0 )\n          {\n            if ( v34 >= 0 )\n            {\n              v52 = v35;\n              sub_804D3A5((int)\"%s has become inaccessible\", v33);\n              goto LABEL_104;\n            }\n          }\n          else\n          {\n            v36 = \"been replaced\";\n            if ( v34 < 0 )\n              v36 = \"appeared\";\n            v52 = v35;\n            sub_804D5F4(\"%s has %s; following end of new file\", v33, v36);\nLABEL_104:\n            v35 = v52;\n          }\n          v53[v32] = v35;\n          v34 = v35;\n        }\n      }\n      if ( v34 >= 0 )\n      {\n        if ( v50 < v45 )\n          v31 = &unk_80D5F92;\n        while ( 1 )\n        {\n          if ( !fstat64() && v60 > 0 )\n          {\n            LODWORD(v37) = lseek64();\n            if ( v60 < v37 )\n              sub_804DD09(0, 0, 0);\n          }\n          v38 = sub_804E5E3(v34, bufa, 0x1000u);\n          v15 = v38;\n          if ( v38 < 0 )\n            break;\n          if ( !v38 )\n            goto LABEL_121;\n          if ( v31 && v43 != v34 )\n          {\n            v44 = v38;\n            v39 = dprintf();\n            v15 = v44;\n            if ( v39 < 0 )\n              goto LABEL_34;\n            v43 = v34;\n            v31 = 0;\n          }\n          sub_804DCAD(v15, (int)bufa);\n        }\n        sub_804D3A5((int)\"read error\");\n        BYTE1(qword_80DB778) = 1;\n      }\nLABEL_121:\n      if ( v47 == ++v32 )\n        continue;\n      goto LABEL_89;\n    }\n  }\n  return BYTE1(qword_80DB778);\n}\n"
    ],
    "sub_8098A80": [
        "0x8098a80",
        "void __cdecl __noreturn sub_8098A80(int a1, int a2)\n{\n  char v2; // al\n  int v3; // ebx\n  _BYTE **v4; // ebp\n  FILE **v5; // ebx\n  _BYTE **v6; // esi\n  int v7; // edi\n  int v8; // ecx\n  _BYTE *v9; // eax\n  int v10; // eax\n  FILE **v11; // esi\n  size_t v12; // edx\n  ssize_t v13; // eax\n  int v14; // esi\n  int v15; // [esp+0h] [ebp-18h]\n  char *n; // [esp+4h] [ebp-14h]\n\n  v2 = sub_80ABEAC(a2, 135079150);\n  v3 = a1 - optind;\n  v4 = (_BYTE **)(a2 + 4 * optind);\n  n = &MEMORY[0x80D6E58][v2 & 2];\n  if ( (v2 & 1) != 0 )\n    signal(2, (__sighandler_t)1);\n  signal(13, (__sighandler_t)1);\n  v5 = (FILE **)sub_804DB2E(4 * v3 + 8);\n  *v5 = stdout;\n  v6 = v4;\n  v7 = 0;\n  HIBYTE(v15) = 0;\n  while ( 1 )\n  {\n    setbuf(v5[v7], 0);\n    while ( 1 )\n    {\n      v9 = *v6;\n      if ( !*v6 )\n      {\n        while ( 1 )\n        {\n          v13 = sub_804E5BC(0x400u, &qword_80DB778, 0);\n          v12 = v13;\n          if ( v13 <= 0 )\n            break;\n          v11 = v5;\n          do\n          {\n            n = (char *)v12;\n            fwrite(&qword_80DB778, 1u, v12, *v11++);\n            v12 = (size_t)n;\n          }\n          while ( *v11 );\n        }\n        if ( v13 )\n          HIBYTE(v15) = 1;\n        *(v4 - 1) = \"standard input\";\n        *v5 = stdin;\n        v14 = 0;\n        do\n        {\n          sub_804DD6F(v5[v14], v4[v14 - 1]);\n          ++v14;\n        }\n        while ( v5[v14] );\n        sub_80AB247(v15, n);\n      }\n      v5[v7 + 1] = stdout;\n      if ( *v9 == 45 && !v9[1] )\n        break;\n      v10 = sub_80B3D18(v8, n);\n      v5[v7 + 1] = (FILE *)v10;\n      if ( v10 )\n        break;\n      HIBYTE(v15) = 1;\n      ++v6;\n    }\n    v4[v7++] = *v6++;\n  }\n}\n"
    ],
    "sub_8098BB4": [
        "0x8098bb4",
        "void __usercall __noreturn sub_8098BB4(const char *a1@<eax>, const char *a2@<edx>)\n{\n  if ( a1 && *a1 )\n    sub_804D5F4(\"%s: %s\", a1, a2);\n  else\n    sub_804D5F4(\"%s\", a2);\n  longjmp((struct __jmp_buf_tag *)((char *)dword_80DBB94 + 16), 2);\n}\n"
    ],
    "sub_8098BEB": [
        "0x8098beb",
        "unsigned __int64 __usercall sub_8098BEB@<edx:eax>(const char *a1@<eax>, char *a2@<edx>)\n{\n  __int64 v3; // rax\n  int v4; // ecx\n  unsigned int v5; // esi\n  const char *v6; // edx\n  unsigned int v7; // edi\n  char *v9; // [esp+0h] [ebp-10h] BYREF\n\n  v9 = a2;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v3 = strtoll(a1, &v9, 10);\n  v5 = v3;\n  if ( *(_DWORD *)dword_80DBB7C )\n  {\n    v6 = \"Value is out of range\" + 9;\n    goto LABEL_5;\n  }\n  if ( v9 == a1 || (v7 = HIDWORD(v3), *(_BYTE *)sub_80B2E8C(v4, HIDWORD(v3))) )\n  {\n    v6 = \"bad number\";\nLABEL_5:\n    sub_8098BB4(a1, v6);\n  }\n  return __PAIR64__(v7, v5);\n}\n"
    ],
    "sub_8098C4C": [
        "0x8098c4c",
        "int __usercall sub_8098C4C@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v1; // ebx\n  int v2; // edx\n  int result; // eax\n\n  v1 = dword_80DBB94;\n  *((_DWORD *)dword_80DBB94 + 1) = &unk_80D6EB9;\n  if ( !a1 )\n    return 0;\n  v2 = sub_804D222(\"-r\", a1);\n  result = 39;\n  if ( v2 >= 0 )\n  {\n    v1[1] = 2 * v2 + 134965824;\n    return (unsigned __int8)byte_80B6A40[2 * v2];\n  }\n  return result;\n}\n"
    ],
    "sub_8098C8E": [
        "0x8098c8e",
        "int sub_8098C8E()\n{\n  int *v0; // ebx\n  const char *v1; // esi\n  const char **v2; // edx\n  _BYTE *v3; // ebp\n  int v4; // eax\n  char *v5; // edx\n  const char *v6; // ebx\n  signed __int64 v7; // kr00_8\n  unsigned int v8; // ebx\n  unsigned __int64 v9; // rax\n  bool v10; // zf\n  bool v11; // zf\n  int result; // eax\n  int v13; // eax\n  __int64 v14; // rcx\n  unsigned int v15; // eax\n  char v16; // [esp+3h] [ebp-D1h]\n  int v17; // [esp+4h] [ebp-D0h]\n  int v18; // [esp+8h] [ebp-CCh]\n  int v19; // [esp+4Ch] [ebp-88h]\n  int v20; // [esp+5Ch] [ebp-78h]\n  int v21; // [esp+60h] [ebp-74h]\n  int v22; // [esp+64h] [ebp-70h]\n  int v23; // [esp+68h] [ebp-6Ch]\n  int v24; // [esp+ACh] [ebp-28h]\n  int v25; // [esp+BCh] [ebp-18h]\n  int v26; // [esp+C0h] [ebp-14h]\n\n  v0 = (int *)dword_80DBB94;\n  v1 = **(const char ***)dword_80DBB94;\n  v2 = (const char **)(*(_DWORD *)dword_80DBB94 + 4);\n  *(_DWORD *)dword_80DBB94 = v2;\n  sub_8098C4C(*v2);\n  v3 = (_BYTE *)v0[1];\n  v4 = *v0;\n  v5 = (char *)(v4 + 4);\n  *v0 += 4;\n  v6 = *(const char **)(v4 + 4);\n  if ( !v6 )\n    sub_8098BB4(*(const char **)v4, \"argument expected\");\n  LOBYTE(v5) = *v3;\n  if ( (unsigned __int8)(*v3 - 28) <= 5u )\n  {\n    v7 = sub_8098BEB(v1, v5);\n    v9 = sub_8098BEB(v6, (char *)HIDWORD(v7));\n    v8 = v9;\n    LOBYTE(v9) = *v3;\n    if ( *v3 == 28 )\n    {\n      v10 = v7 == __PAIR64__(HIDWORD(v9), v8);\nLABEL_23:\n      LOBYTE(result) = v10;\n      return (unsigned __int8)result;\n    }\n    switch ( (_BYTE)v9 )\n    {\n      case 0x1D:\n        v11 = v7 == __PAIR64__(HIDWORD(v9), v8);\nLABEL_8:\n        LOBYTE(result) = !v11;\n        return (unsigned __int8)result;\n      case 0x1E:\n        LODWORD(v9) = 1;\n        if ( v7 >= __SPAIR64__(HIDWORD(v9), v8) )\n          return result;\n        break;\n      case 0x1F:\n        LODWORD(v9) = 1;\n        if ( v7 > __SPAIR64__(HIDWORD(v9), v8) )\n          return result;\n        break;\n      case 0x20:\n        LODWORD(v9) = 1;\n        if ( v7 <= __SPAIR64__(HIDWORD(v9), v8) )\n          return result;\n        break;\n      default:\n        return v7 < __SPAIR64__(HIDWORD(v9), v8);\n    }\n    return 0;\n  }\n  if ( (unsigned __int8)((_BYTE)v5 - 22) > 5u )\n  {\n    if ( stat64() || stat64() )\n      return 0;\n    if ( *v3 == 17 )\n    {\n      LOBYTE(result) = v19 > v24;\n      return (unsigned __int8)result;\n    }\n    if ( *v3 == 18 )\n    {\n      LOBYTE(result) = v19 < v24;\n      return (unsigned __int8)result;\n    }\n    if ( v18 != v23 )\n      return 0;\n    if ( v17 != v22 )\n      return 0;\n    if ( v21 != v26 )\n      return 0;\n    result = 1;\n    if ( v20 != v25 )\n      return 0;\n  }\n  else\n  {\n    v16 = *v3;\n    v13 = strcmp(v1, v6);\n    v14 = v13;\n    if ( v16 == 24 )\n    {\n      v10 = v13 == 0LL;\n      goto LABEL_23;\n    }\n    if ( v16 == 25 )\n    {\n      v11 = v13 == 0LL;\n      goto LABEL_8;\n    }\n    v15 = v13 >> 31;\n    if ( v16 != 26 )\n      v15 = (unsigned __int64)((SHIDWORD(v14) >> 31) - v14) >> 32;\n    return v15 >> 31;\n  }\n  return result;\n}\n"
    ],
    "sub_8098E86": [
        "0x8098e86",
        "unsigned int __usercall sub_8098E86@<eax>(int a1@<eax>)\n{\n  const char ***v1; // ebx\n  const char **v2; // edx\n  int v3; // esi\n  const char *v6; // edx\n  const char *v7; // eax\n  const char **v8; // edx\n  int v9; // esi\n  int v10; // eax\n  const char *v11; // eax\n  char *v12; // edx\n  int v14; // eax\n  int v15; // esi\n  __uid_t v16; // eax\n  bool v17; // zf\n  int v18; // eax\n  const char *v19; // ebx\n  __uid_t v20; // eax\n  int v22; // [esp+0h] [ebp-74h]\n  int v23; // [esp+4h] [ebp-70h]\n  int v24; // [esp+18h] [ebp-5Ch]\n  const char *v25; // [esp+20h] [ebp-54h]\n  const char *v26; // [esp+24h] [ebp-50h]\n  __int64 v27; // [esp+34h] [ebp-40h]\n\n  v1 = (const char ***)dword_80DBB94;\n  if ( a1 != 34 )\n  {\n    v6 = \"argument expected\";\n    if ( !a1 )\n      goto LABEL_9;\n    v7 = *(const char **)(*(_DWORD *)dword_80DBB94 + 4);\n    if ( a1 == 37 )\n    {\n      *(_DWORD *)dword_80DBB94 += 4;\n      sub_8098C4C(v7);\n      v3 = sub_80991CD();\n      v8 = *v1 + 1;\n      *v1 = v8;\n      if ( sub_8098C4C(*v8) == 38 )\n        return v3;\n      v6 = \"closing paren expected\";\nLABEL_9:\n      sub_8098BB4(0, v6);\n    }\n    v9 = *((_DWORD *)dword_80DBB94 + 1);\n    if ( sub_8098C4C(v7) && (*v1)[2] && *((_BYTE *)v1[1] + 1) == 1 )\n      return sub_8098C8E();\n    if ( *(_BYTE *)(v9 + 1) )\n    {\n      if ( *((_BYTE *)v1[1] + 1) == 1 )\n        return sub_8098C8E();\n    }\n    else\n    {\n      v11 = (*v1)[1];\n      if ( v11 )\n      {\n        v12 = (char *)(*v1 + 1);\n        *v1 = (const char **)v12;\n        if ( a1 == 22 )\n          return *v11 == 0;\n        if ( a1 != 23 )\n        {\n          if ( a1 == 13 )\n          {\n            v14 = sub_8098BEB(v11, v12);\n            return isatty(v14);\n          }\n          if ( a1 == 11 )\n          {\n            if ( lstat64() )\n              return 0;\n            v18 = 40960;\n          }\n          else\n          {\n            v23 = stat64();\n            if ( v23 )\n              return 0;\n            v10 = 1;\n            if ( a1 == 4 )\n              return v10;\n            if ( (unsigned __int8)(a1 - 1) <= 2u )\n            {\n              v15 = 2;\n              if ( a1 != 2 )\n                v15 = 3 * (a1 != 3) + 1;\n              v22 = v15;\n              v16 = geteuid();\n              if ( v16 || v15 == 1 && (v24 & 0x49) == 0 )\n              {\n                if ( (const char *)v16 == v25 )\n                {\n                  v22 = v15 << 6;\n                }\n                else if ( v26 == (const char *)getgid() || v26 == (const char *)getegid() )\n                {\nLABEL_42:\n                  v22 = 8 * v15;\n                }\n                else\n                {\n                  if ( !v1[3] )\n                    v1[2] = (const char **)sub_80A991A(v15, 0);\n                  while ( v23 < (int)v1[3] )\n                  {\n                    if ( v26 == v1[2][v23] )\n                      goto LABEL_42;\n                    ++v23;\n                  }\n                }\n                v23 = -((v22 & v24) == 0);\n              }\n              v17 = v23 == 0;\n              goto LABEL_64;\n            }\n            if ( (unsigned __int8)(a1 - 5) > 5u )\n            {\n              if ( (unsigned __int8)(a1 - 14) <= 2u )\n              {\n                v10 = 1024;\n                if ( a1 != 15 )\n                  v10 = a1 != 16 ? 2048 : 512;\n                LOBYTE(v10) = (v10 & v24) != 0;\n                return (unsigned __int8)v10;\n              }\n              if ( a1 == 12 )\n                return (unsigned int)((unsigned __int64)((SHIDWORD(v27) >> 31) - v27) >> 32) >> 31;\n              if ( a1 == 20 )\n              {\n                v19 = v25;\n                v20 = geteuid();\n              }\n              else\n              {\n                v10 = 1;\n                if ( a1 != 21 )\n                  return v10;\n                v19 = v26;\n                v20 = getegid();\n              }\n              v17 = v19 == (const char *)v20;\nLABEL_64:\n              LOBYTE(v10) = v17;\n              return (unsigned __int8)v10;\n            }\n            v18 = 0x4000;\n            if ( a1 != 6 )\n            {\n              v18 = 0x2000;\n              if ( a1 != 7 )\n              {\n                v18 = 24576;\n                if ( a1 != 8 )\n                {\n                  v18 = 4096;\n                  if ( a1 != 9 )\n                    v18 = a1 == 10 ? 49152 : 0x8000;\n                }\n              }\n            }\n          }\n          v17 = (v24 & 0xF000) == v18;\n          goto LABEL_64;\n        }\n        return *v11 != 0;\n      }\n    }\n    v11 = **v1;\n    return *v11 != 0;\n  }\n  v2 = (const char **)(*(_DWORD *)dword_80DBB94 + 4);\n  *(_DWORD *)dword_80DBB94 = v2;\n  if ( sub_8098C4C(*v2) )\n    return sub_8098E86() == 0;\n  --*v1;\n  return 1;\n}\n"
    ],
    "sub_809916D": [
        "0x809916d",
        "int __usercall sub_809916D@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  __int64 v2; // rdi\n  const char ***v3; // ebx\n  const char **v4; // edx\n  const char **v5; // edx\n\n  HIDWORD(v2) = sub_8098E86(a1);\n  LODWORD(v2) = v1;\n  v3 = (const char ***)dword_80DBB94;\n  v4 = (const char **)(*(_DWORD *)dword_80DBB94 + 4);\n  *(_DWORD *)dword_80DBB94 = v4;\n  if ( sub_8098C4C(*v4) == 35 )\n  {\n    v5 = *v3 + 1;\n    *v3 = v5;\n    sub_8098C4C(*v5);\n    HIDWORD(v2) = (v2 != 0) & (sub_809916D() != 0);\n  }\n  else\n  {\n    --*v3;\n  }\n  return HIDWORD(v2);\n}\n"
    ],
    "sub_80991CD": [
        "0x80991cd",
        "_BOOL4 __usercall sub_80991CD@<eax>(int a1@<eax>)\n{\n  int v1; // esi\n  int v2; // edx\n  int v3; // edi\n  const char ***v4; // ebx\n  const char **v5; // edx\n  const char **v6; // edx\n  __int64 v7; // rax\n\n  v1 = sub_809916D(a1);\n  v3 = v2;\n  v4 = (const char ***)dword_80DBB94;\n  v5 = (const char **)(*(_DWORD *)dword_80DBB94 + 4);\n  *(_DWORD *)dword_80DBB94 = v5;\n  if ( sub_8098C4C(*v5) == 36 )\n  {\n    v6 = *v4 + 1;\n    *v4 = v6;\n    sub_8098C4C(*v6);\n    v7 = sub_80991CD();\n    return (v3 | HIDWORD(v7) | v1 | (unsigned int)v7) != 0;\n  }\n  else\n  {\n    --*v4;\n  }\n  return v1;\n}\n"
    ],
    "sub_8099228": [
        "0x8099228",
        "int __cdecl sub_8099228(int a1, const char **a2)\n{\n  char *v2; // eax\n  const char **v3; // ebx\n  const char *v4; // edx\n  int v5; // ebx\n  void *v6; // esi\n  _BYTE *v7; // edx\n  const char *v8; // eax\n  bool v9; // zf\n  _BYTE *v10; // ecx\n  int v11; // eax\n  int v12; // eax\n  __int64 v13; // rax\n  const char **v14; // eax\n  const char *v15; // eax\n  _DWORD *v17; // [esp+1Ah] [ebp+8h]\n\n  v2 = sub_804D315(*a2);\n  if ( *v2 == 91 )\n  {\n    v3 = &a2[a1 - 1];\n    v4 = *v3;\n    if ( v2[1] )\n    {\n      if ( strcmp(v4, \"]]\") )\n      {\n        sub_804D5F4(\"missing ]]\");\n        return 2;\n      }\n    }\n    else if ( *v4 != 93 || v4[1] )\n    {\n      sub_804D5F4(\"missing ]\");\n      return 2;\n    }\n    *v3 = 0;\n  }\n  dword_80DBB94 = sub_804DB2E(0x34u);\n  v5 = _setjmp((struct __jmp_buf_tag *)((char *)dword_80DBB94 + 16));\n  v6 = dword_80DBB94;\n  if ( v5 )\n    goto LABEL_34;\n  v17 = a2 + 1;\n  *(_DWORD *)dword_80DBB94 = v17;\n  while ( 1 )\n  {\n    v7 = (_BYTE *)*v17;\n    if ( !*v17 )\n    {\n      v11 = 1;\n      goto LABEL_21;\n    }\n    v8 = (const char *)v17[1];\n    if ( !v8 )\n    {\n      v9 = *v7 == 0;\nLABEL_19:\n      v11 = v9;\nLABEL_21:\n      v5 ^= v11;\n      goto LABEL_34;\n    }\n    if ( v17[2] )\n    {\n      v10 = (_BYTE *)v17[3];\n      if ( v10 )\n      {\n        if ( !v17[4] && *v7 == 40 && !v7[1] && *v10 == 41 && !v10[1] )\n        {\n          v17[3] = 0;\n          ++v17;\n        }\n      }\n      else\n      {\n        sub_8098C4C(v8);\n        if ( *(_BYTE *)(*((_DWORD *)v6 + 1) + 1) == 1 )\n        {\n          *(_DWORD *)v6 = v17;\n          v9 = sub_8098C8E() == 0;\n          goto LABEL_19;\n        }\n      }\n    }\n    if ( *(_BYTE *)*v17 != 33 || *(_BYTE *)(*v17 + 1) )\n      break;\n    ++v17;\n    v5 ^= 1u;\n  }\n  v12 = sub_8098C4C(**(const char ***)v6);\n  LODWORD(v13) = sub_80991CD(v12);\n  v5 = v13 == 0;\n  v14 = *(const char ***)v6;\n  if ( **(_DWORD **)v6 )\n  {\n    *(_DWORD *)v6 = v14 + 1;\n    v15 = v14[1];\n    if ( v15 )\n    {\n      sub_804D5F4(\"%s: unknown operand\", v15);\n      v5 = 2;\n    }\n  }\nLABEL_34:\n  free(*((void **)v6 + 2));\n  free(v6);\n  return v5;\n}\n"
    ],
    "sub_80993C2": [
        "0x80993c2",
        "int __cdecl sub_80993C2(int a1, int a2)\n{\n  char v2; // di\n  const char **v3; // ebx\n  int v4; // esi\n  struct timeval *p_tvp; // eax\n  int v6; // eax\n  const char *v8; // [esp+0h] [ebp-8Ch] BYREF\n  const char *v9; // [esp+4h] [ebp-88h] BYREF\n  time_t timer; // [esp+8h] [ebp-84h] BYREF\n  struct timeval tvp; // [esp+Ch] [ebp-80h] BYREF\n  __time_t tv_sec; // [esp+14h] [ebp-78h]\n  int v13; // [esp+18h] [ebp-74h]\n  struct tm tp; // [esp+1Ch] [ebp-70h] BYREF\n  __time_t v15; // [esp+64h] [ebp-28h]\n\n  v8 = 0;\n  v9 = 0;\n  tvp.tv_usec = 0;\n  v13 = 0;\n  v2 = sub_80ABEC2(a2, \"cr:d:t:fma\", \"no-create\", &v8, &v9, &v9);\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( !*v3 )\n    sub_804CDC2();\n  if ( v8 )\n  {\n    sub_804DFF3(v8);\n    tvp.tv_sec = v15;\n    tv_sec = v15;\n  }\n  if ( v9 )\n  {\n    time(&timer);\n    localtime_r(&timer, &tp);\n    sub_804E7FD(v9, &tp);\n    tp.tm_isdst = -1;\n    tvp.tv_sec = sub_804EB64(v9, &tp);\n    tv_sec = tvp.tv_sec;\n  }\n  v4 = 0;\n  do\n  {\n    p_tvp = &tvp;\n    if ( !v8 && !v9 )\n      p_tvp = 0;\n    if ( utimes(*v3, p_tvp) )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 2 )\n        goto LABEL_18;\n      if ( (v2 & 1) != 0 )\n        goto LABEL_19;\n      v6 = open64();\n      if ( v6 >= 0 )\n      {\n        sub_804DCF3(v6);\n        if ( v8 || v9 )\n          utimes(*v3, &tvp);\n      }\n      else\n      {\nLABEL_18:\n        sub_804D3F1(*v3);\n        v4 = 1;\n      }\n    }\nLABEL_19:\n    ++v3;\n  }\n  while ( *v3 );\n  return v4;\n}\n"
    ],
    "sub_809950C": [
        "0x809950c",
        "unsigned int __usercall sub_809950C@<eax>(char *a1@<eax>, size_t a2@<edx>)\n{\n  int v4; // esi\n  unsigned int v5; // ebx\n  char v7[272]; // [esp+0h] [ebp-110h] BYREF\n\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    if ( !memchr(a1, v4, a2) )\n      v7[v5++] = v4;\n    ++v4;\n  }\n  while ( v4 != 256 );\n  qmemcpy(a1, v7, v5);\n  return v5;\n}\n"
    ],
    "sub_8099551": [
        "0x8099551",
        "_BYTE *__usercall sub_8099551@<eax>(_BYTE *a1@<eax>, void **a2@<edx>, _BYTE *a3@<ecx>)\n{\n  void *v4; // esi\n  _BYTE *v5; // edi\n  int v6; // eax\n  unsigned __int8 v7; // al\n  _BYTE *v8; // ebp\n  int v9; // edi\n  int v10; // ebp\n  int i; // edx\n  int j; // ecx\n  int k; // ecx\n  unsigned int m; // eax\n  int v15; // eax\n  _BYTE *v17; // [esp+0h] [ebp-2Ch]\n  size_t v18; // [esp+8h] [ebp-24h]\n  unsigned __int8 v20; // [esp+10h] [ebp-1Ch]\n  char *ptr; // [esp+14h] [ebp-18h]\n\n  v4 = *a2;\n  v18 = 4096;\n  v5 = 0;\n  while ( *a1 )\n  {\n    if ( (unsigned int)(v5 + 256) > v18 )\n    {\n      v18 += 256;\n      v4 = sub_804DB13(v4, v18);\n      *a2 = v4;\n    }\n    if ( *a1 == 92 )\n      *a1 = sub_80B0CB3((_BYTE)a3);\n    v6 = (unsigned __int8)a1[1];\n    LOBYTE(a3) = *a1;\n    if ( (_BYTE)v6 == 45 )\n    {\n      v7 = a1[2];\n      if ( v7 )\n      {\n        v8 = (_BYTE *)(unsigned __int8)a3;\n        a1 += 3;\n        if ( v7 == 92 )\n          v7 = sub_80B0CB3((_BYTE)a3);\n        a3 = v8;\n        v9 = v5 - v8;\n        while ( 1 )\n        {\n          v17 = &a3[v9];\n          if ( v7 < (unsigned int)a3 )\n            break;\n          a3[(_DWORD)v4 + v9] = (_BYTE)a3;\n          ++a3;\n        }\n      }\n      else\n      {\n        ++a1;\n        v17 = v5 + 1;\n        v5[(_DWORD)v4] = (_BYTE)a3;\n      }\n      goto LABEL_60;\n    }\n    if ( (_BYTE)a3 != 91 )\n      goto LABEL_59;\n    if ( v6 == 58 )\n    {\n      v10 = (a1[2] == 120) + 7;\n      ptr = sub_804DB5D(a1 + 2, v10);\n      v20 = sub_804D222(\"alpha:]\", ptr);\n      free(ptr);\n      if ( v20 == 0xFF )\n        goto LABEL_59;\n      a1 += v10 + 2;\n      if ( (unsigned __int8)(v20 - 1) <= 1u || (v17 = v5, v20 == 9) )\n      {\n        for ( i = 48; i != 58; ++i )\n          v5[(_DWORD)v4 - 48 + i] = i;\n        v17 = v5 + 10;\n      }\n      if ( v20 <= 1u || v20 == 4 )\n      {\n        for ( j = 65; j != 91; ++j )\n          v17[(_DWORD)v4 - 65 + j] = j;\n        v17 += 26;\n        if ( v20 <= 1u )\n          goto LABEL_29;\n      }\n      if ( v20 == 3 )\n      {\nLABEL_29:\n        for ( k = 97; k != 123; ++k )\n          v17[(_DWORD)v4 - 97 + k] = k;\n        v17 += 26;\n      }\n      LOBYTE(a3) = v20 - 5;\n      if ( (unsigned __int8)(v20 - 5) <= 1u )\n      {\n        a3 = v17 + 1;\n        v17[(_DWORD)v4] = 9;\n        if ( v20 == 5 )\n        {\n          a3[(_DWORD)v4] = 10;\n          v17[(_DWORD)v4 + 2] = 11;\n          v17[(_DWORD)v4 + 3] = 12;\n          a3 = v17 + 5;\n          v17[(_DWORD)v4 + 4] = 13;\n        }\n        v17 = a3 + 1;\n        a3[(_DWORD)v4] = 32;\n      }\n      if ( (unsigned __int8)(v20 - 7) <= 1u )\n      {\n        for ( m = 0; m != 256; ++m )\n        {\n          if ( v20 == 7 )\n          {\n            LOBYTE(a3) = m - 32;\n            if ( m - 32 > 0x5E )\n              continue;\n            LOBYTE(a3) = m - 48;\n            if ( (unsigned __int8)(m - 48) <= 9u )\n              continue;\n            LOBYTE(a3) = (m | 0x20) - 97;\n            if ( (unsigned __int8)a3 <= 0x19u || (_BYTE)m == 32 )\n              continue;\n          }\n          else if ( v20 != 8 || m > 0x1F && (_BYTE)m != 127 )\n          {\n            continue;\n          }\n          (v17++)[(_DWORD)v4] = m;\n        }\n      }\n      if ( v20 == 9 )\n      {\n        v15 = 65;\n        a3 = &v17[(_DWORD)v4];\n        do\n        {\n          a3[v15 - 59] = v15 | 0x20;\n          a3[v15 - 65] = v15;\n          ++v15;\n        }\n        while ( v15 != 71 );\n        v17 += 12;\n      }\n    }\n    else\n    {\n      a3 = &v5[(_DWORD)v4];\n      v17 = v5 + 1;\n      if ( v6 != 61 )\n      {\nLABEL_59:\n        v17 = v5 + 1;\n        v5[(_DWORD)v4] = *a1++;\n        goto LABEL_60;\n      }\n      *a3 = a1[2];\n      if ( !a1[2] || a1[3] != 61 || a1[4] != 93 )\n        sub_804CDC2();\n      a1 += 5;\n    }\nLABEL_60:\n    v5 = v17;\n  }\n  return v5;\n}\n"
    ],
    "sub_80997F8": [
        "0x80997f8",
        "int __cdecl sub_80997F8(int a1, int a2)\n{\n  _BYTE *v2; // ebp\n  int i; // eax\n  char v4; // di\n  int v5; // esi\n  _BYTE *v6; // ecx\n  _BYTE *v7; // ebx\n  _BYTE *v8; // ecx\n  _BYTE *v9; // eax\n  _BYTE *v10; // edi\n  unsigned int v11; // ecx\n  _BYTE *v12; // edx\n  char v13; // al\n  char *v14; // esi\n  unsigned __int8 *v15; // edx\n  int j; // eax\n  _BYTE *v17; // edx\n  int k; // eax\n  int v19; // ebx\n  ssize_t v20; // eax\n  ssize_t v21; // edi\n  int v22; // ecx\n  int v23; // eax\n  int v24; // edx\n  int v25; // esi\n  _BYTE *v27; // [esp-4h] [ebp-38h]\n  char v28; // [esp+0h] [ebp-34h]\n  char *v29; // [esp+4h] [ebp-30h]\n  _BYTE *v30; // [esp+8h] [ebp-2Ch]\n  char *v31; // [esp+Ch] [ebp-28h]\n  _BYTE *v32; // [esp+10h] [ebp-24h]\n  int v33; // [esp+10h] [ebp-24h]\n  void *v34; // [esp+14h] [ebp-20h]\n  void *buf; // [esp+1Ch] [ebp-18h] BYREF\n  _BYTE *v36; // [esp+20h] [ebp-14h] BYREF\n\n  buf = sub_804DAFA(0x1000u);\n  v36 = sub_804DAFA(0x1000u);\n  v2 = sub_804DB2E(0x300u);\n  v29 = v2 + 256;\n  v31 = v2 + 512;\n  for ( i = 0; i != 256; ++i )\n    v2[i] = i;\n  v4 = sub_80ABEAC(a2, \"^+Ccds\");\n  v5 = a2 + 4 * optind;\n  v7 = sub_8099551(*(_BYTE **)v5, &buf, v6);\n  v28 = v4;\n  v8 = v27;\n  if ( (v4 & 3) != 0 )\n    v7 = (_BYTE *)sub_809950C((char *)buf, (size_t)v7);\n  v9 = *(_BYTE **)(v5 + 4);\n  if ( v9 )\n  {\n    if ( !*v9 )\n      sub_804D5E0(\"STRING2 cannot be empty\");\n    v30 = sub_8099551(v9, (void **)&v36, v8);\n    v10 = v30;\n    v32 = v36;\n    v34 = buf;\n    v11 = 0;\n    v12 = 0;\n    v13 = 48;\n    while ( v7 != v12 )\n    {\n      v14 = &v2[(unsigned __int8)v12[(_DWORD)v34]];\n      if ( (unsigned int)v30 > v11 )\n      {\n        v13 = v32[v11];\n        *v14 = v13;\n        ++v11;\n      }\n      else\n      {\n        *v14 = v13;\n      }\n      ++v12;\n    }\n  }\n  else\n  {\n    v10 = 0;\n  }\n  v15 = (unsigned __int8 *)buf;\n  for ( j = 0; j < (int)v7; ++j )\n    v29[v15[j]] = 1;\n  v17 = v36;\n  for ( k = 0; k < (int)v10; ++k )\n    v31[(unsigned __int8)v17[k]] = 1;\n  v19 = 256;\n  while ( 1 )\n  {\n    v20 = sub_804E5BC(0x1000u, buf, 0);\n    v21 = v20;\n    if ( v20 <= 0 )\n      break;\n    v22 = 0;\n    v23 = 0;\n    do\n    {\n      v33 = v23 + 1;\n      v24 = *((unsigned __int8 *)buf + v23);\n      if ( (v28 & 4) == 0 || !v29[v24] )\n      {\n        v25 = (unsigned __int8)v2[v24];\n        if ( (v28 & 8) == 0 || v19 != v25 || !v29[v24] && !v31[v19] )\n        {\n          v36[v22] = v2[v24];\n          v19 = v25;\n          ++v22;\n        }\n      }\n      ++v23;\n    }\n    while ( v21 != v33 );\n    if ( v22 )\n      sub_804DCAD(v22, (int)v36);\n  }\n  if ( v20 )\n    sub_804D3C9((int)\"read error\");\n  return 0;\n}\n"
    ],
    "sub_80999E3": [
        "0x80999e3",
        "int sub_80999E3()\n{\n  return 0;\n}\n"
    ],
    "sub_80999E6": [
        "0x80999e6",
        "int __cdecl sub_80999E6(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // edi\n  int v4; // ebp\n  char v6; // [esp+0h] [ebp-20h]\n  int v7[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v6 = sub_80ABEAC(a2, \"^cs:\", v7);\n  sub_80B3F8E();\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = 0;\n  while ( *v2 )\n  {\n    v4 = open64();\n    if ( v4 >= 0 )\n    {\n      if ( ftruncate64() == -1 )\n      {\n        sub_804D3A5((int)\"%s: truncate\", *v2);\n        v3 = 1;\n      }\n      sub_804DCF3(v4);\n    }\n    else if ( *(_DWORD *)dword_80DBB7C != 2 || (v6 & 1) == 0 )\n    {\n      sub_804D3A5((int)\"%s: open\", *v2);\n      v3 = 1;\n    }\n    ++v2;\n  }\n  return v3;\n}\n"
    ],
    "sub_8099AB6": [
        "0x8099ab6",
        "void __cdecl __noreturn sub_8099AB6(int a1, int a2)\n{\n  int v2; // esi\n  char *v3; // eax\n  int v4; // [esp+0h] [ebp-8h]\n  int v5; // [esp+4h] [ebp-4h]\n\n  byte_80DB560 = 2;\n  v2 = sub_80ABEAC(a2, 135062127);\n  sub_80B3CE5();\n  v3 = sub_804E0D9(0);\n  if ( !v3 )\n    v3 = \"not a tty\";\n  if ( !v2 )\n    puts(v3);\n  sub_80AB247(v4, v5);\n}\n"
    ],
    "sub_8099B08": [
        "0x8099b08",
        "void __cdecl __noreturn sub_8099B08(int a1, int a2)\n{\n  unsigned int v2; // ebx\n  const char *v3; // edi\n  unsigned __int16 *v4; // edi\n  const char *v5; // edx\n  _DWORD v6[65]; // [esp+0h] [ebp-220h] BYREF\n  char name_260; // [esp+106h] [ebp-11Ah] BYREF\n  char dest[65]; // [esp+188h] [ebp-98h] BYREF\n  char v9[65]; // [esp+1C9h] [ebp-57h] BYREF\n  char v10[22]; // [esp+20Ah] [ebp-16h] BYREF\n\n  if ( *ident == 117 )\n  {\n    v2 = sub_80ABEC2(a2, \"snrvmpioa\", \"all\");\n    if ( *(_DWORD *)(a2 + 4 * optind) )\n      sub_804CDC2();\n    if ( (v2 & 0x100) != 0 )\n    {\n      v2 = 255;\n      v3 = &data;\n    }\n    else\n    {\n      v3 = \"unknown\";\n      if ( !v2 )\n        v2 = 1;\n    }\n  }\n  else\n  {\n    v2 = 16;\n    v3 = \"unknown\";\n  }\n  uname((struct utsname *)((char *)v6 + 2));\n  if ( *ident == 97 )\n  {\n    puts(&name_260);\n  }\n  else\n  {\n    strcpy(dest, v3);\n    strcpy(v9, v3);\n    strcpy(v10, \"GNU/Linux\");\n    v4 = (unsigned __int16 *)&unk_80B7FEC;\n    v5 = \"%s\";\n    do\n    {\n      if ( (v2 & 1) != 0 )\n      {\n        if ( *((_BYTE *)v6 + *v4 + 2) )\n        {\n          printf(v5, (char *)v6 + *v4 + 2);\n          v5 = \"  %s\" + 1;\n        }\n      }\n      ++v4;\n      v2 >>= 1;\n    }\n    while ( v2 );\n    sub_804DD98(10);\n  }\n  sub_80AB247(v6[0], v6[1]);\n}\n"
    ],
    "sub_8099C08": [
        "0x8099c08",
        "void __cdecl __noreturn sub_8099C08(int a1, int a2)\n{\n  int *v2; // ebx\n  int v3; // esi\n  int v4; // eax\n  int v5; // eax\n  char *i; // edi\n  const char *v7; // ebx\n  int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  char *v11; // ebp\n  int k; // ebx\n  const char *v13; // eax\n  int v14; // eax\n  char *s1; // [esp+0h] [ebp-28h]\n  int j; // [esp+4h] [ebp-24h]\n  int v17; // [esp+8h] [ebp-20h]\n  int v18; // [esp+Ch] [ebp-1Ch] BYREF\n  int v19; // [esp+10h] [ebp-18h] BYREF\n  size_t n[5]; // [esp+14h] [ebp-14h] BYREF\n\n  v19 = 0;\n  v18 = 0;\n  n[0] = 0x7FFFFFFF;\n  v17 = sub_80ABEAC(a2, \"cduf:+s:+w:+i\", &v18, &v19, n);\n  v2 = (int *)(a2 + 4 * optind);\n  v3 = *v2;\n  if ( *v2 )\n  {\n    if ( *(_BYTE *)v3 != 45 || *(_BYTE *)(v3 + 1) )\n    {\n      close(0);\n      sub_804DBE1((const char *)v3);\n    }\n    v4 = v2[1];\n    if ( v4 )\n    {\n      if ( v2[2] )\n        sub_804CDC2();\n      if ( *(_BYTE *)v4 != 45 || *(_BYTE *)(v4 + 1) )\n      {\n        v5 = sub_804DBE1((const char *)v4);\n        sub_804DC97(v5, 1);\n      }\n    }\n  }\n  s1 = 0;\n  for ( i = 0; ; i = v11 )\n  {\n    v7 = s1;\n    for ( j = 0; ; ++j )\n    {\n      v8 = sub_80AB85A();\n      v11 = (char *)v8;\n      if ( !v8 )\n        break;\n      for ( k = v18; k; --k )\n      {\n        sub_80B2E8C(v10, v9);\n        v8 = sub_80B2E9F();\n      }\n      v7 = (const char *)v8;\n      v13 = (const char *)(v8 + v19);\n      while ( v7 != v13 && *v7 )\n        ++v7;\n      if ( !i )\n        goto LABEL_22;\n      if ( (v17 & 0x40) != 0 )\n        v14 = strncasecmp(s1, v7, n[0]);\n      else\n        v14 = strncmp(s1, v7, n[0]);\n      if ( v14 )\n        goto LABEL_29;\n      free(v11);\n    }\n    if ( !i )\n      break;\nLABEL_29:\n    if ( ((j == 0 ? 2 : 4) & v17) == 0 )\n    {\n      if ( (v17 & 1) != 0 )\n        printf(\"%7lu \", j + 1);\n      puts(i);\n    }\n    free(i);\n    if ( !v11 )\n      break;\nLABEL_22:\n    s1 = (char *)v7;\n  }\n  sub_804DD6F(stdin, (const char *)v3);\n  sub_80AB247(s1, j);\n}\n"
    ],
    "sub_8099D99": [
        "0x8099d99",
        "int __cdecl sub_8099D99(int a1, int a2)\n{\n  sub_80ABEAC(a2, \"^\");\n  sub_804DC28(*(const char **)(a2 + 4 * optind));\n  return 0;\n}\n"
    ],
    "sub_8099DBC": [
        "0x8099dbc",
        "int __cdecl sub_8099DBC(int a1, int a2)\n{\n  __useconds_t v2; // eax\n\n  if ( !*(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v2 = sub_80B40EC();\n  usleep(v2);\n  return 0;\n}\n"
    ],
    "sub_8099DDB": [
        "0x8099ddb",
        "void __noreturn sub_8099DDB()\n{\n  int v0[5]; // [esp+4h] [ebp-14h] BYREF\n\n  v0[0] = 0x10000;\n  sub_80AB359(v0, 135081797);\n}\n"
    ],
    "sub_8099F0D": [
        "0x8099f0d",
        "int __cdecl sub_8099F0D(int a1, int a2)\n{\n  _DWORD *v2; // eax\n  char *v3; // eax\n  char *v4; // ebx\n  const char *v5; // esi\n  void (__noreturn *v6)(); // ebp\n  FILE *v7; // esi\n  char *v8; // eax\n  int v9; // eax\n  int v11; // [esp-8h] [ebp-20h]\n  int v12; // [esp-4h] [ebp-1Ch]\n  int v13; // [esp+0h] [ebp-18h]\n  char *v14; // [esp+4h] [ebp-14h] BYREF\n\n  v14 = 0;\n  sub_80ABEAC(a2, \"^o:\", &v14);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v2 )\n    *(v2 - 1) = \"-\";\n  sub_80B3D9B();\n  while ( 1 )\n  {\n    v3 = (char *)sub_80AB85A();\n    v4 = v3;\n    if ( !v3 )\n      goto LABEL_14;\n    if ( sub_804D210(v3, \"begin-base64 \") )\n    {\n      v5 = v4 + 13;\n      v6 = (void (__noreturn *)())sub_80B3AAF;\n      goto LABEL_10;\n    }\n    if ( sub_804D210(v4, \"begin \") )\n      break;\n    free(v4);\n  }\n  v5 = v4 + 6;\n  v6 = sub_8099DDB;\nLABEL_10:\n  v13 = sub_804ED6C(8, v5, 0, (int)v4);\n  if ( !v14 )\n  {\n    v8 = strchr(v5, 32);\n    v14 = v8;\n    if ( !v8 || (v14 = v8 + 1, sub_80B2F61(v12, v11, v13), !*v14) )\nLABEL_14:\n      sub_804D5E0(\"no 'begin' line\");\n  }\n  v7 = stdout;\n  if ( *v14 != 45 || v14[1] )\n  {\n    v7 = (FILE *)sub_80B3D5D();\n    v9 = fileno_unlocked(v7);\n    fchmod(v9, v13 & 0x1FF);\n  }\n  free(v4);\n  ((void (__fastcall *)(int, FILE *))v6)(384, v7);\n  return 0;\n}\n"
    ],
    "sub_809A039": [
        "0x809a039",
        "void __cdecl __noreturn sub_809A039(int a1, int a2)\n{\n  int v2; // ebx\n  char *v3; // esi\n  const char **v4; // ebp\n  int v5; // edi\n  const char *v6; // eax\n  ssize_t v7; // eax\n  ssize_t v8; // ebx\n  const char *v9; // eax\n  int v10; // [esp-4h] [ebp-E0h]\n  int v11; // [esp+0h] [ebp-DCh] BYREF\n  char v12[61]; // [esp+2Fh] [ebp-ADh] BYREF\n  int v13; // [esp+7Ch] [ebp-60h]\n\n  v2 = ~(unsigned __int16)umask(0x1B6u) & 0x1B6;\n  v3 = byte_80D95B4;\n  if ( sub_80ABEAC(a2, \"^m\") )\n    v3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  v4 = (const char **)(a2 + 4 * optind);\n  v5 = 0;\n  if ( v4[1] )\n  {\n    v5 = sub_804DBE1(*v4);\n    fstat64();\n    v2 = v13 & 0x1FF;\n    ++v4;\n  }\n  v6 = \"-base64\";\n  if ( v3 == byte_80D95B4 )\n    v6 = &data;\n  printf(\"begin%s %o %s\", v6, v2, *v4);\n  while ( 1 )\n  {\n    v7 = sub_804E5E3(v5, (char *)&v11 + 2, 0x2Du);\n    v8 = v7;\n    if ( !v7 )\n      break;\n    if ( v7 < 0 )\n      sub_804D3C9((int)\"read error\");\n    sub_80B3958(v3);\n    sub_804DD98(10);\n    if ( v3 == byte_80D95B4 )\n      sub_804DD98((unsigned __int8)byte_80D95B4[v8]);\n    fflush(stdout);\n    sub_804DCAD(4 * ((v8 + 2) / 3u), (int)v12);\n  }\n  v9 = \"\\n====\\n\";\n  if ( v3 == byte_80D95B4 )\n    v9 = \"\\n`\\nend\\n\";\n  printf(v9);\n  sub_80AB247(v10, v11);\n}\n"
    ],
    "sub_809A176": [
        "0x809a176",
        "void __cdecl __noreturn sub_809A176(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // esi\n  const char **v4; // ebx\n  const char *v5; // ebp\n  int v6; // ebx\n  char v7; // di\n  unsigned int v8; // edx\n  unsigned __int8 *v9; // eax\n  int v10; // ecx\n  const char *v11; // eax\n  unsigned int i; // edi\n  int v13; // edx\n  int v14; // [esp+0h] [ebp-58h]\n  int v15; // [esp+4h] [ebp-54h]\n  const char **v16; // [esp+8h] [ebp-50h]\n  int v17; // [esp+8h] [ebp-50h]\n  char *format; // [esp+Ch] [ebp-4Ch]\n  char *v19; // [esp+10h] [ebp-48h]\n  int *v20; // [esp+14h] [ebp-44h]\n  unsigned int v21; // [esp+18h] [ebp-40h]\n  int v22[5]; // [esp+20h] [ebp-38h] BYREF\n  int v23[9]; // [esp+34h] [ebp-24h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"lwmcL\");\n  v3 = 11;\n  if ( v2 )\n    v3 = v2;\n  v4 = (const char **)(a2 + 4 * optind);\n  v19 = \"  %s\\n\" + 1;\n  if ( !*v4 )\n  {\n    *--v4 = \"standard input\";\n    v19 = (_BYTE *)(\", \\t\\n\" + 3);\n  }\n  format = \"%9u\";\n  if ( !v4[1] && (v3 & (v3 - 1)) == 0 )\n    format = \"\\nSuperblock backups stored on blocks:\\n\\t%u\" + 39;\n  memset(v23, 0, 0x14u);\n  HIBYTE(v14) = 0;\n  v15 = 0;\n  v20 = v22;\n  while ( 1 )\n  {\n    v16 = v4 + 1;\n    v5 = *v4;\n    if ( *v4 )\n    {\n      ++v15;\n      v6 = sub_80B3D76(v14);\n      if ( v6 )\n      {\n        memset(v22, 0, sizeof(v22));\n        v7 = 0;\n        v8 = 0;\n        while ( 1 )\n        {\n          v9 = *(unsigned __int8 **)(v6 + 16);\n          if ( (unsigned int)v9 >= *(_DWORD *)(v6 + 24) )\n          {\n            v21 = v8;\n            v10 = __fgetc_unlocked();\n            v8 = v21;\n            if ( v10 == -1 )\n            {\n              if ( (*(_BYTE *)v6 & 8) != 0 )\n              {\n                sub_804D3F1(v5);\n                HIBYTE(v14) = 1;\n                v8 = v21;\n                v10 = -1;\n              }\n              goto LABEL_23;\n            }\n          }\n          else\n          {\n            *(_DWORD *)(v6 + 16) = v9 + 1;\n            v10 = *v9;\n          }\n          ++v22[3];\n          ++v22[2];\n          if ( (unsigned int)(v10 - 32) > 0x5E )\n          {\n            if ( (unsigned int)(v10 - 9) <= 4 )\n            {\n              if ( v10 == 9 )\n              {\n                v8 = (v8 | 7) + 1;\n                goto LABEL_29;\n              }\nLABEL_23:\n              if ( v22[4] < v8 )\n                v22[4] = v8;\n              if ( v10 == 10 )\n              {\n                ++v22[0];\n              }\n              else if ( v10 == 11 )\n              {\n                goto LABEL_29;\n              }\n              v8 = 0;\nLABEL_29:\n              v22[1] += v7;\n              if ( v10 == -1 )\n              {\n                sub_80AB218(0, v8);\n                if ( v23[4] < (unsigned int)v22[4] )\n                  v23[4] = v22[4];\n                v23[4] -= v22[4];\n                v4 = v16;\n                goto LABEL_36;\n              }\n              v7 = 0;\n            }\n          }\n          else\n          {\n            ++v8;\n            if ( v10 == 32 )\n              goto LABEL_29;\n            v7 = 1;\n          }\n        }\n      }\n      HIBYTE(v14) = 1;\n    }\n    else\n    {\n      if ( v15 <= 1 )\n        sub_80AB247(v14, v15);\n      v15 = 0;\n      v20 = v23;\n      v5 = \"total\";\nLABEL_36:\n      v11 = format;\n      for ( i = 0; i != 5; ++i )\n      {\n        v13 = v20[i];\n        if ( _bittest(&v3, i) )\n        {\n          v17 = v20[i];\n          printf(v11);\n          v11 = \" %9u\";\n          v13 = v17;\n        }\n        v23[i] += v13;\n      }\n      printf(v19, v5);\n      v16 = v4;\n    }\n    v4 = v16;\n  }\n}\n"
    ],
    "sub_809A378": [
        "0x809a378",
        "int __cdecl sub_809A378(int a1, int a2)\n{\n  char v2; // bl\n  const char *v3; // eax\n  char v4; // di\n  struct utmpx *v5; // eax\n  struct utmpx *v6; // ebx\n  signed int v7; // eax\n  char *v8; // eax\n  int v10; // [esp+0h] [ebp-A8h]\n  time_t timer; // [esp+4h] [ebp-A4h] BYREF\n  char s[2]; // [esp+Bh] [ebp-9Dh] BYREF\n  char dest[5]; // [esp+11h] [ebp-97h] BYREF\n  int v14; // [esp+78h] [ebp-30h]\n\n  v2 = ident[1];\n  v3 = \"^\";\n  if ( v2 == 104 )\n    v3 = \"^aH\";\n  v4 = sub_80ABEAC(a2, v3);\n  if ( (v4 & 2) != 0 || !v2 )\n    puts(\"USER\\t\\tTTY\\t\\tIDLE\\tTIME\\t\\t HOST\");\n  setutxent();\n  while ( 1 )\n  {\n    v5 = getutxent();\n    v6 = v5;\n    if ( !v5 )\n      break;\n    if ( v5->ut_user[0] && ((v4 & 1) != 0 || v5->ut_type == 7) )\n    {\n      strcpy(s, \"?\");\n      strcpy(dest, \"/dev/\");\n      sub_80B2C4E(33, v6->ut_line);\n      if ( !stat64() )\n      {\n        v10 = v14;\n        v7 = time(0) - v10;\n        if ( (unsigned int)v7 > 0x1517F )\n          strcpy(s, \"old\");\n        else\n          sprintf(s, \"%02d:%02d\", v7 / 3600, v7 % 3600 / 60);\n      }\n      timer = v6->ut_tv.tv_sec;\n      v8 = ctime(&timer);\n      printf(\"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\", 32, v6->ut_user, 32, v6->ut_line, s, v8 + 4, 256, v6->ut_host);\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_809A4CC": [
        "0x809a4cc",
        "int __cdecl sub_809A4CC(int a1, int a2)\n{\n  const char *v2; // eax\n\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  geteuid();\n  v2 = (const char *)sub_80A99ED();\n  puts(v2);\n  return sub_804DD8F();\n}\n"
    ],
    "sub_809A4F1": [
        "0x809a4f1",
        "void __cdecl __noreturn sub_809A4F1(int a1, _DWORD *a2)\n{\n  _DWORD *v2; // esi\n  _DWORD *v3; // ebx\n  _BYTE *v4; // edx\n  int v5; // [esp-4h] [ebp-Ch]\n\n  *a2 = 135085706;\n  v2 = a2 + 1;\n  if ( !a2[1] )\n    v2 = a2;\n  while ( 1 )\n  {\n    v3 = v2;\n    while ( 1 )\n    {\n      fputs_unlocked();\n      ++v3;\n      v4 = *(_BYTE **)(_stdout + 16);\n      if ( !*v3 )\n        break;\n      if ( (unsigned int)v4 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked();\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v4 + 1;\n        *v4 = 32;\n      }\n    }\n    if ( (unsigned int)v4 >= *(_DWORD *)(_stdout + 28) )\n    {\n      v5 = _stdout;\n      if ( __fputc_unlocked() == -1 )\n        sub_80B0A23(v5, 10);\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v4 + 1;\n      *v4 = 10;\n    }\n  }\n}\n"
    ],
    "sub_809A567": [
        "0x809a567",
        "int __usercall sub_809A567@<eax>(const char *a1@<eax>, int a2@<edx>, int (__cdecl *a3)()@<ecx>)\n{\n  int result; // eax\n\n  if ( a3() >= 0 )\n    return 2 * ((*(_DWORD *)(a2 + 16) & 0xF000) == 0x4000) + 1;\n  result = 0;\n  if ( *(_DWORD *)dword_80DBB7C != 2 )\n  {\n    sub_804D3A5((int)\"can't stat '%s'\", a1);\n    return -1;\n  }\n  return result;\n}\n"
    ],
    "sub_809A5B0": [
        "0x809a5b0",
        "int __usercall sub_809A5B0@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  return sub_809A567(a1, a2, stat64);\n}\n"
    ],
    "sub_809A5BA": [
        "0x809a5ba",
        "int __usercall sub_809A5BA@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int v3; // [esp+0h] [ebp-8h] BYREF\n\n  v3 = 0;\n  v1 = 438;\n  if ( (sub_80ABEAC(a1, 135039668, &v3) & 1) != 0 )\n  {\n    v1 = sub_80B07AF();\n    if ( v1 != -1 )\n      umask(0);\n  }\n  return v1;\n}\n"
    ],
    "sub_809A5FC": [
        "0x809a5fc",
        "int sub_809A5FC()\n{\n  time_t i; // esi\n  int v1; // edx\n  signed int v2; // ebx\n  int v3; // edx\n  time_t v4; // edi\n  char v6[4108]; // [esp+0h] [ebp-100Ch] BYREF\n\n  for ( i = time(0); ; i = v4 )\n  {\n    v2 = sub_804E5BC(0x1000u, v6, 0);\n    if ( v2 <= 0 )\n      break;\n    v4 = time(0);\n    if ( i != v4 )\n      sub_804D830(46, v3);\n    sub_804E586(v2, v6);\n  }\n  sub_804D830(10, v1);\n  return 0;\n}\n"
    ],
    "sub_809A663": [
        "0x809a663",
        "int __cdecl sub_809A663(const char **a1, const char **a2)\n{\n  int result; // eax\n\n  result = strcmp(*a1, *a2);\n  if ( (dword_80DBB9C & 4) != 0 )\n    return -result;\n  return result;\n}\n"
    ],
    "sub_809A682": [
        "0x809a682",
        "int __userpurge sub_809A682@<eax>(const char *a1@<eax>, int a2@<edx>, int a3)\n{\n  int v3; // esi\n  char *i; // edi\n  char v6; // dl\n  int v7; // edx\n  char **v8; // esi\n\n  v3 = a3;\n  if ( a3 != 1 )\n  {\n    if ( a3 != 2 )\n      goto LABEL_12;\n    if ( (*(_DWORD *)(a2 + 16) & 0xA000) != 0 )\n    {\n      for ( i = sub_804D315(a1); ; ++i )\n      {\n        v6 = *i;\n        if ( !*i )\n          break;\n        if ( (unsigned __int8)(v6 - 48) > 9u && v6 != 95 && (unsigned __int8)((*i | 0x20) - 97) > 0x19u && v6 != 45 )\n          return v3;\n      }\n      if ( !access(a1, 1) )\n      {\nLABEL_12:\n        LODWORD(qword_80DB778) = sub_80B4733(HIDWORD(qword_80DB778), 1028);\n        v7 = HIDWORD(qword_80DB778)++;\n        v8 = (char **)(qword_80DB778 + 4 * v7);\n        *v8 = sub_804DB46(a1);\n        return 1;\n      }\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_809A72F": [
        "0x809a72f",
        "int __cdecl sub_809A72F(int a1, int a2)\n{\n  unsigned int v2; // eax\n  int i; // ebx\n  int v4; // ebx\n  const char **v5; // eax\n  const char *v6; // esi\n  int v7; // eax\n  const char *v9; // [esp+0h] [ebp-14h] BYREF\n  _DWORD *v10[4]; // [esp+4h] [ebp-10h] BYREF\n\n  v9 = \"22\";\n  v10[0] = 0;\n  sub_80ABEC2(a2, \"^a:*u:\", \"arg\", v10, &v9);\n  v2 = sub_80B4093(v9, 8, 0, 0xFFFu);\n  umask(v2);\n  for ( i = 1; v10[0] && i != 251; *((_DWORD *)&qword_80DB778 + i + 1) = sub_80AFB01(v10) )\n    ++i;\n  sub_80B2549(\n    *(const char **)(a2 + 4 * optind),\n    3,\n    (int (__stdcall *)(int))sub_809A682,\n    (int (__stdcall *)(int))sub_809A682,\n    0,\n    1);\n  if ( !(_DWORD)qword_80DB778 )\n    return 0;\n  qsort((void *)qword_80DB778, HIDWORD(qword_80DB778), 4u, (__compar_fn_t)sub_809A663);\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = (const char **)qword_80DB778;\n    LODWORD(qword_80DB778) = qword_80DB778 + 4;\n    v6 = *v5;\n    if ( !*v5 )\n      break;\n    if ( (dword_80DBB9C & 8) != 0 )\n    {\n      puts(*v5);\n    }\n    else\n    {\n      unk_80DB780 = (time_t)*v5;\n      v7 = sub_80B3C03((const char **)&unk_80DB780);\n      if ( v7 )\n      {\n        if ( v7 >= 0 )\n          sub_804D5F4(\"%s: exit status %u\", v6, (unsigned __int8)v7);\n        else\n          sub_804D3A5((int)\"can't execute '%s'\", v6);\n        if ( (dword_80DBB9C & 0x10) != 0 )\n          sub_804D604();\n        v4 = 1;\n      }\n    }\n  }\n  return v4;\n}\n"
    ],
    "sub_809A865": [
        "0x809a865",
        "int __usercall sub_809A865@<eax>(int a1@<eax>)\n{\n  char *v2; // ebp\n  char *v3; // edi\n  _BOOL4 v4; // eax\n  int result; // eax\n  const char *v6; // ebx\n  _BOOL4 v7; // [esp+0h] [ebp-88h]\n  char v8[19]; // [esp+5h] [ebp-83h] BYREF\n  char s[24]; // [esp+18h] [ebp-70h] BYREF\n  char *v10; // [esp+30h] [ebp-58h]\n  char v11; // [esp+37h] [ebp-51h]\n\n  if ( !*(&unk_80DB780 + 1) )\n    goto LABEL_21;\n  v2 = &v8[sprintf(s, \"/proc/%u/exe\", a1) + 16];\n  v3 = (char *)sub_804E190(s);\n  v4 = 0;\n  if ( v3 )\n    v4 = strcmp((const char *)*(&unk_80DB780 + 1), v3) == 0;\n  v7 = v4;\n  free(v3);\n  if ( v7\n    || (strcpy(v2, \"cmdline\"),\n        result = sub_804E632((size_t)*(&MEMORY[0x80DB788] + 2), *(&MEMORY[0x80DB788] + 1)),\n        result > 0)\n    && ((*(&MEMORY[0x80DB788] + 1))[result] = 0,\n        (result = strcmp((const char *)*(&unk_80DB780 + 1), *(&MEMORY[0x80DB788] + 1))) == 0) )\n  {\nLABEL_21:\n    if ( !unk_80DB780 )\n      goto LABEL_22;\n    sprintf(s, \"/proc/%u/stat\", a1);\n    result = sub_804E632(0x1Fu, s);\n    if ( result >= 0 )\n    {\n      v11 = 0;\n      result = (int)strchr(s, 40);\n      if ( result )\n      {\n        v6 = (const char *)(result + 1);\n        result = (int)strrchr((const char *)(result + 1), 41);\n        if ( result )\n        {\n          *(_BYTE *)result = 0;\n          result = strlen(v6);\n          if ( (unsigned int)result <= 0xE )\n          {\n            result = strcmp(v6, (const char *)unk_80DB780);\n            if ( !result )\n            {\nLABEL_22:\n              if ( !HIDWORD(qword_80DB778)\n                || (sprintf(v8, \"/proc/%u\", a1), (result = stat64()) == 0)\n                && (result = (int)*(&MEMORY[0x80DB788] + 3), v10 == *(&MEMORY[0x80DB788] + 3)) )\n              {\n                result = (int)sub_804DAFA(8u);\n                *(_DWORD *)result = qword_80DB778;\n                *(_DWORD *)(result + 4) = a1;\n                LODWORD(qword_80DB778) = result;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_809A9EB": [
        "0x809a9eb",
        "int __cdecl sub_809A9EB(int a1, int a2)\n{\n  unsigned int v2; // ebx\n  size_t v3; // eax\n  int v4; // edi\n  int v5; // ecx\n  FILE *v6; // esi\n  DIR *v7; // ebp\n  int v8; // esi\n  int v9; // eax\n  const char *v10; // esi\n  char *v11; // eax\n  _DWORD *v12; // edi\n  int v13; // ebp\n  int v14; // eax\n  _DWORD *i; // esi\n  int v17; // eax\n  int v18; // ebx\n  int v19; // ebx\n  int v20; // [esp-4h] [ebp-2Ch]\n  int v21; // [esp+0h] [ebp-28h] BYREF\n  char *file; // [esp+4h] [ebp-24h] BYREF\n  int v23; // [esp+8h] [ebp-20h] BYREF\n  int v24; // [esp+Ch] [ebp-1Ch] BYREF\n  int v25; // [esp+10h] [ebp-18h] BYREF\n  __gid_t groups[5]; // [esp+14h] [ebp-14h] BYREF\n\n  *(&MEMORY[0x80DB788] + 3) = (char *)-1;\n  LOBYTE(dword_80DB798) = 15;\n  v2 = sub_80ABEC2(\n         a2,\n         \"^KSbqtma:n:s:u:c:x:p:ovN:R:\",\n         \"stop\",\n         &file,\n         &unk_80DB780,\n         &v21,\n         (char *)&qword_80DB778 + 4,\n         &v23,\n         135116676,\n         &MEMORY[0x80DB788],\n         &v24,\n         0);\n  if ( (v2 & 0x100) != 0 )\n  {\n    LOBYTE(dword_80DB798) = sub_80B2FB5();\n    if ( (char)dword_80DB798 < 0 )\n      sub_804CDC2();\n  }\n  if ( (v2 & 0x40) == 0 )\n    file = (char *)*(&unk_80DB780 + 1);\n  if ( !*(&unk_80DB780 + 1) )\n    *(&unk_80DB780 + 1) = (time_t)file;\n  if ( *(&unk_80DB780 + 1) )\n  {\n    v3 = strlen((const char *)*(&unk_80DB780 + 1));\n    *(&MEMORY[0x80DB788] + 2) = (char *)(v3 + 1);\n    *(&MEMORY[0x80DB788] + 1) = (char *)sub_804DAFA(v3 + 2);\n  }\n  v4 = a2 + 4 * optind;\n  if ( HIDWORD(qword_80DB778) )\n  {\n    *(&MEMORY[0x80DB788] + 3) = (char *)sub_804ED6C(10, (const char *)HIDWORD(qword_80DB778), 0, v2);\n    if ( *(_DWORD *)dword_80DBB7C )\n      *(&MEMORY[0x80DB788] + 3) = (char *)sub_80A9A43();\n  }\n  if ( MEMORY[0x80DB788] )\n  {\n    v6 = (FILE *)sub_80B3D37();\n    if ( v6 )\n    {\n      if ( fscanf(v6, \"%u\", &v25) == 1 )\n        sub_809A865(v25);\n      fclose(v6);\n      v5 = v20;\n    }\n    else if ( *(_DWORD *)dword_80DBB7C != 2 )\n    {\n      sub_804D3C9((int)\"open pidfile %s\", MEMORY[0x80DB788]);\n    }\n  }\n  else\n  {\n    v7 = sub_804DF7E(\"/proc\");\n    v8 = 0;\n    while ( 1 )\n    {\n      do\n      {\n        *(_DWORD *)dword_80DBB7C = 0;\n        v9 = readdir64();\n      }\n      while ( *(_DWORD *)dword_80DBB7C );\n      if ( !v9 )\n        break;\n      v8 = sub_804ED6C(10, (const char *)(v9 + 19), 0, v2);\n      if ( !*(_DWORD *)dword_80DBB7C )\n        sub_809A865(v8);\n    }\n    closedir(v7);\n    if ( !v8 )\n      sub_804D5E0(\"nothing in /proc - not mounted?\");\n  }\n  if ( (v2 & 1) != 0 )\n  {\n    v10 = (const char *)unk_80DB780;\n    if ( !unk_80DB780 )\n    {\n      v10 = (const char *)*(&unk_80DB780 + 1);\n      if ( !*(&unk_80DB780 + 1) )\n      {\n        if ( MEMORY[0x80DB788] )\n        {\n          v11 = sub_804DDBF(\"process in pidfile '%s'\", MEMORY[0x80DB788]);\n        }\n        else\n        {\n          if ( !HIDWORD(qword_80DB778) )\n            sub_804D5E0(\"internal error, please report\");\n          v11 = sub_804DDBF(\"process(es) owned by '%s'\", HIDWORD(qword_80DB778));\n        }\n        v10 = v11;\n      }\n    }\n    v12 = (_DWORD *)qword_80DB778;\n    if ( (_DWORD)qword_80DB778 )\n    {\n      v13 = 0;\n      do\n      {\n        v14 = 0;\n        if ( (dword_80DBB9C & 0x10) == 0 )\n          v14 = (char)dword_80DB798;\n        if ( kill(v12[1], v14) )\n        {\n          sub_804D3A5((int)\"warning: killing process %u\", v12[1]);\n          v12[1] = 0;\n          if ( (dword_80DBB9C & 0x10) != 0 )\n            goto LABEL_39;\n        }\n        else\n        {\n          ++v13;\n        }\n        v12 = (_DWORD *)*v12;\n      }\n      while ( v12 );\n      if ( (dword_80DBB9C & 8) == 0 && v13 )\n      {\n        printf(\"stopped %s (pid\", v10);\n        for ( i = (_DWORD *)qword_80DB778; i; i = (_DWORD *)*i )\n        {\n          if ( i[1] )\n            printf(\" %u\", i[1]);\n        }\n        puts(\")\");\n      }\n    }\n    else\n    {\n      if ( (dword_80DBB9C & 8) == 0 )\n        printf(\"no %s found; none killed\\n\", v10);\nLABEL_39:\n      v13 = -1;\n    }\n    return ((v2 >> 13) ^ 1) & (v13 <= 0);\n  }\n  else\n  {\n    if ( !(_DWORD)qword_80DB778 )\n    {\n      *(_DWORD *)(v4 - 4) = file;\n      if ( (v2 & 4) != 0 )\n        sub_80B3C0D();\n      if ( (v2 & 0x20) != 0 )\n        sub_80B0A2C();\n      if ( (v2 & 0x400) != 0 )\n      {\n        sub_80B48BE(v5, v23);\n        if ( v25 == -1 )\n        {\n          if ( groups[0] != -1 )\n          {\n            sub_804DE5E(groups[0]);\n            setgroups(1u, groups);\n          }\n        }\n        else\n        {\n          v17 = sub_80A99D2();\n          if ( groups[0] != -1 )\n            *(_DWORD *)(v17 + 12) = groups[0];\n          sub_80A9B93();\n        }\n      }\n      if ( (v2 & 0x8000) != 0 )\n      {\n        v18 = getpriority(0, 0);\n        v19 = sub_80B4160(0x3FFFFFFF, -1073741824) + v18;\n        if ( setpriority(0, 0, v19) < 0 )\n          sub_804D3C9((int)\"setpriority(%d)\", v19);\n      }\n      execvp(file, (char *const *)(v4 - 4));\n      sub_804D3C9((int)\"can't execute '%s'\", file);\n    }\n    if ( (dword_80DBB9C & 8) == 0 )\n      printf(\"%s is already running\\n%u\\n\", (const char *)*(&unk_80DB780 + 1), *(_DWORD *)(qword_80DB778 + 4));\n    return ((unsigned __int8)(v2 >> 13) ^ 1) & 1;\n  }\n}\n"
    ],
    "sub_809ADCB": [
        "0x809adcb",
        "int __cdecl sub_809ADCB(int a1, int a2)\n{\n  char *v2; // ebp\n  const char **v3; // ebx\n  int v4; // edi\n  char *v5; // eax\n  int v6; // ecx\n  int v7; // esi\n  const char *v8; // eax\n  int v10; // [esp-8h] [ebp-44h]\n  int v11; // [esp-4h] [ebp-40h]\n  char *ptr; // [esp+0h] [ebp-3Ch]\n  char *v13; // [esp+4h] [ebp-38h] BYREF\n  char dest[51]; // [esp+9h] [ebp-33h] BYREF\n\n  v2 = getenv(\"PATH\");\n  if ( !v2 )\n    v2 = strcpy(dest, \"/sbin:/usr/sbin:/bin:/usr/bin\");\n  sub_80ABEAC(a2, &unk_80D7396);\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = 0;\n  do\n  {\n    v5 = strchr(*v3, 47);\n    v6 = v11;\n    if ( v5 )\n    {\n      v7 = 1;\n      if ( sub_80AB151(v11, v10) )\n      {\n        puts(*v3);\n        v7 = 0;\n      }\n    }\n    else\n    {\n      v13 = v2;\n      v7 = 1;\n      do\n      {\n        v8 = (const char *)sub_80AB18F(v6, &v13);\n        if ( !v8 )\n          break;\n        ptr = (char *)v8;\n        puts(v8);\n        free(ptr);\n        v7 = 0;\n      }\n      while ( dword_80DBB9C );\n    }\n    v4 |= v7;\n    ++v3;\n  }\n  while ( *v3 );\n  return v4;\n}\n"
    ],
    "sub_809AE8C": [
        "0x809ae8c",
        "int __cdecl sub_809AE8C(int a1, _DWORD *a2)\n{\n  int v2; // ecx\n  int result; // eax\n\n  while ( 1 )\n  {\n    result = *++a2;\n    if ( !*a2 )\n      break;\n    sub_80B2709(v2, 12);\n  }\n  return result;\n}\n"
    ],
    "sub_809AEA8": [
        "0x809aea8",
        "int __cdecl sub_809AEA8(int a1, int a2)\n{\n  char *v2; // ebx\n  char *v3; // eax\n  char *v4; // esi\n  _DWORD *v5; // ebp\n  int v6; // ecx\n  int v7; // esi\n  int v8; // edi\n  int v9; // eax\n  __int64 v10; // kr00_8\n  unsigned int v11; // ebp\n  __int64 v12; // rcx\n  unsigned int v13; // eax\n  char *v14; // eax\n  int v15; // ecx\n  __int64 v17; // [esp+4h] [ebp-9Ch]\n  int v18; // [esp+Ch] [ebp-94h] BYREF\n  int v19; // [esp+10h] [ebp-90h] BYREF\n  char s[28]; // [esp+14h] [ebp-8Ch] BYREF\n  int v21; // [esp+40h] [ebp-60h]\n  int v22; // [esp+50h] [ebp-50h]\n  int v23; // [esp+54h] [ebp-4Ch]\n\n  v2 = *(char **)(a2 + 4);\n  if ( !v2 )\n    sub_804CDC2();\n  if ( strncmp(v2, \"/dev/\", 5u) )\n  {\n    v3 = strchr(v2, 58);\n    v4 = v3;\n    v5 = (_DWORD *)dword_80DBB7C;\n    if ( v3 )\n    {\n      *v3 = 0;\n      v18 = sub_804ED6C(10, v2, 0, (int)v2);\n      if ( !*v5 )\n        v19 = sub_804ED6C(10, v4 + 1, 0, (int)v2);\n      *v4 = 58;\n      if ( !*v5 )\n        goto LABEL_17;\n    }\n    else\n    {\n      v7 = sub_804ED6C(16, v2, 0, (int)v2);\n      v8 = 0;\n      if ( !*v5 )\n        goto LABEL_18;\n    }\n    v2 = sub_804DDBF(\"/dev/%s\", v2);\n  }\n  if ( !stat64() && (v21 & 0xF000) == 24576 )\n  {\n    v7 = v22;\n    v8 = v23;\n    goto LABEL_18;\n  }\n  sub_804DDBF(\"/sys/class/block/%s/dev\", v2 + 5);\n  v9 = sub_804E632(0x1Bu, s);\n  if ( v9 <= 0 || (s[v9] = 0, sscanf(s, \"%u:%u\", &v18, &v19) != 2) )\n  {\n    v7 = 0;\n    v8 = 0;\n    goto LABEL_18;\n  }\nLABEL_17:\n  v10 = sub_80B0220(v6, v19);\n  v8 = HIDWORD(v10);\n  v7 = v10;\nLABEL_18:\n  v11 = gnu_dev_major(__PAIR64__(v8, v7));\n  if ( !v11 )\n    sub_804D5E0(\"invalid resume device: %s\", *(const char **)(a2 + 4));\n  v12 = 0LL;\n  if ( *(_DWORD *)(a2 + 8) )\n    v12 = sub_80B3F55(0, 0);\n  v17 = v12;\n  sub_804DBE1(\"/sys/power/resume\");\n  v13 = gnu_dev_minor(__PAIR64__(v8, v7));\n  v14 = sub_804DDBF(\"%u:%u:%llu\", v11, v13, v17);\n  sub_804DCD4(v15, v14);\n  return 1;\n}\n"
    ],
    "sub_809B072": [
        "0x809b072",
        "int __usercall sub_809B072@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  bool v5; // zf\n  unsigned int v6; // eax\n  int v7; // eax\n  int v8; // [esp-8h] [ebp-74h]\n  int v9; // [esp-8h] [ebp-74h]\n  unsigned int v10; // [esp+0h] [ebp-6Ch] BYREF\n  int v11; // [esp+14h] [ebp-58h]\n\n  if ( lstat64() )\n  {\n    sub_804D3A5((int)\"stat %s\", a1);\n    return v8;\n  }\n  result = v11 & 0xF000;\n  if ( result == 40960 )\n  {\n    v5 = *(_BYTE *)(a2 + 16) == 0;\n  }\n  else\n  {\n    result -= 0x4000;\n    v5 = (result & 0xFFFFB000) == 0;\n  }\n  if ( v5 )\n  {\n    if ( (*(_BYTE *)(a2 + 12) & 8) != 0 && sub_809B307(a1, 0, *(_DWORD *)a2) )\n      sub_804D3A5((int)\"setting version on %s\", a1);\n    if ( (*(_BYTE *)(a2 + 12) & 4) != 0 )\n    {\n      v6 = *(_DWORD *)(a2 + 4);\n    }\n    else\n    {\n      if ( sub_809B35F(a1, &v10, 0) )\n      {\n        sub_804D3A5((int)\"reading flags on %s\", a1);\n        goto LABEL_19;\n      }\n      v7 = *(_DWORD *)(a2 + 4) | v10 & ~*(_DWORD *)(a2 + 8);\n      v10 = v7;\n      if ( (v11 & 0xF000) == 0x4000 )\n      {\nLABEL_17:\n        result = sub_809B35F(a1, 0, v10);\n        if ( !result )\n          goto LABEL_20;\n        sub_804D3A5((int)\"setting flags on %s\", a1);\nLABEL_19:\n        result = v9;\nLABEL_20:\n        if ( *(_BYTE *)(a2 + 16) )\n        {\n          result = v11 & 0xF000;\n          if ( result == 0x4000 )\n            return sub_809B2CC(a1, (int)sub_809B181, a2);\n        }\n        return result;\n      }\n      v6 = v7 & 0xFFFEFFFF;\n    }\n    v10 = v6;\n    goto LABEL_17;\n  }\n  return result;\n}\n"
    ],
    "sub_809B181": [
        "0x809b181",
        "int __fastcall sub_809B181(int a1, int a2)\n{\n  char *v3; // eax\n  char *v4; // ebx\n\n  v3 = (char *)sub_80A9BF5(a1, a2 + 19);\n  if ( v3 )\n  {\n    v4 = v3;\n    sub_809B072(v3, a1);\n    free(v4);\n  }\n  return 0;\n}\n"
    ],
    "sub_809B1A6": [
        "0x809b1a6",
        "int __cdecl sub_809B1A6(int a1, char **a2)\n{\n  char **v3; // edi\n  char *v4; // ebx\n  int *v5; // esi\n  int v6; // eax\n  char v7; // al\n  char *v8; // eax\n  char v10; // [esp+3h] [ebp-25h]\n  int v11[9]; // [esp+4h] [ebp-24h] BYREF\n\n  memset(v11, 0, 0x14u);\nLABEL_2:\n  v3 = a2 + 1;\n  v4 = a2[1];\n  if ( !v4 )\n    goto LABEL_3;\n  v10 = *v4;\n  if ( *v4 == 45 )\n  {\n    v11[3] |= 2u;\n    v5 = &v11[2];\n    goto LABEL_17;\n  }\n  if ( v10 == 61 || v10 == 43 )\n  {\n    if ( v10 == 43 )\n      v6 = v11[3] | 1;\n    else\n      v6 = v11[3] | 4;\n    v11[3] = v6;\n    v5 = &v11[1];\nLABEL_17:\n    a2 = v3;\n    while ( 1 )\n    {\n      v7 = *++v4;\n      if ( !*v4 )\n        goto LABEL_2;\n      if ( v10 != 45 )\n        goto LABEL_22;\n      if ( v7 == 82 )\n      {\n        LOBYTE(v11[4]) = 1;\n      }\n      else if ( ((v7 - 86) & 0xEF) != 0 )\n      {\n        if ( v7 == 118 )\n        {\n          ++v3;\n          if ( a2[1] )\n          {\n            v11[0] = sub_80B40EC();\n            v11[3] |= 8u;\n            goto LABEL_17;\n          }\nLABEL_3:\n          sub_804CDC2();\n        }\nLABEL_22:\n        v8 = strchr(\"suSDiadAcjtT\", (unsigned __int8)*v4);\n        if ( !v8 )\n          goto LABEL_3;\n        *v5 |= dword_80B6AA4[v8 - \"suSDiadAcjtT\"];\n      }\n    }\n  }\n  if ( (v11[3] & 4) != 0 && (v11[3] & 3) != 0 )\n    sub_804D5E0(\"= is incompatible with - and +\");\n  if ( (v11[2] & v11[1]) != 0 )\n    sub_804D5E0(\"can't set and unset a flag\");\n  if ( !v11[3] )\n    sub_804D5E0(\"must use '-v', =, - or +\");\n  do\n    sub_809B072(*v3++, (int)v11);\n  while ( *v3 );\n  return 0;\n}\n"
    ],
    "sub_809B2CC": [
        "0x809b2cc",
        "int __cdecl sub_809B2CC(char *name, void (__fastcall *a2)(int, int), int a3)\n{\n  DIR *v3; // ebx\n  int result; // eax\n  int v5; // eax\n\n  v3 = opendir(name);\n  result = -1;\n  if ( v3 )\n  {\n    while ( 1 )\n    {\n      v5 = readdir64();\n      if ( !v5 )\n        break;\n      a2(a3, v5);\n    }\n    closedir(v3);\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_809B307": [
        "0x809b307",
        "int sub_809B307(int a1, int a2, ...)\n{\n  int v2; // ebx\n  int v3; // eax\n  int v4; // esi\n  _DWORD *v5; // edi\n  int v6; // ebp\n  va_list va; // [esp+1Ch] [ebp+Ch] BYREF\n\n  va_start(va, a2);\n  v2 = open64();\n  if ( v2 != -1 )\n  {\n    if ( a2 )\n      v3 = ioctl(v2, 0x80047601, a2);\n    else\n      v3 = ioctl(v2, 0x40047602u, va);\n    v4 = v3;\n    v5 = (_DWORD *)dword_80DBB7C;\n    v6 = *(_DWORD *)dword_80DBB7C;\n    close(v2);\n    *v5 = v6;\n    return v4;\n  }\n  return v2;\n}\n"
    ],
    "sub_809B35F": [
        "0x809b35f",
        "int sub_809B35F(int a1, int a2, ...)\n{\n  int v2; // ebx\n  int v3; // eax\n  int v4; // esi\n  _DWORD *v5; // edi\n  int v6; // ebp\n  __int16 v8; // [esp+10h] [ebp-60h]\n  va_list va; // [esp+7Ch] [ebp+Ch] BYREF\n\n  va_start(va, a2);\n  if ( !stat64() && (((v8 & 0xF000) - 0x4000) & 0xFFFFB000) != 0 )\n  {\n    *(_DWORD *)dword_80DBB7C = 95;\n    return -1;\n  }\n  else\n  {\n    v2 = open64();\n    if ( v2 != -1 )\n    {\n      if ( a2 )\n        v3 = ioctl(v2, 0x80046601, a2);\n      else\n        v3 = ioctl(v2, 0x40046602u, va);\n      v4 = v3;\n      v5 = (_DWORD *)dword_80DBB7C;\n      v6 = *(_DWORD *)dword_80DBB7C;\n      close(v2);\n      *v5 = v6;\n      return v4;\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_809B3F2": [
        "0x809b3f2",
        "int __cdecl sub_809B3F2(int a1, int a2, char a3)\n{\n  int v3; // ecx\n  int v4; // edx\n  const char *v5; // esi\n  int *v6; // ebp\n  int v8; // esi\n  char v9; // al\n  char *v10; // edx\n  int v11; // [esp+0h] [ebp-14h]\n\n  v11 = v3;\n  if ( (a3 & 1) != 0 )\n  {\n    v4 = 1;\n    v5 = \"Indexed_directory\";\n    v6 = dword_80B6AA0;\n    do\n    {\n      if ( (a2 & *v6) != 0 )\n      {\n        if ( !v4 )\n          fputs_unlocked();\n        fputs_unlocked();\n        v4 = 0;\n      }\n      v11 = v4;\n      ++v6;\n      v5 += strlen(v5) + 1;\n      v4 = v11;\n    }\n    while ( *v5 );\n    if ( v11 )\n      return fputs_unlocked();\n  }\n  else\n  {\n    v8 = 0;\n    do\n    {\n      v9 = 45;\n      if ( (a2 & dword_80B6AA0[v8]) != 0 )\n        v9 = byte_80D755A[v8];\n      v10 = *(char **)(a1 + 16);\n      if ( (unsigned int)v10 >= *(_DWORD *)(a1 + 28) )\n      {\n        __fputc_unlocked();\n      }\n      else\n      {\n        *(_DWORD *)(a1 + 16) = v10 + 1;\n        *v10 = v9;\n      }\n      ++v8;\n    }\n    while ( byte_80D755A[v8] );\n  }\n  return v11;\n}\n"
    ],
    "sub_809B4AB": [
        "0x809b4ab",
        "int sub_809B4AB()\n{\n  int v0; // edx\n\n  LODWORD(qword_80DB778) = sub_80B4733(HIDWORD(qword_80DB778), 1026);\n  v0 = HIDWORD(qword_80DB778)++;\n  return qword_80DB778 + 4 * v0;\n}\n"
    ],
    "sub_809B4D8": [
        "0x809b4d8",
        "_DWORD *__usercall sub_809B4D8@<eax>(char *s@<ecx>, const char *a2@<eax>, const char *a3@<edx>, const char *a4, int a5)\n{\n  int v7; // esi\n  _DWORD *v8; // ebx\n\n  v7 = a5;\n  v8 = sub_804DB2E(0x1Cu);\n  v8[1] = sub_804DB46(a2);\n  v8[2] = sub_804DB46(a3);\n  if ( strchr(s, 44) )\n    s = \"auto\";\n  v8[3] = sub_804DB46(s);\n  if ( !a4 )\n    a4 = &data;\n  v8[4] = sub_804DB46(a4);\n  if ( a5 < 0 )\n    v7 = 1;\n  v8[5] = v7;\n  if ( pmatch[0].rm_so )\n    *dword_80DB7A4 = v8;\n  else\n    pmatch[0].rm_so = (regoff_t)v8;\n  dword_80DB7A4 = v8;\n  return v8;\n}\n"
    ],
    "sub_809B575": [
        "0x809b575",
        "int __usercall sub_809B575@<eax>(const char *a1@<eax>)\n{\n  FILE *v2; // eax\n  FILE *v4; // ebx\n  int v5; // [esp-4h] [ebp-424h]\n  struct mntent result; // [esp+0h] [ebp-420h] BYREF\n  char buffer[1032]; // [esp+18h] [ebp-408h] BYREF\n\n  v2 = setmntent(a1, \"r\");\n  if ( !v2 )\n    return sub_804D3A5((int)\"can't read '%s'\", a1);\n  v4 = v2;\n  while ( getmntent_r(v4, &result, buffer, 1024) )\n    sub_809B4D8(result.mnt_type, result.mnt_fsname, result.mnt_dir, result.mnt_opts, result.mnt_passno);\n  endmntent(v4);\n  return v5;\n}\n"
    ],
    "sub_809B5EA": [
        "0x809b5ea",
        "int __usercall sub_809B5EA@<eax>(const char *a1@<eax>, char *a2@<edx>)\n{\n  size_t v4; // edi\n  char *v5; // eax\n  char v6; // dl\n\n  if ( !a2 )\n    return 0;\n  v4 = strlen(a1);\n  v5 = a2 - 1;\n  while ( 1 )\n  {\n    v5 = strstr(v5 + 1, a1);\n    if ( !v5 )\n      break;\n    if ( a2 == v5 || *(v5 - 1) == 44 )\n    {\n      v6 = v5[v4];\n      if ( v6 == 44 || !v6 )\n        return 1;\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_809B637": [
        "0x809b637",
        "_BOOL4 __usercall sub_809B637@<eax>(int a1@<eax>)\n{\n  int v2; // ebp\n  int v3; // ebx\n  int i; // esi\n  const char *v5; // eax\n  char v6; // dl\n  _BOOL4 result; // eax\n  int v8; // [esp+0h] [ebp-14h]\n\n  if ( !*(_DWORD *)(a1 + 20) )\n    return 1;\n  v2 = *(&unk_80DB780 + 1);\n  if ( !*(&unk_80DB780 + 1) )\n    return sub_804D222(\"ignore\", *(const char **)(a1 + 12)) >= 0;\n  v8 = 0;\n  v3 = 0;\n  for ( i = 0; ; ++i )\n  {\n    v5 = *(const char **)(v2 + 4 * i);\n    if ( !v5 )\n      break;\n    v6 = MEMORY[0x80DB788][i];\n    if ( v6 == 1 )\n    {\n      if ( !sub_809B5EA(v5, *(char **)(a1 + 16)) )\n        return 1;\n    }\n    else if ( v6 )\n    {\n      if ( v6 == 2 && sub_809B5EA(v5, *(char **)(a1 + 16)) )\n        return 1;\n    }\n    else\n    {\n      ++v8;\n      if ( !strcmp(v5, *(const char **)(a1 + 12)) )\n        v3 = 1;\n    }\n  }\n  if ( !v8 )\n    return sub_804D222(\"ignore\", *(const char **)(a1 + 12)) >= 0;\n  if ( *((_BYTE *)&MEMORY[0x80DB788] + 4) )\n    v3 ^= 1u;\n  result = 1;\n  if ( v3 )\n    return sub_804D222(\"ignore\", *(const char **)(a1 + 12)) >= 0;\n  return result;\n}\n"
    ],
    "sub_809B6F2": [
        "0x809b6f2",
        "char *__usercall sub_809B6F2@<eax>(const char *a1@<eax>)\n{\n  char *v1; // esi\n  char *v2; // eax\n  char *v3; // ebx\n  _BYTE *v4; // edx\n\n  v1 = sub_804DB46(a1);\n  v2 = (char *)sub_80B2EB2();\n  if ( v1 == v2 )\n    goto LABEL_18;\n  v3 = v2;\n  if ( *v2 != 109 || v2[1] != 100 )\n  {\n    if ( sub_804D210(v2, \"rd/\") )\n    {\n      if ( v3[3] == 99 && (unsigned __int8)(v3[4] - 48) <= 9u && v3[5] == 100 && (unsigned __int8)(v3[6] - 48) <= 9u )\n      {\n        v3[7] = 0;\n        return v1;\n      }\n    }\n    else if ( (*v3 == 104 || *v3 == 115) && v3[1] == 100 )\n    {\n      v4 = v3 + 2;\n      if ( (unsigned __int8)(v3[2] - 48) <= 9u )\n        v4 = v3 + 3;\n      if ( (unsigned __int8)((*v4 | 0x20) - 97) <= 0x19u )\n      {\n        v4[1] = 0;\n        return v1;\n      }\n    }\nLABEL_18:\n    free(v1);\n    return 0;\n  }\n  v2[2] = 0;\n  return v1;\n}\n"
    ],
    "sub_809B78D": [
        "0x809b78d",
        "__int64 sub_809B78D()\n{\n  _DWORD *i; // ebx\n  __int64 result; // rax\n  __int64 v2; // [esp-Ch] [ebp-Ch]\n\n  if ( byte_80DBBA4 && !*((_BYTE *)&MEMORY[0x80DB788] + 10) )\n  {\n    for ( i = qword_80DB7A8; i; i = (_DWORD *)*i )\n    {\n      if ( (i[2] & 1) == 0 )\n      {\n        kill(i[1], 15);\n        result = v2;\n      }\n    }\n    *((_BYTE *)&MEMORY[0x80DB788] + 10) = 1;\n  }\n  return result;\n}\n"
    ],
    "sub_809B7CA": [
        "0x809b7ca",
        "void *__usercall sub_809B7CA@<eax>(_DWORD *a1@<eax>)\n{\n  const char *v2; // ebx\n  const char *v3; // edi\n  const char *v4; // esi\n  char **v5; // ebp\n  int v6; // ecx\n  int v7; // edx\n  int v8; // ebx\n  const char *v9; // eax\n  int v10; // eax\n  int v11; // edi\n  void *result; // eax\n  _DWORD *v13; // ebx\n  int v14; // [esp-4h] [ebp-14h]\n\n  v2 = (const char *)a1[3];\n  if ( !strcmp(v2, \"auto\") )\n  {\n    if ( !stream\n      || LOBYTE(stream->_flags) == 110 && BYTE1(stream->_flags) == 111\n      || sub_804D210(stream, \"opts=\")\n      || sub_804D210(stream, \"loop\")\n      || (v2 = (const char *)stream, strchr((const char *)stream, 44)) )\n    {\n      v2 = \"auto\";\n      if ( unk_80DB780 > 2 )\n        printf(\"using filesystem type '%s' %s\\n\", \"auto\", \"(default)\");\n    }\n    else if ( unk_80DB780 > 2 )\n    {\n      printf(\"using filesystem type '%s' %s\\n\", v2, \"from -t\");\n    }\n  }\n  else if ( unk_80DB780 > 2 )\n  {\n    printf(\"using filesystem type '%s' %s\\n\", v2, \"from fstab\");\n  }\n  ++*(&MEMORY[0x80DB788] + 3);\n  v3 = (const char *)a1[2];\n  v4 = (const char *)a1[1];\n  v5 = (char **)qword_80DB778;\n  *v5 = sub_804DDBF(\"fsck.%s\", v2);\n  v7 = HIDWORD(qword_80DB778);\n  *(_DWORD *)(qword_80DB778 + 4 * HIDWORD(qword_80DB778) - 8) = v4;\n  if ( unk_80DB780 || *((_BYTE *)&MEMORY[0x80DB788] + 5) )\n  {\n    if ( !v3 )\n      v3 = v4;\n    printf(\"[%s (%d) -- %s]\", *(const char **)qword_80DB778, *(&MEMORY[0x80DB788] + 3), v3);\n    v8 = 0;\n    while ( 1 )\n    {\n      v9 = *(const char **)(qword_80DB778 + v8);\n      v8 += 4;\n      if ( !v9 )\n        break;\n      printf(\" %s\", v9);\n    }\n    sub_804DD98(10);\n  }\n  if ( *((_BYTE *)&MEMORY[0x80DB788] + 5) )\n    goto LABEL_26;\n  v10 = sub_80B3BA2(v6, v7);\n  v11 = v10;\n  if ( v10 < 0 )\n  {\n    sub_804D3F1(*(const char **)qword_80DB778);\nLABEL_26:\n    free(*(void **)qword_80DB778);\n    return (void *)v14;\n  }\n  if ( !v10 )\n    goto LABEL_26;\n  v13 = sub_804DB2E(0x18u);\n  v13[1] = v11;\n  v13[3] = *(_DWORD *)qword_80DB778;\n  v13[4] = sub_804DB46(v4);\n  v13[5] = sub_809B6F2(v4);\n  result = qword_80DB7A8;\n  *v13 = qword_80DB7A8;\n  qword_80DB7A8 = v13;\n  return result;\n}\n"
    ],
    "sub_809B979": [
        "0x809b979",
        "int __usercall sub_809B979@<eax>(int a1@<eax>, int a2@<esi>)\n{\n  __pid_t v3; // ebp\n  int v4; // esi\n  void *v5; // ebx\n  _DWORD *v6; // edi\n  int v8; // [esp+0h] [ebp-14h] BYREF\n\n  v8 = a2;\n  if ( qword_80DB7A8 )\n  {\nLABEL_2:\n    while ( 1 )\n    {\n      v3 = waitpid(-1, &v8, a1);\n      sub_809B78D();\n      if ( !v3 )\n        break;\n      if ( v3 >= 0 )\n      {\n        v5 = qword_80DB7A8;\n        v6 = 0;\n        while ( *((_DWORD *)v5 + 1) != v3 )\n        {\n          v6 = v5;\n          if ( !*(_DWORD *)v5 )\n            goto LABEL_2;\n          v5 = *(void **)v5;\n        }\n        v4 = BYTE1(v8);\n        if ( (unsigned int)(unsigned __int16)v8 - 1 <= 0xFE )\n        {\n          v4 = 4;\n          if ( (v8 & 0x7F) != 2 )\n          {\n            printf(\n              \"Warning: %s %s terminated by signal %u\\n\",\n              *((const char **)v5 + 3),\n              *((const char **)v5 + 4),\n              v8 & 0x7F);\n            v4 = 8;\n          }\n        }\n        if ( v6 )\n          *v6 = *(_DWORD *)v5;\n        else\n          qword_80DB7A8 = *(void **)v5;\n        if ( unk_80DB780 > 1 )\n          printf(\"Finished with %s (exit status %u)\\n\", *((const char **)v5 + 4), v4);\n        --*(&MEMORY[0x80DB788] + 3);\n        free(*((void **)v5 + 3));\n        free(*((void **)v5 + 4));\n        free(*((void **)v5 + 5));\n        free(v5);\n        return v4;\n      }\n      if ( *(_DWORD *)dword_80DBB7C != 4 )\n      {\n        if ( *(_DWORD *)dword_80DBB7C == 10 )\n        {\n          sub_804D5F4(\"wait: no more children\");\n          return -1;\n        }\n        sub_804D3A5((int)\"wait\");\n      }\n    }\n  }\n  return -1;\n}\n"
    ],
    "sub_809BA80": [
        "0x809ba80",
        "int __usercall sub_809BA80@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // ebx\n  int v4; // eax\n\n  v2 = 0;\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = sub_809B979(v2, v2);\n    if ( v4 == -1 )\n      break;\n    v3 |= v4;\n    v2 |= a1;\n  }\n  return v3;\n}\n"
    ],
    "sub_809BAA1": [
        "0x809baa1",
        "int __cdecl sub_809BAA1(int a1, int a2)\n{\n  char v3; // di\n  const char *v4; // ebx\n  int v5; // esi\n  int i; // edi\n  unsigned __int8 v7; // al\n  const char *v8; // eax\n  char *v9; // eax\n  char *v10; // ebx\n  size_t j; // edi\n  char *v12; // eax\n  int v13; // edi\n  char v14; // bp\n  _BYTE *v15; // ebp\n  char *v16; // eax\n  char *v17; // eax\n  int m; // ebx\n  _DWORD *rm_so; // esi\n  _BYTE *v20; // eax\n  _DWORD *v21; // eax\n  int v22; // ebp\n  _BYTE *v23; // edx\n  regoff_t v24; // esi\n  char v25; // di\n  char *v26; // edx\n  void *n; // ecx\n  const char *v28; // eax\n  int v29; // eax\n  int v30; // eax\n  int v31; // esi\n  const char *v32; // edi\n  _DWORD *k; // ebp\n  int v34; // eax\n  _BYTE *v36; // [esp+0h] [ebp-2Ch]\n  char v37; // [esp+0h] [ebp-2Ch]\n  int v38; // [esp+4h] [ebp-28h]\n  char *v39; // [esp+4h] [ebp-28h]\n  char *v40; // [esp+4h] [ebp-28h]\n  int v41; // [esp+8h] [ebp-24h]\n  char v42; // [esp+8h] [ebp-24h]\n  char v43; // [esp+Ch] [ebp-20h]\n  void **v44; // [esp+Ch] [ebp-20h]\n  char v45; // [esp+13h] [ebp-19h]\n  int v46; // [esp+14h] [ebp-18h]\n  char v47; // [esp+18h] [ebp-14h]\n  _DWORD *v48; // [esp+18h] [ebp-14h]\n\n  sub_804E7B4(2, (int)sub_804E68E);\n  sub_804E7B4(15, (int)sub_804E68E);\n  setbuf(stdout, 0);\n  sub_809B4AB();\n  v43 = 0;\n  v45 = 0;\n  v3 = 0;\n  v38 = 0;\n  v41 = 0;\n  while ( 1 )\n  {\n    v46 = a2 + 4;\n    v4 = *(const char **)(a2 + 4);\n    if ( !v4 )\n      break;\n    if ( !v3 && *v4 == 47 || (v47 = *v4, (v36 = strchr(v4, 61)) != 0) )\n    {\n      v41 = sub_80B4733(v38, 1026);\n      *(_DWORD *)(v41 + 4 * v38++) = v4;\n      goto LABEL_65;\n    }\n    if ( v47 != 45 || v3 )\n    {\n      *(_DWORD *)sub_809B4AB() = v4;\n      goto LABEL_65;\n    }\n    if ( v4[1] == 45 && !v4[2] )\n    {\n      v3 = 1;\n      goto LABEL_65;\n    }\n    v5 = 0;\n    for ( i = 1; ; ++i )\n    {\n      v7 = v4[i];\n      if ( !v7 )\n        break;\n      if ( v7 == 82 )\n      {\n        *((_BYTE *)&MEMORY[0x80DB788] + 7) = 1;\n        continue;\n      }\n      if ( v7 <= 0x52u )\n      {\n        if ( v7 == 65 )\n        {\n          v45 = 1;\n          continue;\n        }\n        if ( v7 > 0x41u )\n        {\n          if ( v7 == 78 )\n          {\n            *((_BYTE *)&MEMORY[0x80DB788] + 5) = 1;\n            continue;\n          }\n          if ( v7 == 80 )\n          {\n            *((_BYTE *)&MEMORY[0x80DB788] + 8) = 1;\n            continue;\n          }\n        }\n        else if ( v7 == 63 )\n        {\n          goto LABEL_58;\n        }\nLABEL_59:\n        v36 = sub_804DB13(v36, v5 + 3);\n        v36[++v5] = v4[i];\n        continue;\n      }\n      if ( v7 == 86 )\n      {\n        ++unk_80DB780;\n        continue;\n      }\n      if ( v7 > 0x56u )\n      {\n        if ( v7 == 115 )\n        {\n          *((_BYTE *)&MEMORY[0x80DB788] + 6) = 1;\n          continue;\n        }\n        if ( v7 == 116 )\n        {\n          if ( stream || (v8 = &v4[i + 1], !*v8) && (v46 = a2 + 8, (v8 = *(const char **)(a2 + 8)) == 0) )\nLABEL_58:\n            sub_804CDC2();\n          v9 = sub_804DB46(v8);\n          v10 = v9;\n          stream = (FILE *)v9;\n          for ( j = 2; ; ++j )\n          {\n            v12 = strchr(v9, 44);\n            if ( !v12 )\n              break;\n            v9 = v12 + 1;\n          }\n          *(&unk_80DB780 + 1) = (time_t)sub_804DB2E(4 * j);\n          MEMORY[0x80DB788] = (char *)sub_804DB2E(j);\n          *((_BYTE *)&MEMORY[0x80DB788] + 4) = -1;\n          v13 = 0;\nLABEL_42:\n          v14 = 0;\n          if ( *v10 == 110 )\n          {\n            if ( v10[1] == 111 )\n            {\n              v10 += 2;\n              goto LABEL_47;\n            }\n          }\n          else if ( *v10 == 33 )\n          {\n            ++v10;\nLABEL_47:\n            v14 = 1;\n          }\n          if ( !strcmp(v10, \"loop\") )\n          {\nLABEL_51:\n            MEMORY[0x80DB788][v13] = v14 + 1;\n          }\n          else\n          {\n            if ( sub_804D210(v10, \"opts=\") )\n            {\n              v10 += 5;\n              goto LABEL_51;\n            }\n            if ( *((_BYTE *)&MEMORY[0x80DB788] + 4) == 0xFF )\n              *((_BYTE *)&MEMORY[0x80DB788] + 4) = v14;\n            if ( v14 != *((_BYTE *)&MEMORY[0x80DB788] + 4) )\n              sub_804D5E0(\"either all or none of the filesystem types passed to -t must be prefixed with 'no' or '!'\");\n          }\n          v15 = (_BYTE *)strchrnul();\n          v48 = (_DWORD *)(*(&unk_80DB780 + 1) + 4 * v13);\n          *v48 = sub_804DB5D(v10, v15 - v10);\n          ++v13;\n          if ( !*v15 )\n            break;\n          v10 = v15 + 1;\n          goto LABEL_42;\n        }\n        goto LABEL_59;\n      }\n      if ( v7 != 84 )\n        goto LABEL_59;\n      v43 = 1;\n    }\n    v3 = 0;\n    if ( v5 )\n    {\n      *v36 = 45;\n      v36[v5 + 1] = 0;\n      *(_DWORD *)sub_809B4AB() = v36;\n    }\nLABEL_65:\n    a2 = v46;\n  }\n  if ( getenv(\"FSCK_FORCE_ALL_PARALLEL\") )\n    *((_BYTE *)&MEMORY[0x80DB788] + 9) = 1;\n  v16 = getenv(\"FSCK_MAX_INST\");\n  dword_80DB798 = (char *)0x7FFFFFFF;\n  if ( v16 )\n    dword_80DB798 = (char *)sub_80B4170();\n  sub_809B4AB();\n  sub_809B4AB();\n  if ( !v43 )\n    puts(\"fsck (busybox 1.29.2)\");\n  v17 = getenv(\"FSTAB_FILE\");\n  if ( !v17 )\n    v17 = \"/etc/fstab\";\n  sub_809B575(v17);\n  if ( v38 )\n  {\n    if ( !v45 )\n    {\n      m = 0;\n      v31 = 0;\n      while ( !byte_80DBBA4 )\n      {\n        v32 = *(const char **)(v41 + 4 * v31);\n        for ( k = (_DWORD *)pmatch[0].rm_so; k; k = (_DWORD *)*k )\n        {\n          if ( !strcmp(v32, (const char *)k[1]) || k[2] && !strcmp(v32, (const char *)k[2]) )\n            goto LABEL_146;\n        }\n        k = sub_809B4D8(\"auto\", v32, &data, 0, -1);\nLABEL_146:\n        sub_809B7CA(k);\n        if ( *((_BYTE *)&MEMORY[0x80DB788] + 6) || (int)*(&MEMORY[0x80DB788] + 3) >= (int)dword_80DB798 )\n        {\n          v34 = sub_809B979(0, v31);\n          if ( v34 >= 0 )\n            m |= v34;\n          if ( unk_80DB780 > 1 )\n            puts(\"----------------------------------\");\n        }\n        if ( v38 == ++v31 )\n          goto LABEL_153;\n      }\n      sub_809B78D();\nLABEL_153:\n      v30 = 0;\n      return sub_809BA80(v30) | m;\n    }\n  }\n  else\n  {\n    *((_BYTE *)&MEMORY[0x80DB788] + 6) = 1;\n  }\n  if ( unk_80DB780 )\n    puts(\"Checking all filesystems\");\n  for ( m = pmatch[0].rm_so; m; m = *(_DWORD *)m )\n  {\n    if ( sub_809B637(m) )\n      *(_DWORD *)(m + 24) |= 1u;\n  }\n  rm_so = (_DWORD *)pmatch[0].rm_so;\n  if ( *((_BYTE *)&MEMORY[0x80DB788] + 8) )\n    goto LABEL_95;\n  while ( 2 )\n  {\n    if ( !rm_so )\n    {\n      m = 0;\nLABEL_95:\n      v21 = (_DWORD *)pmatch[0].rm_so;\n      if ( *((_BYTE *)&MEMORY[0x80DB788] + 7) )\n      {\n        while ( v21 )\n        {\n          v23 = (_BYTE *)v21[2];\n          if ( *v23 == 47 && !v23[1] )\n            v21[6] |= 1u;\n          v21 = (_DWORD *)*v21;\n        }\n      }\n      v22 = 1;\n      while ( 1 )\n      {\n        v24 = pmatch[0].rm_so;\n        v25 = 1;\n        v42 = 0;\n        while ( v24 && !byte_80DBBA4 )\n        {\n          if ( (*(_BYTE *)(v24 + 24) & 1) != 0 )\n            goto LABEL_129;\n          if ( *(_DWORD *)(v24 + 20) > v22 )\n          {\n            v37 = v25;\n            v42 = 1;\n          }\n          else\n          {\n            v39 = *(char **)(v24 + 4);\n            v37 = *((_BYTE *)&MEMORY[0x80DB788] + 9);\n            if ( *((_BYTE *)&MEMORY[0x80DB788] + 9) )\n              goto LABEL_127;\n            if ( !qword_80DB7A8\n              || !sub_804D210(*((_BYTE **)qword_80DB7A8 + 4), \"/dev/md\") && !sub_804D210(v39, \"/dev/md\") )\n            {\n              v26 = sub_809B6F2(v39);\n              if ( v26 )\n              {\n                for ( n = qword_80DB7A8; n; n = *v44 )\n                {\n                  v28 = (const char *)*((_DWORD *)n + 5);\n                  if ( v28 )\n                  {\n                    v44 = (void **)n;\n                    v40 = v26;\n                    v29 = strcmp(v26, v28);\n                    v26 = v40;\n                    if ( v29 )\n                      continue;\n                  }\n                  free(v26);\n                  goto LABEL_108;\n                }\n                free(v26);\n              }\n              else if ( qword_80DB7A8 )\n              {\n                goto LABEL_108;\n              }\nLABEL_127:\n              sub_809B7CA((_DWORD *)v24);\n              *(_DWORD *)(v24 + 24) |= 1u;\n              if ( *((_BYTE *)&MEMORY[0x80DB788] + 6) || (int)*(&MEMORY[0x80DB788] + 3) >= (int)dword_80DB798 )\n              {\n                v25 = 0;\n                break;\n              }\nLABEL_129:\n              v37 = v25;\n            }\n          }\nLABEL_108:\n          v24 = *(_DWORD *)v24;\n          v25 = v37;\n        }\n        if ( !byte_80DBBA4 )\n        {\n          if ( unk_80DB780 > 1 )\n            printf(\"--waiting-- (pass %d)\\n\", v22);\n          m |= sub_809BA80(v25 ^ 1);\n          if ( !v25 )\n            continue;\n          if ( unk_80DB780 > 1 )\n            puts(\"----------------------------------\");\n          ++v22;\n          if ( v42 )\n            continue;\n        }\n        sub_809B78D();\n        v30 = 1;\n        return sub_809BA80(v30) | m;\n      }\n    }\n    v20 = (_BYTE *)rm_so[2];\n    if ( *v20 != 47 || v20[1] )\n    {\n      rm_so = (_DWORD *)*rm_so;\n      continue;\n    }\n    break;\n  }\n  if ( *((_BYTE *)&MEMORY[0x80DB788] + 7) || sub_809B637((int)rm_so) )\n  {\n    m = 0;\n    goto LABEL_92;\n  }\n  sub_809B7CA(rm_so);\n  m = sub_809BA80(0);\n  if ( m <= 1 )\n  {\nLABEL_92:\n    rm_so[6] |= 1u;\n    goto LABEL_95;\n  }\n  return m;\n}\n"
    ],
    "sub_809C137": [
        "0x809c137",
        "int __usercall sub_809C137@<eax>(const char *a1@<eax>)\n{\n  int v3; // [esp+0h] [ebp-Ch] BYREF\n  int v4; // [esp+4h] [ebp-8h] BYREF\n\n  if ( sub_809B35F((int)a1, (int)&v3, 0) )\n    return sub_804D3A5((int)\"reading %s\", a1);\n  if ( (dword_80DBB9C & 0x10) == 0 )\n    goto LABEL_5;\n  if ( sub_809B307((int)a1, (int)&v4, 0) )\n    return sub_804D3A5((int)\"reading %s\", a1);\n  printf(\"%5lu \", v4);\nLABEL_5:\n  if ( (dword_80DBB9C & 8) != 0 )\n  {\n    printf(\"%-28s \", a1);\n    sub_809B3F2((int)stdout, v3, 1);\n    return sub_804DD98(10);\n  }\n  else\n  {\n    sub_809B3F2((int)stdout, v3, 0);\n    return printf(\" %s\\n\", a1);\n  }\n}\n"
    ],
    "sub_809C1E2": [
        "0x809c1e2",
        "int __usercall sub_809C1E2@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char *v4; // ebx\n  __int16 v6; // [esp+10h] [ebp-58h]\n\n  v4 = (char *)sub_804D2D1(a1, (_BYTE *)(a2 + 19), a3);\n  if ( lstat64() )\n  {\n    sub_804D3A5((int)\"stat %s\", v4);\n  }\n  else if ( *(_BYTE *)(a2 + 19) != 46 || (dword_80DBB9C & 2) != 0 )\n  {\n    sub_809C137(v4);\n    if ( (v6 & 0xF000) == 0x4000\n      && (dword_80DBB9C & 1) != 0\n      && (*(_BYTE *)(a2 + 19) != 46 || *(_BYTE *)(a2 + 20) && *(_WORD *)(a2 + 20) != 46) )\n    {\n      printf(\"\\n%s:\\n\", v4);\n      sub_809B2CC(v4, (void (__fastcall *)(int, int))sub_809C1E2, 0);\n      sub_804DD98(10);\n    }\n  }\n  free(v4);\n  return 0;\n}\n"
    ],
    "sub_809C284": [
        "0x809c284",
        "int __cdecl sub_809C284(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  char *v3; // esi\n  __int16 v5; // [esp+10h] [ebp-58h]\n\n  sub_80ABEAC(a2, \"Radlv\");\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v2 )\n    *--v2 = 135072092;\n  do\n  {\n    v3 = (char *)*v2++;\n    if ( lstat64() == -1 )\n    {\n      sub_804D3A5((int)\"stat %s\", v3);\n    }\n    else if ( (v5 & 0xF000) != 0x4000 || (dword_80DBB9C & 4) != 0 )\n    {\n      sub_809C137(v3);\n    }\n    else\n    {\n      sub_809B2CC(v3, (void (__fastcall *)(int, int))sub_809C1E2, 0);\n    }\n  }\n  while ( *v2 );\n  return 0;\n}\n"
    ],
    "sub_809C311": [
        "0x809c311",
        "int __usercall sub_809C311@<eax>(unsigned __int8 *a1@<eax>)\n{\n  int i; // edx\n  int v2; // ecx\n\n  for ( i = 0; ; i = v2 + 63 * i )\n  {\n    v2 = *a1;\n    if ( !(_BYTE)v2 )\n      break;\n    ++a1;\n  }\n  return i;\n}\n"
    ],
    "sub_809C325": [
        "0x809c325",
        "char *__usercall sub_809C325@<eax>(char *result@<eax>)\n{\n  int v1; // ecx\n  char v2; // dl\n\n  v1 = dword_80DBB80;\n  while ( 1 )\n  {\n    v2 = *result;\n    if ( *result != 92 )\n      break;\n    if ( result[1] != 10 )\n      return result;\n    ++result;\n    ++*(_DWORD *)(v1 + 12);\nLABEL_7:\n    ++result;\n  }\n  if ( v2 == 32 || v2 == 9 )\n    goto LABEL_7;\n  return result;\n}\n"
    ],
    "sub_809C34C": [
        "0x809c34c",
        "int __usercall sub_809C34C@<eax>(int *a1@<eax>)\n{\n  int result; // eax\n  _BYTE *v3; // ecx\n\n  result = *a1;\n  do\n    v3 = (_BYTE *)(*a1)++;\n  while ( *v3 );\n  return result;\n}\n"
    ],
    "sub_809C35F": [
        "0x809c35f",
        "int sub_809C35F()\n{\n  int result; // eax\n\n  result = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 - 3) = 1;\n  return result;\n}\n"
    ],
    "sub_809C369": [
        "0x809c369",
        "_DWORD *__usercall sub_809C369@<eax>(_DWORD **a1@<eax>)\n{\n  _DWORD *v1; // edx\n\n  v1 = *a1;\n  if ( *a1 && (*v1 & 0xFF00) == 4864 )\n  {\n    *a1 = (_DWORD *)v1[3];\n    return (_DWORD *)v1[2];\n  }\n  else\n  {\n    *a1 = 0;\n  }\n  return v1;\n}\n"
    ],
    "sub_809C392": [
        "0x809c392",
        "_DWORD *sub_809C392()\n{\n  _DWORD *v0; // ebx\n\n  v0 = sub_804DB2E(0x14u);\n  v0[1] = 61;\n  v0[4] = sub_804DB2E(0xF4u);\n  return v0;\n}\n"
    ],
    "sub_809C3B7": [
        "0x809c3b7",
        "int __usercall sub_809C3B7@<eax>(int *a1@<eax>)\n{\n  int v2; // eax\n\n  while ( 1 )\n  {\n    v2 = *a1;\n    if ( (*a1 & 0x2000) == 0 )\n      break;\n    a1 = (int *)a1[4];\n  }\n  if ( (v2 & 2) == 0 )\n  {\n    *a1 = v2 | 2;\n    a1[4] = (int)sub_809C392();\n  }\n  return a1[4];\n}\n"
    ],
    "sub_809C3DD": [
        "0x809c3dd",
        "_DWORD *__usercall sub_809C3DD@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x14u);\n  *result = a1;\n  result[1] = *(_DWORD *)(dword_80DBB80 - 36);\n  return result;\n}\n"
    ],
    "sub_809C3FA": [
        "0x809c3fa",
        "_DWORD *__usercall sub_809C3FA@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  _DWORD *i; // edi\n  _DWORD *v4; // edx\n  int v5; // ebp\n  _DWORD *v6; // eax\n  int v7; // edx\n  _DWORD *result; // eax\n  unsigned int v9; // ebx\n  _DWORD *j; // edx\n\n  v2 = dword_80DBB80;\n  for ( i = 0; ; i = v4 )\n  {\n    v4 = *(_DWORD **)(v2 - 20);\n    if ( !v4 )\n      break;\n    if ( a1 - 858993459 * ((v4[1] - (int)(v4 + 4)) >> 2) <= *v4 )\n      goto LABEL_9;\n    *(_DWORD *)(v2 - 20) = v4[3];\n  }\n  v5 = a1;\n  if ( a1 < 64 )\n    v5 = 64;\n  v6 = sub_804DB2E(20 * v5 + 16);\n  *(_DWORD *)(v2 - 20) = v6;\n  *v6 = v5;\n  v6[1] = v6 + 4;\n  v6[2] = i;\n  if ( i )\n    i[3] = v6;\nLABEL_9:\n  v7 = *(_DWORD *)(v2 - 20);\n  result = *(_DWORD **)(v7 + 4);\n  v9 = (unsigned int)&result[5 * a1];\n  *(_DWORD *)(v7 + 4) = v9;\n  for ( j = result; v9 > (unsigned int)j; j += 5 )\n  {\n    *j = 0;\n    j[3] = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_809C489": [
        "0x809c489",
        "void *__usercall sub_809C489@<eax>(void *result@<eax>, int a2@<edx>, int *a3@<ecx>)\n{\n  size_t v3; // edx\n\n  if ( !result || *a3 <= a2 )\n  {\n    v3 = a2 + (a2 >> 1) + 80;\n    *a3 = v3;\n    return sub_804DB13(result, v3);\n  }\n  return result;\n}\n"
    ],
    "sub_809C4A3": [
        "0x809c4a3",
        "int __usercall sub_809C4A3@<eax>(int result@<eax>)\n{\n  int v1; // edx\n  int v2; // [esp+0h] [ebp-4h]\n\n  if ( (*(_DWORD *)result & 0x1000) == 0 )\n  {\n    v2 = result;\n    free(*(void **)(result + 12));\n    result = v2;\n  }\n  v1 = *(_DWORD *)result & 0x6C02;\n  BYTE1(v1) |= 0x40u;\n  *(_DWORD *)result = v1;\n  *(_DWORD *)(result + 12) = 0;\n  return result;\n}\n"
    ],
    "sub_809C4D2": [
        "0x809c4d2",
        "char *__usercall sub_809C4D2@<eax>(char *result@<eax>)\n{\n  char *v1; // esi\n  int v2; // ebx\n  int v3; // edi\n  int v4; // ebp\n  _DWORD *i; // edi\n  char *v6; // eax\n  int v7; // edx\n\n  v1 = result;\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 28);\n  if ( v3 <= (int)result )\n  {\n    *(_DWORD *)(dword_80DBB80 - 28) = result + 16;\n    v6 = (char *)sub_804DB13(*(void **)(v2 - 24), 20 * (_DWORD)(result + 16));\n    *(_DWORD *)(v2 - 24) = v6;\n    v7 = *(_DWORD *)(v2 - 28);\n    result = &v6[20 * v3];\n    while ( v7 > v3 )\n    {\n      *(_DWORD *)result = 1024;\n      *((_DWORD *)result + 3) = 0;\n      ++v3;\n      result += 20;\n    }\n  }\n  v4 = 20 * (_DWORD)v1;\n  for ( i = v1; *(_DWORD *)(v2 - 32) > (int)i; i = (_DWORD *)((char *)i + 1) )\n  {\n    result = (char *)sub_809C4A3(v4 + *(_DWORD *)(v2 - 24));\n    v4 += 20;\n  }\n  *(_DWORD *)(v2 - 32) = v1;\n  return result;\n}\n"
    ],
    "sub_809C53C": [
        "0x809c53c",
        "int __usercall sub_809C53C@<eax>(_DWORD *a1@<eax>, int a2@<ebx>)\n{\n  unsigned int i; // esi\n  int j; // edi\n\n  for ( i = 0; a1[1] > i; ++i )\n  {\n    for ( j = *(_DWORD *)(a1[4] + 4 * i); j; j = a2 )\n    {\n      a2 = *(_DWORD *)(j + 24);\n      free(*(void **)(j + 12));\n      free((void *)j);\n    }\n    *(_DWORD *)(a1[4] + 4 * i) = 0;\n  }\n  *a1 = 0;\n  a1[3] = 0;\n  return a2;\n}\n"
    ],
    "sub_809C596": [
        "0x809c596",
        "_DWORD *__usercall sub_809C596@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n  _DWORD *v3; // esi\n  _DWORD *v4; // eax\n  int v5; // eax\n  int v6; // edx\n  int v7; // esi\n  _DWORD *v8; // esi\n  _DWORD *v9; // eax\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD **)(dword_80DBB80 - 72);\n  if ( !*v3 )\n  {\n    v4 = sub_809C3DD(0);\n    v3[1] = v4;\n    **(_DWORD **)(v2 - 72) = v4;\n  }\n  v5 = *(_DWORD *)(v2 - 72);\n  v6 = *(_DWORD *)(v2 - 40);\n  if ( *(_DWORD *)(v5 + 8) != v6 )\n  {\n    *(_DWORD *)(v5 + 8) = v6;\n    v7 = sub_809C596();\n    *(_DWORD *)(v7 + 8) = sub_804DB46(*(const char **)(v2 - 40));\n  }\n  v8 = *(_DWORD **)(*(_DWORD *)(v2 - 72) + 4);\n  *v8 = a1;\n  v9 = sub_809C3DD(10240);\n  v8[4] = v9;\n  *(_DWORD *)(*(_DWORD *)(v2 - 72) + 4) = v9;\n  return v8;\n}\n"
    ],
    "sub_809C5FE": [
        "0x809c5fe",
        "int __usercall sub_809C5FE@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  int v4; // ebp\n  regex_t *v5; // edi\n  int v6; // edx\n\n  v4 = a2 + 20;\n  v5 = (regex_t *)(a2 + 52);\n  if ( (*(_DWORD *)a2 & 0xFF00) == 8448 )\n  {\n    regfree((regex_t *)(a2 + 20));\n    regfree(v5);\n  }\n  v6 = *a1;\n  if ( (_BYTE)v6 && a1[1] )\n  {\n    *(_DWORD *)a2 = 8448;\n    *(_DWORD *)(a2 + 8) = v4;\n    *(_DWORD *)(a2 + 12) = v5;\n    sub_80B47BA(1, a1);\n    sub_80B47BA(3, a1);\n  }\n  else\n  {\n    *(_DWORD *)a2 = v6;\n  }\n  return a2;\n}\n"
    ],
    "sub_809C668": [
        "0x809c668",
        "long double __usercall sub_809C668@<st0>(char **a1@<eax>)\n{\n  char *v2; // ebx\n  unsigned __int64 v3; // rax\n  char v5; // [esp+0h] [ebp-20h]\n\n  v2 = *a1;\n  if ( **a1 == 48\n    && (((unsigned __int8)v2[1] | 0x20) == 120 || (unsigned __int8)(v2[1] - 48) <= 9u)\n    && ((v5 = v2[1] | 0x20, v3 = strtoull(v2, a1, 0), v5 == 120) || (unsigned __int8)(**a1 - 48) > 9u && **a1 != 46) )\n  {\n    return (double)v3;\n  }\n  else\n  {\n    return strtod(v2, a1);\n  }\n}\n"
    ],
    "sub_809C6F9": [
        "0x809c6f9",
        "long double __usercall sub_809C6F9@<st0>(_DWORD *a1@<eax>)\n{\n  int v2; // eax\n  char *v3; // edx\n  char *v5; // [esp+4h] [ebp-Ch] BYREF\n\n  v2 = *a1;\n  if ( (v2 & 0x101) == 0 )\n  {\n    a1[1] = 0;\n    a1[2] = 0;\n    v3 = (char *)a1[3];\n    v5 = v3;\n    if ( v3 && *v3 )\n    {\n      *(double *)(a1 + 1) = sub_809C668(&v5);\n      if ( (*a1 & 0x200) != 0 )\n      {\n        v5 = sub_809C325(v5);\n        if ( *v5 )\n          *a1 &= ~0x200u;\n      }\n    }\n    else\n    {\n      BYTE1(v2) &= ~2u;\n      *a1 = v2;\n    }\n    *a1 |= 0x100u;\n  }\n  return *(double *)(a1 + 1);\n}\n"
    ],
    "sub_809C777": [
        "0x809c777",
        "int __usercall sub_809C777@<eax>(int *a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  _BYTE *v4; // edx\n\n  sub_809C6F9(a1);\n  v2 = *a1;\n  BYTE1(v2) = BYTE1(*a1) ^ 0x40;\n  result = v2 & 0x4201;\n  if ( result )\n    return *(double *)(a1 + 1) != 0.0;\n  v4 = (_BYTE *)a1[3];\n  if ( v4 )\n    return *v4 != 0;\n  return result;\n}\n"
    ],
    "sub_809C7CC": [
        "0x809c7cc",
        "int __usercall sub_809C7CC@<eax>(_DWORD *a1@<eax>)\n{\n  long double v1; // fst7\n\n  v1 = sub_809C6F9(a1);\n  if ( v1 < 0.0 )\n    return -(int)(__int64)-v1;\n  else\n    return (__int64)v1;\n}\n"
    ],
    "sub_809C834": [
        "0x809c834",
        "int __usercall sub_809C834@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>)\n{\n  int i; // ebx\n\n  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * ((unsigned int)sub_809C311(a2) % *(_DWORD *)(a1 + 4)));\n        i;\n        i = *(_DWORD *)(i + 24) )\n  {\n    if ( !strcmp((const char *)(i + 28), (const char *)a2) )\n      return i;\n  }\n  return 0;\n}\n"
    ],
    "sub_809C86E": [
        "0x809c86e",
        "char *__usercall sub_809C86E@<eax>(unsigned int *a1@<eax>, unsigned __int8 *a2@<edx>)\n{\n  char *v4; // esi\n  unsigned int v5; // eax\n  unsigned int v6; // eax\n  _DWORD *v7; // ecx\n  int i; // ebp\n  int v9; // esi\n  char *v10; // eax\n  size_t v11; // ebp\n  char **v12; // eax\n  unsigned int v14; // [esp+0h] [ebp-24h]\n  char *v15; // [esp+4h] [ebp-20h]\n  int v16; // [esp+8h] [ebp-1Ch]\n  unsigned int v17; // [esp+Ch] [ebp-18h]\n  _DWORD *v18; // [esp+10h] [ebp-14h]\n\n  v4 = (char *)sub_809C834((int)a1, a2);\n  if ( !v4 )\n  {\n    v5 = *a1 + 1;\n    *a1 = v5;\n    if ( v5 / a1[1] > 0xA )\n    {\n      v6 = a1[2];\n      if ( v6 != 5 )\n      {\n        a1[2] = v6 + 1;\n        v14 = (unsigned __int16)word_80B863A[v6];\n        v15 = (char *)sub_804DB2E(4 * v14);\n        v17 = a1[1];\n        v7 = (_DWORD *)a1[4];\n        for ( i = 0; i != v17; ++i )\n        {\n          v9 = v7[i];\n          while ( v9 )\n          {\n            v18 = v7;\n            v16 = *(_DWORD *)(v9 + 24);\n            v10 = &v15[4 * (sub_809C311((unsigned __int8 *)(v9 + 28)) % v14)];\n            *(_DWORD *)(v9 + 24) = *(_DWORD *)v10;\n            *(_DWORD *)v10 = v9;\n            v9 = v16;\n            v7 = v18;\n          }\n        }\n        free(v7);\n        a1[1] = v14;\n        a1[4] = (unsigned int)v15;\n      }\n    }\n    v11 = strlen((const char *)a2);\n    v4 = (char *)sub_804DB2E(v11 + 33);\n    strcpy(v4 + 28, (const char *)a2);\n    v12 = (char **)(a1[4] + 4 * (sub_809C311(a2) % a1[1]));\n    *((_DWORD *)v4 + 6) = *v12;\n    *v12 = v4;\n    a1[3] += v11 + 1;\n  }\n  return v4;\n}\n"
    ],
    "sub_809C96D": [
        "0x809c96d",
        "int __usercall sub_809C96D@<eax>(_DWORD *a1@<eax>, unsigned __int8 *a2@<edx>)\n{\n  unsigned int v4; // edx\n  int result; // eax\n  int *i; // edi\n  int v7; // esi\n  int v8; // [esp+0h] [ebp-14h]\n\n  v4 = (unsigned int)sub_809C311(a2) % a1[1];\n  result = a1[4];\n  for ( i = (int *)(result + 4 * v4); ; i = (int *)(v7 + 24) )\n  {\n    v7 = *i;\n    if ( !*i )\n      break;\n    result = strcmp((const char *)(v7 + 28), (const char *)a2);\n    if ( !result )\n    {\n      a1[3] += ~strlen((const char *)a2);\n      --*a1;\n      *i = *(_DWORD *)(v7 + 24);\n      free((void *)v7);\n      return v8;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_809C9C4": [
        "0x809c9c4",
        "char __usercall sub_809C9C4@<al>(int *a1@<eax>, int a2@<ecx>)\n{\n  char *v3; // esi\n  int v4; // edi\n  char result; // al\n\n  v3 = (char *)*a1;\n  v4 = *a1 + 1;\n  *a1 = v4;\n  result = *v3;\n  if ( *v3 == 92 )\n  {\n    result = sub_80B0CB3(a2);\n    if ( result == 92 && v4 == *a1 )\n    {\n      result = v3[1];\n      if ( result )\n        *a1 = (int)(v3 + 2);\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_809C9F5": [
        "0x809c9f5",
        "int __usercall sub_809C9F5@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  char *v2; // ebx\n  char v3; // al\n  int v5; // [esp+0h] [ebp-8h] BYREF\n\n  v2 = (char *)a1;\n  v5 = a1;\n  while ( 1 )\n  {\n    v3 = sub_809C9C4(&v5, a2);\n    *v2 = v3;\n    if ( !v3 )\n      break;\n    ++v2;\n  }\n  return v5;\n}\n"
    ],
    "sub_809CA0F": [
        "0x809ca0f",
        "time_t __usercall sub_809CA0F@<eax>(const char *a1@<eax>)\n{\n  time_t result; // eax\n  struct tm v2; // [esp+0h] [ebp-30h] BYREF\n\n  v2.tm_isdst = -1;\n  if ( sscanf(\n         a1,\n         \"%u %u %u %u %u %u %d\",\n         &v2.tm_year,\n         &v2.tm_mon,\n         &v2.tm_mday,\n         &v2.tm_hour,\n         &v2.tm_min,\n         &v2,\n         &v2.tm_isdst) <= 5 )\n    return -1;\n  result = -1;\n  if ( v2.tm_mon )\n  {\n    if ( v2.tm_year > 0x76Bu )\n    {\n      --v2.tm_mon;\n      v2.tm_year -= 1900;\n      return mktime(&v2);\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_809CA86": [
        "0x809ca86",
        "void __usercall __noreturn sub_809CA86(const char *a1@<eax>)\n{\n  sub_804D5E0(\"%s:%i: %s\", *(const char **)(dword_80DBB80 - 40), *(_DWORD *)(dword_80DBB80 - 36), a1);\n}\n"
    ],
    "sub_809CA9D": [
        "0x809ca9d",
        "int __usercall sub_809CA9D@<eax>(char *a1@<eax>, size_t a2@<edx>, const char *a3@<ecx>, int a4, double a5, int a6)\n{\n  const char *v7; // ebx\n  long double v8; // fst7\n  unsigned __int8 v10; // al\n  int v11; // edi\n\n  v7 = a3;\n  v8 = a5;\n  if ( a6 && (long double)(__int64)v8 == v8 )\n    return snprintf(a1, a2, \"%lld\", (__int64)v8);\n  do\n  {\n    v10 = *a3;\n    if ( !*a3 )\n      break;\n    ++a3;\n  }\n  while ( *a3 );\n  v11 = v10;\n  if ( strchr(\"diouxX\", v10) )\n    return snprintf(a1, a2, v7, (int)a5);\n  if ( !strchr(\"eEfgG\", v11) )\n    sub_809CA86(\"Invalid format specifier\");\n  return snprintf(a1, a2, v7, a5);\n}\n"
    ],
    "sub_809CB8E": [
        "0x809cb8e",
        "const char *__usercall sub_809CB8E@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  const char *v3; // eax\n  const char *result; // eax\n  long double v5; // [esp+0h] [ebp-24h]\n  double v6; // [esp+Ch] [ebp-18h]\n\n  if ( (*(_DWORD *)a1 & 0x101) == 1 )\n  {\n    v6 = *(double *)(a1 + 4);\n    v2 = dword_80DBB80;\n    v3 = (const char *)sub_809CB8E();\n    HIDWORD(v5) = 1;\n    *(double *)&v5 = v6;\n    sub_809CA9D(*(char **)(v2 - 12), 0xF0u, v3, SLODWORD(v6), *(double *)((char *)&v5 + 4), SLODWORD(v6));\n    *(_DWORD *)(a1 + 12) = sub_804DB46(*(const char **)(v2 - 12));\n    *(_DWORD *)a1 |= 0x100u;\n  }\n  result = *(const char **)(a1 + 12);\n  if ( !result )\n    return &data;\n  return result;\n}\n"
    ],
    "sub_809CC09": [
        "0x809cc09",
        "int __usercall sub_809CC09@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>, char **a3@<ecx>)\n{\n  const char *v3; // ebx\n  size_t v5; // eax\n  char *v6; // eax\n  int v7; // esi\n  const char *v8; // eax\n  char *v9; // edx\n  char *v10; // ecx\n  int i; // ebp\n  regoff_t v12; // esi\n  const regex_t *v13; // eax\n  int v14; // eax\n  signed int v15; // edx\n  regoff_t rm_so; // eax\n  char v17; // al\n  char v18; // al\n  char *v19; // edx\n  char *v20; // eax\n  char v21; // al\n  char *v22; // eax\n  char *v24; // [esp-8h] [ebp-38h]\n  char *v25; // [esp-4h] [ebp-34h]\n  char *s; // [esp+8h] [ebp-28h] BYREF\n  char accept; // [esp+Ch] [ebp-24h] BYREF\n  char v29; // [esp+Dh] [ebp-23h]\n  char reject[2]; // [esp+Eh] [ebp-22h] BYREF\n  regmatch_t v31; // [esp+10h] [ebp-20h] BYREF\n\n  v3 = a1;\n  v5 = strlen(a1);\n  v6 = (char *)sub_804DB2E(2 * v5 + 3);\n  s = v6;\n  *a3 = v6;\n  strcpy(v6, v3);\n  v29 = *a2;\n  accept = v29;\n  *(_WORD *)reject = 0;\n  v7 = dword_80DBB80;\n  v8 = sub_809CB8E(*(_DWORD *)(dword_80DBB80 + 36));\n  v9 = v24;\n  v10 = v25;\n  if ( !*v8 )\n    reject[0] = 10;\n  if ( (*a2 & 0xFF00) == 8448 )\n  {\n    i = 0;\n    if ( *v3 )\n    {\n      i = 1;\n      do\n      {\n        v12 = strcspn(v3, reject);\n        if ( *(_BYTE *)(dword_80DBB80 - 8) )\n          v13 = (const regex_t *)a2[3];\n        else\n          v13 = (const regex_t *)a2[2];\n        v14 = regexec(v13, v3, 1u, &v31, 0);\n        v15 = v12;\n        if ( v14 || (rm_so = v31.rm_so, v31.rm_so > v12) )\n        {\n          v31.rm_eo = v12;\n          if ( v3[v12] )\n            v31.rm_eo = v12 + 1;\n        }\n        else\n        {\n          if ( !v31.rm_eo )\n          {\n            v31.rm_eo = 1;\n            rm_so = v31.rm_so + 1;\n          }\n          ++i;\n          v15 = rm_so;\n        }\n        qmemcpy(s, v3, v15);\n        do\n          s[v15++] = 0;\n        while ( v31.rm_eo > v15 );\n        sub_809C34C((int *)&s);\n        v3 += v31.rm_eo;\n      }\n      while ( *v3 );\n    }\n  }\n  else\n  {\n    v17 = accept;\n    if ( accept )\n    {\n      if ( accept == 32 )\n      {\n        i = 0;\n        while ( *v3 )\n        {\n          v3 = (const char *)sub_80B2E8C(v10, v9);\n          if ( !*v3 )\n            break;\n          ++i;\n          while ( 1 )\n          {\n            v9 = s;\n            v10 = s + 1;\n            if ( (*v3 & 0xDF) == 0 || (unsigned __int8)(*v3 - 9) <= 4u )\n              break;\n            ++v3;\n            ++s;\n            *v9 = *(v3 - 1);\n          }\n          ++s;\n          *v9 = 0;\n        }\n      }\n      else\n      {\n        if ( *(_BYTE *)(v7 - 8) )\n        {\n          if ( (unsigned __int8)(accept - 97) <= 0x19u )\n            v17 = accept - 32;\n          accept = v17;\n          v21 = v29;\n          if ( (unsigned __int8)(v29 - 65) <= 0x19u )\n            v21 = v29 + 32;\n          v29 = v21;\n        }\n        for ( i = *s != 0; ; ++i )\n        {\n          v22 = strpbrk(s, &accept);\n          if ( !v22 )\n            break;\n          s = v22 + 1;\n          *v22 = 0;\n        }\n      }\n    }\n    else\n    {\n      for ( i = 0; ; ++i )\n      {\n        v18 = v3[i];\n        if ( !v18 )\n          break;\n        v19 = s++;\n        *v19 = v18;\n        v20 = s++;\n        *v20 = 0;\n      }\n    }\n  }\n  return i;\n}\n"
    ],
    "sub_809CE11": [
        "0x809ce11",
        "void sub_809CE11()\n{\n  int v0; // ebx\n  const char *v1; // eax\n  char *v2; // esi\n  int i; // edi\n  int v4; // eax\n  int v5; // [esp+8h] [ebp-18h]\n  int v6[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v0 = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 - 4) )\n  {\n    *(_BYTE *)(dword_80DBB80 - 4) = 1;\n    free(*(void **)(v0 + 92));\n    sub_809C4D2(0);\n    v1 = sub_809CB8E(*(_DWORD *)(v0 + 52));\n    v2 = (char *)sub_809CC09(v1, (_DWORD *)(v0 + 280), (char **)(v0 + 92));\n    sub_809C4D2(v2);\n    v6[0] = *(_DWORD *)(v0 + 92);\n    for ( i = 0; i < (int)v2; ++i )\n    {\n      v5 = *(_DWORD *)(v0 - 24) + 20 * i;\n      *(_DWORD *)(v5 + 12) = sub_809C34C(v6);\n      *(_DWORD *)(*(_DWORD *)(v0 - 24) + 20 * i) |= 0x5200u;\n    }\n    sub_809C4A3(*(_DWORD *)(v0 + 80));\n    v4 = *(_DWORD *)(v0 + 80);\n    *(_DWORD *)v4 = 1025;\n    *(double *)(v4 + 4) = (double)*(int *)(v0 - 32);\n  }\n}\n"
    ],
    "sub_809CEBC": [
        "0x809cebc",
        "int *__usercall sub_809CEBC@<eax>(int *result@<eax>, int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>, char a6)\n{\n  int *v6; // esi\n  int v7; // ebx\n  long double v8; // fst7\n  size_t v9; // eax\n  unsigned __int8 *v10; // eax\n  int v11; // edx\n  int v12; // esi\n  const char *v13; // [esp+8h] [ebp-4Ch]\n  const char *v14; // [esp+Ch] [ebp-48h]\n  unsigned int v15; // [esp+14h] [ebp-40h]\n  int v16; // [esp+1Ch] [ebp-38h]\n  unsigned int v17; // [esp+20h] [ebp-34h]\n  int v18; // [esp+24h] [ebp-30h]\n  char *v19; // [esp+28h] [ebp-2Ch]\n  int v20; // [esp+28h] [ebp-2Ch]\n  int v21[8]; // [esp+34h] [ebp-20h] BYREF\n  int anonymous0; // [esp+54h] [ebp+0h]\n\n  if ( (*result & 0x400) == 0 )\n    return result;\n  v21[7] = a4;\n  v21[6] = anonymous0;\n  v21[5] = a3;\n  v21[4] = (int)&a6;\n  v21[3] = a5;\n  v21[2] = a2;\n  v6 = result;\n  v7 = dword_80DBB80;\n  result = *(int **)(dword_80DBB80 + 80);\n  if ( result == v6 )\n  {\n    v8 = sub_809C6F9(result);\n    sub_809C4D2((char *)(int)v8);\n    v14 = sub_809CB8E(*(_DWORD *)(v7 + 28));\n    v17 = strlen(v14);\n    v16 = 0;\n    v18 = 0;\n    v19 = 0;\n    while ( v16 < (int)v8 )\n    {\n      v13 = sub_809CB8E(*(_DWORD *)(v7 - 24) + 20 * v16);\n      v9 = strlen(v13);\n      v15 = v9;\n      if ( v19 )\n      {\n        qmemcpy(&v19[v18], v14, v17);\n        v18 += v17;\n      }\n      v19 = (char *)sub_809C489(v19, v9 + v18 + v17, v21);\n      qmemcpy(&v19[v18], v13, v15);\n      ++v16;\n      v18 += v15;\n    }\n    if ( v19 )\n      v19[v18] = 0;\n    result = (int *)sub_809D076();\n    *(_BYTE *)(v7 - 4) = 1;\n    return result;\n  }\n  if ( *(int **)(dword_80DBB80 + 52) == v6 )\n  {\n    *(_BYTE *)(dword_80DBB80 - 4) = 0;\n    return result;\n  }\n  if ( *(int **)(dword_80DBB80 + 24) == v6 )\n  {\n    sub_809CE11();\n    v10 = (unsigned __int8 *)sub_809CB8E((int)v6);\n    v11 = v7 + 280;\n    return (int *)sub_809C5FE(v10, v11);\n  }\n  if ( *(int **)(dword_80DBB80 + 36) == v6 )\n  {\n    v10 = (unsigned __int8 *)sub_809CB8E((int)v6);\n    v11 = v7 + 364;\n    return (int *)sub_809C5FE(v10, v11);\n  }\n  if ( *(int **)(dword_80DBB80 + 84) == v6 )\n  {\n    result = (int *)sub_809C777(v6);\n    *(_BYTE *)(v7 - 8) = (_BYTE)result;\n  }\n  else\n  {\n    v20 = (int)sub_809C6F9(result);\n    v12 = -858993459 * (((int)v6 - *(_DWORD *)(v7 - 24)) >> 2);\n    if ( v12 >= v20 )\n      v20 = v12 + 1;\n    return (int *)sub_809D156(COERCE_UNSIGNED_INT64((double)v20), BYTE4(COERCE_UNSIGNED_INT64((double)v20)));\n  }\n  return result;\n}\n"
    ],
    "sub_809D076": [
        "0x809d076",
        "int *__usercall sub_809D076@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ebp>, int a4@<edi>)\n{\n  char v7; // [esp+0h] [ebp-8h]\n\n  sub_809C4A3((int)a1);\n  a1[3] = a2;\n  sub_809CEBC(a1, (int)a1, a3, a4, a2, v7);\n  return a1;\n}\n"
    ],
    "sub_809D090": [
        "0x809d090",
        "int *__usercall sub_809D090@<eax>(int *a1@<eax>, const char *a2@<edx>, int a3@<ebp>, int a4@<edi>)\n{\n  char *v5; // eax\n\n  v5 = 0;\n  if ( a2 && *a2 )\n    v5 = sub_804DB46(a2);\n  return sub_809D076(a1, (int)v5, a3, a4);\n}\n"
    ],
    "sub_809D0AF": [
        "0x809d0af",
        "int *__usercall sub_809D0AF@<eax>(int *a1@<eax>, const char *a2@<edx>, int a3@<ebp>, int a4@<edi>)\n{\n  int *result; // eax\n\n  result = sub_809D090(a1, a2, a3, a4);\n  *result |= 0x200u;\n  return result;\n}\n"
    ],
    "sub_809D0BB": [
        "0x809d0bb",
        "int __usercall sub_809D0BB@<eax>(const char *a1@<eax>, int a2@<ebp>)\n{\n  char v3; // dl\n  int result; // eax\n  char *v5; // ebx\n  unsigned __int8 *v6; // esi\n  unsigned __int8 *v7; // ebx\n  int v8; // ecx\n  int *v9; // eax\n\n  v3 = *a1;\n  if ( (unsigned __int8)(*a1 - 48) <= 9u || (unsigned __int8)((v3 | 0x20) - 97) <= 0x19u || (result = 0, v3 == 95) )\n  {\n    v5 = strchr(a1, 61);\n    result = 0;\n    if ( v5 )\n    {\n      v6 = (unsigned __int8 *)sub_804DB46(a1);\n      v7 = &v6[v5 - a1];\n      *v7 = 0;\n      sub_809C9F5((int)(v7 + 1), v8);\n      v9 = (int *)sub_809C86E(*(unsigned int **)(dword_80DBB80 - 56), v6);\n      sub_809D0AF(v9, (const char *)v7 + 1, a2, (int)(v7 + 1));\n      free(v6);\n      return 1;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_809D12E": [
        "0x809d12e",
        "int *__usercall sub_809D12E@<eax>(int *a1@<eax>, signed int a2@<edx>, const char *a3@<ecx>, int a4@<ebp>)\n{\n  unsigned __int8 *v6; // esi\n  unsigned int *v7; // eax\n  int *v8; // eax\n\n  v6 = sub_804D70F(a2);\n  v7 = (unsigned int *)sub_809C3B7(a1);\n  v8 = (int *)sub_809C86E(v7, v6);\n  return sub_809D0AF(v8, a3, a4, (int)a1);\n}\n"
    ],
    "sub_809D156": [
        "0x809d156",
        "int __usercall sub_809D156@<eax>(int a1@<eax>, int a2@<esi>, int a3, double a4)\n{\n  double v6; // [esp+0h] [ebp-10h]\n  int savedregs; // [esp+10h] [ebp+0h] BYREF\n\n  v6 = a4;\n  sub_809C4A3(a1);\n  *(_DWORD *)a1 |= 1u;\n  *(double *)(a1 + 4) = v6;\n  sub_809CEBC((int *)a1, a1, (int)&savedregs, (int)&a4, a2, SLOBYTE(v6));\n  return a1;\n}\n"
    ],
    "sub_809D191": [
        "0x809d191",
        "int __usercall sub_809D191@<eax>(_DWORD *a1@<eax>, int a2@<esi>)\n{\n  long double v4; // [esp+0h] [ebp-10h]\n\n  *(double *)&v4 = sub_809C6F9(a1) + 1.0;\n  return sub_809D156((int)a1, a2, SLODWORD(v4), *(double *)((char *)&v4 + 4));\n}\n"
    ],
    "sub_809D1C5": [
        "0x809d1c5",
        "int __usercall sub_809D1C5@<eax>(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4@<esi>, int a5, ...)\n{\n  const char *v6; // eax\n  int savedregs; // [esp+Ch] [ebp+0h] BYREF\n  va_list va; // [esp+18h] [ebp+Ch] BYREF\n\n  va_start(va, a5);\n  if ( a1 != a2 )\n  {\n    a4 = a2;\n    sub_809C4A3(a1);\n    *(_DWORD *)a1 |= *(_DWORD *)a4 & 0xFFFF83FD;\n    *(double *)(a1 + 4) = *(double *)(a4 + 4);\n    v6 = *(const char **)(a4 + 12);\n    if ( v6 )\n      *(_DWORD *)(a1 + 12) = sub_804DB46(v6);\n  }\n  sub_809CEBC((int *)a1, a1, (int)&savedregs, (int)va, a4, a3);\n  return a1;\n}\n"
    ],
    "sub_809D215": [
        "0x809d215",
        "int __usercall sub_809D215@<eax>(const char *a1@<esi>)\n{\n  int v1; // ebx\n  int result; // eax\n  FILE *v3; // edi\n  int v4; // eax\n  unsigned __int8 *v5; // esi\n  unsigned int *v6; // eax\n  char *v7; // eax\n  const char *v8; // eax\n  double v9; // [esp+0h] [ebp-18h]\n  int savedregs; // [esp+18h] [ebp+0h] BYREF\n\n  v1 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 112) )\n    fclose(*(FILE **)(dword_80DBB80 + 112));\n  *(_DWORD *)(v1 + 112) = 0;\n  *(_DWORD *)(v1 + 120) = 0;\n  *(_DWORD *)(v1 + 128) = 0;\n  while ( 1 )\n  {\n    v9 = sub_809C6F9((_DWORD *)*(_DWORD *)(v1 + 56));\n    if ( v9 + 1.0 >= sub_809C6F9((_DWORD *)*(_DWORD *)(v1 + 60)) )\n      break;\n    v4 = sub_809D191(*(_DWORD **)(v1 + 56), (int)a1);\n    v5 = (unsigned __int8 *)sub_809CB8E(v4);\n    v6 = (unsigned int *)sub_809C3B7(*(int **)(v1 + 64));\n    v7 = sub_809C86E(v6, v5);\n    v8 = sub_809CB8E((int)v7);\n    a1 = v8;\n    if ( v8 && *v8 && !sub_809D0BB(v8, (int)&savedregs) )\n    {\n      v3 = (FILE *)sub_80B3D9B();\n      goto LABEL_11;\n    }\n  }\n  result = 0;\n  if ( *(_BYTE *)(v1 + 109) )\n    return result;\n  v3 = stdin;\n  a1 = \"-\";\nLABEL_11:\n  *(_BYTE *)(v1 + 109) = 1;\n  sub_809D090(*(int **)(v1 + 44), a1, (int)&savedregs, (int)v3);\n  *(_DWORD *)(v1 + 112) = v3;\n  return v1 + 112;\n}\n"
    ],
    "sub_809D2E9": [
        "0x809d2e9",
        "int __usercall sub_809D2E9@<eax>(unsigned int a1@<eax>)\n{\n  int v1; // esi\n  char *v2; // ebx\n  int v3; // ecx\n  int v4; // edx\n  char *v5; // ebx\n  char *v6; // edi\n  char v7; // al\n  int v8; // edi\n  char *v9; // edi\n  char *v10; // edx\n  char v11; // al\n  char *v12; // ebx\n  char *v13; // eax\n  const char *v14; // eax\n  size_t v15; // eax\n  int v16; // eax\n  char v17; // al\n  char v18; // al\n  int v19; // eax\n  int v20; // edx\n  unsigned int v22; // [esp+0h] [ebp-30h]\n  char v23; // [esp+8h] [ebp-28h]\n  _DWORD *v24; // [esp+Ch] [ebp-24h]\n  char *v25; // [esp+10h] [ebp-20h]\n  size_t v26; // [esp+10h] [ebp-20h]\n  char *s2; // [esp+14h] [ebp-1Ch]\n  char *v29[5]; // [esp+1Ch] [ebp-14h] BYREF\n\n  v1 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 - 3) )\n  {\n    *(_BYTE *)(dword_80DBB80 - 3) = 0;\n  }\n  else if ( *(_BYTE *)(dword_80DBB80 + 108) )\n  {\n    *(_BYTE *)(dword_80DBB80 + 108) = 0;\n    *(_DWORD *)(v1 + 4) = *(_DWORD *)(v1 + 96);\n    *(_DWORD *)v1 = *(_DWORD *)(v1 + 100);\n  }\n  else\n  {\n    v2 = *(char **)(dword_80DBB80 - 16);\n    v22 = a1 >> 2;\n    do\n    {\n      v2 = sub_809C325(v2);\n      v4 = *(_DWORD *)(v1 + 12);\n      *(_DWORD *)(v1 - 36) = v4;\n      if ( *v2 == 35 )\n      {\n        while ( *v2 != 10 && *v2 )\n          ++v2;\n      }\n      if ( *v2 == 10 )\n        *(_DWORD *)(v1 + 12) = v4 + 1;\n      LOBYTE(v3) = *v2;\n      if ( !*v2 )\n      {\n        v8 = 0x2000000;\n        goto LABEL_65;\n      }\n      if ( (_BYTE)v3 == 34 )\n      {\n        v5 = v2 + 1;\n        *(_DWORD *)(v1 + 8) = v5;\n        v6 = v5;\n        while ( 1 )\n        {\n          v7 = *v5;\n          if ( *v5 == 34 )\n            break;\n          if ( v7 == 10 || !v7 )\n            goto LABEL_74;\n          v29[0] = v5;\n          *v6++ = sub_809C9C4((int *)v29, v3);\n          v5 = v29[0];\n        }\n        v2 = v5 + 1;\n        *v6 = 0;\n        v8 = 0x20000000;\n      }\n      else if ( (v22 & 1) != 0 && (_BYTE)v3 == 47 )\n      {\n        v9 = v2 + 1;\n        *(_DWORD *)(v1 + 8) = v2 + 1;\n        v10 = v2 + 1;\n        while ( 1 )\n        {\n          v11 = *v9;\n          if ( *v9 == 47 )\n            break;\n          if ( !v11 || v11 == 10 )\n            goto LABEL_74;\n          *v10 = v11;\n          v12 = v10 + 1;\n          if ( v11 == 92 )\n          {\n            v25 = v10;\n            v29[0] = v9 + 1;\n            *v10 = sub_80B0CB3(v9 + 1);\n            if ( v9[1] == 92 )\n            {\n              v12 = v25 + 2;\n              v25[1] = 92;\n            }\n            v13 = v29[0];\n            if ( v29[0] == v9 + 1 )\n            {\n              v13 = v9 + 2;\n              *v12++ = v9[1];\n            }\n            v10 = v12;\n            v9 = v13;\n          }\n          else\n          {\n            ++v10;\n            ++v9;\n          }\n        }\n        v2 = v9 + 1;\n        *v10 = 0;\n        v8 = 4;\n      }\n      else if ( (_BYTE)v3 == 46 || (unsigned __int8)(v3 - 48) <= 9u )\n      {\n        v29[0] = v2;\n        *(double *)(v1 - 116) = sub_809C668(v29);\n        v2 = v29[0];\n        if ( *v29[0] == 46 )\n          goto LABEL_37;\n        v8 = 0x40000000;\n      }\n      else\n      {\n        v24 = &unk_80B6AE0;\n        v8 = 1;\n        s2 = (char *)&unk_80D79D0;\n        while ( 1 )\n        {\n          v15 = (unsigned __int8)*s2;\n          if ( !(_BYTE)v15 )\n            break;\n          ++s2;\n          if ( (_BYTE)v15 == 0xFF )\n          {\n            v8 *= 2;\n          }\n          else\n          {\n            v26 = v15;\n            if ( (v8 & (a1 | 0x1FF8080)) != 0 )\n            {\n              v23 = v3;\n              v16 = strncmp(v2, s2, v15);\n              LOBYTE(v3) = v23;\n              if ( !v16 )\n              {\n                if ( (v8 & 0x1FF0080) == 0\n                  || (v17 = v2[v26], (unsigned __int8)(v17 - 48) > 9u)\n                  && (unsigned __int8)((v17 | 0x20) - 97) > 0x19u\n                  && v17 != 95 )\n                {\n                  *(_DWORD *)v1 = *v24;\n                  v2 += v26;\n                  goto LABEL_65;\n                }\n              }\n            }\n            ++v24;\n            s2 += v26;\n          }\n        }\n        if ( (unsigned __int8)((v3 | 0x20) - 97) > 0x19u && (_BYTE)v3 != 95 )\n        {\nLABEL_37:\n          v14 = \"Unexpected token\";\n          goto LABEL_38;\n        }\n        *(_DWORD *)(v1 + 8) = --v2;\n        while ( 1 )\n        {\n          v18 = *++v2;\n          if ( (unsigned __int8)(*v2 - 48) > 9u && (unsigned __int8)((*v2 | 0x20) - 97) > 0x19u && v18 != 95 )\n            break;\n          *(v2 - 1) = v18;\n        }\n        *(v2 - 1) = 0;\n        if ( (a1 & 0xC000000) != 0x4000000 )\n          v2 = sub_809C325(v2);\n        v8 = 0x10000000;\n        if ( *v2 != 40 )\n        {\n          v8 = 0x4000000;\n          if ( *v2 == 91 )\n          {\n            ++v2;\n            v8 = 0x8000000;\n          }\n        }\n      }\nLABEL_65:\n      *(_DWORD *)(v1 - 16) = v2;\n      v19 = *(_DWORD *)(v1 + 104);\n    }\n    while ( (v19 & 0xF3C0) != 0 && (v8 & 0x8000) != 0 );\n    if ( (v19 & 0x64000812) != 0 && (v8 & 0x7C380421) != 0 && (a1 & 0x3C0) != 0 )\n    {\n      *(_BYTE *)(v1 + 108) = 1;\n      *(_DWORD *)(v1 + 96) = v8;\n      *(_DWORD *)(v1 + 100) = *(_DWORD *)v1;\n      *(_DWORD *)v1 = 588190976;\n      v8 = 960;\n    }\n    *(_DWORD *)(v1 + 4) = v8;\n  }\n  v20 = *(_DWORD *)(v1 + 4);\n  *(_DWORD *)(v1 + 104) = v20;\n  if ( (v20 & a1) == 0 )\n  {\n    v14 = \"Unexpected token\";\n    if ( (v20 & 0x2008000) != 0 )\nLABEL_74:\n      v14 = \"Unexpected end of string\";\nLABEL_38:\n    sub_809CA86(v14);\n  }\n  return v20;\n}\n"
    ],
    "sub_809D5FE": [
        "0x809d5fe",
        "int __usercall sub_809D5FE@<eax>(unsigned int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // eax\n  unsigned int i; // ebx\n  int v5; // eax\n  _DWORD *v6; // eax\n  _DWORD *v7; // eax\n  _DWORD *v8; // ebp\n  int result; // eax\n  int v10; // edx\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 20);\n  if ( a1 < v3 + 16 || *(_DWORD *)(v3 + 4) <= a1 )\n    sub_809CA86(\"Internal error\");\n  for ( i = a1; ; i += 20 )\n  {\n    v5 = *(_DWORD *)(v2 - 20);\n    if ( *(_DWORD *)(v5 + 4) <= i )\n      break;\n    if ( (*(_DWORD *)i & 0x2002) == 2 )\n    {\n      v6 = (_DWORD *)sub_809C3B7((int *)i);\n      sub_809C53C(v6, i);\n      free(*(void **)(*(_DWORD *)(i + 16) + 16));\n      free(*(void **)(i + 16));\n    }\n    if ( (*(_DWORD *)i & 0x800) != 0 )\n    {\n      v7 = *(_DWORD **)(i + 16);\n      *(_DWORD *)(i + 16) = 0;\n      while ( v7 )\n      {\n        v8 = (_DWORD *)v7[2];\n        free(v7);\n        v7 = v8;\n      }\n    }\n    sub_809C4A3(i);\n  }\n  *(_DWORD *)(v5 + 4) = a1;\n  while ( 1 )\n  {\n    result = *(_DWORD *)(v2 - 20);\n    v10 = *(_DWORD *)(result + 8);\n    if ( !v10 || *(_DWORD *)(result + 4) != result + 16 )\n      break;\n    *(_DWORD *)(v2 - 20) = v10;\n  }\n  return result;\n}\n"
    ],
    "sub_809D6A9": [
        "0x809d6a9",
        "int __usercall sub_809D6A9@<eax>(int a1@<eax>, int *a2@<edx>)\n{\n  int v2; // edi\n  int v3; // ebx\n  char *v4; // edx\n  int v5; // esi\n  const regex_t *v6; // eax\n  regoff_t rm_so; // ebx\n  bool v8; // zf\n  const char *v9; // eax\n  char *v10; // ebx\n  _BYTE *v11; // eax\n  const char *v12; // edx\n  char *v13; // eax\n  char v14; // al\n  int v15; // eax\n  char *v16; // ebx\n  char *v17; // esi\n  long double v19; // [esp+0h] [ebp-58h]\n  int v20; // [esp+Ch] [ebp-4Ch]\n  char v21; // [esp+13h] [ebp-45h]\n  int c; // [esp+14h] [ebp-44h]\n  char ca; // [esp+14h] [ebp-44h]\n  const char *v25; // [esp+1Ch] [ebp-3Ch]\n  char v26; // [esp+1Ch] [ebp-3Ch]\n  int v27; // [esp+20h] [ebp-38h]\n  int v28; // [esp+24h] [ebp-34h]\n  char *v29; // [esp+28h] [ebp-30h]\n  regoff_t dest; // [esp+30h] [ebp-28h]\n  void *desta; // [esp+30h] [ebp-28h]\n  int v33; // [esp+34h] [ebp-24h] BYREF\n  regmatch_t v34; // [esp+38h] [ebp-20h] BYREF\n  int _58; // [esp+58h] [ebp+0h] BYREF\n\n  c = fileno_unlocked(*(FILE **)a1);\n  v29 = *(char **)(a1 + 4);\n  v28 = *(_DWORD *)(a1 + 8);\n  v2 = *(_DWORD *)(a1 + 16);\n  v33 = *(_DWORD *)(a1 + 12);\n  v3 = *(_DWORD *)(dword_80DBB80 + 364);\n  v21 = v3;\n  if ( !v29 )\n  {\n    v33 = 464;\n    v29 = (char *)sub_804DB13(0, 0x1D0u);\n  }\n  v25 = 0;\n  v4 = 0;\n  v20 = (unsigned __int8)v3;\n  while ( 1 )\n  {\n    v5 = (int)&v29[v28];\n    if ( v2 <= 0 )\n      goto LABEL_24;\n    if ( (*(_DWORD *)(dword_80DBB80 + 364) & 0xFF00) == 8448 )\n    {\n      if ( *(_BYTE *)(dword_80DBB80 - 8) )\n        v6 = *(const regex_t **)(dword_80DBB80 + 376);\n      else\n        v6 = *(const regex_t **)(dword_80DBB80 + 372);\n      if ( regexec(v6, &v29[v28], 1u, &v34, 0) )\n        goto LABEL_24;\n      rm_so = v34.rm_so;\n      dest = v34.rm_eo;\n      v8 = *(_BYTE *)(v5 + v34.rm_eo) == 0;\n    }\n    else\n    {\n      if ( v21 )\n      {\n        v10 = &v4[v5];\n        desta = v4;\n        v11 = strchr(&v4[v5], v20);\n        if ( v11 || (v11 = memchr(v10, 0, v2 - (_DWORD)desta)) != 0 )\n        {\n          rm_so = (regoff_t)&v11[-v5];\n          dest = (regoff_t)&v11[-v5 + 1];\nLABEL_33:\n          v27 = 1;\n          goto LABEL_35;\n        }\nLABEL_24:\n        dest = v2;\n        rm_so = v2;\n        goto LABEL_25;\n      }\n      v9 = &v25[v5];\n      do\n      {\n        v25 = &v9[-v5];\n        v12 = v9++;\n      }\n      while ( *(v9 - 1) == 10 );\n      v13 = strstr(v12, \"\\n\\n\");\n      if ( !v13 )\n        goto LABEL_24;\n      rm_so = (regoff_t)&v13[-v5];\n      for ( dest = (regoff_t)&v13[-v5]; ; ++dest )\n      {\n        v14 = *(_BYTE *)(v5 + dest);\n        if ( v14 != 10 )\n          break;\n      }\n      v8 = v14 == 0;\n    }\n    if ( !v8 )\n      goto LABEL_33;\nLABEL_25:\n    if ( v28 > 0 )\n    {\n      memmove(v29, (const void *)v5, v2 + 1);\n      v28 = 0;\n    }\n    v29 = (char *)sub_809C489(v29, v28 + v2 + 128, &v33);\n    v5 = (int)&v29[v28];\n    v15 = v2 + sub_804E5BC(v33 + ~v2, &v29[v28 + v2], c);\n    v27 = 1;\n    if ( v2 > v15 )\n    {\n      *(double *)&v19 = (double)*(int *)dword_80DBB7C;\n      sub_809D156(*(_DWORD *)(dword_80DBB80 + 68), v5, SLODWORD(v19), *(double *)((char *)&v19 + 4));\n      v27 = 0;\n      v15 = 0;\n    }\n    *(_BYTE *)(v5 + v15) = 0;\n    v4 = (char *)v2;\n    if ( v2 >= v15 )\n      break;\n    v2 = v15;\n  }\n  if ( !v15 )\n  {\n    --v27;\n    goto LABEL_36;\n  }\n  v2 = v15;\nLABEL_35:\n  v16 = (char *)(v5 + rm_so);\n  ca = *v16;\n  *v16 = 0;\n  sub_809D090(a2, &v25[v5], (int)&_58, v2);\n  *a2 |= 0x200u;\n  *v16 = ca;\n  v17 = (char *)(dest + v5);\n  v26 = *v17;\n  *v17 = 0;\n  sub_809D090(*(int **)(dword_80DBB80 + 40), v16, (int)&_58, v2);\n  *v17 = v26;\n  v15 = v2;\nLABEL_36:\n  *(_DWORD *)(a1 + 4) = v29;\n  *(_DWORD *)(a1 + 8) = dest + v28;\n  *(_DWORD *)(a1 + 16) = v15 - dest;\n  *(_DWORD *)(a1 + 12) = v33;\n  return v27;\n}\n"
    ],
    "sub_809D93B": [
        "0x809d93b",
        "int __usercall sub_809D93B@<eax>(int a1@<eax>)\n{\n  int v1; // esi\n  int *i; // edx\n  int *v3; // edx\n  int v4; // edi\n  int v5; // eax\n  int *v6; // ebx\n  int v7; // ecx\n  _DWORD *v8; // esi\n  int *v9; // edx\n  int *v10; // eax\n  int v11; // eax\n  char *v12; // eax\n  int *v13; // eax\n  char *v14; // eax\n  int *v15; // eax\n  double v17; // [esp-4h] [ebp-3Ch]\n  int *v18; // [esp+4h] [ebp-34h]\n  int *v19; // [esp+4h] [ebp-34h]\n  unsigned __int8 *v20; // [esp+4h] [ebp-34h]\n  int *v21; // [esp+8h] [ebp-30h]\n  unsigned int v23; // [esp+10h] [ebp-28h]\n  int v24; // [esp+10h] [ebp-28h]\n  int *v25; // [esp+10h] [ebp-28h]\n  int v26; // [esp+14h] [ebp-24h] BYREF\n  int v27; // [esp+20h] [ebp-18h]\n  int savedregs; // [esp+38h] [ebp+0h] BYREF\n\n  v26 = 2130706432;\n  v27 = 0;\n  v1 = a1 | 0x7C380425;\n  v21 = 0;\n  for ( i = &v26; ; i = v6 )\n  {\n    v18 = i;\n    v23 = sub_809D2E9(v1);\n    v3 = v18;\n    if ( (v23 & a1) != 0 )\n      break;\n    v4 = dword_80DBB80;\n    v5 = *(_DWORD *)dword_80DBB80;\n    if ( v21 && v5 == 654513154 )\n    {\n      v6 = sub_809C3DD(621745408);\n      v21[2] = (int)v6;\n      v6[4] = (int)v21;\n      v1 = 2084045857;\n      v21 = 0;\n      continue;\n    }\n    if ( (v23 & 0x3D0) != 0 )\n    {\n      v7 = *(_DWORD *)dword_80DBB80 & 0xFF00;\n      while ( 1 )\n      {\n        v8 = (_DWORD *)v3[4];\n        if ( (v5 & 0x7F000000u) <= (*v8 & 0x7E000000u) && (*v3 != v5 || v7 != 4608) )\n          break;\n        v3 = (int *)v3[4];\n      }\n      if ( v7 == 9472 )\n        *(_DWORD *)dword_80DBB80 = v5 + 100663296;\n      v19 = v3;\n      v6 = sub_809C3DD(*(_DWORD *)v4);\n      v8[3] = v6;\n      v9 = v19;\n      v6[4] = v19[4];\n      if ( (v23 & 0x3C0) != 0 )\n      {\n        v6[2] = (int)v19;\n        v1 = 2084045861;\n        if ( (*(_DWORD *)v4 & 0xFF00) == 0x2000 )\n        {\n          sub_809D2E9(0x200000u);\n          *v6 &= 0x80FFFFFF;\n          v1 = a1 | 0x7C3807E1;\n          v9 = v19;\n        }\n      }\n      else\n      {\n        v6[3] = (int)v19;\n        v1 = a1 | 0x7C3807E1;\n      }\n      v9[4] = (int)v6;\n    }\n    else\n    {\n      v10 = sub_809C3DD(v5);\n      v6 = v10;\n      v18[3] = (int)v10;\n      v10[4] = (int)v18;\n      if ( (v23 & 0x7C380005) != 0 )\n      {\n        v1 = a1 | 0x7C3807F1;\n        if ( v23 == 0x200000 )\n        {\n          v1 = a1 | 0x7C3807E1;\n          v21 = v10;\n          continue;\n        }\n        if ( v23 > 0x200000 )\n        {\n          if ( v23 == 0x10000000 )\n          {\n            *v10 = 6400;\n            v10[3] = (int)sub_809C86E(*(unsigned int **)(v4 - 44), *(unsigned __int8 **)(v4 + 8));\nLABEL_52:\n            v6[2] = sub_809DC87();\n            continue;\n          }\n          if ( v23 > 0x10000000 )\n          {\n            if ( v23 == 0x20000000 || v23 == 0x40000000 )\n            {\n              *v10 = 9984;\n              v13 = (int *)sub_804DB2E(0x14u);\n              v6[2] = (int)v13;\n              if ( (v23 & 0x40000000) != 0 )\n              {\n                LODWORD(v17) = *(_DWORD *)(v4 - 112);\n                sub_809D156((int)v13, v1, *(_DWORD *)(v4 - 116), v17);\n              }\n              else\n              {\n                sub_809D090(v13, *(const char **)(v4 + 8), (int)&savedregs, v4);\n              }\n            }\n          }\n          else if ( v23 == 0x4000000 || v23 == 0x8000000 )\n          {\n            *v10 = 9984;\n            v20 = *(unsigned __int8 **)(v4 + 8);\n            v11 = sub_809C834(*(_DWORD *)(v4 - 52), v20);\n            if ( v11 )\n            {\n              *v6 = 6144;\n              v12 = *(char **)(v11 + 16);\n            }\n            else\n            {\n              v12 = sub_809C86E(*(unsigned int **)(v4 - 56), v20);\n            }\n            v6[2] = (int)v12;\n            if ( (v23 & 0x8000000) != 0 )\n            {\n              *v6 |= 0xA0000u;\n              v6[3] = sub_809D93B(HIDWORD(v17), (char)v20);\n            }\n          }\n        }\n        else\n        {\n          if ( v23 == 4 )\n          {\n            v14 = (char *)sub_804DB2E(0x40u);\n            v24 = *(_DWORD *)(v4 + 8);\n            *v6 = 8448;\n            v6[2] = (int)v14;\n            v6[3] = (int)(v14 + 32);\n            sub_80B47BA(1, v24);\n            sub_80B47BA(3, v24);\n            continue;\n          }\n          if ( v23 > 4 )\n          {\n            if ( v23 == 0x80000 )\n              goto LABEL_52;\n            if ( v23 == 0x100000 )\n            {\n              sub_809D2E9(0xE001u);\n              sub_809C35F();\n              if ( (*(_BYTE *)(v4 + 4) & 1) != 0 )\n                goto LABEL_52;\n            }\n          }\n          else if ( v23 == 1 )\n          {\n            v25 = v18;\n            v15 = (int *)sub_809D93B(HIDWORD(v17), (char)v18);\n            v6 = v15;\n            v25[3] = (int)v15;\n            if ( !v15 )\n              sub_809CA86(\"Empty sequence\");\n            v15[4] = (int)v25;\n          }\n        }\n      }\n      else\n      {\n        v1 = 2084045861;\n      }\n    }\n  }\n  return v27;\n}\n"
    ],
    "sub_809DC87": [
        "0x809dc87",
        "int sub_809DC87()\n{\n  sub_809D2E9(1u);\n  return sub_809D93B(2);\n}\n"
    ],
    "sub_809DCC3": [
        "0x809dcc3",
        "_DWORD *sub_809DCC3()\n{\n  _DWORD *v0; // ebx\n  int v1; // eax\n  _DWORD *result; // eax\n  int v3; // eax\n  int v4; // ebx\n  unsigned int v5; // edx\n  int v6; // ebx\n  _DWORD *v7; // esi\n  _DWORD *v8; // edi\n  _DWORD *v9; // esi\n  _DWORD *v10; // esi\n  int v11; // ebx\n  _DWORD *v12; // eax\n  _DWORD *v13; // esi\n  _DWORD *v14; // eax\n  int v15; // ebx\n  _DWORD *v16; // eax\n  int v17; // edx\n\n  do\n    v1 = sub_809D2E9(0x7C3BD425u);\n  while ( (v1 & 0x8000) != 0 );\n  if ( (v1 & 0x1000) != 0 )\n  {\n    while ( 1 )\n    {\n      result = (_DWORD *)sub_809D2E9(0x7C3BF425u);\n      if ( result == (_DWORD *)0x2000 )\n        break;\n      if ( *(char *)(dword_80DBB80 + 5) >= 0 )\n      {\n        sub_809C35F();\n        sub_809DCC3();\n      }\n    }\n    return result;\n  }\n  if ( (v1 & 0x7C38C425) != 0 )\n  {\n    sub_809C35F();\n    v3 = 66048;\n    goto LABEL_40;\n  }\n  v4 = dword_80DBB80;\n  v3 = *(_DWORD *)dword_80DBB80;\n  v5 = *(_DWORD *)dword_80DBB80 & 0xFF00;\n  if ( v5 == 2304 )\n  {\n    v16 = sub_809C596(512);\n    v17 = *(_DWORD *)(v4 - 64);\nLABEL_37:\n    v16[4] = v17;\n    v3 = *(_DWORD *)v4;\n    goto LABEL_40;\n  }\n  if ( v5 > 0x900 )\n  {\n    if ( v5 == 12544 )\n    {\n      v10 = sub_809C596(512);\n      v11 = sub_809DF36();\n      v10[4] = *(_DWORD *)(v11 + 16);\n      sub_809D2E9(0x20000u);\n      result = (_DWORD *)sub_809DC87();\n      *(_DWORD *)(v11 + 8) = result;\n      return result;\n    }\n    if ( v5 <= 0x3100 )\n    {\n      if ( v5 == 12288 )\n      {\n        v7 = sub_809C596(67328);\n        v7[2] = sub_809DC87();\n        sub_809DCC3();\n        v8 = sub_809C596(512);\n        v7[3] = *(_DWORD *)(*(_DWORD *)(v4 - 72) + 4);\n        if ( sub_809D2E9(0x7C3FF425u) == 0x40000 )\n        {\n          sub_809DCC3();\n          result = *(_DWORD **)(*(_DWORD *)(v4 - 72) + 4);\n          v8[4] = result;\n          return result;\n        }\n        return (_DWORD *)sub_809C35F();\n      }\n      goto LABEL_40;\n    }\n    if ( v5 == 12800 )\n    {\n      sub_809D2E9(1u);\n      v12 = (_DWORD *)sub_809D93B(16386);\n      v13 = v12;\n      if ( (*(_BYTE *)(v4 + 4) & 2) != 0 )\n      {\n        if ( !v12 || (*v12 & 0xFF00) != 6912 )\n          sub_809CA86(\"Unexpected token\");\n        v14 = sub_809C596(198144);\n        v14[2] = v13[2];\n        v14[3] = v13[3];\n        result = (_DWORD *)sub_809DF36();\n        *result = 69120;\n        result[2] = v13[2];\n      }\n      else\n      {\n        sub_809C596(66048)[2] = v12;\n        v15 = sub_809D93B(0x4000);\n        sub_809D93B(2);\n        result = (_DWORD *)sub_809DF36();\n        result[2] = v15;\n        if ( !v15 )\n          *result = 512;\n      }\n      return result;\n    }\n    if ( v5 == 13056 )\n    {\n      v6 = sub_809DC87();\n      result = (_DWORD *)sub_809DF36();\n      result[2] = v6;\n      return result;\n    }\nLABEL_40:\n    v0 = sub_809C596(v3);\n    v0[2] = sub_809D93B(57344);\n    result = (_DWORD *)dword_80DBB80;\n    if ( (*(_BYTE *)(dword_80DBB80 + 5) & 0x20) == 0 )\n      return result;\n    return (_DWORD *)sub_809C35F();\n  }\n  if ( v5 != 1280 )\n  {\n    if ( v5 != 2048 )\n    {\n      if ( v5 != 1024 )\n        goto LABEL_40;\n      goto LABEL_23;\n    }\n    v16 = sub_809C596(512);\n    v17 = *(_DWORD *)(v4 - 68);\n    goto LABEL_37;\n  }\nLABEL_23:\n  v9 = sub_809C596(v3);\n  result = (_DWORD *)sub_809D93B(57352);\n  v9[2] = result;\n  if ( (*(_BYTE *)(v4 + 4) & 8) != 0 )\n  {\n    *v9 |= *(_DWORD *)v4;\n    result = (_DWORD *)sub_809D93B(57344);\n    v9[3] = result;\n  }\n  if ( (*(_BYTE *)(v4 + 5) & 0x20) != 0 )\n    return (_DWORD *)sub_809C35F();\n  return result;\n}\n"
    ],
    "sub_809DF36": [
        "0x809df36",
        "_DWORD *__usercall sub_809DF36@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // edi\n  int v3; // ebp\n  _DWORD *v4; // esi\n  _DWORD *v5; // eax\n  int v6; // eax\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 - 68);\n  v3 = *(_DWORD *)(dword_80DBB80 - 64);\n  v4 = sub_809C596(67328);\n  *(_DWORD *)(v1 - 64) = sub_809C3DD(512);\n  *(_DWORD *)(v1 - 68) = sub_809C3DD(512);\n  sub_809DCC3();\n  v5 = sub_809C596(66048);\n  v5[2] = a1;\n  v5[4] = v4;\n  *(_DWORD *)(*(_DWORD *)(v1 - 64) + 16) = v5;\n  v6 = *(_DWORD *)(*(_DWORD *)(v1 - 72) + 4);\n  v4[3] = v6;\n  *(_DWORD *)(*(_DWORD *)(v1 - 68) + 16) = v6;\n  *(_DWORD *)(v1 - 64) = v3;\n  *(_DWORD *)(v1 - 68) = v2;\n  return v4;\n}\n"
    ],
    "sub_809DFAB": [
        "0x809dfab",
        "int __usercall sub_809DFAB@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int result; // eax\n  int v3; // eax\n  char *v4; // esi\n  char *v5; // eax\n  int v6; // edx\n  _DWORD *v7; // esi\n\n  v1 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 - 16) = a1;\n  *(_DWORD *)(v1 + 12) = 1;\n  while ( 1 )\n  {\n    result = sub_809D2E9(0x7FF8D425u);\n    if ( result == 0x2000000 )\n      return result;\n    if ( (result & 0xC000) == 0 )\n    {\n      *(_DWORD *)(v1 - 72) = v1 - 96;\n      if ( (result & 0x800000) != 0 )\n      {\n        v3 = v1 - 108;\nLABEL_8:\n        *(_DWORD *)(v1 - 72) = v3;\n        goto LABEL_20;\n      }\n      if ( (result & 0x1000000) != 0 )\n      {\n        v3 = v1 - 84;\n        goto LABEL_8;\n      }\n      if ( (result & 0x400000) != 0 )\n      {\n        sub_809D2E9(0x10000000u);\n        ++*(_DWORD *)(v1 - 16);\n        v4 = sub_809C86E(*(unsigned int **)(v1 - 44), *(unsigned __int8 **)(v1 + 8));\n        *((_DWORD *)v4 + 1) = 0;\n        *(_DWORD *)v4 = 0;\n        do\n        {\n          if ( (sub_809D2E9(0x4000002u) & 0x4000000) == 0 )\n            break;\n          v5 = sub_809C86E(*(unsigned int **)(v1 - 52), *(unsigned __int8 **)(v1 + 8));\n          v6 = (*(_DWORD *)v4)++;\n          *((_DWORD *)v5 + 4) = v6;\n        }\n        while ( (sub_809D2E9(0x102u) & 2) == 0 );\n        *(_DWORD *)(v1 - 72) = v4 + 4;\n        sub_809DCC3();\n        sub_809C53C(*(_DWORD **)(v1 - 52), v1);\n      }\n      else if ( (result & 0x7C380425) != 0 )\n      {\n        sub_809C35F();\n        v7 = sub_809C596(3328);\n        v7[2] = sub_809D93B(33607680);\n        if ( (*(_BYTE *)(v1 + 5) & 0x10) != 0 )\n        {\n          sub_809C35F();\n          sub_809DCC3();\n        }\n        else\n        {\n          sub_809C596(1024);\n        }\n        v7[3] = *(_DWORD *)(v1 - 92);\n      }\n      else\n      {\n        sub_809C35F();\nLABEL_20:\n        sub_809DCC3();\n      }\n    }\n  }\n}\n"
    ],
    "sub_809E0CF": [
        "0x809e0cf",
        "int *__usercall sub_809E0CF@<eax>(unsigned int *a1@<eax>, int *a2@<edx>, int a3, ...)\n{\n  unsigned int *v4; // edi\n  _DWORD *v5; // ebx\n  _DWORD *v6; // eax\n  int v7; // esi\n  int v8; // edx\n  int *v9; // ebx\n  const char *v10; // eax\n  int v11; // eax\n  unsigned __int8 *v12; // esi\n  _DWORD *v13; // eax\n  _DWORD *v14; // eax\n  char v15; // cl\n  int v16; // eax\n  int v17; // edx\n  int v18; // eax\n  int v19; // esi\n  int *v20; // ebx\n  unsigned int v21; // esi\n  int v22; // edx\n  int v23; // ecx\n  _DWORD *v24; // eax\n  int v25; // ebx\n  const char *v26; // eax\n  FILE *v27; // esi\n  char *v28; // esi\n  FILE *v29; // eax\n  _DWORD *v30; // eax\n  const char *v31; // eax\n  int v32; // ebx\n  unsigned int *v33; // eax\n  char *v34; // eax\n  int v35; // eax\n  long double v36; // fst7\n  regex_t *v37; // ebx\n  int v38; // eax\n  int v39; // eax\n  _DWORD *v40; // edx\n  _DWORD *v41; // ecx\n  _DWORD *v42; // esi\n  char v43; // cl\n  int v44; // esi\n  char *v45; // ebx\n  int v46; // ebx\n  unsigned int v47; // eax\n  size_t v48; // eax\n  FILE **v49; // eax\n  FILE *v50; // eax\n  int v51; // eax\n  int v52; // eax\n  long double v53; // fst7\n  long double v54; // fst6\n  long double v55; // fst7\n  int v56; // esi\n  const char *v57; // eax\n  char *v58; // eax\n  long double v59; // fst7\n  long double v60; // fst7\n  int v61; // eax\n  int v62; // eax\n  long double v63; // fst7\n  const char *v64; // esi\n  const char *v65; // eax\n  int v66; // eax\n  int v67; // eax\n  bool v68; // al\n  unsigned int v69; // eax\n  __int128 v71; // [esp+0h] [ebp-7Ch]\n  long double v72; // [esp+0h] [ebp-7Ch]\n  void *v73; // [esp+4h] [ebp-78h]\n  int v74; // [esp+4h] [ebp-78h]\n  FILE *v75; // [esp+8h] [ebp-74h]\n  int v76; // [esp+8h] [ebp-74h]\n  double v77; // [esp+Ch] [ebp-70h]\n  int v78; // [esp+Ch] [ebp-70h]\n  _BOOL4 v79; // [esp+18h] [ebp-64h]\n  char *v80; // [esp+1Ch] [ebp-60h]\n  _DWORD *v81; // [esp+20h] [ebp-5Ch]\n  double v82; // [esp+24h] [ebp-58h]\n  int v83; // [esp+2Ch] [ebp-50h]\n  int v84; // [esp+2Ch] [ebp-50h]\n  int v85; // [esp+2Ch] [ebp-50h]\n  int v86; // [esp+2Ch] [ebp-50h]\n  int v87; // [esp+2Ch] [ebp-50h]\n  int v88; // [esp+2Ch] [ebp-50h]\n  __int64 v89; // [esp+2Ch] [ebp-50h]\n  int v90; // [esp+2Ch] [ebp-50h]\n  double v91; // [esp+2Ch] [ebp-50h]\n  double v92; // [esp+34h] [ebp-48h]\n  unsigned int v93; // [esp+3Ch] [ebp-40h]\n  int *v94; // [esp+40h] [ebp-3Ch]\n  char *s; // [esp+44h] [ebp-38h]\n  int v96; // [esp+48h] [ebp-34h]\n  int *v97; // [esp+4Ch] [ebp-30h]\n  _DWORD *v98[5]; // [esp+68h] [ebp-14h] BYREF\n  int _7C; // [esp+7Ch] [ebp+0h] BYREF\n  va_list va; // [esp+88h] [ebp+Ch] BYREF\n\n  va_start(va, a3);\n  if ( a1 )\n  {\n    v4 = a1;\n    v81 = sub_809C3FA(2);\n    v97 = a2;\n    while ( 1 )\n    {\n      v93 = *v4;\n      v83 = *v4 & 0x7F;\n      v5 = (_DWORD *)dword_80DBB80;\n      *(_DWORD *)(dword_80DBB80 - 36) = v4[1];\n      v6 = (_DWORD *)v4[2];\n      v98[0] = v6;\n      v7 = BYTE1(v93);\n      if ( BYTE1(v93) == 1 )\n      {\n        v8 = *v6 & 0xFF00;\n        if ( v8 == 9984 )\n        {\n          v9 = (int *)v6[2];\n        }\n        else\n        {\n          if ( v8 != 6144 )\n          {\n            v10 = \"Not an array\";\n            goto LABEL_90;\n          }\n          v9 = (int *)(v5[34] + 20 * v6[2]);\n        }\n        if ( v6[3] )\n        {\n          v11 = sub_809E0CF();\n          v12 = (unsigned __int8 *)sub_809CB8E(v11);\n          v13 = (_DWORD *)sub_809C3B7(v9);\n          sub_809C96D(v13, v12);\n        }\n        else\n        {\n          v14 = (_DWORD *)sub_809C3B7(v9);\n          sub_809C53C(v14, (int)v9);\n        }\n      }\n      else\n      {\n        v15 = v93;\n        if ( (v93 & 0x10000) != 0 )\n          v96 = sub_809E0CF();\n        if ( (v93 & 0x20000) != 0 )\n          v94 = (int *)sub_809E0CF();\n        if ( (v93 & 0x40000) != 0 )\n          s = (char *)sub_809CB8E(v96);\n        if ( (v93 & 0x80000) != 0 )\n          v80 = (char *)sub_809CB8E((int)v94);\n        if ( (v93 & 0x100000) != 0 )\n          v92 = sub_809C6F9((_DWORD *)v96);\n        switch ( BYTE1(v93) )\n        {\n          case 2:\n            break;\n          case 3:\n            *(v5 - 10) = v4[2];\n            break;\n          case 4:\n          case 5:\n            v27 = stdout;\n            if ( v4[3] )\n            {\n              v28 = sub_809C86E((unsigned int *)*(v5 - 12), (unsigned __int8 *)v80);\n              if ( !*(_DWORD *)v28 )\n              {\n                if ( v83 == 124 )\n                {\n                  v29 = popen(v80, \"w\");\n                  *(_DWORD *)v28 = v29;\n                  if ( !v29 )\n                    sub_804D3C9((int)\"popen\");\n                  v28[20] = 1;\n                }\n                else\n                {\n                  *(_DWORD *)v28 = sub_804DBA5(v80);\n                }\n              }\n              v27 = *(FILE **)v28;\n            }\n            if ( (v93 & 0xFF00) == 1024 )\n            {\n              if ( v98[0] )\n              {\n                while ( 1 )\n                {\n                  v32 = dword_80DBB80;\n                  if ( !v98[0] )\n                    break;\n                  sub_809C369(v98);\n                  v30 = (_DWORD *)sub_809E0CF();\n                  if ( (*(_BYTE *)v30 & 1) != 0 )\n                  {\n                    v77 = sub_809C6F9(v30);\n                    v31 = sub_809CB8E(*(_DWORD *)(v32 + 20));\n                    HIDWORD(v72) = 1;\n                    *(double *)&v72 = v77;\n                    sub_809CA9D(\n                      *(char **)(v32 - 12),\n                      0xF0u,\n                      v31,\n                      SLODWORD(v77),\n                      *(double *)((char *)&v72 + 4),\n                      SLODWORD(v77));\n                  }\n                  fputs_unlocked();\n                  if ( v98[0] )\n                    fputs_unlocked();\n                }\n              }\n              else\n              {\n                fputs_unlocked();\n              }\n              fputs_unlocked();\n            }\n            else\n            {\n              v73 = (void *)sub_809F5D5();\n              fputs_unlocked();\n              free(v73);\n            }\n            fflush(v27);\n            break;\n          case 6:\n            v17 = sub_809C3B7(v94);\n            v18 = *(_DWORD *)v96;\n            if ( (*(_DWORD *)v96 & 0x800) != 0 )\n            {\n              v19 = *(_DWORD *)(v96 + 16);\n            }\n            else\n            {\n              BYTE1(v18) |= 8u;\n              *(_DWORD *)v96 = v18;\n              v19 = 0;\n            }\n            v84 = v17;\n            v20 = (int *)sub_804DB2E(*(_DWORD *)(v17 + 12) + 17);\n            *(_DWORD *)(v96 + 16) = v20;\n            *v20 = (int)(v20 + 3);\n            v20[1] = (int)(v20 + 3);\n            v20[2] = v19;\n            v21 = 0;\n            v22 = v84;\n            while ( v21 < *(_DWORD *)(v22 + 4) )\n            {\n              v23 = *(_DWORD *)(*(_DWORD *)(v22 + 16) + 4 * v21);\n              while ( v23 )\n              {\n                HIDWORD(v71) = v22;\n                v85 = v23;\n                strcpy((char *)*v20, (const char *)(v23 + 28));\n                sub_809C34C(v20);\n                v23 = *(_DWORD *)(v85 + 24);\n                v22 = HIDWORD(v71);\n              }\n              ++v21;\n            }\n            break;\n          case 7:\n            v16 = sub_809C777((int *)v96);\n            goto LABEL_32;\n          case 0xA:\n            sub_809ECFD();\n          case 0xB:\n            goto LABEL_71;\n          case 0xC:\n            *((_BYTE *)v5 - 5) = 1;\nLABEL_71:\n            *((_BYTE *)v5 - 6) = 1;\n            goto LABEL_72;\n          case 0xD:\n            if ( (*v98[0] & 0xFF00) == 4864 )\n            {\n              if ( (v93 & 0x200000) == 0 && !sub_809F79B() )\n                goto LABEL_33;\n              *v4 |= 0x200000u;\n              if ( sub_809F79B() )\n                *v4 &= ~0x200000u;\n            }\n            else\n            {\n              v16 = sub_809F79B();\nLABEL_32:\n              if ( !v16 )\n              {\nLABEL_33:\n                v4 = (unsigned int *)v4[3];\n                break;\n              }\n            }\nLABEL_46:\n            v4 = (unsigned int *)v4[4];\n            break;\n          case 0xE:\n            v24 = *(_DWORD **)(v96 + 16);\n            if ( v24[1] >= *v24 )\n            {\n              v25 = v24[2];\n              free(*(void **)(v96 + 16));\n              *(_DWORD *)(v96 + 16) = v25;\n              v4 = (unsigned int *)v4[3];\n              break;\n            }\n            v26 = (const char *)sub_809C34C(v24 + 1);\n            sub_809D090((int *)v96, v26, (int)&_7C, (int)v4);\n            goto LABEL_46;\n          case 0x10:\n          case 0x22:\n            v59 = sub_809C6F9(v94);\n            switch ( v83 )\n            {\n              case '%':\n                if ( v59 == 0.0 )\n                  goto LABEL_187;\n                v59 = v59 * (long double)(__int64)(v92 / v59);\nLABEL_191:\n                v60 = v92 - v59;\n                goto LABEL_192;\n              case '&':\n                goto LABEL_118;\n              case '*':\n                v60 = v59 * v92;\n                goto LABEL_192;\n              case '+':\n                v60 = v59 + v92;\n                goto LABEL_192;\n              case '-':\n                goto LABEL_191;\n              case '/':\n                if ( v59 == 0.0 )\n                {\nLABEL_187:\n                  v10 = \"Division by zero\";\nLABEL_90:\n                  sub_809CA86(v10);\n                }\n                v60 = v92 / v59;\nLABEL_192:\n                v92 = v60;\nLABEL_193:\n                if ( (v93 & 0xFF00) != 4096 )\n                  v97 = (int *)v96;\n                DWORD2(v71) = HIDWORD(v92);\n                v97 = (int *)sub_809D156((int)v97, v83 - 37, SLODWORD(v92), *((double *)&v71 + 1));\n                break;\n              default:\n                goto LABEL_193;\n            }\n            break;\n          case 0x11:\n            v34 = (char *)sub_809EFFE();\n            goto LABEL_87;\n          case 0x13:\n          case 0x15:\n            v57 = &data;\n            if ( (v93 & 0xFF00) == 4864 )\n              v57 = sub_809CB8E(v5[12]);\n            v58 = sub_804DDBF(\"%s%s%s\", s, v57, v80);\n            sub_809D076(v97, (int)v58, (int)&_7C, (int)v4);\n            break;\n          case 0x14:\n            sub_809C6F9((_DWORD *)v96);\n            v61 = *(_DWORD *)v96;\n            BYTE1(v61) = BYTE1(*(_DWORD *)v96) ^ 0x40;\n            if ( (v61 & 0x4201) != 0\n              && (sub_809C6F9(v94), v62 = *v94, BYTE1(v62) = BYTE1(*v94) ^ 0x40, (v62 & 0x4201) != 0) )\n            {\n              v91 = sub_809C6F9((_DWORD *)v96);\n              v63 = v91 - sub_809C6F9(v94);\n            }\n            else\n            {\n              v64 = sub_809CB8E(v96);\n              v65 = sub_809CB8E((int)v94);\n              if ( *((_BYTE *)v5 - 8) )\n                v66 = strcasecmp(v64, v65);\n              else\n                v66 = strcmp(v64, v65);\n              v7 = v76;\n              v63 = (long double)v66;\n            }\n            v67 = v93 & 0x7E;\n            if ( v67 == 2 )\n            {\n              v68 = v63 >= 0.0;\nLABEL_208:\n              v79 = v68;\n              goto LABEL_210;\n            }\n            if ( v67 != 4 )\n            {\n              if ( (v93 & 0x7E) != 0 )\n                goto LABEL_210;\n              v68 = v63 > 0.0;\n              goto LABEL_208;\n            }\n            v79 = v63 == 0.0;\nLABEL_210:\n            v39 = v79 ^ ((v93 & 1) == 0);\nLABEL_211:\n            v88 = v39;\nLABEL_212:\n            v36 = (long double)v88;\n            goto LABEL_213;\n          case 0x16:\n            switch ( v83 )\n            {\n              case 0:\n                v89 = (__int64)v92;\n                goto LABEL_128;\n              case 1:\n                v82 = (long double)rand() / 2147483647.0;\n                goto LABEL_150;\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\nLABEL_118:\n                v10 = \"Math support is not compiled in\";\n                goto LABEL_90;\n              case 7:\n                v82 = (double)(unsigned int)v5[35];\n                if ( v98[0] )\n                  v47 = (__int64)v92;\n                else\n                  v47 = time(0);\n                v5[35] = v47;\n                srand(v47);\n                goto LABEL_150;\n              case 8:\n                v82 = (double)time(0);\n                goto LABEL_150;\n              case 9:\n                if ( !v98[0] )\n                {\n                  s = (char *)sub_809CB8E(v5[13]);\n                  v48 = strlen(s);\nLABEL_130:\n                  v82 = (double)v48;\n                  goto LABEL_150;\n                }\n                if ( (*(_BYTE *)v96 & 2) == 0 )\n                {\n                  v48 = strlen(s);\n                  goto LABEL_130;\n                }\n                v89 = **(unsigned int **)(v96 + 16);\nLABEL_128:\n                v82 = (double)v89;\nLABEL_150:\n                DWORD2(v71) = HIDWORD(v82);\n                sub_809D156((int)v97, v7, SLODWORD(v82), *((double *)&v71 + 1));\n                break;\n              case 10:\n                sub_804DD8F();\n                v82 = 0.0;\n                if ( s && *s )\n                  v82 = (double)(system(s) >> 8);\n                goto LABEL_150;\n              case 11:\n                if ( v98[0] )\n                {\n                  if ( s && *s )\n                  {\n                    v75 = *(FILE **)sub_809C86E((unsigned int *)*(v5 - 12), (unsigned __int8 *)s);\n                    fflush(v75);\n                  }\n                  else\n                  {\n                    sub_804DD8F();\n                  }\n                }\n                else\n                {\n                  fflush(stdout);\n                }\n                goto LABEL_150;\n              case 12:\n                v49 = (FILE **)sub_809C834(*(v5 - 12), (unsigned __int8 *)s);\n                v7 = (int)v49;\n                v90 = 0;\n                if ( v49 )\n                {\n                  v50 = *v49;\n                  if ( v50 )\n                  {\n                    if ( *(_BYTE *)(v7 + 20) )\n                      v51 = pclose(v50);\n                    else\n                      v51 = fclose(v50);\n                    v90 = v51;\n                  }\n                  free(*(void **)(v7 + 4));\n                  sub_809C96D((_DWORD *)*(v5 - 12), (unsigned __int8 *)s);\n                  if ( v90 )\n                  {\n                    *(double *)((char *)&v71 + 4) = (double)*(int *)dword_80DBB7C;\n                    sub_809D156(v5[17], v7, SDWORD1(v71), *((double *)&v71 + 1));\n                    v7 = DWORD2(v71);\n                  }\n                }\n                v82 = (double)v90;\n                goto LABEL_150;\n              default:\n                goto LABEL_150;\n            }\n            break;\n          case 0x17:\n            v55 = sub_809C6F9(v94);\n            v56 = (int)v55;\n            if ( (int)v55 < 0 )\n            {\n              v10 = \"Access to negative field\";\n              goto LABEL_90;\n            }\n            if ( (int)v55 )\n            {\n              sub_809CE11();\n              if ( *(v5 - 8) < v56 )\n                sub_809C4D2((char *)(int)v55);\n              v34 = (char *)(*(v5 - 6) + 20 * v56 - 20);\n            }\n            else\n            {\n              v34 = (char *)v5[13];\n            }\nLABEL_87:\n            v97 = (int *)v34;\n            break;\n          case 0x18:\n            v97 = (int *)(v5[34] + 20 * v4[2]);\n            goto LABEL_77;\n          case 0x19:\n            v40 = (_DWORD *)v4[3];\n            if ( !*v40 && !v40[1] )\n            {\n              v10 = \"Call to undefined function\";\n              goto LABEL_90;\n            }\n            v41 = sub_809C3FA(*v40 + 1);\n            v42 = v41;\n            do\n            {\n              if ( !v98[0] )\n                break;\n              v78 = (int)v41;\n              sub_809C369(v98);\n              v86 = sub_809E0CF();\n              sub_809D1C5((int)v42, v86, v43, (int)v42, v78);\n              *v42 |= 0x2000u;\n              v42[4] = v86;\n              v42 += 5;\n              v41 = (_DWORD *)HIDWORD(v71);\n            }\n            while ( (unsigned int)(-858993459 * (((int)v42 - HIDWORD(v71)) >> 2)) < *(_DWORD *)v4[3] );\n            v44 = v5[34];\n            v5[34] = v41;\n            v87 = *(v5 - 10);\n            v97 = (int *)sub_809E0CF();\n            *(v5 - 10) = v87;\n            sub_809D5FE(v5[34]);\n            v5[34] = v44;\n            break;\n          case 0x1A:\n          case 0x20:\n            v7 = v93 & 0xFF00;\n            if ( v98[0] )\n            {\n              v45 = sub_809C86E((unsigned int *)*(v5 - 12), (unsigned __int8 *)s);\n              if ( !*(_DWORD *)v45 )\n              {\n                if ( v7 == 0x2000 )\n                {\n                  *(_DWORD *)v45 = popen(s, \"r\");\n                  v45[20] = 1;\n                  v7 = v74;\n                }\n                else\n                {\n                  *(_DWORD *)v45 = sub_80B3D37();\n                }\n              }\n            }\n            else\n            {\n              if ( !*(v5 - 15) )\n                *(v5 - 15) = sub_809D215((const char *)v7);\n              v45 = (char *)*(v5 - 15);\n              if ( !v45 )\n              {\nLABEL_107:\n                *(double *)((char *)&v71 + 4) = (double)*(int *)dword_80DBB7C;\n                sub_809D156(*(_DWORD *)(dword_80DBB80 + 68), v7, SDWORD1(v71), *((double *)&v71 + 1));\n                LODWORD(v71) = -1074790400;\n                sub_809D156((int)v97, v7, 0, *(double *)&v71);\n                break;\n              }\n            }\n            if ( !*(_DWORD *)v45 )\n              goto LABEL_107;\n            if ( !v4[3] )\n              v94 = *(int **)(dword_80DBB80 + 52);\n            v46 = sub_809D6A9((int)v45, v94);\n            if ( v46 > 0 && !v98[0] )\n            {\n              v7 = dword_80DBB80;\n              sub_809D191(*(_DWORD **)(dword_80DBB80 + 72), dword_80DBB80);\n              sub_809D191(*(_DWORD **)(v7 + 76), v7);\n            }\n            v88 = v46;\n            goto LABEL_212;\n          case 0x1B:\n            v35 = sub_809C3B7(v94);\n            v36 = 0.0;\n            if ( sub_809C834(v35, (unsigned __int8 *)s) )\n              goto LABEL_168;\n            goto LABEL_213;\n          case 0x1C:\n            v36 = 0.0;\n            if ( sub_809C777((int *)v96) )\n              goto LABEL_182;\n            goto LABEL_213;\n          case 0x1D:\n            v36 = 1.0;\n            if ( sub_809C777((int *)v96) )\n              goto LABEL_213;\nLABEL_182:\n            v39 = sub_809F79B();\n            goto LABEL_211;\n          case 0x1E:\n            v98[0] = (_DWORD *)v4[3];\n            goto LABEL_83;\n          case 0x1F:\n            v34 = (char *)sub_809D1C5(v96, (int)v94, v15, BYTE1(v93), SHIDWORD(v71));\n            goto LABEL_87;\n          case 0x21:\n            v98[0] = v4;\n            s = (char *)sub_809CB8E(v5[13]);\nLABEL_83:\n            v37 = (regex_t *)(v5 + 36);\n            v7 = sub_809ED64();\n            v38 = regexec((const regex_t *)v7, s, 0, 0, 0);\n            if ( v37 == (regex_t *)v7 )\n            {\n              HIDWORD(v71) = v38;\n              regfree(v37);\n              v38 = HIDWORD(v71);\n            }\n            v39 = (v83 == 33) ^ (v38 == 0);\n            goto LABEL_211;\n          case 0x23:\n            sub_809D1C5((int)v97, v96, v15, BYTE1(v93), SHIDWORD(v71));\n            break;\n          case 0x24:\n            v52 = sub_809F5D5();\n            sub_809D076(v97, v52, (int)&_7C, (int)v4);\n            break;\n          case 0x25:\n            if ( (*(_DWORD *)v4[3] & 0xFF00) != 4608 )\n              goto LABEL_89;\n            sub_809C777((int *)v96);\n            v34 = (char *)sub_809E0CF();\n            goto LABEL_87;\n          case 0x26:\n            v36 = sub_809C6F9(v94);\n            if ( v83 == 77 )\n            {\n              v53 = v36 - 1.0;\n              goto LABEL_164;\n            }\n            if ( v83 > 77 )\n            {\n              switch ( v83 )\n              {\n                case 'm':\n                  v54 = v36;\n                  v53 = v36 - 1.0;\n                  break;\n                case 'p':\n                  v54 = v36;\n                  v53 = v36 + 1.0;\n                  break;\n                case 'P':\n                  v53 = v36 + 1.0;\nLABEL_164:\n                  v54 = v53;\n                  break;\n                default:\n                  goto LABEL_213;\n              }\n              *(double *)((char *)&v71 + 4) = v53;\n              sub_809D156((int)v94, BYTE1(v93), COERCE_UNSIGNED_INT64(v53), *((double *)&v71 + 1));\n              v36 = (double)v54;\n              goto LABEL_213;\n            }\n            if ( v83 == 33 )\n            {\n              v36 = 0.0;\n              if ( !sub_809C777(v94) )\nLABEL_168:\n                v36 = 1.0;\n            }\n            else if ( v83 == 45 )\n            {\n              v36 = -v36;\n            }\nLABEL_213:\n            *(double *)((char *)&v71 + 4) = v36;\n            sub_809D156((int)v97, v7, COERCE_UNSIGNED_INT64(v36), *((double *)&v71 + 1));\n            break;\n          case 0x27:\n            v97 = (int *)v4[2];\n            if ( v97 == (int *)v5[20] )\n              sub_809CE11();\nLABEL_77:\n            if ( !v4[3] )\n              break;\n            v33 = (unsigned int *)sub_809C3B7(v97);\n            v34 = sub_809C86E(v33, (unsigned __int8 *)v80);\n            goto LABEL_87;\n          case 0x28:\nLABEL_72:\n            sub_809C4A3((int)v97);\n            break;\n          default:\nLABEL_89:\n            v10 = \"Possible syntax error\";\n            goto LABEL_90;\n        }\n      }\n      v69 = v93 & 0xFF00;\n      if ( v69 > 0x600 )\n      {\n        if ( v69 > 0xFFF )\n          goto LABEL_219;\n      }\n      else\n      {\n        v4 = (unsigned int *)v4[4];\n      }\n      if ( *(_BYTE *)(dword_80DBB80 - 6) || !v4 )\n      {\nLABEL_219:\n        sub_809D5FE((unsigned int)v81);\n        return v97;\n      }\n    }\n  }\n  return sub_809D076(a2, 0, (int)&_7C, (int)va);\n}\n"
    ],
    "sub_809ECFD": [
        "0x809ecfd",
        "void __usercall __noreturn sub_809ECFD(int a1@<eax>)\n{\n  int v2; // ebx\n  unsigned int i; // edi\n  int v4; // eax\n  int j; // esi\n  int v6[9]; // [esp+0h] [ebp-24h] BYREF\n\n  memset(v6, 0, 0x14u);\n  v2 = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 - 7) )\n  {\n    *(_BYTE *)(dword_80DBB80 - 7) = 1;\n    *(_BYTE *)(v2 - 6) = 0;\n    sub_809E0CF(*(unsigned int **)(v2 - 84), v6, v6[0]);\n  }\n  for ( i = 0; ; ++i )\n  {\n    v4 = *(_DWORD *)(v2 - 48);\n    if ( *(_DWORD *)(v4 + 4) <= i )\n      break;\n    for ( j = *(_DWORD *)(*(_DWORD *)(v4 + 16) + 4 * i); j; j = *(_DWORD *)(j + 24) )\n    {\n      if ( *(_DWORD *)j )\n      {\n        if ( *(_BYTE *)(j + 20) )\n          pclose(*(FILE **)j);\n      }\n    }\n  }\n  exit(a1);\n}\n"
    ],
    "sub_809ED64": [
        "0x809ed64",
        "regex_t *__usercall sub_809ED64@<eax>(unsigned int *a1@<eax>, regex_t *a2@<edx>)\n{\n  int v3; // ebx\n  regex_t *v4; // esi\n  int *v5; // edi\n  int *v6; // eax\n  const char *v7; // ebp\n  int v8; // ebx\n  int v10; // [esp+0h] [ebp-10h]\n\n  v3 = dword_80DBB80;\n  if ( (*a1 & 0xFF00) == 8448 )\n  {\n    if ( *(_BYTE *)(dword_80DBB80 - 8) )\n      return (regex_t *)a1[3];\n    else\n      return (regex_t *)a1[2];\n  }\n  else\n  {\n    v4 = a2;\n    v5 = sub_809C3FA(1);\n    v6 = sub_809E0CF(a1, v5, v10);\n    v7 = sub_809CB8E((int)v6);\n    v8 = *(_BYTE *)(v3 - 8) == 0 ? 1 : 3;\n    if ( regcomp(v4, v7, v8) )\n      sub_80B47BA(v8 & 0xFFFFFFFE, v7);\n    sub_809D5FE((unsigned int)v5);\n  }\n  return v4;\n}\n"
    ],
    "sub_809EDE3": [
        "0x809ede3",
        "int __usercall sub_809EDE3@<eax>(\n        unsigned int *a1@<eax>,\n        const char *a2@<edx>,\n        int a3@<ecx>,\n        int a4@<edi>,\n        int a5,\n        int *a6,\n        char a7)\n{\n  int v7; // ebx\n  int v8; // eax\n  int v9; // ebx\n  char *v10; // ebp\n  int v11; // esi\n  int v12; // eax\n  unsigned __int8 v13; // dl\n  int v14; // ecx\n  int v15; // esi\n  unsigned int v16; // ebx\n  size_t v17; // eax\n  char *string; // [esp+0h] [ebp-ACh]\n  unsigned int rm_eo; // [esp+4h] [ebp-A8h]\n  int v21; // [esp+8h] [ebp-A4h]\n  int v22; // [esp+Ch] [ebp-A0h]\n  regex_t *preg; // [esp+10h] [ebp-9Ch]\n  const char *i; // [esp+14h] [ebp-98h]\n  size_t v25; // [esp+18h] [ebp-94h]\n  regoff_t rm_so; // [esp+1Ch] [ebp-90h]\n  int v29; // [esp+28h] [ebp-84h] BYREF\n  regex_t v30; // [esp+2Ch] [ebp-80h] BYREF\n  regmatch_t v31[12]; // [esp+4Ch] [ebp-60h] BYREF\n\n  v7 = a5;\n  preg = sub_809ED64(a1, &v30);\n  if ( !a5 )\n    v7 = *(_DWORD *)(dword_80DBB80 + 52);\n  string = (char *)sub_809CB8E(v7);\n  v25 = strlen(a2);\n  v8 = 0;\n  v9 = 0;\n  v22 = 0;\n  v10 = 0;\n  while ( 1 )\n  {\n    v11 = v9;\n    if ( regexec(preg, string, 0xAu, v31, v8) )\n      break;\n    rm_so = v31[0].rm_so;\n    rm_eo = v31[0].rm_eo;\n    v9 += v31[0].rm_eo;\n    v10 = (char *)sub_809C489(v10, v9 + v25, &v29);\n    qmemcpy(&v10[v11], string, rm_eo);\n    a4 = (int)&v10[v11 + rm_eo];\n    if ( ++v22 >= a3 )\n    {\n      v9 -= rm_eo - rm_so;\n      v12 = 0;\n      for ( i = a2; ; ++i )\n      {\n        a4 = (int)i;\n        v13 = *i;\n        v14 = v9;\n        if ( !*i )\n          break;\n        ++v9;\n        v10[v14] = v13;\n        if ( v13 == 92 )\n        {\n          ++v12;\n        }\n        else\n        {\n          if ( v13 == 38 || (unsigned __int8)(v13 - 48) <= 9u && (a7 & 1) != 0 )\n          {\n            v21 = v9 - ((v12 + 3) >> 1);\n            v15 = 0;\n            if ( v13 != 38 )\n            {\n              v15 = v13 - 48;\n              LOBYTE(v12) = v12 + 1;\n            }\n            if ( (v12 & 1) != 0 )\n            {\n              v9 = v21 + 1;\n              v10[v21] = v13;\n            }\n            else\n            {\n              v16 = v31[v15].rm_eo - v31[v15].rm_so;\n              v10 = (char *)sub_809C489(v10, v16 + v21 + v25, &v29);\n              qmemcpy(&v10[v21], &string[v31[v15].rm_so], v16);\n              v9 = v21 + v16;\n            }\n          }\n          v12 = 0;\n        }\n      }\n    }\n    string += rm_eo;\n    if ( v22 == a3 )\n      break;\n    if ( rm_so == rm_eo )\n    {\n      v10[v9] = *string;\n      if ( !*string )\n        goto LABEL_26;\n      ++string;\n      ++v9;\n    }\n    v8 = 1;\n  }\n  v17 = strlen(string);\n  v10 = (char *)sub_809C489(v10, v17 + v9, &v29);\n  strcpy(&v10[v9], string);\nLABEL_26:\n  if ( !a6 )\n    a6 = *(int **)(dword_80DBB80 + 52);\n  sub_809D076(a6, (int)v10, (int)v10, a4);\n  if ( preg == &v30 )\n    regfree(preg);\n  return v22;\n}\n"
    ],
    "sub_809EFFE": [
        "0x809effe",
        "int *__usercall sub_809EFFE@<eax>(size_t *a1@<eax>, int *a2@<edx>)\n{\n  int *v2; // edi\n  size_t v3; // esi\n  int i; // ebx\n  unsigned int *v5; // eax\n  const char *v6; // eax\n  const char *v7; // esi\n  unsigned int *v8; // eax\n  int *v9; // eax\n  unsigned __int8 *v10; // eax\n  unsigned __int8 *buffer; // edi\n  int *v12; // esi\n  _DWORD *v13; // eax\n  signed int j; // ebx\n  const char *v15; // eax\n  char *v16; // esi\n  signed int v17; // edi\n  long double v18; // fst7\n  int v19; // ecx\n  int v20; // edx\n  _BYTE *v21; // edx\n  int v22; // ebx\n  int v23; // ebx\n  long double v24; // fst7\n  int v25; // ebx\n  int v26; // ebx\n  unsigned int v27; // ebx\n  int v28; // ebx\n  char *v29; // eax\n  _BYTE *k; // ecx\n  char *v31; // ebx\n  int v32; // eax\n  int v33; // ecx\n  char *v34; // eax\n  int v35; // edi\n  int v36; // eax\n  struct tm *v37; // eax\n  char *v38; // edx\n  int v39; // ebx\n  regex_t *v40; // ebx\n  int v41; // edi\n  char *v42; // eax\n  char *v43; // eax\n  int v44; // ebx\n  int v45; // eax\n  long double v47; // [esp+0h] [ebp-B8h]\n  long double v48; // [esp+4h] [ebp-B4h]\n  long double v49; // [esp+8h] [ebp-B0h]\n  long double v50; // [esp+Ch] [ebp-ACh]\n  long double v51; // [esp+10h] [ebp-A8h]\n  char *v52; // [esp+10h] [ebp-A8h]\n  int v53; // [esp+1Ch] [ebp-9Ch]\n  size_t v54; // [esp+20h] [ebp-98h]\n  int v55; // [esp+20h] [ebp-98h]\n  size_t v56; // [esp+20h] [ebp-98h]\n  int v57; // [esp+20h] [ebp-98h]\n  size_t v58; // [esp+20h] [ebp-98h]\n  int v59; // [esp+20h] [ebp-98h]\n  signed int v60; // [esp+20h] [ebp-98h]\n  double rm_so; // [esp+20h] [ebp-98h]\n  double v62; // [esp+20h] [ebp-98h]\n  int *v63; // [esp+28h] [ebp-90h]\n  int v65; // [esp+30h] [ebp-88h]\n  size_t *v66; // [esp+40h] [ebp-78h] BYREF\n  time_t v67; // [esp+44h] [ebp-74h] BYREF\n  unsigned int *v68[2]; // [esp+48h] [ebp-70h]\n  unsigned int *v69; // [esp+50h] [ebp-68h]\n  _DWORD *v70; // [esp+58h] [ebp-60h]\n  time_t timer; // [esp+5Ch] [ebp-5Ch]\n  int *v72; // [esp+60h] [ebp-58h]\n  int v73; // [esp+64h] [ebp-54h]\n  char *haystack; // [esp+68h] [ebp-50h]\n  char *s2; // [esp+6Ch] [ebp-4Ch]\n  regmatch_t v76; // [esp+78h] [ebp-40h] BYREF\n  regex_t v77; // [esp+88h] [ebp-30h] BYREF\n  int _B8; // [esp+B8h] [ebp+0h] BYREF\n\n  v66 = a1;\n  v63 = sub_809C3FA(4);\n  v54 = *v66;\n  v66 = (size_t *)v66[2];\n  v73 = 0;\n  v72 = 0;\n  v2 = v63;\n  v3 = v54;\n  for ( i = 0; i != 4; ++i )\n  {\n    if ( !v66 )\n      break;\n    v5 = sub_809C369(&v66);\n    v68[i] = v5;\n    if ( (v3 & 0x9000000) != 0 )\n      (&v70)[i] = sub_809E0CF(v5, v2, SHIDWORD(v51));\n    if ( (v3 & 0x8000000) != 0 )\n      (&haystack)[i] = (char *)sub_809CB8E((int)(&v70)[i]);\n    v3 >>= 1;\n    v2 += 5;\n  }\n  if ( v54 >> 30 > i )\n  {\n    v6 = \"Too few arguments for builtin\";\nLABEL_12:\n    sub_809CA86(v6);\n  }\n  v7 = (const char *)(v54 & 0x7F);\n  switch ( v54 & 0x7F )\n  {\n    case 0u:\n      v6 = \"Math support is not compiled in\";\n      goto LABEL_12;\n    case 1u:\n      v7 = s2;\n      v59 = strlen(s2);\n      v31 = haystack;\n      v32 = strlen(haystack) - v59;\n      v33 = v32;\n      if ( v59 <= 0 || v32 < 0 )\n        goto LABEL_56;\n      if ( *(_BYTE *)(dword_80DBB80 - 8) )\n      {\n        v35 = 0;\n        do\n        {\n          v53 = v33;\n          v36 = strncasecmp(&v31[v35++], v7, v59);\n          v33 = v53;\n          if ( !v36 )\n            goto LABEL_57;\n        }\n        while ( v35 <= v53 );\nLABEL_56:\n        v35 = 0;\n      }\n      else\n      {\n        v34 = strstr(v31, v7);\n        v7 = v52;\n        v35 = 0;\n        if ( v34 )\n          v35 = v34 - v31 + 1;\n      }\nLABEL_57:\n      v60 = v35;\nLABEL_65:\n      v24 = (long double)v60;\nLABEL_33:\n      *(double *)&v51 = v24;\n      sub_809D156((int)a2, (int)v7, COERCE_UNSIGNED_INT64(v24), *(double *)((char *)&v51 + 4));\nLABEL_76:\n      sub_809D5FE((unsigned int)v63);\n      return a2;\n    case 2u:\n      v40 = sub_809ED64(v68[1], &v77);\n      if ( regexec(v40, haystack, 1u, &v76, 0) )\n      {\n        v76.rm_so = 0;\n        v76.rm_eo = -1;\n      }\n      else\n      {\n        ++v76.rm_so;\n        ++v76.rm_eo;\n      }\n      rm_so = (double)v76.rm_so;\n      v41 = dword_80DBB80;\n      v42 = sub_809C86E(*(unsigned int **)(dword_80DBB80 - 56), \"RSTART\");\n      *(double *)&v51 = rm_so;\n      sub_809D156((int)v42, (int)&v77, SLODWORD(rm_so), *(double *)((char *)&v51 + 4));\n      v62 = (double)(v76.rm_eo - v76.rm_so);\n      v43 = sub_809C86E(*(unsigned int **)(v41 - 56), \"RLENGTH\");\n      *(double *)&v49 = v62;\n      sub_809D156((int)v43, (int)&v77, SLODWORD(v62), *(double *)((char *)&v49 + 4));\n      *(double *)&v47 = (double)v76.rm_so;\n      sub_809D156((int)a2, (int)&v77, SLODWORD(v47), *(double *)((char *)&v47 + 4));\n      if ( v40 == &v77 )\n        regfree(v40);\n      goto LABEL_76;\n    case 3u:\n      if ( i <= 2 )\n      {\n        v8 = (unsigned int *)(dword_80DBB80 + 280);\n      }\n      else\n      {\n        v8 = v69;\n        if ( (*v69 & 0xFF00) != 8448 )\n        {\n          i = dword_80DBB80 + 196;\n          v9 = sub_809E0CF(v69, v63 + 10, SHIDWORD(v51));\n          v10 = (unsigned __int8 *)sub_809CB8E((int)v9);\n          v8 = (unsigned int *)sub_809C5FE(v10, i);\n        }\n      }\n      v55 = sub_809CC09(haystack, v8, (char **)&v77);\n      buffer = v77.buffer;\n      v12 = (int *)timer;\n      v13 = (_DWORD *)sub_809C3B7((int *)timer);\n      sub_809C53C(v13, i);\n      for ( j = 1; j <= v55; ++j )\n      {\n        v15 = (const char *)sub_809C34C((int *)&v77);\n        sub_809D12E(v12, j, v15, (int)&_B8);\n      }\n      free(buffer);\n      *(double *)&v50 = (double)v55;\n      sub_809D156((int)a2, (int)v12, SLODWORD(v50), *(double *)((char *)&v50 + 4));\n      goto LABEL_76;\n    case 4u:\n      v16 = haystack;\n      v17 = strlen(haystack);\n      v18 = sub_809C6F9((_DWORD *)timer) - 1.0;\n      v19 = v17;\n      if ( v17 > (int)v18 )\n        v19 = (int)v18;\n      if ( v19 < 0 )\n        v19 = 0;\n      v2 = (int *)(v17 - v19);\n      v20 = (int)v2;\n      if ( i > 2 )\n      {\n        v56 = v19;\n        v20 = (int)sub_809C6F9(v72);\n        v19 = v56;\n      }\n      if ( v20 < 0 )\n        v20 = 0;\n      v21 = sub_804DB5D(&v16[v19], v20);\n      goto LABEL_47;\n    case 5u:\n      if ( i <= 1 )\n        time(&v67);\n      else\n        v67 = (int)sub_809C6F9((_DWORD *)timer);\n      v37 = localtime(&v67);\n      v38 = \"%a %b %d %H:%M:%S %Z %Y\";\n      if ( i )\n        v38 = haystack;\n      v39 = dword_80DBB80;\n      *(_BYTE *)(*(_DWORD *)(v39 - 12) + strftime(*(char **)(dword_80DBB80 - 12), 0xF0u, v38, v37)) = 0;\n      sub_809D090(a2, *(const char **)(v39 - 12), (int)&_B8, (int)v2);\n      goto LABEL_76;\n    case 6u:\n      v60 = sub_809CA0F(haystack);\n      goto LABEL_65;\n    case 7u:\n    case 8u:\n      v29 = sub_804DB46(haystack);\n      v58 = (size_t)v29;\n      for ( k = v29; *k; ++k )\n      {\n        LOBYTE(v29) = *k;\n        v29 = (char *)((unsigned int)v29 | 0x20);\n        v2 = (int *)(v29 - 97);\n        if ( (unsigned __int8)((_BYTE)v29 - 97) <= 0x19u )\n        {\n          if ( v7 == (const char *)8 )\n          {\n            LOBYTE(v29) = *k;\n            v29 = (char *)((unsigned int)v29 & 0xFFFFFFDF);\n          }\n          *k = (_BYTE)v29;\n        }\n      }\n      v21 = (_BYTE *)v58;\nLABEL_47:\n      sub_809D076(a2, (int)v21, (int)&_B8, (int)v2);\n      goto LABEL_76;\n    case 9u:\n      v44 = v73;\n      v65 = (int)sub_809C6F9(v72);\n      sub_809EDE3(v68[0], s2, v65, (int)v2, v44, a2, 1);\n      goto LABEL_76;\n    case 0xAu:\n      v45 = sub_809EDE3(v68[0], s2, 0, (int)v2, (int)v72, v72, 0);\n      goto LABEL_75;\n    case 0xBu:\n      v45 = sub_809EDE3(v68[0], s2, 1, (int)v2, (int)v72, v72, 0);\nLABEL_75:\n      *(double *)&v48 = (double)v45;\n      sub_809D156((int)a2, (int)v7, SLODWORD(v48), *(double *)((char *)&v48 + 4));\n      goto LABEL_76;\n    case 0xCu:\n      v22 = sub_809C7CC(v70);\n      v23 = sub_809C7CC((_DWORD *)timer) & v22;\n      goto LABEL_35;\n    case 0xDu:\n      v57 = ~sub_809C7CC(v70);\n      goto LABEL_32;\n    case 0xEu:\n      v25 = sub_809C7CC(v70);\n      v23 = v25 << sub_809C7CC((_DWORD *)timer);\n      goto LABEL_35;\n    case 0xFu:\n      v26 = sub_809C7CC(v70);\n      v23 = sub_809C7CC((_DWORD *)timer) | v26;\n      goto LABEL_35;\n    case 0x10u:\n      v27 = sub_809C7CC(v70);\n      v23 = v27 >> sub_809C7CC((_DWORD *)timer);\n      goto LABEL_35;\n    case 0x11u:\n      v28 = sub_809C7CC(v70);\n      v23 = sub_809C7CC((_DWORD *)timer) ^ v28;\nLABEL_35:\n      v57 = v23;\nLABEL_32:\n      v24 = (long double)(unsigned int)v57;\n      goto LABEL_33;\n    default:\n      goto LABEL_76;\n  }\n}\n"
    ],
    "sub_809F5D5": [
        "0x809f5d5",
        "_BYTE *__usercall sub_809F5D5@<eax>(char *a1@<eax>)\n{\n  unsigned int *v1; // eax\n  int *v2; // eax\n  const char *v3; // eax\n  int v4; // esi\n  void *v5; // edi\n  const char *i; // eax\n  char *v7; // ebx\n  char v8; // cl\n  unsigned int *v9; // eax\n  int *v10; // eax\n  int v11; // eax\n  int v12; // eax\n  int v13; // eax\n  size_t v14; // eax\n  int v15; // eax\n  _BYTE *result; // eax\n  double v17; // [esp+0h] [ebp-44h]\n  int v18; // [esp+Ch] [ebp-38h]\n  int v19; // [esp+Ch] [ebp-38h]\n  size_t v20; // [esp+10h] [ebp-34h]\n  const char *v21; // [esp+10h] [ebp-34h]\n  char *v22; // [esp+14h] [ebp-30h]\n  size_t v23; // [esp+18h] [ebp-2Ch]\n  int *v24; // [esp+18h] [ebp-2Ch]\n  int *maxlen; // [esp+1Ch] [ebp-28h]\n  const char *ptr; // [esp+20h] [ebp-24h]\n  char v27; // [esp+24h] [ebp-20h]\n  char v28; // [esp+25h] [ebp-1Fh]\n  char *format; // [esp+2Ch] [ebp-18h] BYREF\n  int v30[5]; // [esp+30h] [ebp-14h] BYREF\n\n  format = a1;\n  maxlen = sub_809C3FA(1);\n  v1 = sub_809C369((_DWORD **)&format);\n  v2 = sub_809E0CF(v1, maxlen, v18);\n  v3 = sub_809CB8E((int)v2);\n  v22 = sub_804DB46(v3);\n  ptr = v22;\n  v4 = 0;\n  v5 = 0;\n  while ( *ptr )\n  {\n    for ( i = ptr; ; ++i )\n    {\n      if ( !*i )\n      {\n        v7 = (char *)i;\n        goto LABEL_15;\n      }\n      v7 = (char *)(i + 1);\n      if ( *i == 37 )\n        break;\nLABEL_6:\n      ;\n    }\n    if ( i[1] == 37 )\n    {\n      ++i;\n      goto LABEL_6;\n    }\n    while ( *v7 && (unsigned __int8)((*v7 | 0x20) - 97) > 0x19u )\n    {\n      if ( *v7 == 42 )\n        sub_809CA86(\"%*x formats are not supported\");\n      ++v7;\n    }\nLABEL_15:\n    v20 = v7 - ptr + 240;\n    v23 = v4 + v20;\n    v5 = sub_809C489(v5, v4 + v20, v30);\n    v8 = *v7;\n    if ( *v7 )\n      ++v7;\n    v27 = v8;\n    v28 = *v7;\n    *v7 = 0;\n    v9 = sub_809C369((_DWORD **)&format);\n    v10 = sub_809E0CF(v9, maxlen, v19);\n    if ( v27 != 99 && v27 )\n    {\n      if ( v27 == 115 )\n      {\n        v21 = sub_809CB8E((int)v10);\n        v14 = strlen(v21);\n        v5 = sub_809C489(v5, v14 + v23, v30);\n        v13 = sprintf((char *)v5 + v4, ptr, v21);\n      }\n      else\n      {\n        v17 = sub_809C6F9(v10);\n        v13 = sub_809CA9D((char *)v5 + v4, v20, ptr, SLODWORD(v17), COERCE_DOUBLE((unsigned __int64)HIDWORD(v17)), v19);\n      }\n    }\n    else\n    {\n      v24 = v10;\n      sub_809C6F9(v10);\n      v11 = *v24;\n      BYTE1(v11) = BYTE1(*v24) ^ 0x40;\n      if ( (v11 & 0x4201) != 0 )\n        v12 = (unsigned __int8)(__int16)sub_809C6F9(v24);\n      else\n        v12 = *(unsigned __int8 *)sub_809CB8E((int)v24);\n      v13 = sprintf((char *)v5 + v4, ptr, v12);\n    }\n    v15 = v4 + v13;\n    *v7 = v28;\n    if ( v4 < v15 )\n      v4 = v15;\n    ptr = v7;\n  }\n  free(v22);\n  sub_809D5FE((unsigned int)maxlen);\n  result = sub_804DB13(v5, v4 + 1);\n  result[v4] = 0;\n  return result;\n}\n"
    ],
    "sub_809F79B": [
        "0x809f79b",
        "decompilation failure at 809F79B!\n"
    ],
    "sub_809F7B1": [
        "0x809f7b1",
        "void __usercall __noreturn sub_809F7B1(int *a1@<esi>, int a2, int a3)\n{\n  _DWORD *v3; // eax\n  _DWORD *v4; // ebx\n  int i; // edi\n  int v6; // ebx\n  unsigned __int8 *v7; // eax\n  const char *v8; // eax\n  const char *v9; // eax\n  const char **v10; // esi\n  int v11; // ecx\n  int *v12; // edi\n  char *v13; // eax\n  int v14; // edi\n  unsigned int *v15; // eax\n  int *v16; // eax\n  const char *v17; // eax\n  char *v18; // esi\n  signed int v19; // eax\n  int v20; // ecx\n  int v21; // eax\n  int v22; // eax\n  signed int j; // esi\n  const char *v24; // ecx\n  const char *v25; // esi\n  int v26; // eax\n  char *v27; // eax\n  long double v28; // [esp+0h] [ebp-50h]\n  int v29; // [esp+0h] [ebp-50h]\n  const char *v30; // [esp+0h] [ebp-50h]\n  int v31; // [esp+4h] [ebp-4Ch]\n  double v32; // [esp+4h] [ebp-4Ch]\n  char v33; // [esp+8h] [ebp-48h]\n  int v34; // [esp+Ch] [ebp-44h]\n  FILE *v35; // [esp+Ch] [ebp-44h]\n  char v36; // [esp+10h] [ebp-40h]\n  char *v37; // [esp+10h] [ebp-40h]\n  const char *v38; // [esp+14h] [ebp-3Ch] BYREF\n  int v39; // [esp+18h] [ebp-38h] BYREF\n  int v40; // [esp+1Ch] [ebp-34h] BYREF\n  int v41; // [esp+20h] [ebp-30h] BYREF\n  const char *v42; // [esp+24h] [ebp-2Ch] BYREF\n  const char *v43; // [esp+28h] [ebp-28h] BYREF\n  int v44[9]; // [esp+2Ch] [ebp-24h] BYREF\n  FILE *var44; // [esp+50h] [ebp+0h] BYREF\n\n  v44[5] = (int)&a2;\n  v34 = a3;\n  v39 = 0;\n  v40 = 0;\n  v41 = 0;\n  v42 = \"CONVFMT\";\n  v43 = \"%.6g\";\n  v3 = sub_804DB2E(0x234u);\n  v4 = v3 + 29;\n  dword_80DBB80 = (int)(v3 + 29);\n  v3[55] = 49152;\n  v3[64] = 1;\n  memset(v44, 0, 0x14u);\n  v3[26] = sub_804DAFA(0xF1u);\n  *(v4 - 14) = sub_809C392();\n  *(v4 - 13) = sub_809C392();\n  *(v4 - 12) = sub_809C392();\n  *(v4 - 11) = sub_809C392();\n  for ( i = 0; ; ++i )\n  {\n    v6 = dword_80DBB80;\n    if ( !*v42 )\n      break;\n    v7 = (unsigned __int8 *)sub_809C34C((int *)&v42);\n    a1 = (int *)sub_809C86E(*(unsigned int **)(v6 - 56), v7);\n    *(_DWORD *)(v6 + 4 * i + 16) = a1;\n    if ( *v43 == -1 )\n    {\n      DWORD1(v28) = 0;\n      sub_809D156((int)a1, (int)a1, 0, *(double *)((char *)&v28 + 4));\n    }\n    else\n    {\n      v8 = (const char *)sub_809C34C((int *)&v43);\n      sub_809D090(a1, v8, (int)&var44, i);\n    }\n    v9 = v42;\n    if ( *v42 == 42 )\n    {\n      *a1 |= 0x400u;\n      v42 = v9 + 1;\n    }\n  }\n  sub_809CEBC(*(int **)(dword_80DBB80 + 24), dword_80DBB80, (int)&var44, i, (int)a1, SBYTE8(v28));\n  sub_809CEBC(*(int **)(v6 + 36), v6, (int)&var44, i, (int)a1, v33);\n  *(_DWORD *)sub_809C86E(*(unsigned int **)(v6 - 48), \"/dev/stdin\") = stdin;\n  *(_DWORD *)sub_809C86E(*(unsigned int **)(v6 - 48), \"/dev/stdout\") = stdout;\n  *(_DWORD *)sub_809C86E(*(unsigned int **)(v6 - 48), \"/dev/stderr\") = stderr;\n  v10 = (const char **)environ;\n  if ( environ )\n  {\n    while ( *v10 )\n    {\n      v37 = (char *)*v10;\n      v13 = strchr(*v10, 61);\n      v14 = (int)v13;\n      if ( v13 )\n      {\n        *v13 = 0;\n        v15 = (unsigned int *)sub_809C3B7(*(int **)(v6 + 88));\n        v16 = (int *)sub_809C86E(v15, (unsigned __int8 *)v37);\n        sub_809D0AF(v16, (const char *)(v14 + 1), (int)&var44, v14);\n        *(_BYTE *)v14 = 61;\n      }\n      ++v10;\n    }\n  }\n  v36 = sub_80ABEAC(v34, \"+F:v:*f:*e:*W:\", &v38, &v39, &v40, &v41, 0);\n  v12 = (int *)(v34 + 4 * optind);\n  if ( (v36 & 0x10) != 0 )\n  {\n    sub_804D5F4(\"warning: option -W is ignored\");\n    v11 = v31;\n  }\n  if ( (v36 & 1) != 0 )\n  {\n    sub_809C9F5((int)v38, v11);\n    sub_809D090(*(int **)(v6 + 24), v38, (int)&var44, (int)v12);\n  }\n  while ( v39 )\n  {\n    v17 = (const char *)sub_80AFB01(HIDWORD(v28));\n    if ( !sub_809D0BB(v17, (int)&var44) )\n      goto LABEL_22;\n  }\n  while ( v40 )\n  {\n    *(_DWORD *)(v6 - 40) = sub_80AFB01(HIDWORD(v28));\n    v35 = (FILE *)sub_80B3D9B();\n    v18 = 0;\n    v20 = 1;\n    do\n    {\n      HIDWORD(v28) = v20;\n      v18 = (char *)sub_804DB13(v18, v20 + 4096);\n      v19 = fread(&v18[HIDWORD(v28)], 1u, 0xFFEu, v35);\n      v20 = v19 + HIDWORD(v28);\n    }\n    while ( v19 > 0 );\n    v18[v20] = 0;\n    fclose(v35);\n    sub_809DFAB((int)(v18 + 1));\n    free(v18);\n  }\n  *(_DWORD *)(v6 - 40) = \"cmd. line\";\n  while ( v41 )\n  {\n    v21 = sub_80AFB01(HIDWORD(v28));\n    sub_809DFAB(v21);\n  }\n  if ( (v36 & 0xC) == 0 )\n  {\n    v22 = *v12;\n    if ( !*v12 )\nLABEL_22:\n      sub_804CDC2();\n    ++v12;\n    sub_809DFAB(v22);\n  }\n  sub_809D12E(*(int **)(v6 + 64), 0, \"awk\", (int)&var44);\n  for ( j = 0; ; sub_809D12E(*(int **)(v6 + 64), j, v24, (int)&var44) )\n  {\n    v24 = (const char *)v12[j++];\n    if ( !v24 )\n      break;\n  }\n  *(double *)&v28 = (double)j;\n  sub_809D156(*(_DWORD *)(v6 + 60), j, SLODWORD(v28), *(double *)((char *)&v28 + 4));\n  sub_809E0CF(*(unsigned int **)(v6 - 108), v44, v29);\n  v25 = v30;\n  if ( *(_DWORD *)(v6 - 96) || *(_DWORD *)(v6 - 84) )\n  {\n    if ( *(_DWORD *)(v6 - 60) )\n      goto LABEL_41;\nLABEL_40:\n    while ( 1 )\n    {\n      *(_DWORD *)(v6 - 60) = sub_809D215(v25);\nLABEL_41:\n      if ( !*(_DWORD *)(v6 - 60) )\n        break;\n      *(_BYTE *)(v6 - 5) = 0;\n      LODWORD(v32) = 0;\n      sub_809D156(*(_DWORD *)(v6 + 72), (int)v25, 0, v32);\n      while ( 1 )\n      {\n        v26 = sub_809D6A9(*(_DWORD *)(v6 - 60), *(int **)(v6 + 52));\n        if ( v26 <= 0 )\n          break;\n        *(_BYTE *)(v6 - 6) = 0;\n        sub_809D191(*(_DWORD **)(v6 + 76), (int)v25);\n        sub_809D191(*(_DWORD **)(v6 + 72), (int)v25);\n        sub_809E0CF(*(unsigned int **)(v6 - 96), v44, SHIDWORD(v32));\n        if ( *(_BYTE *)(v6 - 5) )\n          goto LABEL_40;\n      }\n      if ( v26 )\n      {\n        v27 = strerror(*(_DWORD *)dword_80DBB7C);\n        sub_809CA86(v27);\n      }\n    }\n  }\n  sub_809ECFD(0);\n}\n"
    ],
    "sub_809FB30": [
        "0x809fb30",
        "int __cdecl sub_809FB30(int a1, int a2)\n{\n  int v2; // ebx\n  unsigned __int64 v3; // rdi\n  __int64 v4; // kr00_8\n  int v5; // ebx\n  int v6; // ebp\n  unsigned int v7; // eax\n  unsigned int v8; // eax\n  int v9; // edi\n  unsigned __int8 *v10; // eax\n  int v11; // edx\n  unsigned __int8 *v12; // eax\n  int v13; // ecx\n  __int64 v15; // [esp+0h] [ebp-38h]\n  const char *v16; // [esp+8h] [ebp-30h]\n  const char *v17; // [esp+Ch] [ebp-2Ch]\n  char *format; // [esp+10h] [ebp-28h]\n  int v19; // [esp+14h] [ebp-24h]\n  FILE *stream; // [esp+18h] [ebp-20h]\n  int v21; // [esp+24h] [ebp-14h]\n  int v22; // [esp+24h] [ebp-14h]\n  int v23; // [esp+24h] [ebp-14h]\n\n  stream = stdout;\n  v19 = sub_80ABEAC(a2, &unk_80D7B90);\n  v2 = a2 + 4 * optind;\n  v17 = *(const char **)v2;\n  v16 = *(const char **)(v2 + 4);\n  if ( v16 )\n  {\n    if ( *(_DWORD *)(v2 + 8) )\n    {\n      v4 = sub_80B3F6D(-1, 0x7FFFFFFF);\n      v3 = __PAIR64__(v4, HIDWORD(v4));\n      v15 = 0LL;\n      if ( *(_DWORD *)(v2 + 12) )\n        v15 = sub_80B3F6D(-1, 0x7FFFFFFF);\n    }\n    else\n    {\n      v15 = 0LL;\n      v3 = 0LL;\n    }\n  }\n  else\n  {\n    v15 = 0LL;\n    v3 = 0LL;\n    v16 = \"-\";\n  }\n  byte_80DB560 = 2;\n  if ( (v19 & 1) != 0 )\n    byte_80DB561 = 0;\n  v5 = sub_80B3D9B();\n  v6 = sub_80B3D9B();\n  if ( v5 != v6 )\n  {\n    byte_80DB561 = 1;\n    format = \"%.0s%.0s%llu %3o %3o\\n\";\n    if ( (v19 & 2) == 0 )\n      format = \"%s %s differ: char %llu, line %u\\n\";\n    while ( v3 )\n    {\n      v7 = *(_DWORD *)(v5 + 16);\n      if ( v7 >= *(_DWORD *)(v5 + 24) )\n        __fgetc_unlocked();\n      else\n        *(_DWORD *)(v5 + 16) = v7 + 1;\n      LODWORD(v3) = (__PAIR64__(v3, HIDWORD(v3)) - 1) >> 32;\n      --HIDWORD(v3);\n    }\n    while ( v15 )\n    {\n      v8 = *(_DWORD *)(v6 + 16);\n      if ( v8 >= *(_DWORD *)(v6 + 24) )\n        __fgetc_unlocked();\n      else\n        *(_DWORD *)(v6 + 16) = v8 + 1;\n      --v15;\n    }\n    v9 = 1;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v10 = *(unsigned __int8 **)(v5 + 16);\n        if ( (unsigned int)v10 >= *(_DWORD *)(v5 + 24) )\n        {\n          v11 = __fgetc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(v5 + 16) = v10 + 1;\n          v11 = *v10;\n        }\n        v12 = *(unsigned __int8 **)(v6 + 16);\n        if ( (unsigned int)v12 >= *(_DWORD *)(v6 + 24) )\n        {\n          v21 = v11;\n          v13 = __fgetc_unlocked();\n          v11 = v21;\n        }\n        else\n        {\n          *(_DWORD *)(v6 + 16) = v12 + 1;\n          v13 = *v12;\n        }\n        ++v15;\n        if ( v11 != v13 )\n          break;\n        if ( v11 != 10 )\n          goto LABEL_43;\n        ++v9;\n      }\n      if ( v13 == -1 )\n        break;\n      if ( v11 == -1 )\n        goto LABEL_35;\nLABEL_36:\n      if ( (v19 & 1) != 0 )\n        goto LABEL_44;\n      if ( (v19 & 2) != 0 )\n        v9 = v11;\n      v23 = v11;\n      fprintf(stream, format, v17, v16, v15, v9, v13);\n      v11 = v23;\n      if ( !v19 )\n      {\nLABEL_44:\n        sub_804DD6F((_BYTE *)v5, v17);\n        sub_804DD6F((_BYTE *)v6, v16);\n        sub_80AB247(v15, HIDWORD(v15));\n      }\nLABEL_43:\n      if ( v11 == -1 )\n        goto LABEL_44;\n    }\n    v17 = v16;\n    v5 = v6;\nLABEL_35:\n    v22 = v13;\n    sub_804DD6F((_BYTE *)v5, v17);\n    stream = stderr;\n    sub_804DD8F();\n    v11 = -1;\n    format = \"cmp: EOF on %s\\n\";\n    v13 = v22;\n    goto LABEL_36;\n  }\n  return 0;\n}\n"
    ],
    "sub_809FDB8": [
        "0x809fdb8",
        "int __cdecl sub_809FDB8(_DWORD *a1, _DWORD *a2)\n{\n  int result; // eax\n\n  result = a1[2] - a2[2];\n  if ( !result )\n    return *a1 - *a2;\n  return result;\n}\n"
    ],
    "sub_809FDCD": [
        "0x809fdcd",
        "unsigned int __usercall sub_809FDCD@<eax>(unsigned int result@<eax>, _DWORD *a2@<edx>)\n{\n  if ( result )\n  {\n    if ( result <= 2 && ((dword_80DBB9C & 0x40) != 0 || result == 2) )\n      return printf(\"Files %s and %s differ\\n\", *a2, a2[1]);\n  }\n  else if ( (dword_80DBB9C & 0x100) != 0 )\n  {\n    return printf(\"Files %s and %s are identical\\n\", *a2, a2[1]);\n  }\n  return result;\n}\n"
    ],
    "sub_809FE0E": [
        "0x809fe0e",
        "int __userpurge sub_809FE0E@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3)\n{\n  const char *i; // esi\n  int v5; // eax\n  char **v6; // edi\n\n  for ( i = (const char *)(*a2 + a1); *i == 47; ++i )\n    ;\n  v5 = sub_80B4733(a2[2], 1030);\n  a2[3] = v5;\n  v6 = (char **)(v5 + 4 * a2[2]);\n  *v6 = sub_804DB46(i);\n  ++a2[2];\n  return 1;\n}\n"
    ],
    "sub_809FE4F": [
        "0x809fe4f",
        "int __userpurge sub_809FE4F@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3)\n{\n  int v3; // ebx\n  _BYTE *v4; // edx\n  _BYTE *v5; // esi\n  int v6; // ebp\n  void *v8; // [esp-8h] [ebp-78h]\n  __int16 v9; // [esp+10h] [ebp-60h]\n\n  if ( (dword_80DBB9C & 0x80) == 0 && a3 )\n  {\n    sub_809FE0E(a1, a2, a3);\n    return 2;\n  }\n  v3 = 1;\n  if ( (dword_80DBB9C & 0x20) == 0 )\n  {\n    v4 = (_BYTE *)(*a2 + a1);\n    if ( *v4 )\n    {\n      v5 = (_BYTE *)dword_80DBB80;\n      v8 = (void *)sub_804D2D1(*(_DWORD *)(dword_80DBB80 + 8), v4, (int)a2);\n      v6 = stat64();\n      free(v8);\n      if ( v6 || (v9 & 0xF000) != 0x4000 )\n      {\n        *v5 |= 1u;\n        return 2;\n      }\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_809FED1": [
        "0x809fed1",
        "int __usercall sub_809FED1@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  if ( *(_DWORD *)(result + 8) != a3 || *(_DWORD *)(result + 4) != a2 )\n  {\n    *(_DWORD *)(result + 4) = a2;\n    *(_DWORD *)(result + 8) = a3;\n    return fseeko64();\n  }\n  return result;\n}\n"
    ],
    "sub_809FEF5": [
        "0x809fef5",
        "unsigned int __usercall sub_809FEF5@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebx\n  unsigned __int8 *v4; // edx\n  int v5; // eax\n  _BOOL4 v6; // edx\n  int v7; // eax\n\n  v3 = a2;\n  BYTE1(v3) = BYTE1(a2) | 2;\n  while ( (v3 & 0x800) == 0 )\n  {\n    v4 = *(unsigned __int8 **)(*(_DWORD *)a1 + 16);\n    if ( (unsigned int)v4 < *(_DWORD *)(*(_DWORD *)a1 + 24) )\n    {\n      *(_DWORD *)(*(_DWORD *)a1 + 16) = v4 + 1;\n      v5 = *v4;\nLABEL_6:\n      ++*(_QWORD *)(a1 + 4);\n      v6 = (unsigned __int8)(v5 - 9) <= 4u || (_BYTE)v5 == 32;\n      goto LABEL_7;\n    }\n    v5 = __fgetc_unlocked();\n    v6 = 1;\n    if ( v5 != -1 )\n      goto LABEL_6;\nLABEL_7:\n    v3 |= v5 & 0xC00;\n    if ( v5 == 10 )\n      BYTE1(v3) |= 8u;\n    if ( (dword_80DBB9C & 8) != 0 && (unsigned int)(v5 - 65) <= 0x19 )\n      LOWORD(v5) = v5 + 32;\n    if ( (dword_80DBB9C & 0x2000) == 0 || !v6 )\n    {\n      v7 = v5 & 0x1FF;\n      if ( (dword_80DBB9C & 2) == 0 )\n        return v7 | v3 & 0xFFFFFC00;\n      if ( (v3 & 0x1000) == 0 )\n      {\n        if ( v6 )\n          v7 = 4128;\n        return v7 | v3 & 0xFFFFFC00;\n      }\n      if ( !v6 )\n      {\n        BYTE1(v3) &= ~0x10u;\n        return v7 | v3 & 0xFFFFFC00;\n      }\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_809FFB1": [
        "0x809ffb1",
        "_DWORD *__usercall sub_809FFB1@<eax>(int a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>)\n{\n  int i; // esi\n  _DWORD *v4; // edi\n  unsigned int v5; // ebx\n  int v6; // ebp\n  unsigned int v7; // eax\n  int v8; // edx\n  _DWORD *v9; // edi\n  int v10; // ecx\n  int v11; // eax\n  _DWORD *v12; // eax\n  int j; // edx\n  int v14; // ebx\n  int v15; // edx\n  char *v16; // ecx\n  int v17; // edx\n  int m; // ebp\n  int v19; // edx\n  signed int v20; // eax\n  signed int n; // ecx\n  int v22; // ebx\n  int v23; // esi\n  int v24; // edx\n  int v25; // eax\n  int v26; // ecx\n  unsigned int v27; // edi\n  int v28; // eax\n  _DWORD *v29; // ecx\n  int ii; // edx\n  _DWORD *v31; // ecx\n  _DWORD *v32; // eax\n  _DWORD *v33; // edx\n  int jj; // ecx\n  int kk; // edx\n  size_t v36; // edi\n  int v37; // edx\n  int v38; // eax\n  int v39; // esi\n  int v40; // ebx\n  unsigned int v41; // eax\n  _DWORD *v42; // esi\n  int v43; // ecx\n  int v44; // eax\n  char *v45; // eax\n  int v46; // edi\n  int v47; // ebx\n  int v48; // eax\n  int v49; // edx\n  int *v50; // eax\n  int mm; // eax\n  _DWORD *v52; // eax\n  int v53; // edx\n  int *v54; // ebx\n  int v55; // edi\n  int v56; // ebx\n  int *v59; // [esp+4h] [ebp-78h]\n  int k; // [esp+4h] [ebp-78h]\n  int v61; // [esp+4h] [ebp-78h]\n  int v62; // [esp+8h] [ebp-74h]\n  int v63; // [esp+8h] [ebp-74h]\n  int v64; // [esp+8h] [ebp-74h]\n  int ptr; // [esp+Ch] [ebp-70h]\n  void *ptra; // [esp+Ch] [ebp-70h]\n  int ptrb; // [esp+Ch] [ebp-70h]\n  int *ptrc; // [esp+Ch] [ebp-70h]\n  _DWORD *v69; // [esp+10h] [ebp-6Ch]\n  _DWORD *v70; // [esp+10h] [ebp-6Ch]\n  _DWORD *v71; // [esp+14h] [ebp-68h]\n  int v72; // [esp+14h] [ebp-68h]\n  int v73; // [esp+14h] [ebp-68h]\n  int v74; // [esp+18h] [ebp-64h]\n  int v75; // [esp+18h] [ebp-64h]\n  unsigned int v76; // [esp+1Ch] [ebp-60h]\n  int v77; // [esp+20h] [ebp-5Ch]\n  int v79; // [esp+28h] [ebp-54h]\n  char *v81; // [esp+38h] [ebp-44h]\n  _DWORD *v82; // [esp+3Ch] [ebp-40h]\n  int v83; // [esp+40h] [ebp-3Ch]\n  int v84; // [esp+40h] [ebp-3Ch]\n  unsigned int v85; // [esp+44h] [ebp-38h]\n  int v86; // [esp+48h] [ebp-34h]\n  int v87; // [esp+48h] [ebp-34h]\n  int *v88; // [esp+4Ch] [ebp-30h]\n  char *v89; // [esp+50h] [ebp-2Ch]\n  int v90[2]; // [esp+54h] [ebp-28h]\n  _DWORD *v91; // [esp+5Ch] [ebp-20h]\n  _DWORD *v92; // [esp+60h] [ebp-1Ch]\n  int v93[6]; // [esp+64h] [ebp-18h]\n\n  v62 = a1;\n  v59 = a2;\n  for ( i = 0; ; i = 1 )\n  {\n    v4 = sub_804DAFA(0x4D4u);\n    (&v91)[i] = v4;\n    *(_DWORD *)(v62 + 4) = 0;\n    *(_DWORD *)(v62 + 8) = 0;\n    fseeko64();\n    *v59 = 0;\n    *v4 = 0;\n    v4[1] = 0;\n    v5 = 100;\n    do\n    {\n      v6 = 0;\n      for ( ptr = 0; ; ptr = (ptr << 7) - (ptr - (v7 & 0x1FF)) )\n      {\n        v7 = sub_809FEF5(v62, v6);\n        v6 = v7;\n        if ( (v7 & 0x200) != 0 )\n          break;\n      }\n      v8 = (*v59)++;\n      if ( v8 == v5 )\n      {\n        v5 = (3 * v5) >> 1;\n        (&v91)[i] = sub_804DB13((&v91)[i], 12 * v5 + 36);\n      }\n      v9 = (&v91)[i];\n      v9[3 * *v59 + 2] = ptr & 0x7FFFFFFF;\n      v10 = *(_DWORD *)(v62 + 8);\n      v11 = 3 * *v59;\n      v9[v11] = *(_DWORD *)(v62 + 4);\n      v9[v11 + 1] = v10;\n    }\n    while ( (v6 & 0x400) == 0 );\n    if ( ++*(_QWORD *)&v9[3 * *v59] - *(_QWORD *)&v9[3 * *v59 - 3] == 1LL )\n      --*v59;\n    v12 = sub_804DAFA(8 * *v59 + 16);\n    a3[i] = v12;\n    ptra = (void *)*v59;\n    for ( j = 0; (int)ptra >= j; ++j )\n    {\n      v14 = v9[3 * j + 1];\n      v12[2 * j] = v9[3 * j];\n      v12[2 * j + 1] = v14;\n    }\n    v62 += 12;\n    ++v59;\n    if ( i == 1 )\n      break;\n  }\n  v15 = *a2;\n  v71 = v91;\n  v69 = v92;\n  for ( k = 0; v15 > k && a2[1] > k && v91[3 * k + 5] == v92[3 * k + 5]; ++k )\n    ;\n  v16 = (char *)&v91[3 * v15];\n  ptrb = 0;\n  v17 = v15 - k;\n  while ( v17 > ptrb && a2[1] - k > ptrb && *(_DWORD *)&v16[-12 * ptrb + 8] == v92[3 * (a2[1] - ptrb) + 2] )\n    ++ptrb;\n  for ( m = 0; ; m = 1 )\n  {\n    v19 = (int)&(&v91)[m][3 * k];\n    v93[m] = v19;\n    v20 = a2[m] - k - ptrb;\n    v90[m] = v20;\n    for ( n = 0; v20 >= n; ++n )\n      *(_DWORD *)(v19 + 12 * n) = n;\n    qsort((void *)(v19 + 12), v20, 0xCu, (__compar_fn_t)sub_809FDB8);\n    if ( m == 1 )\n      break;\n  }\n  v22 = v90[1];\n  v23 = v93[1];\n  v63 = v90[0];\n  v74 = v93[0];\n  v24 = 1;\n  v25 = 1;\n  while ( v63 >= v25 )\n  {\n    v26 = v74 + 12 * v25;\n    if ( v22 < v24 )\n    {\n      do\n      {\n        ++v25;\n        *(_DWORD *)(v74 + 12 * v25 - 4) = 0;\n      }\n      while ( v63 >= v25 );\n      break;\n    }\n    v27 = *(_DWORD *)(v23 + 12 * v24 + 8);\n    if ( *(_DWORD *)(v26 + 8) >= v27 )\n    {\n      if ( *(_DWORD *)(v26 + 8) == v27 )\n      {\n        ++v25;\n        *(_DWORD *)(v26 + 8) = v24;\n      }\n      else\n      {\n        ++v24;\n      }\n    }\n    else\n    {\n      ++v25;\n      *(_DWORD *)(v26 + 8) = 0;\n    }\n  }\n  *(_DWORD *)(v23 + 12 * (v22 + 1) + 8) = 0;\n  v28 = 0;\n  while ( 1 )\n  {\n    v29 = &v69[++v28];\n    if ( v22 < v28 )\n      break;\n    *v29 = -*(_DWORD *)(v23 + 12 * v28);\n    for ( ii = v23 + 12 * v28 + 8; ; v69[++v28] = *(_DWORD *)(ii - 8) )\n    {\n      v31 = (_DWORD *)ii;\n      ii += 12;\n      if ( v31[3] != *v31 )\n        break;\n    }\n  }\n  *v29 = -1;\n  v81 = (char *)sub_804DB13(v69, 4 * v22 + 8);\n  v32 = sub_804DAFA(4 * v63 + 4);\n  v33 = (_DWORD *)(v74 + 12);\n  for ( jj = 1; v63 >= jj; ++jj )\n  {\n    v32[*v33] = v33[2];\n    v33 += 3;\n  }\n  for ( kk = 1; v63 >= kk; ++kk )\n    v71[kk] = v32[kk];\n  free(v32);\n  v36 = 4 * v63 + 8;\n  v82 = sub_804DB13(v71, v36);\n  v70 = sub_804DAFA(4 * *a2 + 8);\n  v37 = *a2;\n  v72 = a2[1] - *a2;\n  v38 = 0;\n  v39 = *a2 - ptrb;\n  while ( v37 >= v38 )\n  {\n    v40 = v38;\n    if ( k < v38 )\n    {\n      v40 = 0;\n      if ( v39 < v38 )\n        v40 = v72 + v38;\n    }\n    v70[v38++] = v40;\n  }\n  v41 = sub_80AD876();\n  v76 = -1;\n  if ( (dword_80DBB9C & 4) == 0 )\n  {\n    v76 = v41;\n    if ( v41 < 0x100 )\n      v76 = 256;\n  }\n  v42 = sub_804DB2E(0x4B0u);\n  ptrc = (int *)sub_804DB2E(v36);\n  v43 = 1;\n  v77 = 1;\n  v73 = 0;\n  v79 = 100;\nLABEL_62:\n  if ( v63 >= v77 )\n  {\n    v44 = v82[v77];\n    if ( !v44 )\n      goto LABEL_85;\n    v45 = &v81[4 * v44];\n    v46 = -*(_DWORD *)v45;\n    v75 = *ptrc;\n    v89 = v45;\n    v85 = 0;\n    v83 = 0;\n    while ( 1 )\n    {\n      if ( v42[3 * v75 + 1] < v46 )\n      {\n        v47 = v73 + 1;\n        if ( v46 <= v42[3 * ptrc[v73] + 1] )\n        {\n          v86 = v73 + 1;\n          v48 = 0;\n          while ( 1 )\n          {\n            v47 = (v48 + v86) >> 1;\n            if ( v47 <= v48 )\n              break;\n            v49 = 3 * ptrc[v47];\n            if ( v46 >= v42[v49 + 1] )\n            {\n              v48 = (v48 + v86) >> 1;\n              if ( v46 <= v42[v49 + 1] )\n                goto LABEL_74;\n            }\n            else\n            {\n              v86 = (v48 + v86) >> 1;\n            }\n          }\n          ++v47;\n        }\nLABEL_74:\n        if ( v83 + 1 != v47 )\n          v75 = ptrc[v47 - 1];\n        v88 = &ptrc[v47];\n        v87 = *v88;\n        if ( v73 < v47 || v46 < v42[3 * *v88 + 1] )\n        {\n          if ( v43 == v79 )\n          {\n            v84 = v43;\n            v79 = 11 * v43 / 10;\n            v42 = sub_804DB13(v42, 12 * v79);\n            v43 = v84;\n          }\n          v50 = &v42[3 * v43];\n          *v50 = v77;\n          v50[1] = v46;\n          v50[2] = v75;\n          *v88 = v43;\n          if ( v73 < v47 )\n          {\n            ++v73;\n            ++v43;\nLABEL_85:\n            ++v77;\n            goto LABEL_62;\n          }\n          ++v85;\n          v75 = v87;\n          v83 = v47;\n          ++v43;\n        }\n      }\n      v46 = *((_DWORD *)v89 + 1);\n      v89 += 4;\n      if ( v46 <= 0 || v85 >= v76 )\n        goto LABEL_85;\n    }\n  }\n  for ( mm = 3 * ptrc[v73]; ; mm = 3 * v52[2] )\n  {\n    v52 = &v42[mm];\n    v53 = v52[1];\n    if ( !v53 )\n      break;\n    v70[*v52 + k] = k + v53;\n  }\n  free(ptrc);\n  free(v42);\n  v70[*a2 + 1] = a2[1] + 1;\n  free(v82);\n  free(v81);\n  while ( *a2 >= m )\n  {\n    v61 = m;\n    v54 = &v70[m];\n    if ( *v54 )\n    {\n      sub_809FED1(a1, *(_DWORD *)(*a3 + 8 * m - 8), *(_DWORD *)(*a3 + 8 * m - 4));\n      sub_809FED1(a1 + 12, *(_DWORD *)(a3[1] + 8 * *v54 - 8), *(_DWORD *)(a3[1] + 8 * *v54 - 4));\n      v64 = *v54;\n      while ( *a2 >= m && v70[m] == m + v64 - v61 )\n      {\n        v55 = 0;\n        v56 = 0;\n        do\n        {\n          v56 = sub_809FEF5(a1, v56);\n          v55 = sub_809FEF5(a1 + 12, v55);\n          if ( (((unsigned __int16)v55 ^ (unsigned __int16)v56) & 0x200) != 0\n            || (v56 & 0x200) == 0 && (((unsigned __int16)v55 ^ (unsigned __int16)v56) & 0x1FF) != 0 )\n          {\n            v70[m] = 0;\n          }\n        }\n        while ( (v55 & v56 & 0x200) == 0 );\n        ++m;\n      }\n    }\n    ++m;\n  }\n  return v70;\n}\n"
    ],
    "sub_80A06D0": [
        "0x80a06d0",
        "int __usercall sub_80A06D0@<eax>(__int64 a1@<edx:eax>, int a2@<ecx>, char *s, int a4)\n{\n  int v4; // edi\n  int v5; // ebp\n  _QWORD *v6; // ebx\n  _BYTE *v7; // edx\n  _BYTE *v8; // edx\n  unsigned __int8 *v9; // edx\n  int v10; // eax\n  _BYTE *v11; // edx\n  _BYTE *v12; // ecx\n  int v14; // [esp+0h] [ebp-24h]\n  __int64 v15; // [esp+4h] [ebp-20h]\n\n  v4 = a1;\n  v5 = a2;\n  LODWORD(a1) = a4;\n  v6 = (_QWORD *)(HIDWORD(a1) + 8 * a2);\n  while ( v5 <= (int)s )\n  {\n    sub_809FED1(v4, *((_DWORD *)v6 - 2), *((_DWORD *)v6 - 1));\n    v7 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v7 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v7 + 1;\n      *v7 = a4;\n    }\n    if ( (dword_80DBB9C & 0x800) != 0 )\n    {\n      v8 = *(_BYTE **)(_stdout + 16);\n      if ( (unsigned int)v8 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked();\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v8 + 1;\n        *v8 = 9;\n      }\n    }\n    v15 = 0LL;\n    v14 = 0;\n    while ( 1 )\n    {\n      a1 = *v6 - *(v6 - 1);\n      if ( v15 >= a1 )\n        break;\n      v9 = *(unsigned __int8 **)(*(_DWORD *)v4 + 16);\n      if ( (unsigned int)v9 >= *(_DWORD *)(*(_DWORD *)v4 + 24) )\n      {\n        v10 = __fgetc_unlocked();\n        if ( v10 == -1 )\n        {\n          LODWORD(a1) = puts(\"\\n\\\\ No newline at end of file\");\n          return a1;\n        }\n      }\n      else\n      {\n        *(_DWORD *)(*(_DWORD *)v4 + 16) = v9 + 1;\n        v10 = *v9;\n      }\n      ++*(_QWORD *)(v4 + 4);\n      if ( v10 == 9 && (dword_80DBB9C & 0x400) != 0 )\n      {\n        do\n        {\n          v11 = *(_BYTE **)(_stdout + 16);\n          if ( (unsigned int)v11 >= *(_DWORD *)(_stdout + 28) )\n          {\n            __fputc_unlocked();\n          }\n          else\n          {\n            *(_DWORD *)(_stdout + 16) = v11 + 1;\n            *v11 = 32;\n          }\n          ++v14;\n        }\n        while ( (v14 & 7) != 0 );\n      }\n      else\n      {\n        v12 = *(_BYTE **)(_stdout + 16);\n        if ( (unsigned int)v12 >= *(_DWORD *)(_stdout + 28) )\n        {\n          __fputc_unlocked();\n        }\n        else\n        {\n          *(_DWORD *)(_stdout + 16) = v12 + 1;\n          *v12 = v10;\n        }\n        ++v14;\n      }\n      ++v15;\n    }\n    ++v5;\n    ++v6;\n  }\n  return a1;\n}\n"
    ],
    "sub_80A084B": [
        "0x80a084b",
        "int __usercall sub_80A084B@<eax>(const char **a1@<eax>)\n{\n  const char *v1; // eax\n  int v2; // edx\n  int v3; // ecx\n  int v4; // ebx\n  int v5; // eax\n  int v6; // edx\n  int v7; // esi\n  char v8; // bl\n  FILE *v9; // ebp\n  signed int v10; // esi\n  FILE *v11; // edi\n  signed int v12; // eax\n  signed int j; // esi\n  char v14; // cl\n  char v15; // dl\n  int v16; // edi\n  _DWORD *v17; // ecx\n  char k; // bl\n  int v19; // eax\n  _DWORD *v20; // ebp\n  int v21; // edx\n  int v22; // ebx\n  char m; // cl\n  int v24; // edi\n  int v25; // ecx\n  char *v26; // esi\n  int n; // eax\n  int v28; // ecx\n  const char *v29; // eax\n  const char *v30; // eax\n  char *v31; // ebp\n  int ii; // edi\n  int v33; // ebx\n  int v34; // esi\n  int v35; // ebx\n  int v36; // edx\n  int v37; // eax\n  int v38; // ecx\n  char *jj; // ebx\n  int v40; // eax\n  __int64 v41; // rax\n  __int64 v42; // rax\n  __int64 v43; // rax\n  int v44; // edx\n  int v45; // ecx\n  char *v47; // [esp-8h] [ebp-7Ch]\n  char *ptr; // [esp+0h] [ebp-74h]\n  int v49; // [esp+4h] [ebp-70h]\n  int i; // [esp+8h] [ebp-6Ch]\n  int v51; // [esp+Ch] [ebp-68h]\n  int v52; // [esp+Ch] [ebp-68h]\n  _DWORD *v53; // [esp+10h] [ebp-64h]\n  char v54; // [esp+14h] [ebp-60h]\n  char v56; // [esp+1Dh] [ebp-57h]\n  char v57; // [esp+1Eh] [ebp-56h]\n  char v58; // [esp+1Fh] [ebp-55h]\n  FILE *stream; // [esp+24h] [ebp-50h]\n  FILE *v60; // [esp+28h] [ebp-4Ch]\n  int v61[2]; // [esp+2Ch] [ebp-48h] BYREF\n  void *v62; // [esp+34h] [ebp-40h] BYREF\n  void *v63; // [esp+38h] [ebp-3Ch]\n  int v64[4]; // [esp+3Ch] [ebp-38h] BYREF\n  char name[40]; // [esp+4Ch] [ebp-28h] BYREF\n\n  stream = stdin;\n  v60 = stdin;\n  for ( i = 0; ; i = 1 )\n  {\n    v1 = a1[i];\n    if ( *v1 == 45 && !v1[1] )\n    {\n      v4 = 0;\n    }\n    else if ( (dword_80DBB9C & 0x20) != 0 )\n    {\n      v4 = open64();\n      if ( v4 == -1 )\n        v4 = sub_804DBE1(\"/dev/null\");\n    }\n    else\n    {\n      v4 = sub_804DC14(v1);\n      if ( v4 == -1 )\n        goto LABEL_6;\n    }\n    v5 = lseek64();\n    if ( v6 == -1 && v5 == -1 && *(_DWORD *)dword_80DBB7C == 29 )\n    {\n      strcpy(name, \"/tmp/difXXXXXX\");\n      v7 = sub_804DD54(name);\n      unlink(name);\n      if ( (((unsigned __int64)sub_804E572(v4, v7) >> 32) & 0x80000000) != 0LL )\n        sub_804D604();\n      if ( v4 )\n        close(v4);\n      sub_804DD09(0, 0, 0);\n      v4 = v7;\n    }\n    *(&stream + i) = fdopen(v4, \"r\");\n    if ( i == 1 )\n      break;\n  }\n  v56 = 0;\n  v8 = 0;\nLABEL_21:\n  v9 = stream;\n  v10 = fread(&qword_80DB778, 1u, 0x200u, stream);\n  v11 = v60;\n  v12 = fread(&dword_80DB978, 1u, 0x200u, v60);\n  if ( v10 != v12 )\n  {\n    if ( v12 > v10 )\n      v12 = v10;\n    v56 = 1;\n  }\n  if ( v12 )\n  {\n    for ( j = 0; ; ++j )\n    {\n      if ( v12 <= j )\n        goto LABEL_21;\n      v14 = *((_BYTE *)&qword_80DB778 + j);\n      v15 = *((_BYTE *)&dword_80DB978 + j);\n      if ( v14 )\n      {\n        if ( !v15 )\n        {\n          v8 = 1;\nLABEL_35:\n          v56 = 1;\n          continue;\n        }\n      }\n      else\n      {\n        v8 = 1;\n      }\n      if ( v14 != v15 )\n        goto LABEL_35;\n    }\n  }\n  if ( v56 )\n  {\n    if ( v8 && (dword_80DBB9C & 1) == 0 )\n    {\n      i = 2;\nLABEL_101:\n      *(_BYTE *)dword_80DBB80 |= 1u;\n      goto LABEL_102;\n    }\n    *(_DWORD *)name = v9;\n    *(_DWORD *)&name[12] = v11;\n    v53 = sub_809FFB1((int)name, v61, &v62);\n    v51 = 1;\n    v57 = 0;\n    ptr = 0;\n    do\n    {\n      v58 = 0;\n      v49 = -1;\n      while ( 1 )\n      {\n        v64[0] = v51;\n        v16 = v51;\n        v17 = &v53[v51];\n        for ( k = 0; ; k = v56 )\n        {\n          v19 = v16;\n          v20 = v17;\n          v21 = *(v17 - 1) + 1;\n          if ( v61[0] < v16 )\n            break;\n          ++v16;\n          ++v17;\n          if ( *v20 != v21 )\n            break;\n        }\n        if ( k )\n          v64[0] = v19;\n        v64[2] = v21;\n        v22 = v19 - 1;\n        v64[1] = v19 - 1;\n        for ( m = 0; ; m = v56 )\n        {\n          v24 = v53[v22 + 1];\n          if ( v61[0] <= v22 || v24 )\n            break;\n          ++v22;\n        }\n        if ( m )\n          v64[1] = v22;\n        v64[3] = v24 - 1;\n        if ( v24 - 1 >= v21 || v22 >= v19 )\n        {\n          v25 = 2 * *(_DWORD *)(dword_80DBB80 + 4) + 1;\n          if ( v49 != -1 )\n          {\n            v26 = &ptr[16 * v49];\n            if ( v25 + *((_DWORD *)v26 + 1) < v19 && *((_DWORD *)v26 + 3) + v25 < v21 )\n              goto LABEL_69;\n          }\n          for ( n = 0; ; n = 1 )\n          {\n            v52 = v64[2 * n];\n            v28 = 8 * v52;\n            while ( v52 <= v64[2 * n + 1] )\n            {\n              v58 |= *(_QWORD *)((char *)*(&v62 + n) + v28) - *(_QWORD *)((char *)*(&v62 + n) + v28 - 8) != 1LL;\n              ++v52;\n              v28 += 8;\n            }\n            if ( n == 1 )\n              break;\n          }\n          ptr = (char *)sub_80B4733(++v49, 4102);\n          qmemcpy(&ptr[16 * v49], v64, 0x10u);\n        }\n        v51 = v22 + 1;\n        if ( v22 + 1 > v61[0] )\n          break;\n        v53[v22] = v24 - 1;\n      }\n      if ( v49 == -1 )\n        continue;\nLABEL_69:\n      v54 = v58 | (BYTE2(dword_80DBB9C) ^ 1) & 1;\n      if ( v54 )\n      {\n        if ( (dword_80DBB9C & 0x40) == 0 )\n        {\n          if ( !v57 )\n          {\n            v29 = *(const char **)(dword_80DBB80 + 12);\n            if ( !v29 )\n              v29 = *a1;\n            printf(\"--- %s\\n\", v29);\n            v30 = *(const char **)(dword_80DBB80 + 16);\n            if ( !v30 )\n              v30 = a1[1];\n            printf(\"+++ %s\\n\", v30);\n          }\n          printf(\"@@\");\n          v31 = &ptr[16 * v49];\n          for ( ii = 0; ; ii = 1 )\n          {\n            v33 = *(_DWORD *)(dword_80DBB80 + 4);\n            v34 = *(_DWORD *)&ptr[8 * ii] - v33;\n            if ( v34 <= 0 )\n              v34 = 1;\n            v64[2 * ii] = v34;\n            v35 = *(_DWORD *)&v31[8 * ii + 4] + v33;\n            if ( v35 > v61[ii] )\n              v35 = v61[ii];\n            v64[2 * ii + 1] = v35;\n            v36 = v34;\n            if ( v34 > v35 )\n              v36 = v35;\n            printf(\" %c%d\", ii == 0 ? 45 : 43, v36);\n            if ( v34 != v35 )\n            {\n              v37 = 0;\n              if ( v34 < v35 )\n                v37 = v35 - v34 + 1;\n              printf(\",%d\", v37);\n            }\n            if ( ii == 1 )\n              break;\n          }\n          puts(\" @@\");\n          v38 = v64[0];\n          for ( jj = ptr; ; v38 = *((_DWORD *)jj - 3) + 1 )\n          {\n            v40 = v31 >= jj ? *(_DWORD *)jj - 1 : v64[1];\n            v47 = (char *)v40;\n            HIDWORD(v41) = v62;\n            LODWORD(v41) = name;\n            sub_80A06D0(v41, v38, v47, 32);\n            if ( v31 < jj )\n              break;\n            HIDWORD(v42) = v62;\n            LODWORD(v42) = name;\n            sub_80A06D0(v42, *(_DWORD *)jj, *((char **)jj + 1), 45);\n            HIDWORD(v43) = v63;\n            LODWORD(v43) = &name[12];\n            sub_80A06D0(v43, *((_DWORD *)jj + 2), *((char **)jj + 3), 43);\n            jj += 16;\n          }\n        }\n        v57 = v54;\n      }\n    }\n    while ( v61[0] >= v51 );\n    free(ptr);\n    free(v62);\n    free(v63);\n    free(v53);\n    if ( v57 )\n      goto LABEL_101;\n  }\nLABEL_6:\n  i = 0;\nLABEL_102:\n  sub_80AB218(v3, v2);\n  sub_80AB218(v45, v44);\n  return i;\n}\n"
    ],
    "sub_80A0D7C": [
        "0x80a0d7c",
        "int __cdecl sub_80A0D7C(int a1, int a2)\n{\n  _DWORD *v2; // esi\n  int v3; // ebx\n  _BOOL4 v4; // ebp\n  int v5; // edi\n  int v6; // ebp\n  const char *v7; // eax\n  _DWORD *v8; // esi\n  int result; // eax\n  int v10; // eax\n  char *v11; // ebp\n  const char **v12; // edi\n  char *v13; // ebx\n  int v14; // ecx\n  void *v15; // esi\n  char *v16; // ebx\n  char *v17; // esi\n  int v18; // ebx\n  int v19; // edi\n  bool v20; // al\n  int v21; // ebx\n  char *v22; // ebp\n  int v23; // eax\n  int v24; // ecx\n  int v25; // eax\n  int v26; // edx\n  int v27; // eax\n  bool v28; // bl\n  char *v29; // eax\n  char *v30; // edx\n  char *v31; // eax\n  int v32; // eax\n  int v33; // [esp+8h] [ebp-64h]\n  int v34; // [esp+10h] [ebp-5Ch]\n  void *v35; // [esp+10h] [ebp-5Ch]\n  const char *v36; // [esp+10h] [ebp-5Ch]\n  char *v37; // [esp+14h] [ebp-58h] BYREF\n  int v38; // [esp+18h] [ebp-54h] BYREF\n  char *v39; // [esp+1Ch] [ebp-50h] BYREF\n  char *v40; // [esp+20h] [ebp-4Ch]\n  char *v41[2]; // [esp+24h] [ebp-48h]\n  char *v42; // [esp+2Ch] [ebp-40h] BYREF\n  char *s; // [esp+30h] [ebp-3Ch]\n  char *v44; // [esp+34h] [ebp-38h] BYREF\n  void *ptr; // [esp+38h] [ebp-34h]\n  void *v46[12]; // [esp+3Ch] [ebp-30h] BYREF\n\n  v37 = 0;\n  v38 = 0;\n  v2 = sub_804DB2E(0xD4u);\n  dword_80DBB80 = (int)v2;\n  v2[1] = 3;\n  sub_80ABEAC(a2, \"^abdiL:*NqrsS:tTU:+wupBE\", &v38, &v37, v2 + 1);\n  v3 = 4 * optind;\n  while ( v38 )\n  {\n    v4 = v2[3] != 0;\n    v2[v4 + 3] = sub_80AFB01(v34);\n  }\n  byte_80DB560 = 2;\n  v5 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    v7 = *(const char **)(v3 + a2 + 4 * v5);\n    (&v39)[v5] = (char *)v7;\n    v8 = (_DWORD *)dword_80DBB80;\n    if ( *v7 == 45 && !v7[1] )\n    {\n      fstat64();\n      ++v6;\n      goto LABEL_12;\n    }\n    if ( (dword_80DBB9C & 0x20) != 0 )\n    {\n      v34 = dword_80DBB80 + 96 * v5 + 20;\n      if ( !stat64() )\n        goto LABEL_12;\n      v7 = \"/dev/null\";\n    }\n    sub_804DFF3(v7);\nLABEL_12:\n    if ( v5 == 1 )\n      break;\n    v5 = 1;\n  }\n  byte_80DB560 = 1;\n  if ( v6 && ((v8[9] & 0xF000) == 0x4000 || (v8[33] & 0xF000) == 0x4000) )\n    sub_804D5E0(\"can't compare stdin to a directory\", v34);\n  if ( v8[28] != v8[52]\n    || v8[27] != v8[51]\n    || v8[6] != v8[30]\n    || v8[5] != v8[29]\n    || v8[17] != v8[41]\n    || v8[16] != v8[40]\n    || v8[23] != v8[47]\n    || v8[25] != v8[49]\n    || v8[9] != v8[33]\n    || v8[10] != v8[34]\n    || v8[11] != v8[35]\n    || (result = 0, v8[12] != v8[36]) )\n  {\n    v10 = v8[33] & 0xF000;\n    if ( (v8[9] & 0xF000) == 0x4000 )\n    {\n      if ( v10 == 0x4000 )\n      {\n        v11 = v37;\n        memset(v46, 0, 0x20u);\n        v8[2] = v40;\n        v46[0] = (void *)strlen(v39);\n        sub_80B2549(sub_809FE0E, 3, sub_809FE4F, v46, 0);\n        sub_80A9A96(v34);\n        if ( v11 )\n        {\n          v35 = v46[2];\n          v12 = (const char **)v46[3];\n          while ( 1 )\n          {\n            v13 = (char *)v46[1];\n            if ( (int)v46[1] >= (int)v35 || strcmp(v12[(int)v46[1]], v11) >= 0 )\n              break;\n            v46[1] = v13 + 1;\n          }\n        }\n        v8[2] = v39;\n        v46[4] = (void *)strlen(v40);\n        sub_80B2549(sub_809FE0E, 3, sub_809FE4F, &v46[4], 0);\n        sub_80A9A96(v35);\n        if ( v11 )\n        {\n          v15 = v46[6];\n          while ( 1 )\n          {\n            v16 = (char *)v46[5];\n            if ( (int)v46[5] >= (int)v15 || strcmp(*((const char **)v46[7] + (int)v46[5]), v11) >= 0 )\n              break;\n            v46[5] = v16 + 1;\n          }\n        }\n        while ( 2 )\n        {\n          v22 = 0;\n          if ( (int)v46[1] < (int)v46[2] )\n            v22 = (char *)*((_DWORD *)v46[3] + (int)v46[1]);\n          v41[0] = v22;\n          v17 = 0;\n          if ( (int)v46[5] < (int)v46[6] )\n            v17 = (char *)*((_DWORD *)v46[7] + (int)v46[5]);\n          v41[1] = v17;\n          if ( !v22 )\n          {\n            if ( !v17 )\n              return *(char *)dword_80DBB80;\n            v18 = 1;\n            v19 = 1;\n            v20 = 1;\n            goto LABEL_47;\n          }\n          if ( !v17 )\n          {\n            v18 = 0;\n            v19 = -1;\n            v20 = 0;\n            goto LABEL_47;\n          }\n          v23 = strcmp(v22, v17);\n          v14 = v33;\n          v19 = v23;\n          v20 = v23 > 0;\n          v18 = v20;\n          if ( v19 )\n          {\nLABEL_47:\n            if ( (dword_80DBB9C & 0x20) == 0 )\n            {\n              printf(\"Only in %s: %s\\n\", (&v39)[v20], v41[v18]);\n              *(_BYTE *)dword_80DBB80 |= 1u;\n              goto LABEL_49;\n            }\n            if ( v18 )\n            {\n              v42 = (char *)sub_804D2D1((int)v39, v17, v14);\n              v44 = \"/dev/null\";\nLABEL_61:\n              s = (char *)sub_804D2D1((int)v40, v17, v24);\n              ptr = s;\n              stat64();\n              if ( !v19 )\n              {\nLABEL_66:\n                v25 = *(_DWORD *)(dword_80DBB80 + 36) & 0xF000;\n                if ( v25 == 0x4000 )\n                {\n                  if ( (*(_DWORD *)(dword_80DBB80 + 132) & 0xF000) == 0x4000 )\n                  {\n                    printf(\"Common subdirectories: %s and %s\\n\", v42, s);\nLABEL_76:\n                    free(v42);\n                    free(s);\nLABEL_49:\n                    free(v41[v18]);\n                    v46[4 * v18 + 1] = (char *)v46[4 * v18 + 1] + 1;\n                    if ( !v19 )\n                    {\n                      v21 = 1 - v18;\n                      free(v41[v21]);\n                      v46[4 * v21 + 1] = (char *)v46[4 * v21 + 1] + 1;\n                    }\n                    continue;\n                  }\n                }\n                else if ( v25 != 0x8000 )\n                {\n                  printf(\"File %s is not a regular file or directory and was skipped\\n\", v42);\n                  goto LABEL_76;\n                }\n                v26 = *(_DWORD *)(dword_80DBB80 + 132) & 0xF000;\n                if ( ((v26 - 0x4000) & 0xFFFFB000) != 0 )\n                {\n                  printf(\"File %s is not a regular file or directory and was skipped\\n\", s);\n                }\n                else if ( (v25 == 0x4000) == (v26 == 0x4000) )\n                {\n                  v27 = sub_80A084B((const char **)&v44);\n                  sub_809FDCD(v27, &v42);\n                }\n                else if ( v25 == 0x4000 )\n                {\n                  printf(\"File %s is a %s while file %s is a %s\\n\", v42, \"directory\", s, \"regular file\");\n                }\n                else\n                {\n                  printf(\"File %s is a %s while file %s is a %s\\n\", v42, \"regular file\", s, \"directory\");\n                }\n                goto LABEL_76;\n              }\nLABEL_65:\n              stat64();\n              goto LABEL_66;\n            }\n          }\n          break;\n        }\n        v42 = (char *)sub_804D2D1((int)v39, v22, v14);\n        v44 = v42;\n        stat64();\n        if ( !v19 )\n          goto LABEL_61;\n        if ( v18 == 1 )\n        {\n          s = (char *)sub_804D2D1((int)v40, v17, v24);\n          ptr = s;\n          stat64();\n        }\n        else\n        {\n          s = (char *)sub_804D2D1((int)v40, v22, v24);\n          ptr = (void *)\"/dev/null\";\n        }\n        goto LABEL_65;\n      }\n      v28 = 0;\nLABEL_80:\n      v36 = (&v39)[v10 != 0x4000];\n      v29 = strrchr(v36, 47);\n      v30 = (char *)v36;\n      if ( v29 )\n        v30 = v29 + 1;\n      v31 = (char *)sub_804D2D1((int)(&v39)[v28], v30, v28);\n      (&v39)[v28] = v31;\n      sub_804DFF3(v31);\n      if ( v6 > 1 )\n      {\n        sub_809FDCD(0, &v39);\nLABEL_87:\n        free((&v39)[v28]);\n      }\n      else\n      {\nLABEL_86:\n        v32 = sub_80A084B((const char **)&v39);\n        sub_809FDCD(v32, &v39);\n        if ( v5 )\n          goto LABEL_87;\n      }\n    }\n    else\n    {\n      v28 = v10 == 0x4000;\n      if ( v10 == 0x4000 )\n        goto LABEL_80;\n      if ( v6 <= 1 )\n      {\n        v5 = 0;\n        goto LABEL_86;\n      }\n      sub_809FDCD(0, &v39);\n    }\n    return *(char *)dword_80DBB80;\n  }\n  return result;\n}\n"
    ],
    "sub_80A13A3": [
        "0x80a13a3",
        "_DWORD *__usercall sub_80A13A3@<eax>(int *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *result; // eax\n  int v5; // edx\n  _DWORD *v6; // ecx\n\n  result = sub_804DAFA(0xCu);\n  result[2] = a2;\n  v5 = *a1;\n  if ( *a1 )\n  {\n    *result = v5;\n    v6 = *(_DWORD **)(v5 + 4);\n    result[1] = v6;\n    *v6 = result;\n    *(_DWORD *)(v5 + 4) = result;\n  }\n  else\n  {\n    result[1] = result;\n    *result = result;\n    *a1 = (int)result;\n  }\n  return result;\n}\n"
    ],
    "sub_80A13D5": [
        "0x80a13d5",
        "void __cdecl sub_80A13D5(void **ptr)\n{\n  int v1; // eax\n\n  v1 = *(_DWORD *)(dword_80DBB80 + 36);\n  if ( v1 > 1 && v1 != *(unsigned __int8 *)ptr[2] )\n    dprintf();\n  free(ptr[2]);\n  free(ptr);\n}\n"
    ],
    "sub_80A142C": [
        "0x80a142c",
        "void sub_80A142C()\n{\n  int v0; // ebx\n  int v1; // eax\n  const char *v2; // eax\n  char *v3; // esi\n\n  v0 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 52) )\n  {\n    v1 = *(_DWORD *)(dword_80DBB80 + 44);\n    if ( v1 != -1 )\n    {\n      sub_804E572(v1, *(_DWORD *)(dword_80DBB80 + 48));\n      sub_804DCF3(*(_DWORD *)(v0 + 44));\n    }\n    sub_804DCF3(*(_DWORD *)(v0 + 48));\n    v2 = *(const char **)(v0 + 52);\n    if ( *v2 )\n    {\n      v3 = sub_804DB46(v2);\n      v3[strlen(v3) - 6] = 0;\n      rename(*(const char **)(v0 + 52), v3);\n      free(v3);\n      free(*(void **)(v0 + 52));\n    }\n    *(_DWORD *)(v0 + 52) = 0;\n  }\n  *(_DWORD *)(v0 + 44) = -1;\n  *(_DWORD *)(v0 + 48) = -1;\n}\n"
    ],
    "sub_80A14A8": [
        "0x80a14a8",
        "void **__usercall sub_80A14A8@<eax>(void **result@<eax>)\n{\n  void **i; // ebx\n  void **v2; // esi\n  void **v3; // [esp-4h] [ebp-Ch]\n\n  for ( i = result; i; i = v2 )\n  {\n    v2 = (void **)*i;\n    sub_80A13D5(i);\n    result = v3;\n    if ( i == v2 )\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_80A14C4": [
        "0x80a14c4",
        "_BYTE *sub_80A14C4()\n{\n  int v0; // ebx\n  int v1; // eax\n  _BYTE *result; // eax\n  _BYTE *v3; // [esp-8h] [ebp-Ch]\n\n  v0 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 8) )\n  {\n    dprintf();\n    *(_DWORD *)(v0 + 56) = 1;\n    *(_DWORD *)(v0 + 36) = 2;\n    v1 = *(_DWORD *)(v0 + 8);\n    **(_DWORD **)(v1 + 4) = 0;\n    sub_80A14A8((void **)v1);\n    *(_DWORD *)(v0 + 8) = 0;\n    close(*(_DWORD *)(v0 + 44));\n    close(*(_DWORD *)(v0 + 48));\n    result = *(_BYTE **)(v0 + 52);\n    if ( *result )\n    {\n      unlink(*(const char **)(v0 + 52));\n      free(*(void **)(v0 + 52));\n      result = v3;\n    }\n    *(_DWORD *)(v0 + 52) = 0;\n    *(_DWORD *)(v0 + 36) = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80A1547": [
        "0x80a1547",
        "int __cdecl sub_80A1547(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // edx\n  int v4; // eax\n  int v5; // ebp\n  char *v6; // eax\n  char *v7; // ebx\n  int v8; // esi\n  char v9; // al\n  int *v10; // ebx\n  int **v11; // edx\n  int v12; // eax\n  bool v13; // zf\n  int v14; // edi\n  const char *v15; // edx\n  int v16; // ebp\n  int v17; // eax\n  int v18; // eax\n  _DWORD *v19; // ebp\n  int v20; // eax\n  _DWORD *v21; // eax\n  _DWORD *v22; // edx\n  _DWORD *v23; // ecx\n  void **v24; // eax\n  void **v25; // edi\n  char *i; // esi\n  char v27; // al\n  const char *v28; // eax\n  int v29; // ebx\n  char *v30; // edi\n  int v31; // eax\n  char *v32; // edx\n  const char *v33; // ebx\n  int v34; // eax\n  char *v35; // eax\n  char *v36; // eax\n  int v38; // [esp+0h] [ebp-ACh]\n  int v39; // [esp+0h] [ebp-ACh]\n  int v40; // [esp+4h] [ebp-A8h]\n  __int16 v41; // [esp+Ch] [ebp-A0h]\n  const char **v42; // [esp+10h] [ebp-9Ch]\n  int v43; // [esp+14h] [ebp-98h]\n  _BOOL4 v44; // [esp+18h] [ebp-94h]\n  int v45; // [esp+18h] [ebp-94h]\n  char **p_s1; // [esp+1Ch] [ebp-90h]\n  int v47; // [esp+20h] [ebp-8Ch]\n  int v48; // [esp+20h] [ebp-8Ch]\n  void *v49; // [esp+20h] [ebp-8Ch]\n  const char *v50; // [esp+24h] [ebp-88h]\n  char *s1; // [esp+28h] [ebp-84h] BYREF\n  char *v52; // [esp+2Ch] [ebp-80h] BYREF\n  int v53; // [esp+30h] [ebp-7Ch] BYREF\n  int v54; // [esp+34h] [ebp-78h] BYREF\n  char *endptr; // [esp+38h] [ebp-74h] BYREF\n  void *ptr[28]; // [esp+3Ch] [ebp-70h] BYREF\n\n  s1 = 0;\n  v52 = 0;\n  dword_80DBB80 = (int)sub_804DB2E(0x3Cu);\n  v41 = sub_80ABEC2(a2, \"Rup:i:NEfg\", \"reverse\", &v53, &v54);\n  v42 = (const char **)(a2 + 4 * optind);\n  v2 = 0;\n  if ( (v41 & 4) != 0 )\n    v2 = sub_80B4170();\n  v3 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 4) = v2;\n  *(_DWORD *)(v3 + 48) = -1;\n  *(_DWORD *)(v3 + 44) = -1;\n  if ( (v41 & 8) != 0 || *v42 && v42[1] )\n  {\n    v4 = sub_80B3DC6();\n    sub_804DC97(v4, 0);\n  }\n  p_s1 = &s1;\n  if ( (v41 & 1) != 0 )\n    p_s1 = &v52;\nLABEL_9:\n  v5 = 0;\nLABEL_10:\n  while ( 1 )\n  {\n    v6 = (char *)sub_80AB85A();\n    v7 = v6;\n    if ( !v6 )\n      break;\n    if ( !*v6 )\n    {\n      free(v6);\n      v7 = sub_804DB46(\" \");\n    }\n    v8 = dword_80DBB80;\n    if ( v5 <= 1 )\n    {\n      if ( sub_804D210(v7, \"--- \") || sub_804D210(v7, \"+++ \") )\n      {\n        if ( *v7 == 43 )\n        {\n          if ( (v41 & 1) != 0 )\n          {\n            v5 = v41 & 1;\n            v25 = (void **)&s1;\n          }\n          else\n          {\n            v25 = (void **)&v52;\n            v5 = 1;\n          }\n        }\n        else\n        {\n          v25 = (void **)p_s1;\n        }\n        sub_80A142C();\n        if ( !*v42 )\n        {\n          free(*v25);\n          for ( i = v7 + 4; ; ++i )\n          {\n            v27 = *i;\n            if ( !*i || v27 == 9 )\n              break;\n            if ( v27 == 92 && i[1] )\n              ++i;\n          }\n          if ( (unsigned int)(atoi(i) - 1901) > 0x45 )\n          {\n            *i = 0;\n            v28 = v7 + 4;\n          }\n          else\n          {\n            v28 = \"/dev/null\";\n          }\n          *v25 = sub_804DB46(v28);\n        }\n      }\n      else if ( v5 == 1 && sub_804D210(v7, \"@@ -\") )\n      {\n        endptr = v7 + 4;\n        *(_DWORD *)(v8 + 24) = 1;\n        *(_DWORD *)(v8 + 16) = 1;\n        *(_DWORD *)(v8 + 12) = strtol(v7 + 4, &endptr, 10);\n        v38 = 1;\n        if ( *endptr == 44 )\n        {\n          v38 = strtol(endptr + 1, &endptr, 10);\n          *(_DWORD *)(v8 + 16) = v38;\n        }\n        *(_DWORD *)(v8 + 20) = strtol(endptr + 2, &endptr, 10);\n        if ( *endptr == 44 )\n        {\n          v40 = strtol(endptr + 1, &endptr, 10);\n          *(_DWORD *)(v8 + 24) = v40;\n          if ( v38 <= 0 && v40 <= 0 )\n            sub_804D5E0(\"Really? %s\", v7);\n        }\n        else\n        {\n          v40 = 1;\n        }\n        *(_DWORD *)(v8 + 32) = 0;\n        if ( !s1 )\n          s1 = sub_804DB46(\"MISSING_FILENAME\");\n        if ( !v52 )\n          v52 = sub_804DB46(\"MISSING_FILENAME\");\n        if ( *(_DWORD *)(v8 + 44) != -1 )\n          goto LABEL_145;\n        v45 = *(_DWORD *)(v8 + 12) + v38;\n        v29 = *(_DWORD *)(v8 + 20) + v40;\n        if ( (v41 & 1) != 0 )\n          v30 = s1;\n        else\n          v30 = v52;\n        if ( !strcmp(v30, \"/dev/null\") )\n        {\n          if ( (v41 & 1) != 0 )\n            goto LABEL_113;\n        }\n        else\n        {\n          if ( (v41 & 1) != 0 )\n          {\n            if ( v45 )\n            {\nLABEL_111:\n              v5 = 0;\nLABEL_115:\n              endptr = v30;\n              v31 = 0;\n              while ( 1 )\n              {\n                v32 = endptr;\n                if ( !*endptr || (dword_80DBB9C & 4) != 0 && *(_DWORD *)(v8 + 4) == v31 )\n                  break;\n                ++endptr;\n                if ( *v32 == 47 )\n                {\n                  while ( 1 )\n                  {\n                    v30 = endptr;\n                    if ( *endptr != 47 )\n                      break;\n                    ++endptr;\n                  }\n                  ++v31;\n                }\n              }\n              v33 = *v42;\n              if ( !*v42 )\n                v33 = v30;\n              if ( v5 )\n              {\n                v5 = v41 & 0x100;\n                if ( (dword_80DBB9C & 0x20) != 0 )\n                {\n                  printf(\"removing %s\\n\", v33);\n                  if ( (v41 & 0x100) != 0 )\n                    goto LABEL_128;\n                  sub_804DC28(v33);\n                }\n                else\n                {\n                  printf(\"patching file %s\\n\", v33);\n                  if ( (v41 & 0x100) != 0 )\n                  {\nLABEL_128:\n                    v5 = 0;\n                  }\n                  else\n                  {\n                    v34 = sub_804DBE1(v33);\n                    sub_804DCF3(v34);\n                  }\n                }\nLABEL_146:\n                ++*(_DWORD *)(dword_80DBB80 + 40);\n                continue;\n              }\n              if ( (dword_80DBB9C & 4) != 0 && *(_DWORD *)(v8 + 4) < v31 )\n                goto LABEL_145;\n              if ( strcmp(s1, \"/dev/null\") && v45 )\n              {\n                printf(\"patching file %s\\n\", v33);\n                *(_DWORD *)(v8 + 44) = sub_804DBE1(v33);\n                if ( (v41 & 0x100) == 0 )\n                  goto LABEL_142;\n              }\n              else\n              {\n                printf(\"creating %s\\n\", v33);\n                if ( (v41 & 0x100) == 0 )\n                {\n                  v35 = strrchr(v33, 47);\n                  endptr = v35;\n                  if ( v35 )\n                  {\n                    *v35 = 0;\n                    sub_80B00B9(4, -1);\n                    *endptr = 47;\n                  }\n                  *(_DWORD *)(v8 + 44) = sub_804DBE1(v33);\nLABEL_142:\n                  v36 = sub_804DDBF(\"%sXXXXXX\", v33);\n                  *(_DWORD *)(v8 + 52) = v36;\n                  *(_DWORD *)(v8 + 48) = sub_804DD54(v36);\n                  fstat64();\n                  fchmod(*(_DWORD *)(v8 + 48), (__mode_t)ptr[4]);\nLABEL_144:\n                  *(_DWORD *)(v8 + 28) = 0;\n                  *(_DWORD *)(v8 + 40) = 0;\nLABEL_145:\n                  v5 = 2;\n                  goto LABEL_146;\n                }\n                *(_DWORD *)(v8 + 44) = sub_804DBE1(\"/dev/null\");\n              }\n              *(_DWORD *)(v8 + 52) = &data;\n              *(_DWORD *)(v8 + 48) = sub_804DBE1(\"/dev/null\");\n              goto LABEL_144;\n            }\nLABEL_113:\n            v30 = v52;\n            goto LABEL_115;\n          }\n          if ( v29 )\n            goto LABEL_111;\n        }\n        v30 = s1;\n        goto LABEL_115;\n      }\n      free(v7);\n      continue;\n    }\n    if ( ((*v7 - 43) & 0xFD) != 0 && *v7 != 32 )\n    {\n      sub_80A14C4();\n      goto LABEL_9;\n    }\n    sub_80A13A3((int *)(dword_80DBB80 + 8), (int)v7);\n    v9 = *v7;\n    if ( (*v7 == 43 || (--v38, v9 != 45)) && (--v40, v5 == 2) && v9 == 32 )\n      ++*(_DWORD *)(v8 + 32);\n    else\n      v5 = 3;\n    if ( !v38 && !v40 )\n    {\n      ptr[0] = 0;\n      v39 = dword_80DBB9C & 1;\n      v10 = *(int **)(v8 + 8);\n      *(_DWORD *)v10[1] = 0;\n      v11 = (int **)v10;\n      v12 = 0;\n      do\n      {\n        ++v12;\n        if ( *(_BYTE *)v11[2] != 32 )\n          v12 = 0;\n        v11 = (int **)*v11;\n      }\n      while ( v11 );\n      v44 = 1;\n      if ( v12 )\n        v44 = *(_DWORD *)(v8 + 32) > v12;\n      if ( v39 )\n        v13 = *(_DWORD *)(v8 + 16) == 0;\n      else\n        v13 = *(_DWORD *)(v8 + 24) == 0;\n      v43 = 0;\n      if ( v13 )\n      {\nLABEL_64:\n        *(_DWORD *)(v8 + 36) = (unsigned __int8)asc_80D2F2F[v43 ^ v39];\n        sub_80A14A8(*(void ***)(v8 + 8));\n        *(_DWORD *)(v8 + 8) = 0;\n        *(_DWORD *)(v8 + 36) = 1;\n        goto LABEL_65;\n      }\n      v14 = 0;\nLABEL_35:\n      v15 = (const char *)sub_80B2361();\n      v16 = *(_DWORD *)(v8 + 28) + 1;\n      *(_DWORD *)(v8 + 28) = v16;\n      v47 = dword_80DBB9C & 0x10;\n      while ( 1 )\n      {\nLABEL_36:\n        if ( !v10 || (v17 = v10[2], *(_BYTE *)v17 != byte_80D7DDE[v39]) )\n        {\n          if ( !v15 )\n          {\n            if ( !v10 && v44 )\n              goto LABEL_64;\n            if ( v14 )\n              dprintf();\n            sub_80A14C4();\nLABEL_65:\n            v24 = (void **)ptr[0];\n            if ( ptr[0] )\n            {\n              **((_DWORD **)ptr[0] + 1) = 0;\n              sub_80A14A8(v24);\n            }\n            v5 = *(_DWORD *)(v8 + 36);\n            v38 = 0;\n            goto LABEL_10;\n          }\n          v19 = sub_80A13A3((int *)ptr, (int)v15);\n          while ( 1 )\n          {\n            if ( !v10 )\n              goto LABEL_58;\n            while ( 2 )\n            {\n              v48 = v10[2];\n              v20 = strcmp((const char *)v19[2], (const char *)(v48 + 1));\n              if ( *(_BYTE *)v48 == byte_80D7DDE[v39] )\n              {\n                if ( !(v14 | v20) )\n                {\n                  v14 = *(_DWORD *)(v8 + 28);\n                  if ( (dword_80DBB9C & 0x10) != 0 )\n                  {\n                    v39 ^= 1u;\n                    v43 = 1;\n                  }\n                }\n                v10 = (int *)*v10;\n                continue;\n              }\n              break;\n            }\n            if ( !v20 )\n            {\n              v10 = (int *)*v10;\n              if ( !v10 && !v44 )\n                goto LABEL_64;\n              v19 = (_DWORD *)*v19;\n              if ( v19 == ptr[0] )\n                goto LABEL_35;\n            }\n            else\n            {\nLABEL_58:\n              *(_DWORD *)(v8 + 36) = 3;\n              v21 = ptr[0];\n              v22 = *(_DWORD **)ptr[0];\n              ptr[0] = v22;\n              v23 = (_DWORD *)v21[1];\n              *v23 = v22;\n              v22[1] = v23;\n              v49 = v21;\n              sub_80A13D5((void **)v21);\n              v10 = *(int **)(v8 + 8);\n              v19 = ptr[0];\n              if ( v49 == ptr[0] )\n              {\n                ptr[0] = 0;\n                goto LABEL_35;\n              }\n            }\n          }\n        }\n        if ( !v15 )\n          goto LABEL_43;\n        v50 = v15;\n        v18 = strcmp(v15, (const char *)(v17 + 1));\n        v15 = v50;\n        if ( v14 | v18 )\n          goto LABEL_43;\n        if ( !v47 )\n          break;\n        v39 ^= 1u;\n        v14 = v16;\n        v43 = 1;\n      }\n      v14 = v16;\nLABEL_43:\n      v10 = (int *)*v10;\n      goto LABEL_36;\n    }\n  }\n  sub_80A142C();\n  return *(_DWORD *)(dword_80DBB80 + 56);\n}\n"
    ],
    "sub_80A1CC9": [
        "0x80a1cc9",
        "int __usercall sub_80A1CC9@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ebx\n  int v4; // ecx\n  int v5; // edi\n  int v6; // eax\n\n  v2 = a1;\n  v3 = -1;\n  if ( a1 < 0 )\n  {\n    v2 = -a1;\n    v3 = -2;\n  }\n  v4 = 0;\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = *(unsigned __int8 *)(a2 + v4);\n    if ( !(_BYTE)v6 )\n      sub_804D5E0(\"unmatched '%c'\", v2);\n    if ( v3 < 0 )\n      break;\n    if ( (_BYTE)v6 == 93 && v3 != v4 - 1 && (v3 != v4 - 2 || *(_BYTE *)(a2 + v4 - 1) != 94) )\n      v3 = -1;\nLABEL_21:\n    ++v4;\n  }\n  if ( v5 )\n  {\n    v5 = 0;\n    goto LABEL_21;\n  }\n  if ( (_BYTE)v6 == 92 )\n  {\n    v5 = 1;\n    goto LABEL_21;\n  }\n  if ( (_BYTE)v6 == 91 && v3 == -1 )\n  {\n    v3 = v4;\n    goto LABEL_21;\n  }\n  if ( v6 != v2 )\n    goto LABEL_21;\n  return v4;\n}\n"
    ],
    "sub_80A1D44": [
        "0x80a1d44",
        "int sub_80A1D44()\n{\n  int result; // eax\n  int v1; // [esp-4h] [ebp-4h]\n\n  result = *(&unk_80DB780 + 1);\n  if ( *(&unk_80DB780 + 1) )\n  {\n    unlink((const char *)*(&unk_80DB780 + 1));\n    return v1;\n  }\n  return result;\n}\n"
    ],
    "sub_80A1D55": [
        "0x80a1d55",
        "_BYTE *__usercall sub_80A1D55@<eax>(char *a1@<eax>, const char *a2@<edx>, signed int a3@<ecx>, char a4, char a5)\n{\n  signed int v7; // eax\n  char *v8; // ebx\n  signed int v9; // esi\n  char v10; // dl\n  char v11; // cl\n\n  v7 = a3;\n  if ( a3 == -1 )\n    v7 = strlen(a2);\n  v8 = a1;\n  v9 = 0;\n  while ( v9 < v7 )\n  {\n    if ( a2[v9] != 92 )\n      goto LABEL_12;\n    v10 = a2[v9 + 1];\n    if ( !a5 )\n      goto LABEL_9;\n    if ( a4 == v10 )\n    {\n      v10 = a5;\nLABEL_9:\n      *v8 = v10;\n      if ( !v10 )\n        return (_BYTE *)(v8 - a1);\n      v9 += 2;\n      ++v8;\n    }\n    else\n    {\n      ++v9;\n      *v8++ = 92;\nLABEL_12:\n      v11 = a2[v9];\n      *v8 = v11;\n      if ( !v11 )\n        return (_BYTE *)(v8 - a1);\n      ++v8;\n      ++v9;\n    }\n  }\n  *v8 = 0;\n  return (_BYTE *)(v8 - a1);\n}\n"
    ],
    "sub_80A1DD0": [
        "0x80a1dd0",
        "char *__usercall sub_80A1DD0@<eax>(const char *a1@<eax>, _BYTE *a2@<edx>)\n{\n  _BYTE *v3; // ebp\n  char *v4; // esi\n  const char *i; // ebx\n\n  v3 = a2;\n  v4 = (char *)sub_804DAFA((size_t)(a2 + 1));\n  for ( i = \"\\nn\\tt\\rr\"; *i; i += 2 )\n  {\n    v3 = sub_80A1D55(v4, a1, (signed int)v3, i[1], *i);\n    a1 = v4;\n  }\n  return v4;\n}\n"
    ],
    "sub_80A1E11": [
        "0x80a1e11",
        "char *__usercall sub_80A1E11@<eax>(char *a1@<eax>, int *a2@<edx>, _DWORD *a3@<ecx>)\n{\n  char v4; // al\n  int v6; // eax\n  char *v7; // edi\n  _BYTE *v8; // eax\n  _BYTE *v9; // esi\n  char *v10; // edi\n  void *v11; // eax\n  char *v13; // [esp+0h] [ebp-14h] BYREF\n\n  v13 = a1;\n  v4 = *a1;\n  if ( (unsigned __int8)(v4 - 48) > 9u )\n  {\n    if ( v4 == 36 )\n    {\n      *a2 = -1;\n      v13 = a1 + 1;\n    }\n    else\n    {\n      if ( v4 == 47 )\n      {\n        v6 = 47;\n      }\n      else\n      {\n        if ( v4 != 92 )\n          return (char *)(v13 - a1);\n        v13 = a1 + 1;\n        v6 = (unsigned __int8)a1[1];\n      }\n      v7 = v13 + 1;\n      v13 = v7;\n      v8 = (_BYTE *)sub_80A1CC9(v6, (int)v7);\n      v9 = v8;\n      if ( v8 )\n      {\n        v10 = sub_80A1DD0(v7, v8);\n        v11 = sub_804DB2E(0x20u);\n        *a3 = v11;\n        dword_80DB7F0 = (int)v11;\n        sub_80B47BA(HIDWORD(qword_80DB778), v10);\n        free(v10);\n      }\n      else\n      {\n        *a3 = dword_80DB7F0;\n        if ( !dword_80DB7F0 )\n          sub_804D5E0(\"no previous regexp\");\n      }\n      v13 = &v13[(_DWORD)(v9 + 1)];\n    }\n  }\n  else\n  {\n    *a2 = strtol(a1, &v13, 10);\n  }\n  return (char *)(v13 - a1);\n}\n"
    ],
    "sub_80A1EE4": [
        "0x80a1ee4",
        "_BYTE *__usercall sub_80A1EE4@<eax>(const char *a1@<eax>, char **a2@<edx>, char **a3@<ecx>)\n{\n  int v3; // ebx\n  const char *v5; // edi\n  _BYTE *v6; // ebp\n  const char *v7; // edi\n  _BYTE *v8; // ebx\n\n  v3 = *(unsigned __int8 *)a1;\n  if ( !(_BYTE)v3 )\n    sub_804D5E0(\"bad format in substitution expression\");\n  v5 = a1 + 1;\n  v6 = (_BYTE *)sub_80A1CC9(v3, (int)(a1 + 1));\n  *a2 = sub_80A1DD0(v5, v6);\n  v7 = &v6[(_DWORD)v5 + 1];\n  v8 = (_BYTE *)sub_80A1CC9(-v3, (int)v7);\n  *a3 = sub_80A1DD0(v7, v8);\n  return &v8[v7 - a1];\n}\n"
    ],
    "sub_80A1F4E": [
        "0x80a1f4e",
        "_BYTE *__usercall sub_80A1F4E@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<edx>)\n{\n  _BYTE *v4; // ebx\n  _BYTE *v5; // edx\n  _BYTE *v6; // eax\n  unsigned __int8 v7; // cl\n  _BYTE *i; // ebx\n  char v9; // cl\n  _BYTE *v10; // eax\n\n  v4 = a1;\n  do\n  {\n    do\n    {\n      v5 = (_BYTE *)(v4 - a1);\n      v6 = v4;\n      v7 = *v4++ - 9;\n    }\n    while ( v7 == 23 );\n  }\n  while ( v7 <= 4u );\n  for ( i = v5; ; ++i )\n  {\n    v9 = i[(_DWORD)a1];\n    if ( !v9 )\n      break;\n    if ( v9 == 10 )\n    {\n      if ( v5 == i )\n        goto LABEL_9;\n      v10 = sub_804DB5D(v6, i - v5 + 2);\n      *a2 = v10;\n      i[(_DWORD)v10] = 92;\n      return i;\n    }\n  }\n  if ( v5 == i )\nLABEL_9:\n    sub_804D5E0(\"empty filename\");\n  *a2 = sub_804DB5D(v6, i - v5 + 1);\n  return i;\n}\n"
    ],
    "sub_80A1FBC": [
        "0x80a1fbc",
        "void __usercall sub_80A1FBC(const char *a1@<eax>)\n{\n  unsigned int v1; // ebx\n  size_t v2; // eax\n  size_t v3; // esi\n  char *v4; // ebx\n  void *v5; // esi\n  int v6; // edx\n  int v7; // ecx\n  char *v8; // ebx\n  char *v9; // eax\n  int v10; // edx\n  int v11; // ecx\n  int v12; // ebp\n  unsigned __int8 v13; // al\n  int v14; // edi\n  unsigned int v15; // eax\n  int v16; // ebp\n  char *v17; // edi\n  char v18; // al\n  unsigned __int8 v19; // al\n  char v20; // al\n  size_t v21; // edi\n  char *v22; // eax\n  int v23; // eax\n  int v24; // edi\n  char v25; // di\n  size_t v26; // eax\n  int i; // eax\n  char v28; // cl\n  int v29; // edx\n  int v30; // [esp-4h] [ebp-1Ch]\n  void *ptr; // [esp+0h] [ebp-18h] BYREF\n  char *endptr[5]; // [esp+4h] [ebp-14h] BYREF\n\n  v1 = (unsigned int)a1;\n  if ( dword_80DB800 )\n  {\n    v1 = (unsigned int)sub_804DDBF(\"%s\\n%s\", (const char *)dword_80DB800, a1);\n    free(dword_80DB800);\n    dword_80DB800 = (void *)v1;\n  }\n  v2 = strlen((const char *)v1);\n  v3 = v2;\n  while ( v2 && *(_BYTE *)(v1 + v2 - 1) == 92 )\n    --v2;\n  if ( (((_BYTE)v3 - (_BYTE)v2) & 1) == 0 )\n  {\n    while ( 1 )\n    {\n      if ( !*(_BYTE *)v1 || (v4 = (char *)(strspn((const char *)v1, \"; \\n\\r\\t\\v\") + v1), !*v4) )\n      {\nLABEL_17:\n        free(dword_80DB800);\n        dword_80DB800 = 0;\n        return;\n      }\n      if ( *v4 == 35 )\n      {\n        if ( v4[1] == 110 )\n          LODWORD(qword_80DB778) = qword_80DB778 + 1;\n        v1 = (unsigned int)strpbrk(v4, \"\\n\\r\");\n        if ( v1 )\n          continue;\n        goto LABEL_17;\n      }\n      v5 = sub_804DB2E(0x30u);\n      v8 = &v4[(_DWORD)sub_80A1E11(v4, (int *)v5 + 4, (_DWORD *)v5 + 1)];\n      *((_DWORD *)v5 + 5) = *((_DWORD *)v5 + 4);\n      if ( *v8 == 44 )\n      {\n        if ( v8[1] == 43 && (unsigned __int8)(v8[2] - 48) <= 9u )\n        {\n          v9 = (char *)strtol(v8 + 2, endptr, 10);\n          v6 = -2 - (_DWORD)v9;\n          *((_DWORD *)v5 + 6) = -2 - (_DWORD)v9;\n        }\n        else\n        {\n          v9 = sub_80A1E11(v8 + 1, (int *)v5 + 6, (_DWORD *)v5 + 2) - 1;\n        }\n        if ( (int)v9 < 0 )\n          sub_804D5E0(\"no address after comma\");\n        *((_DWORD *)v5 + 7) = *((_DWORD *)v5 + 6);\n      }\n      v12 = sub_80B2E8C(v7, v6);\n      if ( *(_BYTE *)v12 == 33 )\n      {\n        *((_BYTE *)v5 + 44) |= 1u;\n        v12 = sub_80B2E8C(v11, v10);\n      }\n      v13 = *(_BYTE *)v12;\n      if ( !*(_BYTE *)v12 )\n        sub_804D5E0(\"missing command\");\n      v1 = v12 + 1;\n      *((_BYTE *)v5 + 46) = v13;\n      v14 = v13;\n      v30 = v13;\n      v15 = strchrnul() - (_DWORD)\"saicrw:btTydDgGhHlnNpPqx={}\";\n      if ( v15 )\n      {\n        if ( v15 > 3 )\n        {\n          if ( v15 > 5 )\n          {\n            if ( v15 > 9 )\n            {\n              if ( v15 == 10 )\n              {\n                v25 = *(_BYTE *)(v12 + 1);\n                v1 += (unsigned int)(sub_80A1EE4((const char *)(v12 + 1), (char **)&ptr, endptr) + 1);\n                sub_80A1D55((char *)ptr, (const char *)ptr, -1, v25, v25);\n                sub_80A1D55(endptr[0], endptr[0], -1, v25, v25);\n                v26 = strlen((const char *)ptr);\n                *((_DWORD *)v5 + 9) = sub_804DB2E(2 * (v26 + 1));\n                for ( i = 0; ; ++i )\n                {\n                  v28 = *((_BYTE *)ptr + i);\n                  if ( !v28 || !endptr[0][i] )\n                    break;\n                  v29 = 2 * i;\n                  *(_BYTE *)(*((_DWORD *)v5 + 9) + v29) = v28;\n                  *(_BYTE *)(*((_DWORD *)v5 + 9) + v29 + 1) = endptr[0][i];\n                }\n                free(ptr);\n                free(endptr[0]);\n              }\n              else if ( v15 > 0x1A )\n              {\n                sub_804D5E0(\"unsupported command %c\", v14);\n              }\n            }\n            else\n            {\n              v1 = sub_80B2E8C(v30, \"saicrw:btTydDgGhHlnNpPqx={}\");\n              v23 = strcspn((const char *)v1, \"; \\n\\r\\t\\v\");\n              v24 = v23;\n              if ( v23 )\n              {\n                *((_DWORD *)v5 + 9) = sub_804DB5D((_BYTE *)v1, v23);\n                v1 += v24;\n              }\n            }\n            goto LABEL_90;\n          }\n          if ( v15 != 4 || !*((_DWORD *)v5 + 6) && !*((_DWORD *)v5 + 2) )\n          {\n            v1 += (unsigned int)sub_80A1F4E((_BYTE *)(v12 + 1), (_DWORD *)v5 + 9);\n            if ( *((_BYTE *)v5 + 46) == 119 )\n            {\n              *((_DWORD *)v5 + 8) = sub_80B3D5D();\n              *((_BYTE *)v5 + 45) = 10;\n            }\n            goto LABEL_90;\n          }\n        }\n        else if ( v15 == 3 || !*((_DWORD *)v5 + 6) && !*((_DWORD *)v5 + 2) )\n        {\n          while ( 1 )\n          {\n            v20 = *(_BYTE *)v1;\n            if ( *(_BYTE *)v1 == 10 || v20 == 92 )\n              break;\n            v19 = v20 - 9;\n            if ( v19 != 23 && v19 > 4u )\n              goto LABEL_71;\n            ++v1;\n          }\n          ++v1;\nLABEL_71:\n          v21 = strlen((const char *)v1);\n          v22 = sub_80A1DD0((const char *)v1, (_BYTE *)v21);\n          *((_DWORD *)v5 + 9) = v22;\n          v1 += v21;\n          sub_80A1D55(v22, v22, -1, 0, 0);\n          goto LABEL_90;\n        }\n        sub_804D5E0(\"command '%c' uses only one address\", v14);\n      }\n      v16 = HIDWORD(qword_80DB778);\n      v17 = sub_80A1EE4((const char *)v1, (char **)&ptr, (char **)v5 + 9);\n      *((_DWORD *)v5 + 10) = 1;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            while ( 1 )\n            {\n              do\n              {\n                while ( 1 )\n                {\n                  ++v17;\n                  v18 = v17[v1];\n                  if ( !v18 )\n                    goto LABEL_57;\n                  if ( (unsigned __int8)(v18 - 48) > 9u )\n                    break;\n                  if ( *(_BYTE *)ptr != 94 )\n                  {\n                    endptr[0] = &v17[v1];\n                    *((_DWORD *)v5 + 10) = strtol(&v17[v1], endptr, 10);\n                    v17 = &endptr[0][~v1];\n                  }\n                }\n              }\n              while ( v18 == 32 || (unsigned __int8)(v18 - 9) <= 4u );\n              if ( v18 != 103 )\n                break;\n              if ( *(_BYTE *)ptr != 94 )\n                *((_DWORD *)v5 + 10) = 0;\n            }\n            if ( (unsigned __int8)v18 > 0x67u )\n              break;\n            if ( v18 == 59 )\n              goto LABEL_57;\n            if ( v18 != 73 )\n            {\n              if ( v18 == 35 )\n              {\n                v17 += strlen(&v17[v1]);\n                goto LABEL_57;\n              }\nLABEL_56:\n              sub_804D5E0(\"bad option in substitution expression\");\n            }\nLABEL_55:\n            v16 |= 2u;\n          }\n          if ( v18 != 112 )\n            break;\n          *((_BYTE *)v5 + 44) |= 4u;\n        }\n        if ( (unsigned __int8)v18 <= 0x70u )\n        {\n          if ( v18 != 105 )\n            goto LABEL_56;\n          goto LABEL_55;\n        }\n        if ( v18 != 119 )\n          break;\n        v17 = &v17[(_DWORD)sub_80A1F4E(&v17[v1 + 1], endptr)];\n        *((_DWORD *)v5 + 8) = sub_80B3D5D();\n        *((_BYTE *)v5 + 45) = 10;\n        free(endptr[0]);\n      }\n      if ( v18 != 125 )\n        goto LABEL_56;\nLABEL_57:\n      if ( *(_BYTE *)ptr )\n      {\n        *((_DWORD *)v5 + 3) = sub_804DB2E(0x20u);\n        sub_80B47BA(v16, ptr);\n      }\n      free(ptr);\n      v1 += (unsigned int)v17;\nLABEL_90:\n      *(_DWORD *)dword_80DB7F8 = v5;\n      dword_80DB7F8 = (int)v5;\n    }\n  }\n  if ( !dword_80DB800 )\n    dword_80DB800 = sub_804DB46((const char *)v1);\n  *((char *)dword_80DB800 + v3 - 1) = 0;\n}\n"
    ],
    "sub_80A2428": [
        "0x80a2428",
        "int __usercall sub_80A2428@<eax>(const char *a1@<eax>)\n{\n  char *v1; // edi\n  const char *v2; // esi\n  char *v3; // eax\n  char *v4; // ebx\n  int v6; // [esp-4h] [ebp-10h]\n\n  v1 = sub_804DB46(a1);\n  v2 = v1;\n  do\n  {\n    v3 = strchr(v2, 10);\n    v4 = v3;\n    if ( v3 )\n      *v3 = 0;\n    sub_80A1FBC(v2);\n    v2 = v4 + 1;\n  }\n  while ( v4 );\n  free(v1);\n  return v6;\n}\n"
    ],
    "sub_80A2460": [
        "0x80a2460",
        "int __usercall sub_80A2460@<eax>(char a1@<al>)\n{\n  int result; // eax\n\n  if ( dword_80DB808 == dword_80DB80C )\n  {\n    dword_80DB804 = (int)sub_804DB13((void *)dword_80DB804, dword_80DB808 + 64);\n    dword_80DB80C += 64;\n  }\n  result = dword_80DB808++;\n  *(_BYTE *)(dword_80DB804 + result) = a1;\n  return result;\n}\n"
    ],
    "sub_80A24A3": [
        "0x80a24a3",
        "int __usercall sub_80A24A3@<eax>(_BYTE *a1@<eax>, int a2@<edx>, char *a3@<ecx>, int a4@<ebx>, char a5)\n{\n  char v8; // dl\n  _BYTE *v9; // eax\n  char v10; // dl\n  _BYTE *v11; // eax\n  char *v12; // eax\n\n  v8 = *a3;\n  if ( *a3 != 10 && v8 )\n  {\n    v9 = *(_BYTE **)(a2 + 16);\n    if ( (unsigned int)v9 >= *(_DWORD *)(a2 + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(a2 + 16) = v9 + 1;\n      *v9 = 10;\n    }\n    v8 = 10;\n  }\n  HIBYTE(a4) = v8;\n  fputs_unlocked();\n  v10 = HIBYTE(a4);\n  if ( *a1 )\n    v10 = 120;\n  if ( a5 == 2 )\n  {\n    v11 = *(_BYTE **)(a2 + 16);\n    if ( (unsigned int)v11 >= *(_DWORD *)(a2 + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(a2 + 16) = v11 + 1;\n      *v11 = 0;\n    }\n    v10 = 120;\n  }\n  else if ( a5 != 1 )\n  {\n    v12 = *(char **)(a2 + 16);\n    if ( (unsigned int)v12 >= *(_DWORD *)(a2 + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(a2 + 16) = v12 + 1;\n      *v12 = a5;\n    }\n    v10 = a5;\n  }\n  if ( (*(_BYTE *)a2 & 8) != 0 )\n  {\n    byte_80DB560 = 4;\n    sub_804D5E0(\"write error\");\n  }\n  *a3 = v10;\n  return a4;\n}\n"
    ],
    "sub_80A2562": [
        "0x80a2562",
        "_BYTE *__usercall sub_80A2562@<eax>(char *a1@<eax>)\n{\n  _BYTE *result; // eax\n  void *v3; // ebx\n  int v4; // [esp+0h] [ebp-8h]\n\n  while ( 1 )\n  {\n    result = (_BYTE *)sub_80AFB01(v4);\n    v3 = result;\n    if ( !result )\n      break;\n    sub_80A24A3(result, unk_80DB780, a1, (int)result, 10);\n    free(v3);\n  }\n  return result;\n}\n"
    ],
    "sub_80A2594": [
        "0x80a2594",
        "int __usercall sub_80A2594@<eax>(char *a1@<eax>, char *a2@<edx>)\n{\n  int v3; // ecx\n  FILE *v4; // ebx\n  int v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // esi\n  char *v9; // eax\n  char v10; // dl\n  char *IO_write_base; // eax\n  int v12; // eax\n  char v14; // [esp+3h] [ebp-11h]\n  int v15; // [esp+4h] [ebp-10h]\n\n  sub_80A2562(a2);\n  while ( 1 )\n  {\n    if ( (int)*(&MEMORY[0x80DB788] + 2) > (int)*(&MEMORY[0x80DB788] + 3) )\n    {\n      v10 = 1;\n      v8 = 0;\n      goto LABEL_21;\n    }\n    v4 = stream;\n    if ( !stream )\n    {\n      v4 = stdin;\n      if ( *(char **)&dword_80DB798[4 * (_DWORD)*(&MEMORY[0x80DB788] + 2)] != \"standard input\" )\n      {\n        v4 = (FILE *)sub_80B3D18(v3, 135102078);\n        if ( !v4 )\n        {\n          *((_BYTE *)&MEMORY[0x80DB788] + 4) = 1;\n          goto LABEL_17;\n        }\n      }\n      stream = v4;\n    }\n    v5 = sub_80AB7A9();\n    v8 = v5;\n    if ( v5 )\n      break;\n    sub_80AB218(v7, v6);\n    stream = 0;\nLABEL_17:\n    ++*(&MEMORY[0x80DB788] + 2);\n  }\n  v9 = (char *)(v5 + v15 - 1);\n  v10 = *v9;\n  if ( *v9 != 10 && v10 )\n  {\n    v10 = 1;\n  }\n  else\n  {\n    *v9 = 0;\n    if ( v10 )\n      goto LABEL_21;\n    IO_write_base = v4->_IO_write_base;\n    if ( IO_write_base < v4->_IO_write_end )\n    {\n      v4->_IO_write_base = IO_write_base + 1;\n      v12 = (unsigned __int8)*IO_write_base;\nLABEL_15:\n      v14 = v10;\n      ungetc(v12, v4);\n      v10 = v14;\n      goto LABEL_21;\n    }\n    v12 = __fgetc_unlocked();\n    v10 = 0;\n    if ( v12 != -1 )\n      goto LABEL_15;\n    v10 = 2;\n  }\nLABEL_21:\n  *a1 = v10;\n  return v8;\n}\n"
    ],
    "sub_80A268B": [
        "0x80a268b",
        "int sub_80A268B()\n{\n  int result; // eax\n  char *v1; // esi\n  int i; // ebx\n  char v3; // al\n  bool v4; // dl\n  int v5; // ecx\n  bool v6; // zf\n  const regex_t *v7; // eax\n  int v8; // eax\n  char v9; // al\n  int v10; // eax\n  int v11; // eax\n  const regex_t *v12; // eax\n  char v13; // dl\n  char v14; // cl\n  int v15; // eax\n  char v16; // dl\n  char v17; // bp\n  char *v18; // edi\n  char *v19; // eax\n  char *v20; // edi\n  const char *v21; // edi\n  int v22; // eax\n  regoff_t v23; // edx\n  char v24; // al\n  int v25; // edx\n  int j; // ebp\n  char v27; // al\n  int v28; // edx\n  int v29; // eax\n  int v30; // ecx\n  int v31; // ebp\n  regoff_t k; // edx\n  char v33; // al\n  int v34; // edx\n  char *v35; // ecx\n  char *v36; // eax\n  int v37; // ecx\n  FILE *v38; // edi\n  int v39; // eax\n  int v40; // ecx\n  size_t v41; // edi\n  size_t v42; // eax\n  const char *v43; // edi\n  const char *v44; // eax\n  int v45; // eax\n  char v46; // cl\n  int v47; // ebp\n  const char *v48; // eax\n  size_t v49; // edi\n  size_t v50; // eax\n  char *v51; // eax\n  char *v52; // ebp\n  size_t v53; // edi\n  size_t v54; // eax\n  char *v55; // eax\n  char *v56; // eax\n  int v57; // [esp-4h] [ebp-48h]\n  int v58; // [esp-4h] [ebp-48h]\n  char *ptr; // [esp+0h] [ebp-44h]\n  bool v60; // [esp+4h] [ebp-40h]\n  int v61; // [esp+4h] [ebp-40h]\n  char v62; // [esp+4h] [ebp-40h]\n  int v63; // [esp+8h] [ebp-3Ch]\n  regex_t *preg; // [esp+Ch] [ebp-38h]\n  int v65; // [esp+10h] [ebp-34h]\n  regoff_t rm_so; // [esp+14h] [ebp-30h]\n  char v67; // [esp+1Ah] [ebp-2Ah]\n  char v68; // [esp+1Bh] [ebp-29h]\n  int v69; // [esp+1Ch] [ebp-28h]\n  bool v70; // [esp+20h] [ebp-24h]\n  int v71; // [esp+20h] [ebp-24h]\n  regoff_t v72; // [esp+24h] [ebp-20h]\n  regoff_t v73; // [esp+24h] [ebp-20h]\n  bool v74; // [esp+24h] [ebp-20h]\n  int v75; // [esp+28h] [ebp-1Ch]\n  regoff_t v76; // [esp+28h] [ebp-1Ch]\n  int v77; // [esp+2Ch] [ebp-18h]\n  char v78; // [esp+32h] [ebp-12h] BYREF\n  char v79[17]; // [esp+33h] [ebp-11h] BYREF\n\n  v78 = 10;\n  result = sub_80A2594(v79, &v78);\n  v1 = (char *)result;\n  v63 = 0;\n  while ( v1 )\n  {\n    v67 = v79[0];\n    ptr = (char *)sub_80A2594(v79, &v78);\n    ++v63;\n    v65 = 0;\nLABEL_4:\n    for ( i = dword_80DB7F4; i; i = *(_DWORD *)i )\n    {\n      v3 = *(_BYTE *)(i + 44);\n      v4 = (v3 & 2) != 0;\n      v5 = *(_DWORD *)(i + 16);\n      if ( (v3 & 2) != 0 )\n        goto LABEL_25;\n      if ( v5 )\n      {\n        if ( v5 > 0 )\n        {\n          if ( !*(_DWORD *)(i + 24) && !*(_DWORD *)(i + 8) )\n          {\n            v6 = v63 == v5;\nLABEL_17:\n            if ( v6 )\n              goto LABEL_25;\n            goto LABEL_18;\n          }\n          if ( v63 >= v5 )\n            goto LABEL_21;\n        }\n      }\n      else\n      {\n        v5 = *(_DWORD *)(i + 4);\n        if ( !*(_DWORD *)(i + 24) && !v5 )\n        {\n          v6 = *(_DWORD *)(i + 8) == 0;\n          goto LABEL_17;\n        }\n      }\nLABEL_18:\n      v7 = *(const regex_t **)(i + 4);\n      if ( v7 )\n      {\n        v60 = (*(_BYTE *)(i + 44) & 2) != 0;\n        v8 = regexec(v7, v1, 0, 0, 0);\n        v4 = v60;\n        if ( !v8 )\n        {\n          dword_80DB7F0 = *(_DWORD *)(i + 4);\nLABEL_21:\n          *(_BYTE *)(i + 44) |= 2u;\n          goto LABEL_26;\n        }\n      }\n      v3 = *(_BYTE *)(i + 44);\n      if ( *(_DWORD *)(i + 16) != -1 || ptr )\n      {\n        *(_BYTE *)(i + 44) = v3 & 0xFD;\n        v9 = 0;\n        goto LABEL_42;\n      }\nLABEL_25:\n      *(_BYTE *)(i + 44) = v3 | 2;\nLABEL_26:\n      v10 = *(_DWORD *)(i + 24);\n      if ( v10 < -1 )\n      {\n        v5 = v63 - v10;\n        *(_DWORD *)(i + 24) = v63 - v10 - 2;\n      }\n      if ( *(int *)(i + 16) > 0 )\n        *(_DWORD *)(i + 16) = -2;\n      v11 = *(_DWORD *)(i + 24);\n      if ( v11 )\n      {\n        if ( v11 == -1 )\n        {\n          if ( ptr )\n            goto LABEL_37;\n        }\n        else if ( v11 > v63 )\n        {\n          goto LABEL_37;\n        }\n        LOBYTE(v11) = 0;\n      }\n      else if ( *(_DWORD *)(i + 8) )\n      {\nLABEL_37:\n        v12 = *(const regex_t **)(i + 8);\n        LOBYTE(v11) = !v12 || !v4 || regexec(v12, v1, 0, 0, 0) != 0;\n      }\n      *(_BYTE *)(i + 44) = *(_BYTE *)(i + 44) & 0xFD | (2 * (v11 & 1));\n      v9 = 1;\nLABEL_42:\n      v13 = *(_BYTE *)(i + 44) & 1;\n      if ( *(_BYTE *)(i + 46) == 123 )\n      {\n        v14 = v9 ^ 1;\n        if ( v13 )\n          v14 = v9 & 1;\n        if ( v14 )\n        {\n          v15 = 0;\n          while ( 1 )\n          {\n            v16 = *(_BYTE *)(i + 46);\n            if ( v16 == 123 )\n            {\n              ++v15;\n            }\n            else if ( v16 == 125 && !--v15 )\n            {\n              break;\n            }\n            i = *(_DWORD *)i;\n            if ( !i )\n              sub_804D5E0(\"unterminated {\");\n          }\n        }\n      }\n      else\n      {\n        v17 = v9 ^ 1;\n        if ( v13 )\n          v17 = v9 & 1;\n        if ( !v17 )\n        {\n          if ( *(_DWORD *)(i + 4) )\n            dword_80DB7F0 = *(_DWORD *)(i + 4);\n          switch ( *(_BYTE *)(i + 46) )\n          {\n            case '=':\n              fprintf((FILE *)unk_80DB780, \"%d\\n\", v63);\n              continue;\n            case 'D':\n              if ( !strchr(v1, 10) )\n                goto LABEL_176;\n              sub_80B2C69(v57);\n              goto LABEL_4;\n            case 'G':\n              v49 = 2;\n              if ( v1 )\n                v49 = strlen(v1) + 2;\n              v50 = 0;\n              if ( MEMORY[0x80DB788] )\n                v50 = strlen(MEMORY[0x80DB788]);\n              v51 = (char *)sub_804DB13(v1, v49 + v50);\n              v1 = v51;\n              if ( v49 == 2 )\n                *v51 = 0;\n              strcat(v51, \"\\n\");\n              v67 = 10;\n              if ( MEMORY[0x80DB788] )\n                strcat(v1, MEMORY[0x80DB788]);\n              continue;\n            case 'H':\n              v52 = MEMORY[0x80DB788];\n              v53 = 2;\n              if ( MEMORY[0x80DB788] )\n                v53 = strlen(MEMORY[0x80DB788]) + 2;\n              v54 = 0;\n              if ( v1 )\n                v54 = strlen(v1);\n              v55 = (char *)sub_804DB13(v52, v53 + v54);\n              MEMORY[0x80DB788] = v55;\n              if ( v53 == 2 )\n                *v55 = 0;\n              strcat(MEMORY[0x80DB788], \"\\n\");\n              if ( v1 )\n                strcat(MEMORY[0x80DB788], v1);\n              continue;\n            case 'N':\n              if ( !ptr )\n                goto LABEL_174;\n              v41 = strlen(v1);\n              v42 = strlen(ptr);\n              v1 = (char *)sub_804DB13(v1, v41 + v42 + 2);\n              v1[v41] = 10;\n              strcpy(&v1[v41 + 1], ptr);\n              v67 = v79[0];\n              ptr = (char *)sub_80A2594(v79, &v78);\n              ++v63;\n              continue;\n            case 'P':\n              v19 = strchr(v1, 10);\n              v20 = v19;\n              if ( !v19 )\n                goto LABEL_63;\n              *v19 = 0;\n              sub_80A24A3(v1, unk_80DB780, &v78, i, 10);\n              *v20 = 10;\n              continue;\n            case 'T':\n              if ( v65 )\n                continue;\n              goto LABEL_135;\n            case 'a':\n              v36 = sub_804DB46(*(const char **)(i + 36));\n              sub_80AFADF(v37, v36);\n              continue;\n            case 'b':\n              goto LABEL_135;\n            case 'c':\n              if ( (*(_BYTE *)(i + 44) & 2) == 0 )\n                sub_80A24A3(*(_BYTE **)(i + 36), unk_80DB780, &v78, i, 10);\n              goto LABEL_176;\n            case 'd':\n              goto LABEL_176;\n            case 'g':\n              free(v1);\n              v48 = MEMORY[0x80DB788];\n              if ( !MEMORY[0x80DB788] )\n                v48 = &data;\n              v1 = sub_804DB46(v48);\n              continue;\n            case 'h':\n              free(MEMORY[0x80DB788]);\n              MEMORY[0x80DB788] = sub_804DB46(v1);\n              continue;\n            case 'i':\n              sub_80A24A3(*(_BYTE **)(i + 36), unk_80DB780, &v78, i, 10);\n              continue;\n            case 'n':\n              if ( !(_DWORD)qword_80DB778 )\n                sub_80A24A3(v1, unk_80DB780, &v78, i, v67);\n              if ( !ptr )\n                goto LABEL_176;\n              free(v1);\n              v67 = v79[0];\n              ++v63;\n              v1 = ptr;\n              ptr = (char *)sub_80A2594(v79, &v78);\n              v65 = 0;\n              continue;\n            case 'p':\nLABEL_63:\n              sub_80A24A3(v1, unk_80DB780, &v78, i, 10);\n              continue;\n            case 'q':\n              free(ptr);\n              ptr = 0;\n              goto LABEL_174;\n            case 'r':\n              v38 = (FILE *)sub_80B3D37(v5);\n              if ( v38 )\n              {\n                while ( 1 )\n                {\n                  v39 = sub_80AB85A();\n                  if ( !v39 )\n                    break;\n                  sub_80AFADF(v40, v39);\n                }\n                fclose(v38);\n              }\n              continue;\n            case 's':\n              preg = *(regex_t **)(i + 12);\n              if ( !preg )\n              {\n                preg = (regex_t *)dword_80DB7F0;\n                if ( !dword_80DB7F0 )\n                  sub_804D5E0(\"no previous regexp\");\n              }\n              dword_80DB7F0 = (int)preg;\n              if ( regexec(preg, v1, 0xAu, pmatch, 0) == 1 )\n                continue;\n              dword_80DB804 = (int)sub_804DAFA(0x40u);\n              dword_80DB80C = 64;\n              dword_80DB808 = 0;\n              v68 = 0;\n              v21 = v1;\n              v70 = 1;\n              v69 = 0;\n              do\n              {\n                rm_so = pmatch[0].rm_so;\n                v61 = dword_80DB7A4;\n                ++v69;\n                v22 = *(_DWORD *)(i + 40);\n                v23 = 0;\n                if ( !v22 || v69 == v22 )\n                {\n                  while ( rm_so > v23 )\n                  {\n                    v73 = v23;\n                    sub_80A2460(v21[v23]);\n                    v23 = v73 + 1;\n                  }\n                  v74 = v70 || (v61 | rm_so) != 0;\n                  if ( v74 )\n                  {\n                    v71 = *(_DWORD *)(i + 36);\n                    for ( j = 0; ; j = v28 + 1 )\n                    {\n                      v27 = *(_BYTE *)(v71 + j);\n                      if ( !v27 )\n                        break;\n                      v28 = j + 1;\n                      if ( v27 == 92 )\n                      {\n                        v29 = *(unsigned __int8 *)(j + 1 + v71);\n                        v30 = v29 - 48;\n                        if ( (unsigned int)(v29 - 48) > 9 )\n                        {\n                          sub_80A2460(v29);\n                          v28 = j + 1;\n                        }\n                        else\n                        {\n                          v31 = dword_80DB620[2 * v29];\n                          if ( v31 != -1 )\n                          {\n                            while ( v31 < *((_DWORD *)&dword_80DB7A4 + 2 * v30) )\n                            {\n                              v77 = v28;\n                              v75 = v30;\n                              sub_80A2460(v21[v31++]);\n                              v28 = v77;\n                              v30 = v75;\n                            }\n                          }\n                        }\n                      }\n                      else\n                      {\n                        if ( v27 == 38 )\n                        {\n                          for ( k = pmatch[0].rm_so; k < dword_80DB7A4; k = v76 )\n                          {\n                            v76 = k + 1;\n                            sub_80A2460(v21[k]);\n                          }\n                        }\n                        else\n                        {\n                          sub_80A2460(v27);\n                        }\n                        v28 = j;\n                      }\n                    }\n                    v17 = v74;\n                  }\n                  v70 = rm_so == v61;\n                  v33 = v21[v61];\n                  if ( rm_so == v61 )\n                  {\n                    if ( v33 )\n                    {\n                      sub_80A2460(v33);\n                      ++v61;\n                    }\n                    else\n                    {\n                      v68 = 1;\n                    }\n                  }\n                  v21 += v61;\n                  if ( *(_DWORD *)(i + 40) )\n                    goto LABEL_109;\n                }\n                else\n                {\n                  while ( 1 )\n                  {\n                    v24 = v21[v23];\n                    if ( v61 <= v23 )\n                      break;\n                    v72 = v23;\n                    sub_80A2460(v24);\n                    v23 = v72 + 1;\n                  }\n                  v25 = v61;\n                  if ( v61 < 0 )\n                    v25 = 0;\n                  v21 += v25;\n                  if ( rm_so == v61 && v24 )\n                  {\n                    ++v21;\n                    sub_80A2460(v24);\n                  }\n                }\n                if ( !*v21 )\n                {\n                  if ( v68 )\n                  {\n                    sub_80A2460(0);\n                    goto LABEL_110;\n                  }\n                  v68 = 1;\n                }\n              }\n              while ( regexec(preg, v21, 0xAu, pmatch, 1) != 1 );\n              do\n              {\nLABEL_109:\n                v62 = *v21++;\n                sub_80A2460(v62);\n              }\n              while ( v62 );\nLABEL_110:\n              free(v1);\n              v1 = (char *)dword_80DB804;\n              if ( v17 )\n              {\n                if ( (*(_BYTE *)(i + 44) & 4) != 0 )\n                  sub_80A24A3((_BYTE *)dword_80DB804, unk_80DB780, &v78, i, v67);\n                v34 = *(_DWORD *)(i + 32);\n                v65 = 1;\n                v35 = (char *)(i + 45);\n                if ( v34 )\nLABEL_124:\n                  sub_80A24A3(v1, v34, v35, i, v67);\n              }\n              continue;\n            case 't':\n              if ( !v65 )\n                continue;\n              v65 = 0;\nLABEL_135:\n              v43 = *(const char **)(i + 36);\n              if ( !v43 )\n                goto LABEL_174;\n              for ( i = dword_80DB7F4; ; i = *(_DWORD *)i )\n              {\n                if ( !i )\n                  sub_804D5E0(\"can't find label for jump to '%s'\", v43);\n                if ( *(_BYTE *)(i + 46) == 58 )\n                {\n                  v44 = *(const char **)(i + 36);\n                  if ( v44 )\n                  {\n                    if ( !strcmp(v44, v43) )\n                      break;\n                  }\n                }\n              }\n              continue;\n            case 'w':\n              v35 = (char *)(i + 45);\n              v34 = *(_DWORD *)(i + 32);\n              goto LABEL_124;\n            case 'x':\n              v56 = MEMORY[0x80DB788];\n              if ( !MEMORY[0x80DB788] )\n                v56 = (char *)sub_804DB2E(1u);\n              MEMORY[0x80DB788] = v1;\n              v1 = v56;\n              v67 = 10;\n              continue;\n            case 'y':\n              v18 = v1;\nLABEL_148:\n              if ( !*v18 )\n                continue;\n              v47 = *(_DWORD *)(i + 36);\n              v45 = 0;\n              break;\n            default:\n              continue;\n          }\n          while ( 1 )\n          {\n            v46 = *(_BYTE *)(v47 + v45);\n            if ( !v46 )\n              goto LABEL_147;\n            if ( v46 == *v18 )\n              break;\n            v45 += 2;\n          }\n          *v18 = *(_BYTE *)(v47 + v45 + 1);\nLABEL_147:\n          ++v18;\n          goto LABEL_148;\n        }\n      }\n    }\nLABEL_174:\n    if ( !(_DWORD)qword_80DB778 )\n      sub_80A24A3(v1, unk_80DB780, &v78, i, v67);\nLABEL_176:\n    sub_80A2562(&v78);\n    free(v1);\n    result = v58;\n    v1 = ptr;\n  }\n  return result;\n}\n"
    ],
    "sub_80A2F06": [
        "0x80a2f06",
        "int __cdecl sub_80A2F06(int a1, int a2)\n{\n  const char *v2; // eax\n  int v3; // esi\n  char v4; // si\n  const char **v5; // ebx\n  const char *v6; // eax\n  const char *v7; // eax\n  int v8; // ecx\n  const char *v9; // eax\n  const char *v10; // eax\n  int v11; // esi\n  char *v12; // esi\n  _DWORD *i; // eax\n  int v15; // [esp+0h] [ebp-84h]\n  char *ptr; // [esp+4h] [ebp-80h]\n  int v17; // [esp+8h] [ebp-7Ch] BYREF\n  int v18; // [esp+Ch] [ebp-78h] BYREF\n  const char *v19[29]; // [esp+10h] [ebp-74h] BYREF\n\n  dword_80DB7F8 = (int)&dword_80DB7F4;\n  v2 = *(const char **)(a2 + 4);\n  if ( !v2 || (v3 = strcmp(v2, \"--version\")) != 0 )\n  {\n    v18 = 0;\n    v17 = 0;\n    v19[0] = 0;\n    v4 = sub_80ABEC2(a2, \"^i::rEne:*f:*\", \"in-place\", v19, &v17, &v18, &qword_80DB778);\n    v5 = (const char **)(a2 + 4 * optind);\n    v15 = v4 & 1;\n    if ( (v4 & 1) != 0 )\n      dword_80DBB84 = sub_80A1D44;\n    if ( (v4 & 6) != 0 )\n      HIDWORD(qword_80DB778) |= 1u;\n    while ( v17 )\n    {\n      v6 = (const char *)sub_80AFB01(v15);\n      sub_80A2428(v6);\n    }\n    while ( v18 )\n    {\n      sub_80AFB01(v15);\n      sub_80B3D9B();\n      while ( 1 )\n      {\n        v7 = (const char *)sub_80AB85A();\n        if ( !v7 )\n          break;\n        ptr = (char *)v7;\n        sub_80A1FBC(v7);\n        free(ptr);\n      }\n      sub_80AB218(v8, 0);\n    }\n    if ( (v4 & 0x30) == 0 )\n    {\n      v9 = *v5;\n      if ( !*v5 )\n        sub_804CDC2();\n      ++v5;\n      sub_80A2428(v9);\n    }\n    sub_80A1FBC(&data);\n    unk_80DB780 = (time_t)stdout;\n    dword_80DB798 = (char *)v5;\n    if ( *v5 )\n    {\n      while ( 1 )\n      {\n        v10 = *v5;\n        if ( v15 )\n        {\n          if ( stat64() )\n          {\n            sub_804D3F1(*v5);\n            *((_BYTE *)&MEMORY[0x80DB788] + 4) = 1;\n            ++*(&MEMORY[0x80DB788] + 2);\n          }\n          else\n          {\n            *(&unk_80DB780 + 1) = (time_t)sub_804DDBF(\"%sXXXXXX\", *v5);\n            v11 = sub_804DD54((const char *)*(&unk_80DB780 + 1));\n            unk_80DB780 = sub_80B3D6E();\n            fchmod(v11, (__mode_t)v19[5]);\n            fchown(v11, (__uid_t)v19[7], (__gid_t)v19[8]);\n            sub_80A268B();\n            fclose((FILE *)unk_80DB780);\n            unk_80DB780 = (time_t)stdout;\n            if ( v19[0] )\n            {\n              v12 = sub_804DDBF(\"%s%s\", *v5, v19[0]);\n              sub_804DC43(*v5, v12);\n              free(v12);\n            }\n            sub_804DC43((const char *)*(&unk_80DB780 + 1), *v5);\n            free((void *)*(&unk_80DB780 + 1));\n            *(&unk_80DB780 + 1) = 0;\n            for ( i = (_DWORD *)dword_80DB7F4; i; i = (_DWORD *)*i )\n            {\n              i[4] = i[5];\n              i[6] = i[7];\n            }\n          }\n        }\n        else if ( *v10 == 45 && !v10[1] )\n        {\n          *v5 = \"standard input\";\n          sub_80A268B();\n        }\n        if ( !*++v5 )\n          break;\n        ++*(&MEMORY[0x80DB788] + 3);\n      }\n    }\n    else\n    {\n      if ( v15 )\n        sub_804D5E0(\"%s requires an argument\", \"-i\");\n      *v5 = \"standard input\";\n    }\n    sub_80A268B();\n    return *((char *)&MEMORY[0x80DB788] + 4);\n  }\n  else\n  {\n    puts(\"This is not GNU sed version 4.0\");\n  }\n  return v3;\n}\n"
    ],
    "sub_80A3191": [
        "0x80a3191",
        "_BYTE *sub_80A3191()\n{\n  int i; // ecx\n  _BYTE *result; // eax\n\n  for ( i = dword_80DBB80; ; *(_DWORD *)(i + 8) = result + 1 )\n  {\n    result = *(_BYTE **)(i + 8);\n    if ( *result != 32 && (*result == 10 || (unsigned __int8)(*result - 9) > 4u) )\n      break;\n    if ( (unsigned int)result >= *(_DWORD *)(i + 4) - 1 )\n      break;\n  }\n  return result;\n}\n"
    ],
    "sub_80A31C1": [
        "0x80a31c1",
        "int sub_80A31C1()\n{\n  int result; // eax\n\n  result = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 128) = 26;\n  *(_BYTE *)(result + 94) = 0;\n  return result;\n}\n"
    ],
    "sub_80A31D5": [
        "0x80a31d5",
        "char sub_80A31D5()\n{\n  unsigned int v0; // edx\n  char result; // al\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 128);\n  if ( v0 <= 0x19 )\n    return v0 + 97;\n  result = 68;\n  if ( v0 != 26 )\n    return v0 == 27 ? 85 : 68;\n  return result;\n}\n"
    ],
    "sub_80A31FE": [
        "0x80a31fe",
        "_BYTE *__usercall sub_80A31FE@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // esi\n  _BYTE *v4; // ebx\n  int v5; // edi\n\n  v3 = a2 - a1;\n  v4 = a1;\n  if ( a2 - a1 < 0 )\n  {\n    v3 = a1 - a2;\n    v4 = a2;\n  }\n  v5 = dword_80DBB80 + 4 * a3;\n  free(*(void **)(v5 + 136));\n  *(_DWORD *)(v5 + 136) = sub_804DB5D(v4, v3 + 1);\n  return v4;\n}\n"
    ],
    "sub_80A3237": [
        "0x80a3237",
        "_BYTE *__usercall sub_80A3237@<eax>(_BYTE *a1@<eax>, unsigned __int8 a2@<dl>)\n{\n  int v3; // eax\n  char v4; // bl\n  int v5; // edx\n  _BYTE *result; // eax\n  int v7; // edi\n\n  v3 = (strchr(\"()[]{}\", a2) - \"()[]{}\") ^ 1;\n  v4 = asc_80D8020[v3];\n  v5 = ((2 * (_BYTE)v3) & 2) - 1;\n  result = a1;\n  v7 = 1;\n  while ( 1 )\n  {\n    result += v5;\n    if ( *(_DWORD *)dword_80DBB80 > (unsigned int)result || *(_DWORD *)(dword_80DBB80 + 4) <= (unsigned int)result )\n      break;\n    if ( *result == a2 )\n      ++v7;\n    if ( *result == v4 && !--v7 )\n      return result;\n  }\n  return 0;\n}\n"
    ],
    "sub_80A329C": [
        "0x80a329c",
        "void __cdecl __noreturn sub_80A329C(int val)\n{\n  signal(2, sub_80A329C);\n  siglongjmp((struct __jmp_buf_tag *)(dword_80DBB80 + 368), val);\n}\n"
    ],
    "sub_80A32BC": [
        "0x80a32bc",
        "char sub_80A32BC()\n{\n  int v0; // ebx\n  char result; // al\n\n  v0 = dword_80DBB80;\n  sub_804DA14(6, (struct termios *)(dword_80DBB80 + 404), 0);\n  result = *(_BYTE *)(v0 + 423);\n  *(_BYTE *)(v0 + 92) = result;\n  return result;\n}\n"
    ],
    "sub_80A32E0": [
        "0x80a32e0",
        "_BOOL4 sub_80A32E0()\n{\n  int v0; // ebx\n  _BOOL4 result; // eax\n\n  v0 = dword_80DBB80;\n  result = sub_804D878(0, (int *)(dword_80DBB80 + 40), (int *)(dword_80DBB80 + 36));\n  if ( *(_DWORD *)(v0 + 36) > 0x1000u )\n    *(_DWORD *)(v0 + 36) = 4096;\n  if ( *(_DWORD *)(v0 + 40) > 0x1000u )\n    *(_DWORD *)(v0 + 40) = 4096;\n  return result;\n}\n"
    ],
    "sub_80A3316": [
        "0x80a3316",
        "char sub_80A3316()\n{\n  char result; // al\n\n  result = 32;\n  memset(*(void **)(dword_80DBB80 + 76), 32, *(_DWORD *)(dword_80DBB80 + 80));\n  return result;\n}\n"
    ],
    "sub_80A332A": [
        "0x80a332a",
        "int __usercall sub_80A332A@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // esi\n  size_t v5; // eax\n  int v6; // ecx\n  int v7; // edx\n  int v8; // ebx\n  int result; // eax\n\n  v4 = dword_80DBB80;\n  free(*(void **)(dword_80DBB80 + 76));\n  v5 = a2 * a1 + 8;\n  *(_DWORD *)(v4 + 80) = v5;\n  *(_DWORD *)(v4 + 76) = sub_804DAFA(v5);\n  sub_80A3316();\n  v6 = a2;\n  v7 = 1;\n  v8 = a1 - 1;\n  while ( 1 )\n  {\n    result = *(_DWORD *)(v4 + 76);\n    if ( v8 <= v7 )\n      break;\n    *(_BYTE *)(result + v6) = 126;\n    ++v7;\n    v6 += a2;\n  }\n  return result;\n}\n"
    ],
    "sub_80A3374": [
        "0x80a3374",
        "char *__usercall sub_80A3374@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // esi\n  int v4; // ecx\n  int v5; // ebx\n  unsigned int v6; // edx\n  void *v7; // eax\n  size_t v8; // edx\n  char *v9; // eax\n  int v10; // edx\n  int v11; // edi\n  unsigned int v13; // [esp+0h] [ebp-18h]\n  int v14; // [esp+4h] [ebp-14h]\n\n  v2 = 0;\n  if ( a2 > 0 )\n  {\n    v4 = a2;\n    v5 = dword_80DBB80;\n    v6 = a2 + *(_DWORD *)(dword_80DBB80 + 4);\n    *(_DWORD *)(dword_80DBB80 + 4) = v6;\n    v7 = *(void **)v5;\n    v2 = 0;\n    if ( v6 >= *(_DWORD *)v5 + *(_DWORD *)(v5 + 12) )\n    {\n      v14 = v4;\n      v8 = v6 - *(_DWORD *)v5 + 10240;\n      *(_DWORD *)(v5 + 12) = v8;\n      v9 = (char *)sub_804DB13(v7, v8);\n      v2 = &v9[-*(_DWORD *)v5];\n      *(_DWORD *)(v5 + 72) += v2;\n      *(_DWORD *)(v5 + 8) += v2;\n      *(_DWORD *)(v5 + 4) += v2;\n      a1 = &a1[(_DWORD)v2];\n      v10 = 0;\n      v4 = v14;\n      do\n      {\n        v11 = *(_DWORD *)(v5 + 4 * v10 + 248);\n        if ( v11 )\n          *(_DWORD *)(v5 + 4 * v10 + 248) = &v2[v11];\n        ++v10;\n      }\n      while ( v10 != 28 );\n      *(_DWORD *)v5 = v9;\n    }\n    v13 = v4;\n    memmove(&a1[v4], a1, *(_DWORD *)(v5 + 4) - v4 - (_DWORD)a1);\n    memset(a1, 32, v13);\n  }\n  return v2;\n}\n"
    ],
    "sub_80A341E": [
        "0x80a341e",
        "char *__usercall sub_80A341E@<eax>(char *result@<eax>, int a2@<edx>, char a3@<cl>)\n{\n  char *v3; // ebp\n  int v4; // eax\n  char v5; // dl\n  int v6; // edx\n  char v7; // dl\n  int *v8; // ebx\n  int v9; // edx\n  unsigned int v10; // [esp+0h] [ebp-18h]\n  char v11; // [esp+4h] [ebp-14h]\n\n  while ( 1 )\n  {\n    v3 = result;\n    v10 = a2;\n    v11 = a3;\n    if ( a3 == 5 )\n      break;\n    if ( a3 == 64 )\n      return result;\n    if ( a3 != 4 )\n      goto LABEL_22;\n    if ( a2 != 1 )\n      return result;\n    result = (char *)dword_80DBB80;\n    v7 = *(_BYTE *)(dword_80DBB80 + 5108);\n    if ( v7 != 1 )\n    {\n      if ( !v7 )\n      {\nLABEL_19:\n        v6 = *((_DWORD *)result + 1278) + 1;\n        *((_DWORD *)result + 1278) = v6;\n        goto LABEL_11;\n      }\n      if ( v7 == 64 )\n      {\n        *(_BYTE *)(dword_80DBB80 + 5108) = 0;\n        *((_DWORD *)result + 1279) = v3;\n        goto LABEL_19;\n      }\nLABEL_22:\n      v8 = (int *)dword_80DBB80;\n      if ( (a3 & 0xFD) == 1 )\n      {\n        if ( *(char **)(dword_80DBB80 + 4) == &v3[v10] )\n          --v10;\n        result = (char *)sub_804DB2E(v10 + 13);\n        qmemcpy(result + 13, v3, v10);\n      }\n      else\n      {\n        result = (char *)sub_804DB2E(0x10u);\n      }\n      *((_DWORD *)result + 2) = v10;\n      v9 = *v8;\n      if ( (v11 & 0x20) != 0 )\n        *((_DWORD *)result + 1) = v8[1279] - v9;\n      else\n        *((_DWORD *)result + 1) = &v3[-v9];\n      result[12] = v11 & 0xDF;\n      *(_DWORD *)result = v8[1344];\n      v8[1344] = (int)result;\n      ++v8[5];\n      return result;\n    }\n    sub_80A36B1();\n    a3 = 4;\nLABEL_21:\n    a2 = 1;\n    result = v3;\n  }\n  if ( a2 != 1 )\n    return result;\n  v4 = dword_80DBB80;\n  v5 = *(_BYTE *)(dword_80DBB80 + 5108);\n  if ( v5 == 1 )\n    goto LABEL_10;\n  if ( !v5 )\n  {\n    sub_80A36B1();\n    a3 = 5;\n    goto LABEL_21;\n  }\n  if ( v5 != 64 )\n    goto LABEL_22;\n  *(_BYTE *)(dword_80DBB80 + 5108) = 1;\nLABEL_10:\n  *(_DWORD *)(v4 + 5116) = v3;\n  v6 = *(_DWORD *)(v4 + 5112) + 1;\n  *(_DWORD *)(v4 + 5112) = v6;\n  result = (char *)(v4 - v6);\n  result[5376] = *v3;\nLABEL_11:\n  if ( v6 == 256 )\n    return (char *)sub_80A36B1();\n  return result;\n}\n"
    ],
    "sub_80A359D": [
        "0x80a359d",
        "char *__usercall sub_80A359D@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)\n{\n  const void *v3; // edi\n  char *v4; // esi\n  unsigned int *v5; // ebx\n  unsigned int v6; // ebp\n  unsigned int v7; // eax\n  unsigned int v8; // eax\n  unsigned int v9; // edx\n  int v11; // [esp+0h] [ebp-18h]\n  size_t n; // [esp+4h] [ebp-14h]\n\n  if ( a2 >= (unsigned int)a1 )\n  {\n    v3 = (const void *)(a2 + 1);\n    v4 = a1;\n  }\n  else\n  {\n    v3 = a1 + 1;\n    v4 = (char *)a2;\n  }\n  v11 = a2 - (_DWORD)a1 + 1;\n  v5 = (unsigned int *)dword_80DBB80;\n  n = *(_DWORD *)(dword_80DBB80 + 4) - (_DWORD)v3;\n  switch ( a3 )\n  {\n    case 2:\n      LOBYTE(a3) = 3;\nLABEL_10:\n      sub_80A341E(a1, v11, a3);\n      break;\n    case 3:\n      LOBYTE(a3) = 5;\n      goto LABEL_10;\n    case 1:\n      goto LABEL_10;\n  }\n  v6 = v5[5];\n  v5[5] = v6 - 1;\n  if ( *v5 <= (unsigned int)v3 )\n  {\n    v7 = v5[1];\n    if ( v7 >= (unsigned int)v3 && *v5 <= (unsigned int)v4 && v7 > (unsigned int)v4 )\n    {\n      v5[5] = v6;\n      if ( v7 > (unsigned int)v3 )\n        memmove(v4, v3, n);\n      v8 = v5[1] - v11;\n      v5[1] = v8;\n      if ( v8 <= (unsigned int)v4 )\n        v4 = (char *)(v8 - 1);\n      v9 = *v5;\n      if ( v8 <= *v5 )\n      {\n        v5[1] = v9;\n        return (char *)v9;\n      }\n    }\n  }\n  return v4;\n}\n"
    ],
    "sub_80A364E": [
        "0x80a364e",
        "char *__usercall sub_80A364E@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4, int a5)\n{\n  char *v5; // ebx\n  char *v6; // esi\n  char *v7; // eax\n\n  v5 = a1;\n  v6 = a2;\n  if ( a1 > a2 )\n  {\n    v5 = a2;\n    v6 = a1;\n  }\n  if ( a3 <= 0 )\n  {\n    v7 = v5;\n    if ( *v5 == 10 )\n      return v5;\n    while ( v7 + 1 <= v6 )\n    {\n      if ( v7[1] == 10 )\n      {\n        v6 = v7;\n        break;\n      }\n      ++v7;\n    }\n  }\n  sub_80A31FE(v5, v6, *(_DWORD *)(dword_80DBB80 + 128));\n  if ( a4 == 1 )\n    return sub_80A359D(v5, (unsigned int)v6, a5);\n  return v5;\n}\n"
    ],
    "sub_80A36B1": [
        "0x80a36b1",
        "char *sub_80A36B1()\n{\n  int v0; // ebx\n  int v1; // edx\n  char *result; // eax\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 5112);\n  if ( v1 > 0 )\n  {\n    result = sub_80A341E((char *)(dword_80DBB80 - v1 + 5376), v1, *(_BYTE *)(dword_80DBB80 + 5108) | 0x20);\n    *(_BYTE *)(v0 + 5108) = 64;\n    *(_DWORD *)(v0 + 5112) = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80A36EF": [
        "0x80a36ef",
        "unsigned int sub_80A36EF()\n{\n  unsigned int result; // eax\n\n  sub_80A36B1();\n  result = *(_DWORD *)(dword_80DBB80 + 8);\n  if ( result > *(_DWORD *)dword_80DBB80 && *(_BYTE *)(result - 1) != 10 )\n    *(_DWORD *)(dword_80DBB80 + 8) = --result;\n  return result;\n}\n"
    ],
    "sub_80A370C": [
        "0x80a370c",
        "_BYTE *sub_80A370C()\n{\n  _BYTE *result; // eax\n\n  sub_80A36B1();\n  result = *(_BYTE **)(dword_80DBB80 + 8);\n  if ( (unsigned int)result < *(_DWORD *)(dword_80DBB80 + 4) - 1 && *result != 10 )\n    *(_DWORD *)(dword_80DBB80 + 8) = ++result;\n  return result;\n}\n"
    ],
    "sub_80A372C": [
        "0x80a372c",
        "char *sub_80A372C(char *format, ...)\n{\n  int v1; // ebx\n  char *v2; // esi\n  char *result; // eax\n  va_list __varargs; // [esp+14h] [ebp+8h] BYREF\n\n  va_start(__varargs, format);\n  v1 = dword_80DBB80;\n  v2 = (char *)(dword_80DBB80 + 492);\n  strcpy((char *)(dword_80DBB80 + 492), \"\\x1B[7m\");\n  vsprintf((char *)(v1 + 496), format, __varargs);\n  result = strcat(v2, \"\\x1B[m\");\n  *(_DWORD *)(v1 + 60) = 8;\n  return result;\n}\n"
    ],
    "sub_80A3774": [
        "0x80a3774",
        "char *__usercall sub_80A3774@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // edi\n  char *i; // ebx\n  char v3; // dl\n  int v4; // ebp\n  char v5; // al\n  char v6; // al\n  _WORD *v7; // ecx\n  char v9; // [esp+3h] [ebp-91h]\n  char dest[144]; // [esp+4h] [ebp-90h] BYREF\n\n  dest[0] = 0;\n  v1 = \"(NULL)\";\n  if ( *a1 )\n    v1 = a1;\n  for ( i = dest; ; i = (char *)v7 )\n  {\n    v3 = *v1;\n    if ( !*v1 )\n      break;\n    if ( *v1 < 0 )\n    {\n      if ( v3 == -101 )\n      {\n        strcpy(i, \"\\x1B[m\");\n        i += 3;\n        v4 = 1;\n        v5 = 46;\n        v3 = -101;\n        goto LABEL_15;\n      }\nLABEL_14:\n      v5 = *v1;\n      v4 = 0;\n      goto LABEL_15;\n    }\n    if ( (unsigned __int8)v3 <= 0x1Fu )\n    {\n      v6 = *v1;\n    }\n    else\n    {\n      v6 = 127;\n      if ( v3 != 127 )\n        goto LABEL_14;\n    }\n    *i = 94;\n    v5 = v6 | 0x40;\n    ++i;\n    v4 = 0;\n    if ( v5 == 127 )\n      v5 = 63;\nLABEL_15:\n    v7 = i + 1;\n    *i = v5;\n    i[1] = 0;\n    if ( v4 )\n    {\n      v9 = v3;\n      strcpy(i + 1, \"\\x1B[7m\");\n      v7 = i + 5;\n      v3 = v9;\n    }\n    if ( v3 == 10 )\n    {\n      *v7 = 36;\n      v7 = (_WORD *)((char *)v7 + 1);\n    }\n    if ( (char *)v7 - dest > 118 )\n      return sub_80A372C(\"'%s' is not implemented\", dest);\n    ++v1;\n  }\n  return sub_80A372C(\"'%s' is not implemented\", dest);\n}\n"
    ],
    "sub_80A3847": [
        "0x80a3847",
        "int sub_80A3847(char *format, ...)\n{\n  int v1; // ebx\n  int result; // eax\n  va_list __varargs; // [esp+Ch] [ebp+8h] BYREF\n\n  va_start(__varargs, format);\n  v1 = dword_80DBB80;\n  result = vsprintf((char *)(dword_80DBB80 + 492), format, __varargs);\n  *(_DWORD *)(v1 + 60) = 1;\n  return result;\n}\n"
    ],
    "sub_80A386F": [
        "0x80a386f",
        "char *__usercall sub_80A386F@<eax>(char *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  const char *v4; // ebx\n  int v6; // eax\n  unsigned int v7; // ebp\n  char v8; // cl\n  char *v9; // edx\n  int v10; // ecx\n  unsigned __int8 v11; // al\n  int v12; // ecx\n  char *v14; // [esp+0h] [ebp-14h]\n\n  v4 = a2;\n  v6 = strlen(a2);\n  v7 = v6;\n  v8 = 0;\n  if ( a3 == 2 )\n    v8 = 2;\n  sub_80A341E(a1, v6, v8);\n  v9 = sub_80A3374(a1, v7);\n  qmemcpy(&v9[(_DWORD)a1], v4, v7);\n  v10 = 0;\n  while ( *v4 )\n  {\n    if ( *v4 == 10 )\n      ++v10;\n    ++v4;\n  }\n  v14 = v9;\n  v11 = sub_80A31D5();\n  sub_80A3847(\"Put %d lines (%d chars) from [%c]\", v12, v7, v11);\n  return v14;\n}\n"
    ],
    "sub_80A38E2": [
        "0x80a38e2",
        "char *__usercall sub_80A38E2@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)\n{\n  char v6; // al\n  char *v7; // edi\n  char v8; // bl\n  bool v9; // cf\n  int v10; // edx\n  int v12; // [esp+0h] [ebp-14h]\n  int v13; // [esp+0h] [ebp-14h]\n\n  while ( 1 )\n  {\n    v6 = *a1;\n    v7 = &a1[a3];\n    v8 = a1[a3];\n    switch ( a4 )\n    {\n      case 1:\n        if ( v8 == 32 )\n          return a1;\n        if ( (unsigned __int8)(v8 - 9) > 4u )\n        {\nLABEL_4:\n          if ( v8 == 10 )\n          {\n            if ( a2 == 1 )\n              return a1;\n            a2 = 1;\n          }\n          break;\n        }\n        v10 = v8 == 10;\nLABEL_23:\n        if ( !v10 )\n          return a1;\n        goto LABEL_4;\n      case 2:\n        if ( v6 == 32 )\n          return a1;\n        if ( (unsigned __int8)(v6 - 9) <= 4u )\n        {\n          LOBYTE(v10) = v6 == 10;\n          goto LABEL_20;\n        }\n        break;\n      case 3:\n        if ( v6 == 32 )\n          break;\n        LOBYTE(v10) = (unsigned __int8)(v6 - 9) <= 4u;\nLABEL_20:\n        v10 = (unsigned __int8)v10;\n        v8 = *a1;\n        goto LABEL_23;\n      case 4:\n        v13 = a3;\n        v10 = *(unsigned __int8 *)strchrnul();\n        a3 = v13;\n        goto LABEL_23;\n      case 5:\n        if ( (unsigned __int8)(v8 - 48) > 9u )\n        {\n          if ( (unsigned __int8)((a1[a3] | 0x20) - 97) <= 0x19u )\n            goto LABEL_4;\n          if ( v8 != 95 )\n            return a1;\n        }\n        break;\n      default:\n        return a1;\n    }\n    if ( a3 == -1 )\n    {\n      v9 = *(_DWORD *)dword_80DBB80 < (unsigned int)a1;\n    }\n    else\n    {\n      v12 = *(_DWORD *)(dword_80DBB80 + 4);\n      v9 = (unsigned int)a1 < v12 - 1;\n    }\n    if ( !v9 )\n      return a1;\n    a1 = v7;\n  }\n}\n"
    ],
    "sub_80A39D8": [
        "0x80a39d8",
        "int __usercall sub_80A39D8@<eax>(int a1@<eax>, const char *a2@<edx>, int a3@<ecx>, char *a4, int a5)\n{\n  const char *v7; // ebx\n  size_t v8; // eax\n  int result; // eax\n  int v10; // ecx\n\n  v7 = (const char *)(a1 + a3);\n  v8 = strlen(a2);\n  result = strncasecmp(v7, a2, v8 - 1);\n  if ( !result || (result = strncasecmp(v7, a4, 2u)) == 0 )\n  {\n    LOBYTE(result) = *(_BYTE *)(dword_80DBB80 + 16);\n    if ( a3 )\n    {\n      LOBYTE(v10) = a5;\n      result &= ~v10;\n    }\n    else\n    {\n      result |= a5;\n    }\n    *(_BYTE *)(dword_80DBB80 + 16) = result;\n  }\n  return result;\n}\n"
    ],
    "sub_80A3A2F": [
        "0x80a3a2f",
        "int __usercall sub_80A3A2F@<eax>(size_t n@<ecx>, char *s2@<edx>, const char *a3@<eax>)\n{\n  if ( (*(_BYTE *)(dword_80DBB80 + 16) & 4) != 0 )\n    return strncasecmp(a3, s2, n);\n  else\n    return strncmp(a3, s2, n);\n}\n"
    ],
    "sub_80A3A53": [
        "0x80a3a53",
        "int __usercall sub_80A3A53@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // edi\n  int v5; // esi\n  size_t v6; // ebx\n\n  if ( a1 )\n  {\n    v5 = open64();\n    v3 = -1;\n    if ( v5 >= 0 )\n    {\n      v6 = a3 - (_DWORD)a2 + 1;\n      v3 = sub_804E586(v6, a2);\n      ftruncate64();\n      if ( v6 != v3 )\n        v3 = 0;\n      close(v5);\n    }\n  }\n  else\n  {\n    sub_80A372C(\"No current filename\");\n    return -2;\n  }\n  return v3;\n}\n"
    ],
    "sub_80A3ABA": [
        "0x80a3aba",
        "void *__usercall sub_80A3ABA@<eax>(void *a1@<eax>)\n{\n  int v1; // edx\n  int v2; // ebx\n\n  v1 = *(_DWORD *)(dword_80DBB80 + 4);\n  v2 = v1 - 1;\n  if ( v1 - 1 <= (unsigned int)a1 )\n    return a1;\n  a1 = memchr(a1, 10, v1 - (_DWORD)a1 - 1);\n  if ( a1 )\n    return a1;\n  return (void *)v2;\n}\n"
    ],
    "sub_80A3AE4": [
        "0x80a3ae4",
        "_BYTE *__usercall sub_80A3AE4@<eax>(void *a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = sub_80A3ABA(a1);\n  if ( (unsigned int)result < *(_DWORD *)(dword_80DBB80 + 4) - 1 && *result == 10 )\n    ++result;\n  return result;\n}\n"
    ],
    "sub_80A3AFE": [
        "0x80a3afe",
        "_BYTE *__usercall sub_80A3AFE@<eax>(int a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = *(_BYTE **)dword_80DBB80;\n  while ( a1 > 1 )\n  {\n    result = sub_80A3AE4(result);\n    --a1;\n  }\n  return result;\n}\n"
    ],
    "sub_80A3B17": [
        "0x80a3b17",
        "_BYTE *sub_80A3B17()\n{\n  int v0; // ebx\n  _BYTE *result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3AE4(*(void **)(dword_80DBB80 + 8));\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
    ],
    "sub_80A3B30": [
        "0x80a3b30",
        "int __usercall sub_80A3B30@<eax>(void *a1@<eax>, void *a2@<edx>)\n{\n  void *v3; // eax\n  void *v4; // edx\n  void *v5; // ebp\n  int v6; // edi\n  int v7; // esi\n  _BYTE *v8; // eax\n\n  v3 = a2;\n  if ( a2 < a1 )\n  {\n    v4 = a1;\n    a1 = v3;\n    v3 = v4;\n  }\n  v5 = sub_80A3ABA(v3);\n  v6 = dword_80DBB80;\n  v7 = 0;\n  while ( a1 <= v5 && (unsigned int)a1 <= *(_DWORD *)(v6 + 4) - 1 )\n  {\n    v8 = sub_80A3ABA(a1);\n    if ( *v8 == 10 )\n      ++v7;\n    a1 = v8 + 1;\n  }\n  return v7;\n}\n"
    ],
    "sub_80A3B76": [
        "0x80a3b76",
        "void *sub_80A3B76()\n{\n  _BYTE *v0; // eax\n  int v1; // esi\n  int v2; // ebx\n\n  v0 = *(_BYTE **)(dword_80DBB80 + 72);\n  v1 = *(_DWORD *)(dword_80DBB80 + 36);\n  v2 = 1;\n  while ( v1 != ++v2 )\n    v0 = sub_80A3AE4(v0);\n  return sub_80A3ABA(v0);\n}\n"
    ],
    "sub_80A3B9C": [
        "0x80a3b9c",
        "void *sub_80A3B9C()\n{\n  int v0; // ebx\n  void *result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3ABA(*(void **)(dword_80DBB80 + 8));\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
    ],
    "sub_80A3BB5": [
        "0x80a3bb5",
        "int __usercall sub_80A3BB5@<eax>(unsigned int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // eax\n\n  v1 = *(_DWORD *)dword_80DBB80;\n  if ( *(_DWORD *)dword_80DBB80 >= a1 )\n    return a1;\n  v2 = memrchr();\n  if ( v2 )\n    return v2 + 1;\n  return v1;\n}\n"
    ],
    "sub_80A3BDF": [
        "0x80a3bdf",
        "int __usercall sub_80A3BDF@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // eax\n\n  v1 = sub_80A3BB5(a1);\n  if ( *(_DWORD *)dword_80DBB80 < v1 && *(_BYTE *)(v1 - 1) == 10 )\n    --v1;\n  return sub_80A3BB5(v1);\n}\n"
    ],
    "sub_80A3BFA": [
        "0x80a3bfa",
        "char *__usercall sub_80A3BFA@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4)\n{\n  size_t v7; // edi\n  char *v8; // esi\n  unsigned int v9; // esi\n\n  v7 = strlen(a2);\n  if ( a3 == 1 )\n  {\n    v8 = (char *)(*(_DWORD *)(dword_80DBB80 + 4) - 1);\n    if ( !a4 )\n      v8 = sub_80A3AE4(a1);\n    while ( a1 < v8 )\n    {\n      if ( !sub_80A3A2F(v7, a2, a1) )\n        return a1;\n      ++a1;\n    }\n  }\n  else if ( a3 == -1 )\n  {\n    v9 = *(_DWORD *)dword_80DBB80;\n    if ( !a4 )\n      v9 = sub_80A3BDF((unsigned int)a1);\n    for ( a1 -= v7; (unsigned int)a1 >= v9; --a1 )\n    {\n      if ( !sub_80A3A2F(v7, a2, a1) )\n        return a1;\n    }\n  }\n  return 0;\n}\n"
    ],
    "sub_80A3C7E": [
        "0x80a3c7e",
        "int sub_80A3C7E()\n{\n  int v0; // ebx\n  int result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3BDF(*(_DWORD *)(dword_80DBB80 + 8));\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
    ],
    "sub_80A3C97": [
        "0x80a3c97",
        "int __usercall sub_80A3C97@<eax>(char *a1@<eax>, int *a2@<edx>, int a3@<esi>)\n{\n  int v3; // ebx\n  char v5; // al\n  void **v6; // edi\n  unsigned int v7; // eax\n  char v8; // al\n  unsigned __int8 v9; // al\n  void *v10; // edx\n  void *v11; // eax\n  _BYTE *v12; // edi\n  char *v13; // edi\n  void **v14; // ebp\n  char *v15; // eax\n  int v17; // [esp+0h] [ebp-14h] BYREF\n\n  v17 = a3;\n  v3 = (int)a1;\n  *a2 = -1;\n  v5 = *a1;\n  switch ( v5 )\n  {\n    case '.':\n      ++v3;\n      v6 = (void **)dword_80DBB80;\n      v7 = *(_DWORD *)(dword_80DBB80 + 8);\nLABEL_18:\n      v10 = (void *)sub_80A3BB5(v7);\n      v11 = *v6;\n      goto LABEL_9;\n    case '\\'':\n      v8 = *(_BYTE *)(v3 + 1);\n      if ( (unsigned __int8)(v8 - 65) <= 0x19u )\n        v8 += 32;\n      v3 += 2;\n      v9 = v8 - 97;\n      if ( v9 <= 0x19u )\n      {\n        v10 = *(void **)(dword_80DBB80 + 4 * v9 + 248);\n        if ( v10 )\n        {\n          v11 = *(void **)dword_80DBB80;\nLABEL_9:\n          *a2 = sub_80A3B30(v11, v10);\n        }\n      }\n      break;\n    case '/':\n      v12 = (_BYTE *)(v3 + 1);\n      v3 = strchrnul();\n      v13 = sub_804DB5D(v12, v3 - (_DWORD)v12);\n      if ( *(_BYTE *)v3 == 47 )\n        ++v3;\n      v14 = (void **)dword_80DBB80;\n      v15 = sub_80A3BFA(*(char **)(dword_80DBB80 + 8), v13, 1, 1);\n      if ( v15 )\n        *a2 = sub_80A3B30(*v14, v15);\n      free(v13);\n      break;\n    case '$':\n      ++v3;\n      v6 = (void **)dword_80DBB80;\n      v7 = *(_DWORD *)(dword_80DBB80 + 4) - 1;\n      goto LABEL_18;\n    default:\n      if ( (unsigned __int8)(v5 - 48) <= 9u )\n      {\n        sscanf((const char *)v3, \"%d%n\", a2, &v17);\n        v3 += v17;\n      }\n      break;\n  }\n  return v3;\n}\n"
    ],
    "sub_80A3D95": [
        "0x80a3d95",
        "_BYTE *__usercall sub_80A3D95@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // ebx\n  void *v5; // eax\n  _BYTE *v6; // eax\n  void *v7; // eax\n\n  sub_80A36B1();\n  v4 = dword_80DBB80;\n  while ( 1 )\n  {\n    v5 = *(void **)(v4 + 72);\n    if ( a1 <= 0 )\n      break;\n    if ( a2 == -1 )\n      v6 = (_BYTE *)sub_80A3BDF((unsigned int)v5);\n    else\n      v6 = sub_80A3AE4(v5);\n    *(_DWORD *)(v4 + 72) = v6;\n    --a1;\n  }\n  if ( *(_DWORD *)(v4 + 8) < (unsigned int)v5 )\n    *(_DWORD *)(v4 + 8) = v5;\n  v7 = sub_80A3B76();\n  if ( *(_DWORD *)(v4 + 8) > (unsigned int)v7 )\n    *(_DWORD *)(v4 + 8) = sub_80A3BB5((unsigned int)v7);\n  return sub_80A3191();\n}\n"
    ],
    "sub_80A3DE7": [
        "0x80a3de7",
        "unsigned __int8 *__usercall sub_80A3DE7@<eax>(unsigned int a1@<eax>, int a2@<edx>)\n{\n  unsigned __int8 *v3; // esi\n  int v4; // ecx\n  unsigned __int8 v5; // al\n  int v6; // ebx\n\n  v3 = (unsigned __int8 *)sub_80A3BB5(a1);\n  v4 = 0;\n  while ( v4 < a2 )\n  {\n    if ( *(_DWORD *)(dword_80DBB80 + 4) <= (unsigned int)v3 )\n      break;\n    v5 = *v3;\n    if ( *v3 == 10 )\n      break;\n    if ( v5 == 9 )\n    {\n      v6 = v4 + *(_DWORD *)(dword_80DBB80 + 84) - 1 - v4 % *(_DWORD *)(dword_80DBB80 + 84);\n    }\n    else\n    {\n      v6 = v4 + 1;\n      if ( v5 != 127 && v5 > 0x1Fu )\n        v6 = v4;\n    }\n    v4 = v6 + 1;\n    ++v3;\n  }\n  return v3;\n}\n"
    ],
    "sub_80A3E3B": [
        "0x80a3e3b",
        "int sub_80A3E3B()\n{\n  int v0; // ebx\n  int result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3BB5(*(_DWORD *)(dword_80DBB80 + 8));\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
    ],
    "sub_80A3E54": [
        "0x80a3e54",
        "_BOOL4 __usercall sub_80A3E54@<eax>(int a1@<eax>)\n{\n  if ( a1 )\n    sub_804DD8F();\n  return sub_80B2C0A(10 * a1, 1u) > 0;\n}\n"
    ],
    "sub_80A3E8D": [
        "0x80a3e8d",
        "int sub_80A3E8D()\n{\n  sub_804DD8F();\n  return sub_804D995((const struct termios *)(dword_80DBB80 + 404));\n}\n"
    ],
    "sub_80A3EA1": [
        "0x80a3ea1",
        "unsigned __int64 __usercall sub_80A3EA1@<edx:eax>(unsigned int a1@<eax>)\n{\n  unsigned __int64 v2; // [esp-8h] [ebp-8h]\n\n  v2 = __PAIR64__((unsigned int)stdout, a1);\n  fputs_unlocked();\n  return v2;\n}\n"
    ],
    "sub_80A3EB0": [
        "0x80a3eb0",
        "unsigned __int64 __usercall sub_80A3EB0@<edx:eax>(int a1@<eax>, int a2@<edx>)\n{\n  unsigned int v2; // ebx\n  unsigned int v3; // ecx\n  char s[37]; // [esp+3h] [ebp-25h] BYREF\n\n  if ( a1 < 0 )\n    a1 = 0;\n  v2 = *(_DWORD *)(dword_80DBB80 + 36);\n  if ( v2 <= a1 )\n    a1 = v2 - 1;\n  if ( a2 < 0 )\n    a2 = 0;\n  v3 = *(_DWORD *)(dword_80DBB80 + 40);\n  if ( v3 <= a2 )\n    a2 = v3 - 1;\n  sprintf(s, \"\\x1B[%u;%uH\", a1 + 1, a2 + 1);\n  return sub_80A3EA1((unsigned int)s);\n}\n"
    ],
    "sub_80A3EF9": [
        "0x80a3ef9",
        "unsigned __int64 sub_80A3EF9()\n{\n  sub_80A3EB0(*(_DWORD *)(dword_80DBB80 + 36) - 1, 0);\n  return sub_80A3EA1(0x80CABEFu);\n}\n"
    ],
    "sub_80A3F13": [
        "0x80a3f13",
        "void sub_80A3F13()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  sub_80A3EF9();\n  sub_80A3E8D();\n  signal(18, sub_80A4758);\n  signal(20, 0);\n  kill(*(_DWORD *)(dword_80DBB80 + 108), 20);\n  *v0 = v1;\n}\n"
    ],
    "sub_80A3F53": [
        "0x80a3f53",
        "int sub_80A3F53()\n{\n  char *v0; // ebx\n  int result; // eax\n\n  sub_804DD8F();\n  v0 = (char *)(dword_80DBB80 + 476);\n  while ( 1 )\n  {\n    result = sub_80B20CC(-1, v0, 0);\n    if ( result != -1 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 11 )\n    {\n      sub_80A3EF9();\n      sub_80A3E8D();\n      sub_804D5E0(\"can't read user input\");\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80A3F95": [
        "0x80a3f95",
        "int sub_80A3F95()\n{\n  int v0; // ebx\n  unsigned __int8 *v1; // eax\n  int result; // eax\n  int v3; // edx\n  int v4; // [esp+0h] [ebp-8h]\n\n  v0 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 94) )\n  {\n    result = sub_80A3F53();\n    v3 = *(_DWORD *)(v0 + 96);\n    if ( v3 <= 126 )\n    {\n      *(_DWORD *)(v0 + 96) = v3 + 1;\n      *(_BYTE *)(v0 + v3 + 692) = result;\n    }\n    else\n    {\n      v4 = result;\n      sub_80A372C(\"last_modifying_cmd overrun\");\n      return v4;\n    }\n  }\n  else\n  {\n    v1 = *(unsigned __int8 **)(dword_80DBB80 + 100);\n    if ( v1 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 100) = v1 + 1;\n      result = *v1;\n      if ( result )\n        return result;\n      free(*(void **)(v0 + 104));\n      *(_DWORD *)(v0 + 100) = 0;\n      *(_DWORD *)(v0 + 104) = 0;\n    }\n    return sub_80A3F53();\n  }\n  return result;\n}\n"
    ],
    "sub_80A4009": [
        "0x80a4009",
        "int __usercall sub_80A4009@<eax>(const char *a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  char *v4; // eax\n  char *v5; // ebx\n  int v6; // esi\n  signed int v7; // ebp\n  char *v8; // ebx\n  ssize_t v9; // eax\n  int fd; // [esp+0h] [ebp-78h]\n  __int16 v13; // [esp+18h] [ebp-60h]\n  __int64 nbytes; // [esp+34h] [ebp-44h]\n\n  v4 = *(char **)dword_80DBB80;\n  if ( *(_DWORD *)dword_80DBB80 < (unsigned int)a2 )\n    v4 = a2;\n  v5 = *(char **)(dword_80DBB80 + 4);\n  if ( v5 > v4 )\n    v5 = v4;\n  fd = open64();\n  if ( fd < 0 )\n  {\n    v6 = -1;\n    if ( !a3 )\n      sub_80A372C(\"'%s' %m\", a1);\n    return v6;\n  }\n  if ( fstat64() >= 0 )\n  {\n    if ( (v13 & 0xF000) == 0x8000 )\n    {\n      v7 = nbytes;\n      if ( nbytes > 2147483646 )\n        v7 = 0x7FFFFFFF;\n      v8 = &v5[(_DWORD)sub_80A3374(v5, v7)];\n      v9 = sub_804E5E3(fd, v8, v7);\n      v6 = v9;\n      if ( v9 >= 0 )\n      {\n        if ( v7 > v9 )\n        {\n          sub_80A359D(&v8[v9], (unsigned int)&v8[v7 - 1], 0);\n          sub_80A372C(\"can't read '%s'\", a1);\n        }\n      }\n      else\n      {\n        sub_80A372C(\"'%s' %m\", a1);\n        sub_80A359D(v8, (unsigned int)&v8[v7 - 1], 0);\n      }\n      goto LABEL_19;\n    }\n    sub_80A372C(\"'%s' is not a regular file\", a1);\n  }\n  else\n  {\n    sub_80A372C(\"'%s' %m\", a1);\n  }\n  v6 = -1;\nLABEL_19:\n  close(fd);\n  if ( a3 && (access(a1, 2) < 0 || (v13 & 0x92) == 0) )\n    *(_BYTE *)(dword_80DBB80 + 17) |= 1u;\n  return v6;\n}\n"
    ],
    "sub_80A414A": [
        "0x80a414a",
        "int *__usercall sub_80A414A@<eax>(_BYTE *a1@<eax>, unsigned int *a2@<edx>, int *a3@<ecx>)\n{\n  int v3; // ebx\n  _BYTE *v4; // edx\n  unsigned int v5; // edi\n  unsigned int v6; // eax\n  int v7; // esi\n  _BYTE *v8; // esi\n  unsigned int i; // ebp\n  _BYTE *v10; // eax\n  signed int v11; // ebp\n  signed int v12; // esi\n  signed int v13; // ecx\n  unsigned __int8 v14; // al\n  signed int v15; // edi\n  int v16; // eax\n  int v17; // ecx\n  int *result; // eax\n  _BYTE *v19; // [esp+0h] [ebp-20h]\n\n  v19 = (_BYTE *)sub_80A3BB5((unsigned int)a1);\n  v3 = dword_80DBB80;\n  v4 = *(_BYTE **)(dword_80DBB80 + 72);\n  v5 = *(_DWORD *)(dword_80DBB80 + 36) - 1;\n  if ( v4 <= v19 )\n  {\n    v10 = sub_80A3B76();\n    if ( v19 <= v10 )\n      goto LABEL_4;\n    v6 = sub_80A3B30(v10, v19);\n    if ( v5 >> 1 >= v6 )\n    {\n      v11 = 0;\n      v12 = v6 - 1;\n      while ( v12 > v11 )\n      {\n        *(_DWORD *)(v3 + 72) = sub_80A3AE4(*(void **)(v3 + 72));\n        ++v11;\n      }\n      goto LABEL_4;\n    }\n  }\n  else\n  {\n    v6 = sub_80A3B30(v19, v4);\n  }\n  *(_DWORD *)(v3 + 72) = v19;\n  v7 = 0;\n  if ( v5 >> 1 < v6 )\n  {\n    while ( v7 != v5 >> 1 )\n    {\n      *(_DWORD *)(v3 + 72) = sub_80A3BDF(*(_DWORD *)(v3 + 72));\n      ++v7;\n    }\n  }\nLABEL_4:\n  v8 = *(_BYTE **)(v3 + 72);\n  for ( i = 0; v8 != v19 && i < v5; ++i )\n    v8 = sub_80A3AE4(v8);\n  v13 = 0;\n  while ( v8 < a1 )\n  {\n    v14 = *v8;\n    if ( *v8 == 10 )\n      break;\n    if ( v14 == 9 )\n    {\n      v15 = v13 + *(_DWORD *)(v3 + 84) - 1 - v13 % *(_DWORD *)(v3 + 84);\n    }\n    else\n    {\n      v15 = v13 + 1;\n      if ( v14 != 127 && v14 > 0x1Fu )\n        v15 = v13;\n    }\n    v13 = v15 + 1;\n    ++v8;\n  }\n  if ( *(_DWORD *)(v3 + 56) > v13 )\n    *(_DWORD *)(v3 + 56) = v13;\n  v16 = *(_DWORD *)(v3 + 40);\n  if ( v16 + *(_DWORD *)(v3 + 56) <= (unsigned int)v13 )\n    *(_DWORD *)(v3 + 56) = v13 - v16 + 1;\n  if ( a1 == v19 && *a1 == 9 )\n    *(_DWORD *)(v3 + 56) = 0;\n  v17 = v13 - *(_DWORD *)(v3 + 56);\n  *a2 = i;\n  result = a3;\n  *a3 = v17;\n  return result;\n}\n"
    ],
    "sub_80A4273": [
        "0x80a4273",
        "int __usercall sub_80A4273@<eax>(int a1@<eax>)\n{\n  int v1; // ebp\n  int v2; // ebx\n  int v3; // esi\n  int v4; // esi\n  char *v5; // eax\n  signed int v6; // edi\n  char v7; // bl\n  signed int v8; // edx\n  char *v9; // ecx\n  size_t v10; // eax\n  signed int v11; // edx\n  signed int v12; // eax\n  int v13; // esi\n  unsigned int v14; // ecx\n  unsigned int v15; // edi\n  unsigned int v16; // ebx\n  char *v17; // eax\n  int v18; // ebx\n  int v19; // ebx\n  int v20; // edx\n  signed int v21; // eax\n  int v22; // edi\n  void *v23; // ebx\n  int result; // eax\n  signed int size; // [esp+0h] [ebp-28h]\n  size_t sizea; // [esp+0h] [ebp-28h]\n  unsigned int sizeb; // [esp+0h] [ebp-28h]\n  char *s; // [esp+4h] [ebp-24h]\n  unsigned int v29; // [esp+8h] [ebp-20h]\n  signed int v30; // [esp+Ch] [ebp-1Ch]\n  signed int v31; // [esp+Ch] [ebp-1Ch]\n  char *v33; // [esp+14h] [ebp-14h]\n\n  v1 = dword_80DBB80;\n  if ( !*(_DWORD *)(dword_80DBB80 + 44) )\n  {\n    v2 = *(_DWORD *)(dword_80DBB80 + 40);\n    v3 = *(_DWORD *)(dword_80DBB80 + 36);\n    sub_80A32E0();\n    a1 |= (v3 - *(_DWORD *)(v1 + 36)) | (v2 - *(_DWORD *)(v1 + 40));\n  }\n  sub_80A414A(*(_BYTE **)(v1 + 8), (unsigned int *)(v1 + 48), (int *)(v1 + 52));\n  s = *(char **)(v1 + 72);\n  v29 = 0;\nLABEL_4:\n  if ( *(_DWORD *)(v1 + 36) - 1 > v29 )\n  {\n    size = *(_DWORD *)(v1 + 56);\n    v4 = v1 + 948;\n    v5 = s;\n    v6 = 0;\n    v7 = 126;\n    while ( 1 )\n    {\n      v8 = v6;\n      if ( v6 >= (unsigned int)(*(_DWORD *)(v1 + 40) + *(_DWORD *)(v1 + 84)) )\n      {\nLABEL_29:\n        v12 = v6;\n        if ( v6 > size )\n          v12 = size;\n        v13 = v12 + v4;\n        v14 = *(_DWORD *)(v1 + 40);\n        v15 = v6 - v12;\n        if ( v14 > v15 )\n          memset((void *)(v13 + v15), 32, v14 - v15);\n        v16 = *(_DWORD *)(v1 + 4);\n        if ( v16 > (unsigned int)s )\n        {\n          v17 = (char *)memchr(s, 10, v16 - (_DWORD)s);\n          if ( !v17 )\n            v17 = (char *)(v16 - 1);\n          s = v17 + 1;\n        }\n        v18 = *(_DWORD *)(v1 + 40);\n        sizea = v18 - 1;\n        v31 = v18 - 1;\n        v19 = *(_DWORD *)(v1 + 76) + v29 * v18;\n        v20 = 0;\n        if ( a1 )\n        {\n          v21 = sizea;\n          v20 = 0;\n        }\n        else\n        {\n          while ( 1 )\n          {\n            if ( v20 > (int)sizea )\n            {\n              v21 = sizea;\n              v22 = 0;\n              goto LABEL_46;\n            }\n            if ( *(_BYTE *)(v13 + v20) != *(_BYTE *)(v19 + v20) )\n              break;\n            ++v20;\n          }\n          v21 = sizea;\n          do\n          {\n            if ( *(_BYTE *)(v13 + v21) != *(_BYTE *)(v19 + v21) )\n              break;\n            --v21;\n          }\n          while ( v20 <= v21 );\n          v22 = 1;\nLABEL_46:\n          if ( *(_DWORD *)(v1 + 56) == *(_DWORD *)(v1 + 120) )\n          {\nLABEL_50:\n            if ( sizea < v21 )\n              v21 = sizea;\n            if ( v20 > v21 )\n              v20 = 0;\n            else\n              v31 = v21;\n            if ( v22 )\n            {\n              sizeb = v31 - v20 + 1;\n              v23 = (void *)(v20 + v19);\n              qmemcpy(v23, (const void *)(v20 + v13), sizeb);\n              sub_80A3EB0(v29, v20);\n              fwrite(v23, sizeb, 1u, stdout);\n            }\n            ++v29;\n            goto LABEL_4;\n          }\n        }\n        v22 = 1;\n        goto LABEL_50;\n      }\n      if ( *(_DWORD *)(v1 + 4) <= (unsigned int)v5 )\n      {\n        v9 = v5;\n        goto LABEL_23;\n      }\n      v9 = v5 + 1;\n      v7 = *v5;\n      if ( *v5 == 10 )\n        goto LABEL_29;\n      if ( v7 >= 0 )\n      {\n        if ( (unsigned __int8)v7 > 0x1Fu )\n        {\n          if ( v7 != 127 )\n            goto LABEL_23;\nLABEL_19:\n          ++v6;\n          *(_BYTE *)(v4 + v8) = 94;\n          if ( v7 == 127 )\n            v7 = 63;\n          else\n            v7 += 64;\n          goto LABEL_23;\n        }\n        if ( v7 != 9 )\n          goto LABEL_19;\n        while ( v6 % *(_DWORD *)(v1 + 84) != *(_DWORD *)(v1 + 84) - 1 )\n          *(_BYTE *)(v4 + v6++) = 32;\n        v7 = 32;\n      }\n      else if ( v7 == -101 )\n      {\n        v7 = 46;\n      }\nLABEL_23:\n      v10 = v6 + 1;\n      *(_BYTE *)(v4 + v6) = v7;\n      v30 = *(_DWORD *)(v1 + 84);\n      v11 = v6 + 1;\n      if ( v6 + 1 > size )\n        v11 = size;\n      ++v6;\n      if ( v30 <= v11 )\n      {\n        v33 = v9;\n        memmove((void *)(v1 + 948), (const void *)(v4 + v30), v10);\n        v6 -= v30;\n        size -= v30;\n        v9 = v33;\n      }\n      if ( *(_DWORD *)(v1 + 4) <= (unsigned int)v9 )\n        goto LABEL_29;\n      v5 = v9;\n    }\n  }\n  sub_80A3EB0(*(_DWORD *)(v1 + 48), *(_DWORD *)(v1 + 52));\n  result = *(_DWORD *)(v1 + 56);\n  *(_DWORD *)(v1 + 120) = result;\n  return result;\n}\n"
    ],
    "sub_80A44B8": [
        "0x80a44b8",
        "const char *__usercall sub_80A44B8@<eax>(const char *a1@<eax>)\n{\n  int v2; // esi\n  const char *v3; // edi\n  signed int v4; // ebx\n  unsigned int v5; // eax\n  int v6; // edx\n\n  v2 = dword_80DBB80;\n  v3 = (const char *)(dword_80DBB80 + 820);\n  strcpy((char *)(dword_80DBB80 + 820), a1);\n  *(_DWORD *)(v2 + 64) = 0;\n  sub_80A3EF9();\n  sub_80A3EA1((unsigned int)a1);\n  v4 = strlen(v3);\n  while ( v4 <= 127 )\n  {\n    v5 = sub_80A3F95();\n    if ( v5 <= 0x1B )\n    {\n      v6 = 134226944;\n      if ( _bittest(&v6, v5) )\n        break;\n    }\n    if ( v5 == 8 || *(unsigned __int8 *)(v2 + 92) == v5 || v5 == 127 )\n    {\n      --v4;\n      *(_BYTE *)(v2 + v4 + 820) = 0;\n      sub_80A3EA1((unsigned int)\"\\b \\b\");\n      if ( v4 <= 0 )\n        break;\n    }\n    else if ( v5 - 1 <= 0xFE )\n    {\n      *(_BYTE *)(v2 + v4++ + 820) = v5;\n      *(_BYTE *)(v2 + v4 + 820) = 0;\n      sub_804DD98(v5);\n    }\n  }\n  sub_80A4273(0);\n  return v3;\n}\n"
    ],
    "sub_80A4567": [
        "0x80a4567",
        "int __usercall sub_80A4567@<eax>(int a1@<eax>)\n{\n  sub_80A3EB0(0, 0);\n  sub_80A3EA1(0x80CA4D0u);\n  sub_80A3316();\n  *(_DWORD *)(dword_80DBB80 + 64) = 0;\n  sub_80A4273(a1);\n  return sub_80A45D2();\n}\n"
    ],
    "sub_80A459B": [
        "0x80a459b",
        "int sub_80A459B()\n{\n  int v0; // eax\n\n  sub_80A3EA1((unsigned int)\"\\x1B[7m\");\n  sub_80A3EA1((unsigned int)\"[Hit return to continue]\");\n  sub_80A3EA1(0x80CAC5Bu);\n  do\n    v0 = sub_80A3F95();\n  while ( v0 != 13 && v0 != 10 );\n  return sub_80A4567(1);\n}\n"
    ],
    "sub_80A45D2": [
        "0x80a45d2",
        "int sub_80A45D2()\n{\n  int v0; // ebx\n  int v1; // esi\n  void *v2; // edi\n  int v3; // ebp\n  int v4; // ecx\n  int v5; // edi\n  unsigned int v6; // edi\n  const char *v7; // eax\n  unsigned int v8; // eax\n  unsigned __int8 *v9; // ecx\n  unsigned int v10; // edx\n  int v11; // esi\n  int v13; // [esp+0h] [ebp-24h]\n  const char *v14; // [esp+0h] [ebp-24h]\n  const char *v15; // [esp+4h] [ebp-20h]\n  int v16; // [esp+8h] [ebp-1Ch]\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 60);\n  if ( v1 )\n  {\n    v1 = 0;\n    v10 = 0;\n  }\n  else\n  {\n    v2 = *(void **)(dword_80DBB80 + 8);\n    v3 = sub_80A3B30(*(void **)dword_80DBB80, v2);\n    v4 = *(_DWORD *)(v0 + 20);\n    if ( v4 != *(_DWORD *)(v0 + 24) )\n    {\n      v13 = *(_DWORD *)(v0 + 20);\n      *(_DWORD *)(v0 + 124) = v3 + sub_80A3B30(v2, (void *)(*(_DWORD *)(v0 + 4) - 1)) - 1;\n      v4 = v13;\n      *(_DWORD *)(v0 + 24) = v13;\n    }\n    v5 = *(_DWORD *)(v0 + 124);\n    if ( v5 <= 0 )\n    {\n      *(_DWORD *)(v0 + 124) = 0;\n      v3 = 0;\n      v16 = 100;\n    }\n    else\n    {\n      v16 = 100 * v3 / v5;\n    }\n    v6 = *(_DWORD *)(v0 + 40);\n    if ( v6 > 0xC7 )\n      v6 = 199;\n    v15 = &data;\n    if ( v4 )\n      v15 = \" [Modified]\";\n    v14 = &data;\n    if ( *(_BYTE *)(v0 + 17) )\n      v14 = \" [Readonly]\";\n    v7 = *(const char **)(v0 + 68);\n    if ( !v7 )\n      v7 = \"No file\";\n    v8 = snprintf(\n           (char *)(v0 + 492),\n           v6 + 1,\n           \"%c %s%s%s %d/%d %d%%\",\n           (unsigned __int8)byte_80D858A[*(_BYTE *)(v0 + 19) & 3],\n           v7,\n           v14,\n           v15,\n           v3,\n           *(_DWORD *)(v0 + 124),\n           v16);\n    v9 = (unsigned __int8 *)(v0 + 492);\n    v10 = v6;\n    if ( v6 > v8 )\n      v10 = v8;\n    while ( v0 + 492 + v10 > (unsigned int)v9 )\n      v1 += *v9++;\n  }\n  if ( *(_DWORD *)(v0 + 60) || v10 && *(_DWORD *)(v0 + 64) != v1 )\n  {\n    *(_DWORD *)(v0 + 64) = v1;\n    sub_80A3EF9();\n    sub_80A3EA1(v0 + 492);\n    v11 = *(_DWORD *)(v0 + 60);\n    if ( v11 )\n    {\n      if ( strlen((const char *)(v0 + 492)) - v11 + 1 > *(_DWORD *)(v0 + 40) - 1 )\n      {\n        *(_DWORD *)(v0 + 60) = 0;\n        sub_80A459B();\n      }\n      *(_DWORD *)(v0 + 60) = 0;\n    }\n    sub_80A3EB0(*(_DWORD *)(v0 + 48), *(_DWORD *)(v0 + 52));\n  }\n  return sub_804DD8F();\n}\n"
    ],
    "sub_80A4758": [
        "0x80a4758",
        "void sub_80A4758()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  sub_80A32BC();\n  *(_DWORD *)(dword_80DBB80 + 64) = 0;\n  sub_80A4567(1);\n  signal(20, (__sighandler_t)sub_80A3F13);\n  signal(18, 0);\n  *v0 = v1;\n}\n"
    ],
    "sub_80A479A": [
        "0x80a479a",
        "void sub_80A479A()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  signal(28, (__sighandler_t)sub_80A479A);\n  sub_80A32E0();\n  sub_80A332A(*(_DWORD *)(dword_80DBB80 + 36), *(_DWORD *)(dword_80DBB80 + 40));\n  sub_80A4567(1);\n  *v0 = v1;\n}\n"
    ],
    "sub_80A47D6": [
        "0x80a47d6",
        "int sub_80A47D6()\n{\n  if ( (*(_BYTE *)(dword_80DBB80 + 16) & 8) == 0 )\n    return sub_80A3EA1((unsigned int)\"\\a\");\n  sub_80A3EA1((unsigned int)\"\\x1B[7m\");\n  sub_80A4567(1);\n  sub_80A3E54(10);\n  sub_80A3EA1(0x80CAC5Bu);\n  return sub_80A4567(1);\n}\n"
    ],
    "sub_80A481D": [
        "0x80a481d",
        "unsigned int __usercall sub_80A481D@<eax>(unsigned int result@<eax>)\n{\n  unsigned int *v1; // ebx\n  unsigned int v2; // edx\n  unsigned int v3; // ebx\n  unsigned int v4; // [esp+0h] [ebp-8h]\n\n  v1 = (unsigned int *)dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 4);\n  if ( v2 <= result && v2 > *(_DWORD *)dword_80DBB80 )\n  {\n    v4 = v2 - 1;\n    sub_80A47D6();\n    result = v4;\n  }\n  v3 = *v1;\n  if ( v3 > result )\n  {\n    sub_80A47D6();\n    return v3;\n  }\n  return result;\n}\n"
    ],
    "sub_80A4850": [
        "0x80a4850",
        "char *__usercall sub_80A4850@<eax>(char *a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>)\n{\n  unsigned int v3; // edi\n  char *v5; // edi\n  char v6; // cl\n  int v7; // ebx\n  char v9; // cl\n  char *v10; // ebp\n  _BYTE *v11; // eax\n  int v12; // esi\n  const char *v13; // esi\n  int v14; // eax\n  unsigned int v15; // ebx\n  char *v16; // eax\n  char *v17; // ebp\n  const char *v18; // esi\n  unsigned __int8 v19; // [esp+1h] [ebp-11h]\n\n  v3 = (unsigned int)a1;\n  v19 = a2;\n  if ( a2 == 22 )\n  {\n    v5 = &a1[(_DWORD)sub_80A3374(a1, 1)];\n    *v5 = 94;\n    sub_80A4273(0);\n    *v5 = sub_80A3F95();\n    switch ( a3 )\n    {\n      case 2:\n        v6 = 2;\n        break;\n      case 3:\n        v6 = 4;\n        break;\n      case 1:\n        v6 = 0;\n        break;\n      default:\n        return v5 + 1;\n    }\n    sub_80A341E(v5, 1, v6);\n    return v5 + 1;\n  }\n  v7 = dword_80DBB80;\n  if ( a2 == 27 )\n  {\n    *(_BYTE *)(dword_80DBB80 + 19) = 0;\n    sub_80A36B1();\n    *(_DWORD *)(v7 + 32) = 0;\n    sub_80A31C1();\n    *(_DWORD *)(v7 + 64) = 0;\n    if ( *(_BYTE *)(v3 - 1) != 10 && *(_DWORD *)(v7 + 8) > *(_DWORD *)v7 )\n      --v3;\n    return (char *)v3;\n  }\n  if ( a2 != 8 && *(_BYTE *)(dword_80DBB80 + 92) != a2 && a2 != 127 )\n  {\n    if ( a2 == 13 || a2 == 10 )\n    {\n      sub_80A36B1();\n      v19 = 10;\n    }\n    switch ( a3 )\n    {\n      case 2:\n        v9 = 2;\n        break;\n      case 3:\n        v9 = 4;\n        break;\n      case 1:\n        v9 = 0;\n        break;\n      default:\n        goto LABEL_28;\n    }\n    sub_80A341E((char *)v3, 1, v9);\nLABEL_28:\n    v10 = &sub_80A3374((char *)v3, 1)[v3];\n    *v10 = v19;\n    v3 = (unsigned int)(v10 + 1);\n    if ( (*(_BYTE *)(v7 + 16) & 2) != 0 && strchr(\")]}\", v19) )\n    {\n      v11 = sub_80A3237(v10, v19);\n      if ( v11 )\n      {\n        v12 = *(_DWORD *)(v7 + 8);\n        *(_DWORD *)(v7 + 8) = v11;\n        sub_80A4273(0);\n        sub_80A3E54(40);\n        *(_DWORD *)(v7 + 8) = v12;\n        sub_80A4273(0);\n      }\n      else\n      {\n        sub_80A47D6();\n      }\n    }\n    if ( (*(_BYTE *)(v7 + 16) & 1) != 0 && v19 == 10 )\n    {\n      v13 = (const char *)sub_80A3BDF(v3);\n      v14 = strspn(v13, \" \\t\");\n      v15 = v14;\n      if ( v14 )\n      {\n        v16 = sub_80A3374((char *)v3, v14);\n        v17 = &v16[v3];\n        v18 = &v13[(_DWORD)v16];\n        sub_80A341E(&v16[v3], v15, 0);\n        qmemcpy(v17, v18, v15);\n        return &v17[v15];\n      }\n    }\n    return (char *)v3;\n  }\n  if ( *(_DWORD *)dword_80DBB80 < (unsigned int)a1 )\n    return sub_80A359D(a1 - 1, (unsigned int)(a1 - 1), 3);\n  return (char *)v3;\n}\n"
    ],
    "sub_80A4A19": [
        "0x80a4a19",
        "int __usercall sub_80A4A19@<eax>(const char *a1@<eax>)\n{\n  int v2; // edi\n  void *v3; // eax\n  int v4; // ebx\n  _DWORD *v5; // eax\n\n  v2 = dword_80DBB80;\n  free(*(void **)dword_80DBB80);\n  *(_DWORD *)(v2 + 12) = 10240;\n  v3 = sub_804DB2E(0x2800u);\n  *(_DWORD *)v2 = v3;\n  *(_DWORD *)(v2 + 4) = v3;\n  *(_DWORD *)(v2 + 8) = v3;\n  *(_DWORD *)(v2 + 72) = v3;\n  if ( *(const char **)(v2 + 68) != a1 )\n  {\n    free(*(void **)(v2 + 68));\n    *(_DWORD *)(v2 + 68) = sub_804DB46(a1);\n  }\n  v4 = sub_80A4009(a1, *(char **)v2, 1);\n  if ( v4 < 0 )\n    sub_80A4850(*(char **)v2, 0xAu, 0);\n  while ( 1 )\n  {\n    v5 = *(_DWORD **)(v2 + 5376);\n    if ( !v5 )\n      break;\n    *(_DWORD *)(v2 + 5376) = *v5;\n    free(v5);\n  }\n  *(_DWORD *)(v2 + 20) = 0;\n  *(_DWORD *)(v2 + 24) = -1;\n  memset((void *)(v2 + 248), 0, 0x70u);\n  return v4;\n}\n"
    ],
    "sub_80A4ABE": [
        "0x80a4abe",
        "unsigned int __usercall sub_80A4ABE@<eax>(char *a1@<eax>)\n{\n  char *v1; // edi\n  char v2; // al\n  int v3; // esi\n  char *v4; // ebx\n  char v5; // al\n  char v6; // al\n  char *v7; // eax\n  const char *v8; // eax\n  char *j; // ebp\n  char v10; // cl\n  const char *v11; // eax\n  int v12; // ebp\n  _BYTE *v13; // eax\n  int v14; // edi\n  int v15; // eax\n  size_t v16; // eax\n  void *v17; // edi\n  size_t v18; // eax\n  _BYTE *v19; // eax\n  int v20; // edi\n  unsigned int v21; // eax\n  unsigned int v22; // eax\n  int v23; // ebx\n  void *v24; // ebp\n  int v25; // eax\n  int v26; // ebx\n  const char *v27; // ecx\n  const char *v28; // edx\n  size_t v29; // eax\n  size_t v30; // eax\n  size_t v31; // eax\n  void *v32; // esi\n  unsigned __int8 v33; // dl\n  int v34; // esi\n  size_t v35; // eax\n  size_t v36; // eax\n  size_t v37; // eax\n  int v38; // eax\n  int v39; // edx\n  size_t v40; // eax\n  char *v41; // edi\n  int v42; // eax\n  int v43; // ebx\n  char *v44; // edi\n  int v45; // eax\n  const char *v46; // edx\n  unsigned int v47; // eax\n  size_t v48; // eax\n  size_t v49; // eax\n  int v50; // ebp\n  char *v51; // ebx\n  int v52; // edi\n  char v53; // al\n  const char *v54; // esi\n  const char *v55; // ebx\n  const char *v56; // ecx\n  const char *v57; // edx\n  _BYTE *v58; // eax\n  int v59; // edi\n  char *v60; // eax\n  char *v61; // eax\n  char *v62; // ebx\n  int v63; // esi\n  int v64; // ebp\n  char *v65; // edi\n  char *v66; // eax\n  char *v67; // ebx\n  char *v68; // eax\n  size_t v69; // eax\n  size_t v70; // eax\n  size_t v71; // eax\n  size_t v72; // eax\n  int v73; // esi\n  int v74; // eax\n  int v75; // edi\n  int v76; // eax\n  int v77; // eax\n  void *v78; // edi\n  int v79; // edi\n  unsigned __int8 v80; // bl\n  size_t v81; // eax\n  int v82; // ebx\n  unsigned int result; // eax\n  int v84; // [esp+0h] [ebp-138h]\n  char *v85; // [esp+4h] [ebp-134h]\n  char *v86; // [esp+4h] [ebp-134h]\n  char *i; // [esp+8h] [ebp-130h]\n  char v88; // [esp+8h] [ebp-130h]\n  char *v89; // [esp+8h] [ebp-130h]\n  char *v90; // [esp+Ch] [ebp-12Ch]\n  char v91; // [esp+Ch] [ebp-12Ch]\n  char src; // [esp+10h] [ebp-128h]\n  char *srca; // [esp+10h] [ebp-128h]\n  char *v94; // [esp+14h] [ebp-124h]\n  int v95; // [esp+14h] [ebp-124h]\n  int v96; // [esp+18h] [ebp-120h]\n  int v97; // [esp+1Ch] [ebp-11Ch] BYREF\n  int v98; // [esp+20h] [ebp-118h] BYREF\n  int v99; // [esp+24h] [ebp-114h] BYREF\n  char v100[4]; // [esp+28h] [ebp-110h] BYREF\n  char v101[4]; // [esp+A8h] [ebp-90h] BYREF\n\n  v1 = a1;\n  v2 = *a1;\n  if ( !v2 )\n    goto LABEL_235;\n  if ( v2 == 58 )\n    ++v1;\n  v98 = -1;\n  v97 = -1;\n  v3 = dword_80DBB80;\n  v4 = *(char **)dword_80DBB80;\n  v85 = (char *)(*(_DWORD *)(dword_80DBB80 + 4) - 1);\n  sub_80A3B30(*(void **)dword_80DBB80, v85);\n  v94 = *(char **)(v3 + 68);\n  while ( 1 )\n  {\n    v5 = *v1;\n    if ( *v1 != 32 && v5 != 9 )\n      break;\n    ++v1;\n  }\n  if ( v5 == 37 )\n  {\n    i = v1 + 1;\n    v97 = 1;\n    v98 = sub_80A3B30(v4, v85);\nLABEL_21:\n    while ( *i == 9 || *i == 32 )\n      ++i;\n    goto LABEL_23;\n  }\n  for ( i = (char *)sub_80A3C97(v1, &v97, v3); ; ++i )\n  {\n    v6 = *i;\n    if ( *i != 32 && v6 != 9 )\n      break;\n  }\n  if ( v6 == 44 )\n  {\n    v7 = i;\n    do\n    {\n      do\n        ++v7;\n      while ( *v7 == 9 );\n    }\n    while ( *v7 == 32 );\n    i = (char *)sub_80A3C97(v7, &v98, v3);\n    goto LABEL_21;\n  }\nLABEL_23:\n  v8 = i;\n  for ( j = v100; ; *(j - 1) = v10 )\n  {\n    v10 = *v8;\n    if ( (*v8 & 0xDF) == 0 || (unsigned __int8)(v10 - 9) <= 4u )\n      break;\n    ++v8;\n    ++j;\n  }\n  *j = 0;\n  while ( *v8 == 32 || *v8 == 9 )\n    ++v8;\n  strcpy(v101, v8);\n  v11 = sub_804D378(v100, 33);\n  v96 = 0;\n  if ( v11 )\n  {\n    *v11 = 0;\n    v96 = 1;\n  }\n  v90 = (char *)v97;\n  if ( v97 >= 0 )\n  {\n    v4 = sub_80A3AFE(v97);\n    v85 = (char *)sub_80A3ABA(v4);\n  }\n  v12 = v98;\n  if ( v98 >= 0 )\n  {\n    v13 = sub_80A3AFE(v98);\n    v85 = (char *)sub_80A3ABA(v13);\n  }\n  v14 = strlen(v100);\n  if ( !v14 )\n  {\n    if ( (int)v90 >= 0 )\n    {\n      *(_DWORD *)(v3 + 8) = sub_80A3AFE((int)v90);\n      sub_80A3191();\n    }\n    goto LABEL_235;\n  }\n  src = v100[0];\n  if ( v100[0] == 33 )\n  {\n    sub_80A3EF9();\n    sub_80A3E8D();\n    v15 = system(i + 1);\n    if ( v15 )\n      printf(\"\\nshell returned %i\\n\\n\", v15);\n    sub_80A32BC();\nLABEL_108:\n    sub_80A459B();\n    goto LABEL_235;\n  }\n  if ( v100[0] == 61 && !v100[1] )\n  {\n    if ( (int)v90 < 0 )\n    {\n      v98 = sub_80A3B30(*(void **)v3, *(void **)(v3 + 8));\n      v97 = v98;\n    }\n    sub_80A3847(\"%d\", v97);\n    goto LABEL_235;\n  }\n  v16 = v14;\n  if ( v14 > 7 )\n    v16 = 7;\n  if ( !strncmp(v100, \"delete\", v16) )\n  {\n    if ( (int)v90 < 0 )\n    {\n      v17 = *(void **)(v3 + 8);\n      v4 = (char *)sub_80A3BB5((unsigned int)v17);\n      v85 = (char *)sub_80A3ABA(v17);\n    }\n    *(_DWORD *)(v3 + 8) = sub_80A364E(v4, v85, 1, 1, 1);\n    sub_80A3191();\n    goto LABEL_235;\n  }\n  v18 = v14;\n  if ( v14 > 5 )\n    v18 = 5;\n  if ( !strncmp(v100, \"edit\", v18) )\n  {\n    if ( !*(_DWORD *)(v3 + 20) || v96 )\n    {\n      if ( v101[0] )\n      {\n        v94 = v101;\n      }\n      else\n      {\n        v19 = *(_BYTE **)(v3 + 68);\n        if ( !v19 || !*v19 )\n        {\n          sub_80A372C(\"No current filename\");\n          goto LABEL_235;\n        }\n      }\n      v20 = sub_80A4A19(v94);\n      v21 = *(_DWORD *)(v3 + 132);\n      if ( v21 <= 0x1B )\n      {\n        free(*(void **)(v3 + 4 * v21 + 136));\n        *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 132) + 136) = 0;\n      }\n      v22 = *(_DWORD *)(v3 + 128);\n      if ( v22 <= 0x1B )\n      {\n        free(*(void **)(v3 + 4 * v22 + 136));\n        *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 128) + 136) = 0;\n      }\n      v23 = *(_DWORD *)(v3 + 4);\n      v24 = *(void **)v3;\n      v25 = sub_80A3B30(*(void **)v3, (void *)(v23 - 1));\n      v26 = v23 - (_DWORD)v24;\n      v27 = &data;\n      if ( *(_BYTE *)(v3 + 17) )\n        v27 = \" [Readonly]\";\n      v28 = &data;\n      if ( v20 < 0 )\n        v28 = \" [New file]\";\n      sub_80A3847(\"'%s'%s%s %dL, %dC\", *(const char **)(v3 + 68), v28, v27, v25, v26);\n      goto LABEL_235;\n    }\n    goto LABEL_60;\n  }\n  v29 = v14;\n  if ( v14 > 5 )\n    v29 = 5;\n  if ( !strncmp(v100, \"file\", v29) )\n  {\n    if ( v12 == -1 && v90 == (char *)-1 )\n    {\n      if ( v101[0] )\n      {\n        free(*(void **)(v3 + 68));\n        *(_DWORD *)(v3 + 68) = sub_804DB46(v101);\n      }\n      else\n      {\n        *(_DWORD *)(v3 + 64) = 0;\n      }\n    }\n    else\n    {\n      sub_80A372C(\"No address allowed on this command\");\n    }\n    goto LABEL_235;\n  }\n  v30 = v14;\n  if ( v14 > 9 )\n    v30 = 9;\n  if ( !strncmp(v100, \"features\", v30) )\n  {\n    sub_80A3EF9();\n    sub_80A3E8D();\n    puts(\n      \"These features are available:\\n\"\n      \"\\tPattern searches with / and ?\\n\"\n      \"\\tLast command repeat with .\\n\"\n      \"\\tLine marking with 'x\\n\"\n      \"\\tNamed buffers with \\\"x\\n\"\n      \"\\tSome colon mode commands with :\\n\"\n      \"\\tSettable options with \\\":set\\\"\\n\"\n      \"\\tSignal catching- ^C\\n\"\n      \"\\tJob suspend and resume with ^Z\\n\"\n      \"\\tAdapt to window re-sizes\");\n    sub_80A32BC();\n    sub_80A459B();\n    goto LABEL_235;\n  }\n  v31 = v14;\n  if ( v14 > 5 )\n    v31 = 5;\n  if ( !strncmp(v100, \"list\", v31) )\n  {\n    if ( (int)v90 < 0 )\n    {\n      v32 = *(void **)(v3 + 8);\n      v4 = (char *)sub_80A3BB5((unsigned int)v32);\n      v85 = (char *)sub_80A3ABA(v32);\n    }\n    sub_80A3EF9();\n    puts(\"\\r\");\n    while ( 1 )\n    {\n      if ( v4 > v85 )\n        goto LABEL_108;\n      v33 = *v4;\n      if ( *v4 < 0 )\n        break;\n      if ( v33 == 10 )\n      {\n        sub_80A3EA1((unsigned int)\"$\\r\");\n        v34 = 0;\n        v33 = 10;\n        goto LABEL_105;\n      }\n      if ( v33 > 0x1Fu )\n        goto LABEL_101;\nLABEL_102:\n      v88 = *v4;\n      sub_804DD98(94);\n      if ( v88 == 127 )\n      {\n        v34 = 0;\n        v33 = 63;\n      }\n      else\n      {\n        v33 = v88 + 64;\n        v34 = 0;\n      }\nLABEL_105:\n      sub_804DD98(v33);\n      if ( v34 )\n        sub_80A3EA1(0x80CAC5Bu);\n      ++v4;\n    }\n    if ( v33 == 0x9B )\n    {\n      sub_80A3EA1((unsigned int)\"\\x1B[7m\");\n      v34 = 1;\n      v33 = 46;\n      goto LABEL_105;\n    }\nLABEL_101:\n    v34 = 0;\n    if ( v33 != 127 )\n      goto LABEL_105;\n    goto LABEL_102;\n  }\n  v35 = v14;\n  if ( v14 > 5 )\n    v35 = 5;\n  if ( !strncmp(v100, \"quit\", v35) )\n    goto LABEL_118;\n  v36 = v14;\n  if ( v14 > 5 )\n    v36 = 5;\n  if ( !strncmp(v100, \"next\", v36) )\n    goto LABEL_118;\n  v37 = v14;\n  if ( v14 > 5 )\n    v37 = 5;\n  if ( !strncmp(v100, \"prev\", v37) )\n  {\nLABEL_118:\n    if ( v96 )\n    {\n      if ( src == 113 )\n      {\n        v38 = *(_DWORD *)(v3 + 28);\nLABEL_132:\n        optind = v38;\n        goto LABEL_155;\n      }\n      goto LABEL_155;\n    }\n    if ( !*(_DWORD *)(v3 + 20) )\n    {\n      v39 = *(_DWORD *)(v3 + 28) + ~optind;\n      switch ( src )\n      {\n        case 'q':\n          if ( v39 > 0 )\n          {\n            sub_80A372C(\"%d more file(s) to edit\", *(_DWORD *)(v3 + 28) + ~optind);\n            goto LABEL_235;\n          }\n          break;\n        case 'n':\n          if ( v39 <= 0 )\n          {\n            sub_80A372C(\"No more files to edit\");\n            goto LABEL_235;\n          }\n          break;\n        case 'p':\n          if ( optind <= 0 )\n          {\n            sub_80A372C(\"No previous files to edit\");\n            goto LABEL_235;\n          }\n          v38 = optind - 2;\n          goto LABEL_132;\n      }\nLABEL_155:\n      *(_BYTE *)(v3 + 18) = 0;\n      goto LABEL_235;\n    }\nLABEL_60:\n    sub_80A372C(\"No write since last change (:%s! overrides)\", v100);\n    goto LABEL_235;\n  }\n  v40 = v14;\n  if ( v14 > 5 )\n    v40 = 5;\n  if ( !strncmp(v100, \"read\", v40) )\n  {\n    if ( !v101[0] )\n    {\n      sub_80A372C(\"No filename given\");\n      goto LABEL_235;\n    }\n    if ( (int)v90 >= 0 )\n    {\n      if ( !v90 )\n      {\nLABEL_143:\n        v41 = &v4[-*(_DWORD *)v3];\n        v42 = sub_80A4009(v101, v4, 0);\n        v43 = v42;\n        v44 = &v41[*(_DWORD *)v3];\n        if ( v42 >= 0 )\n        {\n          v45 = sub_80A3B30(v44, &v44[v42 - 1]);\n          v46 = &data;\n          if ( *(_BYTE *)(v3 + 17) )\n            v46 = \" [Readonly]\";\n          sub_80A3847(\"'%s'%s %dL, %dC\", v101, v46, v45, v43);\n          if ( v43 )\n          {\n            v47 = *(_DWORD *)(v3 + 8);\n            if ( v47 >= (unsigned int)v44 )\n              *(_DWORD *)(v3 + 8) = v47 + v43;\n          }\n        }\n        goto LABEL_235;\n      }\n    }\n    else\n    {\n      v4 = (char *)sub_80A3BB5(*(_DWORD *)(v3 + 8));\n    }\n    v4 = sub_80A3AE4(v4);\n    if ( v4 == (char *)(*(_DWORD *)(v3 + 4) - 1) )\n      v4 = *(char **)(v3 + 4);\n    goto LABEL_143;\n  }\n  v48 = v14;\n  if ( v14 > 7 )\n    v48 = 7;\n  if ( !strncmp(v100, \"rewind\", v48) )\n  {\n    if ( !*(_DWORD *)(v3 + 20) || v96 )\n    {\n      optind = -1;\n      goto LABEL_155;\n    }\n    goto LABEL_60;\n  }\n  v49 = v14;\n  if ( v14 > 4 )\n    v49 = 4;\n  v50 = strncmp(v100, \"set\", v49);\n  if ( !v50 )\n  {\n    if ( v101[0] && (v51 = v101, strcasecmp(v101, \"all\")) )\n    {\n      while ( *v51 )\n      {\n        if ( !strncmp(v51, \"no\", 2u) )\n          v50 = 2;\n        sub_80A39D8((int)v51, \"autoindent \", v50, \"ai\", 1);\n        sub_80A39D8((int)v51, \"flash \", v50, \"fl\", 8);\n        sub_80A39D8((int)v51, \"ignorecase \", v50, \"ic\", 4);\n        sub_80A39D8((int)v51, \"showmatch \", v50, \"sm\", 2);\n        if ( !strncmp(&v51[v50], \"tabstop=\", 8u) )\n        {\n          v99 = 0;\n          sscanf(&v51[v50 + 8], \"%u\", &v99);\n          if ( (unsigned int)(v99 - 1) <= 0x1F )\n            *(_DWORD *)(v3 + 84) = v99;\n        }\n        v58 = sub_80B2E9F(v51);\n        v51 = sub_80B2E8C(v58);\n      }\n    }\n    else\n    {\n      v52 = *(_DWORD *)(v3 + 84);\n      v53 = *(_BYTE *)(v3 + 16);\n      v54 = \"no\";\n      if ( (v53 & 2) != 0 )\n        v54 = &data;\n      v55 = \"no\";\n      if ( (v53 & 4) != 0 )\n        v55 = &data;\n      v56 = \"no\";\n      if ( (v53 & 8) != 0 )\n        v56 = &data;\n      v57 = \"no\";\n      if ( (v53 & 1) != 0 )\n        v57 = &data;\n      sub_80A372C(\"%sautoindent %sflash %signorecase %sshowmatch tabstop=%u\", v57, v56, v55, v54, v52);\n    }\n    goto LABEL_235;\n  }\n  if ( src != 115 )\n  {\n    v69 = v14;\n    if ( v14 > 8 )\n      v69 = 8;\n    if ( !strncmp(v100, \"version\", v69) )\n    {\n      sub_80A3847((char *)\"1.29.2\");\n    }\n    else\n    {\n      v70 = v14;\n      if ( v14 > 6 )\n        v70 = 6;\n      if ( strncmp(v100, \"write\", v70) )\n      {\n        v71 = v14;\n        if ( v14 > 3 )\n          v71 = 3;\n        if ( strncmp(v100, \"wq\", v71) )\n        {\n          v72 = v14;\n          if ( v14 > 3 )\n            v72 = 3;\n          if ( strncmp(v100, \"wn\", v72) && (src != 120 || v100[1]) )\n          {\n            if ( v14 > 5 )\n              v14 = 5;\n            if ( !strncmp(v100, \"yank\", v14) )\n            {\n              if ( (int)v90 < 0 )\n              {\n                v78 = *(void **)(v3 + 8);\n                v4 = (char *)sub_80A3BB5((unsigned int)v78);\n                v85 = (char *)sub_80A3ABA(v78);\n              }\n              sub_80A31FE(v4, v85, *(_DWORD *)(v3 + 128));\n              v79 = sub_80A3B30(v4, v85);\n              v80 = sub_80A31D5();\n              v81 = strlen(*(const char **)(v3 + 4 * *(_DWORD *)(v3 + 128) + 136));\n              sub_80A3847(\"Yank %d lines (%d chars) into [%c]\", v79, v81, v80);\n            }\n            else\n            {\n              sub_80A3774(v100);\n            }\n            goto LABEL_235;\n          }\n        }\n      }\n      if ( v101[0] )\n        v94 = v101;\n      if ( !*(_BYTE *)(v3 + 17) || v96 )\n      {\n        if ( !*(_DWORD *)(v3 + 20) && src == 120 )\n        {\n          v73 = 0;\n          v75 = 0;\n        }\n        else\n        {\n          v73 = v85 - v4 + 1;\n          v74 = sub_80A3A53((int)v94, v4, (int)v85);\n          v75 = v74;\n          if ( v74 < 0 )\n          {\n            if ( v74 == -1 )\n              sub_80A372C(\"'%s' %m\", v94);\n            goto LABEL_235;\n          }\n        }\n        v76 = sub_80A3B30(v4, &v4[v75 - 1]);\n        sub_80A3847(\"'%s' %dL, %dC\", v94, v76, v75);\n        v77 = dword_80DBB80;\n        if ( v75 == v73 )\n        {\n          if ( *(char **)dword_80DBB80 == v4 && *(char **)(dword_80DBB80 + 4) == &v4[v75] )\n          {\n            *(_DWORD *)(dword_80DBB80 + 20) = 0;\n            *(_DWORD *)(v77 + 24) = -1;\n          }\n          if ( v100[0] == 120 || (v100[1] & 0xDF) == 81 || (v100[1] & 0xDF) == 78 )\n            *(_BYTE *)(v77 + 18) = 0;\n        }\n        goto LABEL_235;\n      }\n      sub_80A372C(\"'%s' is read only\", v94);\n    }\nLABEL_235:\n    v82 = dword_80DBB80;\n    result = sub_80A481D(*(_DWORD *)(dword_80DBB80 + 8));\n    *(_DWORD *)(v82 + 8) = result;\n    return result;\n  }\n  v86 = i + 2;\n  v59 = (unsigned __int8)i[1];\n  v60 = strchr(i + 2, v59);\n  if ( v60 )\n  {\n    srca = (char *)(v60 - v86);\n    v89 = v60 + 1;\n    *v60 = 0;\n    v61 = strchr(v60 + 1, v59);\n    if ( v61 )\n    {\n      v95 = v61 - v89;\n      *v61 = 0;\n      v91 = v61[1];\n      v62 = (char *)sub_80A3BB5((unsigned int)v4);\n      if ( v97 < 0 )\n      {\n        v62 = (char *)sub_80A3BB5(*(_DWORD *)(v3 + 8));\n        v97 = sub_80A3B30(*(void **)v3, v62);\n      }\n      v63 = v97;\n      if ( v98 < 0 )\n        v98 = v97;\n      v64 = 1;\n      while ( v98 >= v63 )\n      {\n        v65 = v62;\n        do\n        {\n          v66 = sub_80A3BFA(v62, v86, 1, 0);\n          v67 = v66;\n          if ( !v66 )\n            break;\n          sub_80A359D(v66, (unsigned int)&srca[(_DWORD)v66 - 1], v64);\n          v68 = sub_80A386F(v67, v89, 2);\n          v65 = &v65[(_DWORD)v68];\n          if ( v91 != 103 )\n          {\n            v64 = 2;\n            break;\n          }\n          v62 = &v68[v95 + (_DWORD)v67];\n          v64 = 2;\n        }\n        while ( v62 < sub_80A3ABA(v65) );\n        v62 = sub_80A3AE4(v65);\n        ++v63;\n      }\n      goto LABEL_235;\n    }\n  }\n  sub_80A3847(\":s expression missing delimiters\");\n  return v84;\n}\n"
    ],
    "sub_80A56C1": [
        "0x80a56c1",
        "int __usercall sub_80A56C1@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  char *v2; // eax\n  unsigned __int8 v3; // dl\n  char *v4; // eax\n  int v5; // ecx\n  void *v6; // eax\n  int v7; // eax\n  int v8; // edx\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  int v12; // eax\n  unsigned int v13; // eax\n  int v14; // eax\n  char *v15; // eax\n  void *v16; // eax\n  void *v17; // esi\n  int v18; // eax\n  int v19; // eax\n  _BYTE *v20; // eax\n  _BYTE *v21; // eax\n  int v22; // eax\n  const char *v23; // eax\n  unsigned __int8 v24; // al\n  void *v25; // eax\n  int v26; // edx\n  void *v27; // edi\n  char *v28; // esi\n  char *v29; // eax\n  char v30; // al\n  char v31; // al\n  _BOOL4 v32; // esi\n  char *v33; // ebp\n  char *v34; // edi\n  int v35; // eax\n  unsigned int v36; // edi\n  unsigned __int8 v37; // dl\n  unsigned __int8 v38; // bp\n  _BYTE *v39; // eax\n  int v40; // edx\n  unsigned int v41; // esi\n  _BYTE *v42; // eax\n  int v43; // edi\n  int v44; // eax\n  int v45; // edx\n  _BYTE *v46; // esi\n  _BYTE *v47; // eax\n  int v48; // eax\n  int v49; // eax\n  int v50; // eax\n  char *v51; // eax\n  const char *v52; // eax\n  _BYTE *v53; // edx\n  int v54; // eax\n  int v55; // esi\n  int v56; // ebx\n  char *v57; // edi\n  char *v58; // eax\n  int v59; // eax\n  int v60; // eax\n  char *v61; // eax\n  const char *v62; // edx\n  char *v63; // eax\n  int v64; // eax\n  int v65; // ebp\n  unsigned __int8 v66; // al\n  int i; // esi\n  int j; // edi\n  _BYTE *v69; // eax\n  char *v70; // eax\n  int v71; // esi\n  char *v72; // eax\n  char *v73; // eax\n  int v74; // eax\n  void *v75; // edi\n  char *v76; // eax\n  char *v77; // esi\n  int v78; // eax\n  int v79; // eax\n  unsigned int v80; // eax\n  int v81; // eax\n  _BYTE *v82; // eax\n  char *v83; // eax\n  int v84; // eax\n  char *v85; // eax\n  unsigned int v86; // eax\n  int v87; // eax\n  unsigned int v88; // esi\n  int k; // edi\n  char *v90; // eax\n  int v91; // eax\n  int v92; // eax\n  int v93; // eax\n  int v94; // esi\n  char *v95; // eax\n  char *v96; // edi\n  char v97; // cl\n  char *v98; // eax\n  int v99; // eax\n  int v100; // edi\n  int v101; // ebp\n  int v102; // esi\n  char *v103; // eax\n  char *v104; // eax\n  const char *v105; // ebx\n  char *v106; // eax\n  int v107; // esi\n  unsigned __int8 v108; // di\n  size_t v109; // eax\n  int v110; // eax\n  char v111; // si\n  char *v112; // eax\n  char *v113; // eax\n  unsigned int v114; // eax\n  char *v115; // eax\n  int v116; // eax\n  char *v117; // esi\n  char v118; // cl\n  int v119; // eax\n  unsigned int v120; // esi\n  int v121; // eax\n  char *v122; // eax\n  char *v123; // edx\n  char v124; // al\n  int v125; // ebx\n  char *v126; // eax\n  unsigned int v127; // eax\n  _BYTE *v128; // edi\n  int v129; // eax\n  _BYTE *v130; // eax\n  int result; // eax\n  char *v133; // [esp+8h] [ebp-2Ch]\n  unsigned int v134; // [esp+Ch] [ebp-28h]\n  char *v135; // [esp+10h] [ebp-24h]\n  const char *v136; // [esp+10h] [ebp-24h]\n  char *v137; // [esp+10h] [ebp-24h]\n  char *v138; // [esp+10h] [ebp-24h]\n  char *v139; // [esp+10h] [ebp-24h]\n  char *v140; // [esp+10h] [ebp-24h]\n  _BYTE *v141; // [esp+10h] [ebp-24h]\n  const char *v142; // [esp+10h] [ebp-24h]\n  char *v143; // [esp+14h] [ebp-20h] BYREF\n  char v144[28]; // [esp+18h] [ebp-1Ch] BYREF\n\n  memset(v144, 0, 0xCu);\n  sub_80A45D2();\n  v1 = dword_80DBB80;\n  if ( (unsigned int)(a1 + 11) <= 9 && ((1 << (a1 + 11)) & 0x3F7) != 0 )\n    goto LABEL_21;\n  if ( *(_BYTE *)(dword_80DBB80 + 19) != 2 )\n  {\nLABEL_14:\n    if ( *(_BYTE *)(v1 + 19) == 1 )\n    {\n      if ( a1 != -8 )\n      {\n        if ( a1 <= 0 && ((_BYTE)a1 == 0x9B || (unsigned __int8)a1 <= 0x1Fu) )\n          goto LABEL_328;\n        v3 = a1;\n        v4 = *(char **)(v1 + 8);\n        v5 = 3;\n        goto LABEL_20;\n      }\nLABEL_217:\n      *(_BYTE *)(v1 + 19) = 2;\nLABEL_218:\n      sub_80A36B1();\n      goto LABEL_328;\n    }\nLABEL_21:\n    switch ( a1 )\n    {\n      case -11:\n      case 6:\n        v7 = *(_DWORD *)(v1 + 36) - 2;\n        goto LABEL_25;\n      case -10:\n      case 2:\n        v7 = *(_DWORD *)(v1 + 36) - 2;\n        goto LABEL_37;\n      case -9:\n        v90 = *(char **)(v1 + 8);\n        if ( (unsigned int)v90 < *(_DWORD *)(v1 + 4) - 1 )\n          *(_DWORD *)(v1 + 8) = sub_80A364E(v90, v90, 1, 1, 1);\n        goto LABEL_328;\n      case -8:\n      case 105:\n        goto LABEL_197;\n      case -7:\n      case 36:\n        while ( 1 )\n        {\n          *(_DWORD *)(v1 + 8) = sub_80A3ABA(*(void **)(v1 + 8));\n          v35 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v35;\n          if ( v35 <= 0 )\n            break;\n          sub_80A3B17();\n        }\n        goto LABEL_328;\n      case -6:\n        goto LABEL_326;\n      case -5:\n      case 8:\n      case 104:\n      case 127:\n        do\n        {\n          sub_80A36EF();\n          v9 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v9;\n        }\n        while ( v9 > 0 );\n        goto LABEL_328;\n      case -4:\n      case 32:\n      case 108:\n        do\n        {\n          sub_80A370C();\n          v12 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v12;\n        }\n        while ( v12 > 0 );\n        goto LABEL_328;\n      case -3:\n      case 10:\n      case 106:\n        do\n        {\n          sub_80A3B17();\n          *(_DWORD *)(v1 + 8) = sub_80A3DE7(*(_DWORD *)(v1 + 8), *(_DWORD *)(v1 + 52) + *(_DWORD *)(v1 + 56));\n          v10 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v10;\n        }\n        while ( v10 > 0 );\n        goto LABEL_328;\n      case -2:\n      case 107:\n        do\n        {\n          sub_80A3C7E();\n          *(_DWORD *)(v1 + 8) = sub_80A3DE7(*(_DWORD *)(v1 + 8), *(_DWORD *)(v1 + 52) + *(_DWORD *)(v1 + 56));\n          v110 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v110;\n        }\n        while ( v110 > 0 );\n        goto LABEL_328;\n      case 0:\n        goto LABEL_328;\n      case 4:\n        v7 = (unsigned int)(*(_DWORD *)(v1 + 36) - 2) >> 1;\nLABEL_25:\n        v8 = 1;\n        goto LABEL_26;\n      case 5:\n        v8 = 1;\n        goto LABEL_39;\n      case 7:\n        goto LABEL_43;\n      case 12:\n      case 18:\n        sub_80A3EB0(0, 0);\n        sub_80A3EA1(0x80CA4D0u);\n        sub_80A3316();\n        *(_DWORD *)(v1 + 64) = 0;\n        sub_80A4273(1);\n        goto LABEL_328;\n      case 13:\n      case 43:\n        do\n        {\n          sub_80A3B17();\n          sub_80A3191();\n          v11 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v11;\n        }\n        while ( v11 > 0 );\n        goto LABEL_328;\n      case 21:\n        v7 = (unsigned int)(*(_DWORD *)(v1 + 36) - 2) >> 1;\nLABEL_37:\n        v8 = -1;\n        goto LABEL_26;\n      case 25:\n        v8 = -1;\nLABEL_39:\n        v7 = 1;\n        goto LABEL_26;\n      case 27:\n        if ( !*(_BYTE *)(v1 + 19) )\n          sub_80A47D6();\n        *(_BYTE *)(v1 + 19) = 0;\n        sub_80A36B1();\n        sub_80A31C1();\nLABEL_43:\n        *(_DWORD *)(v1 + 64) = 0;\n        goto LABEL_328;\n      case 34:\n        v13 = (sub_80A3F95() | 0x20) - 97;\n        if ( v13 > 0x19 )\n          goto LABEL_229;\n        *(_DWORD *)(v1 + 128) = v13;\n        goto LABEL_328;\n      case 37:\n        v143 = *(char **)(v1 + 8);\n        v36 = *(_DWORD *)(v1 + 4);\n        while ( 2 )\n        {\n          v37 = *v143;\n          if ( v36 > (unsigned int)v143 && v37 != 10 )\n          {\n            v38 = *v143;\n            if ( !strchr(\"()[]{}\", v37) )\n            {\n              ++v143;\n              continue;\n            }\n            v39 = sub_80A3237(v143, v38);\n            if ( v39 )\n              *(_DWORD *)(v1 + 8) = v39;\n            else\n              sub_80A47D6();\n          }\n          break;\n        }\n        if ( *v143 == 10 )\n          goto LABEL_229;\n        goto LABEL_328;\n      case 39:\n        v14 = sub_80A3F95() | 0x20;\n        if ( (unsigned int)(v14 - 97) > 0x19 )\n        {\n          if ( v14 == 39 )\n          {\n            v16 = *(void **)(v1 + 8);\n            v17 = *(void **)(v1 + 356);\n            if ( *(_DWORD *)v1 <= (unsigned int)v17 && (unsigned int)v17 <= *(_DWORD *)(v1 + 4) - 1 )\n            {\n              *(_DWORD *)(v1 + 356) = v16;\n              *(_DWORD *)(v1 + 352) = v17;\n              v18 = sub_80A3BDF((unsigned int)v17);\n              v19 = sub_80A3BDF(v18);\n              *(_DWORD *)(v1 + 360) = sub_80A3BDF(v19);\n              v20 = sub_80A3AE4(v17);\n              v21 = sub_80A3AE4(v20);\n              *(_DWORD *)(v1 + 364) = sub_80A3AE4(v21);\n              v16 = v17;\n            }\n            *(_DWORD *)(v1 + 8) = v16;\n            sub_80A3E3B();\n            sub_80A3191();\n            LOBYTE(a1) = 39;\n          }\n          else\n          {\nLABEL_229:\n            sub_80A47D6();\n          }\n          goto LABEL_328;\n        }\n        v15 = *(char **)(v1 + 4 * v14 - 140);\n        v143 = v15;\n        if ( (unsigned int)v15 < *(_DWORD *)v1 || (unsigned int)v15 >= *(_DWORD *)(v1 + 4) )\n          goto LABEL_328;\n        *(_DWORD *)(v1 + 8) = v15;\nLABEL_240:\n        sub_80A3E3B();\n        goto LABEL_241;\n      case 44:\n        v45 = *(_DWORD *)(v1 + 88);\n        if ( !v45 )\n          goto LABEL_328;\n        v46 = *(_BYTE **)v1;\n        do\n        {\n          v47 = *(_BYTE **)(v1 + 8);\n          while ( 1 )\n          {\n            v143 = --v47;\n            if ( v46 > v47 )\n              break;\n            if ( *v47 == 10 )\n            {\n              if ( v45 != 10 )\n                break;\nLABEL_119:\n              *(_DWORD *)(v1 + 8) = v47;\n              break;\n            }\n            if ( v45 == (unsigned __int8)*v47 )\n              goto LABEL_119;\n          }\n          v48 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v48;\n        }\n        while ( v48 > 0 );\n        goto LABEL_328;\n      case 45:\n        do\n        {\n          sub_80A3C7E();\n          sub_80A3191();\n          v49 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v49;\n        }\n        while ( v49 > 0 );\n        goto LABEL_328;\n      case 46:\n        v50 = *(_DWORD *)(v1 + 96);\n        if ( v50 > 0 )\n        {\n          *(_BYTE *)(v1 + v50 + 692) = 0;\n          v51 = sub_804DB46((const char *)(v1 + 692));\n          *(_DWORD *)(v1 + 104) = v51;\n          *(_DWORD *)(v1 + 100) = v51;\n        }\n        goto LABEL_328;\n      case 47:\n      case 63:\n        v144[0] = a1;\n        v144[1] = 0;\n        v52 = sub_80A44B8(v144);\n        v143 = (char *)v52;\n        if ( !*v52 )\n          goto LABEL_328;\n        v53 = *(_BYTE **)(v1 + 112);\n        if ( v52[1] )\n        {\n          free(*(void **)(v1 + 112));\n          *(_DWORD *)(v1 + 112) = sub_804DB46(v143);\n        }\n        else if ( *v53 )\n        {\n          *v53 = a1;\n        }\n        goto LABEL_136;\n      case 48:\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        v64 = *(_DWORD *)(v1 + 32);\n        if ( a1 == 48 && v64 <= 0 )\nLABEL_326:\n          sub_80A3E3B();\n        else\n          *(_DWORD *)(v1 + 32) = a1 + 10 * v64 - 48;\n        goto LABEL_328;\n      case 58:\n        v140 = (char *)sub_80A44B8(\":\");\n        sub_80A4ABE(v140);\n        goto LABEL_328;\n      case 59:\n        goto LABEL_99;\n      case 60:\n      case 62:\n        v65 = sub_80A3B30(*(void **)v1, *(void **)(v1 + 8));\n        v66 = sub_80A3F95();\n        sub_80A688F(v66, &v143);\n        sub_80A364E(v135, v143, 1, 0, 0);\n        v141 = (_BYTE *)sub_80A3BB5((unsigned int)v135);\n        v143 = (char *)sub_80A3ABA(v143);\n        for ( i = sub_80A3B30(v141, v143); i > 0; --i )\n        {\n          if ( a1 == 60 )\n          {\n            if ( *v141 == 9 )\n            {\n              sub_80A359D(v141, (unsigned int)v141, 0);\n            }\n            else if ( *v141 == 32 )\n            {\n              for ( j = 0; *v141 == 32 && *(_DWORD *)(v1 + 84) > j; ++j )\n                sub_80A359D(v141, (unsigned int)v141, 0);\n            }\n          }\n          else if ( a1 == 62 )\n          {\n            sub_80A4850(v141, 9u, 1);\n          }\n          v141 = sub_80A3AE4(v141);\n        }\n        *(_DWORD *)(v1 + 8) = sub_80A3AFE(v65);\n        sub_80A3191();\n        goto LABEL_71;\n      case 65:\n        sub_80A3B9C();\n        goto LABEL_168;\n      case 66:\n      case 69:\n      case 87:\n        v71 = 2 * (a1 != 66) - 1;\n        do\n        {\n          v72 = *(char **)(v1 + 8);\n          if ( a1 != 87 && (unsigned __int8)(v72[v71] - 9) > 4u && v72[v71] != 32\n            || (v73 = sub_80A38E2(v72, 1, v71, 2),\n                *(_DWORD *)(v1 + 8) = v73,\n                *(_DWORD *)(v1 + 8) = sub_80A38E2(v73, 2, v71, 3),\n                a1 != 87) )\n          {\n            *(_DWORD *)(v1 + 8) = sub_80A38E2(*(char **)(v1 + 8), 1, v71, 1);\n          }\n          v74 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v74;\n        }\n        while ( v74 > 0 );\n        goto LABEL_328;\n      case 67:\n      case 68:\n        v75 = *(void **)(v1 + 8);\n        v76 = (char *)sub_80A3ABA(v75);\n        v77 = v76;\n        if ( *v76 == 10 && (int)&v76[-sub_80A3BB5((unsigned int)v76)] > 0 )\n          --v77;\n        *(_DWORD *)(v1 + 8) = v77;\n        *(_DWORD *)(v1 + 8) = sub_80A364E((char *)v75, v77, 0, 1, 1);\n        if ( a1 == 67 )\n          goto LABEL_197;\n        sub_80A31C1();\n        LOBYTE(a1) = 68;\n        goto LABEL_328;\n      case 71:\n        goto LABEL_189;\n      case 72:\n        *(_DWORD *)(v1 + 8) = *(_DWORD *)(v1 + 72);\n        v80 = *(_DWORD *)(v1 + 36) - 1;\n        if ( *(_DWORD *)(v1 + 32) > v80 )\n          *(_DWORD *)(v1 + 32) = v80;\n        v81 = *(_DWORD *)(v1 + 32) - 1;\n        *(_DWORD *)(v1 + 32) = v81;\n        if ( v81 > 0 )\n          sub_80A56C1();\n        goto LABEL_241;\n      case 73:\n        sub_80A3E3B();\n        sub_80A3191();\n        goto LABEL_197;\n      case 74:\n        do\n        {\n          sub_80A3B9C();\n          v85 = *(char **)(v1 + 8);\n          if ( (unsigned int)v85 < *(_DWORD *)(v1 + 4) - 1 )\n          {\n            sub_80A341E(v85, 1, 1);\n            v82 = *(_BYTE **)(v1 + 8);\n            *(_DWORD *)(v1 + 8) = v82 + 1;\n            *v82 = 32;\n            sub_80A341E((char *)(*(_DWORD *)(v1 + 8) - 1), 1, 2);\n            while ( 1 )\n            {\n              v83 = *(char **)(v1 + 8);\n              if ( *v83 != 9 && *v83 != 32 )\n                break;\n              sub_80A359D(v83, *(_DWORD *)(v1 + 8), 2);\n            }\n          }\n          v84 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v84;\n        }\n        while ( v84 > 0 );\n        goto LABEL_71;\n      case 76:\n        *(_DWORD *)(v1 + 8) = sub_80A3B76();\n        v86 = *(_DWORD *)(v1 + 36) - 1;\n        if ( *(_DWORD *)(v1 + 32) > v86 )\n          *(_DWORD *)(v1 + 32) = v86;\n        v87 = *(_DWORD *)(v1 + 32) - 1;\n        *(_DWORD *)(v1 + 32) = v87;\n        if ( v87 > 0 )\n          sub_80A56C1();\n        goto LABEL_240;\n      case 77:\n        *(_DWORD *)(v1 + 8) = *(_DWORD *)(v1 + 72);\n        v88 = (unsigned int)(*(_DWORD *)(v1 + 36) - 1) >> 1;\n        for ( k = 0; k != v88; ++k )\n          *(_DWORD *)(v1 + 8) = sub_80A3AE4(*(void **)(v1 + 8));\n        goto LABEL_328;\n      case 78:\n        v54 = *(_DWORD *)(v1 + 8);\n        v138 = (char *)(v54 - 1);\n        v55 = -1;\n        if ( **(_BYTE **)(v1 + 112) == 63 )\n        {\n          v138 = (char *)(v54 + 1);\n          v55 = 1;\n        }\n        goto LABEL_133;\n      case 79:\n        if ( *(_BYTE *)(sub_80A3BB5(*(_DWORD *)(v1 + 8)) - 1) == 10 )\n        {\n          sub_80A3C7E();\nLABEL_214:\n          sub_80A3B9C();\n          v70 = sub_80A4850(*(char **)(v1 + 8), 0xAu, 1);\nLABEL_215:\n          *(_DWORD *)(v1 + 8) = v70;\n        }\n        else\n        {\n          sub_80A3E3B();\n          *(_DWORD *)(v1 + 8) = sub_80A4850(*(char **)(v1 + 8), 0xAu, 1);\n          sub_80A3C7E();\n        }\n        goto LABEL_197;\n      case 80:\n      case 112:\n        v23 = *(const char **)(v1 + 4 * *(_DWORD *)(v1 + 128) + 136);\n        v136 = v23;\n        if ( !v23 )\n        {\n          v24 = sub_80A31D5();\n          sub_80A372C(\"Nothing in register %c\", v24);\n          goto LABEL_328;\n        }\n        if ( strchr(v23, 10) )\n        {\n          if ( a1 == 80 )\n          {\n            sub_80A3E3B();\n          }\n          else if ( a1 == 112 )\n          {\n            v25 = sub_80A3ABA(*(void **)(v1 + 8));\n            v26 = *(_DWORD *)(v1 + 4);\n            if ( v25 == (void *)(v26 - 1) )\n              *(_DWORD *)(v1 + 8) = v26;\n            else\n              sub_80A3B17();\n          }\n        }\n        else if ( a1 == 112 )\n        {\n          sub_80A370C();\n        }\n        sub_80A386F(*(char **)(v1 + 8), v136, 1);\n        goto LABEL_71;\n      case 82:\n        goto LABEL_217;\n      case 85:\n        if ( !*(_DWORD *)(v1 + 4 * *(_DWORD *)(v1 + 132) + 136) )\n          goto LABEL_328;\n        v27 = *(void **)(v1 + 8);\n        v28 = (char *)sub_80A3BB5((unsigned int)v27);\n        v143 = (char *)sub_80A3ABA(v27);\n        v137 = sub_80A359D(v28, (unsigned int)v143, 1);\n        v29 = &sub_80A386F(v137, *(const char **)(v1 + 4 * *(_DWORD *)(v1 + 132) + 136), 2)[(_DWORD)v137];\n        goto LABEL_191;\n      case 88:\n      case 115:\n      case 120:\n        do\n        {\n          v91 = *(_DWORD *)(v1 + 8);\n          if ( *(_BYTE *)(v91 - (a1 == 88)) != 10 )\n          {\n            if ( a1 == 88 )\n              *(_DWORD *)(v1 + 8) = v91 - 1;\n            *(_DWORD *)(v1 + 8) = sub_80A364E(*(char **)(v1 + 8), *(char **)(v1 + 8), 0, 1, 1);\n          }\n          v92 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v92;\n        }\n        while ( v92 > 0 );\n        sub_80A31C1();\n        if ( a1 == 115 )\n          goto LABEL_197;\n        goto LABEL_328;\n      case 89:\n      case 99:\n      case 100:\n      case 121:\n        v100 = (a1 & 0xFFFFFFDF) != 89;\n        v101 = 121;\n        if ( a1 != 89 )\n          v101 = sub_80A3F95();\n        v102 = sub_80A688F((unsigned __int8)v101, &v143);\n        sub_80A3EB0(0, 0);\n        if ( v101 == 27 )\n          goto LABEL_327;\n        if ( strchr(\"wW\", v101) )\n        {\n          if ( a1 == 99 )\n          {\n            while ( (*v143 == 32 || *v143 == 9) && *(_DWORD *)v1 < (unsigned int)v143 && *(v143 - 1) != 10 )\n              --v143;\n          }\n        }\n        else if ( !strchr(MEMORY[0x80D84FC], v101) )\n        {\n          if ( !strchr(\"cdykjHL+-{}\\r\\n\", v101) )\n          {\n            sub_80A47D6();\nLABEL_327:\n            LOBYTE(a1) = 27;\n            goto LABEL_328;\n          }\n          v103 = sub_80A364E(v135, v143, v102, v100, 1);\n          *(_DWORD *)(v1 + 8) = v103;\n          if ( v102 )\n          {\n            if ( a1 == 99 )\n            {\n              v104 = sub_80A4850(v103, 0xAu, 2);\n              *(_DWORD *)(v1 + 8) = v104;\n              if ( v104 != (char *)(*(_DWORD *)(v1 + 4) - 1) )\n                sub_80A3C7E();\n              goto LABEL_280;\n            }\n            if ( a1 == 100 )\n            {\n              sub_80A3E3B();\n              sub_80A3191();\nLABEL_282:\n              strcpy(v144, \"Delete\");\n              LOBYTE(a1) = 100;\nLABEL_285:\n              v105 = *(const char **)(v1 + 4 * *(_DWORD *)(v1 + 128) + 136);\n              v142 = v105;\n              v106 = (char *)&v105[strlen(v105)];\n              v143 = v106;\n              v107 = 0;\n              while ( v106 >= v142 )\n              {\n                if ( *v142 == 10 )\n                  ++v107;\n                ++v142;\n              }\n              v108 = sub_80A31D5();\n              v109 = strlen(v105);\n              sub_80A3847(\"%s %d lines (%d chars) using [%c]\", v144, v107, v109, v108);\n              sub_80A31C1();\n              goto LABEL_328;\n            }\nLABEL_283:\n            if ( (a1 & 0xFFFFFFDF) == 89 )\n              strcpy(v144, \"Yank\");\n            goto LABEL_285;\n          }\nLABEL_279:\n          if ( a1 == 99 )\n          {\nLABEL_280:\n            strcpy(v144, \"Change\");\n            LOBYTE(a1) = 99;\n            goto LABEL_197;\n          }\n          if ( a1 == 100 )\n            goto LABEL_282;\n          goto LABEL_283;\n        }\n        *(_DWORD *)(v1 + 8) = sub_80A364E(v135, v143, v102, v100, 1);\n        goto LABEL_279;\n      case 90:\n        if ( sub_80A3F95() != 90 )\n          goto LABEL_229;\n        if ( *(_DWORD *)(v1 + 20) )\n        {\n          if ( !*(_BYTE *)(v1 + 17) )\n          {\n            v93 = sub_80A3A53(*(_DWORD *)(v1 + 68), *(char **)v1, *(_DWORD *)(v1 + 4) - 1);\n            if ( v93 >= 0 )\n            {\n              LOBYTE(a1) = 90;\n              if ( *(_DWORD *)(v1 + 4) - *(_DWORD *)v1 == v93 )\n                *(_BYTE *)(v1 + 18) = 0;\n            }\n            else\n            {\n              LOBYTE(a1) = 90;\n              if ( v93 == -1 )\n                sub_80A372C(\"Write error: %m\");\n            }\n            goto LABEL_328;\n          }\n          sub_80A372C(\"'%s' is read only\", *(const char **)(v1 + 68));\n        }\n        else\n        {\n          *(_BYTE *)(v1 + 18) = 0;\n        }\n        LOBYTE(a1) = 90;\n        goto LABEL_328;\n      case 94:\n        goto LABEL_240;\n      case 97:\nLABEL_168:\n        v69 = *(_BYTE **)(v1 + 8);\n        if ( *v69 == 10 )\n          goto LABEL_197;\n        v70 = v69 + 1;\n        goto LABEL_215;\n      case 98:\n      case 101:\n        v94 = 2 * (a1 != 98) - 1;\n        v133 = *(char **)v1;\n        v134 = *(_DWORD *)(v1 + 4) - 1;\n        while ( 2 )\n        {\n          v95 = (char *)(v94 + *(_DWORD *)(v1 + 8));\n          if ( v95 < v133 || (unsigned int)v95 > v134 )\n            goto LABEL_328;\n          *(_DWORD *)(v1 + 8) = v95;\n          if ( (unsigned __int8)(*v95 - 9) <= 4u || *v95 == 32 )\n            *(_DWORD *)(v1 + 8) = sub_80A38E2(v95, (a1 == 101) + 1, v94, 3);\n          v96 = *(char **)(v1 + 8);\n          v97 = *v96;\n          if ( (unsigned __int8)(*v96 - 48) <= 9u || (unsigned __int8)((v97 | 0x20) - 97) <= 0x19u || v97 == 95 )\n          {\n            v98 = sub_80A38E2(v96, 1, v94, 5);\n          }\n          else\n          {\n            if ( !*(_BYTE *)strchrnul() )\n              goto LABEL_255;\n            v98 = sub_80A38E2(v96, 1, v94, 4);\n          }\n          *(_DWORD *)(v1 + 8) = v98;\nLABEL_255:\n          v99 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v99;\n          if ( v99 <= 0 )\n            goto LABEL_328;\n          continue;\n        }\n      case 102:\n        *(_DWORD *)(v1 + 88) = sub_80A3F95();\nLABEL_99:\n        v40 = *(_DWORD *)(v1 + 88);\n        v41 = *(_DWORD *)(v1 + 4) - 1;\n        do\n        {\n          if ( !v40 )\n            break;\n          v42 = *(_BYTE **)(v1 + 8);\n          while ( 1 )\n          {\n            v143 = ++v42;\n            v43 = (unsigned __int8)*v42;\n            if ( v41 <= (unsigned int)v42 )\n              break;\n            if ( *v42 == 10 )\n            {\n              v43 = 10;\n              break;\n            }\n            if ( v40 == v43 )\n              goto LABEL_108;\n          }\n          if ( v40 != v43 )\n            goto LABEL_109;\nLABEL_108:\n          *(_DWORD *)(v1 + 8) = v42;\nLABEL_109:\n          v44 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v44;\n        }\n        while ( v44 > 0 );\n        goto LABEL_328;\n      case 103:\n        v78 = sub_80A3F95();\n        if ( v78 == 103 )\n        {\n          if ( !*(_DWORD *)(v1 + 32) )\n            *(_DWORD *)(v1 + 32) = 1;\nLABEL_189:\n          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v1 + 4) - 1;\n          v79 = *(_DWORD *)(v1 + 32);\n          if ( v79 > 0 )\n          {\n            v29 = sub_80A3AFE(v79);\nLABEL_191:\n            *(_DWORD *)(v1 + 8) = v29;\n          }\nLABEL_241:\n          sub_80A3191();\n        }\n        else\n        {\n          v144[0] = 103;\n          if ( v78 < 0 )\n            LOBYTE(v78) = 42;\n          v144[1] = v78;\n          v144[2] = 0;\n          sub_80A3774(v144);\n        }\n        goto LABEL_328;\n      case 109:\n        v22 = sub_80A3F95() | 0x20;\n        if ( (unsigned int)(v22 - 97) > 0x19 )\n          goto LABEL_229;\n        *(_DWORD *)(v1 + 4 * v22 - 140) = *(_DWORD *)(v1 + 8);\n        goto LABEL_328;\n      case 110:\n        do\n        {\nLABEL_136:\n          v60 = *(_DWORD *)(dword_80DBB80 + 8);\n          v138 = (char *)(v60 + 1);\n          v55 = 1;\n          if ( **(_BYTE **)(dword_80DBB80 + 112) == 63 )\n          {\n            v138 = (char *)(v60 - 1);\n            v55 = -1;\n          }\nLABEL_133:\n          v56 = dword_80DBB80;\n          v57 = (char *)(*(_DWORD *)(dword_80DBB80 + 112) + 1);\n          v58 = sub_80A3BFA(v138, v57, v55, 1);\n          v143 = v58;\n          if ( v58 )\n          {\n            *(_DWORD *)(v56 + 8) = v58;\n          }\n          else\n          {\n            v139 = *(char **)v56;\n            if ( v55 == -1 )\n              v139 = (char *)(*(_DWORD *)(v56 + 4) - 1);\n            v61 = sub_80A3BFA(v139, v57, v55, 1);\n            v143 = v61;\n            v62 = \"Pattern not found\";\n            if ( v61 )\n            {\n              *(_DWORD *)(v56 + 8) = v61;\n              v62 = \"search hit TOP, continuing at BOTTOM\";\n              if ( v55 != -1 )\n                v62 = \"search hit BOTTOM, continuing at TOP\";\n            }\n            sub_80A372C(\"%s\", v62);\n          }\n          v59 = *(_DWORD *)(v56 + 32) - 1;\n          *(_DWORD *)(v56 + 32) = v59;\n        }\n        while ( v59 > 0 );\n        goto LABEL_328;\n      case 111:\n        goto LABEL_214;\n      case 114:\n        v111 = sub_80A3F95();\n        v112 = *(char **)(v1 + 8);\n        if ( *v112 != 10 )\n        {\n          sub_80A341E(v112, 1, 1);\n          **(_BYTE **)(v1 + 8) = v111;\n          sub_80A341E(*(char **)(v1 + 8), 1, 2);\n        }\n        goto LABEL_71;\n      case 116:\n        *(_DWORD *)(v1 + 88) = sub_80A3F95();\n        sub_80A56C1();\n        if ( **(unsigned __int8 **)(v1 + 8) == *(_DWORD *)(v1 + 88) )\n          sub_80A36EF();\n        *(_DWORD *)(v1 + 88) = 0;\n        goto LABEL_328;\n      case 117:\n        while ( 2 )\n        {\n          sub_80A36B1();\n          v33 = *(char **)(v1 + 5376);\n          if ( !v33 )\n          {\n            sub_80A3847(\"Already at oldest change\");\n            goto LABEL_328;\n          }\n          v30 = v33[12];\n          switch ( v30 )\n          {\n            case 1:\n              goto LABEL_83;\n            case 0:\n            case 2:\n              sub_80A359D(\n                (char *)(*(_DWORD *)v1 + *((_DWORD *)v33 + 1)),\n                *(_DWORD *)v1 + *((_DWORD *)v33 + 1) + *((_DWORD *)v33 + 2) - 1,\n                0);\n              sub_80A3847(\n                \"Undo [%d] %s %d chars at position %d\",\n                *(_DWORD *)(v1 + 20),\n                \"deleted\",\n                *((_DWORD *)v33 + 2),\n                *((_DWORD *)v33 + 1));\n              break;\n            case 3:\nLABEL_83:\n              v34 = (char *)(*(_DWORD *)v1 + *((_DWORD *)v33 + 1));\n              sub_80A3374(v34, *((_DWORD *)v33 + 2));\n              qmemcpy(v34, v33 + 13, *((_DWORD *)v33 + 2));\n              sub_80A3847(\n                \"Undo [%d] %s %d chars at position %d\",\n                *(_DWORD *)(v1 + 20),\n                \"restored\",\n                *((_DWORD *)v33 + 2),\n                *((_DWORD *)v33 + 1));\n              break;\n          }\n          v31 = v33[12];\n          if ( (unsigned __int8)v31 <= 1u )\n          {\n            *(_DWORD *)(v1 + 8) = *(_DWORD *)v1 + *((_DWORD *)v33 + 1);\n            sub_80A4273(0);\n            v32 = 0;\n          }\n          else\n          {\n            v32 = (unsigned __int8)v31 < 4u;\n          }\n          *(_DWORD *)(v1 + 5376) = *(_DWORD *)v33;\n          free(v33);\n          --*(_DWORD *)(v1 + 20);\n          if ( !v32 )\n            goto LABEL_328;\n          continue;\n        }\n      case 119:\n        while ( 1 )\n        {\n          v117 = *(char **)(v1 + 8);\n          v118 = *v117;\n          if ( (unsigned __int8)(*v117 - 48) <= 9u || (unsigned __int8)((v118 | 0x20) - 97) <= 0x19u || v118 == 95 )\n          {\n            v113 = sub_80A38E2(v117, 1, 1, 5);\n          }\n          else\n          {\n            if ( !*(_BYTE *)strchrnul() )\n              goto LABEL_301;\n            v113 = sub_80A38E2(v117, 1, 1, 4);\n          }\n          *(_DWORD *)(v1 + 8) = v113;\nLABEL_301:\n          v114 = *(_DWORD *)(v1 + 8);\n          if ( v114 < *(_DWORD *)(v1 + 4) - 1 )\n            *(_DWORD *)(v1 + 8) = v114 + 1;\n          v115 = *(char **)(v1 + 8);\n          if ( *v115 == 32 || (unsigned __int8)(*v115 - 9) <= 4u )\n            *(_DWORD *)(v1 + 8) = sub_80A38E2(v115, 2, 1, 3);\n          v116 = *(_DWORD *)(v1 + 32) - 1;\n          *(_DWORD *)(v1 + 32) = v116;\n          if ( v116 <= 0 )\n            goto LABEL_328;\n        }\n      case 122:\n        v119 = sub_80A3F95();\n        if ( v119 == 46 )\n        {\n          v120 = (unsigned int)(*(_DWORD *)(v1 + 36) - 2) >> 1;\n        }\n        else\n        {\n          v120 = 0;\n          if ( v119 == 45 )\n            v120 = *(_DWORD *)(v1 + 36) - 2;\n        }\n        *(_DWORD *)(v1 + 72) = sub_80A3BB5(*(_DWORD *)(v1 + 8));\n        v8 = -1;\n        v7 = v120;\nLABEL_26:\n        sub_80A3D95(v7, v8);\n        goto LABEL_328;\n      case 123:\n        v63 = sub_80A3BFA(*(char **)(v1 + 8), \"\\n\\n\", -1, 1);\n        goto LABEL_145;\n      case 124:\n        v6 = sub_80A3DE7(*(_DWORD *)(v1 + 8), *(_DWORD *)(v1 + 32) - 1);\n        goto LABEL_147;\n      case 125:\n        v63 = sub_80A3BFA(*(char **)(v1 + 8), \"\\n\\n\", 1, 1);\nLABEL_145:\n        v143 = v63;\n        if ( !v63 )\n          goto LABEL_328;\n        v6 = sub_80A3AE4(v63);\n        goto LABEL_147;\n      case 126:\n        break;\n      default:\n        v144[0] = a1;\n        v144[1] = 0;\n        sub_80A3774(v144);\n        goto LABEL_71;\n    }\n    while ( 1 )\n    {\n      v122 = *(char **)(v1 + 8);\n      if ( (unsigned __int8)(*v122 - 97) <= 0x19u )\n        break;\n      if ( (unsigned __int8)(*v122 - 65) <= 0x19u )\n      {\n        sub_80A341E(v122, 1, 1);\n        v123 = *(char **)(v1 + 8);\n        v124 = *v123;\n        if ( (unsigned __int8)(*v123 - 65) <= 0x19u )\n          v124 += 32;\n        goto LABEL_325;\n      }\nLABEL_319:\n      sub_80A370C();\n      v121 = *(_DWORD *)(v1 + 32) - 1;\n      *(_DWORD *)(v1 + 32) = v121;\n      if ( v121 <= 0 )\n      {\nLABEL_71:\n        sub_80A31C1();\n        goto LABEL_328;\n      }\n    }\n    sub_80A341E(v122, 1, 1);\n    v123 = *(char **)(v1 + 8);\n    v124 = *v123;\n    if ( (unsigned __int8)(*v123 - 97) <= 0x19u )\n      v124 -= 32;\nLABEL_325:\n    *v123 = v124;\n    sub_80A341E(*(char **)(v1 + 8), 1, 2);\n    goto LABEL_319;\n  }\n  if ( a1 == -8 )\n  {\nLABEL_197:\n    *(_BYTE *)(dword_80DBB80 + 19) = 1;\n    goto LABEL_218;\n  }\n  v2 = *(char **)(dword_80DBB80 + 8);\n  if ( *v2 == 10 )\n  {\n    *(_BYTE *)(dword_80DBB80 + 19) = 1;\n    sub_80A36B1();\n    goto LABEL_14;\n  }\n  if ( a1 <= 0 )\n  {\n    if ( (_BYTE)a1 == 0x9B || (unsigned __int8)a1 <= 0x1Fu )\n      goto LABEL_328;\n    goto LABEL_12;\n  }\n  if ( a1 != 27 )\nLABEL_12:\n    *(_DWORD *)(v1 + 8) = sub_80A364E(v2, v2, 0, 1, 1);\n  v3 = a1;\n  v4 = *(char **)(v1 + 8);\n  v5 = 2;\nLABEL_20:\n  v6 = sub_80A4850(v4, v3, v5);\nLABEL_147:\n  *(_DWORD *)(v1 + 8) = v6;\nLABEL_328:\n  v125 = dword_80DBB80;\n  v126 = *(char **)(dword_80DBB80 + 4);\n  if ( v126 == *(char **)dword_80DBB80 )\n  {\n    sub_80A4850(v126, 0xAu, 0);\n    *(_DWORD *)(v125 + 8) = *(_DWORD *)v125;\n  }\n  v127 = *(_DWORD *)(v125 + 8);\n  if ( v127 != *(_DWORD *)(v125 + 4) )\n    *(_DWORD *)(v125 + 8) = sub_80A481D(v127);\n  v128 = *(_BYTE **)(v125 + 8);\n  if ( ((unsigned int)v128 < *(_DWORD *)(v125 + 360) || (unsigned int)v128 > *(_DWORD *)(v125 + 364))\n    && strchr(\"cCdDJoOpPrRxX<>~\", (unsigned __int8)a1) )\n  {\n    *(_DWORD *)(v125 + 356) = *(_DWORD *)(v125 + 352);\n    *(_DWORD *)(v125 + 352) = v128;\n    v129 = sub_80A3BDF((unsigned int)v128);\n    *(_DWORD *)(v125 + 360) = sub_80A3BDF(v129);\n    v130 = sub_80A3AE4(v128);\n    *(_DWORD *)(v125 + 364) = sub_80A3AE4(v130);\n  }\n  if ( (unsigned __int8)(a1 - 48) > 9u )\n    *(_DWORD *)(v125 + 32) = 0;\n  result = sub_80A3BB5((unsigned int)v128);\n  if ( *v128 == 10 && (int)&v128[-result] > 0 && !*(_BYTE *)(v125 + 19) )\n    *(_DWORD *)(v125 + 8) = v128 - 1;\n  return result;\n}\n"
    ],
    "sub_80A688F": [
        "0x80a688f",
        "int __usercall sub_80A688F@<eax>(unsigned int *a1@<eax>, _DWORD *a2@<edx>, unsigned __int8 a3@<cl>)\n{\n  unsigned int *v3; // ebx\n  int v4; // esi\n  _BYTE *v5; // eax\n  unsigned int v6; // edi\n  int i; // ebp\n  char *v8; // ebp\n  _BYTE *v9; // edi\n  unsigned int v10; // ebp\n  char v11; // cl\n  _BYTE *v12; // eax\n  char v13; // cl\n  _BYTE *v14; // eax\n  _BYTE *v15; // eax\n  char *v16; // eax\n  char *j; // eax\n  int result; // eax\n  char *v19; // [esp+0h] [ebp-20h]\n  int v20; // [esp+4h] [ebp-1Ch]\n  char v21; // [esp+4h] [ebp-1Ch]\n\n  v3 = (unsigned int *)dword_80DBB80;\n  v19 = *(char **)(dword_80DBB80 + 8);\n  v4 = a3;\n  if ( strchr(\"cdy><\", a3) )\n  {\n    v5 = (_BYTE *)sub_80A3BB5((unsigned int)v19);\n    v6 = (unsigned int)v5;\n    v20 = v3[8];\n    for ( i = 1; v20 > i; ++i )\n      v5 = sub_80A3AE4(v5);\n    v8 = (char *)sub_80A3ABA(v5);\n    goto LABEL_29;\n  }\n  if ( strchr(MEMORY[0x80D8555], v4) )\n  {\n    sub_80A56C1(v4);\nLABEL_24:\n    v8 = (char *)v3[2];\n    v6 = (unsigned int)v19;\n    goto LABEL_29;\n  }\n  if ( strchr(\"wW\", v4) )\n  {\n    sub_80A56C1(v4);\n    v9 = (_BYTE *)v3[2];\n    v10 = *v3;\n    if ( (unsigned int)v9 > *v3 )\n    {\n      if ( ((v11 = *(v9 - 1), (unsigned __int8)(v11 - 9) <= 4u) || v11 == 32)\n        && (unsigned __int8)(*v9 - 9) > 4u\n        && *v9 != 32\n        || (v21 = *(v9 - 1), v12 = (_BYTE *)strchrnul(), v13 = v21, *v12)\n        && (v14 = (_BYTE *)strchrnul(), v13 = v21, !*v14)\n        || ((unsigned __int8)(v13 - 48) <= 9u || (unsigned __int8)((v13 | 0x20) - 97) <= 0x19u)\n        && (unsigned __int8)(*v9 - 48) > 9u\n        && (unsigned __int8)((*v9 | 0x20) - 97) > 0x19u )\n      {\n        v3[2] = (unsigned int)(v9 - 1);\n      }\n    }\n    v15 = (_BYTE *)v3[2];\n    if ( v10 < (unsigned int)v15 && *v15 == 10 )\n      v3[2] = (unsigned int)(v15 - 1);\n    goto LABEL_24;\n  }\n  if ( strchr(\"H-k{\", v4) )\n  {\n    v8 = (char *)sub_80A3ABA(v19);\n    sub_80A56C1(v4);\n    sub_80A3E3B();\n    v6 = v3[2];\n  }\n  else\n  {\n    if ( !strchr(\"L+j}\\r\\n\", v4) )\n    {\n      v6 = (unsigned int)v19;\n      v8 = v19;\n      goto LABEL_36;\n    }\n    v6 = sub_80A3BB5((unsigned int)v19);\n    sub_80A56C1(v4);\n    sub_80A3B9C();\n    v8 = (char *)v3[2];\n  }\nLABEL_29:\n  if ( v6 > (unsigned int)v8 )\n  {\n    v16 = (char *)v6;\n    v6 = (unsigned int)v8;\n    v8 = v16;\n    goto LABEL_33;\n  }\n  if ( v6 < (unsigned int)v8 )\n  {\nLABEL_33:\n    if ( strchr(MEMORY[0x80D856F], v4) )\n      --v8;\n  }\nLABEL_36:\n  for ( j = (char *)v6; ; ++j )\n  {\n    if ( v8 < j )\n    {\n      result = 0;\n      goto LABEL_42;\n    }\n    if ( *j == 10 )\n      break;\n  }\n  result = 1;\nLABEL_42:\n  *a1 = v6;\n  *a2 = v8;\n  v3[2] = (unsigned int)v19;\n  return result;\n}\n"
    ],
    "sub_80A6A75": [
        "0x80a6a75",
        "char *__usercall sub_80A6A75@<eax>(const char *a1@<eax>, char *a2@<edi>)\n{\n  int v3; // ebx\n  _BOOL4 v4; // eax\n  unsigned int v5; // edx\n  unsigned int v6; // eax\n  unsigned int v7; // edx\n  int v8; // eax\n  int v9; // eax\n  int v10; // ebx\n  int v11; // eax\n  void **i; // edi\n  char *v13; // edx\n  char *v14; // esi\n  int v15; // esi\n  void *v16; // edi\n  int v17; // eax\n  _BYTE *v18; // ebp\n  _BYTE *v19; // eax\n  int v20; // edi\n  int v21; // eax\n\n  v3 = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + 18) = 1;\n  sub_80A32BC();\n  *(_DWORD *)(v3 + 36) = 24;\n  *(_DWORD *)(v3 + 40) = 80;\n  v4 = sub_80A32E0();\n  *(_DWORD *)(v3 + 44) = v4;\n  if ( v4 )\n  {\n    sub_80A3EA1(0x80D592Au);\n    sub_804DD8F();\n    if ( sub_80B20CC(100, (char *)(v3 + 476), 0) == -256 )\n    {\n      v6 = v5 & 0x7FFF;\n      *(_DWORD *)(v3 + 40) = v6;\n      if ( v6 > 0x1000 )\n        *(_DWORD *)(v3 + 40) = 4096;\n      v7 = HIWORD(v5) & 0x7FFF;\n      *(_DWORD *)(v3 + 36) = v7;\n      if ( v7 > 0x1000 )\n        *(_DWORD *)(v3 + 36) = 4096;\n    }\n  }\n  sub_80A332A(*(_DWORD *)(v3 + 36), *(_DWORD *)(v3 + 40));\n  sub_80A4A19(a1);\n  *(_DWORD *)(v3 + 128) = 26;\n  *(_DWORD *)(v3 + 132) = 27;\n  v8 = *(_DWORD *)v3;\n  *(_DWORD *)(v3 + 356) = *(_DWORD *)v3;\n  *(_DWORD *)(v3 + 352) = v8;\n  *(_BYTE *)(v3 + 93) = 0;\n  *(_DWORD *)(v3 + 88) = 0;\n  *(_DWORD *)(v3 + 48) = 0;\n  *(_DWORD *)(v3 + 52) = 0;\n  signal(2, (__sighandler_t)sub_80A329C);\n  signal(28, (__sighandler_t)sub_80A479A);\n  signal(20, (__sighandler_t)sub_80A3F13);\n  v9 = __sigsetjmp((struct __jmp_buf_tag *)(v3 + 368), 1);\n  v10 = dword_80DBB80;\n  if ( v9 )\n  {\n    v11 = *(_DWORD *)dword_80DBB80;\n    *(_DWORD *)(dword_80DBB80 + 8) = *(_DWORD *)dword_80DBB80;\n    *(_DWORD *)(v10 + 72) = v11;\n  }\n  *(_BYTE *)(v10 + 19) = 0;\n  *(_DWORD *)(v10 + 32) = 0;\n  *(_DWORD *)(v10 + 84) = 8;\n  *(_DWORD *)(v10 + 56) = 0;\n  free(*(void **)(v10 + 104));\n  *(_DWORD *)(v10 + 104) = 0;\n  *(_DWORD *)(v10 + 100) = 0;\n  *(_DWORD *)(v10 + 96) = 0;\n  *(_BYTE *)(v10 + 94) = 0;\n  for ( i = (void **)(v10 + 464); ; ++i )\n  {\n    v13 = (char *)*i;\n    if ( !*i )\n      break;\n    while ( 1 )\n    {\n      a2 = v13;\n      v14 = strchr(v13, 10);\n      if ( v14 )\n      {\n        while ( *v14 == 10 )\n          *v14++ = 0;\n      }\n      if ( *a2 )\n        sub_80A4ABE(a2);\n      if ( !v14 )\n        break;\n      v13 = v14;\n    }\n    free(*i);\n    *i = 0;\n  }\n  sub_80A4567(0);\n  while ( *(char *)(v10 + 18) > 0 )\n  {\n    v15 = sub_80A3F95();\n    *(_BYTE *)(v10 + 93) = v15;\n    v16 = *(void **)(v10 + 8);\n    v17 = sub_80A3BB5((unsigned int)v16);\n    if ( *(_DWORD *)(v10 + 116) != v17 )\n    {\n      *(_DWORD *)(v10 + 116) = v17;\n      v18 = sub_80A3ABA(v16);\n      v19 = (_BYTE *)sub_80A3BB5((unsigned int)v16);\n      sub_80A31FE(v19, v18, *(_DWORD *)(v10 + 132));\n    }\n    if ( !*(_BYTE *)(v10 + 94)\n      && !*(_DWORD *)(v10 + 104)\n      && !*(_BYTE *)(v10 + 19)\n      && (unsigned int)(v15 - 1) <= 0x7D\n      && strchr(\"cCdDJoOpPrRxX<>~\", v15) )\n    {\n      v20 = dword_80DBB80;\n      v21 = *(_DWORD *)(dword_80DBB80 + 32);\n      if ( v21 <= 0 )\n      {\n        *(_BYTE *)(dword_80DBB80 + 692) = v15;\n        *(_DWORD *)(v20 + 96) = 1;\n      }\n      else\n      {\n        *(_DWORD *)(v20 + 96) = sprintf((char *)(dword_80DBB80 + 692), \"%d%c\", v21, v15);\n      }\n      *(_BYTE *)(v20 + 94) = 1;\n    }\n    sub_80A56C1(v15);\n    if ( !*(_BYTE *)(v10 + 476) && !sub_80A3E54(0) )\n    {\n      sub_80A4273(0);\n      sub_80A45D2();\n    }\n  }\n  sub_80A3EF9();\n  sub_80A3E8D();\n  return a2;\n}\n"
    ],
    "sub_80A6D25": [
        "0x80a6d25",
        "int __cdecl sub_80A6D25(int argc, char **argv)\n{\n  _DWORD *v2; // ebx\n  char *v3; // eax\n  int v4; // eax\n  _BOOL4 v5; // ebp\n  int v6; // ebp\n  int v7; // esi\n\n  v2 = sub_804DB2E(0x1504u);\n  dword_80DBB80 = (int)v2;\n  v2[6] = -1;\n  v2[28] = sub_804DB2E(2u);\n  *((_BYTE *)v2 + 5108) = 64;\n  v2[27] = getpid();\n  *((_BYTE *)v2 + 16) = 6;\n  v3 = getenv(\"EXINIT\");\n  if ( v3 && *v3 )\n    v2[116] = sub_804DB5D(v3, 128);\n  while ( 1 )\n  {\n    v4 = getopt(argc, argv, \"hCRHc:\");\n    if ( v4 == -1 )\n      break;\n    if ( v4 == 82 )\n    {\n      *((_BYTE *)v2 + 17) |= 2u;\n    }\n    else\n    {\n      if ( v4 != 99 )\n      {\n        if ( v4 == 72 )\n          puts(\n            \"These features are available:\\n\"\n            \"\\tPattern searches with / and ?\\n\"\n            \"\\tLast command repeat with .\\n\"\n            \"\\tLine marking with 'x\\n\"\n            \"\\tNamed buffers with \\\"x\\n\"\n            \"\\tSome colon mode commands with :\\n\"\n            \"\\tSettable options with \\\":set\\\"\\n\"\n            \"\\tSignal catching- ^C\\n\"\n            \"\\tJob suspend and resume with ^Z\\n\"\n            \"\\tAdapt to window re-sizes\");\n        sub_804CDC2();\n      }\n      if ( *optarg )\n      {\n        v5 = v2[116] != 0;\n        v2[v5 + 116] = sub_804DB5D(optarg, 128);\n      }\n    }\n  }\n  v6 = optind;\n  v7 = argc - optind;\n  v2[7] = argc - optind;\n  optind = 0;\n  sub_80A3EA1((unsigned int)\"\\x1B[?1049h\");\n  do\n  {\n    sub_80A6A75((&argv[optind])[v6], (char *)argv);\n    ++optind;\n  }\n  while ( optind < v7 );\n  sub_80A3EA1((unsigned int)\"\\x1B[?1049l\");\n  return 0;\n}\n"
    ],
    "sub_80A6E49": [
        "0x80a6e49",
        "int __usercall sub_80A6E49@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)\n{\n  int v3; // ebx\n  _DWORD *v4; // esi\n  int v5; // ebp\n\n  v3 = 0;\nLABEL_2:\n  v4 = (_DWORD *)*a1;\n  if ( *a1 )\n  {\n    v3 &= ~1u;\n    while ( 1 )\n    {\n      v5 = *v4;\n      if ( !*v4 )\n        break;\n      v3 |= (*(int (__fastcall **)(_DWORD, int))v5)(*v4, a2) ^ 1;\n      if ( *(_BYTE *)(v5 + 4) )\n        v3 ^= 1u;\n      ++v4;\n      if ( (v3 & 1) != 0 )\n      {\n        ++a1;\n        goto LABEL_2;\n      }\n    }\n  }\n  return v3 ^ 1;\n}\n"
    ],
    "sub_80A6E9E": [
        "0x80a6e9e",
        "_BOOL4 __fastcall sub_80A6E9E(int a1, int a2)\n{\n  return (*(_DWORD *)(a2 + 16) & 0xF000) == *(_DWORD *)(a1 + 8);\n}\n"
    ],
    "sub_80A6EB0": [
        "0x80a6eb0",
        "int __fastcall sub_80A6EB0(int a1, int a2)\n{\n  int result; // eax\n  int v3; // edx\n\n  result = *(_DWORD *)(a2 + 16);\n  v3 = *(_DWORD *)(a1 + 12);\n  if ( (*(_BYTE *)(a1 + 8) & 0xFB) == 43 )\n  {\n    LOBYTE(result) = (result & v3) != 0;\n  }\n  else\n  {\n    if ( *(_BYTE *)(a1 + 8) == 45 )\n      result &= v3;\n    else\n      result &= 0xFFFu;\n    LOBYTE(result) = result == v3;\n  }\n  return (unsigned __int8)result;\n}\n"
    ],
    "sub_80A6EE3": [
        "0x80a6ee3",
        "_BOOL4 __fastcall sub_80A6EE3(int a1, int a2)\n{\n  return *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 72);\n}\n"
    ],
    "sub_80A6EF0": [
        "0x80a6ef0",
        "_BOOL4 __fastcall sub_80A6EF0(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 24) == *(_DWORD *)(a1 + 8);\n}\n"
    ],
    "sub_80A6EFD": [
        "0x80a6efd",
        "_BOOL4 __fastcall sub_80A6EFD(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 28) == *(_DWORD *)(a1 + 8);\n}\n"
    ],
    "sub_80A6F0A": [
        "0x80a6f0a",
        "int __fastcall sub_80A6F0A(int a1, int a2)\n{\n  return sub_80A6E49(*(_DWORD **)(a1 + 8), a2);\n}\n"
    ],
    "sub_80A6F1A": [
        "0x80a6f1a",
        "_BOOL4 __fastcall sub_80A6F1A(int a1, int a2)\n{\n  char v2; // al\n  unsigned int v3; // edx\n  unsigned int v4; // esi\n  __int64 v5; // rcx\n  _BOOL4 result; // eax\n\n  v2 = *(_BYTE *)(a1 + 8);\n  HIDWORD(v5) = *(_DWORD *)(a2 + 44);\n  v3 = *(_DWORD *)(a2 + 48);\n  v4 = *(_DWORD *)(a1 + 12);\n  LODWORD(v5) = *(_DWORD *)(a1 + 16);\n  if ( v2 == 43 )\n  {\n    result = 1;\n    if ( __SPAIR64__(v3, HIDWORD(v5)) > __SPAIR64__(v5, v4) )\n      return result;\n    return 0;\n  }\n  if ( v2 == 45 )\n  {\n    result = 1;\n    if ( __SPAIR64__(v3, HIDWORD(v5)) < __SPAIR64__(v5, v4) )\n      return result;\n    return 0;\n  }\n  return v5 == __PAIR64__(v4, v3);\n}\n"
    ],
    "sub_80A6F65": [
        "0x80a6f65",
        "int sub_80A6F65()\n{\n  return 3;\n}\n"
    ],
    "sub_80A6F6B": [
        "0x80a6f6b",
        "_BYTE *__usercall sub_80A6F6B@<eax>(_BYTE *a1@<eax>)\n{\n  return &a1[((*a1 - 43) & 0xFD) == 0];\n}\n"
    ],
    "sub_80A6F7C": [
        "0x80a6f7c",
        "int __userpurge sub_80A6F7C@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>, time_t a3)\n{\n  int v3; // edi\n  int i; // ebx\n  char v8; // al\n  char v9; // dl\n  char v10; // [esp+0h] [ebp-14h]\n\n  v3 = 1;\n  if ( (a2[4] & 0xF000) == 0x4000 && HIDWORD(qword_80DB778) )\n  {\n    for ( i = 0; ; ++i )\n    {\n      if ( SHIDWORD(qword_80DB778) <= i )\n      {\n        v3 = 0;\n        goto LABEL_10;\n      }\n      if ( *(_DWORD *)(qword_80DB778 + 8 * i + 4) == a2[1] && *(_DWORD *)(qword_80DB778 + 8 * i) == *a2 )\n        break;\n    }\n    v3 = 1;\n  }\nLABEL_10:\n  if ( unk_80DB780 <= a3 )\n  {\n    if ( *(&unk_80DB780 + 1) < a3 )\n      return 2;\n    v8 = sub_80A6E49(MEMORY[0x80DB788], (int)a2);\n    v9 = v8;\n    if ( (v8 & 1) != 0 && *((_BYTE *)&MEMORY[0x80DB788] + 4) )\n    {\n      v10 = v8;\n      puts(a1);\n      v9 = v10;\n    }\n    if ( (a2[4] & 0xF000) == 0x4000 && *(&unk_80DB780 + 1) == a3 || !v3 || (v9 & 2) != 0 )\n      return 2;\n  }\n  else if ( !v3 )\n  {\n    return 2;\n  }\n  return 1;\n}\n"
    ],
    "sub_80A7047": [
        "0x80a7047",
        "int __usercall sub_80A7047@<eax>(const char *a1@<eax>)\n{\n  puts(a1);\n  return 1;\n}\n"
    ],
    "sub_80A7054": [
        "0x80a7054",
        "_BYTE *__usercall sub_80A7054@<eax>(int a1@<eax>, size_t a2@<edx>, int a3@<ecx>)\n{\n  _BYTE *v5; // esi\n  void **v6; // ebp\n  void *v7; // eax\n  int v8; // edx\n\n  v5 = sub_804DB2E(a2);\n  v6 = (void **)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4));\n  v7 = sub_804DB13(*v6, 4 * *(_DWORD *)(a1 + 8) + 8);\n  *v6 = v7;\n  v8 = *(_DWORD *)(a1 + 8);\n  *(_DWORD *)(a1 + 8) = v8 + 1;\n  *((_DWORD *)v7 + v8) = v5;\n  *((_DWORD *)v7 + v8 + 1) = 0;\n  *(_DWORD *)v5 = a3;\n  v5[4] = *(_BYTE *)(a1 + 12);\n  *(_BYTE *)(a1 + 12) = 0;\n  return v5;\n}\n"
    ],
    "sub_80A70A9": [
        "0x80a70a9",
        "int __fastcall sub_80A70A9(int a1, int a2)\n{\n  int v3; // ebx\n  int v4; // edx\n  char v5; // al\n  int v6; // edx\n  bool v7; // sf\n  bool v8; // of\n  int result; // eax\n\n  v3 = time(0) - *(_DWORD *)(a2 + 72);\n  v4 = 60 * *(_DWORD *)(a1 + 12);\n  v5 = *(_BYTE *)(a1 + 8);\n  if ( v5 == 43 )\n  {\n    v6 = v4 + 59;\n    v8 = __OFSUB__(v6, v3);\n    v7 = v6 - v3 < 0;\nLABEL_5:\n    LOBYTE(result) = v7 ^ v8;\n    return (unsigned __int8)result;\n  }\n  if ( v5 == 45 )\n  {\n    v8 = __OFSUB__(v3, v4);\n    v7 = v3 - v4 < 0;\n    goto LABEL_5;\n  }\n  result = 0;\n  if ( v3 < v4 )\n    return result;\n  LOBYTE(result) = v4 + 59 >= v3;\n  return (unsigned __int8)result;\n}\n"
    ],
    "sub_80A70ED": [
        "0x80a70ed",
        "int __fastcall sub_80A70ED(int a1, int a2)\n{\n  int v3; // ebx\n  int v4; // edx\n  char v5; // al\n  int v6; // edx\n  bool v7; // sf\n  bool v8; // of\n  int result; // eax\n\n  v3 = time(0) - *(_DWORD *)(a2 + 72);\n  v4 = 86400 * *(_DWORD *)(a1 + 12);\n  v5 = *(_BYTE *)(a1 + 8);\n  if ( v5 == 43 )\n  {\n    v6 = v4 + 86399;\n    v8 = __OFSUB__(v6, v3);\n    v7 = v6 - v3 < 0;\nLABEL_5:\n    LOBYTE(result) = v7 ^ v8;\n    return (unsigned __int8)result;\n  }\n  if ( v5 == 45 )\n  {\n    v8 = __OFSUB__(v3, v4);\n    v7 = v3 - v4 < 0;\n    goto LABEL_5;\n  }\n  result = 0;\n  if ( v3 < v4 )\n    return result;\n  LOBYTE(result) = v4 + 86399 >= v3;\n  return (unsigned __int8)result;\n}\n"
    ],
    "sub_80A713A": [
        "0x80a713a",
        "int __usercall sub_80A713A@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  int result; // eax\n  regmatch_t v4; // [esp+0h] [ebp-Ch] BYREF\n\n  result = regexec((const regex_t *)(a2 + 8), a1, 1u, &v4, 0);\n  if ( result )\n    return 0;\n  if ( !v4.rm_so )\n    return a1[v4.rm_eo] == 0;\n  return result;\n}\n"
    ],
    "sub_80A7177": [
        "0x80a7177",
        "_BOOL4 __usercall sub_80A7177@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  return fnmatch(*(const char **)(a2 + 8), a1, *(_BYTE *)(a2 + 12) != 0 ? 0x10 : 0) == 0;\n}\n"
    ],
    "sub_80A7198": [
        "0x80a7198",
        "_BOOL4 __usercall sub_80A7198@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  char *v4; // eax\n  char *v5; // edx\n  char *v6; // ebx\n  int v7; // eax\n\n  v4 = sub_804D315(a1);\n  if ( *v4 )\n  {\nLABEL_16:\n    v6 = 0;\n  }\n  else\n  {\n    while ( v4 != a1 )\n    {\n      if ( *(v4 - 1) != 47 )\n      {\n        v5 = v4;\n        do\n        {\n          if ( *(v5 - 1) == 47 )\n            break;\n          --v5;\n        }\n        while ( a1 != v5 );\n        v6 = v4;\n        v4 = v5;\nLABEL_13:\n        *v6 = 0;\n        goto LABEL_14;\n      }\n      --v4;\n    }\n    if ( !v4[1] )\n      goto LABEL_16;\n    v6 = v4 + 1;\n    if ( v4 != (char *)-1 )\n      goto LABEL_13;\n  }\nLABEL_14:\n  v7 = fnmatch(*(const char **)(a2 + 8), v4, *(_BYTE *)(a2 + 12) != 0 ? 0x10 : 0);\n  if ( v6 )\n    *v6 = 47;\n  return v7 == 0;\n}\n"
    ],
    "sub_80A7208": [
        "0x80a7208",
        "_BOOL4 __usercall sub_80A7208@<eax>(_DWORD *a1@<eax>, char *a2@<edx>)\n{\n  void *v3; // esp\n  char **v4; // esi\n  _DWORD *v5; // eax\n  char **v6; // edi\n  char *v7; // eax\n  char *v8; // eax\n  int v9; // ebx\n  char **i; // esi\n  char *s; // [esp+0h] [ebp-24h] BYREF\n  unsigned int v13; // [esp+4h] [ebp-20h]\n  int v14; // [esp+8h] [ebp-1Ch]\n  char **p_s; // [esp+Ch] [ebp-18h]\n  const char *v16; // [esp+10h] [ebp-14h]\n  int v17; // [esp+14h] [ebp-10h]\n\n  s = a2;\n  v3 = alloca(4 * (a1[4] + a1[6]) + 8);\n  v13 = ((unsigned int)&s + 3) >> 2;\n  p_s = &s;\n  v4 = &s;\n  v17 = 0;\n  while ( 1 )\n  {\n    v5 = (_DWORD *)a1[5];\n    if ( v17 >= a1[4] )\n      break;\n    v16 = *(const char **)(a1[2] + 4 * v17);\n    if ( !v5 )\n    {\n      v6 = v4 + 1;\n      v7 = (char *)sub_80B2955((char *)\"{}\", s);\n      goto LABEL_10;\n    }\n    if ( !*(_DWORD *)(a1[3] + 4 * v17) )\n    {\n      v6 = v4 + 1;\n      v7 = sub_804DB46(v16);\nLABEL_10:\n      *v4 = v7;\n      goto LABEL_11;\n    }\n    v6 = v4;\n    while ( 1 )\n    {\n      v14 = (char *)v6 - (char *)v4;\n      v8 = *(char **)(a1[5] + (char *)v6 - (char *)v4);\n      if ( !v8 )\n        break;\n      *v6++ = (char *)sub_80B2955((char *)\"{}\", v8);\n      free(*(void **)(a1[5] + v14));\n    }\nLABEL_11:\n    ++v17;\n    v4 = v6;\n  }\n  *v4 = 0;\n  if ( v5 )\n  {\n    *v5 = 0;\n    a1[6] = 0;\n    a1[7] = 0;\n  }\n  v9 = sub_80B3C03(s, v13, v14, p_s, v16, v17);\n  if ( v9 < 0 )\n    sub_804D3F1(*(const char **)(4 * v13));\n  for ( i = p_s; *i++; free(*(i - 1)) )\n    ;\n  return v9 == 0;\n}\n"
    ],
    "sub_80A7336": [
        "0x80a7336",
        "_BOOL4 __usercall sub_80A7336@<eax>(char *a1@<eax>, _DWORD *a2@<ecx>)\n{\n  int v4; // eax\n  int v5; // edx\n  size_t v6; // eax\n\n  if ( !a2[5] )\n    return sub_80A7208(a2, a1);\n  v4 = sub_80B4733(a2[6], 1032);\n  a2[5] = v4;\n  v5 = a2[6];\n  a2[6] = v5 + 1;\n  *(_DWORD *)(v4 + 4 * v5) = sub_804DB46(a1);\n  v6 = strlen(a1) + a2[7] + 5;\n  a2[7] = v6;\n  return v6 < (unsigned int)*(&MEMORY[0x80DB788] + 2) || sub_80A7208(a2, 0);\n}\n"
    ],
    "sub_80A739D": [
        "0x80a739d",
        "int __usercall sub_80A739D@<eax>(const char *a1@<eax>)\n{\n  printf(\"%s%c\", a1, 0);\n  return 1;\n}\n"
    ],
    "sub_80A73B3": [
        "0x80a73b3",
        "void *__usercall sub_80A73B3@<eax>(int a1@<eax>)\n{\n  const char *v2; // edi\n  int v3; // eax\n  int v4; // ecx\n  int v5; // esi\n  char *v6; // ebp\n  int v7; // eax\n  void *v8; // ecx\n  _DWORD *v9; // esi\n  const char *v10; // eax\n  int v11; // eax\n  int v12; // ebp\n  int v13; // edi\n  int i; // ecx\n  _BYTE **v15; // esi\n  int v16; // eax\n  _BYTE *v17; // edx\n  _BYTE *v18; // edi\n  _BYTE *v19; // eax\n  bool v20; // zf\n  _BYTE *v21; // eax\n  char v22; // dl\n  int v23; // edx\n  _BYTE *v24; // esi\n  _BYTE *v25; // ebp\n  int v26; // eax\n  int (__fastcall *v27)(int, int); // ecx\n  _BYTE *v28; // esi\n  _BYTE *v29; // esi\n  int v30; // eax\n  _BYTE *v31; // esi\n  const char *v33; // [esp-4h] [ebp-8Ch]\n  _DWORD *v34; // [esp+0h] [ebp-88h]\n  int v35; // [esp+4h] [ebp-84h]\n  void *v36; // [esp+8h] [ebp-80h] BYREF\n  int v37; // [esp+Ch] [ebp-7Ch]\n  int v38; // [esp+10h] [ebp-78h]\n  char v39; // [esp+14h] [ebp-74h]\n  int v40; // [esp+60h] [ebp-28h]\n\n  v37 = 0;\n  v38 = 0;\n  v39 = 0;\n  v36 = sub_804DB2E(8u);\n  while ( 1 )\n  {\n    v2 = *(const char **)a1;\n    if ( !*(_DWORD *)a1 )\n      return v36;\n    v3 = sub_804D222(\"-follow\", *(const char **)a1);\n    v5 = v3;\n    v6 = *(char **)(a1 + 4);\n    if ( v3 <= 13 )\n    {\n      if ( !v3 )\n      {\n        *((_BYTE *)&MEMORY[0x80DB788] + 6) |= 0x42u;\n        goto LABEL_104;\n      }\n      if ( v3 == 1 )\n      {\n        *((_BYTE *)&MEMORY[0x80DB788] + 5) = 1;\n        goto LABEL_104;\n      }\n    }\n    else\n    {\n      if ( !v6 )\n        goto LABEL_39;\n      a1 += 4;\n    }\n    if ( (unsigned int)(v3 - 28) <= 1 )\n    {\n      *(&unk_80DB780 + v3 - 28) = sub_80B4187(v4, v3 - 28);\n      goto LABEL_104;\n    }\n    if ( v3 == 2 )\n    {\n      *((_BYTE *)&MEMORY[0x80DB788] + 6) |= 8u;\n      goto LABEL_104;\n    }\n    if ( v3 != 6 && v3 != 3 )\n    {\n      switch ( v3 )\n      {\n        case 7:\n        case 4:\n          v7 = v37++;\n          v36 = sub_804DB13(v36, 4 * v7 + 12);\n          *((_DWORD *)v36 + v37 + 1) = 0;\n          v38 = 0;\n          goto LABEL_104;\n        case 8:\n        case 5:\n          v39 ^= 1u;\n          goto LABEL_104;\n        case 9:\n          *((_BYTE *)&MEMORY[0x80DB788] + 4) = 0;\n          v8 = sub_80A7047;\nLABEL_26:\n          sub_80A7054((int)&v36, 8u, (int)v8);\n          goto LABEL_104;\n        case 10:\n          *((_BYTE *)&MEMORY[0x80DB788] + 4) = 0;\n          v8 = sub_80A739D;\n          goto LABEL_26;\n      }\n      v8 = sub_80A6F65;\n      switch ( v3 )\n      {\n        case 11:\n          goto LABEL_26;\n        case 12:\n          *((_BYTE *)&MEMORY[0x80DB788] + 4) = 0;\n          v9 = sub_80A7054((int)&v36, 0x20u, (int)sub_80A7336);\n          a1 += 4;\n          v9[2] = a1;\n          while ( 1 )\n          {\n            v10 = *(const char **)a1;\n            if ( !*(_DWORD *)a1 )\n            {\n              v33 = \"-exec\";\n              goto LABEL_32;\n            }\n            if ( (*v10 & 0xEF) == 43 && !v10[1] )\n              break;\n            a1 += 4;\n            ++v9[4];\n          }\n          if ( *v10 == 43 )\n            v9[5] = sub_804DB2E(4u);\n          v11 = v9[4];\n          if ( !v11 )\n          {\nLABEL_39:\n            v33 = v2;\nLABEL_32:\n            sub_804D5E0(\"%s requires an argument\", v33);\n          }\n          v9[3] = sub_804DAFA(4 * v11);\n          v12 = v9[4];\n          v13 = 4 * v12;\n          for ( i = 0; ; i = *(_DWORD *)(v9[3] + v13) + v35 )\n          {\n            --v12;\n            v13 -= 4;\n            if ( v12 == -1 )\n              break;\n            v35 = i;\n            v34 = (_DWORD *)(v13 + v9[3]);\n            *v34 = sub_80B2928();\n          }\n          if ( i != 1 )\n          {\n            if ( v9[5] )\n              sub_804D5E0(\"only one '{}' allowed for -exec +\");\n          }\n          break;\n        case 13:\n          v15 = (_BYTE **)a1;\n          v16 = 1;\n          do\n          {\n            while ( 1 )\n            {\n              v17 = *++v15;\n              if ( !*v15 )\n                sub_804D5E0(\"unpaired '('\");\n              if ( *v17 != 40 )\n                break;\n              if ( !v17[1] )\n                ++v16;\n            }\n          }\n          while ( *v17 != 41 || v17[1] || --v16 );\n          *v15 = 0;\n          v18 = sub_80A7054((int)&v36, 0xCu, (int)sub_80A6F0A);\n          *((_DWORD *)v18 + 2) = sub_80A73B3();\n          *v15 = (_BYTE *)(\" (DUP!)\" + 6);\n          a1 = (int)v15;\n          break;\n        default:\n          if ( (unsigned int)(v3 - 14) <= 1 )\n          {\n            v19 = sub_80A7054((int)&v36, 0x10u, (int)sub_80A7198);\n            *((_DWORD *)v19 + 2) = v6;\n            v20 = v5 == 15;\nLABEL_61:\n            v19[12] = v20;\n            break;\n          }\n          if ( (unsigned int)(v3 - 16) <= 2 )\n          {\n            v19 = sub_80A7054((int)&v36, 0x10u, (int)sub_80A7177);\n            *((_DWORD *)v19 + 2) = v6;\n            v20 = v5 == 18;\n            goto LABEL_61;\n          }\n          switch ( v3 )\n          {\n            case 19:\n              sub_80A7054((int)&v36, 0x28u, (int)sub_80A713A);\n              sub_80B47BA(0, v6);\n              goto LABEL_104;\n            case 20:\n              v21 = sub_80A7054((int)&v36, 0xCu, (int)sub_80A6E9E);\n              v22 = *v6;\n              if ( *v6 == 98 )\n              {\n                v23 = 24576;\n              }\n              else\n              {\n                switch ( v22 )\n                {\n                  case 'c':\n                    v23 = 0x2000;\n                    break;\n                  case 'd':\n                    v23 = 0x4000;\n                    break;\n                  case 'p':\n                    v23 = 4096;\n                    break;\n                  case 'f':\n                    v23 = 0x8000;\n                    break;\n                  case 'l':\n                    v23 = 40960;\n                    break;\n                  case 's':\n                    v23 = 49152;\n                    break;\n                  default:\n                    goto LABEL_80;\n                }\n              }\n              if ( v6[1] )\nLABEL_80:\n                sub_804D5E0(\"invalid argument '%s' to '%s'\", v6, \"-type\");\n              *((_DWORD *)v21 + 2) = v23;\n              break;\n            case 21:\n              v24 = sub_80A7054((int)&v36, 0x10u, (int)sub_80A6EB0);\n              v24[8] = *v6;\n              if ( *v6 == 47 )\n                v25 = v6 + 1;\n              else\n                v25 = sub_80A6F6B(v6);\n              v26 = sub_80B07AF();\n              *((_DWORD *)v24 + 3) = v26;\n              if ( v26 == -1 )\n                sub_804D5E0(\"invalid mode '%s'\", v25);\n              break;\n            default:\n              v27 = sub_80A70ED;\n              switch ( v3 )\n              {\n                case 22:\n                  goto LABEL_91;\n                case 23:\n                  v27 = sub_80A70A9;\nLABEL_91:\n                  v28 = sub_80A7054((int)&v36, 0x10u, (int)v27);\n                  v28[8] = *v6;\n                  sub_80A6F6B(v6);\n                  *((_DWORD *)v28 + 3) = sub_80B40EC();\n                  goto LABEL_104;\n                case 24:\n                  v29 = sub_80A7054((int)&v36, 0xCu, (int)sub_80A6EE3);\n                  sub_804DFF3(v6);\n                  v30 = v40;\nLABEL_100:\n                  *((_DWORD *)v29 + 2) = v30;\n                  goto LABEL_104;\n                case 25:\n                  v29 = sub_80A7054((int)&v36, 0xCu, (int)sub_80A6EF0);\n                  *((_DWORD *)v29 + 2) = sub_804ED6C(10, v6, 0, a1);\n                  if ( !*(_DWORD *)dword_80DBB7C )\n                    goto LABEL_104;\n                  v30 = sub_80A9A43();\n                  goto LABEL_100;\n                case 26:\n                  v29 = sub_80A7054((int)&v36, 0xCu, (int)sub_80A6EFD);\n                  *((_DWORD *)v29 + 2) = sub_804ED6C(10, v6, 0, a1);\n                  if ( !*(_DWORD *)dword_80DBB7C )\n                    goto LABEL_104;\n                  v30 = sub_80A9A4C();\n                  goto LABEL_100;\n              }\n              if ( v3 != 27 )\n              {\n                sub_804D5F4(\"unrecognized: %s\", v2);\n                sub_804CDC2();\n              }\n              v31 = sub_80A7054((int)&v36, 0x14u, (int)sub_80A6F1A);\n              v31[8] = *v6;\n              sub_80A6F6B(v6);\n              *(_QWORD *)(v31 + 12) = sub_80B3F8E();\n              break;\n          }\n          break;\n      }\n    }\nLABEL_104:\n    a1 += 4;\n  }\n}\n"
    ],
    "sub_80A78D0": [
        "0x80a78d0",
        "int __cdecl sub_80A78D0(int a1, _DWORD *a2)\n{\n  _DWORD *i; // edi\n  _DWORD *v3; // ebx\n  int v4; // esi\n  char v5; // al\n  int j; // esi\n  char *v7; // edx\n  char v8; // al\n  int k; // esi\n  int v10; // ecx\n  int v11; // esi\n  char *v12; // ebp\n  int v13; // edi\n  int v14; // ebx\n  int v15; // eax\n  int v16; // eax\n  int v18; // [esp+0h] [ebp-70h]\n  int v19; // [esp+4h] [ebp-6Ch]\n\n  memset(&qword_80DB778, 0, 0x1Cu);\n  *(&unk_80DB780 + 1) = 0x7FFFFFFF;\n  *(&MEMORY[0x80DB788] + 2) = (char *)(sub_80B2F43() - 2048);\n  *((_BYTE *)&MEMORY[0x80DB788] + 4) = 1;\n  *((_BYTE *)&MEMORY[0x80DB788] + 6) = 1;\n  for ( i = a2; ; ++i )\n  {\n    v3 = i + 1;\n    v4 = i[1];\n    if ( !v4 || *(_BYTE *)v4 != 45 || !*(_BYTE *)(v4 + 1) || *(_BYTE *)(v4 + strspn((const char *)(v4 + 1), \"HLP\") + 1) )\n      break;\n  }\n  *v3 = 0;\n  v5 = sub_80ABEAC(a2, \"+HLP\");\n  if ( (v5 & 1) != 0 )\n    *((_BYTE *)&MEMORY[0x80DB788] + 6) |= 0x44u;\n  if ( (v5 & 2) != 0 )\n    *((_BYTE *)&MEMORY[0x80DB788] + 6) |= 0x42u;\n  *v3 = v4;\n  for ( j = 0; ; ++j )\n  {\n    v7 = (char *)v3[j];\n    if ( !v7 )\n      break;\n    v8 = *v7;\n    if ( *v7 == 45 )\n      break;\n    if ( (v8 == 33 || v8 == 40) && !v7[1] )\n      break;\n  }\n  if ( !j )\n  {\n    *i = 135072092;\n    v3 = i;\n    j = 1;\n  }\n  MEMORY[0x80DB788] = (char *)sub_80A73B3((int)&v3[j]);\n  v3[j] = 0;\n  if ( *((_BYTE *)&MEMORY[0x80DB788] + 5) )\n  {\n    HIDWORD(qword_80DB778) = j;\n    LODWORD(qword_80DB778) = sub_804DB2E(8 * j);\n    for ( k = 0; v3[k]; ++k )\n    {\n      if ( !stat64() )\n      {\n        v10 = qword_80DB778;\n        *(_DWORD *)(qword_80DB778 + 8 * k) = v18;\n        *(_DWORD *)(v10 + 8 * k + 4) = v19;\n      }\n    }\n  }\n  v11 = 0;\n  while ( *v3 )\n  {\n    if ( !sub_80B2549(sub_80A6F7C, *((unsigned __int8 *)&MEMORY[0x80DB788] + 6), sub_80A6F7C, 0, 0) )\n      v11 = 1;\n    ++v3;\n  }\n  v12 = MEMORY[0x80DB788];\n  while ( 1 )\n  {\n    v12 += 4;\n    v13 = *((_DWORD *)v12 - 1);\n    if ( !v13 )\n      break;\n    while ( 1 )\n    {\n      v13 += 4;\n      v14 = *(_DWORD *)(v13 - 4);\n      if ( !v14 )\n        break;\n      if ( *(_BOOL4 (__usercall **)@<eax>(char *@<eax>, _DWORD *@<ecx>))v14 == sub_80A7336 && *(_DWORD *)(v14 + 24) )\n      {\n        v15 = sub_80A7208(*(_DWORD **)(v13 - 4), 0);\n        if ( *(_BYTE *)(v14 + 4) )\n          v15 = v15 == 0;\n        if ( !v15 )\n        {\n          v16 = 1;\n          return v11 | v16;\n        }\n      }\n    }\n  }\n  v16 = 0;\n  return v11 | v16;\n}\n"
    ],
    "sub_80A7A88": [
        "0x80a7a88",
        "int __usercall sub_80A7A88@<eax>(int result@<eax>, int a2@<edx>, unsigned __int8 a3@<cl>)\n{\n  const char *v5; // esi\n  int v6; // [esp-10h] [ebp-10h]\n\n  if ( a2 > 0 )\n  {\n    v5 = (const char *)result;\n    if ( qword_80DB784 )\n    {\n      if ( unk_80DB783 )\n      {\n        result = a2 - 1;\n        if ( unk_80DB790 != a2 - 1 )\n          result = puts(\"--\");\n      }\n    }\n    unk_80DB783 = 1;\n    unk_80DB790 = a2;\n    if ( unk_80DB781 )\n      result = printf(\"%s%c\", dword_80DB798, a3);\n    if ( (dword_80DBB9C & 2) != 0 )\n      result = printf(\"%i%c\", a2, a3);\n    if ( (dword_80DBB9C & 0x2008) != 8200 )\n    {\n      puts(v5);\n      return v6;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80A7B36": [
        "0x80a7b36",
        "// positive sp value has been detected, the output may be wrong!\nint __usercall sub_80A7B36@<eax>(int a1@<eax>, _DWORD *a2@<ebx>)\n{\n  char *v2; // ebp\n  const char *v3; // edi\n  const char *v4; // esi\n  char *v5; // eax\n  char *v6; // edx\n  char v7; // al\n  size_t v8; // eax\n  char v9; // al\n  int v10; // eax\n  const char *v11; // edi\n  int i; // eax\n  int v13; // eax\n  int v14; // edx\n  char v15; // al\n  int v16; // eax\n  char v17; // si\n  bool v18; // zf\n  int v19; // eax\n  int v20; // edi\n  int v21; // esi\n  int v22; // eax\n  int v23; // eax\n  int v24; // esi\n  char *v25; // edi\n  int v26; // eax\n  int v28; // [esp-8h] [ebp-44h]\n  char v29; // [esp-1h] [ebp-3Dh]\n  int v30; // [esp+0h] [ebp-3Ch]\n  char v31; // [esp+7h] [ebp-35h]\n  int v32; // [esp+Ch] [ebp-30h]\n  size_t v33; // [esp+10h] [ebp-2Ch]\n  _DWORD *v35; // [esp+18h] [ebp-24h]\n  int v36; // [esp+24h] [ebp-18h]\n  char *v37; // [esp+28h] [ebp-14h]\n\n  v28 = 0;\n  v31 = 0;\n  v30 = 0;\n  while ( 2 )\n  {\n    v2 = (char *)sub_80AB85A();\n    if ( v2 )\n    {\n      v33 = unk_80DB794;\n      ++v30;\n      v29 = 0;\n      while ( v33 )\n      {\n        a2 = *(_DWORD **)(v33 + 4);\n        v32 = dword_80DBB9C;\n        if ( (dword_80DBB9C & 0x40) != 0 )\n        {\n          v3 = (const char *)*a2;\n          v4 = v2;\n          v35 = (_DWORD *)(dword_80DBB9C & 0x80);\n          while ( 1 )\n          {\n            v5 = v35 ? (char *)strcasestr((int)v4, (int)v3) : strstr(v4, v3);\n            v6 = v5;\n            if ( !v5 )\n              break;\n            if ( v36 )\n            {\n              if ( v4 != v5 || v4[strlen(v3)] )\n                break;\n              goto LABEL_14;\n            }\n            if ( (a1 & 0x10000) == 0 )\n              goto LABEL_14;\n            v7 = 32;\n            if ( v6 != v2 )\n              v7 = *(v6 - 1);\n            if ( (unsigned __int8)(v7 - 48) > 9u && (unsigned __int8)((v7 | 0x20) - 97) > 0x19u && v7 != 95 )\n            {\n              v37 = v6;\n              v8 = strlen(v3);\n              v6 = v37;\n              v9 = v37[v8];\n              if ( !v9 || (unsigned __int8)(v9 - 48) > 9u && (unsigned __int8)((v9 | 0x20) - 97) > 0x19u && v9 != 95 )\n                goto LABEL_14;\n            }\n            v4 = v6 + 1;\n          }\n        }\n        else\n        {\n          v10 = a2[11];\n          if ( (v10 & 2) == 0 )\n          {\n            a2[11] = v10 | 2;\n            sub_80B47BA(HIDWORD(qword_80DB778), *a2);\n          }\n          a2[9] = 0;\n          a2[10] = 0;\n          v11 = v2;\n          for ( i = 0; ; i = 1 )\n          {\n            v13 = regexec((const regex_t *)(a2 + 1), v11, 1u, (regmatch_t *)(a2 + 9), i);\n            if ( v13 )\n              break;\n            if ( (dword_80DBB9C & 0x20000) != 0 )\n            {\n              if ( !a2[9] )\n                LOBYTE(v13) = v11[a2[10]] == 0;\n              v29 = v13;\n              break;\n            }\n            if ( (dword_80DBB9C & 0x10000) == 0 )\n              goto LABEL_14;\n            v14 = a2[9];\n            if ( v11 > v2 || (v15 = 32, v14) )\n              v15 = v11[v14 - 1];\n            if ( (unsigned __int8)(v15 - 48) > 9u && (unsigned __int8)((v15 | 0x20) - 97) > 0x19u && v15 != 95 )\n              v15 = v11[a2[10]];\n            if ( (unsigned __int8)(v15 - 48) > 9u && (unsigned __int8)((v15 | 0x20) - 97) > 0x19u && v15 != 95 )\n              goto LABEL_14;\n            v16 = a2[10];\n            if ( !v16 )\n              break;\n            v11 += v16;\n          }\n        }\n        if ( v31 )\n        {\nLABEL_14:\n          v31 = 1;\n          if ( !(_BYTE)unk_80DB780 )\n            goto LABEL_51;\n        }\n        v35 = (_DWORD *)*v35;\n      }\n      if ( (_BYTE)unk_80DB780 == v29 )\n      {\n        if ( qword_80DB784 )\n        {\n          free(*(void **)&unk_80DB78C[4 * v28]);\n          *(_DWORD *)&unk_80DB78C[4 * v28] = v2;\n          v28 = (v28 + 1) % qword_80DB784;\n          v2 = 0;\n        }\n      }\n      else\n      {\nLABEL_51:\n        ++v32;\n        v17 = dword_80DBB9C;\n        if ( (dword_80DBB9C & 0x1005) != 0 )\n        {\n          free(v2);\n          if ( (v17 & 4) != 0 )\n            exit(0);\n          v32 = 1;\n          v18 = (v17 & 1) == 0;\n          goto LABEL_89;\n        }\n        if ( (dword_80DBB9C & 0x8000) != 0 && (int)qword_80DB778 < v32 )\n          break;\n        if ( (dword_80DBB9C & 0x20) == 0 )\n        {\n          v19 = v30 - 1;\n          if ( !v30 )\n            v19 = qword_80DB784 - 1;\n          if ( qword_80DB784 && *(_DWORD *)&unk_80DB78C[4 * v19] )\n          {\n            v20 = -qword_80DB784;\n            v21 = v30;\n            while ( !*(_DWORD *)&unk_80DB78C[4 * v21] )\n            {\n              v21 = (v21 + 1) % qword_80DB784;\n              ++v20;\n            }\n            while ( 1 )\n            {\n              v22 = *(_DWORD *)&unk_80DB78C[4 * v21];\n              if ( !v22 )\n                break;\n              sub_80A7A88(v22, v20, 0x2Du);\n              free(*(void **)&unk_80DB78C[4 * v21]);\n              *(_DWORD *)&unk_80DB78C[4 * v21] = 0;\n              v21 = (v21 + 1) % qword_80DB784;\n              ++v20;\n            }\n          }\n          v33 = *(&qword_80DB784 + 1);\n          if ( (dword_80DBB9C & 0x2000) == 0 )\n          {\n            v26 = (int)v2;\nLABEL_78:\n            sub_80A7A88(v26, 0, 0x3Au);\n            goto LABEL_81;\n          }\n          if ( (dword_80DBB9C & 0x40) == 0 )\n          {\n            while ( 1 )\n            {\n              v23 = a2[9];\n              v24 = a2[10];\n              v25 = &v2[v24];\n              v31 = v2[v24];\n              v2[v24] = 0;\n              if ( v23 == v24 )\n              {\n                if ( !v31 )\n                  goto LABEL_81;\n                *v25 = v31;\n                ++v24;\n              }\n              else\n              {\n                sub_80A7A88((int)&v2[v23], 0, 0x3Au);\n                if ( !v31 )\n                  goto LABEL_81;\n                *v25 = v31;\n              }\n              if ( regexec((const regex_t *)(a2 + 1), &v2[v24], 1u, (regmatch_t *)(a2 + 9), 1) )\n                goto LABEL_81;\n              a2[9] += v24;\n              a2[10] += v24;\n            }\n          }\n          if ( v31 )\n          {\n            v26 = *a2;\n            goto LABEL_78;\n          }\n        }\n      }\nLABEL_81:\n      free(v2);\n      if ( (dword_80DBB9C & 0x8000) == 0 || v33 || (_DWORD)qword_80DB778 != v32 )\n        continue;\n    }\n    break;\n  }\n  if ( (dword_80DBB9C & 0x20) != 0 )\n  {\n    if ( unk_80DB781 )\n      printf(\"%s:\", dword_80DB798);\n    printf(\"%d\\n\", v32);\n  }\n  v18 = (dword_80DBB9C & 0x1000) == 0;\nLABEL_89:\n  if ( !v18 )\n    puts(dword_80DB798);\n  return v32;\n}\n"
    ],
    "sub_80A8004": [
        "0x80a8004",
        "int __userpurge sub_80A8004@<eax>(char *a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4)\n{\n  _DWORD *v5; // edi\n  int v6; // eax\n  int v7; // esi\n  int v8; // eax\n  FILE *v9; // esi\n  _WORD v11[54]; // [esp+0h] [ebp-6Ch] BYREF\n\n  v5 = a3;\n  if ( (*(_DWORD *)(a2 + 16) & 0xF000) == 40960 )\n  {\n    v6 = stat64();\n    a3 = v11;\n    if ( v6 )\n    {\n      v7 = 0;\n      if ( (dword_80DBB9C & 0x10) == 0 )\n        sub_804D3F1(a1);\n      return v7;\n    }\n    v7 = 1;\n    if ( (v11[8] & 0xF000) == 0x4000 )\n      return v7;\n  }\n  v8 = sub_80B3D37(a3);\n  v9 = (FILE *)v8;\n  if ( v8 )\n  {\n    dword_80DB798 = a1;\n    *v5 += sub_80A7B36(v8, a1);\n    fclose(v9);\n    return 1;\n  }\n  else\n  {\n    if ( (dword_80DBB9C & 0x10) == 0 )\n      sub_804D3F1(a1);\n    unk_80DB782 = 1;\n    return 0;\n  }\n}\n"
    ],
    "sub_80A809F": [
        "0x80a809f",
        "int __cdecl sub_80A809F(int a1, int a2)\n{\n  int v2; // eax\n  int *v3; // ecx\n  _DWORD *i; // ebx\n  int v5; // edi\n  _DWORD *v6; // eax\n  _DWORD *v7; // edx\n  _DWORD *v8; // edi\n  int v9; // edx\n  int v10; // ecx\n  int v11; // ebp\n  _DWORD *v12; // eax\n  int v13; // ecx\n  _DWORD *v14; // eax\n  int v15; // ecx\n  char **v16; // ebx\n  char *v17; // esi\n  _DWORD *v18; // eax\n  int v19; // ecx\n  int v20; // esi\n  char *v21; // eax\n  FILE *v22; // edi\n  int v23; // eax\n  int v24; // edx\n  int v25; // ecx\n  int result; // eax\n  void *v27; // [esp+4h] [ebp-7Ch] BYREF\n  void *ptr; // [esp+8h] [ebp-78h] BYREF\n  int v29; // [esp+Ch] [ebp-74h] BYREF\n  int v30; // [esp+10h] [ebp-70h] BYREF\n  int v31; // [esp+20h] [ebp-60h]\n\n  v27 = 0;\n  byte_80DB560 = 2;\n  v2 = sub_80ABEAC(\n         a2,\n         \"^lnqvscFiHhe:*f:*Lorm:+wxA:+B:+C:+EaI\",\n         &unk_80DB794,\n         &v27,\n         &qword_80DB778,\n         (char *)&qword_80DB784 + 4,\n         135116676,\n         &ptr);\n  if ( (v2 & 0x100000) != 0 )\n  {\n    if ( (v2 & 0x40000) == 0 )\n      *(&qword_80DB784 + 1) = ptr;\n    if ( (v2 & 0x80000) == 0 )\n      qword_80DB784 = ptr;\n  }\n  if ( (v2 & 0x1025) != 0 )\n  {\n    dword_80DBB9C &= ~2u;\n    qword_80DB784 = 0;\n    *(&qword_80DB784 + 1) = 0;\n  }\n  else if ( qword_80DB784 > 0 )\n  {\n    if ( qword_80DB784 > 0xFFFFFFF )\n      qword_80DB784 = 0xFFFFFFF;\n    unk_80DB78C = (char *)sub_804DB2E(4 * qword_80DB784);\n  }\n  LOBYTE(unk_80DB780) = (dword_80DBB9C & 8) != 0;\n  for ( i = (_DWORD *)unk_80DB794; i; i = (_DWORD *)*i )\n  {\n    v5 = i[1];\n    v6 = sub_804DB2E(0x30u);\n    *v6 = v5;\n    i[1] = v6;\n  }\n  v7 = v27;\n  if ( (dword_80DBB9C & 0x800) != 0 )\n  {\n    while ( v7 )\n    {\n      v8 = (_DWORD *)*v7;\n      free(v7);\n      sub_80B3D9B();\n      while ( 1 )\n      {\n        v11 = sub_80AB85A();\n        if ( !v11 )\n          break;\n        v12 = sub_804DB2E(0x30u);\n        *v12 = v11;\n        sub_80AFAC3(v13, v12);\n      }\n      sub_80AB218(v10, v9);\n      v7 = v8;\n    }\n    if ( !unk_80DB794 )\n    {\n      v14 = sub_804DB2E(0x30u);\n      *v14 = &data;\n      sub_80AFAC3(v15, v14);\n      LOBYTE(unk_80DB780) = unk_80DB780 ^ 1;\n    }\n  }\n  if ( *ident == 102 )\n    dword_80DBB9C |= 0x40u;\n  if ( (dword_80DBB9C & 0x32000) == 0 )\n    HIDWORD(qword_80DB778) = 8;\n  if ( *ident == 101 || (dword_80DBB9C & 0x200000) != 0 )\n    HIDWORD(qword_80DB778) |= 1u;\n  if ( (dword_80DBB9C & 0x80u) != 0 )\n    HIDWORD(qword_80DB778) |= 2u;\n  v16 = (char **)(a2 + 4 * optind);\n  v17 = *v16;\n  if ( !unk_80DB794 )\n  {\n    if ( !v17 )\n      sub_804CDC2();\n    ++v16;\n    v18 = sub_804DB2E(0x30u);\n    *v18 = v17;\n    sub_80AFAC3(v19, v18);\n  }\n  if ( *v16 && v16[1] )\n    unk_80DB781 = 1;\n  if ( (dword_80DBB9C & 0x100) != 0 )\n    unk_80DB781 = 1;\n  if ( (dword_80DBB9C & 0x200) != 0 )\n    unk_80DB781 = 0;\n  v20 = 0;\n  do\n  {\n    v21 = *v16;\n    dword_80DB798 = v21;\n    v22 = stdin;\n    if ( !v21 || *v21 == 45 && !v21[1] )\n    {\n      dword_80DB798 = \"(standard input)\";\nLABEL_58:\n      v20 += sub_80A7B36((int)v22, v16);\n      sub_80AB218(v25, v24);\n      goto LABEL_59;\n    }\n    if ( (dword_80DBB9C & 0x4000) != 0 && (v23 = stat64(), v3 = &v30, !v23) && (v31 & 0xF000) == 0x4000 )\n    {\n      if ( (dword_80DBB9C & 0x200) == 0 )\n        unk_80DB781 = 1;\n      v29 = 0;\n      sub_80B2549(sub_80A8004, 13, 0, &v29, 0);\n      v20 += v29;\n    }\n    else\n    {\n      v22 = (FILE *)sub_80B3D37(v3);\n      if ( v22 )\n        goto LABEL_58;\n      if ( (dword_80DBB9C & 0x10) == 0 )\n        sub_804D3F1(dword_80DB798);\n      unk_80DB782 = 1;\n    }\nLABEL_59:\n    if ( !*v16 )\n      break;\n    ++v16;\n  }\n  while ( *v16 );\n  result = 2;\n  if ( !unk_80DB782 )\n    return v20 == 0;\n  return result;\n}\n"
    ],
    "sub_80A83BF": [
        "0x80a83bf",
        "char *__usercall sub_80A83BF@<eax>(int a1@<eax>)\n{\n  char *result; // eax\n\n  if ( !(_BYTE)unk_80DB78C )\n    LODWORD(qword_80DB778) = sub_804DB13((void *)qword_80DB778, 4 * (_DWORD)unk_80DB78C + 1024);\n  result = unk_80DB78C++;\n  *(_DWORD *)(qword_80DB778 + 4 * (_DWORD)result) = a1;\n  return result;\n}\n"
    ],
    "sub_80A83FB": [
        "0x80a83fb",
        "char *__usercall sub_80A83FB@<eax>(char *s@<ecx>, int a2@<eax>)\n{\n  int i; // ebx\n  void *v5; // edx\n  char *v6; // edi\n  char *v7; // ebx\n  unsigned __int8 *v8; // edx\n  int v9; // eax\n  int j; // edi\n  int v11; // ebx\n\n  for ( i = 0; (_DWORD)qword_80DB778; i += 4 )\n  {\n    v5 = *(void **)(qword_80DB778 + i);\n    if ( !v5 )\n      break;\n    if ( *(void **)(HIDWORD(qword_80DB778) + i) != v5 )\n      free(v5);\n  }\n  v6 = &s[a2];\n  v7 = s;\n  while ( 1 )\n  {\n    v8 = *(unsigned __int8 **)(_stdin + 16);\n    if ( (unsigned int)v8 < *(_DWORD *)(_stdin + 24) )\n    {\n      *(_DWORD *)(_stdin + 16) = v8 + 1;\n      v9 = *v8;\nLABEL_13:\n      if ( qword_80DB784 != v9 )\n        goto LABEL_14;\n      goto LABEL_11;\n    }\n    v9 = __fgetc_unlocked();\n    if ( v9 != -1 )\n      goto LABEL_13;\nLABEL_11:\n    if ( v7 == s )\n      goto LABEL_22;\n    v9 = 0;\nLABEL_14:\n    *v7++ = v9;\n    if ( !v9 )\n      break;\n    if ( v6 == v7 )\n      goto LABEL_23;\n  }\n  for ( j = 0; ; j += 4 )\n  {\n    v11 = *(_DWORD *)(HIDWORD(qword_80DB778) + j);\n    if ( !v11 )\n      break;\n    if ( sub_80B2928() )\n      v11 = sub_80B2955((char *)unk_80DB780, s);\n    sub_80A83BF(v11);\n  }\nLABEL_22:\n  v7 = s;\nLABEL_23:\n  *v7 = 0;\n  return s;\n}\n"
    ],
    "sub_80A84BF": [
        "0x80a84bf",
        "char *__usercall sub_80A84BF@<eax>(char *s@<ecx>, int a2@<eax>, int a3@<edx>)\n{\n  char *v5; // ebx\n  char *v6; // esi\n  char *v7; // edi\n  unsigned __int8 *v8; // edx\n  int v9; // eax\n\n  v5 = s;\n  v6 = &s[strlen(s)];\n  v7 = &v5[a2];\n  while ( 1 )\n  {\n    v8 = *(unsigned __int8 **)(_stdin + 16);\n    if ( (unsigned int)v8 >= *(_DWORD *)(_stdin + 24) )\n      break;\n    *(_DWORD *)(_stdin + 16) = v8 + 1;\n    v9 = *v8;\nLABEL_7:\n    *v6++ = v9;\n    if ( !v9 )\n    {\n      sub_80A83BF((int)v5);\n      v5 = v6;\n      if ( !--a3 )\n        goto LABEL_12;\n    }\n    if ( v7 == v6 )\n      goto LABEL_12;\n  }\n  v9 = __fgetc_unlocked();\n  if ( v9 != -1 )\n    goto LABEL_7;\n  if ( v5 != v6 )\n  {\n    v9 = 0;\n    goto LABEL_7;\n  }\n  v6 = v5;\nLABEL_12:\n  *v6 = 0;\n  return v5;\n}\n"
    ],
    "sub_80A8525": [
        "0x80a8525",
        "const char *__usercall sub_80A8525@<eax>(char *s1@<ecx>, int a2@<eax>, int a3@<edx>)\n{\n  const char *v4; // ebx\n  char *v5; // esi\n  char v6; // dl\n  unsigned __int8 v7; // bp\n  unsigned __int8 *v8; // ecx\n  int v9; // eax\n  const char *v10; // eax\n  unsigned int v11; // edx\n  char *v13; // [esp+0h] [ebp-1Ch]\n  char v15; // [esp+Bh] [ebp-11h]\n\n  v4 = s1;\n  v5 = &s1[strlen(s1)];\n  v13 = (char *)&v4[a2];\n  v6 = 0;\n  v7 = 0;\n  while ( 1 )\n  {\n    v8 = *(unsigned __int8 **)(_stdin + 16);\n    if ( (unsigned int)v8 >= *(_DWORD *)(_stdin + 24) )\n    {\n      v15 = v6;\n      v9 = __fgetc_unlocked();\n      v6 = v15;\n      if ( v9 == -1 )\n      {\n        if ( v4 == v5 )\n          goto LABEL_41;\nLABEL_6:\n        LOBYTE(v9) = 0;\n        v6 = 4;\n        goto LABEL_21;\n      }\n    }\n    else\n    {\n      *(_DWORD *)(_stdin + 16) = v8 + 1;\n      v9 = *v8;\n    }\n    if ( v6 == 2 )\n    {\n      v6 = 0;\n      goto LABEL_21;\n    }\n    if ( v6 != 1 )\n      break;\n    if ( v7 != v9 )\n      goto LABEL_21;\n    v7 = 0;\nLABEL_33:\n    v6 = 0;\nLABEL_39:\n    if ( v13 == v5 )\n      goto LABEL_42;\n  }\n  if ( (_BYTE)v9 == 32 || (unsigned __int8)(v9 - 9) <= 4u )\n  {\n    if ( v4 == v5 )\n      goto LABEL_39;\n    goto LABEL_6;\n  }\n  switch ( v9 )\n  {\n    case '\\\\':\n      v6 = 2;\n      goto LABEL_39;\n    case '\\'':\n      v7 = 39;\nLABEL_37:\n      v6 = 1;\n      goto LABEL_39;\n    case '\"':\n      v7 = 34;\n      goto LABEL_37;\n  }\nLABEL_21:\n  *v5 = v9;\n  if ( v6 != 4 )\n  {\n    ++v5;\n    goto LABEL_39;\n  }\n  if ( v7 )\n  {\n    v10 = \"single\";\n    if ( v7 != 39 )\n      v10 = \"double\";\n    sub_804D5E0(\"unmatched %s quote\", v10);\n  }\n  if ( !*(&qword_80DB784 + 1) || strcmp(v4, *(&qword_80DB784 + 1)) )\n  {\n    sub_80A83BF((int)v4);\n    v4 = ++v5;\n    if ( !--a3 )\n      goto LABEL_42;\n    goto LABEL_33;\n  }\n  do\n  {\n    while ( 1 )\n    {\n      v11 = *(_DWORD *)(_stdin + 16);\n      if ( v11 >= *(_DWORD *)(_stdin + 24) )\n        break;\n      *(_DWORD *)(_stdin + 16) = v11 + 1;\n    }\n  }\n  while ( __fgetc_unlocked() != -1 );\nLABEL_41:\n  v5 = (char *)v4;\nLABEL_42:\n  *v5 = 0;\n  return v4;\n}\n"
    ],
    "sub_80A867D": [
        "0x80a867d",
        "int __usercall sub_80A867D@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  __pid_t v2; // eax\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  v3 = a1;\n  if ( unk_80DB794 == 1 )\n  {\n    result = sub_80B3C03((const char **)qword_80DB778);\n    goto LABEL_18;\n  }\n  while ( 1 )\n  {\n    v2 = unk_80DB790 < (int)unk_80DB794 ? sub_804DA5C(&v3) : sub_804DA34(0, &v3, -1);\n    if ( v2 <= 0 )\n      break;\n    if ( unk_80DB790 )\n      --unk_80DB790;\n    result = BYTE1(v3);\n    if ( (unsigned int)(unsigned __int16)v3 - 1 <= 0xFE )\n      result = (v3 & 0x7F) + 384;\n    if ( (unsigned int)(result - 1) > 0xFD )\n    {\n      if ( result )\n        goto LABEL_18;\n    }\n    else\n    {\n      LOBYTE(dword_80DB798) = 123;\n    }\n  }\n  result = unk_80DB794;\n  if ( unk_80DB794 )\n  {\n    result = sub_80B3BA2((const char **)qword_80DB778);\n    if ( result > 0 )\n    {\n      ++unk_80DB790;\n      return 0;\n    }\nLABEL_18:\n    if ( result < 0 )\n    {\n      sub_804D3F1(*(const char **)qword_80DB778);\n      result = (*(_DWORD *)dword_80DBB7C == 2) + 126;\nLABEL_27:\n      LOBYTE(dword_80DB798) = result;\n      return result;\n    }\n    if ( result > 383 )\n    {\n      sub_804D5F4(\"'%s' terminated by signal %d\", *(const char **)qword_80DB778, result - 384);\n      result = 125;\n      goto LABEL_27;\n    }\n    if ( !result )\n      return result;\n    if ( result == 255 )\n    {\n      sub_804D5F4(\"%s: exited with status 255; aborting\", *(const char **)qword_80DB778);\n      return 124;\n    }\n    LOBYTE(dword_80DB798) = 123;\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80A87A3": [
        "0x80a87a3",
        "int __cdecl sub_80A87A3(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // eax\n  _DWORD *v4; // esi\n  int v5; // eax\n  int v6; // edi\n  _DWORD *v7; // ebp\n  _DWORD *v8; // ecx\n  int v9; // edx\n  _DWORD *v10; // ecx\n  const char *v11; // eax\n  int v12; // edi\n  int v13; // eax\n  char *v14; // esi\n  _BYTE *v15; // ebp\n  int v16; // ebx\n  const char *i; // edx\n  int v18; // ecx\n  int (__fastcall *v20)(void *, int); // [esp+0h] [ebp-30h]\n  int v21; // [esp+4h] [ebp-2Ch]\n  _DWORD *v22; // [esp+8h] [ebp-28h]\n  void *v23; // [esp+8h] [ebp-28h]\n  int v24; // [esp+Ch] [ebp-24h]\n  int v25; // [esp+10h] [ebp-20h]\n  int v26; // [esp+14h] [ebp-1Ch] BYREF\n  int v27; // [esp+18h] [ebp-18h] BYREF\n  const char *v28; // [esp+1Ch] [ebp-14h] BYREF\n\n  v28 = 0;\n  *(&qword_80DB784 + 1) = 0;\n  unk_80DB78C = 0;\n  unk_80DB790 = 0;\n  unk_80DB794 = 1;\n  LOBYTE(dword_80DB798) = 0;\n  unk_80DB780 = 135102500;\n  qword_80DB784 = 10;\n  v2 = sub_80ABEC2(\n         a2,\n         \"+trn:s:e::E:x0I:i::P:+a:\",\n         \"no-run-if-empty\",\n         &v26,\n         &v27,\n         (char *)&qword_80DB784 + 4,\n         (char *)&qword_80DB784 + 4,\n         &unk_80DB780,\n         &unk_80DB780,\n         &unk_80DB794,\n         &v28);\n  if ( (int)unk_80DB794 <= 0 )\n    unk_80DB794 = 100;\n  if ( v28 )\n  {\n    v3 = sub_804DBE1(v28);\n    sub_804DC97(v3, 0);\n  }\n  if ( (v2 & 0x20) != 0 && !**(&qword_80DB784 + 1) )\n    *(&qword_80DB784 + 1) = 0;\n  v20 = (int (__fastcall *)(void *, int))sub_80A8525;\n  if ( (v2 & 0x80u) != 0 )\n  {\n    qword_80DB784 = 0;\n    v20 = (int (__fastcall *)(void *, int))sub_80A84BF;\n  }\n  v4 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v4 )\n    *--v4 = \"echo\";\n  v5 = sub_80B2F43();\n  if ( v5 > 0x8000 )\n    v5 = 0x8000;\n  v6 = v5 - 2048;\n  if ( (v2 & 8) != 0 )\n    v6 = sub_80B40CC(0x7FFFFFFF, 1);\n  v7 = v4;\n  v8 = v4;\n  v9 = 0;\n  while ( 1 )\n  {\n    v10 = v8 + 1;\n    v11 = (const char *)*(v10 - 1);\n    if ( !v11 )\n      break;\n    v22 = v10;\n    v9 += strlen(v11) + 1;\n    v8 = v22;\n  }\n  v12 = v6 - v9;\n  if ( v12 <= 0 )\n    sub_804D5E0(\"can't fit single argument within argument list size limit\");\n  v23 = sub_804DB2E(v12 + 1);\n  v21 = v12;\n  if ( (v2 & 4) != 0 )\n    v21 = sub_80B40CC(0x7FFFFFFF, 1);\n  if ( (v2 & 0x300) != 0 )\n  {\n    LODWORD(qword_80DB778) = 0;\n    HIDWORD(qword_80DB778) = v4;\n    v2 |= 2u;\n    v20 = (int (__fastcall *)(void *, int))sub_80A83FB;\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v13 = *v7++;\n      if ( !v13 )\n        break;\n      sub_80A83BF(v13);\n    }\n  }\n  v14 = unk_80DB78C;\n  v24 = 4 * (_DWORD)unk_80DB78C;\n  while ( 1 )\n  {\n    unk_80DB78C = v14;\n    v15 = (_BYTE *)v20(v23, v21);\n    sub_80A83BF(0);\n    if ( !*(_DWORD *)(qword_80DB778 + v24) )\n    {\n      if ( *v15 )\n        sub_804D5E0(\"argument line too long\");\n      if ( (v2 & 2) != 0 )\n        break;\n    }\n    v25 = v2 | 2;\n    if ( (v2 & 1) != 0 )\n    {\n      v16 = qword_80DB778;\n      for ( i = \"%s\"; ; i = \"  %s\" + 1 )\n      {\n        v16 += 4;\n        if ( !*(_DWORD *)(v16 - 4) )\n          break;\n        fprintf(stderr, i, *(_DWORD *)(v16 - 4));\n      }\n      sub_804D830(10, (int)i);\n    }\n    if ( sub_80A867D() )\n      break;\n    sub_80B2C69(v18);\n    v2 = v25;\n  }\n  unk_80DB794 = 0;\n  sub_80A867D();\n  return (unsigned __int8)dword_80DB798;\n}\n"
    ],
    "sub_80A8A40": [
        "0x80a8a40",
        "int sub_80A8A40()\n{\n  int v1[96]; // [esp+0h] [ebp-310h] BYREF\n  struct utsname name; // [esp+182h] [ebp-18Eh] BYREF\n\n  memset(v1, 0, sizeof(v1));\n  v1[85] = time(0);\n  strcpy((char *)&v1[11], \"shutdown\");\n  LOWORD(v1[0]) = 1;\n  LOWORD(v1[10]) = 32382;\n  LOWORD(v1[2]) = 32382;\n  uname(&name);\n  sub_80B2C4E(256, name.release);\n  return updwtmpx();\n}\n"
    ],
    "sub_80A8ABD": [
        "0x80a8abd",
        "int __cdecl sub_80A8ABD(int a1, int a2)\n{\n  int i; // ebx\n  char v3; // si\n  __pid_t v4; // eax\n  int v5; // edi\n  int v6; // esi\n  int v7; // ebx\n  int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  int v12; // [esp-8h] [ebp-18h]\n  int v13; // [esp-4h] [ebp-14h]\n  int v14; // [esp-4h] [ebp-14h]\n  unsigned int v15; // [esp+0h] [ebp-10h] BYREF\n\n  v15 = 0;\n  for ( i = 0; byte_80D87B6[i] != *ident; ++i )\n    ;\n  v3 = sub_80ABEAC(a2, \"d:+nfwi\", &v15);\n  sleep(v15);\n  sub_80A8A40();\n  if ( (v3 & 8) == 0 )\n  {\n    if ( (v3 & 2) == 0 )\n      sync();\n    if ( (v3 & 4) != 0 )\n    {\n      v6 = reboot(howto[i]);\n      v10 = v14;\n    }\n    else\n    {\n      v4 = *(_DWORD *)sub_80AB493();\n      v5 = byte_80D87CA[i];\n      if ( v4 > 0 && !kill(v4, byte_80D87CA[i]) )\n        return 0;\n      v6 = kill(1, v5);\n      v7 = 4;\n      while ( 1 )\n      {\n        v8 = access(\"/proc/meminfo\", 0);\n        v9 = v12;\n        v10 = v13;\n        if ( !v8 )\n          break;\n        if ( --v7 == -1 )\n          goto LABEL_16;\n        sleep(1u);\n      }\n      if ( v7 == 4 )\n        goto LABEL_18;\nLABEL_16:\n      v6 = kill(1, v5);\n    }\nLABEL_18:\n    if ( v6 )\n      sub_80B0A23(v10, v9);\n  }\n  return 0;\n}\n"
    ],
    "sub_80A8BA7": [
        "0x80a8ba7",
        "int sub_80A8BA7()\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  sleep(0x278D00u);\n  return v1;\n}\n"
    ],
    "sub_80A8BB3": [
        "0x80a8bb3",
        "int sub_80A8BB3()\n{\n  struct termios v1; // [esp+0h] [ebp-3Ch] BYREF\n\n  tcgetattr(0, &v1);\n  *(_WORD *)&v1.c_cc[8] = 4881;\n  v1.c_cc[10] = 26;\n  *(_DWORD *)&v1.c_line = 2132542208;\n  *(_WORD *)&v1.c_cc[3] = 1045;\n  v1.c_cflag = v1.c_cflag & 0x8000137F | 0xC80;\n  v1.c_iflag = 5376;\n  v1.c_oflag = 5;\n  v1.c_lflag = 35387;\n  return sub_804D995(&v1);\n}\n"
    ],
    "sub_80A8C10": [
        "0x80a8c10",
        "int __usercall sub_80A8C10@<eax>(char *s2@<ecx>, char *src@<edx>, char a3@<al>)\n{\n  char *v5; // ebx\n  __int64 *v6; // ebp\n  size_t v7; // eax\n\n  v5 = (char *)qword_80DB778;\n  v6 = &qword_80DB778;\n  while ( 1 )\n  {\n    if ( !v5 )\n    {\n      v7 = strlen(src);\n      v5 = (char *)sub_804DB2E(v7 + 44);\n      goto LABEL_11;\n    }\n    if ( !strcmp(v5 + 41, src) && !strcmp(v5 + 9, s2) )\n      break;\n    v6 = (__int64 *)v5;\n    v5 = *(char **)v5;\n  }\n  for ( *(_DWORD *)v6 = *(_DWORD *)v5; *(_DWORD *)v6; v6 = *(__int64 **)v6 )\n    ;\n  *(_DWORD *)v5 = 0;\nLABEL_11:\n  *(_DWORD *)v6 = v5;\n  v5[8] = a3;\n  strcpy(v5 + 41, src);\n  return sub_80B2C4E(32, s2);\n}\n"
    ],
    "sub_80A8CA3": [
        "0x80a8ca3",
        "void __usercall __noreturn sub_80A8CA3(int a1@<eax>)\n{\n  sleep(1u);\n  if ( !vfork() )\n  {\n    reboot(a1);\n    _exit(0);\n  }\n  while ( 1 )\n    sleep(1u);\n}\n"
    ],
    "sub_80A8CD1": [
        "0x80a8cd1",
        "int sub_80A8CD1()\n{\n  sub_804E6C8(1610766, 0);\n  return sub_804E6A5(1);\n}\n"
    ],
    "sub_80A8CE7": [
        "0x80a8ce7",
        "_DWORD *__usercall sub_80A8CE7@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  if ( a1 <= 0 )\n    return 0;\n  sub_80B3947();\n  for ( result = (_DWORD *)qword_80DB778; ; result = (_DWORD *)*result )\n  {\n    if ( !result )\n      return 0;\n    if ( result[1] == a1 )\n      break;\n  }\n  result[1] = 0;\n  return result;\n}\n"
    ],
    "sub_80A8D17": [
        "0x80a8d17",
        "__int64 sub_80A8D17()\n{\n  char v0; // bl\n  _DWORD *v1; // edi\n  int v2; // esi\n  int v3; // eax\n  __int64 v5; // [esp-8h] [ebp-14h]\n\n  v0 = byte_80DBBA4;\n  v1 = (_DWORD *)dword_80DBB7C;\n  v2 = *(_DWORD *)dword_80DBB7C;\n  signal(18, (__sighandler_t)sub_804E68E);\n  while ( byte_80DBBA4 != 18 )\n  {\n    v3 = sub_804DA5C(0);\n    sub_80A8CE7(v3);\n    sleep(1u);\n  }\n  signal(18, 0);\n  *v1 = v2;\n  byte_80DBBA4 = v0;\n  return v5;\n}\n"
    ],
    "sub_80A8D6C": [
        "0x80a8d6c",
        "void sub_80A8D6C(char a1, char *format, ...)\n{\n  unsigned int v2; // ebx\n  char v3; // [esp+0h] [ebp-88h] BYREF\n  char s[135]; // [esp+1h] [ebp-87h] BYREF\n  va_list __varargs; // [esp+94h] [ebp+Ch] BYREF\n\n  va_start(__varargs, format);\n  v3 = 13;\n  v2 = vsnprintf(s, 0x7Eu, format, __varargs) + 1;\n  if ( v2 > 0x7E )\n    v2 = 126;\n  s[v2 - 1] = 0;\n  if ( (a1 & 1) != 0 )\n  {\n    openlog(ident, 0, 24);\n    syslog(6, \"%s\", s);\n    closelog();\n  }\n  s[v2 - 1] = 10;\n  s[v2] = 0;\n  if ( (a1 & 2) != 0 )\n    sub_804E586(v2 + 1, &v3);\n}\n"
    ],
    "sub_80A8DF9": [
        "0x80a8df9",
        "int __fastcall sub_80A8DF9(int a1)\n{\n  int v1; // esi\n  char *v3; // ebx\n  int v4; // edi\n  _BYTE *v5; // eax\n  int v6; // ecx\n  int v7; // edx\n  int v8; // ecx\n  char *ptr; // [esp+0h] [ebp-1Ch]\n  const char *v10; // [esp+8h] [ebp-14h]\n  char *src; // [esp+Ch] [ebp-10h]\n\n  v1 = sub_80B0511(a1, sub_80B3D37);\n  if ( v1 )\n  {\n    while ( sub_80B0560(\"#:\") )\n    {\n      v3 = ptr;\n      if ( src && (v4 = sub_804D222(\"sysinit\", v10), v4 >= 0) && *src )\n      {\n        if ( *ptr )\n        {\n          v5 = (_BYTE *)sub_80B2EB2();\n          v3 = (char *)sub_804D2D1((int)\"/dev/\", v5, v6);\n        }\n        sub_80A8C10(v3, src, 1 << v4);\n        if ( *v3 )\n          free(v3);\n      }\n      else\n      {\n        sub_80A8D6C(3, \"Bad inittab entry at line %d\", *(_DWORD *)(v1 + 24));\n      }\n    }\n    return sub_80B0536(v8, v7);\n  }\n  else\n  {\n    sub_80A8C10((char *)&data, \"/etc/init.d/rcS\", 1);\n    sub_80A8C10((char *)&data, \"-/bin/sh\", 16);\n    sub_80A8C10(\"/dev/tty2\", \"-/bin/sh\", 16);\n    sub_80A8C10(\"/dev/tty3\", \"-/bin/sh\", 16);\n    sub_80A8C10(\"/dev/tty4\", \"-/bin/sh\", 16);\n    sub_80A8C10((char *)&data, \"reboot\", 32);\n    sub_80A8C10((char *)&data, \"umount -a -r\", 64);\n    sub_80A8C10((char *)&data, \"swapoff -a\", 64);\n    return sub_80A8C10((char *)&data, \"init\", 128);\n  }\n}\n"
    ],
    "sub_80A8F72": [
        "0x80a8f72",
        "int __usercall sub_80A8F72@<eax>(const char *a1@<eax>)\n{\n  if ( *a1 )\n  {\n    close(0);\n    if ( sub_80AA444() )\n    {\n      sub_80A8D6C(3, \"can't open %s: %m\", a1);\n      return 0;\n    }\n    dup2(0, 1);\n    dup2(0, 2);\n  }\n  sub_80A8BB3();\n  return 1;\n}\n"
    ],
    "sub_80A8FC7": [
        "0x80a8fc7",
        "void __usercall sub_80A8FC7(const char *a1@<eax>)\n{\n  size_t v2; // eax\n  void *v3; // esp\n  void *v4; // esp\n  char *v5; // eax\n  const char *v6; // ebx\n  int v7; // esi\n  char *v8; // eax\n  char *s; // [esp+0h] [ebp-20h] BYREF\n  char *v10; // [esp+4h] [ebp-1Ch]\n  char *v11; // [esp+8h] [ebp-18h]\n  int v12; // [esp+Ch] [ebp-14h]\n  char *stringp; // [esp+10h] [ebp-10h] BYREF\n\n  v2 = strlen(a1);\n  v3 = alloca(v2 + 8);\n  s = (char *)&s;\n  v4 = alloca(((2 * v2 + 16) & 0xFFFFFFFC) + 4);\n  HIBYTE(v12) = *a1;\n  v11 = (char *)(HIBYTE(v12) == 45);\n  v10 = &v11[(_DWORD)a1];\n  if ( strpbrk(&v11[(_DWORD)a1], \"~`!$^&*()=|\\\\{}[];\\\"'<>?\") )\n  {\n    v11 = s;\n    sprintf(s, \"exec %s\", v10);\n    v5 = \"-/bin/sh\";\n    if ( HIBYTE(v12) != 45 )\n      v5 = \"-/bin/sh\" + 1;\n    s = v5;\n    v10 = \"-c\";\n    v12 = 0;\n    v6 = \"/bin/sh\";\n  }\n  else\n  {\n    stringp = strcpy(s, a1);\n    v6 = &v11[(_DWORD)stringp];\n    v7 = 0;\n    while ( 1 )\n    {\n      v8 = strsep(&stringp, \" \\t\");\n      if ( !v8 )\n        break;\n      if ( *v8 )\n        (&s)[v7++] = v8;\n    }\n    (&s)[v7] = 0;\n  }\n  if ( HIBYTE(v12) == 45 )\n    ioctl(0, 0x540Eu, 0);\n  execvp(v6, &s);\n  sub_80A8D6C(3, \"can't run '%s': %m\", v6);\n}\n"
    ],
    "sub_80A90EC": [
        "0x80a90ec",
        "__pid_t __usercall sub_80A90EC@<eax>(int a1@<eax>)\n{\n  __pid_t v1; // eax\n  __pid_t v2; // ebx\n  __pid_t v3; // eax\n  char buf[9]; // [esp+7h] [ebp-9h] BYREF\n\n  sub_804E6A5(0);\n  if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 )\n    v1 = fork();\n  else\n    v1 = vfork();\n  v2 = v1;\n  if ( v1 < 0 )\n    sub_80A8D6C(3, \"can't fork\");\n  if ( !v2 )\n  {\n    sub_80A8CD1();\n    setsid();\n    if ( !sub_80A8F72((const char *)(a1 + 9)) )\n      _exit(1);\n    if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 )\n    {\n      sub_804E586(0x2Eu, \"\\nPlease press Enter to activate this console. \");\n      while ( sub_804E5BC(1u, buf, 0) == 1 && buf[0] != 10 )\n        ;\n    }\n    v3 = getpid();\n    sub_80A8D6C(1, \"starting pid %u, tty '%s': '%s'\", v3, a1 + 9, a1 + 41);\n    sub_80A8FC7((const char *)(a1 + 41));\n    _exit(-1);\n  }\n  sub_804E6A5(1);\n  return v2;\n}\n"
    ],
    "sub_80A91C3": [
        "0x80a91c3",
        "__pid_t __usercall sub_80A91C3@<eax>(__pid_t result@<eax>)\n{\n  __pid_t v1; // edi\n  int i; // ebx\n  __pid_t v3; // edx\n  __pid_t v4; // esi\n  int v5; // eax\n\n  v1 = result;\n  for ( i = qword_80DB778; i; i = *(_DWORD *)i )\n  {\n    v3 = *(unsigned __int8 *)(i + 8);\n    result = v3;\n    if ( (v1 & v3) != 0 )\n    {\n      if ( (v3 & 0x67) != 0 )\n      {\n        result = sub_80A90EC(i);\n        v4 = result;\n        if ( (*(_BYTE *)(i + 8) & 0x63) != 0 && result > 0 )\n        {\n          do\n          {\n            v5 = wait(0);\n            sub_80A8CE7(v5);\n            result = kill(v4, 0);\n          }\n          while ( !result );\n        }\n      }\n      if ( (*(_BYTE *)(i + 8) & 0x18) != 0 && !*(_DWORD *)(i + 4) )\n      {\n        result = sub_80A90EC(i);\n        *(_DWORD *)(i + 4) = result;\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80A922C": [
        "0x80a922c",
        "void sub_80A922C()\n{\n  sub_80A91C3(64);\n  sub_80A8D6C(3, \"The system is going down NOW!\");\n  kill(-1, 15);\n  sub_80A8D6C(2, \"Sent SIG%s to all processes\", \"TERM\");\n  sync();\n  sleep(1u);\n  kill(-1, 9);\n  sub_80A8D6C(2, \"Sent SIG%s to all processes\", \"KILL\");\n  sync();\n}\n"
    ],
    "sub_80A928D": [
        "0x80a928d",
        "int sub_80A928D()\n{\n  int result; // eax\n  char v1; // bl\n  int *i; // eax\n  int *j; // ebx\n  __pid_t v4; // eax\n  __int64 *v5; // ebx\n  __int64 *v6; // eax\n  const char *k; // ebx\n  int v8; // eax\n  int v9; // ebx\n  const char *v10; // eax\n  int v11; // [esp-4h] [ebp-Ch]\n\n  for ( result = 0; ; result = 1 )\n  {\n    v1 = byte_80DBBA4;\n    if ( !byte_80DBBA4 )\n      break;\n    byte_80DBBA4 = 0;\n    if ( v1 == 1 )\n    {\n      sub_80A8D6C(1, \"reloading /etc/inittab\");\n      for ( i = (int *)qword_80DB778; i; i = (int *)*i )\n        *((_BYTE *)i + 8) = 0;\n      sub_80A8DF9(v11);\n      for ( j = (int *)qword_80DB778; j; j = (int *)*j )\n      {\n        if ( !*((_BYTE *)j + 8) )\n        {\n          v4 = j[1];\n          if ( v4 )\n            kill(v4, 15);\n        }\n      }\n      v5 = &qword_80DB778;\n      while ( 1 )\n      {\n        v6 = *(__int64 **)v5;\n        if ( !*(_DWORD *)v5 )\n          break;\n        if ( (v6[1] & 0xFE) != 0 || *((_DWORD *)v6 + 1) )\n        {\n          v5 = *(__int64 **)v5;\n        }\n        else\n        {\n          *(_DWORD *)v5 = *(_DWORD *)v6;\n          free(v6);\n        }\n      }\n      continue;\n    }\n    if ( v1 == 2 )\n    {\n      sub_80A91C3(32);\nLABEL_30:\n      v8 = 1073779712;\n      if ( _bittest(&v8, v1) )\n      {\n        sub_80A8CD1();\n        sub_80A922C();\n        if ( v1 == 15 )\n        {\n          v9 = 19088743;\n          v10 = \"/crond.reboot\" + 7;\n        }\n        else if ( v1 == 12 )\n        {\n          v9 = 1126301404;\n          v10 = \"poweroff\";\n        }\n        else\n        {\n          v9 = -839974621;\n          v10 = \"halt\";\n        }\n        sub_80A8D6C(2, \"Requesting system %s\", v10);\n        sub_80A8CA3(v9);\n      }\n      continue;\n    }\n    if ( v1 != 3 )\n      goto LABEL_30;\n    for ( k = (const char *)qword_80DB778; k; k = *(const char **)k )\n    {\n      if ( k[8] < 0 )\n      {\n        sub_80A8CD1();\n        sub_80A922C();\n        reboot(-1985229329);\n        if ( sub_80A8F72(k + 9) )\n          sub_80A8FC7(k + 41);\n        sub_80A8CA3(-839974621);\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80A93E1": [
        "0x80a93e1",
        "int __cdecl sub_80A93E1(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  const char *v3; // eax\n  int v4; // esi\n  char *v5; // edi\n  int v6; // ecx\n  const char *v7; // edx\n  int v8; // edi\n  int v9; // eax\n  char *v10; // edi\n  size_t v11; // eax\n  int v12; // ebx\n  int v13; // ebx\n  int i; // esi\n  int v15; // eax\n  int v16; // ebx\n  const char *v17; // eax\n  int v19; // [esp+0h] [ebp-24h]\n  size_t v20[3]; // [esp+4h] [ebp-20h] BYREF\n  int v21[5]; // [esp+10h] [ebp-14h] BYREF\n\n  v2 = (_DWORD *)a2;\n  v3 = *(const char **)(a2 + 4);\n  if ( !v3 || strcmp(v3, \"-q\") )\n  {\n    sub_804E6A5(0);\n    if ( getpid() != 1 && *ident != 108 )\n      sub_804D5E0(\"must be run as PID 1\");\n    reboot(0);\n    dword_80DBB84 = sub_80A8BA7;\n    if ( getenv(\"CONSOLE\") || getenv(\"console\") )\n    {\n      v4 = open64();\n      if ( v4 >= 0 )\n      {\n        dup2(v4, 0);\n        dup2(v4, 1);\n        sub_804DC97(v4, 2);\n      }\n    }\n    else\n    {\n      sub_80B3CDB();\n    }\n    v5 = getenv(\"TERM\");\n    if ( ioctl(0, 0x5600u, v20) )\n    {\n      if ( !v5 || !strcmp(v5, \"linux\") )\n        putenv(\"TERM=vt102\");\n    }\n    else if ( !v5 )\n    {\n      putenv(\"TERM=linux\");\n    }\n    sub_80A8BB3();\n    sub_804DF04(\"/\");\n    setsid();\n    putenv(\"HOME=/\");\n    putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\");\n    putenv(\"SHELL=/bin/sh\");\n    putenv(\"USER=root\");\n    v7 = *(const char **)(a2 + 4);\n    if ( v7 )\n      sub_804DDE4(\"RUNLEVEL\", v7);\n    v8 = *(_DWORD *)(a2 + 4);\n    if ( v8\n      && (!strcmp((const char *)v8, \"single\")\n       || (v9 = strcmp((const char *)v8, \"-s\"), v6 = v19, !v9)\n       || *(_BYTE *)v8 == 49 && !*(_BYTE *)(v8 + 1)) )\n    {\n      sub_80A8C10((char *)&data, \"-/bin/sh\", 8);\n    }\n    else\n    {\n      sub_80A8DF9(v6);\n    }\n    v10 = *(char **)a2;\n    v11 = strlen(*(const char **)a2);\n    strncpy(v10, \"init\", v11);\n    while ( *++v2 )\n      sub_80B030A();\n    memset(v20, 0, sizeof(v20));\n    v21[0] = -1;\n    v21[1] = -1;\n    sigdelset((sigset_t *)v21, 18);\n    v20[0] = (size_t)sub_80A8D17;\n    sub_804E698(20, (const struct sigaction *)v20);\n    sub_804E698(19, (const struct sigaction *)v20);\n    sub_804E6F4(1073779726, (int)sub_804E68E);\n    sub_804E6A5(1);\n    sub_80A91C3(1);\n    sub_80A928D();\n    sub_80A91C3(2);\n    sub_80A928D();\n    sub_80A91C3(4);\n    while ( 1 )\n    {\n      v12 = sub_80A928D();\n      sub_80A91C3(24);\n      v13 = sub_80A928D() | v12;\n      sleep(1u);\n      for ( i = (sub_80A928D() | v13) != 0; ; i = 1 )\n      {\n        v15 = waitpid(-1, 0, i);\n        v16 = v15;\n        if ( v15 <= 0 )\n          break;\n        v17 = (const char *)sub_80A8CE7(v15);\n        if ( v17 )\n          sub_80A8D6C(1, \"process '%s' (pid %d) exited. Scheduling for restart.\", v17 + 41, v16);\n      }\n    }\n  }\n  return kill(1, 1);\n}\n"
    ],
    "sub_80A96FD": [
        "0x80a96fd",
        "_BOOL4 sub_80A96FD()\n{\n  FILE *v0; // ebx\n  char v1; // dl\n  char *IO_write_base; // eax\n  int v3; // eax\n  char v5; // [esp+1h] [ebp-5h]\n\n  v0 = stdin;\n  sub_804DD8F();\n  v1 = 0;\n  while ( 1 )\n  {\n    IO_write_base = v0->_IO_write_base;\n    if ( IO_write_base >= v0->_IO_write_end )\n    {\n      v5 = v1;\n      v3 = __fgetc_unlocked();\n      v1 = v5;\n      if ( v3 == -1 )\n        return v1 == 121;\n    }\n    else\n    {\n      v0->_IO_write_base = IO_write_base + 1;\n      v3 = (unsigned __int8)*IO_write_base;\n    }\n    if ( v3 == 10 )\n      break;\n    if ( !v1 && (_BYTE)v3 != 32 && (_BYTE)v3 != 9 )\n      v1 = v3 | 0x20;\n  }\n  return v1 == 121;\n}\n"
    ],
    "sub_80A9707": [
        "0x80a9707",
        "void *__usercall sub_80A9707@<eax>(void *a1@<eax>)\n{\n  int v1; // esi\n  char v2; // bl\n  void *result; // eax\n\n  v1 = (unsigned __int8)byte_80DB772;\n  v2 = byte_80DB772;\n  free(*(&dword_80DB728 + (unsigned __int8)byte_80DB772));\n  result = a1;\n  *(&dword_80DB728 + v1) = a1;\n  byte_80DB772 = (v2 + 1) & 3;\n  return result;\n}\n"
    ],
    "nullsub_9": [
        "0x80a973d",
        "void nullsub_9()\n{\n  ;\n}\n"
    ],
    "sub_80A973E": [
        "0x80a973e",
        "char *__usercall sub_80A973E@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v4; // edi\n  char *v5; // esi\n  ssize_t v6; // eax\n  char *v8; // [esp+0h] [ebp-B4h]\n  int v9[5]; // [esp+4h] [ebp-B0h] BYREF\n  struct sigaction v10; // [esp+18h] [ebp-9Ch] BYREF\n\n  tcflush(a1, 0);\n  fputs_unlocked();\n  sub_804DD8F();\n  tcgetattr(a1, (struct termios *)&v10.sa_mask.__val[19]);\n  qmemcpy(&v10.sa_mask.__val[4], &v10.sa_mask.__val[19], 0x3Cu);\n  v10.sa_mask.__val[7] &= 0xFFFFFF87;\n  tcsetattr(a1, 0, (const struct termios *)&v10.sa_mask.__val[4]);\n  memset(&v9[1], 0, 0x10u);\n  v9[0] = (int)nullsub_9;\n  sigaction(2, (const struct sigaction *)v9, &v10);\n  if ( a2 )\n  {\n    sub_804E698(14, (const struct sigaction *)v9);\n    alarm(a2);\n  }\n  v4 = 0;\n  v5 = 0;\n  while ( 1 )\n  {\n    v5 = (char *)sub_804DB13(v5, v4 + 2);\n    v8 = &v5[v4];\n    v6 = read(a1, &v5[v4], 1u);\n    if ( !v4 )\n    {\n      if ( v6 <= 0 )\n      {\nLABEL_6:\n        *v8 = 0;\n        sub_80B030A();\n        free(v5);\n        v5 = 0;\n        goto LABEL_12;\n      }\n      goto LABEL_8;\n    }\n    if ( v6 < 0 )\n      goto LABEL_6;\n    if ( !v6 )\n      break;\nLABEL_8:\n    if ( *v8 != 10 && *v8 != 13 && ++v4 != 4095 )\n      continue;\n    break;\n  }\n  v5[v4] = 0;\nLABEL_12:\n  if ( a2 )\n    alarm(0);\n  sub_804E698(2, &v10);\n  tcsetattr(a1, 0, (const struct termios *)&v10.sa_mask.__val[19]);\n  sub_804DD98(10);\n  sub_804DD8F();\n  return v5;\n}\n"
    ],
    "sub_80A9888": [
        "0x80a9888",
        "char *sub_80A9888()\n{\n  return sub_80A973E(0, 0);\n}\n"
    ],
    "sub_80A9893": [
        "0x80a9893",
        "unsigned __int32 __fastcall sub_80A9893(int a1, unsigned int a2)\n{\n  return _byteswap_ulong(a2);\n}\n"
    ],
    "sub_80A98A4": [
        "0x80a98a4",
        "int __usercall sub_80A98A4@<eax>(void **a1@<eax>)\n{\n  void **v1; // ebx\n  int v2; // edi\n  int v3; // eax\n  int v4; // esi\n  int v5; // ebp\n\n  v1 = &off_80B8488;\n  if ( *a1 )\n    v1 = a1;\n  v2 = 0;\n  do\n  {\n    v3 = sub_80B3DAA();\n    v4 = v3;\n    if ( v3 < 0 )\n      goto LABEL_5;\n    v5 = (unsigned __int64)sub_804E572(v3, 1) >> 32;\n    if ( v4 )\n      close(v4);\n    if ( v5 < 0 )\nLABEL_5:\n      v2 = 1;\n    ++v1;\n  }\n  while ( *v1 );\n  return v2;\n}\n"
    ],
    "sub_80A98F4": [
        "0x80a98f4",
        "signed int __usercall sub_80A98F4@<eax>(signed int a1@<eax>)\n{\n  time_t v2; // esi\n  signed int result; // eax\n\n  v2 = time(0);\n  do\n  {\n    sleep(a1);\n    result = time(0) - v2;\n  }\n  while ( result < a1 );\n  return result;\n}\n"
    ],
    "sub_80A991A": [
        "0x80a991a",
        "void *__usercall sub_80A991A@<eax>(int *a1@<eax>, void *a2@<edx>)\n{\n  int v3; // esi\n  int v5; // eax\n\n  v3 = 32;\n  if ( a1 )\n  {\n    v3 = *a1;\n    if ( *a1 < 32 )\n      v3 = 32;\n  }\n  while ( 1 )\n  {\n    a2 = sub_804DB13(a2, 4 * v3 + 4);\n    v5 = getgroups(v3, (__gid_t *)a2);\n    if ( v5 >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 22 )\n      sub_804D3C9((int)\"getgroups\");\n    v3 = getgroups(0, (__gid_t *)a2);\n  }\n  *((_DWORD *)a2 + v5) = -1;\n  if ( a1 )\n    *a1 = v5;\n  return a2;\n}\n"
    ],
    "sub_80A998A": [
        "0x80a998a",
        "int __usercall sub_80A998A@<eax>(int a1@<eax>, struct sockaddr *a2@<edx>, socklen_t a3@<ecx>)\n{\n  socklen_t v4; // [esp+0h] [ebp-4h] BYREF\n\n  v4 = a3;\n  return getsockname(a1, a2, &v4);\n}\n"
    ],
    "sub_80A999C": [
        "0x80a999c",
        "struct passwd *__usercall sub_80A999C@<eax>(const char *a1@<eax>)\n{\n  struct passwd *result; // eax\n\n  result = getpwnam(a1);\n  if ( !result )\n    sub_804D5E0(\"unknown user %s\", a1);\n  return result;\n}\n"
    ],
    "sub_80A99B7": [
        "0x80a99b7",
        "struct group *__usercall sub_80A99B7@<eax>(const char *a1@<eax>)\n{\n  struct group *result; // eax\n\n  result = getgrnam(a1);\n  if ( !result )\n    sub_804D5E0(\"unknown group %s\", a1);\n  return result;\n}\n"
    ],
    "sub_80A99D2": [
        "0x80a99d2",
        "struct passwd *__usercall sub_80A99D2@<eax>(__uid_t a1@<eax>)\n{\n  struct passwd *result; // eax\n\n  result = getpwuid(a1);\n  if ( !result )\n    sub_804D5E0(\"unknown uid %u\", a1);\n  return result;\n}\n"
    ],
    "sub_80A99ED": [
        "0x80a99ed",
        "char *__usercall sub_80A99ED@<eax>(__uid_t a1@<eax>)\n{\n  return sub_80A99D2(a1)->pw_name;\n}\n"
    ],
    "sub_80A99F5": [
        "0x80a99f5",
        "char *__usercall sub_80A99F5@<eax>(__uid_t a1@<eax>)\n{\n  struct passwd *v1; // eax\n\n  v1 = getpwuid(a1);\n  if ( v1 )\n    return v1->pw_name;\n  else\n    return 0;\n}\n"
    ],
    "sub_80A9A06": [
        "0x80a9a06",
        "char *__usercall sub_80A9A06@<eax>(__gid_t a1@<eax>)\n{\n  struct group *v1; // eax\n\n  v1 = getgrgid(a1);\n  if ( v1 )\n    return v1->gr_name;\n  else\n    return 0;\n}\n"
    ],
    "sub_80A9A17": [
        "0x80a9a17",
        "char *__usercall sub_80A9A17@<eax>(__uid_t a1@<eax>)\n{\n  char *result; // eax\n\n  result = sub_80A99F5(a1);\n  if ( !result )\n    return sub_804D6F7(a1);\n  return result;\n}\n"
    ],
    "sub_80A9A2D": [
        "0x80a9a2d",
        "char *__usercall sub_80A9A2D@<eax>(__gid_t a1@<eax>)\n{\n  char *result; // eax\n\n  result = sub_80A9A06(a1);\n  if ( !result )\n    return sub_804D6F7(a1);\n  return result;\n}\n"
    ],
    "sub_80A9A43": [
        "0x80a9a43",
        "__uid_t __usercall sub_80A9A43@<eax>(const char *a1@<eax>)\n{\n  return sub_80A999C(a1)->pw_uid;\n}\n"
    ],
    "sub_80A9A4C": [
        "0x80a9a4c",
        "__gid_t __usercall sub_80A9A4C@<eax>(const char *a1@<eax>)\n{\n  return sub_80A99B7(a1)->gr_gid;\n}\n"
    ],
    "sub_80A9A55": [
        "0x80a9a55",
        "int __usercall sub_80A9A55@<eax>(const char *a1@<eax>, int (*a2)(void)@<edx>)\n{\n  int result; // eax\n\n  result = sub_804ED6C(10, a1, 0, (int)a1);\n  if ( *(_DWORD *)dword_80DBB7C )\n    return a2();\n  return result;\n}\n"
    ],
    "sub_80A9A96": [
        "0x80a9a96",
        "void __usercall sub_80A9A96(void *a1@<eax>, size_t a2@<edx>)\n{\n  qsort(a1, a2, 4u, loc_80A9A7D);\n}\n"
    ],
    "sub_80A9AA8": [
        "0x80a9aa8",
        "unsigned int __usercall sub_80A9AA8@<eax>(const char *a1@<eax>, unsigned int a2@<ecx>)\n{\n  unsigned int v3; // ebx\n  unsigned int v5; // [esp+0h] [ebp-Ch] BYREF\n\n  v5 = a2;\n  if ( sscanf(a1, \"cap_%u\", &v5) == 1 )\n  {\n    v3 = v5;\n    if ( v5 > 0x25 )\nLABEL_7:\n      sub_804D5E0(\"unknown capability '%s'\", a1);\n  }\n  else\n  {\n    v3 = 0;\n    while ( !strcasecmp((&off_80B6CC0)[v3], a1) )\n    {\n      if ( ++v3 == 38 )\n        goto LABEL_7;\n    }\n  }\n  return v3;\n}\n"
    ],
    "sub_80A9AF5": [
        "0x80a9af5",
        "int __usercall sub_80A9AF5@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  if ( a2 > 0x25 )\n    return printf(\"%scap_%u\", a1, a2);\n  else\n    return printf(\"%s%s\", a1, (&off_80B6CC0)[a2]);\n}\n"
    ],
    "sub_80A9B19": [
        "0x80a9b19",
        "int __usercall sub_80A9B19@<eax>(int *a1@<eax>)\n{\n  int v2; // esi\n  int v3; // eax\n  int result; // eax\n\n  a1[1] = 0;\n  v2 = 0;\n  while ( 1 )\n  {\n    *a1 = (unsigned __int8)byte_80D8A98[v2];\n    if ( !capget() )\n      break;\n    if ( ++v2 == 3 )\n      goto LABEL_4;\n  }\n  v3 = *a1;\n  if ( *a1 == 537333798 || v3 == 537396514 )\n  {\n    a1[2] = 2;\n  }\n  else\n  {\n    if ( v3 != 429392688 )\n      sub_804D5E0(\"unsupported capability version\");\n    a1[2] = 1;\n  }\n  result = capget();\n  if ( result )\nLABEL_4:\n    sub_804D3FF(\"capget\");\n  return result;\n}\n"
    ],
    "sub_80A9B93": [
        "0x80a9b93",
        "int __usercall sub_80A9B93@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // ebx\n  int result; // eax\n\n  v2 = initgroups(*(const char **)a1, *(_DWORD *)(a1 + 12));\n  endgrent();\n  if ( v2 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 38 || (v3 = *(_DWORD *)(a1 + 8), result = getuid(), v3 != result) )\n      sub_804D3C9((int)\"can't set groups\");\n  }\n  else\n  {\n    sub_804DE5E(*(_DWORD *)(a1 + 12));\n    return sub_804DE74(*(_DWORD *)(a1 + 8));\n  }\n  return result;\n}\n"
    ],
    "sub_80A9BE3": [
        "0x80a9be3",
        "const char *__usercall sub_80A9BE3@<eax>(const char *a1@<eax>)\n{\n  const char *result; // eax\n\n  result = sub_804D378(a1, 10);\n  if ( result )\n    *result = 0;\n  return result;\n}\n"
    ],
    "sub_80A9BF5": [
        "0x80a9bf5",
        "int __usercall sub_80A9BF5@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  if ( a2 && *a2 == 46 && ((LOBYTE(a3) = a2[1], !(_BYTE)a3) || (_BYTE)a3 == 46 && !a2[2]) )\n    return 0;\n  else\n    return sub_804D2D1(a1, a2, a3);\n}\n"
    ],
    "sub_80A9C18": [
        "0x80a9c18",
        "int __usercall sub_80A9C18@<eax>(const char *a1@<eax>, char a2@<dl>)\n{\n  _DWORD *v3; // esi\n  int v4; // edi\n  int result; // eax\n\n  v3 = (_DWORD *)dword_80DBB7C;\n  v4 = *(_DWORD *)dword_80DBB7C;\n  if ( (a2 & 0x10) == 0 || (fprintf(stderr, \"%s: overwrite '%s'? \", ident, a1), (result = sub_80A96FD()) != 0) )\n  {\n    if ( unlink(a1) < 0 )\n    {\n      *v3 = v4;\n      sub_804D3A5((int)\"can't create '%s'\", a1);\n      return -1;\n    }\n    else\n    {\n      return 1;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80A9C77": [
        "0x80a9c77",
        "int __usercall sub_80A9C77@<eax>(const char *a1@<eax>, const char *a2@<edx>, int *a3@<ecx>)\n{\n  int v5; // ebp\n  int (*v6)(); // eax\n  int (*v7)(const char *, const char *); // ebp\n  int v8; // eax\n  int v9; // eax\n  int *v10; // ecx\n  __mode_t v11; // eax\n  __mode_t v12; // esi\n  __mode_t v13; // eax\n  int v14; // eax\n  int v15; // ecx\n  _BYTE *v16; // ebp\n  int v17; // ecx\n  void *v18; // ebp\n  int *v19; // ecx\n  int v20; // esi\n  char v21; // al\n  int v22; // eax\n  const char *v23; // eax\n  const char *v24; // ebp\n  int v25; // ebp\n  char v26; // al\n  int v27; // eax\n  __int64 v28; // rax\n  __mode_t v29; // esi\n  const char *v30; // eax\n  char *v31; // esi\n  int v32; // ebp\n  char v35; // [esp+0h] [ebp-F4h]\n  char v36; // [esp+4h] [ebp-F0h]\n  char v37; // [esp+Bh] [ebp-E9h]\n  DIR *dirp; // [esp+Ch] [ebp-E8h]\n  char *name; // [esp+10h] [ebp-E4h]\n  struct timeval tvp; // [esp+14h] [ebp-E0h] BYREF\n  __time_t v41; // [esp+1Ch] [ebp-D8h]\n  int v42; // [esp+20h] [ebp-D4h]\n  int v43; // [esp+24h] [ebp-D0h]\n  int *v44; // [esp+28h] [ebp-CCh]\n  __mode_t mode; // [esp+34h] [ebp-C0h]\n  __uid_t owner; // [esp+3Ch] [ebp-B8h]\n  __gid_t group; // [esp+40h] [ebp-B4h]\n  __dev_t dev; // [esp+44h] [ebp-B0h]\n  __time_t v49; // [esp+6Ch] [ebp-88h]\n  int v50; // [esp+7Ch] [ebp-78h]\n  int *v51; // [esp+80h] [ebp-74h]\n  int v52; // [esp+84h] [ebp-70h] BYREF\n  int *v53; // [esp+88h] [ebp-6Ch]\n  int v54; // [esp+94h] [ebp-60h]\n  __time_t v55; // [esp+CCh] [ebp-28h]\n  int v56; // [esp+DCh] [ebp-18h]\n  int *v57; // [esp+E0h] [ebp-14h]\n\n  v5 = (unsigned __int16)a3 & 0x102;\n  v6 = stat64;\n  if ( ((unsigned __int16)a3 & 0x102) == 0 )\n    v6 = lstat64;\n  if ( v6() < 0 )\n  {\n    if ( ((unsigned __int8)a3 & 0x60) != 0 )\n    {\nLABEL_5:\n      v7 = link;\n      if ( ((unsigned __int8)a3 & 0x40) != 0 )\n      {\n        v7 = symlink;\n        v8 = symlink(a1, a2);\n      }\n      else\n      {\n        v8 = link(a1, a2);\n      }\n      if ( v8 < 0 )\n      {\n        v21 = sub_80A9C18(a2, (char)a3);\n        if ( v21 > 0 )\n        {\n          v22 = v7(a1, a2);\n          goto LABEL_53;\n        }\n        return v21;\n      }\n      return 0;\n    }\n    goto LABEL_10;\n  }\n  v9 = lstat64();\n  v10 = &v52;\n  if ( v9 >= 0 )\n  {\n    v10 = v53;\n    if ( v44 == v53 && v43 == v52 )\n    {\n      v10 = v57;\n      if ( v51 == v57 && v50 == v56 )\n      {\n        sub_804D5F4(\"'%s' and '%s' are the same file\", a1, a2);\n        return -1;\n      }\n    }\n    v37 = 1;\n  }\n  else\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n    {\nLABEL_10:\n      sub_804D3A5((int)\"can't stat '%s'\");\n      return -1;\n    }\n    v37 = 0;\n  }\n  v11 = mode & 0xF000;\n  if ( v11 == 0x4000 )\n  {\n    if ( ((unsigned __int8)a3 & 4) == 0 )\n    {\n      sub_804D5F4(\"omitting directory '%s'\", a1);\n      return -1;\n    }\n    if ( sub_80AD709(v10, a2) )\n    {\n      sub_804D5F4(\"recursion detected, omitting directory '%s'\", a1);\n      return -1;\n    }\n    if ( v37 )\n    {\n      if ( (v54 & 0xF000) != 0x4000 )\n      {\n        sub_804D5F4(\"target '%s' is not a directory\", a2);\n        return -1;\n      }\n      v12 = 0;\n    }\n    else\n    {\n      v12 = umask(0);\n      v13 = mode;\n      if ( ((unsigned __int8)a3 & 1) == 0 )\n        v13 = ~v12 & mode;\n      if ( mkdir(a2, v13 | 0x1C0) < 0 )\n      {\n        umask(v12);\n        sub_804D3A5((int)\"can't create directory '%s'\", a2);\n        return -1;\n      }\n      umask(v12);\n      if ( lstat64() < 0 )\n        goto LABEL_10;\n    }\n    sub_80AD771();\n    dirp = opendir(a1);\n    v36 = -1;\n    if ( dirp )\n    {\n      v36 = 0;\n      while ( 1 )\n      {\n        v14 = readdir64();\n        if ( !v14 )\n          break;\n        v16 = (_BYTE *)(v14 + 19);\n        name = (char *)sub_80A9BF5((int)a1, (_BYTE *)(v14 + 19), v15);\n        if ( name )\n        {\n          v18 = (void *)sub_804D2D1((int)a2, v16, v17);\n          v19 = a3;\n          BYTE1(v19) = BYTE1(a3) & 0xFE;\n          if ( sub_80A9C77(v19) < 0 )\n            v36 = -1;\n          free(name);\n          free(v18);\n        }\n      }\n      closedir(dirp);\n      if ( !v37 && chmod(a2, mode & ~v12) < 0 )\n        sub_804D3A5((int)\"can't preserve %s of '%s'\", \"permissions\", a2);\n    }\n    goto LABEL_93;\n  }\n  if ( v37 )\n  {\n    v10 = a3;\n    if ( ((unsigned __int16)a3 & 0x2000) != 0 )\n    {\n      v10 = (int *)v55;\n      if ( v49 <= v55 )\n        return 0;\n    }\n  }\n  if ( ((unsigned __int8)a3 & 0x60) != 0 )\n    goto LABEL_5;\n  if ( ((unsigned __int8)a3 & 4) != 0 && v11 != 0x8000 )\n  {\n    if ( !v37 )\n      goto LABEL_78;\n    goto LABEL_76;\n  }\n  if ( v5 )\n    goto LABEL_64;\n  if ( v11 == 40960 )\n  {\n    if ( !v37 )\n      goto LABEL_79;\nLABEL_76:\n    *(_DWORD *)dword_80DBB7C = 17;\n    v21 = sub_80A9C18(a2, (char)a3);\n    if ( v21 <= 0 )\n      return v21;\nLABEL_78:\n    v29 = mode & 0xF000;\n    if ( v29 != 40960 )\n    {\n      if ( v29 != 49152 && (mode & 0xB000) != 0x2000 && v29 != 4096 )\n      {\n        sub_804D5F4(\"unrecognized file '%s' with mode %x\", a1, mode);\n        return -1;\n      }\n      if ( mknod(a2, mode, dev) < 0 )\n      {\n        sub_804D3A5((int)\"can't create '%s'\");\n        return -1;\n      }\n      v36 = 0;\nLABEL_93:\n      if ( ((unsigned __int8)a3 & 1) != 0 )\n      {\n        tvp.tv_sec = v49;\n        v41 = v49;\n        tvp.tv_usec = 0;\n        v42 = 0;\n        if ( utimes(a2, &tvp) < 0 )\n          sub_804D3A5((int)\"can't preserve %s of '%s'\", \"times\", a2);\n        if ( chown(a2, owner, group) < 0 )\n        {\n          mode &= 0xFFFFF3FF;\n          sub_804D3A5((int)\"can't preserve %s of '%s'\", \"ownership\", a2);\n        }\n        if ( chmod(a2, mode) < 0 )\n          sub_804D3A5((int)\"can't preserve %s of '%s'\", \"permissions\", a2);\n      }\nLABEL_100:\n      if ( ((unsigned __int16)a3 & 0x1000) != 0 )\n        printf(\"'%s' -> '%s'\\n\", a1, a2);\n      return v36;\n    }\nLABEL_79:\n    v30 = (const char *)sub_804E261(a1);\n    v31 = (char *)v30;\n    if ( v30 )\n    {\n      v32 = symlink(v30, a2);\n      free(v31);\n      if ( v32 < 0 )\n      {\n        sub_804D3A5((int)\"can't create %slink '%s' to '%s'\", \"sym\", a2, v31);\n        return -1;\n      }\n      if ( ((unsigned __int8)a3 & 1) != 0 && lchown(a2, owner, group) < 0 )\n        sub_804D3A5((int)\"can't preserve %s of '%s'\", \"ownership\", a2);\n    }\n    v36 = 0;\n    goto LABEL_100;\n  }\n  v23 = (const char *)sub_80AD709(v10, a2);\n  v24 = v23;\n  if ( v23 )\n  {\n    if ( link(v23, a2) < 0 )\n    {\n      v21 = sub_80A9C18(a2, (char)a3);\n      if ( v21 > 0 )\n      {\n        v22 = link(v24, a2);\nLABEL_53:\n        if ( v22 < 0 )\n        {\n          sub_804D3A5((int)\"can't create link '%s'\");\n          return -1;\n        }\n        return 0;\n      }\n      return v21;\n    }\n    return 0;\n  }\n  sub_80AD771();\nLABEL_64:\n  v25 = sub_804DC14(a1);\n  v20 = -1;\n  if ( v25 >= 0 )\n  {\n    v20 = open64();\n    if ( v20 == -1 )\n    {\n      v26 = sub_80A9C18(a2, (char)a3);\n      if ( v26 <= 0 )\n      {\n        v35 = v26;\n        close(v25);\n        return v35;\n      }\n      v27 = sub_804DBEB(a2);\n      if ( v27 < 0 )\n      {\n        close(v25);\n        return v20;\n      }\n      v20 = v27;\n    }\n    v28 = sub_804E572(v25, v20);\n    v36 = -((HIDWORD(v28) & (unsigned int)v28) == -1);\n    if ( close(v20) < 0 )\n    {\n      sub_804D3A5((int)\"error writing to '%s'\", a2);\n      v36 = -1;\n    }\n    close(v25);\n    v20 = v36;\n    if ( (mode & 0xF000) == 0x8000 )\n      goto LABEL_93;\n  }\n  return v20;\n}\n"
    ],
    "sub_80AA26C": [
        "0x80aa26c",
        "char *__usercall sub_80AA26C@<eax>(const char **a1@<eax>, char *a2@<edx>)\n{\n  const char *v2; // ecx\n  int v3; // eax\n  struct spwd *v5; // [esp+0h] [ebp-2Ch] BYREF\n  struct spwd v6; // [esp+4h] [ebp-28h] BYREF\n\n  if ( !a1 )\n    return \"aa\";\n  v2 = a1[1];\n  if ( (*v2 == 120 || *v2 == 42) && !v2[1] )\n  {\n    v5 = 0;\n    v3 = getspnam_r(*a1, &v6, a2, 0x100u, &v5);\n    v2 = \"aa\";\n    if ( !v3 )\n    {\n      if ( v5 )\n        return v5->sp_pwdp;\n    }\n  }\n  return (char *)v2;\n}\n"
    ],
    "sub_80AA2CA": [
        "0x80aa2ca",
        "int __usercall sub_80AA2CA@<eax>(const char **a1@<eax>)\n{\n  char *v1; // eax\n  int v2; // ebx\n  const char *v3; // ebx\n  char *v4; // esi\n  char v6[264]; // [esp+0h] [ebp-108h] BYREF\n\n  v1 = sub_80AA26C(a1, v6);\n  v2 = 2;\n  if ( *v1 )\n  {\n    v3 = v1;\n    v4 = (char *)sub_80B1D56(1, v1);\n    v2 = strcmp(v4, v3) == 0;\n    free(v4);\n  }\n  return v2;\n}\n"
    ],
    "sub_80AA319": [
        "0x80aa319",
        "int __usercall sub_80AA319@<eax>(const char **a1@<eax>, unsigned int a2@<edx>)\n{\n  char *v4; // esi\n  int v5; // ebx\n  char v7[268]; // [esp+4h] [ebp-10Ch] BYREF\n\n  if ( !*sub_80AA26C(a1, v7) )\n    return 2;\n  v4 = sub_80A973E(0, a2);\n  v5 = -1;\n  if ( v4 )\n  {\n    v5 = sub_80AA2CA(a1);\n    sub_80B030A();\n  }\n  return v5;\n}\n"
    ],
    "sub_80AA371": [
        "0x80aa371",
        "int __usercall sub_80AA371@<eax>(const char **a1@<eax>)\n{\n  return sub_80AA319(a1, 0);\n}\n"
    ],
    "sub_80AA37D": [
        "0x80aa37d",
        "_DWORD *__usercall sub_80AA37D@<eax>(_DWORD *result@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  unsigned int i; // ebx\n  unsigned int v5; // ecx\n  int v6; // edx\n  int v7; // ebp\n  int v8; // ebp\n\n  v3 = a2 == 0 ? -306674912 : 79764919;\n  if ( !result )\n    result = sub_804DAFA(0x400u);\n  for ( i = 0; i != 256; ++i )\n  {\n    v5 = i;\n    if ( a2 )\n      v5 = i << 24;\n    v6 = 8;\n    do\n    {\n      v7 = v5;\n      if ( a2 )\n      {\n        v5 *= 2;\n        if ( v7 >= 0 )\n          goto LABEL_12;\n      }\n      else\n      {\n        v8 = v5 & 1;\n        v5 >>= 1;\n        if ( !v8 )\n          goto LABEL_12;\n      }\n      v5 ^= v3;\nLABEL_12:\n      --v6;\n    }\n    while ( v6 );\n    result[i] = v5;\n  }\n  return result;\n}\n"
    ],
    "sub_80AA3DF": [
        "0x80aa3df",
        "_DWORD *sub_80AA3DF()\n{\n  return sub_80AA37D(0, 0);\n}\n"
    ],
    "sub_80AA3E8": [
        "0x80aa3e8",
        "_DWORD *sub_80AA3E8()\n{\n  _DWORD *result; // eax\n\n  result = sub_80AA3DF();\n  dword_80DBB98 = (int)result;\n  return result;\n}\n"
    ],
    "sub_80AA3F3": [
        "0x80aa3f3",
        "unsigned int __userpurge sub_80AA3F3@<eax>(unsigned int result@<eax>, unsigned __int8 *a2@<edx>, int a3@<ecx>, int a4)\n{\n  unsigned __int8 *i; // ecx\n\n  for ( i = &a2[a3]; a2 != i; ++a2 )\n    result = *(_DWORD *)(a4 + 4 * (*a2 ^ HIBYTE(result))) ^ (result << 8);\n  return result;\n}\n"
    ],
    "sub_80AA41E": [
        "0x80aa41e",
        "unsigned int __userpurge sub_80AA41E@<eax>(unsigned int result@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, int a4)\n{\n  _BYTE *i; // ecx\n\n  for ( i = &a2[a3]; a2 != i; ++a2 )\n    result = *(_DWORD *)(a4 + 4 * (unsigned __int8)(result ^ *a2)) ^ (result >> 8);\n  return result;\n}\n"
    ],
    "sub_80AA444": [
        "0x80aa444",
        "int __usercall sub_80AA444@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // ebp\n  int v5; // edi\n  int v6; // ebx\n  int v8; // [esp+0h] [ebp-14h]\n\n  v4 = a2 | 0x800;\n  v5 = 5;\n  while ( 1 )\n  {\n    v8 = a1;\n    v6 = open64();\n    a1 = v8;\n    if ( v6 >= 0 )\n      break;\n    if ( !--v5 )\n      return v6;\n  }\n  if ( a2 != v4 )\n    fcntl64();\n  return v6;\n}\n"
    ],
    "sub_80AA493": [
        "0x80aa493",
        "int *__usercall sub_80AA493@<eax>(int a1@<eax>, int *a2@<edx>)\n{\n  _DWORD *i; // ebx\n  _DWORD *v3; // eax\n  _DWORD *v4; // ebp\n  char *v5; // esi\n  const char *v6; // edi\n  unsigned __int8 *v7; // edx\n  int v8; // eax\n  int v9; // eax\n  char *v10; // eax\n  char *v11; // eax\n  char v12; // al\n  char *v13; // eax\n  int v14; // ecx\n  _BYTE *v15; // eax\n  char *j; // ecx\n  char *v17; // eax\n  char *v18; // eax\n  char *v19; // edi\n  char *v20; // esi\n  _DWORD *k; // eax\n  int *result; // eax\n  int **m; // ecx\n  int *v24; // ebx\n  int v25; // edx\n  int *v26; // edi\n  _BYTE *v27; // ecx\n  _BYTE *v28; // esi\n  unsigned __int8 v29; // [esp+0h] [ebp-30h]\n  char *v30; // [esp+0h] [ebp-30h]\n  char *s; // [esp+4h] [ebp-2Ch]\n  char *sa; // [esp+4h] [ebp-2Ch]\n  char *v33; // [esp+8h] [ebp-28h]\n  unsigned __int8 v34; // [esp+8h] [ebp-28h]\n  int v35; // [esp+8h] [ebp-28h]\n  int v36; // [esp+Ch] [ebp-24h]\n  int v38; // [esp+14h] [ebp-1Ch]\n\n  for ( i = (_DWORD *)a2[1]; i; i = (_DWORD *)*i )\n  {\n    s = (char *)i[5];\n    v38 = 0;\n    while ( *s )\n    {\n      v3 = sub_804DB2E(0x18u);\n      v4 = v3;\n      if ( !i[1] )\n        i[1] = v3;\n      v5 = strchr(s, 37);\n      v36 = i[4];\n      if ( !v5 )\n      {\n        v4[4] = s;\n        v4[1] = 1024;\n        break;\n      }\n      if ( v36 )\n      {\n        do\n          ++v5;\n        while ( strchr(\".#-+ 0123456789\", (unsigned __int8)*v5) );\n        goto LABEL_19;\n      }\n      while ( 1 )\n      {\n        v33 = v5 + 1;\n        v29 = v5[1];\n        if ( !strchr(\"#-+ 0123456789\", v29) )\n          break;\n        ++v5;\n      }\n      if ( v29 != 46 )\n      {\n        ++v5;\nLABEL_19:\n        v6 = 0;\n        goto LABEL_20;\n      }\n      v6 = v5 + 2;\n      v5 += 2;\n      if ( (unsigned __int8)(v33[1] - 48) > 9u )\n        goto LABEL_19;\n      do\n        ++v5;\n      while ( (unsigned __int8)(*v5 - 48) <= 9u );\nLABEL_20:\n      v30 = v5 + 1;\n      v34 = *v5;\n      if ( *v5 == 99 )\n      {\n        v4[1] = 8;\nLABEL_22:\n        v7 = (unsigned __int8 *)&unk_80D8D18;\n        goto LABEL_23;\n      }\n      if ( v34 == 108 )\n      {\n        v10 = v5 + 2;\n        ++v5;\n        v30 = v10;\nLABEL_30:\n        v11 = strchr(\"diouxX\", (unsigned __int8)*v5);\n        if ( !v11 )\n          goto LABEL_57;\n        v4[1] = 32;\n        v7 = (unsigned __int8 *)&unk_80D8D16;\n        if ( (unsigned int)v11 > 0x80D8E73 )\n          v4[1] = 512;\nLABEL_23:\n        v8 = i[4];\n        if ( v8 )\n        {\n          while ( v8 != *v7 )\n          {\n            if ( !*++v7 )\n              sub_804D5E0(\"bad byte count for conversion character %s\", v5);\n          }\n        }\n        v9 = *v7;\nLABEL_41:\n        v4[2] = v9;\n        goto LABEL_58;\n      }\n      if ( strchr(\"diouxX\", v34) )\n        goto LABEL_30;\n      if ( strchr(\"eEfgG\", v34) )\n      {\n        v4[1] = 16;\n        v7 = (unsigned __int8 *)&unk_80D8D1A;\n        goto LABEL_23;\n      }\n      if ( v34 == 115 )\n      {\n        v4[1] = 128;\n        v4[2] = v36;\n        if ( !v36 )\n        {\n          if ( !v6 )\n            sub_804D5E0(\"%%s needs precision or byte count\");\n          v9 = atoi(v6);\n          goto LABEL_41;\n        }\n      }\n      else\n      {\n        if ( v34 != 95 )\n          goto LABEL_57;\n        v30 = v5 + 2;\n        v12 = v5[1];\n        if ( v12 == 99 )\n        {\n          v4[1] = 4;\n          goto LABEL_22;\n        }\n        if ( (unsigned __int8)v12 > 0x63u )\n        {\n          if ( v12 == 112 )\n          {\n            v4[1] = 64;\n            *v5 = 99;\n          }\n          else\n          {\n            if ( v12 != 117 )\n              goto LABEL_57;\n            v4[1] = 256;\n          }\n          goto LABEL_22;\n        }\n        if ( v12 == 65 )\n        {\n          *(_DWORD *)(a1 + 24) = i;\n          i[2] |= 1u;\n        }\n        else if ( v12 != 97 )\n        {\n          goto LABEL_57;\n        }\n        v4[1] = 1;\n        v13 = v5 + 3;\n        v30 = v5 + 3;\n        LOBYTE(v13) = v5[2];\n        if ( (unsigned __int8)((_BYTE)v13 - 100) > 0x14u || (v14 = 1050625, !_bittest(&v14, (unsigned int)(v13 - 100))) )\nLABEL_57:\n          sub_804D5E0(\"bad conversion character %%%s\", v5);\n        *v5 = (char)v13;\n      }\nLABEL_58:\n      v35 = v5 - s + 1;\n      v15 = sub_804DB5D(s, v35);\n      v4[4] = v15;\n      for ( j = v30; *j != 37 && *j; ++j )\n        ;\n      if ( j != v30 )\n      {\n        sa = j;\n        v17 = (char *)sub_804DB13(v15, v35 + j - v30 + 1);\n        v4[4] = v17;\n        v18 = &v17[v35];\n        v19 = v18;\n        v20 = v30;\n        do\n          *v19++ = *v20++;\n        while ( sa != v20 );\n        v18[sa - v30] = 0;\n        v30 = sa;\n      }\n      v4[3] = v4[4] + v35 - 1;\n      if ( (v4[1] & 1) == 0 && i[4] )\n      {\n        if ( v38 )\n          sub_804D5E0(\"byte count with multiple conversion characters\");\n        v38 = 1;\n      }\n      s = v30;\n    }\n    if ( !i[4] )\n    {\n      for ( k = (_DWORD *)i[1]; k; k = (_DWORD *)*k )\n        i[4] += k[2];\n    }\n  }\n  result = a2;\n  for ( m = (int **)a2[1]; m; m = (int **)v24 )\n  {\n    v24 = *m;\n    if ( !*m )\n    {\n      v25 = a2[2];\n      result = *(int **)(a1 + 52);\n      if ( v25 < (int)result && ((_BYTE)m[2] & 2) == 0 )\n      {\n        v26 = m[4];\n        if ( v26 )\n        {\n          result = (int *)((char *)m[3] + ((int)result - v25) / (int)v26);\n          m[3] = result;\n        }\n      }\n    }\n    if ( (int)m[3] > 1 )\n    {\n      result = m[1];\n      if ( result )\n      {\n        while ( *result )\n          result = (int *)*result;\n        v27 = (_BYTE *)result[4];\n        v28 = 0;\n        while ( *v27 )\n        {\n          if ( (unsigned __int8)(*v27 - 9) <= 4u || (v28 = 0, *v27 == 32) )\n            v28 = v27;\n          ++v27;\n        }\n        if ( v28 )\n          result[5] = (int)v28;\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AA84C": [
        "0x80aa84c",
        "int __usercall sub_80AA84C@<eax>(int a1@<eax>)\n{\n  int *v2; // eax\n  int v3; // esi\n  __int64 v5; // rax\n  __int16 v6; // [esp+10h] [ebp-60h]\n  __int64 v7; // [esp+2Ch] [ebp-44h]\n\n  do\n  {\n    while ( 1 )\n    {\n      v2 = *(int **)(a1 + 20);\n      v3 = *v2;\n      if ( !*v2 )\n        break;\n      *(_DWORD *)(a1 + 20) = v2 + 1;\n      if ( *(_BYTE *)v3 == 45 && !*(_BYTE *)(v3 + 1) || freopen64() )\n        goto LABEL_4;\n      sub_804D3F1((const char *)v3);\n      *(_BYTE *)(a1 + 56) = 1;\n    }\n    if ( *(_BYTE *)(a1 + 57) )\n      return 0;\nLABEL_4:\n    *(_BYTE *)(a1 + 57) = 1;\n    if ( *(_QWORD *)a1 )\n    {\n      if ( !v3 )\n        v3 = 135100411;\n      sub_804E010((const char *)v3);\n      if ( (v6 & 0xF000) == 0x8000 && *(_QWORD *)a1 >= v7 )\n      {\n        *(_QWORD *)a1 -= v7;\n        *(_QWORD *)(a1 + 44) += v7;\n      }\n      else\n      {\n        if ( fseeko64() )\n          sub_804D3FF((const char *)v3);\n        v5 = *(_QWORD *)(a1 + 44) + *(_QWORD *)a1;\n        *(_QWORD *)(a1 + 44) = v5;\n        *(_QWORD *)(a1 + 28) = v5;\n        *(_DWORD *)a1 = 0;\n        *(_DWORD *)(a1 + 4) = 0;\n      }\n    }\n  }\n  while ( *(_QWORD *)a1 );\n  return 1;\n}\n"
    ],
    "sub_80AA959": [
        "0x80aa959",
        "int __usercall sub_80AA959@<eax>(_DWORD *a1@<eax>)\n{\n  int v2; // esi\n  unsigned __int8 *v3; // ebx\n  int v4; // esi\n  unsigned __int8 *v5; // edi\n  char *v6; // eax\n  int v7; // ecx\n  unsigned int v8; // ecx\n  int v9; // eax\n  int v11; // [esp-4h] [ebp-28h]\n  int v12; // [esp+0h] [ebp-24h]\n  int v13; // [esp+4h] [ebp-20h]\n  int v14; // [esp+8h] [ebp-1Ch]\n  unsigned __int8 v15; // [esp+Fh] [ebp-15h]\n  unsigned __int8 v16; // [esp+Fh] [ebp-15h]\n\n  v13 = 0;\n  while ( a1 )\n  {\n    v12 = a1[4];\n    v14 = a1[3];\n    if ( v12 )\n    {\n      v2 = a1[3] * v12;\n      goto LABEL_25;\n    }\n    v3 = (unsigned __int8 *)a1[5];\n    v4 = 0;\n    while ( *v3 )\n    {\n      if ( *v3 != 37 )\n        goto LABEL_23;\n      while ( 1 )\n      {\n        v15 = v3[1];\n        if ( !strchr(\"#-+ 0123456789\", v15) )\n          break;\n        ++v3;\n      }\n      v5 = v3 + 1;\n      if ( v15 == 46 )\n      {\n        v5 = v3 + 2;\n        if ( (unsigned __int8)(v3[2] - 48) <= 9u )\n        {\n          v12 = atoi((const char *)v3 + 2);\n          do\n            ++v5;\n          while ( (unsigned __int8)(*v5 - 48) <= 9u );\n        }\n      }\n      v16 = *v5;\n      v6 = strchr(\"cdiouxXeEfgG\", *v5);\n      v7 = v11;\n      v3 = v5 + 1;\n      if ( v6 )\n      {\n        v4 += (unsigned __int8)*(v6 - 12);\n        goto LABEL_22;\n      }\n      if ( v16 == 115 )\n      {\n        v4 += v12;\nLABEL_22:\n        v3 = v5;\n        goto LABEL_23;\n      }\n      if ( v16 != 95 )\n        goto LABEL_22;\n      LOBYTE(v7) = v5[1];\n      v8 = v7 - 99;\n      if ( (unsigned __int8)v8 <= 0x12u )\n      {\n        v9 = 270337;\n        if ( _bittest(&v9, v8) )\n          ++v4;\n      }\nLABEL_23:\n      ++v3;\n    }\n    v2 = v14 * v4;\nLABEL_25:\n    v13 += v2;\n    a1 = (_DWORD *)*a1;\n  }\n  return v13;\n}\n"
    ],
    "sub_80AAA6C": [
        "0x80aaa6c",
        "_DWORD *sub_80AAA6C()\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x44u);\n  result[2] = -1;\n  *((_BYTE *)result + 12) = 2;\n  *((_BYTE *)result + 58) = 1;\n  return result;\n}\n"
    ],
    "sub_80AAA86": [
        "0x80aaa86",
        "int __usercall sub_80AAA86@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int *v4; // esi\n  int *v5; // edx\n  int v6; // ecx\n  int v7; // eax\n  signed int v8; // edi\n  int v9; // eax\n  __int64 v10; // rax\n  int v11; // esi\n  char *v12; // edi\n  signed int v13; // edx\n  size_t v14; // eax\n  size_t v15; // eax\n  int v16; // edx\n  char v17; // dl\n  __int64 v18; // rax\n  unsigned __int8 *v19; // edi\n  int **j; // esi\n  int *k; // ecx\n  int v22; // eax\n  char *v23; // eax\n  int *v24; // eax\n  char v25; // cl\n  char *v26; // eax\n  unsigned int v27; // eax\n  int v28; // edx\n  _BYTE *v29; // eax\n  int *v30; // eax\n  int *v31; // eax\n  int *v32; // eax\n  unsigned __int8 v33; // dl\n  int *v34; // eax\n  int *v35; // ecx\n  int v36; // eax\n  int v37; // edx\n  int **n; // esi\n  int *v39; // eax\n  int *v41; // [esp+8h] [ebp-40h]\n  int v42; // [esp+Ch] [ebp-3Ch]\n  int i; // [esp+10h] [ebp-38h]\n  _BYTE *v44; // [esp+14h] [ebp-34h]\n  char v45; // [esp+1Bh] [ebp-2Dh]\n  unsigned __int8 *m; // [esp+1Ch] [ebp-2Ch]\n  unsigned __int8 *v47; // [esp+20h] [ebp-28h]\n  int v48; // [esp+24h] [ebp-24h]\n  int v49; // [esp+28h] [ebp-20h]\n  char v50; // [esp+28h] [ebp-20h]\n  _DWORD *v51; // [esp+28h] [ebp-20h]\n  int **v52; // [esp+30h] [ebp-18h]\n  signed int v53; // [esp+30h] [ebp-18h]\n  char v54; // [esp+30h] [ebp-18h]\n  size_t v55; // [esp+30h] [ebp-18h]\n  char v56[4]; // [esp+34h] [ebp-14h] BYREF\n\n  v4 = *(int **)(a1 + 16);\n  v5 = v4;\n  v6 = 0;\n  while ( v5 )\n  {\n    v49 = v6;\n    v52 = (int **)v5;\n    v7 = sub_80AA959((_DWORD *)v5[1]);\n    v52[2] = (int *)v7;\n    v6 = v49;\n    if ( v49 < v7 )\n      v6 = v7;\n    v5 = *v52;\n  }\n  *(_DWORD *)(a1 + 52) = v6;\n  while ( v4 )\n  {\n    sub_80AA493(a1, v4);\n    v4 = (int *)*v4;\n  }\n  *(_DWORD *)(a1 + 20) = a2;\n  v45 = 0;\nLABEL_10:\n  v8 = *(_DWORD *)(a1 + 52);\n  v9 = *(_DWORD *)(a1 + 60);\n  if ( v9 )\n  {\n    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 64);\n    *(_DWORD *)(a1 + 64) = v9;\n    v10 = *(_QWORD *)(a1 + 28) + v8;\n    *(_QWORD *)(a1 + 28) = v10;\n    *(_QWORD *)(a1 + 44) = v10;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 44) = 0;\n    *(_DWORD *)(a1 + 48) = 0;\n    *(_DWORD *)(a1 + 60) = sub_804DAFA(v8);\n    *(_DWORD *)(a1 + 64) = sub_804DB2E(v8);\n  }\n  v53 = v8;\n  v11 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( !*(_DWORD *)(a1 + 8) || *(_BYTE *)(a1 + 58) && !sub_80AA84C(a1) )\n        {\n          if ( v8 != v53 )\n          {\n            v12 = *(char **)(a1 + 60);\n            if ( !*(_BYTE *)(a1 + 12) || (v50 = *(_BYTE *)(a1 + 12), memcmp(v12, *(const void **)(a1 + 64), v11)) )\n            {\n              memset(&v12[v11], 0, v53);\n              *(_QWORD *)(a1 + 36) = *(_QWORD *)(a1 + 44) + v11;\n              v47 = *(unsigned __int8 **)(a1 + 60);\n              goto LABEL_44;\n            }\n            if ( v50 != 1 )\n              puts(\"*\");\n          }\n          goto LABEL_122;\n        }\n        v13 = *(_DWORD *)(a1 + 8);\n        v14 = v53;\n        if ( v13 != -1 )\n        {\n          v14 = *(_DWORD *)(a1 + 8);\n          if ( v13 > v53 )\n            v14 = v53;\n        }\n        v15 = fread((void *)(v11 + *(_DWORD *)(a1 + 60)), 1u, v14, stdin);\n        if ( v15 )\n          break;\n        if ( (stdin->_flags & 8) != 0 )\n          sub_804D3F1(*(const char **)(*(_DWORD *)(a1 + 20) - 4));\n        *(_BYTE *)(a1 + 58) = 1;\n      }\n      *(_BYTE *)(a1 + 58) = 0;\n      v16 = *(_DWORD *)(a1 + 8);\n      if ( v16 != -1 )\n        *(_DWORD *)(a1 + 8) = v16 - v15;\n      v53 -= v15;\n      if ( !v53 )\n        break;\n      v11 += v15;\n    }\n    v17 = *(_BYTE *)(a1 + 12);\n    v47 = *(unsigned __int8 **)(a1 + 60);\n    if ( !v17 )\n      break;\n    if ( v17 == 2 )\n      break;\n    v54 = *(_BYTE *)(a1 + 12);\n    v11 = memcmp(*(const void **)(a1 + 60), *(const void **)(a1 + 64), v8);\n    v17 = v54;\n    if ( v11 )\n      break;\n    if ( v54 == 3 )\n      puts(\"*\");\n    *(_BYTE *)(a1 + 12) = 1;\n    v18 = *(_QWORD *)(a1 + 28) + v8;\n    *(_QWORD *)(a1 + 28) = v18;\n    *(_QWORD *)(a1 + 44) = v18;\n    v53 = v8;\n  }\n  if ( (unsigned __int8)(v17 - 1) <= 1u )\n    *(_BYTE *)(a1 + 12) = 3;\nLABEL_44:\n  if ( v47 )\n  {\n    v51 = *(_DWORD **)(a1 + 16);\n    v42 = *(_DWORD *)(a1 + 44);\n    for ( i = *(_DWORD *)(a1 + 48); ; *(_DWORD *)(a1 + 48) = i )\n    {\n      if ( !v51 )\n        goto LABEL_10;\n      v55 = v51[1];\n      v19 = v47;\nLABEL_48:\n      if ( v55 && (*(_BYTE *)(v55 + 8) & 1) == 0 )\n        break;\n      v51 = (_DWORD *)*v51;\n      *(_DWORD *)(a1 + 44) = v42;\n    }\n    v48 = *(_DWORD *)(v55 + 12);\nLABEL_51:\n    if ( !v48 )\n    {\n      v55 = *(_DWORD *)v55;\n      goto LABEL_48;\n    }\n    for ( j = *(int ***)(v55 + 4); ; j = (int **)*j )\n    {\n      if ( !j )\n      {\n        --v48;\n        goto LABEL_51;\n      }\n      if ( *(_QWORD *)(a1 + 36) && *(_QWORD *)(a1 + 36) <= *(_QWORD *)(a1 + 44) && ((unsigned int)j[1] & 0x402) == 0 )\n      {\n        j[1] = (int *)2;\n        *(_BYTE *)j[3] = 115;\n        for ( k = j[4]; ; k = (int *)((char *)k + 1) )\n        {\n          v44 = (char *)k + 1;\n          if ( *(_BYTE *)k == 37 )\n            break;\n        }\n        for ( m = (unsigned __int8 *)k + 1; ; ++m )\n        {\n          v22 = *m;\n          if ( !(_BYTE)v22 )\n          {\n            *((_BYTE *)k + 1) = 0;\n            goto LABEL_67;\n          }\n          v41 = k;\n          v23 = strchr(\" -0+#\", v22);\n          k = v41;\n          if ( !v23 )\n            break;\n          v24 = j[5];\n          if ( v24 )\n            j[5] = (int *)((char *)v24 - 1);\n        }\n        do\n        {\n          v25 = v23[(_DWORD)m];\n          (v23++)[(_DWORD)v44] = v25;\n        }\n        while ( v25 );\n      }\nLABEL_67:\n      if ( v48 == 1 )\n      {\n        v26 = (char *)j[5];\n        if ( v26 )\n        {\n          v45 = *v26;\n          *v26 = 0;\n        }\n      }\n      v27 = (unsigned int)j[1];\n      if ( v27 == 32 )\n        break;\n      if ( v27 > 0x20 )\n      {\n        if ( v27 == 256 )\n        {\n          v33 = *v19;\n          v30 = j[3];\n          if ( *v19 > 0x1Fu )\n          {\n            if ( v33 == 127 )\n            {\n              *(_BYTE *)v30 = 115;\n            }\n            else if ( v33 > 0x7Eu )\n            {\n              *(_BYTE *)v30 = 120;\n            }\n            else\n            {\nLABEL_108:\n              *(_BYTE *)v30 = 99;\n            }\n          }\n          else\n          {\n            *(_BYTE *)v30 = 115;\n          }\nLABEL_114:\n          printf((const char *)j[4]);\n          goto LABEL_115;\n        }\n        if ( v27 <= 0x100 )\n        {\n          if ( v27 == 64 || v27 == 128 )\n            goto LABEL_114;\n          goto LABEL_115;\n        }\n        if ( v27 != 512 )\n        {\n          if ( v27 == 1024 )\n            printf((const char *)j[4]);\n          goto LABEL_115;\n        }\n        v32 = j[2];\n        if ( v32 == (int *)2 )\n          goto LABEL_114;\n        goto LABEL_112;\n      }\n      if ( v27 == 4 )\n      {\n        v28 = *v19;\n        v29 = &unk_80D8E51;\n        while ( (_BYTE)v28 != *v29 )\n        {\n          v29 += 4;\n          if ( !*v29 )\n          {\n            if ( (unsigned int)(v28 - 32) <= 0x5E )\n            {\n              v30 = j[3];\n              goto LABEL_108;\n            }\n            sprintf(v56, \"%03o\", *v19);\n            break;\n          }\n        }\n        *(_BYTE *)j[3] = 115;\n        goto LABEL_114;\n      }\n      if ( v27 > 4 )\n      {\n        if ( v27 == 8 )\n          goto LABEL_114;\n        if ( v27 == 16 )\n        {\n          v31 = j[2];\n          if ( v31 == (int *)4 )\n          {\n            printf((const char *)j[4], *(float *)v19);\n          }\n          else if ( v31 == (int *)8 )\n          {\n            printf((const char *)j[4], *(_DWORD *)v19, *((_DWORD *)v19 + 1));\n          }\n        }\n      }\n      else if ( v27 == 1 || v27 == 2 )\n      {\n        goto LABEL_114;\n      }\nLABEL_115:\n      if ( v48 == 1 )\n      {\n        v34 = j[5];\n        if ( v34 )\n          *(_BYTE *)v34 = v45;\n      }\n      v35 = j[2];\n      *(_QWORD *)(a1 + 44) += (int)v35;\n      v19 = &v19[(_DWORD)v35];\n    }\n    v32 = j[2];\n    if ( v32 == (int *)2 )\n      goto LABEL_114;\nLABEL_112:\n    if ( v32 == (int *)4 || v32 == (int *)1 )\n      goto LABEL_114;\n    goto LABEL_115;\n  }\nLABEL_122:\n  v36 = *(_DWORD *)(a1 + 24);\n  if ( v36 )\n  {\n    if ( !*(_QWORD *)(a1 + 36) )\n    {\n      v37 = *(_DWORD *)(a1 + 48);\n      if ( !*(_QWORD *)(a1 + 44) )\n        return *(char *)(a1 + 56);\n      *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 44);\n      *(_DWORD *)(a1 + 40) = v37;\n    }\n    for ( n = *(int ***)(v36 + 4); n; n = (int **)*n )\n    {\n      v39 = n[1];\n      if ( v39 == (int *)1 )\n      {\n        printf((const char *)n[4], *(_DWORD *)(a1 + 36));\n      }\n      else if ( v39 == (int *)1024 )\n      {\n        printf((const char *)n[4]);\n      }\n    }\n  }\n  return *(char *)(a1 + 56);\n}\n"
    ],
    "sub_80AAFEF": [
        "0x80aafef",
        "_DWORD *__usercall sub_80AAFEF@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  char *v4; // eax\n  _DWORD *v5; // ecx\n  _DWORD *v6; // edx\n  int v7; // ebx\n  int v8; // edx\n  int v9; // ecx\n  _DWORD *v10; // esi\n  char *v11; // edi\n  char v12; // dl\n  int v14; // edx\n  int v15; // edi\n  char v16; // al\n  unsigned __int8 v17; // al\n  int v18; // ecx\n  char *v19; // edx\n  char v20; // cl\n  int v22; // [esp-4h] [ebp-18h]\n  int v23; // [esp-4h] [ebp-18h]\n  _DWORD *v24; // [esp+0h] [ebp-14h]\n\n  v4 = (char *)sub_804DB2E(0xCu);\n  v6 = *(_DWORD **)(a1 + 16);\n  if ( v6 )\n  {\n    while ( 1 )\n    {\n      v5 = (_DWORD *)*v6;\n      if ( !*v6 )\n        break;\n      v6 = (_DWORD *)*v6;\n    }\n    *v6 = v4;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 16) = v4;\n  }\n  v24 = v4 + 4;\n  while ( 1 )\n  {\n    v7 = sub_80B2E8C(v5, v6);\n    if ( !*(_BYTE *)v7 )\n      return v24;\n    v10 = sub_804DB2E(0x18u);\n    *v24 = v10;\n    v24 = v10;\n    v10[3] = 1;\n    if ( (unsigned __int8)(*(_BYTE *)v7 - 48) <= 9u )\n    {\n      v11 = (char *)v7;\n      do\n        v12 = *v11;\n      while ( (unsigned __int8)(*v11++ - 48) <= 9u );\n      if ( (unsigned __int8)(v12 - 9) > 4u && v12 != 32 && v12 != 47 )\n        goto LABEL_13;\n      v10[3] = atoi((const char *)v7);\n      v10[2] = 2;\n      v7 = sub_80B2E8C(v22, v14);\n    }\n    if ( *(_BYTE *)v7 == 47 )\n      v7 = sub_80B2E8C(v9, v8);\n    v15 = v7;\n    if ( (unsigned __int8)(*(_BYTE *)v7 - 48) <= 9u )\n    {\n      while ( 1 )\n      {\n        v16 = *(_BYTE *)(v15 + 1);\n        if ( (unsigned __int8)(v16 - 48) > 9u )\n          break;\n        ++v15;\n      }\n      v17 = v16 - 9;\n      if ( v17 != 23 && v17 > 4u )\nLABEL_13:\n        sub_804D5E0(\"bad format {%s}\", a2);\n      v10[4] = atoi((const char *)v7);\n      v7 = sub_80B2E8C(v18, v23);\n    }\n    if ( *(_BYTE *)v7 != 34 )\n      goto LABEL_13;\n    v19 = (char *)(v7 + 1);\n    while ( 1 )\n    {\n      v20 = *v19;\n      if ( *v19 == 34 )\n        break;\n      ++v19;\n      if ( !v20 )\n        goto LABEL_13;\n    }\n    v10[5] = sub_804DB5D((_BYTE *)(v7 + 1), (int)&v19[-v7 - 1]);\n    sub_80B0D53();\n  }\n}\n"
    ],
    "sub_80AB128": [
        "0x80ab128",
        "char *__usercall sub_80AB128@<eax>(char *result@<eax>)\n{\n  char v1; // dl\n\n  v1 = *result;\n  if ( *result == 95 )\n  {\nLABEL_3:\n    while ( 1 )\n    {\n      v1 = *++result;\n      if ( !*result )\n        break;\n      if ( v1 != 95 && (unsigned __int8)(v1 - 48) > 9u )\n        goto LABEL_2;\n    }\n  }\n  else\n  {\nLABEL_2:\n    if ( (unsigned __int8)((v1 | 0x20) - 97) <= 0x19u )\n      goto LABEL_3;\n  }\n  return result;\n}\n"
    ],
    "sub_80AB151": [
        "0x80ab151",
        "_BOOL4 __usercall sub_80AB151@<eax>(const char *a1@<eax>)\n{\n  __int16 v2; // [esp+10h] [ebp-54h]\n\n  return !access(a1, 1) && !stat64() && (v2 & 0xF000) == 0x8000;\n}\n"
    ],
    "sub_80AB18F": [
        "0x80ab18f",
        "char *__usercall sub_80AB18F@<eax>(_BYTE *a1@<eax>, char **a2@<edx>)\n{\n  char *i; // ebx\n  char *v5; // eax\n  char *v6; // esi\n  _BOOL4 v7; // eax\n  int v9; // [esp-4h] [ebp-14h]\n\n  for ( i = *a2; i; i = v6 )\n  {\n    v5 = strchr(i, 58);\n    v6 = v5;\n    if ( v5 )\n      *v5 = 0;\n    if ( !*i )\n      i = \"<<...\" + 4;\n    i = (char *)sub_804D2D1((int)i, a1, v9);\n    v7 = sub_80AB151(i);\n    if ( v6 )\n      *v6++ = 58;\n    if ( v7 )\n    {\n      *a2 = v6;\n      return i;\n    }\n    free(i);\n  }\n  return i;\n}\n"
    ],
    "sub_80AB1EC": [
        "0x80ab1ec",
        "void __usercall __noreturn sub_80AB1EC(const char **a1@<eax>)\n{\n  execvp(*a1, (char *const *)a1);\n  byte_80DB560 = (*(_DWORD *)dword_80DBB7C == 2) + 126;\n  sub_804D3C9((int)\"can't execute '%s'\", *a1);\n}\n"
    ],
    "sub_80AB218": [
        "0x80ab218",
        "int __usercall sub_80AB218@<eax>(FILE *a1@<eax>)\n{\n  int v1; // edx\n  int v2; // ebx\n\n  v1 = a1->_flags & 8;\n  v2 = (unsigned __int16)v1;\n  if ( (_WORD)v1 )\n    *(_DWORD *)dword_80DBB7C = 5;\n  if ( stdin != a1 )\n    return fclose(a1) | (unsigned __int16)v1;\n  return v2;\n}\n"
    ],
    "sub_80AB247": [
        "0x80ab247",
        "void __usercall __noreturn sub_80AB247(char a1@<al>)\n{\n  byte_80DB560 = a1;\n  if ( fflush(stdout) )\n    sub_804D3C9((int)\"standard output\");\n  sub_804D604();\n}\n"
    ],
    "sub_80AB345": [
        "0x80ab345",
        "void __noreturn sub_80AB345()\n{\n  int v0; // [esp+0h] [ebp-4h] BYREF\n\n  v0 = 2147479552;\n  ((void (__cdecl __noreturn *)(int *))loc_80AB26B)(&v0);\n}\n"
    ],
    "sub_80AB359": [
        "0x80ab359",
        "void __fastcall __noreturn sub_80AB359(int *a1)\n{\n  int v1; // [esp+0h] [ebp-4h] BYREF\n\n  if ( !a1 )\n  {\n    v1 = 2147479552;\n    a1 = &v1;\n  }\n  ((void (__cdecl __noreturn *)(int *, int))loc_80AB26B)(a1, v1);\n}\n"
    ],
    "sub_80AB375": [
        "0x80ab375",
        "struct mntent *__usercall sub_80AB375@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  struct mntent *v2; // ebx\n  int v3; // esi\n  int v4; // edi\n  struct mntent *v5; // eax\n  const char *mnt_fsname; // ebp\n  FILE *stream; // [esp+0h] [ebp-80h]\n  char v10; // [esp+Bh] [ebp-75h]\n  int v12; // [esp+10h] [ebp-70h]\n  int v13; // [esp+14h] [ebp-6Ch]\n  __int16 v14; // [esp+20h] [ebp-60h]\n  int v15; // [esp+30h] [ebp-50h]\n  int v16; // [esp+34h] [ebp-4Ch]\n\n  if ( stat64() )\n    return 0;\n  v3 = v12;\n  v4 = v13;\n  v10 = 0;\n  if ( (v14 & 0xB000) == 0x2000 )\n  {\n    v3 = v15;\n    v4 = v16;\n    v10 = 1;\n  }\n  stream = setmntent(\"/proc/mounts\", \"r\");\n  if ( !stream )\n    return 0;\n  while ( 1 )\n  {\n    v5 = getmntent(stream);\n    v2 = v5;\n    if ( !v5 )\n      break;\n    mnt_fsname = v5->mnt_fsname;\n    if ( strcmp(v5->mnt_fsname, \"rootfs\") )\n    {\n      if ( !strcmp(a1, v2->mnt_dir)\n        || !strcmp(a1, mnt_fsname)\n        || (a2 || v10) && (!stat64() && v16 == v4 && v15 == v3 || !stat64() && v13 == v4 && v12 == v3) )\n      {\n        break;\n      }\n    }\n  }\n  endmntent(stream);\n  return v2;\n}\n"
    ],
    "sub_80AB493": [
        "0x80ab493",
        "_DWORD *__usercall sub_80AB493@<eax>(const char *a1@<eax>)\n{\n  signed int v2; // ecx\n  _DWORD *v3; // esi\n  int v4; // edi\n  int v5; // ebx\n  const char *v6; // eax\n  signed int v7; // eax\n  char *v8; // eax\n  int v9; // eax\n  char *v10; // eax\n  int v11; // eax\n  const char *v12; // eax\n  char *v13; // eax\n  int v14; // eax\n  signed int v16; // [esp-8h] [ebp-1Ch]\n  signed int v17; // [esp-8h] [ebp-1Ch]\n  signed int v18; // [esp-8h] [ebp-1Ch]\n  const char *v19; // [esp+0h] [ebp-14h]\n\n  v3 = sub_804DB2E(4u);\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = sub_80B0EC0(v2, 65825);\n    if ( !v5 )\n      break;\n    if ( strncmp((const char *)(v5 + 72), a1, 0xFu)\n      || *(_BYTE *)(v5 + 86)\n      && (!*(_DWORD *)(v5 + 8)\n       || (v19 = *(const char **)(v5 + 8), v7 = strlen(v19) + 1, v2 = *(unsigned __int16 *)(v5 + 6), v7 >= v2)\n       || (v8 = sub_804D315(&v19[v7]), v9 = strcmp(v8, a1), v2 = v16, v9)) )\n    {\n      v6 = *(const char **)(v5 + 8);\n      if ( !v6 || (v10 = sub_804D315(v6), v11 = strcmp(v10, a1), v2 = v17, v11) )\n      {\n        v12 = *(const char **)(v5 + 12);\n        if ( !v12 )\n          continue;\n        v13 = sub_804D315(v12);\n        v14 = strcmp(v13, a1);\n        v2 = v18;\n        if ( v14 )\n          continue;\n      }\n    }\n    v3 = (_DWORD *)sub_80B4733(v4, 1026);\n    v3[v4++] = *(_DWORD *)(v5 + 36);\n  }\n  v3[v4] = 0;\n  return v3;\n}\n"
    ],
    "sub_80AB572": [
        "0x80ab572",
        "int __usercall sub_80AB572@<eax>(int result@<eax>)\n{\n  int i; // edx\n  int v2; // edx\n  int j; // ecx\n  int v4; // ebx\n\n  for ( i = 0; *(_DWORD *)(result + 4 * i); ++i )\n    ;\n  v2 = i - 1;\n  if ( v2 != -1 )\n  {\n    for ( j = 0; v2 > j; ++j )\n    {\n      v4 = *(_DWORD *)(result + 4 * v2);\n      *(_DWORD *)(result + 4 * v2) = *(_DWORD *)(result + 4 * j);\n      *(_DWORD *)(result + 4 * j) = v4;\n      --v2;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AB5A2": [
        "0x80ab5a2",
        "char *__usercall sub_80AB5A2@<eax>(int a1@<eax>)\n{\n  const char *v2; // edi\n  size_t v3; // esi\n  char *v4; // esi\n  DIR *v5; // ebp\n  int v6; // eax\n  size_t v8; // [esp+0h] [ebp-18h]\n\n  v2 = (const char *)(a1 + 104);\n  v3 = strlen((const char *)(a1 + 104));\n  v8 = 254 - v3;\n  if ( (int)(254 - v3) <= 0 )\n    return 0;\n  v5 = opendir(v2);\n  if ( !v5 )\n    return 0;\n  *(_BYTE *)(a1 + v3 + 104) = 47;\n  while ( 1 )\n  {\n    v4 = (char *)readdir64();\n    if ( !v4 )\n      break;\n    sub_80B2C4E(v8, v4 + 19);\n    if ( !lstat64() )\n    {\n      v6 = *(_DWORD *)(a1 + 16) & 0xF000;\n      if ( v6 == 24576 )\n      {\n        if ( *(_DWORD *)(a1 + 36) == *(_DWORD *)(a1 + 100) && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a1 + 96) )\n        {\n          v4 = sub_804DB46(v2);\n          break;\n        }\n      }\n      else if ( v6 == 0x4000 && (v4[19] != 46 || v4[20] && *((_WORD *)v4 + 10) != 46) )\n      {\n        v4 = (char *)sub_80AB5A2(a1, v2);\n        if ( v4 )\n          break;\n      }\n    }\n  }\n  closedir(v5);\n  return v4;\n}\n"
    ],
    "sub_80AB672": [
        "0x80ab672",
        "char *sub_80AB672()\n{\n  int v0; // eax\n  int v1; // edx\n  int v3[4]; // [esp+0h] [ebp-168h] BYREF\n  int v4; // [esp+10h] [ebp-158h]\n  int v5; // [esp+20h] [ebp-148h]\n  int v6; // [esp+24h] [ebp-144h]\n  int v7; // [esp+60h] [ebp-108h]\n  int v8; // [esp+64h] [ebp-104h]\n  char dest[256]; // [esp+68h] [ebp-100h] BYREF\n\n  if ( stat64() )\n    return 0;\n  if ( (v4 & 0xF000) == 24576 )\n  {\n    v0 = v5;\n    v1 = v6;\n  }\n  else\n  {\n    v0 = v3[0];\n    v1 = v3[1];\n  }\n  v7 = v0;\n  v8 = v1;\n  strcpy(dest, \"/dev\");\n  return sub_80AB5A2((int)v3);\n}\n"
    ],
    "sub_80AB6D3": [
        "0x80ab6d3",
        "int __usercall sub_80AB6D3@<eax>(int a1@<ebp>)\n{\n  int v1; // esi\n  int v2; // ebx\n  int v3; // edi\n  char v5[17]; // [esp+1h] [ebp-11h] BYREF\n\n  v5[0] = HIBYTE(a1);\n  v1 = 2;\n  while ( 1 )\n  {\n    v2 = open64();\n    v3 = v2;\n    if ( v2 < 0 )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 13 || (v2 = open64(), v3 = v2, v2 < 0) )\n      {\n        if ( *(_DWORD *)dword_80DBB7C != 13 )\n        {\n          v3 = v2;\n          goto LABEL_9;\n        }\n        v3 = open64();\n        v2 = v3;\n        if ( v3 < 0 )\n          goto LABEL_9;\n      }\n    }\n    while ( 2 )\n    {\n      v5[0] = 0;\n      if ( !ioctl(v2, 0x4B33u, v5) )\n        return v2;\n      if ( v3 >= 0 )\n      {\n        close(v3);\n        v3 = -1;\nLABEL_9:\n        v2 = v1;\n        continue;\n      }\n      break;\n    }\n    if ( --v1 == -1 )\n      sub_804D5E0(\"can't open console\");\n  }\n}\n"
    ],
    "sub_80AB77C": [
        "0x80ab77c",
        "int __usercall sub_80AB77C@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  sub_804E0BE(a1, 0x5606u, a2, \"VT_ACTIVATE\");\n  return sub_804E0BE(a1, 0x5607u, a2, \"VT_WAITACTIVE\");\n}\n"
    ],
    "sub_80AB7A9": [
        "0x80ab7a9",
        "void *__usercall sub_80AB7A9@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  void *v3; // ebx\n  int i; // esi\n  unsigned __int8 *v5; // eax\n  unsigned __int8 *v6; // edx\n  int v7; // ebp\n  int v8; // edi\n  int v11; // [esp+4h] [ebp-14h]\n  int v12; // [esp+4h] [ebp-14h]\n\n  v3 = 0;\n  for ( i = 0; ; ++i )\n  {\n    v5 = *(unsigned __int8 **)(a1 + 16);\n    if ( (unsigned int)v5 < *(_DWORD *)(a1 + 24) )\n    {\n      v6 = v5 + 1;\n      *(_DWORD *)(a1 + 16) = v5 + 1;\n      v7 = *v5;\n      goto LABEL_4;\n    }\n    v12 = a1;\n    v7 = __fgetc_unlocked();\n    a1 = v12;\n    if ( v7 == -1 )\n      break;\nLABEL_4:\n    if ( !(_BYTE)i )\n    {\n      if ( i == -256 )\n        sub_804DAC9(a1, v6);\n      v11 = a1;\n      v3 = sub_804DB13(v3, i + 256);\n      a1 = v11;\n    }\n    v8 = i + 1;\n    *((_BYTE *)v3 + i) = v7;\n    if ( !v7 )\n      goto LABEL_14;\n    if ( v7 == 10 && a2 )\n      goto LABEL_15;\n  }\n  v8 = i;\nLABEL_14:\n  if ( !a2 )\n    goto LABEL_16;\nLABEL_15:\n  *a2 = v8;\nLABEL_16:\n  if ( v3 )\n  {\n    v3 = sub_804DB13(v3, v8 + 1);\n    *((_BYTE *)v3 + v8) = 0;\n  }\n  return v3;\n}\n"
    ],
    "sub_80AB850": [
        "0x80ab850",
        "void *__usercall sub_80AB850@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // [esp-4h] [ebp-4h] BYREF\n\n  v3 = a2;\n  return sub_80AB7A9(a1, &v3);\n}\n"
    ],
    "sub_80AB85A": [
        "0x80ab85a",
        "char *__usercall sub_80AB85A@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  char *result; // eax\n  int v3; // edx\n  char *v4; // edx\n  int v5; // [esp+0h] [ebp-4h] BYREF\n\n  v5 = a2;\n  result = (char *)sub_80AB7A9(a1, &v5);\n  v3 = v5;\n  if ( v5 )\n  {\n    --v5;\n    v4 = &result[v3 - 1];\n    if ( *v4 == 10 )\n      *v4 = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80AB879": [
        "0x80ab879",
        "char *sub_80AB879()\n{\n  char *result; // eax\n  __uid_t v1; // eax\n  struct passwd *v2; // edx\n\n  result = getenv(\"SHELL\");\n  if ( !result || !*result )\n  {\n    v1 = getuid();\n    v2 = getpwuid(v1);\n    result = (_BYTE *)(\"-/bin/sh\" + 1);\n    if ( v2 )\n    {\n      result = v2->pw_shell;\n      if ( !result || !*result )\n        return (_BYTE *)(\"-/bin/sh\" + 1);\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AB8B7": [
        "0x80ab8b7",
        "unsigned int __fastcall sub_80AB8B7(unsigned int a1, int a2, int a3)\n{\n  unsigned __int64 v4; // kr00_8\n  int v5; // ecx\n  int v6; // edi\n  unsigned int v7; // esi\n  int v8; // edi\n  int v9; // eax\n  int v10; // edx\n  int v11; // edx\n\n  if ( a2 )\n  {\n    v4 = sub_80B3F6D(-1, 0x7FFFFFFF);\n    if ( sub_80B4B88(-1, 0x7FFFFFFF, a1, 0) <= v4 )\n      sub_804D5E0(\"image size is too big\");\n    v5 = a1 * HIDWORD(v4);\n    v6 = ((unsigned int)v4 * (unsigned __int64)a1) >> 32;\n    v7 = v4 * a1;\n    v8 = v5 + v6;\n    v9 = lseek64();\n    if ( a3 && (v10 & v9) != -1 )\n      sub_804DCAD(1, (int)&data);\n  }\n  else\n  {\n    v7 = sub_804DD09(0, 0, 2);\n    v8 = v11;\n  }\n  sub_804DD09(0, 0, 0);\n  if ( !v8 && v7 <= 0x3FFF )\n    sub_804D5E0(\"image is too small\");\n  return v7;\n}\n"
    ],
    "sub_80AB993": [
        "0x80ab993",
        "int __usercall sub_80AB993@<eax>(int a1@<eax>, const char *a2@<edx>, char *a3@<ecx>, int *a4)\n{\n  const char *v4; // esi\n  size_t v5; // eax\n  const char *v6; // ebx\n  void *v7; // esp\n  char *v8; // eax\n  char *v9; // esi\n  char *v10; // edi\n  int v11; // edx\n  char *v12; // esi\n  void *v13; // esp\n  struct option **p_longopts; // esi\n  struct option **i; // edi\n  char *v16; // eax\n  size_t v17; // eax\n  char *v18; // eax\n  char *v19; // edx\n  struct option *v20; // eax\n  int v21; // edx\n  unsigned __int8 v22; // al\n  int v23; // esi\n  unsigned __int8 *v24; // eax\n  unsigned int v25; // esi\n  char *v26; // esi\n  char *j; // eax\n  char v28; // cl\n  unsigned __int8 v29; // dl\n  unsigned __int8 v30; // dl\n  int v31; // edx\n  char *v32; // edx\n  char *k; // esi\n  char v34; // cl\n  char *m; // edi\n  int v36; // ebx\n  int v37; // eax\n  char *n; // ecx\n  int v39; // esi\n  _DWORD *v40; // eax\n  char v41; // al\n  _DWORD *v42; // esi\n  char *ii; // eax\n  int v44; // edx\n  int v45; // ebx\n  char v48; // [esp+Bh] [ebp-3C1h]\n  struct option *longopts; // [esp+Ch] [ebp-3C0h] BYREF\n  char *shortopts; // [esp+10h] [ebp-3BCh]\n  int v51; // [esp+14h] [ebp-3B8h]\n  int v52; // [esp+18h] [ebp-3B4h]\n  char *s; // [esp+1Ch] [ebp-3B0h]\n  int v54; // [esp+20h] [ebp-3ACh]\n  char v55[936]; // [esp+24h] [ebp-3A8h] BYREF\n\n  v4 = a2;\n  s = a3;\n  memset(v55, 0, 0x39Cu);\n  v5 = strlen(a2);\n  v6 = 0;\n  if ( *v4 == 94 )\n    v6 = &(++v4)[v5];\n  v48 = *v4;\n  if ( *v4 == 33 )\n    ++v4;\n  v7 = alloca(v5 + 16);\n  shortopts = strcpy((char *)&longopts, v4);\n  v8 = &shortopts[((*shortopts - 43) & 0xFD) == 0];\n  v9 = v55;\n  v54 = 0;\n  while ( *v8 && v54 != 32 )\n  {\n    *v9 = *v8;\n    *((_DWORD *)v9 + 1) = 1 << v54;\n    v10 = v8 + 1;\n    if ( v8[1] == 58 )\n    {\n      v52 = (int)(a4 + 1);\n      v11 = *a4;\n      *((_DWORD *)v9 + 5) = *a4;\n      LOBYTE(v11) = v8[2];\n      if ( (unsigned __int8)(v11 - 42) <= 1u )\n      {\n        v9[1] = ((_BYTE)v11 == 43) + 1;\n        sub_80B2C69(v11 - 42);\n      }\n      do\n        ++v10;\n      while ( *v10 == 58 );\n      a4 = (int *)v52;\n    }\n    v9 += 28;\n    ++v54;\n    v8 = v10;\n  }\n  if ( s )\n  {\n    v12 = s;\n    v52 = 1;\n    while ( *v12 )\n    {\n      v12 += strlen(v12) + 3;\n      ++v52;\n    }\n    v13 = alloca(16 * v52 + 16);\n    p_longopts = &longopts;\n    longopts = (struct option *)&longopts;\n    memset(&longopts, 0, 16 * v52);\n    for ( i = &longopts; --v52; i += 4 )\n    {\n      v16 = s;\n      *i = (struct option *)s;\n      v17 = strlen(v16);\n      v18 = &s[v17 + 1];\n      i[1] = (struct option *)(unsigned __int8)*v18;\n      s = v18 + 2;\n      i[3] = (struct option *)(unsigned __int8)v18[1];\n    }\n    while ( *p_longopts )\n    {\n      v19 = v55;\n      if ( !p_longopts[2] )\n      {\n        while ( 1 )\n        {\n          v20 = (struct option *)(unsigned __int8)*v19;\n          if ( !(_BYTE)v20 )\n            break;\n          if ( v20 == p_longopts[3] )\n            goto LABEL_31;\n          v19 += 28;\n        }\n        if ( v54 > 31 )\n          break;\n        *v19 = (unsigned __int8)p_longopts[3];\n        *((_DWORD *)v19 + 1) = 1 << v54;\n        if ( p_longopts[1] )\n          *((_DWORD *)v19 + 5) = *a4++;\n        ++v54;\n      }\nLABEL_31:\n      p_longopts += 4;\n    }\n  }\n  else\n  {\n    longopts = (struct option *)&unk_80B8478;\n  }\n  v52 = -1;\n  s = 0;\n  v51 = 0;\n  v54 = 0;\n  if ( v6 )\n  {\n    while ( 1 )\n    {\n      v21 = *(unsigned __int8 *)v6;\n      if ( !(_BYTE)v21 )\n        goto LABEL_82;\n      v22 = v6[1];\n      if ( (_BYTE)v21 != 58 )\n        break;\nLABEL_81:\n      ++v6;\n    }\n    v23 = v22;\n    switch ( (_BYTE)v21 )\n    {\n      case '?':\n        v24 = (unsigned __int8 *)(v6 + 1);\n        v25 = v23 - 48;\n        if ( v25 > 9 )\n          goto LABEL_81;\n        v52 = v25;\nLABEL_41:\n        v6 = (const char *)v24;\n        goto LABEL_81;\n      case '-':\n        v24 = (unsigned __int8 *)(v6 + 1);\n        v26 = (char *)(v23 - 48);\n        if ( (unsigned int)v26 > 9 )\n          goto LABEL_81;\n        s = v26;\n        goto LABEL_41;\n      case '=':\n        s = (char *)(v22 - 48);\n        ++v6;\n        v52 = (int)s;\n        goto LABEL_81;\n    }\n    for ( j = v55; ; j += 28 )\n    {\n      v28 = *j;\n      if ( !*j )\n        sub_804D5E0(\"NO OPT %c!\", v21);\n      if ( v28 == (_BYTE)v21 )\n        break;\n    }\n    switch ( v23 )\n    {\n      case 58:\n        if ( v6[2] == 58 )\n        {\n          j[1] = 1;\n          goto LABEL_81;\n        }\nLABEL_57:\n        v51 |= *((_DWORD *)j + 1);\n        goto LABEL_81;\n      case 43:\n        v29 = v6[2];\n        if ( v29 == 58 || !v29 )\n        {\n          j[1] = 2;\nLABEL_62:\n          ++v6;\n          goto LABEL_81;\n        }\n        break;\n      case 0:\n        goto LABEL_57;\n      case 45:\n        v30 = v6[2];\n        if ( v30 == 58 || !v30 )\n        {\n          v31 = *((_DWORD *)j + 1);\n          v54 |= v31;\n          *((_DWORD *)j + 3) |= v31;\n          goto LABEL_62;\n        }\n        goto LABEL_65;\n    }\n    if ( v28 == v6[1] )\n    {\n      *((_DWORD *)j + 6) = *a4++;\n      ++v6;\n    }\nLABEL_65:\n    v32 = j + 4;\n    for ( k = (char *)(v6 + 1); ; ++k )\n    {\n      v34 = *k;\n      if ( *k == 58 || !v34 )\n        break;\n      if ( v34 == 63 )\n      {\n        v32 = j + 16;\n      }\n      else if ( v34 == 45 )\n      {\n        if ( j + 8 == v32 )\n          v32 = j + 12;\n        else\n          v32 = j + 8;\n      }\n      else\n      {\n        for ( m = v55; *m; m += 28 )\n        {\n          if ( *m == v34 )\n          {\n            *(_DWORD *)v32 |= *((_DWORD *)m + 1);\n            break;\n          }\n        }\n      }\n    }\n    v6 = k - 1;\n    goto LABEL_81;\n  }\nLABEL_82:\n  optind = 0;\n  v36 = sub_804CD3D((_DWORD *)(a1 + 4)) + 1;\n  while ( 1 )\n  {\n    v37 = getopt_long(v36, (char *const *)a1, shortopts, longopts, 0);\n    if ( v37 == -1 )\n      break;\n    for ( n = v55; ; n += 28 )\n    {\n      v39 = (unsigned __int8)*n;\n      if ( v39 == (unsigned __int8)v37 )\n        break;\n      if ( !(_BYTE)v39 )\n        goto LABEL_110;\n    }\n    if ( (v54 & *((_DWORD *)n + 3)) != 0 )\n      goto LABEL_110;\n    v54 = (v54 & (*((_DWORD *)n + 1) | ~*((_DWORD *)n + 2)) | *((_DWORD *)n + 1) & ~*((_DWORD *)n + 2)) ^ *((_DWORD *)n + 2) & *((_DWORD *)n + 1);\n    v40 = (_DWORD *)*((_DWORD *)n + 6);\n    if ( v40 )\n      ++*v40;\n    if ( optarg )\n    {\n      v41 = n[1];\n      v42 = (_DWORD *)*((_DWORD *)n + 5);\n      if ( v41 == 1 )\n      {\n        sub_80AFADF(n, optarg);\n      }\n      else if ( v41 == 2 )\n      {\n        *v42 = sub_80B4187(n, optarg);\n      }\n      else if ( v42 )\n      {\n        *v42 = optarg;\n      }\n    }\n  }\n  for ( ii = v55; *ii; ii += 28 )\n  {\n    v44 = *((_DWORD *)ii + 4);\n    if ( v44 && (v54 & *((_DWORD *)ii + 1)) != 0 && (v44 & v54) == 0 )\n      goto LABEL_110;\n  }\n  if ( !v51 || (v51 & v54) != 0 )\n  {\n    v45 = v36 - optind;\n    if ( (int)s <= v45 && (v52 >= v45 || v52 < 0) )\n    {\n      dword_80DBB9C = v54;\n      return v54;\n    }\n  }\nLABEL_110:\n  if ( v48 != 33 )\n    sub_804CDC2();\n  return -1;\n}\n"
    ],
    "sub_80ABEAC": [
        "0x80abeac",
        "int sub_80ABEAC(int a1, const char *a2, ...)\n{\n  va_list va; // [esp+Ch] [ebp+Ch] BYREF\n\n  va_start(va, a2);\n  return sub_80AB993(a1, a2, 0, (int *)va);\n}\n"
    ],
    "sub_80ABEC2": [
        "0x80abec2",
        "int sub_80ABEC2(int a1, const char *a2, char *a3, ...)\n{\n  va_list va; // [esp+10h] [ebp+10h] BYREF\n\n  va_start(va, a3);\n  return sub_80AB993(a1, a2, a3, (int *)va);\n}\n"
    ],
    "sub_80ABEDA": [
        "0x80abeda",
        "const char *__usercall sub_80ABEDA@<eax>(const char **a1@<eax>)\n{\n  const char *result; // eax\n  size_t v3; // eax\n  _BYTE *v4; // esi\n\n  while ( 1 )\n  {\n    result = *++a1;\n    if ( !*a1 )\n      break;\n    if ( *result != 45 )\n    {\n      v3 = strlen(*a1);\n      v4 = sub_804DAFA(v3 + 2);\n      *v4 = 45;\n      strcpy(v4 + 1, *a1);\n      *a1 = v4;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80ABF14": [
        "0x80abf14",
        "_DWORD *__usercall sub_80ABF14@<eax>(_DWORD *result@<eax>)\n{\n  int v1; // edx\n  int v2; // ecx\n  int i; // edi\n  int v4; // esi\n  int v5; // ebx\n  int j; // edi\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int k; // ebx\n  int v11; // esi\n  int v12; // esi\n  int m; // edi\n  int v14; // ebx\n  int v15; // ebx\n  int v16; // ebx\n  int v17; // [esp+0h] [ebp-28h]\n  int v18; // [esp+4h] [ebp-24h]\n  int v19; // [esp+Ch] [ebp-1Ch]\n  int v20; // [esp+10h] [ebp-18h]\n  int v21; // [esp+14h] [ebp-14h]\n\n  v19 = result[20];\n  v20 = result[21];\n  v21 = result[22];\n  v1 = v21;\n  v18 = v20;\n  v2 = v19;\n  v17 = result[19];\n  for ( i = 0; i != 16; i += 4 )\n  {\n    v4 = __ROL4__(result[i] + dword_80B6DA0[i] + (v1 ^ v2 & (v1 ^ v18)) + v17, 7);\n    v17 = v2 + v4;\n    v1 = v2 + v4 + __ROL4__((v18 ^ (v2 + v4) & (v2 ^ v18)) + result[i + 1] + dword_80B6DA4[i] + v1, 12);\n    v5 = __ROR4__(v18 + result[i + 2] + dword_80B6DA8[i] + (v2 ^ v1 & (v2 ^ (v2 + v4))), 15);\n    v18 = v5 + v1;\n    v2 = v5 + v1 + __ROR4__((v17 ^ (v5 + v1) & (v1 ^ v17)) + result[i + 3] + dword_80B6DAC[i] + v2, 10);\n  }\n  for ( j = 0; j != 16; j += 4 )\n  {\n    v7 = __ROL4__(v17 + result[(unsigned __int8)byte_80D8F0D[j]] + dword_80B6DE0[j] + (v18 ^ v1 & (v2 ^ v18)), 5);\n    v17 = v7 + v2;\n    v8 = __ROL4__(result[(unsigned __int8)byte_80D8F0E[j]] + dword_80B6DE4[j] + v1 + (v2 ^ v18 & (v2 ^ (v7 + v2))), 9);\n    v1 = v8 + v17;\n    v9 = __ROL4__(\n           result[(unsigned __int8)byte_80D8F0F[j]] + dword_80B6DE8[j] + v18 + (v17 ^ v2 & ((v8 + v17) ^ v17)),\n           14);\n    v18 = v9 + v1;\n    v2 = __ROR4__(result[(unsigned __int8)byte_80D8F10[j]] + dword_80B6DEC[j] + v2 + (v1 ^ v17 & (v1 ^ (v9 + v1))), 12)\n       + v9\n       + v1;\n  }\n  for ( k = 0; k != 16; k += 4 )\n  {\n    v11 = __ROL4__(v17 + result[(unsigned __int8)byte_80D8F1D[k]] + dword_80B6E20[k] + (v1 ^ v2 ^ v18), 4);\n    v17 = v2 + v11;\n    v1 = v2\n       + v11\n       + __ROL4__(((v2 + v11) ^ v2 ^ v18) + result[(unsigned __int8)byte_80D8F1E[k]] + dword_80B6E24[k] + v1, 11);\n    v12 = __ROL4__(result[(unsigned __int8)byte_80D8F1F[k]] + dword_80B6E28[k] + v18 + (v1 ^ v2 ^ (v2 + v11)), 16);\n    v18 = v1 + v12;\n    v2 = v1\n       + v12\n       + __ROR4__(result[(unsigned __int8)byte_80D8F20[k]] + dword_80B6E2C[k] + v2 + ((v1 + v12) ^ v1 ^ v17), 9);\n  }\n  for ( m = 0; m != 16; m += 4 )\n  {\n    v14 = __ROL4__(v17 + result[(unsigned __int8)byte_80D8F2D[m]] + dword_80B6E60[m] + (v18 ^ (v2 | ~v1)), 6);\n    v17 = v14 + v2;\n    v15 = __ROL4__(result[(unsigned __int8)byte_80D8F2E[m]] + dword_80B6E64[m] + v1 + (v2 ^ ((v14 + v2) | ~v18)), 10);\n    v1 = v15 + v17;\n    v16 = __ROL4__(result[(unsigned __int8)byte_80D8F2F[m]] + dword_80B6E68[m] + v18 + (v17 ^ ((v15 + v17) | ~v2)), 15);\n    v18 = v1 + v16;\n    v2 = __ROR4__(result[(unsigned __int8)byte_80D8F30[m]] + dword_80B6E6C[m] + v2 + (v1 ^ ((v1 + v16) | ~v17)), 11)\n       + v1\n       + v16;\n  }\n  result[19] += v17;\n  result[20] = v19 + v2;\n  result[21] = v18 + v20;\n  result[22] = v21 + v1;\n  return result;\n}\n"
    ],
    "sub_80AC1FF": [
        "0x80ac1ff",
        "int __usercall sub_80AC1FF@<eax>(int result@<eax>)\n{\n  int j; // edx\n  int v2; // ecx\n  int v3; // ebx\n  _DWORD *v4; // edx\n  int v5; // edi\n  int v6; // ecx\n  unsigned __int64 v7; // rt0\n  int v8; // edi\n  int v9; // esi\n  int k; // edx\n  unsigned __int64 *v11; // ebx\n  int v12; // ecx\n  int v13; // edi\n  int v14; // esi\n  int v15; // ecx\n  int v16; // esi\n  int v17; // edi\n  unsigned int m; // edx\n  int v19; // ecx\n  int v20; // esi\n  int v21; // edi\n  unsigned __int64 v22; // [esp+4h] [ebp-7Ch]\n  int v23; // [esp+Ch] [ebp-74h]\n  int v24; // [esp+Ch] [ebp-74h]\n  int v25; // [esp+10h] [ebp-70h]\n  int v26; // [esp+14h] [ebp-6Ch]\n  unsigned __int64 v27; // [esp+14h] [ebp-6Ch]\n  int i; // [esp+1Ch] [ebp-64h]\n  int v29[24]; // [esp+20h] [ebp-60h]\n\n  for ( i = 0; i != 24; ++i )\n  {\n    for ( j = 0; j != 5; ++j )\n    {\n      v2 = *(_DWORD *)(result + 8 * j + 160) ^ *(_DWORD *)(result + 8 * j + 120) ^ *(_DWORD *)(result + 8 * j + 80) ^ *(_DWORD *)(result + 8 * j + 40) ^ *(_DWORD *)(result + 8 * j);\n      v3 = *(_DWORD *)(result + 8 * j + 164) ^ *(_DWORD *)(result + 8 * j + 124) ^ *(_DWORD *)(result + 8 * j + 84) ^ *(_DWORD *)(result + 8 * j + 44) ^ *(_DWORD *)(result + 8 * j + 4);\n      v29[2 * j] = v2;\n      v29[2 * j + 1] = v3;\n      v29[2 * j + 10] = v2;\n      v29[2 * j + 11] = v3;\n    }\n    v4 = (_DWORD *)result;\n    v26 = 0;\n    do\n    {\n      v5 = v29[2 * v26 + 8];\n      v23 = v29[2 * v26++ + 9];\n      HIDWORD(v7) = v29[2 * v26];\n      LODWORD(v7) = v29[2 * v26 + 1];\n      v6 = v7 >> 31;\n      HIDWORD(v7) = v7;\n      LODWORD(v7) = v29[2 * v26];\n      v8 = v6 ^ v5;\n      v9 = (v7 >> 31) ^ v23;\n      *v4 ^= v8;\n      v4[1] ^= v9;\n      v4[10] ^= v8;\n      v4[11] ^= v9;\n      v4[20] ^= v8;\n      v4[21] ^= v9;\n      v4[30] ^= v8;\n      v4[31] ^= v9;\n      v4[40] ^= v8;\n      v4[41] ^= v9;\n      v4 += 2;\n    }\n    while ( v26 != 5 );\n    v27 = *(_QWORD *)(result + 8);\n    for ( k = 0; k != 24; ++k )\n    {\n      v11 = (unsigned __int64 *)(result + 8 * (unsigned __int8)byte_80B84A8[k]);\n      v22 = *v11;\n      v12 = (unsigned __int8)byte_80B8490[k];\n      v13 = v27 << v12 >> 32;\n      v14 = (_DWORD)v27 << v12;\n      if ( (v12 & 0x20) != 0 )\n      {\n        v13 = (_DWORD)v27 << v12;\n        v14 = 0;\n      }\n      v24 = v14;\n      v25 = v13;\n      v15 = -v12 & 0x3F;\n      v16 = v27 >> v15;\n      v17 = HIDWORD(v27) >> v15;\n      if ( (v15 & 0x20) != 0 )\n      {\n        v16 = HIDWORD(v27) >> v15;\n        v17 = 0;\n      }\n      *(_DWORD *)v11 = v16 | v24;\n      *((_DWORD *)v11 + 1) = v17 | v25;\n      v27 = v22;\n    }\n    for ( m = 0; m <= 0x28; m += 9 )\n    {\n      while ( 1 )\n      {\n        v19 = *(_DWORD *)(result + 4 * m);\n        v20 = *(_DWORD *)(result + 4 * m + 8);\n        *(_DWORD *)(result + 4 * m) = v19 ^ *(_DWORD *)(result + 4 * m + 16) & ~v20;\n        *(_DWORD *)(result + 4 * m + 8) = v20 ^ *(_DWORD *)(result + 4 * m + 24) & ~*(_DWORD *)(result + 4 * m + 16);\n        v21 = *(_DWORD *)(result + 4 * m + 32);\n        *(_DWORD *)(result + 4 * m + 16) ^= v21 & ~*(_DWORD *)(result + 4 * m + 24);\n        *(_DWORD *)(result + 4 * m + 24) ^= v19 & ~v21;\n        *(_DWORD *)(result + 4 * m + 32) = v21 ^ v20 & ~v19;\n        if ( (((_BYTE)m + 1) & 1) == 0 )\n          break;\n        ++m;\n      }\n    }\n    *(_DWORD *)result ^= (unsigned __int16)word_80B6D60[i] | (372775680 << i) & 0x80000000;\n    *(_DWORD *)(result + 4) ^= (856153344 << i) & 0x80000000;\n  }\n  return result;\n}\n"
    ],
    "sub_80AC3F5": [
        "0x80ac3f5",
        "int __usercall sub_80AC3F5@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // eax\n  int v5; // edi\n  unsigned int v6; // esi\n  __int64 v7; // rax\n  int result; // eax\n\n  v4 = *(_DWORD *)(a1 + 68) & 0x3F;\n  v5 = v4 + 1;\n  *(_BYTE *)(a1 + v4) = 0x80;\n  do\n  {\n    v6 = 64 - v5;\n    memset((void *)(a1 + v5), 0, 64 - v5);\n    if ( (unsigned int)(64 - v5) > 7 )\n    {\n      v7 = 8LL * *(_QWORD *)(a1 + 68);\n      if ( a2 )\n        LODWORD(v7) = sub_80A9893(0, HIDWORD(v7));\n      *(_QWORD *)(a1 + 56) = v7;\n    }\n    result = (*(int (**)(void))(a1 + 64))();\n    v5 = 0;\n  }\n  while ( v6 <= 7 );\n  return result;\n}\n"
    ],
    "sub_80AC44E": [
        "0x80ac44e",
        "unsigned __int64 __usercall sub_80AC44E@<edx:eax>(_QWORD *a1@<eax>, int a2@<ecx>)\n{\n  _QWORD *v3; // esi\n  int i; // ebx\n  int v5; // edx\n  int *v6; // esi\n  unsigned int v7; // edx\n  unsigned __int64 v8; // rt0\n  int v9; // esi\n  __int64 v10; // rax\n  unsigned __int64 v11; // rax\n  unsigned __int64 result; // rax\n  __int64 v13; // [esp+8h] [ebp-308h]\n  __int64 v14; // [esp+20h] [ebp-2F0h]\n  __int64 v15; // [esp+28h] [ebp-2E8h]\n  unsigned __int64 v16; // [esp+30h] [ebp-2E0h]\n  unsigned __int64 v17; // [esp+38h] [ebp-2D8h]\n  unsigned __int64 v18; // [esp+40h] [ebp-2D0h]\n  int v19; // [esp+48h] [ebp-2C8h]\n  unsigned __int64 v20; // [esp+48h] [ebp-2C8h]\n  unsigned __int64 v21; // [esp+50h] [ebp-2C0h]\n  unsigned __int64 v22; // [esp+58h] [ebp-2B8h]\n  unsigned __int64 v23; // [esp+60h] [ebp-2B0h]\n  unsigned __int64 v24; // [esp+68h] [ebp-2A8h]\n  unsigned __int64 v25; // [esp+70h] [ebp-2A0h]\n  unsigned __int64 v26; // [esp+78h] [ebp-298h]\n  int v27[128]; // [esp+80h] [ebp-290h] BYREF\n  char v28; // [esp+280h] [ebp-90h] BYREF\n\n  v25 = a1[2];\n  v24 = a1[3];\n  v23 = a1[4];\n  v18 = a1[5];\n  v26 = a1[6];\n  v22 = a1[7];\n  v21 = a1[8];\n  v17 = a1[9];\n  v3 = a1 + 10;\n  for ( i = 0; i != 16; ++i )\n  {\n    v27[2 * i] = sub_80A9893(a2, HIDWORD(v3[i]));\n    v27[2 * i + 1] = v5;\n  }\n  v6 = v27;\n  do\n  {\n    v7 = v6[29];\n    v19 = v6[28];\n    LODWORD(v15) = (__PAIR64__(v7, v19) >> 6) ^ (__PAIR64__(v19, v7) >> 29) ^ (__PAIR64__(v7, v19) >> 19);\n    HIDWORD(v15) = (v7 >> 6) ^ (__PAIR64__(v7, v19) >> 29) ^ (__PAIR64__(v19, v7) >> 19);\n    LODWORD(v8) = v6[3];\n    HIDWORD(v8) = v6[2];\n    LODWORD(v14) = (*((_QWORD *)v6 + 1) >> 7) ^ (*((_QWORD *)v6 + 1) >> 8) ^ (*((_QWORD *)v6 + 1) >> 1);\n    HIDWORD(v14) = ((unsigned int)v8 >> 7) ^ (v8 >> 8) ^ (v8 >> 1);\n    *((_QWORD *)v6 + 16) = v14 + v15 + *((_QWORD *)v6 + 9) + *(_QWORD *)v6;\n    v6 += 2;\n  }\n  while ( &v28 != (char *)v6 );\n  v9 = 0;\n  while ( 1 )\n  {\n    LODWORD(v10) = v27[v9];\n    HIDWORD(v10) = v27[v9 + 1];\n    v20 = v17\n        + (v22 & v26 ^ v21 & ~v26)\n        + __PAIR64__(\n            (v26 >> 9) ^ (__PAIR64__(v26, HIDWORD(v26)) >> 18) ^ (__PAIR64__(v26, HIDWORD(v26)) >> 14),\n            (__PAIR64__(v26, HIDWORD(v26)) >> 9) ^ (v26 >> 18) ^ (v26 >> 14))\n        + __PAIR64__(dword_80B6F24[v9], dword_80B6F20[v9])\n        + v10;\n    LODWORD(v13) = (__PAIR64__(v25, HIDWORD(v25)) >> 7) ^ (v25 >> 28) ^ (__PAIR64__(v25, HIDWORD(v25)) >> 2);\n    HIDWORD(v13) = (v25 >> 7) ^ (__PAIR64__(v25, HIDWORD(v25)) >> 28) ^ (v25 >> 2);\n    v16 = v20 + v18;\n    v11 = v20 + (v23 & v24 ^ v25 & (v23 ^ v24)) + v13;\n    v9 += 2;\n    v18 = v23;\n    v17 = v21;\n    if ( v9 == 160 )\n      break;\n    v21 = v22;\n    v22 = v26;\n    v26 = v16;\n    v23 = v24;\n    v24 = v25;\n    v25 = v11;\n  }\n  a1[2] += v11;\n  a1[3] += v25;\n  a1[4] += v24;\n  a1[5] += v23;\n  a1[6] += v16;\n  a1[7] += v26;\n  result = v22;\n  a1[8] += v22;\n  a1[9] += v21;\n  return result;\n}\n"
    ],
    "sub_80AC9D5": [
        "0x80ac9d5",
        "_DWORD *__usercall sub_80AC9D5@<eax>(_DWORD *result@<eax>)\n{\n  int i; // edx\n  unsigned __int32 v2; // ecx\n  int v3; // ebx\n  int v4; // edx\n  int v5; // esi\n  int j; // edi\n  int v7; // ecx\n  int v8; // ebp\n  int v9; // ecx\n  int v10; // [esp+0h] [ebp-C0h]\n  int v11; // [esp+4h] [ebp-BCh]\n  int v12; // [esp+8h] [ebp-B8h]\n  int v13; // [esp+Ch] [ebp-B4h]\n  int v14; // [esp+10h] [ebp-B0h]\n  int v15; // [esp+14h] [ebp-ACh]\n  int v16; // [esp+18h] [ebp-A8h]\n  int v17; // [esp+1Ch] [ebp-A4h]\n  int v18; // [esp+20h] [ebp-A0h]\n  int v19; // [esp+24h] [ebp-9Ch]\n  int v20; // [esp+28h] [ebp-98h]\n  int v21; // [esp+2Ch] [ebp-94h]\n  int v22[36]; // [esp+30h] [ebp-90h]\n\n  for ( i = 0; i != 16; ++i )\n  {\n    v2 = _byteswap_ulong(result[i]);\n    v22[i + 16] = v2;\n    v22[i] = v2;\n  }\n  v16 = result[19];\n  v17 = result[20];\n  v18 = result[21];\n  v19 = result[22];\n  v20 = result[23];\n  v3 = v20;\n  v13 = v19;\n  v4 = v18;\n  v12 = v17;\n  v11 = v16;\n  v5 = 0;\n  for ( j = 0; j != 4; ++j )\n  {\n    v21 = dword_80B84C0[j];\n    v15 = v3;\n    v3 = v13;\n    v13 = v4;\n    v10 = v12;\n    v12 = v11;\n    v14 = 19;\n    while ( 1 )\n    {\n      v7 = v3 ^ v4;\n      v8 = v22[v5];\n      if ( j )\n      {\n        v9 = v10 ^ v7;\n        if ( j == 2 )\n          v9 = v10 & v4 | v3 & (v4 | v10);\nLABEL_10:\n        v8 = __ROL4__(v22[v5 + 2] ^ v22[v5 + 8] ^ v22[v5 + 13] ^ v8, 1);\n        v22[v5 + 16] = v8;\n        v22[v5] = v8;\n        goto LABEL_11;\n      }\n      v9 = v3 ^ v10 & v7;\n      if ( v14 <= 3 )\n        goto LABEL_10;\nLABEL_11:\n      v11 = v15 + v8 + v9 + v21 + __ROL4__(v11, 5);\n      v4 = __ROR4__(v10, 2);\n      v5 = ((_BYTE)v5 + 1) & 0xF;\n      --v14;\n      v10 = v12;\n      v15 = v3;\n      if ( v14 == -1 )\n        break;\n      v3 = v13;\n      v13 = v4;\n      v12 = v11;\n    }\n  }\n  result[19] = v11 + v16;\n  result[20] = v17 + v12;\n  result[21] = v18 + v4;\n  result[22] = v19 + v13;\n  result[23] = v20 + v3;\n  return result;\n}\n"
    ],
    "sub_80ACB39": [
        "0x80acb39",
        "_DWORD *__usercall sub_80ACB39@<eax>(_DWORD *result@<eax>)\n{\n  int i; // edx\n  int *v2; // edx\n  int v3; // ecx\n  int v4; // ebx\n  int v5; // ebp\n  int v6; // edx\n  int v7; // esi\n  int v8; // edi\n  int v9; // [esp+0h] [ebp-148h]\n  int v10; // [esp+4h] [ebp-144h]\n  int v11; // [esp+8h] [ebp-140h]\n  int v12; // [esp+Ch] [ebp-13Ch]\n  int v13; // [esp+14h] [ebp-134h]\n  int v14; // [esp+18h] [ebp-130h]\n  int v15; // [esp+1Ch] [ebp-12Ch]\n  int v16; // [esp+20h] [ebp-128h]\n  int v17; // [esp+24h] [ebp-124h]\n  int v18; // [esp+28h] [ebp-120h]\n  int v19; // [esp+2Ch] [ebp-11Ch]\n  int v20; // [esp+30h] [ebp-118h]\n  int v21; // [esp+34h] [ebp-114h]\n  int v22[48]; // [esp+38h] [ebp-110h] BYREF\n  char v23; // [esp+F8h] [ebp-50h] BYREF\n\n  for ( i = 0; i != 16; ++i )\n    v22[i] = _byteswap_ulong(result[i]);\n  v2 = v22;\n  do\n  {\n    v2[16] = (((unsigned int)v2[1] >> 3) ^ __ROL4__(v2[1], 14) ^ __ROR4__(v2[1], 7))\n           + v2[9]\n           + *v2\n           + (((unsigned int)v2[14] >> 10) ^ __ROL4__(v2[14], 13) ^ __ROL4__(v2[14], 15));\n    ++v2;\n  }\n  while ( &v23 != (char *)v2 );\n  v13 = result[20];\n  v14 = result[21];\n  v15 = result[22];\n  v16 = result[23];\n  v17 = result[24];\n  v18 = result[25];\n  v19 = result[26];\n  v21 = v19;\n  v12 = v18;\n  v11 = v17;\n  v3 = v16;\n  v20 = v15;\n  v10 = v14;\n  v9 = v13;\n  v4 = result[19];\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = v21\n       + v22[v5]\n       + dword_80B6F24[2 * v5]\n       + (__ROL4__(v3, 7) ^ __ROR4__(v3, 6) ^ __ROR4__(v3, 11))\n       + (v3 & v11 ^ v12 & ~v3);\n    v7 = v6 + v20;\n    v8 = v6 + (__ROL4__(v4, 10) ^ __ROR4__(v4, 13) ^ __ROR4__(v4, 2)) + (v10 & v9 ^ v4 & (v10 ^ v9));\n    ++v5;\n    v20 = v10;\n    v21 = v12;\n    if ( v5 == 64 )\n      break;\n    v12 = v11;\n    v11 = v3;\n    v3 = v7;\n    v10 = v9;\n    v9 = v4;\n    v4 = v8;\n  }\n  result[19] += v8;\n  result[20] = v13 + v4;\n  result[21] = v9 + v14;\n  result[22] = v10 + v15;\n  result[23] = v16 + v7;\n  result[24] = v17 + v3;\n  result[25] = v11 + v18;\n  result[26] = v12 + v19;\n  return result;\n}\n"
    ],
    "sub_80ACCF3": [
        "0x80accf3",
        "_DWORD *__usercall sub_80ACCF3@<eax>(_DWORD *result@<eax>)\n{\n  result[19] = 1732584193;\n  result[20] = -271733879;\n  result[21] = -1732584194;\n  result[22] = 271733878;\n  result[17] = 0;\n  result[18] = 0;\n  result[16] = sub_80ABF14;\n  return result;\n}\n"
    ],
    "sub_80ACD25": [
        "0x80acd25",
        "unsigned int __usercall sub_80ACD25@<eax>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)\n{\n  int v5; // edx\n  unsigned int v6; // ebp\n  unsigned int v8; // [esp+0h] [ebp-14h]\n\n  v8 = a3;\n  v5 = *(_DWORD *)(a1 + 68) & 0x3F;\n  *(_QWORD *)(a1 + 68) += a3;\n  while ( 1 )\n  {\n    v6 = 64 - v5;\n    if ( 64 - v5 > v8 )\n      v6 = v8;\n    qmemcpy((void *)(a1 + v5), a2, v6);\n    a2 += v6;\n    v8 -= v6;\n    if ( v5 + v6 != 64 )\n      break;\n    (*(void (**)(void))(a1 + 64))();\n    v5 = 0;\n  }\n  return v8;\n}\n"
    ],
    "sub_80ACD79": [
        "0x80acd79",
        "int __usercall sub_80ACD79@<eax>(int a1@<eax>, void *a2@<edx>)\n{\n  sub_80AC3F5(a1, 0);\n  qmemcpy(a2, (const void *)(a1 + 76), 0x10u);\n  return 16;\n}\n"
    ],
    "sub_80ACD9C": [
        "0x80acd9c",
        "_DWORD *__usercall sub_80ACD9C@<eax>(_DWORD *result@<eax>)\n{\n  result[19] = 1732584193;\n  result[20] = -271733879;\n  result[21] = -1732584194;\n  result[22] = 271733878;\n  result[23] = -1009589776;\n  result[17] = 0;\n  result[18] = 0;\n  result[16] = sub_80AC9D5;\n  return result;\n}\n"
    ],
    "sub_80ACDD5": [
        "0x80acdd5",
        "int __usercall sub_80ACDD5@<eax>(int result@<eax>)\n{\n  qmemcpy((void *)(result + 68), &dword_80B6EE0, 0x28u);\n  *(_DWORD *)(result + 64) = sub_80ACB39;\n  return result;\n}\n"
    ],
    "sub_80ACDF2": [
        "0x80acdf2",
        "int __usercall sub_80ACDF2@<eax>(int result@<eax>)\n{\n  unsigned int i; // edx\n  __int64 v2; // rcx\n\n  for ( i = 0; i != 40; i += 4 )\n  {\n    HIDWORD(v2) = dword_80B6EE0[i / 4];\n    LODWORD(v2) = 0;\n    *(_QWORD *)(result + 2 * i) = (unsigned int)dword_80B6EA0[i / 4] + v2;\n  }\n  return result;\n}\n"
    ],
    "sub_80ACE29": [
        "0x80ace29",
        "int __usercall sub_80ACE29@<eax>(unsigned __int64 *a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned __int64 v5; // rax\n  unsigned int v6; // eax\n  int result; // eax\n  int v8; // [esp+0h] [ebp-18h]\n  unsigned int v9; // [esp+4h] [ebp-14h]\n\n  v9 = a3;\n  v8 = *(_DWORD *)a1 & 0x7F;\n  v5 = *a1 + a3;\n  *a1 = v5;\n  if ( a3 > v5 )\n    ++a1[1];\n  while ( 1 )\n  {\n    v6 = v9;\n    if ( v9 > 128 - v8 )\n      v6 = 128 - v8;\n    qmemcpy((char *)a1 + v8 + 80, a2, v6);\n    a2 += v6;\n    v9 -= v6;\n    result = v8 + v6 - 128;\n    if ( result )\n      break;\n    sub_80AC44E(a1, 0);\n    v8 = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80ACEAA": [
        "0x80aceaa",
        "unsigned int __usercall sub_80ACEAA@<eax>(int a1@<eax>, void *a2@<edx>)\n{\n  int v4; // eax\n  int v5; // edx\n  unsigned int result; // eax\n\n  sub_80AC3F5(a1, 1);\n  v4 = 3 * (*(_DWORD *)(a1 + 64) != (_DWORD)sub_80AC9D5) + 5;\n  v5 = 0;\n  do\n  {\n    *(_DWORD *)(a1 + 4 * v5 + 76) = _byteswap_ulong(*(_DWORD *)(a1 + 4 * v5 + 76));\n    ++v5;\n  }\n  while ( v4 != v5 );\n  result = 4 * v4;\n  qmemcpy(a2, (const void *)(a1 + 76), result);\n  return result;\n}\n"
    ],
    "sub_80ACEEC": [
        "0x80aceec",
        "int __usercall sub_80ACEEC@<eax>(int a1@<eax>, void *a2@<edx>)\n{\n  int v4; // eax\n  int v5; // edx\n  unsigned int v6; // ebp\n  int v7; // ecx\n  int v8; // edx\n  int v9; // edx\n  int v10; // ecx\n  int i; // ebp\n  int v12; // edx\n\n  v4 = *(_DWORD *)a1 & 0x7F;\n  v5 = v4 + 1;\n  *(_BYTE *)(a1 + v4 + 80) = 0x80;\n  do\n  {\n    v6 = 128 - v5;\n    memset((void *)(a1 + v5 + 80), 0, 128 - v5);\n    v7 = 0;\n    if ( (unsigned int)(128 - v5) > 0xF )\n    {\n      *(_DWORD *)(a1 + 200) = sub_80A9893(0, *(_QWORD *)a1 >> 29);\n      *(_DWORD *)(a1 + 204) = v8;\n      *(_DWORD *)(a1 + 192) = sub_80A9893(*(_DWORD *)(a1 + 4) >> 29, *(_QWORD *)(a1 + 8) >> 29);\n      *(_DWORD *)(a1 + 196) = v9;\n    }\n    sub_80AC44E((_QWORD *)a1, v7);\n    v5 = 0;\n  }\n  while ( v6 <= 0xF );\n  for ( i = 0; i != 8; ++i )\n  {\n    *(_DWORD *)(a1 + 8 * i + 16) = sub_80A9893(v10, *(_DWORD *)(a1 + 8 * i + 20));\n    *(_DWORD *)(a1 + 8 * i + 20) = v12;\n  }\n  qmemcpy(a2, (const void *)(a1 + 16), 0x40u);\n  return 64;\n}\n"
    ],
    "sub_80ACFB1": [
        "0x80acfb1",
        "int __usercall sub_80ACFB1@<eax>(_DWORD *a1@<eax>)\n{\n  int result; // eax\n\n  result = 0;\n  memset(a1, 0, 0xCCu);\n  a1[51] = 72;\n  return result;\n}\n"
    ],
    "sub_80ACFCB": [
        "0x80acfcb",
        "int __usercall sub_80ACFCB@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)\n{\n  int i; // eax\n  unsigned int v7; // ecx\n  int v8; // ebp\n  int v10; // [esp+0h] [ebp-14h]\n\n  for ( i = *(_DWORD *)(a1 + 200); ; i = 0 )\n  {\n    v7 = a3;\n    if ( a3 > *(_DWORD *)(a1 + 204) - i )\n      v7 = *(_DWORD *)(a1 + 204) - i;\n    a3 -= v7;\n    v10 = i + v7;\n    v8 = a2 - i;\n    while ( i != v10 )\n    {\n      *(_BYTE *)(a1 + i) ^= *(_BYTE *)(v8 + i);\n      ++i;\n    }\n    a2 += v7;\n    if ( *(_DWORD *)(a1 + 204) != i )\n      break;\n    sub_80AC1FF(a1);\n  }\n  *(_DWORD *)(a1 + 200) = i;\n  return v10;\n}\n"
    ],
    "sub_80AD028": [
        "0x80ad028",
        "int __usercall sub_80AD028@<eax>(_DWORD *a1@<eax>, void *a2@<edx>)\n{\n  *((_BYTE *)a1 + a1[50]) ^= 6u;\n  *((_BYTE *)a1 + a1[51] - 1) += 0x80;\n  sub_80AC1FF((int)a1);\n  qmemcpy(a2, a1, 0x40u);\n  return 64;\n}\n"
    ],
    "sub_80AD05E": [
        "0x80ad05e",
        "void __noreturn sub_80AD05E(char *a1, ...)\n{\n  int *v1; // eax\n  const char *v2; // eax\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v1 = __h_errno_location();\n  v2 = hstrerror(*v1);\n  sub_804D40A(a1, va, v2);\n  sub_804D604();\n}\n"
    ],
    "sub_80AD07E": [
        "0x80ad07e",
        "char *__userpurge sub_80AD07E@<eax>(unsigned __int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3)\n{\n  int v3; // esi\n  __int64 v4; // rax\n  char *v5; // eax\n  char *v6; // edi\n  unsigned __int8 *v7; // esi\n  unsigned int v8; // ebx\n\n  if ( a1 )\n  {\n    if ( a2 > 1 )\n    {\n      v3 = a2 * HIDWORD(a1);\n      a1 = a2 * (unsigned __int64)(unsigned int)a1;\n      HIDWORD(a1) += v3;\n    }\n    if ( a3 )\n    {\n      v4 = sub_80B4B88((a3 >> 1) + (unsigned int)a1, ((a3 >> 1) + a1) >> 32, a3, 0);\n      v5 = sub_804DDBF((char *)\"%llu\", v4);\n      return (char *)sub_80A9707(v5);\n    }\n    v6 = (_BYTE *)(\" %llu\" + 1);\n    v7 = (unsigned __int8 *)&unk_80D8F5A;\n    v8 = 0;\n    while ( a1 > 0x3FF )\n    {\n      ++v7;\n      v8 = (10 * (a1 & 0x3FF) + 512) >> 10;\n      a1 >>= 10;\n      v6 = \"%llu.%u%c\";\n    }\n    if ( v8 == 10 )\n    {\n      ++a1;\n      v8 = 0;\n      if ( !a2 )\n      {\nLABEL_15:\n        v6 = \"%llu%*c\";\n        v8 = 1;\n      }\n    }\n    else if ( !a2 )\n    {\n      if ( v8 > 4 )\n        ++a1;\n      goto LABEL_15;\n    }\n    v5 = sub_804DDBF(v6, a1, v8, *v7);\n    return (char *)sub_80A9707(v5);\n  }\n  return \"0\";\n}\n"
    ],
    "sub_80AD152": [
        "0x80ad152",
        "char *__userpurge sub_80AD152@<eax>(__int64 a1@<edx:eax>, char *a2@<ecx>, int a3)\n{\n  unsigned int v3; // edi\n  int v4; // esi\n  unsigned int v5; // ebp\n  unsigned int v6; // ebx\n  unsigned int v7; // ebp\n  char v8; // al\n  char *v9; // esi\n  char v10; // al\n  char v11; // al\n  char v12; // al\n  char v13; // al\n  char *v14; // edi\n  char v15; // al\n  char v16; // al\n  char *v17; // ebx\n  unsigned int v19; // [esp+0h] [ebp-1Ch]\n  unsigned int v20; // [esp+4h] [ebp-18h]\n\n  v3 = a1;\n  if ( HIDWORD(a1) || (v4 = 0, (unsigned int)a1 > 0x1869F) )\n  {\n    v3 = 10 * a1;\n    v5 = (unsigned __int64)(10 * a1) >> 32;\n    v4 = 0;\n    do\n    {\n      v3 = __PAIR64__(v5, v3) >> 10;\n      v5 >>= 10;\n      ++v4;\n    }\n    while ( __PAIR64__(v5, v3) > 0x1869F );\n  }\n  v6 = v3;\n  v19 = v3 / 0xA;\n  v7 = v3 % 0xA;\n  v20 = v3 / 0x64;\n  if ( v4 )\n  {\n    if ( v19 <= 0x63 )\n    {\n      v16 = byte_80D8F4F[v20];\n      *a2 = v16;\n      v17 = \"0123456789\";\n      if ( v16 == 32 )\n        v17 = byte_80D8F4F;\n      a2[1] = v17[v19 % 0xA];\n      a2[2] = 46;\n    }\n    else\n    {\n      v13 = byte_80D8F4F[v3 / 0x2710];\n      *a2 = v13;\n      v14 = \"0123456789\";\n      if ( v13 == 32 )\n        v14 = byte_80D8F4F;\n      v15 = v14[v6 / 0x3E8 % 0xA];\n      a2[1] = v15;\n      if ( v15 != 32 )\n        v14 = \"0123456789\";\n      v7 = v19 % 0xA;\n      a2[2] = v14[v20 % 0xA];\n    }\n    a2[3] = MEMORY[0x80D5BDE][v7];\n    v12 = *(_BYTE *)(a3 + v4);\n  }\n  else\n  {\n    v8 = byte_80D8F4F[v3 / 0x2710];\n    *a2 = v8;\n    v9 = \"0123456789\";\n    if ( v8 == 32 )\n      v9 = byte_80D8F4F;\n    v10 = v9[v3 / 0x3E8 % 0xA];\n    a2[1] = v10;\n    if ( v10 != 32 )\n      v9 = \"0123456789\";\n    v11 = v9[v20 % 0xA];\n    a2[2] = v11;\n    if ( v11 != 32 )\n      v9 = \"0123456789\";\n    a2[3] = v9[v19 % 0xA];\n    v12 = MEMORY[0x80D5BDE][v3 % 0xA];\n  }\n  a2[4] = v12;\n  return a2 + 5;\n}\n"
    ],
    "sub_80AD2FA": [
        "0x80ad2fa",
        "char *__userpurge sub_80AD2FA@<eax>(__int64 a1@<edx:eax>, char *a2@<ecx>, int a3)\n{\n  int v3; // edi\n  unsigned int v4; // eax\n  unsigned int v5; // esi\n  unsigned int v6; // ebx\n  char v7; // al\n  char *v8; // edi\n  char v9; // al\n  char v10; // al\n  char v11; // al\n  char *v12; // ebp\n  unsigned __int64 v14; // [esp+0h] [ebp-18h]\n\n  LODWORD(v14) = a1;\n  if ( HIDWORD(a1) || (v3 = 0, (unsigned int)a1 > 0x270F) )\n  {\n    v14 = 10 * a1;\n    v3 = 0;\n    do\n    {\n      v14 >>= 10;\n      ++v3;\n    }\n    while ( v14 > 0x270F );\n  }\n  v4 = (unsigned int)v14 / 0xA;\n  v5 = (unsigned int)v14 / 0xA;\n  v6 = (unsigned int)v14 % 0xA;\n  if ( v3 )\n  {\n    if ( v4 <= 9 )\n    {\n      *a2 = MEMORY[0x80D5BDE][v4];\n      a2[1] = 46;\n    }\n    else\n    {\n      v11 = byte_80D8F4F[(unsigned int)v14 / 0x3E8];\n      *a2 = v11;\n      v12 = byte_80D8F4F;\n      if ( v11 != 32 )\n        v12 = \"0123456789\";\n      v6 = v5 % 0xA;\n      a2[1] = v12[(unsigned int)v14 / 0x64 % 0xA];\n    }\n    a2[2] = MEMORY[0x80D5BDE][v6];\n    v10 = *(_BYTE *)(a3 + v3);\n  }\n  else\n  {\n    v7 = byte_80D8F4F[(unsigned int)v14 / 0x3E8];\n    *a2 = v7;\n    v8 = byte_80D8F4F;\n    if ( v7 != 32 )\n      v8 = \"0123456789\";\n    v9 = v8[(unsigned int)v14 / 0x64 % 0xA];\n    a2[1] = v9;\n    if ( v9 != 32 )\n      v8 = \"0123456789\";\n    a2[2] = v8[v5 % 0xA];\n    v10 = MEMORY[0x80D5BDE][(unsigned int)v14 % 0xA];\n  }\n  a2[3] = v10;\n  return a2 + 4;\n}\n"
    ],
    "sub_80AD44F": [
        "0x80ad44f",
        "int __usercall sub_80AD44F@<eax>(unsigned __int8 *a1@<eax>, _WORD *a2@<edx>)\n{\n  _WORD *v2; // ebp\n  int v3; // ebx\n  char v4; // cl\n  int v5; // edi\n  unsigned __int8 v6; // si\n  unsigned __int8 v7; // dl\n  unsigned __int8 *v9; // [esp+4h] [ebp-14h]\n\n  *a2 = 1;\n  v2 = a2 + 1;\n  v3 = 0;\nLABEL_2:\n  v9 = a1 + 2;\n  v4 = 0;\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = *a1;\n    v7 = *a1 - 48;\n    if ( v7 > 9u )\n      break;\nLABEL_10:\n    ++a1;\n    v4 = v7 + 16 * v4;\n    v5 = 1;\n    if ( a1 == v9 )\n    {\nLABEL_11:\n      *((_BYTE *)v2 + v3) = v4;\n      if ( v3 == 5 )\n        return *a1;\n      if ( *a1 == 58 )\n        ++a1;\n      ++v3;\n      goto LABEL_2;\n    }\n  }\n  if ( (unsigned __int8)((v6 | 0x20) - 97) <= 5u )\n  {\n    v7 = (v6 | 0x20) - 87;\n    goto LABEL_10;\n  }\n  if ( v5 && (v6 == 58 || !v6) )\n    goto LABEL_11;\n  return -1;\n}\n"
    ],
    "sub_80AD4D4": [
        "0x80ad4d4",
        "unsigned int __usercall sub_80AD4D4@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  unsigned int v2; // ecx\n\n  v2 = 0;\n  while ( a2 > 1 )\n  {\n    a1 += 2;\n    v2 += *((unsigned __int16 *)a1 - 1);\n    a2 -= 2;\n  }\n  if ( a2 == 1 )\n    v2 += *a1;\n  return ~(HIWORD(v2) + (unsigned __int16)v2 + ((unsigned int)(HIWORD(v2) + (unsigned __int16)v2) >> 16));\n}\n"
    ],
    "sub_80AD506": [
        "0x80ad506",
        "int __usercall sub_80AD506@<eax>(const char *a1@<eax>, struct in_addr *a2@<edx>)\n{\n  int v4; // ebx\n  struct hostent *v5; // eax\n\n  a2->s_addr = 2;\n  if ( !strcmp(a1, \"default\") )\n  {\n    a2[1].s_addr = 0;\n    return 1;\n  }\n  else\n  {\n    v4 = inet_aton(a1, a2 + 1);\n    if ( v4 )\n    {\n      return 0;\n    }\n    else\n    {\n      v5 = gethostbyname(a1);\n      if ( v5 )\n        a2[1].s_addr = (*(struct in_addr **)v5->h_addr_list)->s_addr;\n      else\n        return -1;\n    }\n  }\n  return v4;\n}\n"
    ],
    "sub_80AD56A": [
        "0x80ad56a",
        "char *__usercall sub_80AD56A@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)\n{\n  const char *v3; // ebp\n  int v4; // ebx\n  const char *v6; // eax\n  int v7; // ebp\n  char v8; // si\n  int i; // ecx\n  size_t v10; // eax\n  void *v11; // edi\n\n  if ( *(_WORD *)a1 != 2 )\n  {\n    *(_DWORD *)dword_80DBB7C = 97;\n    return 0;\n  }\n  v4 = *(_DWORD *)(a1 + 4);\n  if ( (a2 & 0xFFF) != 0 )\n    return (char *)sub_80B46B6(a3, a2);\n  if ( v4 )\n  {\n    v7 = 1;\n    if ( (v4 & ~a3) == 0 )\n    {\n      a2 = (a2 >> 14) & 1;\n      v7 = a2;\n    }\n    v8 = v7;\n    for ( i = dword_80DB738; i; i = *(_DWORD *)i )\n    {\n      if ( *(_DWORD *)(i + 4) == v4 )\n      {\n        a2 = v7;\n        if ( *(_BYTE *)(i + 8) == (_BYTE)v7 )\n        {\n          v6 = (const char *)(i + 9);\n          return sub_804DB46(v6);\n        }\n      }\n    }\n    if ( !v7 || (v3 = (const char *)sub_80B46A2()) == 0 )\n      v3 = (const char *)sub_80B46B6(i, a2);\n    v10 = strlen(v3);\n    v11 = sub_804DAFA(v10 + 12);\n    *(_DWORD *)v11 = dword_80DB738;\n    *((_DWORD *)v11 + 1) = v4;\n    *((_BYTE *)v11 + 8) = v8;\n    strcpy((char *)v11 + 9, v3);\n    dword_80DB738 = (int)v11;\n    return (char *)v3;\n  }\n  v6 = \"default\";\n  if ( (a2 & 0x8000) != 0 )\n    return sub_804DB46(v6);\n  else\n    return sub_804DB46(\"*\");\n}\n"
    ],
    "sub_80AD640": [
        "0x80ad640",
        "int __usercall sub_80AD640@<eax>(const char *a1@<eax>, struct sockaddr *a2@<edx>)\n{\n  int v4; // eax\n  struct addrinfo *v6; // edx\n  struct addrinfo *pai; // [esp+4h] [ebp-30h] BYREF\n  struct addrinfo req; // [esp+8h] [ebp-2Ch] BYREF\n\n  pai = 0;\n  memset(&req, 0, sizeof(req));\n  req.ai_family = 10;\n  v4 = getaddrinfo(a1, 0, &req, &pai);\n  if ( v4 )\n  {\n    sub_804D5F4(\"getaddrinfo: %s: %d\", a1, v4);\n    return -1;\n  }\n  else\n  {\n    v6 = pai;\n    qmemcpy(a2, pai->ai_addr, 0x1Cu);\n    freeaddrinfo(v6);\n    return 0;\n  }\n}\n"
    ],
    "sub_80AD6B6": [
        "0x80ad6b6",
        "char *__usercall sub_80AD6B6@<eax>(int a1@<eax>, __int16 a2@<dx>, int a3@<ecx>)\n{\n  const char *v4; // eax\n\n  if ( *(_WORD *)a1 == 10 )\n  {\n    if ( (a2 & 0x7FFF) != 0 )\n    {\n      return (char *)sub_80B46B6(a3, a2);\n    }\n    else if ( *(_DWORD *)(a1 + 8) || *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 20) )\n    {\n      return (char *)sub_80B46A2();\n    }\n    else\n    {\n      v4 = \"default\";\n      if ( (a2 & 0x8000) == 0 )\n        v4 = \"   *\" + 3;\n      return sub_804DB46(v4);\n    }\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 97;\n    return 0;\n  }\n}\n"
    ],
    "sub_80AD709": [
        "0x80ad709",
        "int __usercall sub_80AD709@<eax>(_DWORD *a1@<eax>)\n{\n  unsigned int v2; // ebx\n  int v3; // esi\n  int result; // eax\n\n  if ( !dword_80DB73C )\n    return 0;\n  v2 = a1[22];\n  v3 = a1[23];\n  for ( result = *((_DWORD *)dword_80DB73C + v2 % 0x137); result; result = *(_DWORD *)(result + 16) )\n  {\n    if ( v3 == *(_DWORD *)(result + 4)\n      && v2 == *(_DWORD *)result\n      && *(_DWORD *)(result + 12) == a1[1]\n      && *(_DWORD *)(result + 8) == *a1\n      && *(_BYTE *)(result + 20) == ((a1[4] & 0xF000) == 0x4000) )\n    {\n      result += 21;\n      return result;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AD771": [
        "0x80ad771",
        "_DWORD *__usercall sub_80AD771@<eax>(_DWORD *a1@<eax>, const char *a2@<edx>)\n{\n  const char *v3; // edi\n  size_t v4; // eax\n  void *v5; // ebx\n  int v6; // edx\n  int v7; // edx\n  _DWORD *result; // eax\n\n  v3 = &data;\n  if ( a2 )\n    v3 = a2;\n  v4 = strlen(v3);\n  v5 = sub_804DAFA(v4 + 24);\n  v6 = a1[23];\n  *(_DWORD *)v5 = a1[22];\n  *((_DWORD *)v5 + 1) = v6;\n  v7 = a1[1];\n  *((_DWORD *)v5 + 2) = *a1;\n  *((_DWORD *)v5 + 3) = v7;\n  *((_BYTE *)v5 + 20) = (a1[4] & 0xF000) == 0x4000;\n  strcpy((char *)v5 + 21, v3);\n  if ( !dword_80DB73C )\n    dword_80DB73C = sub_804DB2E(0x4DCu);\n  result = (char *)dword_80DB73C + 4 * (a1[22] % 0x137u);\n  *((_DWORD *)v5 + 4) = *result;\n  *result = v5;\n  return result;\n}\n"
    ],
    "sub_80AD7FC": [
        "0x80ad7fc",
        "void sub_80AD7FC()\n{\n  _DWORD *v0; // esi\n  int i; // ebx\n  _DWORD *j; // eax\n  _DWORD *v3; // edi\n\n  v0 = dword_80DB73C;\n  if ( dword_80DB73C )\n  {\n    for ( i = 0; i != 311; ++i )\n    {\n      for ( j = (_DWORD *)v0[i]; j; j = v3 )\n      {\n        v3 = (_DWORD *)j[4];\n        free(j);\n      }\n    }\n    free(v0);\n    dword_80DB73C = 0;\n  }\n}\n"
    ],
    "sub_80AD83E": [
        "0x80ad83e",
        "_BOOL4 __fastcall sub_80AD83E(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // edx\n  __int16 v5; // [esp+10h] [ebp-50h]\n\n  if ( a2 )\n    v2 = stat64();\n  else\n    v2 = lstat64();\n  v3 = 0;\n  if ( !v2 )\n    return (v5 & 0xF000) == 0x4000;\n  return v3;\n}\n"
    ],
    "sub_80AD876": [
        "0x80ad876",
        "int __usercall sub_80AD876@<eax>(unsigned __int64 a1@<edx:eax>)\n{\n  int v1; // ecx\n  int v2; // ebp\n  int v3; // ebx\n\n  v1 = 62;\n  v2 = 0;\n  do\n  {\n    v3 = 2 * v2;\n    v2 = 2 * v2 + 1;\n    if ( (unsigned int)v2 * (unsigned __int64)(unsigned int)v2 > a1 >> v1 )\n      v2 = v3;\n    v1 -= 2;\n  }\n  while ( v1 != -2 );\n  return v2;\n}\n"
    ],
    "sub_80AD8CD": [
        "0x80ad8cd",
        "int __usercall sub_80AD8CD@<eax>(char a1@<al>)\n{\n  return (unsigned __int8)(a1 - 48) <= 9u || (unsigned __int8)((a1 | 0x20) - 97) <= 0x19u || a1 == 95;\n}\n"
    ],
    "sub_80AD8F8": [
        "0x80ad8f8",
        "__int16 *__usercall sub_80AD8F8@<eax>(__int16 *result@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int v3; // edx\n  __int16 v4; // cx\n\n  if ( a2 != a3 )\n  {\n    result += a3;\n    v3 = a2 - a3;\n    do\n    {\n      v4 = *result;\n      result[v3] = *result;\n      ++result;\n    }\n    while ( v4 );\n  }\n  return result;\n}\n"
    ],
    "sub_80AD916": [
        "0x80ad916",
        "int __usercall sub_80AD916@<eax>(int a1@<eax>)\n{\n  signed int v2; // eax\n  int i; // edx\n  __int16 v4; // ax\n  int v5; // esi\n  int v6; // edi\n  int v7; // esi\n  __int16 *v8; // ebp\n  __int16 v9; // dx\n  int j; // eax\n  int v11; // ebp\n  unsigned __int16 v12; // di\n  int v13; // ecx\n  int k; // edx\n  __int16 v15; // ax\n  int v16; // esi\n  int m; // ecx\n  __int16 v18; // ax\n  int n; // eax\n  __int16 v20; // dx\n  int ii; // ecx\n  int v22; // esi\n  int jj; // ecx\n  __int16 v24; // ax\n  int kk; // eax\n  int mm; // eax\n  __int16 v27; // di\n  bool v28; // dl\n  int nn; // eax\n  __int16 v30; // dx\n\n  v2 = strlen((const char *)a1);\n  do\n  {\n    *(_WORD *)(a1 + 2 * v2) = *(unsigned __int8 *)(a1 + v2);\n    --v2;\n  }\n  while ( v2 >= 0 );\n  for ( i = 0; ; i = v5 )\n  {\n    v4 = *(_WORD *)(a1 + 2 * i);\n    if ( !v4 )\n      break;\n    v5 = i + 1;\n    if ( v4 == 92 )\n    {\n      sub_80AD8F8((__int16 *)a1, i, i + 1);\n      *(_WORD *)(a1 + 2 * v5 - 2) |= 0x100u;\n    }\n  }\n  v6 = 0;\n  v7 = 0;\n  while ( 1 )\n  {\n    v8 = (__int16 *)(a1 + 2 * v7);\n    v9 = *v8;\n    if ( !*v8 )\n      break;\n    j = v9;\n    if ( !v9 )\n      break;\n    if ( v9 != 34 && v9 != 39 )\n    {\n      if ( !v6 )\n        goto LABEL_18;\n      goto LABEL_17;\n    }\n    if ( v6 != v9 && v6 )\n    {\nLABEL_17:\n      HIBYTE(v9) |= 1u;\n      *v8 = v9;\nLABEL_18:\n      ++v7;\n    }\n    else\n    {\n      v6 ^= v9;\n      sub_80AD8F8((__int16 *)a1, v7, v7 + 1);\n    }\n  }\n  for ( j = 0; ; ++j )\n  {\n    v11 = 2 * j;\n    v12 = *(_WORD *)(a1 + 2 * j);\n    if ( !v12 )\n      break;\n    if ( v12 == 38 || v12 == 59 || v12 == 124 )\n    {\n      if ( j )\n      {\n        v13 = *(__int16 *)(a1 + v11 - 2);\n        if ( v12 == 38 )\n        {\n          if ( (*(_WORD *)(a1 + v11 - 2) & 0xFFFD) == 60 )\n            continue;\nLABEL_32:\n          sub_80AD8F8((__int16 *)a1, 0, j + (*(_WORD *)(a1 + v11 + 2) == v12) + 1);\n          j = -1;\n          continue;\n        }\n      }\n      else\n      {\n        v13 = 0;\n        if ( v12 == 38 )\n          goto LABEL_32;\n      }\n      if ( v13 != 62 || v12 != 124 )\n        goto LABEL_32;\n    }\n  }\n  for ( k = 0; ; k = v16 )\n  {\n    v15 = *(_WORD *)(a1 + 2 * k);\n    if ( !v15 )\n      break;\n    v16 = k + 1;\n    if ( v15 == 96 )\n    {\n      for ( m = k + 1; ; ++m )\n      {\n        v18 = *(_WORD *)(a1 + 2 * m);\n        if ( !v18 )\n          break;\n        if ( v18 == 96 )\n        {\n          sub_80AD8F8((__int16 *)a1, k, m);\n          goto LABEL_42;\n        }\n      }\n      sub_80AD8F8((__int16 *)a1, 0, k + 1);\n      break;\n    }\nLABEL_42:\n    ;\n  }\n  for ( n = 0; ; ++n )\n  {\n    v20 = *(_WORD *)(a1 + 2 * n);\n    if ( !v20 )\n      break;\n    if ( v20 == 40 || v20 == 123 )\n    {\n      sub_80AD8F8((__int16 *)a1, 0, n + 1);\n      n = -1;\n    }\n  }\n  for ( ii = 0; *(_WORD *)(a1 + 2 * ii) == 32; ++ii )\n    ;\n  sub_80AD8F8((__int16 *)a1, 0, ii);\n  v22 = 0;\n  for ( jj = 0; ; ++jj )\n  {\n    v24 = *(_WORD *)(a1 + 2 * jj);\n    if ( !v24 )\n      break;\n    if ( v24 == 32 )\n    {\n      if ( v22 || *(_BYTE *)a1 != 99 || *(_BYTE *)(a1 + 2) != 100 || jj != 2 )\n      {\nLABEL_62:\n        v22 = 2;\n        break;\n      }\n      v22 = 1;\n    }\n    else if ( (v24 & 0xFFFD) == 60 )\n    {\n      goto LABEL_62;\n    }\n  }\n  for ( kk = 0; *(_WORD *)(a1 + 2 * kk); ++kk )\n    ;\n  for ( mm = kk - 1; mm != -1; --mm )\n  {\n    v27 = *(_WORD *)(a1 + 2 * mm);\n    v28 = 1;\n    if ( (unsigned __int16)(v27 - 32) <= 0x1Eu )\n      v28 = ((0x50000041u >> (v27 - 32)) & 1) == 0;\n    if ( v27 == 124 || !v28 )\n    {\n      sub_80AD8F8((__int16 *)a1, 0, mm + 1);\n      break;\n    }\n  }\n  for ( nn = 0; ; ++nn )\n  {\n    v30 = *(_WORD *)(a1 + 2 * nn);\n    *(_BYTE *)(a1 + nn) = v30;\n    if ( !(_BYTE)v30 )\n      break;\n  }\n  return v22;\n}\n"
    ],
    "sub_80ADB45": [
        "0x80adb45",
        "int sub_80ADB45()\n{\n  return sub_804DD98(7);\n}\n"
    ],
    "sub_80ADB4F": [
        "0x80adb4f",
        "unsigned int __usercall sub_80ADB4F@<eax>(unsigned int result@<eax>)\n{\n  _DWORD *v1; // esi\n  unsigned int v2; // edx\n  unsigned int v3; // ebx\n  unsigned int v4; // eax\n  int v5; // ebx\n  unsigned int v6; // edi\n  int v7; // [esp-8h] [ebp-14h]\n\n  v1 = dword_80DBBA0;\n  v2 = *((_DWORD *)dword_80DBBA0 + 5);\n  v3 = result;\n  if ( v2 <= result )\n    v3 = *((_DWORD *)dword_80DBBA0 + 5);\n  if ( v3 )\n  {\n    *((_DWORD *)dword_80DBBA0 + 5) = v2 - v3;\n    v4 = v1[2];\n    if ( v4 < v3 )\n    {\n      v5 = v3 - v4;\n      v6 = v1[1];\n      v1[2] = (v6 * v1[3] - v5) % v6;\n      v1[3] -= (v5 - 1) / v6 + 1;\n      printf(\"\\r\\x1B[%uA\", (v5 - 1) / v6 + 1);\n      result = v1[2];\n      if ( !result )\n        return result;\n      printf(\"\\x1B[%uC\", v1[2]);\n    }\n    else\n    {\n      v1[2] = v4 - v3;\n      if ( v3 <= 4 )\n      {\n        do\n        {\n          result = sub_804DD98(8);\n          --v3;\n        }\n        while ( v3 );\n        return result;\n      }\n      printf(\"\\x1B[%uD\", v3);\n    }\n    return v7;\n  }\n  return result;\n}\n"
    ],
    "sub_80ADBDF": [
        "0x80adbdf",
        "int sub_80ADBDF()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  int result; // eax\n  unsigned __int8 v3; // al\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  while ( 1 )\n  {\n    result = v0[5];\n    if ( !result )\n      break;\n    v3 = *(_BYTE *)(v1 + result - 1) - 9;\n    if ( v3 != 23 && v3 > 4u )\n    {\n      while ( 1 )\n      {\n        result = v0[5];\n        if ( !result )\n          break;\n        LOBYTE(result) = *(_BYTE *)(v1 + result - 1);\n        result -= 9;\n        if ( (_BYTE)result == 23 || (unsigned __int8)result <= 4u )\n          break;\n        sub_80ADB4F(1u);\n      }\n      return result;\n    }\n    sub_80ADB4F(1u);\n  }\n  return result;\n}\n"
    ],
    "sub_80ADC31": [
        "0x80adc31",
        "_BYTE *sub_80ADC31()\n{\n  const char **v0; // esi\n  _BYTE *result; // eax\n  int v2; // ebx\n  const char *v3; // edi\n  int v4; // [esp-4h] [ebp-10h]\n\n  v0 = (const char **)dword_80DBBA0;\n  result = (_BYTE *)*((_DWORD *)dword_80DBBA0 + 8);\n  if ( *result )\n  {\n    v2 = *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 16) + 8;\n    free(*(void **)(*(_DWORD *)dword_80DBBA0 + 4 * v2));\n    v3 = *v0;\n    *(_DWORD *)&v3[4 * v2] = sub_804DB46(v0[8]);\n    return (_BYTE *)v4;\n  }\n  return result;\n}\n"
    ],
    "sub_80ADC64": [
        "0x80adc64",
        "int sub_80ADC64()\n{\n  void *v0; // esi\n  int v1; // ebx\n\n  v0 = dword_80DBBA0;\n  v1 = **(_DWORD **)dword_80DBBA0 & 1;\n  if ( v1 && *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 16) )\n  {\n    sub_80ADC31();\n    --*(_DWORD *)(*(_DWORD *)v0 + 16);\n  }\n  else\n  {\n    sub_80ADB45();\n    return 0;\n  }\n  return v1;\n}\n"
    ],
    "sub_80ADC93": [
        "0x80adc93",
        "// This function checks certain conditions related to a counter and either\n// increments it or performs a different action. It first retrieves a pointer from\n// a global variable (dword_80DBBA0), then checks if the byte at that location has\n// bit 0 set and if another condition related to two DWORD values is met. If these\n// conditions are true, it calls another function (sub_80ADC31) and increments the\n// counter by one. Otherwise, it calls a different function (sub_80ADB45) and\n// returns 0.\nint sub_80ADC93()\n{\n  void *v0; // ebx\n  int result; // eax\n\n  v0 = dword_80DBBA0;\n  if ( (**(_BYTE **)dword_80DBBA0 & 1) != 0\n    && *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 16) < *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 12) )\n  {\n    sub_80ADC31();\n    result = *(_DWORD *)(*(_DWORD *)v0 + 16) + 1;\n    *(_DWORD *)(*(_DWORD *)v0 + 16) = result;\n  }\n  else\n  {\n    sub_80ADB45();\n    return 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80ADCC2": [
        "0x80adcc2",
        "void sub_80ADCC2()\n{\n  void *v0; // ebx\n  int v1; // eax\n  int v2; // edx\n  int v3; // eax\n\n  v0 = dword_80DBBA0;\n  if ( *((_DWORD *)dword_80DBBA0 + 13) )\n  {\n    while ( 1 )\n    {\n      v1 = *((_DWORD *)v0 + 14);\n      v2 = *((_DWORD *)v0 + 13);\n      if ( !v1 )\n        break;\n      v3 = v1 - 1;\n      *((_DWORD *)v0 + 14) = v3;\n      free(*(void **)(v2 + 4 * v3));\n    }\n    free(*((void **)v0 + 13));\n    *((_DWORD *)v0 + 13) = 0;\n  }\n}\n"
    ],
    "sub_80ADCF8": [
        "0x80adcf8",
        "int sub_80ADCF8()\n{\n  void **v0; // ebx\n  void *v1; // eax\n  int v3; // [esp-4h] [ebp-8h]\n\n  v0 = (void **)dword_80DBBA0;\n  free(*((void **)dword_80DBBA0 + 9));\n  free(v0[11]);\n  v1 = v0[12];\n  if ( v1 != &unk_80D8FD5 )\n    free(v1);\n  free(v0);\n  return v3;\n}\n"
    ],
    "sub_80ADD2B": [
        "0x80add2b",
        "unsigned int __usercall sub_80ADD2B@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)\n{\n  unsigned int result; // eax\n  FILE *v4; // ebp\n  int i; // ebx\n  int v6; // ecx\n  char *v7; // eax\n  char *v8; // edi\n  int v9; // edi\n  int v10; // edx\n  const char *v11; // ebp\n  int v12; // [esp+0h] [ebp-FB0h]\n  void *ptr[1003]; // [esp+4h] [ebp-FACh] BYREF\n\n  result = sub_80B3D37(a2);\n  if ( result )\n  {\n    v4 = (FILE *)result;\n    for ( i = a1[3]; i; a1[i + 8] = 0 )\n      free((void *)a1[--i + 8]);\n    memset(ptr, 0, 0xF9Cu);\n    v6 = 0;\n    a1[6] = 0;\n    while ( 1 )\n    {\n      v7 = sub_80AB85A((int)v4, v6);\n      v8 = v7;\n      if ( !v7 )\n        break;\n      if ( *v7 )\n      {\n        free(ptr[i]);\n        ptr[i] = v8;\n        ++a1[6];\n        if ( a1[5] == ++i )\n          i = 0;\n      }\n      else\n      {\n        free(v7);\n      }\n    }\n    result = fclose(v4);\n    v9 = a1[5];\n    if ( a1[6] )\n    {\n      while ( !ptr[i] )\n      {\n        if ( ++i == v9 )\n          i = 0;\n      }\n    }\n    v10 = 0;\n    while ( v9 != v10 )\n    {\n      v11 = (const char *)ptr[i];\n      if ( !v11 )\n        break;\n      if ( v9 == ++i )\n        i = 0;\n      v12 = v10;\n      result = strlen(v11);\n      if ( result > 0x3FF )\n        *((_BYTE *)v11 + 1023) = 0;\n      v10 = v12 + 1;\n      a1[v12 + 8] = v11;\n    }\n    a1[3] = v10;\n  }\n  return result;\n}\n"
    ],
    "sub_80ADE14": [
        "0x80ade14",
        "void sub_80ADE14()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  int v2; // eax\n  char v3; // cl\n  int v4; // eax\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  if ( *((_DWORD *)dword_80DBBA0 + 5) )\n  {\n    while ( 1 )\n    {\n      sub_80ADB4F(1u);\n      v2 = v0[5];\n      if ( !v2 )\n        break;\n      v3 = *(_BYTE *)(v1 + v2);\n      if ( (unsigned __int8)(v3 - 9) > 4u && v3 != 32 )\n      {\n        if ( (unsigned __int8)sub_80AD8CD(v3) )\n        {\n          while ( 1 )\n          {\n            v4 = v0[5];\n            if ( !v4 || !(unsigned __int8)sub_80AD8CD(*(_BYTE *)(v1 + v4 - 1)) )\n              break;\n            sub_80ADB4F(1u);\n          }\n        }\n        else if ( *(_BYTE *)strchrnul() )\n        {\n          while ( v0[5] && *(_BYTE *)strchrnul() )\n            sub_80ADB4F(1u);\n        }\n        return;\n      }\n    }\n  }\n}\n"
    ],
    "sub_80ADEB4": [
        "0x80adeb4",
        "unsigned int sub_80ADEB4()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  unsigned int result; // eax\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  while ( 1 )\n  {\n    sub_80ADB4F(1u);\n    result = v0[5];\n    if ( !result )\n      break;\n    if ( *(_BYTE *)(v1 + result) != 32 && !*(_BYTE *)strchrnul() )\n    {\n      do\n      {\n        result = *(unsigned __int8 *)(v1 + v0[5] - 1);\n        if ( (_BYTE)result == 32 )\n          break;\n        result = strchrnul();\n        if ( *(_BYTE *)result )\n          break;\n        result = sub_80ADB4F(1u);\n      }\n      while ( v0[5] );\n      return result;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80ADF1B": [
        "0x80adf1b",
        "unsigned __int64 __usercall sub_80ADF1B@<edx:eax>(char a1@<al>)\n{\n  _DWORD *v1; // ebx\n  unsigned int v2; // eax\n  int v3; // edx\n  unsigned __int64 v5; // [esp-8h] [ebp-Ch]\n\n  v1 = dword_80DBBA0;\n  if ( a1 )\n    v2 = *((_DWORD *)dword_80DBBA0 + 9);\n  else\n    v2 = *((_DWORD *)dword_80DBBA0 + 10);\n  v5 = __PAIR64__((unsigned int)stdout, v2);\n  fputs_unlocked();\n  v1[5] = 0;\n  v3 = v1[4] % v1[1];\n  v1[3] = v1[4] / v1[1];\n  v1[2] = v3;\n  return v5;\n}\n"
    ],
    "sub_80ADF54": [
        "0x80adf54",
        "unsigned __int64 __usercall sub_80ADF54@<edx:eax>(char *a1@<eax>)\n{\n  int v1; // edx\n  void *v2; // esi\n  char *v3; // ebx\n  int v4; // ebp\n  char *v5; // edi\n  char *v6; // ecx\n  char v7; // al\n  char *v8; // eax\n  char *v9; // edi\n  _BYTE *v10; // edx\n  char *v11; // eax\n  int v12; // ecx\n  char v13; // al\n  char *v14; // eax\n  int v15; // edi\n  size_t v16; // eax\n  char *v17; // eax\n  _DWORD *v18; // ebx\n  char *v19; // eax\n  char v21; // [esp+0h] [ebp-34h]\n  char v22; // [esp+7h] [ebp-2Dh]\n  char *src; // [esp+8h] [ebp-2Ch]\n  const char *srca; // [esp+8h] [ebp-2Ch]\n  char v26[2]; // [esp+12h] [ebp-22h] BYREF\n  char *endptr; // [esp+14h] [ebp-20h] BYREF\n  char nptr[25]; // [esp+1Bh] [ebp-19h] BYREF\n\n  v2 = sub_804DB2E(1u);\n  v26[1] = 0;\n  v22 = 91;\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = a1;\n    if ( !*a1 )\n      break;\n    endptr = v26;\n    v6 = ++a1;\n    v21 = *v5;\n    if ( *v5 != 92 )\n      goto LABEL_56;\n    v21 = v5[1];\n    if ( v21 != 116 )\n    {\n      v21 = sub_80B0CB3(v6);\n      v6 = v5 + 1;\n    }\n    if ( v6 != a1 )\n      goto LABEL_56;\n    if ( !v5[1] )\n      break;\n    a1 = v5 + 2;\n    v7 = v5[1];\n    v21 = v7;\n    if ( v7 == 88 )\n      goto LABEL_45;\n    if ( (unsigned __int8)v7 > 0x58u )\n    {\n      if ( v7 == 116 )\n      {\nLABEL_33:\n        *(sub_804EB80(0, 9u, nptr, (time_t)v3) - 3) = 0;\n        endptr = nptr;\n        goto LABEL_56;\n      }\n      if ( (unsigned __int8)v7 > 0x74u )\n      {\n        if ( v7 != 119 )\n        {\n          if ( v7 == 120 )\n          {\nLABEL_45:\n            v15 = 0;\n            while ( 1 )\n            {\n              nptr[v15] = *a1;\n              src = (char *)(v15 + 1);\n              nptr[v15 + 1] = 0;\n              if ( strtoul(nptr, &endptr, 16) > 0xFF || endptr - nptr < (int)src )\n                break;\n              ++a1;\n              ++v15;\n              if ( src == (char *)3 )\n                goto LABEL_50;\n            }\n            nptr[v15] = 0;\nLABEL_50:\n            v21 = strtoul(nptr, 0, 16);\n            if ( !v21 )\n              v21 = 63;\n            v8 = v26;\nLABEL_53:\n            endptr = v8;\n          }\n          else if ( v7 == 117 )\n          {\n            v8 = (char *)*((_DWORD *)dword_80DBBA0 + 11);\n            if ( !v8 )\n              v8 = (char *)&data;\n            goto LABEL_53;\n          }\nLABEL_56:\n          v9 = 0;\n          goto LABEL_57;\n        }\nLABEL_34:\n        if ( !v3 )\n        {\n          v3 = (char *)sub_80B46C0(v6, v1);\n          if ( v3 )\n          {\n            v10 = (_BYTE *)*((_DWORD *)dword_80DBBA0 + 12);\n            if ( *v10 )\n            {\n              v11 = sub_804D210(v3, v10);\n              if ( v11 )\n              {\n                v13 = *v11;\n                if ( v13 == 47 || !v13 )\n                {\n                  *v3 = 126;\n                  sub_80B2C69(v12);\n                }\n              }\n            }\n          }\n          else\n          {\n            v3 = \"(unknown)\";\n          }\n        }\n        endptr = v3;\n        v9 = 0;\n        if ( v21 != 119 )\n        {\n          v14 = strrchr(v3, 47);\n          if ( v14 )\n            endptr = v14 + 1;\n        }\n        goto LABEL_57;\n      }\n      if ( v7 != 93 )\n      {\n        if ( v7 == 104 )\n          goto LABEL_29;\n        if ( v7 != 91 )\n          goto LABEL_56;\n      }\n      if ( v22 != v7 )\n        goto LABEL_56;\n      v22 ^= 6u;\n    }\n    else\n    {\n      if ( (unsigned __int8)v7 > 0x41u )\n      {\n        if ( v7 == 84 )\n          goto LABEL_33;\n        if ( v7 != 87 )\n        {\n          if ( v7 != 72 )\n            goto LABEL_56;\nLABEL_29:\n          v9 = (char *)sub_80B2BD8();\n          endptr = v9;\n          if ( v21 == 104 )\n            *(_BYTE *)strchrnul() = 0;\n          goto LABEL_57;\n        }\n        goto LABEL_34;\n      }\n      if ( (unsigned __int8)v7 >= 0x40u )\n        goto LABEL_33;\n      if ( v7 != 36 )\n        goto LABEL_56;\n      v9 = 0;\n      if ( !geteuid() )\n        v21 = 35;\nLABEL_57:\n      v26[0] = v21;\n      srca = endptr;\n      v16 = strlen(endptr);\n      v4 += v16;\n      if ( v21 == 10 )\n      {\n        *((_DWORD *)dword_80DBBA0 + 4) = 0;\n      }\n      else if ( v22 != 93 )\n      {\n        *((_DWORD *)dword_80DBBA0 + 4) += v16;\n      }\n      v17 = (char *)sub_804DB13(v2, v4 + 1);\n      v2 = strcat(v17, srca);\n      free(v9);\n    }\n  }\n  if ( v3 != \"(unknown)\" )\n    free(v3);\n  v18 = dword_80DBBA0;\n  *((_DWORD *)dword_80DBBA0 + 10) = v2;\n  v18[9] = v2;\n  v19 = strrchr((const char *)v2, 10);\n  if ( v19 )\n    v18[10] = v19 + 1;\n  return sub_80ADF1B(1);\n}\n"
    ],
    "sub_80AE287": [
        "0x80ae287",
        "int sub_80AE287()\n{\n  _DWORD *v0; // ebx\n  int v1; // edx\n  int v2; // eax\n  int v3; // ecx\n  int v4; // esi\n  int result; // eax\n  int v6; // [esp-4h] [ebp-Ch]\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 5);\n  v2 = *(unsigned __int8 *)(*((_DWORD *)dword_80DBBA0 + 8) + v1);\n  v3 = *((_DWORD *)dword_80DBBA0 + 2);\n  if ( (_BYTE)v2 )\n  {\n    *((_DWORD *)dword_80DBBA0 + 5) = v1 + 1;\n    v0[2] = v3 + 1;\n  }\n  else\n  {\n    v2 = 32;\n  }\n  v4 = v0[2] - v0[1];\n  result = sub_804DD98(v2);\n  if ( v4 >= 0 )\n  {\n    puts(\"\\r\");\n    ++v0[3];\n    v0[2] = 0;\n    return v6;\n  }\n  return result;\n}\n"
    ],
    "sub_80AE2D8": [
        "0x80ae2d8",
        "void *sub_80AE2D8()\n{\n  void *result; // eax\n\n  result = dword_80DBBA0;\n  if ( *((_DWORD *)dword_80DBBA0 + 5) < *((_DWORD *)dword_80DBBA0 + 6) )\n    return (void *)sub_80AE287();\n  return result;\n}\n"
    ],
    "sub_80AE2EB": [
        "0x80ae2eb",
        "_BYTE *__usercall sub_80AE2EB@<eax>(int a1@<eax>)\n{\n  _DWORD *v2; // ebx\n  int v3; // esi\n  unsigned int v4; // eax\n  _BYTE *result; // eax\n\n  v2 = dword_80DBBA0;\n  v3 = *((_DWORD *)dword_80DBBA0 + 8);\n  if ( (unsigned __int8)sub_80AD8CD(*(_BYTE *)(v3 + *((_DWORD *)dword_80DBBA0 + 5))) )\n  {\n    while ( 1 )\n    {\n      v4 = v2[5];\n      if ( v4 >= v2[6] || !(unsigned __int8)sub_80AD8CD(*(_BYTE *)(v3 + v4 + 1)) )\n        break;\n      sub_80AE2D8();\n    }\n  }\n  else if ( *(_BYTE *)strchrnul() )\n  {\n    while ( v2[5] < v2[6] && *(_BYTE *)strchrnul() )\n      sub_80AE2D8();\n  }\n  result = (_BYTE *)v2[6];\n  if ( v2[5] < (unsigned int)result )\n    result = sub_80AE2D8();\n  if ( a1 )\n  {\n    while ( 1 )\n    {\n      result = (_BYTE *)v2[5];\n      if ( (unsigned int)result >= v2[6] )\n        break;\n      LOBYTE(result) = result[v3];\n      result -= 9;\n      if ( (_BYTE)result != 23 && (unsigned __int8)result > 4u )\n        break;\n      sub_80AE2D8();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AE394": [
        "0x80ae394",
        "_BYTE *__usercall sub_80AE394@<eax>(_BYTE *result@<eax>)\n{\n  _BYTE *v1; // edi\n  _DWORD *v2; // ebx\n  int v3; // esi\n  unsigned int v4; // edx\n  unsigned __int8 v5; // dl\n\n  v1 = result;\n  v2 = dword_80DBBA0;\n  v3 = *((_DWORD *)dword_80DBBA0 + 8);\n  while ( 1 )\n  {\n    v4 = v2[5];\n    if ( v4 >= v2[6] )\n      break;\n    v5 = *(_BYTE *)(v3 + v4) - 9;\n    if ( v5 == 23 || v5 <= 4u )\n      break;\n    result = sub_80AE2D8();\n  }\n  if ( v1 )\n  {\n    while ( 1 )\n    {\n      result = (_BYTE *)v2[5];\n      if ( (unsigned int)result >= v2[6] )\n        break;\n      LOBYTE(result) = result[v3];\n      result -= 9;\n      if ( (_BYTE)result != 23 && (unsigned __int8)result > 4u )\n        break;\n      sub_80AE2D8();\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AE3E6": [
        "0x80ae3e6",
        "_BYTE *sub_80AE3E6()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  _BYTE *result; // eax\n  unsigned int v3; // edx\n  unsigned int v4; // edx\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  result = (_BYTE *)(*((_DWORD *)dword_80DBBA0 + 6) - 1);\n  if ( *((_DWORD *)dword_80DBBA0 + 5) < (unsigned int)result )\n  {\n    while ( 1 )\n    {\n      sub_80AE2D8();\n      v3 = v0[5];\n      result = (_BYTE *)(v0[6] - 1);\n      if ( v3 >= (unsigned int)result )\n        break;\n      if ( (unsigned __int8)(*(_BYTE *)(v1 + v3) - 9) > 4u && *(_BYTE *)(v1 + v3) != 32 )\n      {\n        if ( (unsigned __int8)sub_80AD8CD(*(_BYTE *)(v1 + v3)) )\n        {\n          while ( 1 )\n          {\n            v4 = v0[5];\n            result = (_BYTE *)(v0[6] - 1);\n            if ( v4 >= (unsigned int)result )\n              break;\n            result = (_BYTE *)sub_80AD8CD(*(_BYTE *)(v1 + v4 + 1));\n            if ( !(_BYTE)result )\n              break;\n            sub_80AE2D8();\n          }\n        }\n        else\n        {\n          result = (_BYTE *)strchrnul();\n          if ( *result )\n          {\n            while ( 1 )\n            {\n              result = (_BYTE *)(v0[6] - 1);\n              if ( v0[5] >= (unsigned int)result )\n                break;\n              result = (_BYTE *)strchrnul();\n              if ( !*result )\n                break;\n              sub_80AE2D8();\n            }\n          }\n        }\n        return result;\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AE486": [
        "0x80ae486",
        "unsigned int sub_80AE486()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  unsigned int v2; // eax\n  unsigned __int8 v3; // al\n  unsigned int v4; // edx\n  unsigned int result; // eax\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  do\n  {\n    sub_80AE2D8();\n    v2 = v0[5];\n    if ( v2 >= v0[6] )\n      break;\n    v3 = *(_BYTE *)(v1 + v2) - 9;\n  }\n  while ( v3 == 23 || v3 <= 4u );\n  while ( 1 )\n  {\n    v4 = v0[5];\n    result = v0[6] - 1;\n    if ( v4 >= result )\n      break;\n    LOBYTE(result) = *(_BYTE *)(v1 + v4 + 1);\n    result -= 9;\n    if ( (_BYTE)result == 23 || (unsigned __int8)result <= 4u )\n      break;\n    sub_80AE2D8();\n  }\n  return result;\n}\n"
    ],
    "sub_80AE4D0": [
        "0x80ae4d0",
        "int sub_80AE4D0()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  int result; // eax\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  while ( 1 )\n  {\n    result = *(unsigned __int8 *)(v1 + v0[5]);\n    if ( !(_BYTE)result )\n      break;\n    if ( (_BYTE)result != 32 && !*(_BYTE *)strchrnul() )\n    {\n      do\n      {\n        sub_80AE2D8();\n        result = *(unsigned __int8 *)(v1 + v0[5]);\n        if ( (result & 0xDF) == 0 )\n          break;\n        result = strchrnul();\n      }\n      while ( !*(_BYTE *)result );\n      return result;\n    }\n    sub_80AE2D8();\n  }\n  return result;\n}\n"
    ],
    "sub_80AE52A": [
        "0x80ae52a",
        "void *sub_80AE52A()\n{\n  void *result; // eax\n\n  while ( 1 )\n  {\n    result = dword_80DBBA0;\n    if ( *((_DWORD *)dword_80DBBA0 + 5) >= *((_DWORD *)dword_80DBBA0 + 6) )\n      break;\n    sub_80AE287();\n  }\n  return result;\n}\n"
    ],
    "sub_80AE53F": [
        "0x80ae53f",
        "void *sub_80AE53F()\n{\n  void *result; // eax\n\n  sub_80AE52A();\n  result = dword_80DBBA0;\n  if ( !*((_DWORD *)dword_80DBBA0 + 5) || *((_DWORD *)dword_80DBBA0 + 2) )\n    return (void *)sub_804DD98(10);\n  return result;\n}\n"
    ],
    "sub_80AE560": [
        "0x80ae560",
        "unsigned int __usercall sub_80AE560@<eax>(int a1@<eax>, unsigned int a2@<edx>, char a3@<cl>)\n{\n  if ( a1 > 0 )\n    printf(\"\\x1B[%uA\", a1);\n  sub_804DD98(13);\n  sub_80ADF1B(a3);\n  sub_80AE52A();\n  printf(\"\\x1B[J\");\n  return sub_80ADB4F(a2);\n}\n"
    ],
    "sub_80AE5A2": [
        "0x80ae5a2",
        "unsigned int __fastcall sub_80AE5A2(int a1, int a2)\n{\n  unsigned int v2; // esi\n  _DWORD *v3; // ecx\n  int v4; // eax\n  unsigned int v5; // ebx\n  unsigned int v6; // eax\n\n  v2 = sub_804D986(0, a2);\n  v3 = dword_80DBBA0;\n  *((_DWORD *)dword_80DBBA0 + 1) = v2;\n  v4 = v3[5];\n  v5 = v3[6] - v4;\n  v6 = (v3[4] + v4) / v2;\n  if ( v6 < v3[3] )\n    v6 = v3[3];\n  return sub_80AE560(v6, v5, 0);\n}\n"
    ],
    "sub_80AE5D9": [
        "0x80ae5d9",
        "void *__fastcall sub_80AE5D9(int a1)\n{\n  void *result; // eax\n  char v2; // dl\n  _DWORD *v3; // ebx\n  int v4; // esi\n\n  result = dword_80DBBA0;\n  v2 = *((_BYTE *)dword_80DBBA0 + 68);\n  if ( v2 )\n  {\n    v3 = (_DWORD *)dword_80DBB7C;\n    v4 = *(_DWORD *)dword_80DBB7C;\n    sub_80AE5A2(a1, v2);\n    result = (void *)sub_804DD8F();\n    *v3 = v4;\n  }\n  else\n  {\n    ++*((_DWORD *)dword_80DBBA0 + 16);\n  }\n  return result;\n}\n"
    ],
    "sub_80AE606": [
        "0x80ae606",
        "unsigned int __usercall sub_80AE606@<eax>(unsigned int result@<eax>)\n{\n  _BYTE *v1; // ebx\n  int v2; // esi\n  char *v3; // edx\n  _BYTE *v4; // eax\n  _BYTE *v5; // ecx\n\n  v1 = dword_80DBBA0;\n  v2 = *((_DWORD *)dword_80DBBA0 + 5);\n  if ( *((_DWORD *)dword_80DBBA0 + 6) != v2 )\n  {\n    if ( result )\n    {\n      v3 = (char *)dword_80DBBA0 + 76;\n      if ( *((_BYTE *)dword_80DBBA0 + 69) )\n      {\n        *((_DWORD *)dword_80DBBA0 + 18) = v3;\n        v1[69] = 0;\n      }\n      v4 = (_BYTE *)*((_DWORD *)v1 + 18);\n      v5 = (_BYTE *)(v2 + *((_DWORD *)v1 + 8));\n      if ( v4 - v3 <= 127 )\n      {\n        *((_DWORD *)v1 + 18) = v4 + 1;\n        *v4 = *v5;\n      }\n    }\n    memmove((void *)(v2 + *((_DWORD *)v1 + 8)), (const void *)(*((_DWORD *)v1 + 8) + v2 + 1), *((_DWORD *)v1 + 6) - v2);\n    --*((_DWORD *)v1 + 6);\n    sub_80AE52A();\n    printf(\"\\x1B[J\");\n    return sub_80ADB4F(*((_DWORD *)v1 + 5) - v2);\n  }\n  return result;\n}\n"
    ],
    "sub_80AE682": [
        "0x80ae682",
        "void *sub_80AE682()\n{\n  void *result; // eax\n\n  result = dword_80DBBA0;\n  if ( *((_DWORD *)dword_80DBBA0 + 5) )\n  {\n    sub_80ADB4F(1u);\n    return (void *)sub_80AE606(0);\n  }\n  return result;\n}\n"
    ],
    "sub_80AE69F": [
        "0x80ae69f",
        "size_t __usercall sub_80AE69F@<eax>(int a1@<eax>)\n{\n  const char **v1; // ebx\n\n  v1 = (const char **)dword_80DBBA0;\n  sub_80B2C4E(*((_DWORD *)dword_80DBBA0 + 7), a1);\n  return strlen(v1[8]);\n}\n"
    ],
    "sub_80AE6BE": [
        "0x80ae6be",
        "_BYTE *__usercall sub_80AE6BE@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // esi\n  size_t v2; // eax\n  _BYTE *v3; // edi\n  int v4; // ebx\n  char v6; // [esp+1h] [ebp-11h]\n\n  v1 = a1;\n  v2 = strlen(a1);\n  v3 = sub_804DB2E(2 * (v2 + 1));\n  v4 = 0;\n  while ( *v1 )\n  {\n    v6 = *v1;\n    if ( strchr(\" `\\\"#$%^&*()=+{}[]:;'|\\\\<>\", *(unsigned __int8 *)v1) )\n      v3[v4++] = 92;\n    ++v1;\n    v3[v4++] = v6;\n  }\n  return v3;\n}\n"
    ],
    "sub_80AE715": [
        "0x80ae715",
        "size_t __usercall sub_80AE715@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // eax\n  void **v3; // edi\n  _BYTE *v4; // esi\n  char *v5; // ebx\n  const char *v6; // edx\n  int i; // esi\n  char *v8; // eax\n  char *v9; // eax\n  int j; // ebx\n  char *v11; // eax\n  char *v12; // ebx\n  _BYTE *v13; // eax\n  char *v14; // ebp\n  char v15; // dl\n  int v16; // ecx\n  void *v17; // ebx\n  _BYTE *k; // edx\n  _DWORD *v19; // ebp\n  int v20; // eax\n  int v21; // edx\n  char *s; // [esp+0h] [ebp-90h]\n  const char **v24; // [esp+4h] [ebp-8Ch]\n  DIR *dirp; // [esp+8h] [ebp-88h]\n  const char **v27; // [esp+10h] [ebp-80h]\n  size_t v28; // [esp+14h] [ebp-7Ch]\n  size_t v29; // [esp+18h] [ebp-78h]\n  _BYTE *v30; // [esp+1Ch] [ebp-74h] BYREF\n  int v31; // [esp+30h] [ebp-60h]\n\n  s = (char *)a1;\n  v30 = \"<<...\" + 4;\n  v2 = strrchr(a1, 47);\n  if ( v2 )\n  {\n    v12 = v2 + 1;\n    v4 = sub_804DB5D(s, v2 + 1 - s);\n    v30 = v4;\n    s = v12;\n    v3 = (void **)&v30;\n  }\n  else\n  {\n    if ( !a2 )\n    {\n      v5 = (**(_BYTE **)dword_80DBBA0 & 0x10) != 0 ? *(char **)(*(_DWORD *)dword_80DBBA0 + 8) : getenv(\"PATH\");\n      if ( v5 && *v5 && (*v5 != 58 || v5[1]) )\n      {\n        v6 = v5;\n        for ( i = 1; ; ++i )\n        {\n          v8 = strchr(v6, 58);\n          if ( !v8 )\n            break;\n          v6 = v8 + 1;\n          if ( !v8[1] )\n            break;\n        }\n        v3 = (void **)sub_804DAFA(4 * i);\n        v9 = sub_804DB46(v5);\n        *v3 = v9;\n        for ( j = 1; ; v3[j - 1] = v9 )\n        {\n          v11 = strchr(v9, 58);\n          v4 = v11;\n          if ( !v11 )\n            break;\n          v9 = v11 + 1;\n          *v4 = 0;\n          if ( !v4[1] )\n          {\n            v4 = 0;\n            goto LABEL_22;\n          }\n          ++j;\n        }\n        goto LABEL_22;\n      }\n    }\n    v3 = (void **)&v30;\n    v4 = 0;\n  }\n  j = 1;\nLABEL_22:\n  v28 = strlen(s);\n  v24 = (const char **)v3;\n  v27 = (const char **)&v3[j];\n  do\n  {\n    dirp = opendir(*v24);\n    if ( !dirp )\n      goto LABEL_44;\n    while ( 1 )\n    {\n      v13 = (_BYTE *)readdir64();\n      if ( !v13 )\n        break;\n      v14 = v13 + 19;\n      if ( !*s && v13[19] == 46 )\n      {\n        v15 = v13[20];\n        if ( !v15 || v15 == 46 && !v13[21] )\n          continue;\n      }\n      if ( sub_804D210(v13 + 19, s) )\n      {\n        v17 = (void *)sub_804D2D1((int)*v24, v14, v16);\n        if ( stat64() && lstat64() )\n          goto LABEL_42;\n        v29 = strlen(v14);\n        v17 = sub_804DB13(v17, v29 + 2);\n        strcpy((char *)v17, v14);\n        if ( (v31 & 0xF000) == 0x4000 )\n        {\n          *((_BYTE *)v17 + v29) = 47;\n          *((_BYTE *)v17 + v29 + 1) = 0;\nLABEL_37:\n          for ( k = v17; *k; ++k )\n          {\n            if ( (unsigned __int8)(*k - 32) > 0x5Eu )\n              goto LABEL_42;\n          }\n          v19 = dword_80DBBA0;\n          v20 = sub_80B4733(*((_DWORD *)dword_80DBBA0 + 14), 1028);\n          v19[13] = v20;\n          v21 = v19[14];\n          *(_DWORD *)(v20 + 4 * v21) = v17;\n          v19[14] = v21 + 1;\n        }\n        else\n        {\n          if ( a2 != 1 )\n            goto LABEL_37;\nLABEL_42:\n          free(v17);\n        }\n      }\n    }\n    closedir(dirp);\nLABEL_44:\n    ++v24;\n  }\n  while ( v27 != v24 );\n  if ( v3 != (void **)&v30 )\n  {\n    free(*v3);\n    free(v3);\n  }\n  free(v4);\n  return v28;\n}\n"
    ],
    "sub_80AE98C": [
        "0x80ae98c",
        "int __usercall sub_80AE98C@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  _BYTE *v4; // ebx\n  int result; // eax\n  int v6; // [esp+0h] [ebp-Ch]\n\n  sub_804DD8F();\n  v4 = dword_80DBBA0;\n  *((_BYTE *)dword_80DBBA0 + 68) = 1;\n  result = sub_80B20CC(a2, a1, v6);\n  v4[68] = 0;\n  return result;\n}\n"
    ],
    "sub_80AE9B5": [
        "0x80ae9b5",
        "_BYTE *__usercall sub_80AE9B5@<eax>(_BYTE *result@<eax>)\n{\n  void *v1; // ebx\n  signed int v2; // edi\n  int k; // esi\n  signed int v4; // eax\n  int v5; // esi\n  int m; // edi\n  int v7; // edx\n  const char *v8; // ecx\n  int v9; // edx\n  size_t v10; // eax\n  char *v11; // esi\n  int v12; // ebp\n  char *v13; // ebp\n  unsigned __int8 *v14; // edi\n  void *v15; // eax\n  unsigned int i; // edi\n  int v17; // ebp\n  int v18; // ecx\n  const char *v19; // edx\n  const char **v20; // eax\n  char *v21; // edi\n  char *v22; // eax\n  const char *v23; // ebp\n  size_t v24; // ecx\n  size_t v25; // eax\n  size_t v26; // eax\n  int v27; // [esp-4h] [ebp-3Ch]\n  size_t v28; // [esp+4h] [ebp-34h]\n  int v29; // [esp+4h] [ebp-34h]\n  signed int v30; // [esp+8h] [ebp-30h]\n  int v31; // [esp+8h] [ebp-30h]\n  unsigned int j; // [esp+8h] [ebp-30h]\n  size_t v33; // [esp+8h] [ebp-30h]\n  _BYTE *v34; // [esp+Ch] [ebp-2Ch]\n  int v35; // [esp+Ch] [ebp-2Ch]\n  int v36; // [esp+10h] [ebp-28h]\n  int n; // [esp+14h] [ebp-24h]\n  void *v38; // [esp+18h] [ebp-20h]\n  char *v39; // [esp+18h] [ebp-20h]\n  const char *ptr; // [esp+20h] [ebp-18h]\n  int v41; // [esp+24h] [ebp-14h]\n\n  v1 = dword_80DBBA0;\n  if ( (**(_BYTE **)dword_80DBBA0 & 2) == 0 )\n    return result;\n  v34 = result;\n  if ( !*result )\n  {\n    *result = 1;\n    v11 = (char *)sub_804DAFA(0x800u);\n    sub_80B2C4E(*((_DWORD *)v1 + 5) + 1, *((_DWORD *)v1 + 8));\n    v12 = sub_80AD916((int)v11);\n    sub_80ADCC2();\n    if ( !*((_DWORD *)v1 + 13) )\n      v28 = sub_80AE715(v11, v12);\n    v13 = &v11[strlen(v11)];\n    v14 = (unsigned __int8 *)&v13[-v28];\n    while ( v14 < (unsigned __int8 *)v13 )\n    {\n      if ( strchr(\" `\\\"#$%^&*()=+{}[]:;'|\\\\<>\", *v14++) )\n        ++v28;\n    }\n    v15 = (void *)*((_DWORD *)v1 + 13);\n    if ( v15 )\n    {\n      sub_80A9A96(v15, *((_DWORD *)v1 + 14));\n      v31 = 0;\n      for ( i = 0; ; ++i )\n      {\n        v17 = *((_DWORD *)v1 + 13);\n        v18 = 4 * i;\n        v19 = *(const char **)(v17 + 4 * i);\n        if ( *((_DWORD *)v1 + 14) - 1 <= i )\n          break;\n        v39 = (char *)v19;\n        if ( !strcmp(v19, *(const char **)(v17 + v18 + 4)) )\n          free(v39);\n        else\n          *(_DWORD *)(v17 + 4 * v31++) = v39;\n      }\n      *(_DWORD *)(v17 + 4 * v31) = v19;\n      *((_DWORD *)v1 + 14) = v31 + 1;\n    }\n    if ( *((_DWORD *)v1 + 14) == 1 )\n    {\n      *v34 = 0;\n      v21 = sub_80AE6BE(**((const char ***)v1 + 13));\n      v25 = strlen(v21);\n      v24 = v25;\n      if ( v21[v25 - 1] != 47 )\n      {\n        v21[v25] = 32;\n        v21[v25 + 1] = 0;\n        v24 = v25 + 1;\n      }\n    }\n    else\n    {\n      sub_80ADB45();\n      v20 = (const char **)*((_DWORD *)v1 + 13);\n      v21 = 0;\n      if ( !v20 )\n        goto LABEL_49;\n      v22 = sub_804DB46(*v20);\n      v21 = v22;\n      while ( *v22 )\n      {\n        for ( j = 1; *((_DWORD *)v1 + 14) > j; ++j )\n        {\n          if ( *(_BYTE *)(*(_DWORD *)(*((_DWORD *)v1 + 13) + 4 * j) + v22 - v21) != *v22 )\n            goto LABEL_43;\n        }\n        ++v22;\n      }\nLABEL_43:\n      if ( v22 == v21 )\n        goto LABEL_49;\n      *v22 = 0;\n      v23 = sub_80AE6BE(v21);\n      free(v21);\n      v24 = strlen(v23);\n      v21 = (char *)v23;\n    }\n    if ( (signed int)(v24 + *((_DWORD *)v1 + 6) - v28) < *((_DWORD *)v1 + 7) )\n    {\n      v33 = v24;\n      strcpy(v11, (const char *)(*((_DWORD *)v1 + 8) + *((_DWORD *)v1 + 5)));\n      sprintf((char *)(*((_DWORD *)v1 + 8) + *((_DWORD *)v1 + 5)), \"%s%s\", &v21[v28], v11);\n      v26 = strlen(*((const char **)v1 + 8));\n      *((_DWORD *)v1 + 6) = v26;\n      sub_80AE560(*((_DWORD *)v1 + 3), v26 - (*((_DWORD *)v1 + 5) + v33 - v28), 0);\n    }\nLABEL_49:\n    free(v21);\n    free(v11);\n    return (_BYTE *)v27;\n  }\n  if ( *((_DWORD *)dword_80DBBA0 + 14) )\n  {\n    v38 = (void *)*((_DWORD *)dword_80DBBA0 + 5);\n    sub_80AE53F();\n    v29 = *((_DWORD *)v1 + 14);\n    v2 = 0;\n    for ( k = 0; v29 > k; ++k )\n    {\n      v4 = strlen(*(const char **)(*((_DWORD *)v1 + 13) + 4 * k));\n      if ( v2 < v4 )\n        v2 = v4;\n    }\n    v36 = v2 + 2;\n    v30 = *((_DWORD *)v1 + 1) / (unsigned int)(v2 + 2);\n    if ( v30 <= 1 )\n    {\n      v5 = v29;\n      v30 = 1;\n    }\n    else\n    {\n      v5 = v29 / v30;\n      if ( v29 % v30 )\n        ++v5;\n    }\n    for ( m = 0; v5 > m; ++m )\n    {\n      v7 = 4 * m;\n      v35 = m;\n      for ( n = 1; ; ++n )\n      {\n        v8 = *(const char **)(*((_DWORD *)v1 + 13) + v7);\n        if ( n == v30 )\n          break;\n        v35 += v5;\n        v9 = 4 * v5 + v7;\n        if ( v29 <= v35 )\n          break;\n        v41 = v9;\n        ptr = v8;\n        v10 = strlen(v8);\n        printf(\"%s%-*s\", ptr, v36 - v10, &data);\n        v7 = v41;\n      }\n      puts(v8);\n    }\n    return (_BYTE *)sub_80AE560(0, *((_DWORD *)v1 + 6) - (_DWORD)v38, 1);\n  }\n  return result;\n}\n"
    ],
    "sub_80AED15": [
        "0x80aed15",
        "_DWORD *__usercall sub_80AED15@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0xFC0u);\n  *result = a1;\n  result[1] = -1;\n  result[5] = 999;\n  return result;\n}\n"
    ],
    "sub_80AED34": [
        "0x80aed34",
        "int __usercall sub_80AED34@<eax>(int result@<eax>)\n{\n  int v1; // esi\n  int i; // ebx\n\n  if ( result )\n  {\n    v1 = result;\n    for ( i = 0; *(_DWORD *)(v1 + 12) > i; ++i )\n      result = printf(\"%4d %s\\n\", i, *(const char **)(v1 + 4 * i + 32));\n  }\n  return result;\n}\n"
    ],
    "sub_80AED5C": [
        "0x80aed5c",
        "size_t __userpurge sub_80AED5C@<eax>(int a1@<eax>, char *a2@<edx>, char *a3@<ecx>, int a4)\n{\n  char *v6; // ebp\n  int v7; // ecx\n  size_t v8; // ebx\n  _DWORD *v9; // eax\n  __uid_t v10; // eax\n  struct passwd *v11; // eax\n  int v12; // edx\n  struct passwd *v13; // ebx\n  int v14; // edx\n  int v15; // ecx\n  int v16; // eax\n  int v17; // ebx\n  bool v18; // zf\n  bool v19; // zf\n  bool v20; // zf\n  unsigned int v21; // eax\n  int v22; // eax\n  const char *v23; // eax\n  int v24; // eax\n  unsigned __int8 v25; // al\n  int v26; // eax\n  int v27; // eax\n  unsigned __int8 v28; // al\n  int v29; // ebx\n  unsigned int v30; // ebx\n  unsigned int v31; // ebx\n  char *v32; // eax\n  size_t v33; // ebx\n  int v34; // eax\n  int v35; // edx\n  int v36; // esi\n  const char *v37; // edi\n  char *v38; // eax\n  unsigned int v39; // eax\n  int v40; // eax\n  int v41; // ebx\n  unsigned int v42; // esi\n  unsigned int v43; // esi\n  int v44; // ebx\n  int v45; // eax\n  int v46; // edx\n  int v47; // edi\n  int v48; // esi\n  int v49; // eax\n  int v50; // esi\n  int v51; // ebx\n  int v52; // eax\n  int v53; // edx\n  int v54; // ecx\n  int v55; // eax\n  int i; // edx\n  int v57; // edi\n  _DWORD *v58; // eax\n  int v59; // esi\n  size_t v60; // eax\n  char *v61; // edi\n  size_t v62; // ebx\n  int *v63; // eax\n  int v64; // edi\n  _DWORD *v65; // ebx\n  int v66; // eax\n  int v67; // ecx\n  __pid_t v68; // eax\n  char *v69; // esi\n  FILE *v70; // edi\n  int j; // esi\n  int v72; // edx\n  int v74; // [esp-4h] [ebp-15Ch]\n  int v75; // [esp+0h] [ebp-158h]\n  char v76; // [esp+0h] [ebp-158h]\n  int v77; // [esp+0h] [ebp-158h]\n  char *v78; // [esp+0h] [ebp-158h]\n  char v80; // [esp+8h] [ebp-150h]\n  int v81; // [esp+8h] [ebp-150h]\n  int v82; // [esp+Ch] [ebp-14Ch]\n  int v83; // [esp+10h] [ebp-148h]\n  int v84; // [esp+14h] [ebp-144h]\n  int v85; // [esp+18h] [ebp-140h]\n  unsigned int v86; // [esp+18h] [ebp-140h]\n  const void *v87; // [esp+20h] [ebp-138h]\n  int v88; // [esp+24h] [ebp-134h]\n  int v89; // [esp+28h] [ebp-130h]\n  char v90; // [esp+2Fh] [ebp-129h] BYREF\n  char v91[16]; // [esp+30h] [ebp-128h] BYREF\n  char v92[16]; // [esp+40h] [ebp-118h] BYREF\n  struct termios termios_p; // [esp+50h] [ebp-108h] BYREF\n  struct termios v94; // [esp+8Ch] [ebp-CCh] BYREF\n  char needle[144]; // [esp+C8h] [ebp-90h] BYREF\n\n  v90 = 0;\n  v6 = (char *)sub_804DB2E(0xE0u);\n  dword_80DBBA0 = v6;\n  *((_DWORD *)v6 + 1) = 80;\n  *((_DWORD *)v6 + 12) = &unk_80D8FD5;\n  v87 = v6 + 76;\n  *((_DWORD *)v6 + 18) = v6 + 76;\n  v83 = sub_804D9A3(&termios_p, 0, &v94, 1);\n  if ( v83 || (termios_p.c_lflag & 0xA) == 2 )\n  {\n    sub_80ADF54(a2);\n    sub_804DD8F();\n    v8 = -1;\n    if ( fgets_unlocked() )\n      v8 = strlen(a3);\n    goto LABEL_277;\n  }\n  v84 = a4;\n  if ( a4 > 1024 )\n    v84 = 1024;\n  *((_DWORD *)v6 + 7) = v84;\n  *(_DWORD *)v6 = &unk_80B75C4;\n  v82 = -1;\n  if ( a1 )\n  {\n    *(_DWORD *)v6 = a1;\n    v82 = *(_DWORD *)(a1 + 4);\n  }\n  v9 = *(_DWORD **)v6;\n  if ( *(_DWORD *)(*(_DWORD *)v6 + 28) && !v9[3] )\n    sub_80ADD2B(v9, v7);\n  if ( (**(_BYTE **)v6 & 1) != 0 )\n    *(_DWORD *)(*(_DWORD *)v6 + 16) = *(_DWORD *)(*(_DWORD *)v6 + 12);\n  *((_DWORD *)v6 + 3) = 0;\n  *((_DWORD *)v6 + 6) = 0;\n  *((_DWORD *)v6 + 8) = a3;\n  *a3 = 0;\n  sub_804D995(&v94);\n  v10 = geteuid();\n  v11 = getpwuid(v10);\n  v13 = v11;\n  if ( v11 )\n  {\n    *((_DWORD *)v6 + 11) = sub_804DB46(v11->pw_name);\n    *((_DWORD *)v6 + 12) = sub_804DB46(v13->pw_dir);\n  }\n  *((_DWORD *)v6 + 1) = sub_804D986(0, v12);\n  sub_80ADF54(a2);\n  *((_DWORD *)v6 + 51) = sub_80AE5D9;\n  *((_DWORD *)v6 + 52) = 0x10000000;\n  sigaction(28, (const struct sigaction *)(v6 + 204), (struct sigaction *)(v6 + 204));\n  v91[0] = 0;\n  v80 = 0;\n  while ( 1 )\n  {\n    v16 = *((_DWORD *)v6 + 16);\n    if ( *((_DWORD *)v6 + 15) != v16 )\n    {\n      *((_DWORD *)v6 + 15) = v16;\n      sub_80AE5A2(v15, v14);\n    }\n    v75 = sub_80AE98C((int)v91, v82);\nLABEL_20:\n    v6[69] = 1;\n    v17 = v75;\n    if ( v80 )\n      v17 = v75 | 0x40000000;\n    if ( v17 == 1073741834 )\n      break;\n    if ( v17 > 1073741834 )\n    {\n      if ( v17 == 1073741911 )\n      {\n        sub_80AE394((_BYTE *)1);\n        goto LABEL_246;\n      }\n      if ( v17 > 1073741911 )\n      {\n        if ( v17 == 1073741929 )\n          goto LABEL_245;\n        if ( v17 > 1073741929 )\n        {\n          if ( v17 == 1073741936 )\n          {\n            sub_80AE2D8();\n            goto LABEL_214;\n          }\n          if ( v17 <= 1073741936 )\n          {\n            if ( v17 != 1073741931 )\n            {\n              if ( v17 >= 1073741931 )\n              {\n                if ( v17 == 1073741932 )\n                {\nLABEL_226:\n                  sub_80AE2D8();\n                  goto LABEL_246;\n                }\n                goto LABEL_230;\n              }\n              goto LABEL_128;\n            }\n            goto LABEL_132;\n          }\n          if ( v17 == 1073741943 )\n          {\n            sub_80AE2EB(1);\n            goto LABEL_246;\n          }\n          if ( v17 > 1073741943 )\n          {\n            if ( v17 == 1073741944 )\n              goto LABEL_176;\n            v20 = v17 == 1073741951;\n            goto LABEL_106;\n          }\n          if ( v17 != 1073741938 )\n            goto LABEL_230;\n          v45 = sub_80AE98C((int)v91, v82);\n          if ( *(_DWORD *)dword_80DBB7C )\n            goto LABEL_237;\n          if ( (unsigned int)(v45 - 32) > 0xDF )\n          {\nLABEL_222:\n            sub_80ADB45();\n            goto LABEL_246;\n          }\n          *(_BYTE *)(*((_DWORD *)v6 + 8) + *((_DWORD *)v6 + 5)) = v45;\n          sub_804DD98(v45);\n          sub_804DD98(8);\n        }\n        else\n        {\n          if ( v17 == 1073741923 )\n          {\n            v80 = 0;\nLABEL_185:\n            v40 = sub_80AE98C((int)v91, v82);\n            v14 = dword_80DBB7C;\n            if ( *(_DWORD *)dword_80DBB7C )\n              goto LABEL_237;\n            v41 = *((_DWORD *)v6 + 5);\n            if ( v75 == v40 )\n            {\n              sub_80ADB4F(*((_DWORD *)v6 + 5));\nLABEL_211:\n              while ( *((_DWORD *)v6 + 5) < *((_DWORD *)v6 + 6) )\n                sub_80AE606(1u);\n              goto LABEL_246;\n            }\n            v42 = *((_DWORD *)v6 + 5);\n            if ( v40 == 69 )\n            {\n              sub_80AE486();\nLABEL_201:\n              sub_80AE2D8();\n              goto LABEL_204;\n            }\n            if ( v40 > 69 )\n            {\n              if ( v40 == 98 )\n              {\n                sub_80ADE14();\nLABEL_209:\n                while ( *((_DWORD *)v6 + 5) < v42 )\n                {\n                  sub_80AE606(1u);\n                  --v42;\n                }\n                goto LABEL_246;\n              }\n              if ( v40 > 98 )\n              {\n                if ( v40 == 101 )\n                {\n                  sub_80AE3E6();\n                  goto LABEL_201;\n                }\n                if ( v40 == 119 )\n                {\n                  sub_80AE2EB(v80);\nLABEL_204:\n                  v43 = *((_DWORD *)v6 + 5);\n                  sub_80ADB4F(v43 - v41);\n                  while ( *((_DWORD *)v6 + 5) < v43 )\n                  {\n                    sub_80AE606(1u);\n                    --v43;\n                  }\n                  goto LABEL_246;\n                }\n              }\n              else if ( v40 == 87 )\n              {\n                sub_80AE394((_BYTE *)v80);\n                goto LABEL_204;\n              }\n            }\n            else\n            {\n              switch ( v40 )\n              {\n                case '$':\n                  goto LABEL_211;\n                case 'B':\n                  sub_80ADBDF();\n                  goto LABEL_209;\n                case ' ':\n                  goto LABEL_176;\n              }\n            }\n            goto LABEL_246;\n          }\n          if ( v17 > 1073741923 )\n          {\n            if ( v17 == 1073741925 )\n            {\n              sub_80AE3E6();\n              goto LABEL_246;\n            }\n            if ( v17 >= 1073741925 )\n            {\n              v20 = v17 == 1073741928;\n              goto LABEL_106;\n            }\n            goto LABEL_185;\n          }\n          if ( v17 == 1073741921 )\n          {\n            sub_80AE2D8();\n            goto LABEL_245;\n          }\n          if ( v17 > 1073741921 )\n          {\n            sub_80ADE14();\n            goto LABEL_246;\n          }\n          if ( v17 != 1073741912 )\n            goto LABEL_230;\n          if ( *((_DWORD *)v6 + 5) )\n          {\n            sub_80ADB4F(1u);\nLABEL_176:\n            v39 = 1;\n            goto LABEL_177;\n          }\n        }\n      }\n      else\n      {\n        if ( v17 == 1073741860 )\n        {\nLABEL_229:\n          sub_80AE52A();\n          goto LABEL_246;\n        }\n        if ( v17 > 1073741860 )\n        {\n          if ( v17 == 1073741891 )\n          {\n            v80 = 0;\n            goto LABEL_211;\n          }\n          if ( v17 <= 1073741891 )\n          {\n            if ( v17 == 1073741889 )\n            {\n              sub_80AE52A();\n              goto LABEL_245;\n            }\n            if ( v17 > 1073741889 )\n            {\n              sub_80ADBDF();\n              goto LABEL_246;\n            }\n            v19 = v17 == 1073741872;\n            goto LABEL_88;\n          }\n          if ( v17 == 1073741893 )\n          {\n            sub_80AE486();\n            goto LABEL_246;\n          }\n          if ( v17 < 1073741893 )\n            goto LABEL_211;\n          if ( v17 == 1073741897 )\n          {\n            sub_80ADB4F(*((_DWORD *)v6 + 5));\nLABEL_245:\n            v80 = 0;\n            goto LABEL_246;\n          }\n          if ( v17 != 1073741904 )\n            goto LABEL_230;\nLABEL_214:\n          v86 = *((_DWORD *)v6 + 18) - (_DWORD)v87;\n          if ( !v86 )\n            goto LABEL_246;\n          v44 = *((_DWORD *)v6 + 5);\n          memmove(\n            (void *)(v44 + v86 + *((_DWORD *)v6 + 8)),\n            (const void *)(*((_DWORD *)v6 + 8) + v44),\n            *((_DWORD *)v6 + 6) - v44 + 1);\n          qmemcpy((void *)(*((_DWORD *)v6 + 8) + *((_DWORD *)v6 + 5)), v87, v86);\n          *((_DWORD *)v6 + 6) += v86;\n          sub_80AE52A();\n          v21 = *((_DWORD *)v6 + 5) + 1 - v44 - v86;\n          goto LABEL_123;\n        }\n        if ( v17 == 1073741840 )\n          goto LABEL_132;\n        if ( v17 <= 1073741840 )\n        {\n          if ( v17 == 1073741837 )\n            break;\n          if ( v17 != 1073741838 )\n          {\n            if ( v17 == 1073741836 )\n              goto LABEL_127;\n            goto LABEL_230;\n          }\nLABEL_128:\n          v22 = sub_80ADC93();\nLABEL_129:\n          if ( !v22 )\n            goto LABEL_246;\nLABEL_130:\n          v23 = *(const char **)(*(_DWORD *)v6 + 4 * *(_DWORD *)(*(_DWORD *)v6 + 16) + 32);\n          if ( !v23 )\n            v23 = &data;\n          *((_DWORD *)v6 + 6) = sub_80AE69F((int)v23);\n          v46 = **(_DWORD **)v6 & 8;\n          if ( v46 )\n            v46 = 9999;\n          sub_80AE560(*((_DWORD *)v6 + 3), v46, 0);\n          goto LABEL_246;\n        }\n        if ( v17 != 1073741847 )\n        {\n          if ( v17 == 1073741856 )\n            goto LABEL_226;\n          if ( v17 != 1073741845 )\n            goto LABEL_230;\nLABEL_133:\n          v14 = *((_DWORD *)v6 + 5);\n          if ( v14 )\n          {\n            v24 = *((_DWORD *)v6 + 6) - v14;\n            *((_DWORD *)v6 + 6) = v24;\n            memmove(*((void **)v6 + 8), (const void *)(*((_DWORD *)v6 + 8) + v14), v24 + 1);\n            sub_80AE560(*((_DWORD *)v6 + 3), *((_DWORD *)v6 + 6), 0);\n          }\n          goto LABEL_246;\n        }\nLABEL_137:\n        while ( 1 )\n        {\n          v26 = *((_DWORD *)v6 + 5);\n          if ( !v26 )\n            break;\n          v14 = *((_DWORD *)v6 + 8);\n          v25 = *(_BYTE *)(v14 + v26 - 1) - 9;\n          if ( v25 != 23 && v25 > 4u )\n          {\n            while ( 1 )\n            {\n              v27 = *((_DWORD *)v6 + 5);\n              if ( !v27 )\n                break;\n              v14 = *((_DWORD *)v6 + 8);\n              v28 = *(_BYTE *)(v14 + v27 - 1) - 9;\n              if ( v28 == 23 || v28 <= 4u )\n                break;\n              sub_80AE682();\n            }\n            break;\n          }\n          sub_80AE682();\n        }\n      }\n    }\n    else\n    {\n      if ( v17 == 2 )\n        goto LABEL_122;\n      if ( v17 > 2 )\n      {\n        if ( v17 == 13 )\n          break;\n        if ( v17 > 13 )\n        {\n          if ( v17 == 21 )\n            goto LABEL_133;\n          if ( v17 <= 21 )\n          {\n            if ( v17 != 16 )\n            {\n              if ( v17 == 18 )\n              {\n                v92[0] = 0;\n                needle[0] = 0;\n                v88 = *((_DWORD *)v6 + 10);\n                v89 = *((_DWORD *)v6 + 4);\n                v85 = 0;\nLABEL_151:\n                v32 = sub_804DDBF(\"(reverse-i-search)'%s': \", needle);\n                *((_DWORD *)v6 + 10) = v32;\n                *((_DWORD *)v6 + 4) = strlen(v32);\n                sub_80AE560(*((_DWORD *)v6 + 3), *((_DWORD *)v6 + 6) - *((_DWORD *)v6 + 5), 0);\nLABEL_152:\n                v33 = strlen(needle);\n                v34 = sub_80AE98C((int)v92, v82);\n                v75 = v34;\n                if ( v34 != 18 )\n                {\n                  if ( v34 == 127 || v34 == 8 )\n                  {\n                    if ( v33 )\n                      --v33;\n                    needle[v33] = 0;\n                  }\n                  else\n                  {\n                    if ( (unsigned int)(v34 - 32) > 0xDF )\n                    {\n                      if ( v85 )\n                        *((_DWORD *)v6 + 6) = sub_80AE69F(v85);\n                      free(*((void **)v6 + 10));\n                      *((_DWORD *)v6 + 10) = v88;\n                      *((_DWORD *)v6 + 4) = v89;\n                      sub_80AE560(*((_DWORD *)v6 + 3), *((_DWORD *)v6 + 6) - *((_DWORD *)v6 + 5), 0);\n                      v15 = v74;\n                      goto LABEL_20;\n                    }\n                    if ( v33 <= 0x7E )\n                    {\n                      needle[v33] = v34;\n                      needle[v33 + 1] = 0;\n                    }\n                  }\n                }\n                v35 = *(_DWORD *)v6;\n                v36 = *(_DWORD *)(*(_DWORD *)v6 + 16);\n                if ( v34 != 18 )\n                  goto LABEL_163;\n                while ( 1 )\n                {\n                  --v36;\nLABEL_163:\n                  if ( v36 < 0 )\n                  {\n                    needle[v33] = 0;\n                    sub_80ADB45();\n                    goto LABEL_152;\n                  }\n                  v37 = *(const char **)(v35 + 4 * v36 + 32);\n                  if ( v37 )\n                  {\n                    v77 = v35;\n                    v38 = strstr(v37, needle);\n                    v35 = v77;\n                    if ( v38 )\n                    {\n                      v78 = v38;\n                      *(_DWORD *)(v35 + 16) = v36;\n                      *((_DWORD *)v6 + 6) = sub_80AE69F((int)v37);\n                      *((_DWORD *)v6 + 5) = v78 - v37;\n                      free(*((void **)v6 + 10));\n                      v85 = (int)v37;\n                      goto LABEL_151;\n                    }\n                  }\n                }\n              }\n              if ( v17 != 14 )\n                goto LABEL_230;\n              goto LABEL_128;\n            }\nLABEL_132:\n            v22 = sub_80ADC64();\n            goto LABEL_129;\n          }\n          if ( v17 != 27 )\n          {\n            if ( v17 <= 27 )\n            {\n              if ( v17 == 23 )\n                goto LABEL_137;\n              goto LABEL_230;\n            }\n            if ( v17 == 127 )\n              goto LABEL_124;\n            v20 = v17 == 1073741832;\nLABEL_106:\n            if ( !v20 )\n              goto LABEL_230;\n            goto LABEL_122;\n          }\n          if ( (**(_BYTE **)v6 & 8) != 0 )\n          {\n            sub_80ADB4F(1u);\n            v80 = 1;\n          }\n        }\n        else\n        {\n          if ( v17 == 9 )\n          {\n            sub_80AE9B5(&v90);\n            goto LABEL_246;\n          }\n          if ( v17 <= 9 )\n          {\n            switch ( v17 )\n            {\n              case 6:\n                goto LABEL_226;\n              case 8:\nLABEL_124:\n                sub_80AE682();\n                goto LABEL_246;\n              case 5:\n                goto LABEL_229;\n            }\nLABEL_230:\n            if ( termios_p.c_cc[0] && termios_p.c_cc[0] == v75 )\n            {\n              *((_DWORD *)v6 + 6) = 0;\nLABEL_238:\n              v76 = -1;\n              goto LABEL_248;\n            }\n            if ( termios_p.c_cc[4] && termios_p.c_cc[4] == v75 )\n            {\n              if ( !*((_DWORD *)v6 + 6) )\n              {\n                *(_DWORD *)dword_80DBB7C = 0;\nLABEL_237:\n                *((_DWORD *)v6 + 6) = -1;\n                goto LABEL_238;\n              }\nLABEL_239:\n              v39 = 0;\nLABEL_177:\n              sub_80AE606(v39);\n              goto LABEL_246;\n            }\n            if ( (unsigned int)(v17 - 32) > 0xDF )\n              goto LABEL_246;\n            v47 = *((_DWORD *)v6 + 6);\n            if ( v47 >= v84 - 2 )\n              goto LABEL_246;\n            *((_DWORD *)v6 + 6) = v47 + 1;\n            v48 = *((_DWORD *)v6 + 5);\n            v49 = *((_DWORD *)v6 + 8);\n            if ( v48 == v47 )\n            {\n              *(_BYTE *)(v49 + v48) = v17;\n              *(_BYTE *)(*((_DWORD *)v6 + 8) + *((_DWORD *)v6 + 5) + 1) = 0;\n              sub_80AE287();\n              goto LABEL_246;\n            }\n            memmove((void *)(v48 + 1 + v49), (const void *)(v49 + v48), v47 + 1 - v48);\n            *(_BYTE *)(*((_DWORD *)v6 + 8) + v48) = v17;\n            sub_80AE52A();\n            v21 = *((_DWORD *)v6 + 5) - (v48 + 1);\nLABEL_123:\n            sub_80ADB4F(v21);\n            goto LABEL_246;\n          }\n          if ( v17 != 11 )\n          {\n            if ( v17 <= 11 )\n              break;\nLABEL_127:\n            printf(\"\\x1B[H\\x1B[J\");\n            sub_80AE560(0, *((_DWORD *)v6 + 6) - *((_DWORD *)v6 + 5), 1);\n            goto LABEL_246;\n          }\n          *(_BYTE *)(*((_DWORD *)v6 + 8) + *((_DWORD *)v6 + 5)) = 0;\n          *((_DWORD *)v6 + 6) = *((_DWORD *)v6 + 5);\n          printf(\"\\x1B[J\");\n        }\n      }\n      else\n      {\n        if ( v17 == -7 )\n          goto LABEL_229;\n        if ( v17 > -7 )\n        {\n          if ( v17 == -3 )\n            goto LABEL_128;\n          if ( v17 <= -3 )\n          {\n            if ( v17 != -5 )\n            {\n              if ( v17 > -5 )\n                goto LABEL_226;\n              goto LABEL_228;\n            }\nLABEL_122:\n            v21 = 1;\n            goto LABEL_123;\n          }\n          if ( v17 == -1 )\n            goto LABEL_237;\n          if ( v17 >= -1 )\n          {\n            v19 = v17 == 1;\nLABEL_88:\n            if ( !v19 )\n              goto LABEL_230;\nLABEL_228:\n            v21 = *((_DWORD *)v6 + 5);\n            goto LABEL_123;\n          }\n          if ( !sub_80ADC64() )\n            goto LABEL_222;\n          goto LABEL_130;\n        }\n        if ( v17 == -44 )\n        {\n          v31 = *((_DWORD *)v6 + 5);\n          sub_80ADEB4();\n          while ( *((_DWORD *)v6 + 5) < v31 )\n          {\n            sub_80AE606(1u);\n            --v31;\n          }\n          goto LABEL_246;\n        }\n        if ( v17 > -44 )\n        {\n          if ( v17 == -36 )\n          {\nLABEL_227:\n            sub_80AE4D0();\n            goto LABEL_246;\n          }\n          if ( v17 == -9 )\n            goto LABEL_239;\n          v18 = v17 == -37;\n        }\n        else\n        {\n          if ( v17 == -68 )\n            goto LABEL_227;\n          if ( v17 == -45 )\n          {\n            v29 = *((_DWORD *)v6 + 5);\n            sub_80AE4D0();\n            v30 = *((_DWORD *)v6 + 5) - v29;\n            sub_80ADB4F(v30);\n            while ( (--v30 & 0x80000000) == 0 )\n              sub_80AE606(1u);\n            goto LABEL_246;\n          }\n          v18 = v17 == -69;\n        }\n        if ( !v18 )\n          goto LABEL_230;\n        sub_80ADEB4();\n      }\n    }\nLABEL_246:\n    if ( v75 != 9 )\n      v90 = 0;\n  }\n  sub_80AE53F();\n  v76 = 1;\nLABEL_248:\n  if ( *((int *)v6 + 6) > 0 )\n  {\n    v50 = *(_DWORD *)v6;\n    if ( (**(_BYTE **)v6 & 1) != 0 )\n    {\n      if ( *a3 )\n      {\n        v51 = *(_DWORD *)(v50 + 12);\n        if ( !v51 || strcmp(*(const char **)(v50 + 4 * v51 + 28), a3) )\n        {\n          free(*(void **)(v50 + 4 * *(_DWORD *)(v50 + 20) + 32));\n          v52 = *(_DWORD *)v6;\n          v53 = *(_DWORD *)(*(_DWORD *)v6 + 20);\n          *(_DWORD *)(*(_DWORD *)v6 + 4 * v53 + 32) = 0;\n          if ( v51 >= v53 )\n          {\n            free(*(void **)(v52 + 32));\n            v54 = *(_DWORD *)v6;\n            v55 = *(_DWORD *)(*(_DWORD *)v6 + 20);\n            for ( i = 0; v55 - 1 > i; ++i )\n              *(_DWORD *)(v54 + 4 * i + 32) = *(_DWORD *)(v54 + 4 * i + 36);\n            if ( v55 <= 0 )\n              v55 = 1;\n            v51 = v55 - 1;\n          }\n          v57 = *(_DWORD *)v6;\n          *(_DWORD *)(v57 + 4 * v51 + 32) = sub_804DB46(a3);\n          v58 = *(_DWORD **)v6;\n          v58[4] = v51 + 1;\n          v58[3] = v51 + 1;\n          if ( v58[7] )\n          {\n            v59 = open64();\n            if ( v59 >= 0 )\n            {\n              sub_804DD09(0, 0, 2);\n              v60 = strlen(a3);\n              v61 = &a3[v60];\n              a3[v60] = 10;\n              v62 = v60 + 1;\n              v81 = sub_804E586(v60 + 1, a3);\n              *v61 = 0;\n              close(v59);\n              if ( v62 == v81 )\n              {\n                v63 = *(int **)v6;\n                v64 = *(_DWORD *)(*(_DWORD *)v6 + 24);\n                v63[6] = v64 + 1;\n                if ( v64 + 1 > (unsigned int)(4 * v63[5]) )\n                {\n                  v65 = sub_80AED15(*v63);\n                  v66 = *(_DWORD *)v6;\n                  v65[7] = *(_DWORD *)(*(_DWORD *)v6 + 28);\n                  v65[5] = *(_DWORD *)(v66 + 20);\n                  sub_80ADD2B(v65, v67);\n                  v68 = getpid();\n                  v69 = sub_804DDBF(\"%s.%u.new\", *(const char **)(*(_DWORD *)v6 + 28), v68);\n                  if ( open64() >= 0 )\n                  {\n                    v70 = (FILE *)sub_80B3D6E();\n                    while ( v83 < v65[3] )\n                      fprintf(v70, \"%s\\n\", (const char *)v65[v83++ + 8]);\n                    fclose(v70);\n                    if ( !rename(v69, *(const char **)(*(_DWORD *)v6 + 28)) )\n                      *(_DWORD *)(*(_DWORD *)v6 + 24) = v65[3];\n                  }\n                  free(v69);\n                  for ( j = v65[3]; j > 0; free((void *)v65[j + 8]) )\n                    --j;\n                  free(v65);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if ( v76 == 1 )\n  {\n    v72 = *((_DWORD *)v6 + 6);\n    *((_DWORD *)v6 + 6) = v72 + 1;\n    a3[v72] = 10;\n    a3[v72 + 1] = 0;\n  }\n  sub_80ADCC2();\n  sub_804D995(&termios_p);\n  sub_804E698(28, (const struct sigaction *)(v6 + 204));\n  sub_804DD8F();\n  v8 = *((_DWORD *)v6 + 6);\nLABEL_277:\n  sub_80ADCF8();\n  return v8;\n}\n"
    ],
    "sub_80AFAC3": [
        "0x80afac3",
        "_DWORD *__usercall sub_80AFAC3@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DAFA(8u);\n  result[1] = a2;\n  *result = *a1;\n  *a1 = result;\n  return result;\n}\n"
    ],
    "sub_80AFADF": [
        "0x80afadf",
        "_DWORD *__usercall sub_80AFADF@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *result; // eax\n\n  while ( *a1 )\n    a1 = (_DWORD *)*a1;\n  result = sub_804DB2E(8u);\n  *a1 = result;\n  result[1] = a2;\n  return result;\n}\n"
    ],
    "sub_80AFB01": [
        "0x80afb01",
        "int __usercall sub_80AFB01@<eax>(_DWORD **a1@<eax>)\n{\n  _DWORD *v1; // edx\n  int v2; // ebx\n\n  v1 = *a1;\n  v2 = 0;\n  if ( *a1 )\n  {\n    v2 = v1[1];\n    *a1 = (_DWORD *)*v1;\n    free(v1);\n  }\n  return v2;\n}\n"
    ],
    "sub_80AFB1E": [
        "0x80afb1e",
        "_DWORD *__usercall sub_80AFB1E@<eax>(_DWORD *result@<eax>, _DWORD *a2@<edx>)\n{\n  if ( a2 )\n  {\n    while ( *result )\n    {\n      if ( (_DWORD *)*result == a2 )\n      {\n        *result = *a2;\n        return result;\n      }\n      result = (_DWORD *)*result;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AFB36": [
        "0x80afb36",
        "int __usercall sub_80AFB36@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(int)@<edx>)\n{\n  int v3; // eax\n  _DWORD *v5; // [esp+0h] [ebp-8h] BYREF\n\n  v5 = a1;\n  while ( v5 )\n  {\n    v3 = sub_80AFB01(&v5);\n    if ( a2 )\n      a2(v3);\n  }\n  return 0;\n}\n"
    ],
    "sub_80AFB57": [
        "0x80afb57",
        "int __usercall sub_80AFB57@<eax>(int a1@<eax>)\n{\n  unsigned __int64 v1; // rax\n  unsigned int v2; // ecx\n\n  HIDWORD(v1) = a1;\n  LODWORD(v1) = 0;\n  while ( HIDWORD(v1) )\n  {\n    v2 = *(_DWORD *)HIDWORD(v1);\n    *(_DWORD *)HIDWORD(v1) = v1;\n    v1 = __PAIR64__(v2, HIDWORD(v1));\n  }\n  return v1;\n}\n"
    ],
    "sub_80AFB6A": [
        "0x80afb6a",
        "int **__usercall sub_80AFB6A@<eax>(int **a1@<eax>, const char *a2@<edx>)\n{\n  while ( a1 && strcmp((const char *)a1[1], a2) )\n    a1 = (int **)*a1;\n  return a1;\n}\n"
    ],
    "sub_80AFB8C": [
        "0x80afb8c",
        "int __usercall sub_80AFB8C@<eax>(time_t a1@<eax>)\n{\n  int v2; // ecx\n  int result; // eax\n  FILE *v4; // esi\n  char *IO_write_base; // eax\n  int v6; // eax\n  char *v7; // eax\n  int v8; // eax\n  bool v9; // zf\n  struct tm *v10; // eax\n  FILE *v11; // [esp-4h] [ebp-29Ch]\n  int v12; // [esp-4h] [ebp-29Ch]\n  time_t v13; // [esp+0h] [ebp-298h] BYREF\n  char s; // [esp+5h] [ebp-293h] BYREF\n  __int16 v15; // [esp+6h] [ebp-292h]\n  struct utsname name; // [esp+106h] [ebp-192h] BYREF\n\n  time(&v13);\n  uname(&name);\n  puts(\"\\r\");\n  result = sub_80B3D37(v2);\n  v4 = (FILE *)result;\n  if ( result )\n  {\n    while ( 1 )\n    {\n      IO_write_base = v4->_IO_write_base;\n      if ( IO_write_base >= v4->_IO_write_end )\n      {\n        v6 = __fgetc_unlocked();\n        if ( v6 == -1 )\n        {\n          fclose(v4);\n          sub_804DD8F();\n          return v12;\n        }\n      }\n      else\n      {\n        v4->_IO_write_base = IO_write_base + 1;\n        v6 = (unsigned __int8)*IO_write_base;\n      }\n      s = v6;\n      LOBYTE(v15) = 0;\n      if ( v6 == 10 )\n      {\n        v15 = 13;\n        goto LABEL_35;\n      }\n      if ( v6 != 92 && v6 != 37 )\n        goto LABEL_35;\n      v7 = v4->_IO_write_base;\n      if ( v7 >= v4->_IO_write_end )\n      {\n        v8 = __fgetc_unlocked();\n      }\n      else\n      {\n        v4->_IO_write_base = v7 + 1;\n        v8 = (unsigned __int8)*v7;\n      }\n      if ( v8 == 109 )\n        goto LABEL_35;\n      if ( v8 > 109 )\n      {\n        if ( v8 == 114 )\n          goto LABEL_35;\n        if ( v8 <= 114 )\n        {\n          if ( v8 == 110 )\n            goto LABEL_35;\n          v9 = v8 == 111;\nLABEL_25:\n          if ( !v9 )\n            goto LABEL_34;\n          goto LABEL_35;\n        }\n        if ( v8 == 116 )\n        {\n          sub_804EB80(&v13, 0x101u, &s, a1);\n          goto LABEL_35;\n        }\n        if ( v8 >= 116 && v8 != 118 )\n          goto LABEL_34;\n      }\n      else\n      {\n        if ( v8 == 83 )\n          goto LABEL_35;\n        if ( v8 <= 83 )\n        {\n          if ( v8 == 68 )\n            goto LABEL_35;\n          v9 = v8 == 79;\n          goto LABEL_25;\n        }\n        if ( v8 != 104 && v8 != 108 )\n        {\n          if ( v8 == 100 )\n          {\n            v10 = localtime(&v13);\n            strftime(&s, 0x101u, \"%A, %d %B %Y\", v10);\n            goto LABEL_35;\n          }\nLABEL_34:\n          s = v8;\n        }\n      }\nLABEL_35:\n      v11 = stdout;\n      fputs_unlocked();\n      a1 = (time_t)v11;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80AFD20": [
        "0x80afd20",
        "void sub_80AFD20()\n{\n  void *v0; // ebx\n\n  v0 = (void *)sub_80B2BD8();\n  fputs_unlocked();\n  fputs_unlocked();\n  sub_804DD8F();\n  free(v0);\n}\n"
    ],
    "sub_80AFD54": [
        "0x80afd54",
        "int sub_80AFD54()\n{\n  __uid_t v0; // ebx\n  __uid_t v1; // eax\n  int v2; // edx\n  const char *v3; // ebx\n\n  v0 = getuid();\n  v1 = geteuid();\n  v2 = 0;\n  if ( v0 != v1 )\n  {\n    v3 = \"ENV\";\n    do\n    {\n      unsetenv(v3);\n      v3 += strlen(v3) + 1;\n    }\n    while ( *v3 );\n    putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\");\n    return 1;\n  }\n  return v2;\n}\n"
    ],
    "sub_80AFD97": [
        "0x80afd97",
        "char *sub_80AFD97()\n{\n  int v0; // eax\n  char *v1; // ebx\n  int v2; // esi\n  _QWORD v4[7]; // [esp+0h] [ebp-F0h] BYREF\n  char v5[184]; // [esp+38h] [ebp-B8h] BYREF\n\n  v0 = open64();\n  v1 = 0;\n  if ( v0 >= 0 )\n  {\n    v2 = v0;\n    v1 = 0;\n    if ( !ioctl(v0, 0x4C05u, v4) )\n      v1 = sub_804DDBF(\"%llu %s\", v4[3], v5);\n    close(v2);\n  }\n  return v1;\n}\n"
    ],
    "sub_80AFDF4": [
        "0x80afdf4",
        "int sub_80AFDF4()\n{\n  int v0; // eax\n  int v1; // esi\n  int v2; // ebx\n\n  v0 = open64();\n  v1 = 1;\n  if ( v0 >= 0 )\n  {\n    v2 = v0;\n    v1 = ioctl(v0, 0x4C01u, 0);\n    close(v2);\n  }\n  return v1;\n}\n"
    ],
    "sub_80AFE28": [
        "0x80afe28",
        "int __userpurge sub_80AFE28@<eax>(char **a1@<eax>, int a2@<edx>, int a3, int a4, int a5)\n{\n  int i; // ebp\n  int v6; // ebx\n  int v7; // esi\n  _DWORD *v8; // edi\n  __dev_t v9; // rax\n  char *v11; // [esp+0h] [ebp-188h]\n  int v12; // [esp+4h] [ebp-184h]\n  int fd; // [esp+Ch] [ebp-17Ch]\n  char s[23]; // [esp+19h] [ebp-16Fh] BYREF\n  int v17; // [esp+40h] [ebp-148h]\n  int v18[62]; // [esp+90h] [ebp-F8h] BYREF\n\n  for ( i = (a5 & 1) == 0 ? 2 : 0; ; i = 0 )\n  {\n    fd = open64();\n    if ( fd >= 0 )\n      break;\n    if ( !i )\n      return -*(_DWORD *)dword_80DBB7C;\n  }\n  v11 = *a1;\n  if ( !*a1 )\n    v11 = s;\n  v7 = -1;\n  v6 = -1;\n  v12 = 0;\n  while ( 1 )\n  {\n    sprintf(s, \"/dev/loop%u\", v12);\n    v8 = (_DWORD *)dword_80DBB7C;\n    *(_DWORD *)dword_80DBB7C = 0;\n    if ( stat64() || (v17 & 0xF000) != 24576 )\n    {\n      if ( *v8 != 2 )\n        break;\n      if ( v11 != s )\n        break;\n      v9 = sub_80B0220(s, v12);\n      if ( mknod(s, 0x61A4u, v9) )\n        break;\n    }\n    v6 = open64();\n    if ( v6 >= 0 || *v8 == 30 && (v6 = open64(), v6 >= 0) )\n    {\n      v7 = ioctl(v6, 0x4C05u, v18);\n      if ( v7 && *v8 == 6 )\n      {\n        if ( !ioctl(v6, 0x4C00u, fd) )\n        {\n          memset(v18, 0, 0xE8u);\n          sub_80B2C4E(64, a2);\n          v18[6] = a3;\n          v18[7] = a4;\n          v18[13] = a5 & 0xFFFFFFFE;\n          v7 = ioctl(v6, 0x4C04u, v18);\n          if ( !v7 )\n            goto LABEL_30;\n          if ( (v18[13] & 4) != 0 )\n          {\n            v18[13] -= 4;\n            v7 = ioctl(v6, 0x4C04u, v18);\n            if ( !v7 )\n              goto LABEL_30;\n          }\n          ioctl(v6, 0x4C01u, 0);\n        }\n      }\n      else\n      {\n        v7 = -1;\n      }\n      close(v6);\n    }\n    else if ( *v8 == 6 )\n    {\n      break;\n    }\nLABEL_30:\n    if ( !*a1 )\n    {\n      ++v12;\n      if ( v7 )\n      {\n        if ( v12 != 0x100000 )\n          continue;\n      }\n    }\n    goto LABEL_35;\n  }\n  v7 = -1;\nLABEL_35:\n  close(fd);\n  if ( v7 )\n    return v7;\n  if ( !*a1 )\n    *a1 = sub_804DB46(s);\n  return v6;\n}\n"
    ],
    "sub_80B00B9": [
        "0x80b00b9",
        "int __usercall sub_80B00B9@<eax>(char *a1@<eax>, __mode_t a2@<edx>, int a3@<ecx>)\n{\n  int v4; // edi\n  char *v5; // edi\n  __mode_t v6; // ebx\n  unsigned int v7; // ebp\n  char v8; // al\n  const char *v9; // eax\n  char v11; // [esp+3h] [ebp-7Dh]\n  __int16 v14; // [esp+20h] [ebp-60h]\n\n  if ( (unsigned __int8)(*a1 - 46) <= 1u )\n  {\n    v4 = 0;\n    if ( !a1[1] )\n      return v4;\n  }\n  v5 = a1;\n  v6 = -1;\n  v7 = -1;\n  while ( 1 )\n  {\n    if ( (a3 & 4) != 0 )\n    {\n      while ( *v5 )\n      {\n        if ( *v5 == 47 )\n        {\n          do\n          {\n            v8 = *++v5;\n            v11 = *v5;\n          }\n          while ( *v5 == 47 );\n          *v5 = 0;\n          if ( !v8 )\n            break;\n          if ( v7 == -1 )\n          {\n            v6 = umask(0);\n            v7 = v6 & 0xFFFFFF3F;\n            if ( (v6 & 0xFFFFFF3F) != 0 )\n              umask(v6 & 0xFFFFFF3F);\n          }\n          goto LABEL_16;\n        }\n        ++v5;\n      }\n    }\n    v11 = 0;\n    if ( v7 != v6 )\n    {\n      umask(v6);\n      v7 = v6;\n    }\nLABEL_16:\n    if ( mkdir(a1, 0x1FFu) >= 0 )\n      break;\n    if ( (*(_DWORD *)dword_80DBB7C & 0xFFFFFFFB) != 17 || (a3 & 4) == 0 || stat64() < 0 || (v14 & 0xF000) != 0x4000 )\n    {\n      v9 = \"create\";\n      v4 = -1;\n      goto LABEL_31;\n    }\n    if ( !v11 )\n      goto LABEL_22;\nLABEL_29:\n    *v5 = v11;\n  }\n  if ( (a3 & 0x1000) != 0 )\n    printf(\"created directory: '%s'\\n\", a1);\n  if ( v11 )\n    goto LABEL_29;\n  if ( a2 == -1 || chmod(a1, a2) >= 0 )\n  {\nLABEL_22:\n    v4 = 0;\n    goto LABEL_32;\n  }\n  v4 = ~a3 >> 31;\n  v9 = \"set permissions of\";\nLABEL_31:\n  sub_804D3A5((int)\"can't %s directory '%s'\", v9, a1);\nLABEL_32:\n  if ( v7 != v6 )\n    umask(v6);\n  return v4;\n}\n"
    ],
    "sub_80B0220": [
        "0x80b0220",
        "unsigned __int64 __usercall sub_80B0220@<edx:eax>(unsigned int a1@<eax>, unsigned int a2@<edx>)\n{\n  return gnu_dev_makedev(a1, a2);\n}\n"
    ],
    "sub_80B0232": [
        "0x80b0232",
        "int __usercall sub_80B0232@<eax>(_BYTE *a1@<eax>, char *a2@<edx>)\n{\n  int v2; // esi\n  char *v4; // ebx\n  char *v5; // eax\n  char v6; // al\n  char *v7; // eax\n\n  v2 = 1;\n  if ( a2 )\n  {\n    v4 = a2;\n    v2 = 1;\n    if ( *a2 == 110 && a2[1] == 111 )\n    {\n      v4 = a2 + 2;\n      v2 = 0;\n    }\n    while ( 1 )\n    {\n      v5 = sub_804D210(v4, a1);\n      if ( v5 )\n      {\n        v6 = *v5;\n        if ( !v6 || v6 == 44 )\n          break;\n      }\n      v7 = strchr(v4, 44);\n      if ( !v7 )\n        return v2 ^ 1;\n      v4 = v7 + 1;\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_80B028A": [
        "0x80b028a",
        "char *__usercall sub_80B028A@<eax>(int a1@<eax>)\n{\n  int v1; // edi\n  int v2; // ecx\n  char *v3; // ebx\n  char v4; // si\n  int i; // edx\n\n  byte_80DB740 = byte_80D90DC[(unsigned __int16)a1 >> 12];\n  v1 = 256;\n  v2 = 0;\n  v3 = &byte_80DB740;\n  do\n  {\n    v4 = 0;\n    for ( i = 0; i != 3; ++i )\n    {\n      v3[i + 1] = 45;\n      if ( (v1 & a1) != 0 )\n      {\n        v3[i + 1] = byte_80D90D5[i];\n        v4 = i;\n      }\n      v1 >>= 1;\n    }\n    v3 += 3;\n    if ( ((4096 >> ++v2) & a1) != 0 )\n      *v3 = byte_80D90D8[(v4 & 2) + (v2 == 3)];\n  }\n  while ( v2 != 3 );\n  return &byte_80DB740;\n}\n"
    ],
    "sub_80B030A": [
        "0x80b030a",
        "_BYTE *__usercall sub_80B030A@<eax>(_BYTE *result@<eax>)\n{\n  if ( result )\n  {\n    while ( *result )\n      *result++ = 0;\n  }\n  return result;\n}\n"
    ],
    "sub_80B031C": [
        "0x80b031c",
        "// positive sp value has been detected, the output may be wrong!\n_BOOL4 __usercall sub_80B031C@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return strcasestr(a2, a1) || strcasestr(a1, a2) != 0;\n}\n"
    ],
    "sub_80B034A": [
        "0x80b034a",
        "int __usercall sub_80B034A@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  _BOOL4 v4; // esi\n  char *v5; // ebp\n  char *v6; // ecx\n  signed int i; // edx\n  signed int v8; // edx\n  char *v9; // ebp\n  int v10; // esi\n  signed int v12; // [esp+0h] [ebp-14h]\n\n  v4 = sub_80B031C((int)a1, a2);\n  v5 = sub_804DB46(a1);\n  v12 = strlen(a1);\n  v6 = v5;\n  for ( i = v12; --i >= 0; *(v6 - 1) = a1[i] )\n    ++v6;\n  v8 = v12;\n  if ( v12 < 0 )\n    v8 = 0;\n  v9 = &v5[v8 - v12];\n  v10 = sub_80B031C((int)v9, a2) || v4;\n  sub_80B030A(v9);\n  free(v9);\n  return v10;\n}\n"
    ],
    "sub_80B03AD": [
        "0x80b03ad",
        "int __usercall sub_80B03AD@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, int *a3@<ecx>)\n{\n  _BYTE *v5; // edx\n  void *v6; // ebx\n  int v7; // ebp\n  int v8; // ebx\n  unsigned int v9; // edx\n  const char *v10; // eax\n  char v11; // al\n  const char *v12; // ecx\n  int v13; // edi\n  char *v14; // eax\n  int v15; // edi\n  unsigned int v16; // ecx\n  int v17; // eax\n  size_t v19; // [esp+0h] [ebp-20h]\n  int c; // [esp+8h] [ebp-18h]\n  unsigned int v22; // [esp+Ch] [ebp-14h]\n\n  if ( !a2 || (v19 = strlen(a2), v19 <= 5) )\n  {\n    v10 = \"too short\";\n    goto LABEL_35;\n  }\n  if ( sub_80B034A(a2, *a3) )\n  {\n    v10 = \"similar to username\";\n    goto LABEL_35;\n  }\n  v5 = (_BYTE *)a3[4];\n  if ( *v5 && sub_80B034A(a2, (int)v5) )\n  {\n    v10 = \"similar to gecos\";\nLABEL_35:\n    printf(\"Bad password: %s\\n\", v10);\n    return 1;\n  }\n  v6 = (void *)sub_80B2BD8();\n  v7 = sub_80B034A(a2, (int)v6);\n  free(v6);\n  if ( v7 )\n  {\n    v10 = \"similar to hostname\";\n    goto LABEL_35;\n  }\n  v8 = 0;\n  v9 = 0;\n  do\n  {\n    v11 = a2[v9];\n    if ( (unsigned __int8)(v11 - 97) > 0x19u )\n    {\n      if ( (unsigned __int8)(v11 - 65) > 0x19u )\n      {\n        if ( (unsigned __int8)(v11 - 48) > 9u )\n          v8 |= 8u;\n        else\n          v8 |= 4u;\n      }\n      else\n      {\n        v8 |= 2u;\n      }\n    }\n    else\n    {\n      v8 |= 1u;\n    }\n    v12 = a2;\n    v13 = 0;\n    c = (unsigned __int8)a2[v9];\n    do\n    {\n      v22 = v9;\n      v14 = strchr(v12, c);\n      v9 = v22;\n      if ( !v14 )\n        break;\n      ++v13;\n      v12 = v14 + 1;\n    }\n    while ( v14[1] );\n    if ( v19 <= 2 * v13 )\n    {\n      v10 = \"too many similar characters\";\n      goto LABEL_35;\n    }\n    v9 = v22 + 1;\n  }\n  while ( v19 != v22 + 1 );\n  v15 = 4;\n  v16 = 14;\n  v17 = 1;\n  do\n  {\n    if ( (v17 & v8) != 0 )\n      v16 -= 2;\n    v17 *= 2;\n    --v15;\n  }\n  while ( v15 );\n  if ( v9 < v16 )\n  {\n    v10 = \"too weak\";\n    goto LABEL_35;\n  }\n  if ( a1 && *a1 && sub_80B034A(a2, (int)a1) )\n  {\n    v10 = \"similar to old password\";\n    goto LABEL_35;\n  }\n  return v7;\n}\n"
    ],
    "sub_80B0511": [
        "0x80b0511",
        "_DWORD *__fastcall sub_80B0511(int a1, int (__fastcall *a2)(int, _DWORD))\n{\n  int v2; // eax\n  int v3; // ebx\n  _DWORD *result; // eax\n\n  v2 = a2(a1, a2);\n  if ( !v2 )\n    return 0;\n  v3 = v2;\n  result = sub_804DB2E(0x1Cu);\n  *result = v3;\n  return result;\n}\n"
    ],
    "sub_80B052C": [
        "0x80b052c",
        "_DWORD *__fastcall sub_80B052C(int a1)\n{\n  return sub_80B0511(a1, (int (__fastcall *)(int, _DWORD))sub_80B3D76);\n}\n"
    ],
    "sub_80B0536": [
        "0x80b0536",
        "void __usercall sub_80B0536(int a1@<eax>)\n{\n  if ( a1 )\n  {\n    fclose(*(FILE **)a1);\n    free(*(void **)(a1 + 8));\n    free(*(void **)(a1 + 12));\n    free((void *)a1);\n  }\n}\n"
    ],
    "sub_80B0560": [
        "0x80b0560",
        "int __userpurge sub_80B0560@<eax>(int a1@<eax>, void *a2@<edx>, int a3@<ecx>, char *reject)\n{\n  int v5; // eax\n  unsigned int v6; // ecx\n  int v7; // esi\n  char *v8; // ebx\n  int v9; // eax\n  size_t v10; // edx\n  const char *v11; // edi\n  size_t v12; // eax\n  const char *v13; // eax\n  char v14; // al\n  int v15; // ebx\n  int v16; // esi\n  const char *v17; // eax\n  const char *v18; // ecx\n  char *v19; // eax\n  char v20; // al\n  unsigned int v22; // [esp-8h] [ebp-3Ch]\n  int v24; // [esp+4h] [ebp-30h]\n  char v25; // [esp+Bh] [ebp-29h]\n  int v26; // [esp+Ch] [ebp-28h]\n  unsigned int v28; // [esp+14h] [ebp-20h]\n  int v29; // [esp+18h] [ebp-1Ch]\n  int v30; // [esp+1Ch] [ebp-18h]\n  const char *v31; // [esp+20h] [ebp-14h]\n\n  if ( !a1 )\n    return 0;\n  v25 = 0;\n  if ( (a3 & 0x800000) != 0 )\n    v25 = *reject++;\n  v24 = (unsigned __int8)a3;\n  v26 = BYTE1(a3);\n  v28 = 4 * (unsigned __int8)a3;\n  while ( 1 )\n  {\n    do\n    {\n      memset(a2, 0, v28);\n      v5 = getline();\n      v7 = v5;\n      if ( v5 <= 0 )\n      {\n        if ( v5 )\n          return 0;\n      }\n      else\n      {\n        v8 = *(char **)(a1 + 8);\n        while ( 1 )\n        {\n          ++*(_DWORD *)(a1 + 24);\n          if ( v8[v7 - 1] == 10 && !--v7 )\n            break;\n          if ( v8[v7 - 1] != 92 )\n            break;\n          --v7;\n          v9 = getline();\n          v6 = v9;\n          if ( v9 <= 0 )\n            break;\n          v29 = v7 + v9;\n          v10 = v7 + v9 + 1;\n          if ( *(_DWORD *)(a1 + 16) < v10 )\n          {\n            v30 = v9;\n            *(_DWORD *)(a1 + 16) = v10;\n            v8 = (char *)sub_804DB13(v8, v10);\n            *(_DWORD *)(a1 + 8) = v8;\n            v6 = v30;\n          }\n          qmemcpy(&v8[v7], *(const void **)(a1 + 12), v6);\n          v6 = 0;\n          v7 = v29;\n        }\n        v8[v7] = 0;\n      }\n      v11 = *(const char **)(a1 + 8);\n      if ( (a3 & 0x20000) != 0 )\n      {\n        v12 = strspn(v11, reject + 1);\n        v6 = v22;\n        v11 += v12;\n      }\n      v13 = v11;\n      if ( (a3 & 0x1000000) != 0 )\n        v13 = (const char *)sub_80B2E8C(v6, a3);\n      v14 = *v13;\n    }\n    while ( !v14 || *reject == v14 || v14 == v25 );\n    v15 = 0;\n    v16 = a3 & 0x400000;\n    do\n    {\n      *((_DWORD *)a2 + v15) = v11;\n      if ( v24 - 1 == v15 && (a3 & 0x40000) != 0 )\n      {\n        v11 = (const char *)strchrnul();\n        if ( (a3 & 0x20000) != 0 )\n        {\n          v18 = reject + 1;\n          while ( 1 )\n          {\n            v31 = v18;\n            v19 = strchr(v18, *((unsigned __int8 *)v11 - 1));\n            v18 = v31;\n            if ( !v19 )\n              break;\n            --v11;\n          }\n        }\n      }\n      else\n      {\n        v17 = reject;\n        if ( !*reject || !v16 )\n          v17 = reject + 1;\n        v11 += strcspn(v11, v17);\n      }\n      v20 = *v11;\n      if ( v16 && *reject == v20 )\n      {\n        *v11 = 0;\n      }\n      else if ( v20 )\n      {\n        *v11++ = 0;\n      }\n      if ( (a3 & 0x10000) != 0 )\n        v11 += strspn(v11, reject + 1);\n      ++v15;\n    }\n    while ( *v11 && *reject != *v11 && v24 > v15 );\n    if ( v26 <= v15 )\n      break;\n    sub_804D5F4(\"bad line %u: %d tokens found, %d needed\", *(_DWORD *)(a1 + 24), v15, v26);\n    if ( (a3 & 0x100000) != 0 )\n      sub_804D604();\n  }\n  return v15;\n}\n"
    ],
    "sub_80B07AF": [
        "0x80b07af",
        "unsigned int __usercall sub_80B07AF@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *v2; // ebx\n  unsigned int result; // eax\n  int v5; // edx\n  const char *v6; // eax\n  _BYTE *v7; // eax\n  int v8; // eax\n  int v9; // edi\n  char v10; // al\n  const char *v11; // ebp\n  int v12; // ebp\n  __mode_t v13; // ebp\n  int v14; // edi\n  char v15; // [esp+3h] [ebp-1Dh]\n  int v16; // [esp+4h] [ebp-1Ch]\n  char *endptr; // [esp+Ch] [ebp-14h] BYREF\n\n  v2 = a1;\n  if ( (unsigned __int8)(*a1 - 48) > 7u )\n  {\nLABEL_12:\n    while ( *v2 )\n    {\n      if ( *v2 == 44 )\n      {\n        ++v2;\n      }\n      else\n      {\n        v5 = 0;\nLABEL_6:\n        v6 = \"augo\";\n        do\n        {\n          if ( *v6 == *v2 )\n          {\n            v5 |= dword_80B84E8[v6 - \"augo\"];\n            if ( *++v2 )\n              goto LABEL_6;\n            return -1;\n          }\n          ++v6;\n        }\n        while ( *v6 );\n        v16 = -4096;\n        if ( v5 )\n          v16 = ~v5;\n        while ( 2 )\n        {\n          v15 = *v2;\n          if ( ((*v2 - 43) & 0xFD) != 0 )\n          {\n            if ( v15 != 61 )\n              return -1;\n            a2 &= v16;\n          }\n          v7 = \"augo\" + 1;\n          while ( *v7 != v2[1] )\n          {\n            if ( !*++v7 )\n            {\n              ++v2;\n              v9 = 0;\n              do\n              {\n                v10 = *v2;\n                v11 = \"rwxXst\";\n                while ( *v11 != v10 )\n                {\n                  if ( !*++v11 )\n                    goto LABEL_39;\n                }\n                if ( v10 != 88 || (a2 & 0x4049) != 0 )\n                  v9 |= dword_80B84D0[v11 - \"rwxXst\"];\n                ++v2;\n              }\n              while ( *v2 );\n              if ( !v9 )\n                goto LABEL_12;\n              goto LABEL_40;\n            }\n          }\n          v8 = a2 & dword_80B84E8[v7 - \"augo\"];\n          v9 = v8 & 0x1FF;\n          if ( (v8 & 0x124) != 0 )\n            v9 |= 0x124u;\n          if ( (v9 & 0x92) != 0 )\n            v9 |= 0x92u;\n          if ( (v9 & 0x49) != 0 )\n            v9 |= 0x49u;\n          v2 += 2;\nLABEL_39:\n          if ( v9 )\n          {\nLABEL_40:\n            v12 = v5;\n            if ( !v5 )\n            {\n              v13 = umask(0);\n              umask(v13);\n              v12 = ~v13;\n              v5 = 0;\n            }\n            v14 = v12 & v9;\n            if ( v15 == 45 )\n              a2 &= ~v14;\n            else\n              a2 |= v14;\n          }\n          if ( *v2 != 44 && *v2 )\n            continue;\n          break;\n        }\n      }\n    }\n    return a2;\n  }\n  else\n  {\n    result = strtoul(a1, &endptr, 8);\n    if ( *endptr || result > 0xFFF )\n      return -1;\n  }\n  return result;\n}\n"
    ],
    "sub_80B0948": [
        "0x80b0948",
        "char *__usercall sub_80B0948@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *result; // eax\n  char *v4; // ebx\n  char *i; // edi\n  char v6; // cl\n  unsigned int v7; // ecx\n  int v8; // ecx\n  unsigned int v9; // esi\n  unsigned int v10; // ecx\n  int v11; // esi\n  unsigned int v12; // ecx\n  char *v13; // [esp+0h] [ebp-1Ch]\n  int v14; // [esp+4h] [ebp-18h]\n\n  result = a1 + 1;\n  v4 = result;\n  for ( i = a1; ; i = v13 )\n  {\n    v13 = i + 1;\n    v6 = *i;\n    if ( !*i )\n    {\n      *(v4 - 1) = 0;\n      return a1;\n    }\n    if ( v6 == 43 && !a2 )\n    {\n      *(v4 - 1) = 32;\n      goto LABEL_18;\n    }\n    if ( v6 != 37 )\n    {\n      *(v4 - 1) = v6;\n      goto LABEL_18;\n    }\n    v7 = (unsigned __int8)i[1] - 48;\n    if ( v7 > 9 )\n    {\n      v8 = (unsigned __int8)i[1] | 0x20;\n      v9 = v8 - 97;\n      v7 = v8 - 87;\n      if ( v9 > 5 )\n        break;\n    }\n    v14 = 16 * v7;\n    v10 = (unsigned __int8)i[2] - 48;\n    if ( v10 > 9 )\n    {\n      v11 = (unsigned __int8)i[2] | 0x20;\n      v10 = -1;\n      if ( (unsigned int)(v11 - 97) <= 5 )\n        v10 = v11 - 87;\n    }\n    v12 = v14 | v10;\n    if ( v12 > 0xFF )\n      break;\n    if ( a2 && (v12 == 47 || !v12) )\n      return result;\n    *(v4 - 1) = v12;\n    v13 = i + 3;\nLABEL_18:\n    ++v4;\n  }\n  if ( !a2 )\n  {\n    *(v4 - 1) = 37;\n    goto LABEL_18;\n  }\n  return 0;\n}\n"
    ],
    "sub_80B0A23": [
        "0x80b0a23",
        "void __noreturn sub_80B0A23()\n{\n  sub_804D3C9(0);\n}\n"
    ],
    "sub_80B0A2C": [
        "0x80b0a2c",
        "int __usercall sub_80B0A2C@<eax>(int result@<eax>)\n{\n  int v1; // ebx\n  unsigned int v2; // eax\n  _BYTE *v3; // eax\n  int v4; // [esp-6h] [ebp-7Ch]\n  char v5[30]; // [esp+0h] [ebp-76h] BYREF\n  __int16 v6; // [esp+1Eh] [ebp-58h]\n\n  if ( result )\n  {\n    result = open64();\n    v1 = result;\n    if ( result >= 0 )\n    {\n      if ( fstat64() || (v6 & 0xF000) != 0x8000 )\n      {\n        byte_80DBBA7 = 0;\n      }\n      else\n      {\n        byte_80DBBA7 = 1;\n        v2 = getpid();\n        v3 = sub_804D68B(v2, v5, 14);\n        *v3 = 10;\n        sub_804E586(v3 - v5 + 1, v5);\n      }\n      close(v1);\n      return v4;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80B0AB7": [
        "0x80b0ab7",
        "int __userpurge sub_80B0AB7@<eax>(_DWORD *a1@<eax>, const char *a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  const char *v7; // edi\n\n  v7 = 0;\n  while ( *a2 )\n  {\n    if ( (a3 & *a1) != 0 )\n    {\n      if ( !v7 )\n        v7 = &data;\n      printf(\"%s%s\", v7, a2);\n      a3 &= ~*a1;\n      v7 = a4;\n    }\n    ++a1;\n    a2 += strlen(a2) + 1;\n  }\n  return a3;\n}\n"
    ],
    "sub_80B0B09": [
        "0x80b0b09",
        "int __usercall sub_80B0B09@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_80B0AB7((_DWORD *)(a1 + 4), *(const char **)a1, a2, 0);\n}\n"
    ],
    "sub_80B0B1C": [
        "0x80b0b1c",
        "int __usercall sub_80B0B1C@<eax>(int a1@<eax>)\n{\n  int v2; // ecx\n  FILE *v3; // ebp\n  int v4; // esi\n  char *v5; // eax\n  char *v6; // edi\n  int v8; // [esp-4h] [ebp-14h]\n\n  v3 = (FILE *)sub_80B3D76();\n  v4 = *(_DWORD *)(a1 + 4);\n  while ( 1 )\n  {\n    v5 = sub_80AB85A((int)v3, v2);\n    v6 = v5;\n    if ( !v5 )\n      break;\n    if ( *(_BYTE *)(a1 + 20) || *(_BYTE *)(a1 + 21) && *v5 )\n    {\n      printf(\"%*u%s%s\\n\", *(_DWORD *)a1, v4, *(const char **)(a1 + 12), v5);\n      v4 += *(_DWORD *)(a1 + 8);\n    }\n    else if ( *(_DWORD *)(a1 + 16) )\n    {\n      fputs_unlocked();\n    }\n    free(v6);\n  }\n  *(_DWORD *)(a1 + 4) = v4;\n  fclose(v3);\n  return v8;\n}\n"
    ],
    "sub_80B0B92": [
        "0x80b0b92",
        "_BYTE *__usercall sub_80B0B92@<eax>(__int16 a1@<ax>, int a2@<edx>)\n{\n  int v2; // ebx\n  _BYTE *v4; // eax\n  _BYTE *result; // eax\n\n  LOBYTE(v2) = a1;\n  if ( (a1 & 0x180) == 384 )\n  {\n    fputs_unlocked();\n    LOBYTE(v2) = v2 & 0x7F;\n  }\n  v2 = (unsigned __int8)v2;\n  if ( (unsigned __int8)v2 == 155 )\n  {\n    v2 = 123;\nLABEL_9:\n    v4 = *(_BYTE **)(a2 + 16);\n    if ( (unsigned int)v4 >= *(_DWORD *)(a2 + 28) )\n    {\n      __fputc_unlocked();\n    }\n    else\n    {\n      *(_DWORD *)(a2 + 16) = v4 + 1;\n      *v4 = 94;\n    }\n    goto LABEL_12;\n  }\n  if ( (unsigned __int8)v2 <= 0x1Fu )\n  {\n    v2 = (unsigned __int8)v2 + 64;\n    goto LABEL_9;\n  }\n  if ( (unsigned __int8)v2 == 127 )\n  {\n    v2 = 63;\n    goto LABEL_9;\n  }\nLABEL_12:\n  result = *(_BYTE **)(a2 + 16);\n  if ( (unsigned int)result >= *(_DWORD *)(a2 + 28) )\n  {\n    __fputc_unlocked();\n    return (_BYTE *)v2;\n  }\n  else\n  {\n    *(_DWORD *)(a2 + 16) = result + 1;\n    *result = v2;\n  }\n  return result;\n}\n"
    ],
    "sub_80B0C15": [
        "0x80b0c15",
        "unsigned int __usercall sub_80B0C15@<eax>(unsigned int result@<eax>, int a2@<edx>, char a3@<cl>)\n{\n  if ( result == 9 )\n  {\n    if ( (a3 & 2) == 0 )\n      goto LABEL_13;\n    goto LABEL_9;\n  }\n  if ( result != 10 )\n  {\n    if ( result > 0x7F )\n    {\n      result -= 128;\n      *(_WORD *)a2 = 11597;\n      a2 += 2;\n    }\nLABEL_9:\n    if ( result <= 0x1F || result == 127 )\n    {\n      *(_BYTE *)a2 = 94;\n      result ^= 0x40u;\n      goto LABEL_12;\n    }\n    goto LABEL_13;\n  }\n  if ( (a3 & 1) != 0 )\n  {\n    *(_BYTE *)a2 = 36;\nLABEL_12:\n    ++a2;\n  }\nLABEL_13:\n  *(_BYTE *)a2 = result;\n  *(_BYTE *)(a2 + 1) = 0;\n  return result;\n}\n"
    ],
    "sub_80B0C58": [
        "0x80b0c58",
        "const char *__usercall sub_80B0C58@<eax>(int *a1@<eax>, const char *a2@<edx>)\n{\n  const char *result; // eax\n  const char *i; // ebx\n  int v5; // ebx\n  int *v6; // ebx\n  char *v7; // eax\n  char *j; // edx\n  int v9; // edx\n\n  result = a2;\n  for ( i = a2; ; ++i )\n  {\n    if ( !*i )\n    {\n      if ( a1 )\n      {\n        v5 = i - a2;\n        *a1 = v5;\n        a1[1] = v5;\n        a1[2] = v5;\n      }\n      return result;\n    }\n    if ( (unsigned __int8)(*i - 32) > 0x5Eu )\n      break;\n  }\n  v6 = a1;\n  v7 = sub_804DB46(a2);\n  for ( j = v7; *j; ++j )\n  {\n    if ( (unsigned __int8)(*j - 32) > 0x5Eu )\n      *j = 63;\n  }\n  if ( v6 )\n  {\n    v9 = j - v7;\n    *v6 = v9;\n    v6[1] = v9;\n    v6[2] = v9;\n  }\n  return (const char *)sub_80A9707(v7);\n}\n"
    ],
    "sub_80B0CB3": [
        "0x80b0cb3",
        "int __usercall sub_80B0CB3@<eax>(_BYTE **a1@<eax>)\n{\n  _BYTE *v1; // edx\n  unsigned int v2; // edi\n  int v3; // ecx\n  unsigned int v4; // ebx\n  unsigned __int8 v5; // al\n  unsigned int v6; // ebp\n  int v7; // esi\n  const char *v8; // ecx\n\n  v1 = *a1;\n  if ( **a1 == 120 )\n  {\n    ++v1;\n    v2 = 16;\n    v3 = 1;\n  }\n  else\n  {\n    v2 = 8;\n    v3 = 0;\n  }\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = *v1 | 0x20;\n    v6 = v5 - 48;\n    if ( v6 > 9 )\n      v6 = v5 - 87;\n    if ( v6 >= v2 )\n      break;\n    if ( v6 + v2 * v4 > 0xFF )\n      goto LABEL_14;\n    ++v1;\n    ++v3;\n    v4 = v6 + v2 * v4;\n    if ( v3 == 3 )\n      goto LABEL_20;\n  }\n  if ( v2 != 16 )\n  {\nLABEL_14:\n    if ( !v3 )\n    {\n      v8 = \"abefnrtv\\\\\";\n      while ( *v1 != *v8 )\n      {\n        if ( !*++v8 )\n          goto LABEL_19;\n      }\n      ++v1;\nLABEL_19:\n      v4 = *((unsigned __int8 *)v8 + 10);\n    }\n    goto LABEL_20;\n  }\n  v7 = 92;\n  if ( v3 == 1 )\n    return v7;\nLABEL_20:\n  *a1 = v1;\n  return v4;\n}\n"
    ],
    "sub_80B0D53": [
        "0x80b0d53",
        "_BYTE *__usercall sub_80B0D53@<eax>(_BYTE *a1@<eax>, char *a2@<edx>)\n{\n  char *v3; // eax\n  char v4; // dl\n  char v5; // al\n  char *v7; // [esp+4h] [ebp-8h] BYREF\n\n  v7 = a2;\n  while ( 1 )\n  {\n    v3 = v7++;\n    v4 = *v3;\n    v5 = v4;\n    if ( v4 == 92 )\n    {\n      v5 = sub_80B0CB3(&v7);\n      v4 = 92;\n    }\n    *a1 = v5;\n    if ( !v4 )\n      break;\n    ++a1;\n  }\n  return a1;\n}\n"
    ],
    "sub_80B0D92": [
        "0x80b0d92",
        "int __usercall sub_80B0D92@<eax>(int *a1@<eax>, int a2@<edx>, int (*a3)(void)@<ecx>)\n{\n  int v4; // ebx\n  int v5; // eax\n  int i; // ebp\n  _DWORD *v7; // edi\n  int v11; // eax\n  int v12; // ebx\n  int v13; // eax\n\n  v4 = a1[1];\n  v5 = *a1;\n  for ( i = 0; v4 > i; ++i )\n  {\n    v7 = (_DWORD *)(v5 + 32 * i);\n    if ( *v7 == a2 )\n      return (int)(v7 + 1);\n  }\n  a1[1] = v4 + 1;\n  v11 = sub_80B4733(v4, 8194);\n  *a1 = v11;\n  v12 = 32 * v4;\n  *(_DWORD *)(v11 + v12) = a2;\n  v13 = a3();\n  sub_80B2C4E(28, v13);\n  return v12 + *a1 + 4;\n}\n"
    ],
    "sub_80B0DF7": [
        "0x80b0df7",
        "ssize_t __fastcall sub_80B0DF7(int a1, void *a2)\n{\n  int v3; // eax\n  ssize_t v4; // ebx\n  int v5; // esi\n  ssize_t v6; // eax\n\n  v3 = open64();\n  v4 = -1;\n  if ( v3 >= 0 )\n  {\n    v5 = v3;\n    v4 = read(v3, a2, 0x3FFu);\n    close(v5);\n  }\n  v6 = v4;\n  if ( v4 < 0 )\n    v6 = 0;\n  *((_BYTE *)a2 + v6) = 0;\n  return v4;\n}\n"
    ],
    "sub_80B0E38": [
        "0x80b0e38",
        "__int64 sub_80B0E38()\n{\n  __int64 v1; // [esp-8h] [ebp-8h]\n\n  free(dword_80DB754);\n  dword_80DB754 = 0;\n  dword_80DB758 = 0;\n  free(dword_80DB74C);\n  dword_80DB74C = 0;\n  dword_80DB750 = 0;\n  return v1;\n}\n"
    ],
    "sub_80B0E79": [
        "0x80b0e79",
        "int __usercall sub_80B0E79@<eax>(int a1@<eax>)\n{\n  return sub_80B0D92((int *)&dword_80DB754, a1, (int (*)(void))sub_80A9A17);\n}\n"
    ],
    "sub_80B0E8A": [
        "0x80b0e8a",
        "int __usercall sub_80B0E8A@<eax>(int a1@<eax>)\n{\n  return sub_80B0D92((int *)&dword_80DB74C, a1, (int (*)(void))sub_80A9A2D);\n}\n"
    ],
    "sub_80B0E9B": [
        "0x80b0e9b",
        "void __usercall sub_80B0E9B(int a1@<eax>)\n{\n  closedir(*(DIR **)a1);\n  free(*(void **)(a1 + 8));\n  free(*(void **)(a1 + 12));\n  free((void *)a1);\n}\n"
    ],
    "sub_80B0EC0": [
        "0x80b0ec0",
        "char *__usercall sub_80B0EC0@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // ebx\n  unsigned int v4; // edi\n  char v5; // al\n  int v6; // eax\n  int v7; // edx\n  int v8; // ecx\n  char *v9; // edi\n  char *v10; // eax\n  unsigned int v11; // edx\n  int v12; // ecx\n  int v13; // eax\n  int v14; // ecx\n  ssize_t v15; // eax\n  void *v16; // eax\n  char *dest; // [esp+0h] [ebp-458h]\n  int v19; // [esp+4h] [ebp-454h] BYREF\n  int v20; // [esp+8h] [ebp-450h] BYREF\n  unsigned int v21; // [esp+Ch] [ebp-44Ch] BYREF\n  int v22; // [esp+10h] [ebp-448h] BYREF\n  char s[49]; // [esp+17h] [ebp-441h] BYREF\n  char v24[24]; // [esp+48h] [ebp-410h] BYREF\n  int v25; // [esp+60h] [ebp-3F8h]\n  int v26; // [esp+64h] [ebp-3F4h]\n\n  v2 = a1;\n  if ( !a1 )\n  {\n    v4 = getpagesize();\n    v2 = (char *)sub_804DB2E(0x58u);\n    *(_DWORD *)v2 = sub_804DF7E(\"/proc\");\n    while ( 1 )\n    {\n      v5 = v2[4];\n      v4 >>= 1;\n      if ( !v4 )\n        break;\n      v2[4] = v5 + 1;\n    }\n    v2[5] = v5 - 10;\n  }\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      do\n      {\n        v6 = readdir64();\n        if ( !v6 )\n        {\n          sub_80B0E9B((int)v2);\n          return 0;\n        }\n        v7 = sub_804ED6C(10, (const char *)(v6 + 19), 0, (int)v2);\n      }\n      while ( *(_DWORD *)dword_80DBB7C );\n      memset(v2 + 16, 0, 0x48u);\n      *((_DWORD *)v2 + 9) = v7;\n      if ( (a2 & 0xFFFFFFFE) == 0 )\n        return v2;\n      dest = &s[sprintf(s, \"/proc/%u/\", v7)];\n      if ( (a2 & 0x10) == 0 )\n        break;\n      if ( !stat64() )\n      {\n        *((_DWORD *)v2 + 13) = v25;\n        *((_DWORD *)v2 + 14) = v26;\n        break;\n      }\n    }\n    if ( (a2 & 0x47E2E) == 0 )\n      goto LABEL_23;\n    strcpy(dest, \"stat\");\n    if ( sub_80B0DF7(v8, v24) >= 0 )\n    {\n      v9 = strrchr(v24, 41);\n      *v9 = 0;\n      v10 = strchr(v24, 40);\n      sub_80B2C4E(16, v10 + 1);\n      if ( sscanf(\n             v9 + 2,\n             \"%c %u %u %u %d %*s %*s %*s %*s %*s %*s %lu %lu %*s %*s %*s %ld %*s %*s %lu %lu %lu \",\n             v2 + 68,\n             v2 + 40,\n             v2 + 44,\n             v2 + 48,\n             &v20,\n             v2 + 28,\n             v2 + 24,\n             &v19,\n             v2 + 32,\n             &v21,\n             &v22) > 10 )\n        break;\n    }\n  }\n  v11 = v21 >> 10;\n  *((_DWORD *)v2 + 4) = v21 >> 10;\n  *((_DWORD *)v2 + 5) = v22 << v2[5];\n  v12 = v20;\n  *((_DWORD *)v2 + 15) = (v20 >> 8) & 0xFFF;\n  *((_DWORD *)v2 + 16) = (unsigned __int8)v12 | (v12 >> 12) & 0xFFF00;\n  *(_WORD *)(v2 + 69) = 8224;\n  v13 = 1;\n  if ( !v11 && v2[68] != 90 )\n  {\n    v2[69] = 87;\n    v13 = 2;\n  }\n  if ( v19 )\n  {\n    if ( v19 >= 0 )\n      v2[v13 + 68] = 78;\n    else\n      v2[v13 + 68] = 60;\n  }\nLABEL_23:\n  if ( (a2 & 0x100) != 0 )\n  {\n    strcpy(dest, \"exe\");\n    free(*((void **)v2 + 3));\n    *((_DWORD *)v2 + 3) = sub_804E190(s);\n  }\n  if ( (a2 & 0x10080) != 0 )\n  {\n    free(*((void **)v2 + 2));\n    *((_DWORD *)v2 + 2) = 0;\n    strcpy(dest, \"cmdline\");\n    v15 = sub_80B0DF7(v14, v24);\n    if ( v15 > 0 )\n    {\n      if ( (a2 & 0x10000) != 0 )\n      {\n        *((_WORD *)v2 + 3) = v15;\n        v16 = sub_804DB8D(v24, v15 + 1);\n      }\n      else\n      {\n        *((_WORD *)v2 + 3) = 0;\n        v16 = sub_804DB46(v24);\n      }\n      *((_DWORD *)v2 + 2) = v16;\n    }\n  }\n  return v2;\n}\n"
    ],
    "sub_80B1146": [
        "0x80b1146",
        "char *__userpurge sub_80B1146@<eax>(char *a1@<eax>, signed int a2@<edx>, int a3@<ecx>, char *a4)\n{\n  const char *v6; // ebp\n  int v7; // eax\n  int v8; // esi\n  char *result; // eax\n  char *v10; // edx\n  size_t v11; // esi\n  signed int v12; // esi\n  const char *v13; // [esp+4h] [ebp-34h]\n  size_t n; // [esp+8h] [ebp-30h] BYREF\n\n  v6 = a4;\n  sprintf((char *)&n + 3, \"/proc/%u/cmdline\", a3);\n  v7 = sub_804E632(a2 - 1, a1);\n  if ( v7 <= 0 )\n  {\n    if ( !a4 )\n      v6 = \"~`!$^&*()=|\\\\{}[];\\\"'<>?\" + 21;\n    return (char *)snprintf(a1, a2, \"[%s]\", v6);\n  }\n  else\n  {\n    v8 = v7;\n    a1[v7] = 0;\n    do\n      --v8;\n    while ( v8 != -1 && !a1[v8] );\n    *(_BYTE *)strchrnul() = 0;\n    result = sub_804D315(a1);\n    v10 = result;\n    while ( v8 != -1 )\n    {\n      if ( (unsigned __int8)a1[v8] <= 0x1Fu )\n        a1[v8] = 32;\n      --v8;\n    }\n    if ( *result == 45 )\n      v10 = result + 1;\n    if ( a4 )\n    {\n      v13 = v10;\n      v11 = strlen(a4);\n      result = (char *)strncmp(v13, a4, v11);\n      if ( result )\n      {\n        v12 = v11 + 3;\n        if ( a2 > v12 )\n          memmove(&a1[v12], a1, a2 - v12);\n        result = (char *)snprintf(a1, a2, \"{%s}\", a4);\n        if ( a2 > v12 )\n        {\n          a1[v12 - 1] = 32;\n          a1[a2 - 1] = 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80B123C": [
        "0x80b123c",
        "int __usercall sub_80B123C@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  a1[4] = a2;\n  result = sub_804EC4A();\n  a1[3] = result;\n  a1[1] = result;\n  a1[2] = result;\n  *a1 = 0;\n  return result;\n}\n"
    ],
    "sub_80B1258": [
        "0x80b1258",
        "FILE *__userpurge sub_80B1258@<eax>(\n        unsigned int *a1@<eax>,\n        unsigned int a2@<edx>,\n        unsigned int a3@<ecx>,\n        int a4,\n        unsigned int a5,\n        unsigned __int64 a6)\n{\n  FILE *result; // eax\n  unsigned int v8; // edi\n  unsigned int v9; // esi\n  int v10; // edx\n  int v11; // eax\n  unsigned int v12; // edx\n  void *v13; // esp\n  unsigned int v14; // eax\n  int v15; // edi\n  unsigned int v16; // eax\n  char *IO_write_base; // edx\n  const char *v18; // [esp-8h] [ebp-38h]\n  FILE *v19; // [esp-4h] [ebp-34h]\n  int *v20; // [esp+0h] [ebp-30h] BYREF\n  int v21; // [esp+4h] [ebp-2Ch]\n  int v22; // [esp+8h] [ebp-28h]\n  FILE *v23; // [esp+Ch] [ebp-24h]\n  unsigned int v24; // [esp+10h] [ebp-20h]\n  unsigned __int64 v25; // [esp+14h] [ebp-1Ch]\n  char v26[18]; // [esp+1Eh] [ebp-12h] BYREF\n\n  v25 = __PAIR64__(a3, a2);\n  v22 = a4;\n  v24 = a5;\n  v23 = (FILE *)sub_804EC4A();\n  result = (FILE *)a1[1];\n  a1[1] = (unsigned int)v23;\n  if ( !a6 || (v8 = (a6 - v25) >> 32, v9 = a6 - v25, a6 - v25 > __PAIR64__(v24, v22)) )\n  {\n    if ( result == v23 )\n      return result;\n    v9 = v22;\n    v8 = v24;\n  }\n  *sub_80AD152(__PAIR64__(v8, v9) + v25, v26, (int)\" kMGTPEZY\") = 0;\n  while ( a6 > 0xFFFFF )\n  {\n    a6 >>= 8;\n    v25 >>= 8;\n    v9 = __PAIR64__(v8, v9) >> 8;\n    v8 >>= 8;\n  }\n  v22 = isatty(2);\n  fprintf(stderr, (const char *)((v22 == 0) + 135107147), a1[4]);\n  v24 = a6;\n  if ( (_DWORD)a6 )\n  {\n    v21 = v9 + v25;\n    fprintf(stderr, \"%3u%% \", 100 * (v9 + (unsigned int)v25) / v24);\n    v11 = sub_804D986(2, v10) - 48;\n    if ( v11 > 2 )\n    {\n      v12 = v11;\n      if ( v11 > 999 )\n        v12 = 999;\n      v20 = (int *)&v20;\n      v13 = alloca(v12 + 1);\n      memset(&v20, 32, v12);\n      *((_BYTE *)&v20 + v12) = 0;\n      memset(&v20, 42, v21 * v12 / v24);\n      fprintf(stderr, \"|%s| \", (const char *)&v20);\n    }\n  }\n  v19 = stderr;\n  v18 = v26;\n  fputs_unlocked();\n  v14 = (unsigned int)v23 - a1[2];\n  if ( v9 != *a1 )\n  {\n    a1[2] = (unsigned int)v23;\n    *a1 = v9;\n    if ( v14 > 4 )\n      a1[3] += v14;\n    v14 = 0;\n  }\n  v15 = (int)v23 - a1[3];\n  if ( v14 <= 4 )\n  {\n    if ( v24 && v9 && v15 >= 0 )\n    {\n      v16 = v15 * (v24 - (unsigned int)v25) / v9 - v15;\n      if ( v16 > 0x36EE7F )\n        v16 = 3599999;\n      result = (FILE *)fprintf(stderr, \"%3u:%02u:%02u ETA\", v16 / 0xE10, v16 % 0xE10 / 0x3C, v16 % 0xE10 % 0x3C);\n      goto LABEL_27;\n    }\n    v19 = stderr;\n    v18 = \" --:--:-- ETA\";\n  }\n  else\n  {\n    v19 = stderr;\n    v18 = \"  - stalled -\";\n  }\n  result = (FILE *)fputs(v18, v19);\nLABEL_27:\n  if ( !v22 )\n  {\n    result = stderr;\n    IO_write_base = stderr->_IO_write_base;\n    if ( IO_write_base >= stderr->_IO_buf_base )\n    {\n      v19 = stderr;\n      v18 = (const char *)10;\n      __fputc_unlocked();\n      return (FILE *)v18;\n    }\n    else\n    {\n      stderr->_IO_write_base = IO_write_base + 1;\n      *IO_write_base = 10;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80B14A5": [
        "0x80b14a5",
        "int __usercall sub_80B14A5@<eax>(char a1@<al>)\n{\n  int v1; // edx\n  int result; // eax\n\n  v1 = a1 & 0x3F;\n  if ( (a1 & 0x3F) == 0 )\n    return 46;\n  result = 47;\n  if ( v1 != 1 )\n  {\n    if ( v1 > 11 )\n    {\n      result = v1 + 59;\n      if ( v1 <= 37 )\n        return v1 + 53;\n    }\n    else\n    {\n      return v1 + 46;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80B14D1": [
        "0x80b14d1",
        "int __usercall sub_80B14D1@<eax>(unsigned __int8 a1@<al>)\n{\n  int result; // eax\n\n  if ( a1 > 0x7Au )\n    return 0;\n  if ( a1 > 0x60u )\n    return a1 - 59;\n  result = 0;\n  if ( a1 <= 0x5Au )\n  {\n    if ( a1 <= 0x40u )\n    {\n      if ( (unsigned __int8)(a1 - 46) <= 0xBu )\n        return a1 - 46;\n    }\n    else\n    {\n      return a1 - 53;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80B1507": [
        "0x80b1507",
        "int __fastcall sub_80B1507(int a1, unsigned int a2)\n{\n  char v3; // al\n  _BYTE *v4; // ecx\n  char v5; // al\n  int v6; // ecx\n  char v7; // al\n  int v8; // ecx\n  int result; // eax\n  int v10; // ecx\n\n  v3 = sub_80B14A5(a2 >> 18);\n  *v4 = v3;\n  v5 = sub_80B14A5(a2 >> 12);\n  *(_BYTE *)(v6 + 1) = v5;\n  v7 = sub_80B14A5(a2 >> 6);\n  *(_BYTE *)(v8 + 2) = v7;\n  result = sub_80B14A5(a2);\n  *(_BYTE *)(v10 + 3) = result;\n  return result;\n}\n"
    ],
    "sub_80B153E": [
        "0x80b153e",
        "unsigned __int8 *__usercall sub_80B153E@<eax>(\n        int *a1@<eax>,\n        unsigned __int8 *a2@<edx>,\n        char *a3@<ecx>,\n        unsigned __int8 *a4)\n{\n  unsigned int *i; // eax\n  char v6; // di\n  unsigned __int32 v7; // edx\n  unsigned __int32 v8; // eax\n  int *v9; // ebp\n  int *v10; // edi\n  char *v11; // esi\n  char *v12; // ecx\n  int j; // edi\n  int *v14; // ebp\n  char *v15; // esi\n  char *v16; // ecx\n  int v17; // esi\n  int v18; // eax\n  unsigned __int8 v19; // dl\n  int v20; // ecx\n  unsigned int v21; // esi\n  int v22; // edx\n  int v23; // edi\n  unsigned int v24; // edx\n  unsigned int v25; // eax\n  int v26; // esi\n  int v27; // ebp\n  unsigned int v28; // ebp\n  int *v29; // ebp\n  int *v30; // edi\n  int *v31; // esi\n  int v32; // ecx\n  int *v33; // edx\n  unsigned int v34; // ebx\n  unsigned int v35; // ebp\n  int v36; // ecx\n  int v37; // ecx\n  unsigned __int8 *result; // eax\n  char *v40; // [esp+4h] [ebp-38h]\n  int v41; // [esp+4h] [ebp-38h]\n  unsigned __int8 v42; // [esp+4h] [ebp-38h]\n  char *v43; // [esp+4h] [ebp-38h]\n  unsigned int v44; // [esp+8h] [ebp-34h]\n  unsigned int v45; // [esp+8h] [ebp-34h]\n  int *v46; // [esp+8h] [ebp-34h]\n  char *v47; // [esp+Ch] [ebp-30h]\n  unsigned int v48; // [esp+Ch] [ebp-30h]\n  unsigned int v49; // [esp+Ch] [ebp-30h]\n  char *v50; // [esp+Ch] [ebp-30h]\n  char *v51; // [esp+10h] [ebp-2Ch]\n  int v52; // [esp+1Ch] [ebp-20h]\n  unsigned int v53[6]; // [esp+24h] [ebp-18h] BYREF\n\n  for ( i = v53; (char *)i - (char *)v53 != 8; i = (unsigned int *)((char *)i + 1) )\n  {\n    v6 = *a3;\n    *(_BYTE *)i = 2 * *a3;\n    if ( 2 * v6 )\n      ++a3;\n  }\n  v7 = _byteswap_ulong(v53[0]);\n  v8 = _byteswap_ulong(v53[1]);\n  v9 = &a1[v7 >> 25];\n  v40 = (char *)a1 + ((v7 >> 15) & 0x1FC);\n  v51 = (char *)a1 + ((v7 >> 7) & 0x1FC);\n  v47 = (char *)a1 + ((2 * (_WORD)v7) & 0x1FC);\n  v10 = &a1[v8 >> 25];\n  v11 = (char *)a1 + ((v8 >> 15) & 0x1FC);\n  v12 = (char *)a1 + ((v8 >> 7) & 0x1FC);\n  v44 = *(int *)((char *)a1 + ((2 * (_WORD)v8) & 0x1FC) + 20256) | *((_DWORD *)v12 + 4936) | *((_DWORD *)v11 + 4808) | *((_DWORD *)v47 + 4552) | *((_DWORD *)v51 + 4424) | *((_DWORD *)v40 + 4296) | v10[4680] | v9[4168];\n  v48 = *(int *)((char *)a1 + ((2 * (_WORD)v8) & 0x1FC) + 24352) | *((_DWORD *)v12 + 5960) | *((_DWORD *)v11 + 5832) | *((_DWORD *)v47 + 5576) | *((_DWORD *)v51 + 5448) | *((_DWORD *)v40 + 5320) | v10[5704] | v9[5192];\n  v41 = 0;\n  for ( j = 0; j != 16; ++j )\n  {\n    v41 += (unsigned __int8)byte_80B8500[j];\n    v14 = &a1[((v44 >> (28 - v41)) | (v44 << v41)) & 0x7F];\n    v15 = (char *)a1 + ((((v48 >> (28 - v41)) | (v48 << v41)) >> 19) & 0x1FC);\n    v16 = (char *)a1 + ((((v48 >> (28 - v41)) | (v48 << v41)) >> 12) & 0x1FC);\n    a1[j + 40] = *(int *)((char *)a1 + ((((v48 >> (28 - v41)) | (v48 << v41)) >> 5) & 0x1FC) + 27936) | *((_DWORD *)v16 + 6856) | *((_DWORD *)v15 + 6728) | *(int *)((char *)a1 + ((((v44 >> (28 - v41)) | (v44 << v41)) >> 5) & 0x1FC) + 25888) | *(int *)((char *)a1 + ((((v44 >> (28 - v41)) | (v44 << v41)) >> 12) & 0x1FC) + 25376) | *(int *)((char *)a1 + ((((v44 >> (28 - v41)) | (v44 << v41)) >> 19) & 0x1FC) + 24864) | a1[(((v48 >> (28 - v41)) | (v48 << v41)) & 0x7F) + 7112] | v14[6600];\n    a1[j + 56] = *(int *)((char *)a1 + ((((v48 >> (28 - v41)) | (v48 << v41)) >> 5) & 0x1FC) + 32032) | *((_DWORD *)v16 + 7880) | *((_DWORD *)v15 + 7752) | *(int *)((char *)a1 + ((((v44 >> (28 - v41)) | (v44 << v41)) >> 5) & 0x1FC) + 29984) | *(int *)((char *)a1 + ((((v44 >> (28 - v41)) | (v44 << v41)) >> 12) & 0x1FC) + 29472) | *(int *)((char *)a1 + ((((v44 >> (28 - v41)) | (v44 << v41)) >> 19) & 0x1FC) + 28960) | a1[(((v48 >> (28 - v41)) | (v48 << v41)) & 0x7F) + 8136] | v14[7624];\n  }\n  v17 = sub_80B14D1(a4[1]);\n  v42 = *a4;\n  v18 = (v17 << 6) | sub_80B14D1(*a4);\n  v19 = v42;\n  *a2 = v42;\n  if ( a4[1] )\n    v19 = a4[1];\n  a2[1] = v19;\n  a1[1] = 0;\n  v20 = 24;\n  v21 = 0x800000;\n  v22 = 1;\n  do\n  {\n    if ( (v22 & v18) != 0 )\n      a1[1] |= v21;\n    v22 *= 2;\n    v21 >>= 1;\n    --v20;\n  }\n  while ( v20 );\n  v52 = 25;\n  v24 = 0;\n  v25 = 0;\n  do\n  {\n    v49 = v25;\n    v26 = 0;\n    while ( 1 )\n    {\n      v27 = a1[1] & (((2 * (_BYTE)v24) & 0x3E | (8 * (_WORD)v24) & 0xFC0 | (v24 >> 31) | (v24 << 7) & 0xFC0000 | (32 * v24) & 0x3F000) ^ ((v24 >> 15) & 0x3F | (v24 >> 13) & 0xFC0 | (v24 >> 11) & 0x3F000 | (v24 >> 9) & 0x7C0000 | (v24 << 23) & 0x800000));\n      v45 = v27 ^ a1[v26 + 40] ^ ((v24 >> 15) & 0x3F | (v24 >> 13) & 0xFC0 | (v24 >> 11) & 0x3F000 | (v24 >> 9) & 0x7C0000 | (v24 << 23) & 0x800000);\n      v28 = a1[v26 + 56] ^ ((2 * (_BYTE)v24) & 0x3E | (8 * (_WORD)v24) & 0xFC0 | (v24 >> 31) | (v24 << 7) & 0xFC0000 | (32 * v24) & 0x3F000) ^ v27;\n      v23 = *a1;\n      v25 = v49 ^ (a1[*(unsigned __int8 *)(v23 + (v28 & 0xFFF) + 12352) + 9032] | a1[*(unsigned __int8 *)(v23 + (v28 >> 12) + 8256)\n                                                                                   + 8776] | a1[*(unsigned __int8 *)(v23 + (v45 & 0xFFF) + 4160)\n                                                                                              + 8520] | a1[*(unsigned __int8 *)(v23 + (v45 >> 12) + 64) + 8264]);\n      ++v26;\n      v49 = v24;\n      if ( v26 == 16 )\n        break;\n      v24 = v25;\n    }\n    --v52;\n  }\n  while ( v52 );\n  v29 = &a1[HIBYTE(v25)];\n  v50 = (char *)a1 + ((v25 >> 14) & 0x3FC);\n  v46 = &a1[BYTE1(v25)];\n  v30 = &a1[(unsigned __int8)v25];\n  v31 = &a1[HIBYTE(v24)];\n  v43 = (char *)a1 + ((v24 >> 14) & 0x3FC);\n  v32 = (int)&a1[BYTE1(v24)];\n  v33 = &a1[(unsigned __int8)v24];\n  v34 = *(_DWORD *)(v32 + 6432) | *((_DWORD *)v43 + 1352) | v46[584] | *((_DWORD *)v50 + 328) | v33[1864] | v31[1096] | v30[840] | v29[72];\n  v35 = *(_DWORD *)(v32 + 14624) | *((_DWORD *)v43 + 3400) | v46[2632] | *((_DWORD *)v50 + 2376) | v33[3912] | v31[3144] | v30[2888] | v29[2120];\n  sub_80B1507(v32, v34 >> 8);\n  sub_80B1507(v36, (v34 << 16) | HIWORD(v35));\n  sub_80B1507(v37, v35 << 8);\n  result = a2;\n  a2[13] = 0;\n  return result;\n}\n"
    ],
    "sub_80B1A6B": [
        "0x80b1a6b",
        "char *__usercall sub_80B1A6B@<eax>(char *a1@<eax>, char *a2@<edx>, char *a3@<ecx>)\n{\n  unsigned int i; // ebx\n  char v5; // al\n  unsigned int v6; // ebp\n  int j; // ebx\n  unsigned int v8; // ecx\n  char *v9; // edx\n  unsigned int v10; // ecx\n  char *v11; // edx\n  unsigned int v12; // ecx\n  char *v13; // edx\n  char *v14; // ebp\n  char *v15; // ecx\n  char *v16; // edi\n  unsigned int v17; // ebx\n  int k; // esi\n  int v19; // ecx\n  unsigned int v20; // ecx\n  unsigned int v22; // [esp+0h] [ebp-110h]\n  int v23; // [esp+4h] [ebp-10Ch]\n  char *v26; // [esp+10h] [ebp-100h]\n  char v27[17]; // [esp+17h] [ebp-F9h] BYREF\n  _DWORD v28[27]; // [esp+28h] [ebp-E8h] BYREF\n  _DWORD v29[31]; // [esp+94h] [ebp-7Ch] BYREF\n\n  for ( i = 3; i != 11; ++i )\n  {\n    v5 = a3[i];\n    if ( !v5 )\n      break;\n    if ( v5 == 36 )\n      break;\n  }\n  sub_80ACCF3(v28);\n  v22 = strlen(a2);\n  v23 = v22;\n  sub_80ACD25((int)v28, a2, v22);\n  sub_80ACD25((int)v28, a3, i);\n  qmemcpy(a1, a3, i);\n  a1[i] = 36;\n  v26 = a3 + 3;\n  sub_80ACCF3(v29);\n  sub_80ACD25((int)v29, a2, v22);\n  v6 = i - 3;\n  sub_80ACD25((int)v29, v26, i - 3);\n  sub_80ACD25((int)v29, a2, v22);\n  sub_80ACD79((int)v29, v27);\n  for ( j = v22; j > 0; j -= 16 )\n  {\n    v8 = j;\n    if ( j > 16 )\n      v8 = 16;\n    sub_80ACD25((int)v28, v27, v8);\n  }\n  memset(v27, 0, sizeof(v27));\n  while ( v23 )\n  {\n    v9 = v27;\n    if ( (v23 & 1) == 0 )\n      v9 = a2;\n    sub_80ACD25((int)v28, v9, 1u);\n    v23 >>= 1;\n  }\n  sub_80ACD79((int)v28, v27);\n  do\n  {\n    sub_80ACCF3(v29);\n    if ( (v23 & 1) != 0 )\n    {\n      v10 = v22;\n      v11 = a2;\n    }\n    else\n    {\n      v10 = 16;\n      v11 = v27;\n    }\n    sub_80ACD25((int)v29, v11, v10);\n    if ( v23 % 3 )\n      sub_80ACD25((int)v29, v26, v6);\n    if ( v23 % 7 )\n      sub_80ACD25((int)v29, a2, v22);\n    if ( (v23 & 1) != 0 )\n    {\n      v12 = 16;\n      v13 = v27;\n    }\n    else\n    {\n      v12 = v22;\n      v13 = a2;\n    }\n    sub_80ACD25((int)v29, v13, v12);\n    sub_80ACD79((int)v29, v27);\n    ++v23;\n  }\n  while ( v23 != 1000 );\n  v14 = &a1[v6 + 4];\n  v27[16] = v27[5];\n  v15 = v27;\n  v16 = v14;\n  do\n  {\n    v17 = (unsigned __int8)v15[12] | ((unsigned __int8)v15[6] << 8) | ((unsigned __int8)*v15 << 16);\n    for ( k = 0; k != 4; ++k )\n    {\n      v16[k] = sub_80B14A5(v17);\n      v17 >>= 6;\n    }\n    v16 += 4;\n    v15 = (char *)(v19 + 1);\n  }\n  while ( &v27[5] != v15 );\n  v14[20] = sub_80B14A5(v27[11]);\n  v14[21] = sub_80B14A5(v20 >> 6);\n  v14[22] = 0;\n  return a1;\n}\n"
    ],
    "sub_80B1CD4": [
        "0x80b1cd4",
        "int __usercall sub_80B1CD4@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  __pid_t v4; // edi\n  int v5; // ecx\n  int v6; // ebx\n  _BYTE *v7; // edi\n  unsigned int v8; // ecx\n\n  v4 = getpid();\n  v5 = v4 + sub_804EBDE();\n  v6 = 2 * a2;\n  v7 = a1;\n  do\n  {\n    *v7 = sub_80B14A5((unsigned int)(1664525 * v5 + 1013904223) >> 16);\n    v7 += 2;\n    *(v7 - 1) = sub_80B14A5(v8 >> 22);\n  }\n  while ( v7 != &a1[v6] );\n  a1[v6] = 0;\n  return v5;\n}\n"
    ],
    "sub_80B1D29": [
        "0x80b1d29",
        "_BYTE *__usercall sub_80B1D29@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>)\n{\n  char v3; // al\n  int v4; // edx\n\n  v3 = *a2 | 0x20;\n  v4 = 1;\n  if ( v3 != 100 )\n  {\n    *(_WORD *)a1 = 12580;\n    a1[2] = 36;\n    a1 += 3;\n    v4 = 4;\n  }\n  sub_80B1CD4(a1, v4);\n  return a1;\n}\n"
    ],
    "sub_80B1D56": [
        "0x80b1d56",
        "void *__usercall sub_80B1D56@<eax>(char *a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  char v3; // al\n  char *v4; // eax\n  void *result; // eax\n  int i; // ebx\n  unsigned int v7; // ecx\n  char v8; // dl\n  unsigned int j; // esi\n  unsigned __int8 v10; // dl\n  int k; // edx\n  _DWORD *v12; // eax\n  int m; // edx\n  int n; // edx\n  int ii; // edx\n  _DWORD *v16; // ebx\n  int kk; // ecx\n  int v18; // edi\n  int v19; // esi\n  int mm; // edx\n  unsigned int v21; // ebp\n  int v22; // edx\n  _DWORD *v23; // ebp\n  int v24; // edi\n  int v25; // esi\n  int v26; // ecx\n  int v27; // ebx\n  int v28; // esi\n  int v29; // edi\n  int v30; // ecx\n  int v31; // ebx\n  int nn; // edx\n  _DWORD *v33; // ebx\n  int i1; // edx\n  int v35; // esi\n  int i2; // ecx\n  unsigned __int8 *v37; // eax\n  _BYTE *v38; // [esp+0h] [ebp-38h]\n  _DWORD *v39; // [esp+0h] [ebp-38h]\n  void *v40; // [esp+0h] [ebp-38h]\n  char v42; // [esp+8h] [ebp-30h]\n  int jj; // [esp+8h] [ebp-30h]\n  _DWORD *v44; // [esp+Ch] [ebp-2Ch]\n  char *v45; // [esp+10h] [ebp-28h]\n  unsigned __int8 *v46; // [esp+10h] [ebp-28h]\n  _DWORD *v47; // [esp+14h] [ebp-24h]\n  _DWORD *v48; // [esp+18h] [ebp-20h]\n\n  if ( *a2 == 36 && (v3 = a2[1]) != 0 && a2[2] == 36 && v3 == 49 )\n  {\n    v4 = (char *)sub_804DB2E(0x24u);\n    result = sub_80B1A6B(v4, a1, a2);\n  }\n  else\n  {\n    if ( !dword_80DB760 )\n    {\n      v38 = sub_804DAFA(0x4040u);\n      for ( i = 0; i != 4; ++i )\n      {\n        v7 = 0;\n        v45 = (char *)&unk_80B7240 + 64 * i;\n        do\n        {\n          v8 = 16 * v45[v7 >> 1];\n          if ( (v7 & 1) != 0 )\n            v8 = v45[v7 >> 1];\n          v42 = v8 & 0xF0;\n          for ( j = 0; j != 64; ++j )\n          {\n            v10 = byte_80B7260[64 * i + (j >> 1)];\n            if ( (j & 1) != 0 )\n              v10 >>= 4;\n            v38[4096 * i + 64 + (j | (v7 << 6))] = v42 | v10 & 0xF;\n          }\n          ++v7;\n        }\n        while ( v7 != 64 );\n      }\n      for ( k = 0; k != 64; ++k )\n        v38[k] = byte_80B73C0[k] - 1;\n      dword_80DB760 = v38;\n    }\n    v46 = (unsigned __int8 *)dword_80DB760;\n    v12 = dword_80DB75C;\n    if ( !dword_80DB75C )\n      v12 = sub_804DAFA(0x9120u);\n    *v12 = v46;\n    v12[1] = 0;\n    for ( m = 0; m != 64; ++m )\n      *((_BYTE *)v12 + m + 96) = -1;\n    for ( n = 0; n != 56; ++n )\n    {\n      *((_BYTE *)v12 + (unsigned __int8)byte_80B7380[n] + 95) = n;\n      *((_BYTE *)v12 + n + 40) = -1;\n    }\n    for ( ii = 0; ii != 48; ++ii )\n      *((_BYTE *)v12 + (unsigned __int8)byte_80B7340[ii] + 39) = ii;\n    v44 = v12;\n    v47 = v12 + 72;\n    v48 = v12;\n    v39 = v12;\n    for ( jj = 0; jj != 16; jj += 2 )\n    {\n      v16 = v47;\n      for ( kk = 0; kk != 256; ++kk )\n      {\n        v18 = 0;\n        v19 = 0;\n        for ( mm = 0; mm != 8; ++mm )\n        {\n          if ( ((unsigned __int8)kk & (unsigned __int8)byte_80B84F8[mm]) != 0 )\n          {\n            v21 = v46[jj * 4 + mm];\n            if ( v21 > 0x1F )\n              v18 |= dword_80B7120[v21];\n            else\n              v19 |= dword_80B71A0[v21];\n          }\n        }\n        *v16 = v19;\n        v16[2048] = v18;\n        ++v16;\n      }\n      v22 = 0;\n      v23 = &v12[jj];\n      do\n      {\n        v24 = 0;\n        v25 = 0;\n        v26 = 0;\n        do\n        {\n          if ( ((unsigned __int8)v22 & (unsigned __int8)byte_80B84F8[++v26]) != 0 )\n          {\n            v27 = *((unsigned __int8 *)v23 + v26 + 95);\n            if ( v27 != 255 )\n            {\n              if ( *((unsigned __int8 *)v23 + v26 + 95) > 0x1Bu )\n                v24 |= dword_80B7140[v27];\n              else\n                v25 |= dword_80B71B0[v27];\n            }\n          }\n        }\n        while ( v26 != 7 );\n        v39[v22 + 4168] = v25;\n        v39[v22 + 5192] = v24;\n        v28 = 0;\n        v29 = 0;\n        v30 = 0;\n        do\n        {\n          if ( ((unsigned __int8)v22 & (unsigned __int8)byte_80B84F8[++v30]) != 0 )\n          {\n            v31 = *((unsigned __int8 *)v48 + v30 + 39);\n            if ( v31 != 255 )\n            {\n              if ( *((unsigned __int8 *)v48 + v30 + 39) > 0x17u )\n                v28 |= dword_80B7160[v31];\n              else\n                v29 |= dword_80B71C0[v31];\n            }\n          }\n        }\n        while ( v30 != 7 );\n        v39[v22 + 6216] = v29;\n        v39[v22++ + 7240] = v28;\n      }\n      while ( v22 != 128 );\n      v39 += 128;\n      v48 = (_DWORD *)((char *)v48 + 7);\n      v47 += 256;\n    }\n    for ( nn = 0; nn != 32; ++nn )\n      *((_BYTE *)v12 + (unsigned __int8)byte_80B7220[nn] + 7) = nn;\n    v33 = v12;\n    do\n    {\n      for ( i1 = 0; i1 != 256; ++i1 )\n      {\n        v35 = 0;\n        for ( i2 = 0; i2 != 8; ++i2 )\n        {\n          if ( ((unsigned __int8)i1 & (unsigned __int8)byte_80B84F8[i2]) != 0 )\n            v35 |= dword_80B71A0[*((unsigned __int8 *)v33 + i2 + 8)];\n        }\n        v44[i1 + 8264] = v35;\n      }\n      v44 += 256;\n      v33 += 2;\n    }\n    while ( v44 != v12 + 1024 );\n    dword_80DB75C = v12;\n    v37 = (unsigned __int8 *)sub_804DB2E(0x15u);\n    result = sub_80B153E((int *)dword_80DB75C, v37, a1, (unsigned __int8 *)a2);\n  }\n  if ( a3 )\n  {\n    v40 = result;\n    free(dword_80DB760);\n    free(dword_80DB75C);\n    dword_80DB760 = 0;\n    dword_80DB75C = 0;\n    return v40;\n  }\n  return result;\n}\n"
    ],
    "sub_80B20CC": [
        "0x80b20cc",
        "int __usercall sub_80B20CC@<eax>(int a1@<ecx>, char *a2@<edx>, char *a3@<eax>)\n{\n  ssize_t v4; // eax\n  unsigned __int8 v5; // dl\n  size_t v6; // eax\n  _BYTE *i; // edi\n  int j; // esi\n  char *v10; // eax\n  unsigned int v11; // esi\n  unsigned int v12; // eax\n  unsigned __int8 v13; // [esp+3h] [ebp-29h]\n  char *dest; // [esp+8h] [ebp-24h]\n  int v17; // [esp+10h] [ebp-1Ch]\n  char *endptr[2]; // [esp+14h] [ebp-18h] BYREF\n  __int16 v19; // [esp+1Ch] [ebp-10h]\n\n  endptr[1] = a3;\n  v19 = 1;\n  dest = a2 + 1;\n  while ( 1 )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    v4 = (unsigned __int8)*a2;\n    if ( *a2 )\n      goto LABEL_7;\n    if ( a1 >= -1 && !sub_80B2C0A(a1, 1u) )\n      break;\n    v4 = sub_804E5BC(1u, dest, (int)a3);\n    if ( v4 <= 0 )\n      return -1;\nLABEL_7:\n    v5 = a2[1];\n    v6 = v4 - 1;\n    v17 = v6;\n    if ( v6 )\n    {\n      v13 = a2[1];\n      memmove(dest, a2 + 2, v6);\n      v5 = v13;\n    }\n    if ( v5 != 27 )\n    {\n      *a2 = v17;\n      return v5;\n    }\n    for ( i = &unk_80D9291; *i; i = v10 + 2 )\n    {\n      for ( j = 0; ; ++j )\n      {\n        if ( v17 <= j )\n        {\n          if ( !sub_80B2C0A(50, 1u) )\n            goto LABEL_41;\n          *(_DWORD *)dword_80DBB7C = 0;\n          if ( sub_804E5BC(1u, &dest[v17], (int)a3) <= 0 )\n            goto LABEL_17;\n          ++v17;\n        }\n        v10 = &i[j];\n        if ( (i[j] & 0x7F) != a2[j + 1] )\n          break;\n        if ( (char)i[j] < 0 )\n        {\n          *a2 = 0;\n          return (char)i[j + 1];\n        }\n      }\n      while ( *v10 >= 0 )\n        ++v10;\n    }\n    while ( v17 <= 14 )\n    {\n      if ( !sub_80B2C0A(50, 1u) )\n        goto LABEL_41;\n      *(_DWORD *)dword_80DBB7C = 0;\n      if ( sub_804E5BC(1u, &a2[v17 + 1], (int)a3) <= 0 )\n      {\nLABEL_17:\n        if ( *(_DWORD *)dword_80DBB7C != 11 )\n        {\n          *a2 = 0;\n          return -1;\n        }\nLABEL_41:\n        if ( v17 <= 1 )\n        {\n          *a2 = v17;\n          return 27;\n        }\n        break;\n      }\n      if ( ++v17 > 4 && a2[1] == 91 && a2[v17] == 82 && (unsigned __int8)(a2[2] - 48) <= 9u )\n      {\n        v11 = strtoul(a2 + 2, endptr, 10);\n        if ( *endptr[0] == 59 && (unsigned __int8)(endptr[0][1] - 48) <= 9u )\n        {\n          v12 = strtoul(endptr[0] + 1, endptr, 10);\n          if ( v11 != 0 && *endptr[0] == 82 && v12 && (v12 | v11) <= 0x7FFF )\n          {\n            *a2 = 0;\n            return -256;\n          }\n        }\n      }\n    }\n    *a2 = 0;\n  }\n  *(_DWORD *)dword_80DBB7C = 11;\n  return -1;\n}\n"
    ],
    "sub_80B2319": [
        "0x80b2319",
        "ssize_t __usercall sub_80B2319@<eax>(int a1@<eax>, void *a2@<edx>, size_t a3@<ecx>)\n{\n  ssize_t result; // eax\n\n  while ( 1 )\n  {\n    result = sub_804E5BC(a3, a2, a1);\n    if ( result >= 0 || *(_DWORD *)dword_80DBB7C != 11 )\n      break;\n    sub_80B2C0A(-1, 1u);\n  }\n  return result;\n}\n"
    ],
    "sub_80B2361": [
        "0x80b2361",
        "void *__usercall sub_80B2361@<eax>(int a1@<eax>, unsigned int *a2@<edx>)\n{\n  int v3; // ecx\n  char *v4; // esi\n  unsigned int v5; // ebp\n  char *v6; // ebx\n  _BYTE *v7; // eax\n  unsigned int v9; // [esp+0h] [ebp-1Ch]\n  int v11; // [esp+8h] [ebp-14h]\n\n  v9 = 2147479552;\n  if ( a2 )\n    v9 = *a2;\n  v3 = 0;\n  v4 = 0;\nLABEL_4:\n  v5 = v3 + 128;\n  v11 = v3;\n  v4 = (char *)sub_804DB13(v4, v3 + 128);\n  v6 = &v4[v11];\n  while ( sub_80B2319(a1, v6, 1u) == 1 )\n  {\n    v7 = v6 + 1;\n    if ( *v6 == 10 )\n      goto LABEL_13;\n    if ( v5 >= v9 )\n    {\n      ++v6;\n      goto LABEL_13;\n    }\n    v3 = v7 - v4;\n    ++v6;\n    if ( v7 - v4 == v5 )\n      goto LABEL_4;\n  }\n  if ( v6 == v4 )\n  {\n    free(v6);\n    return 0;\n  }\nLABEL_13:\n  *v6 = 0;\n  if ( a2 )\n    *a2 = v6 - v4;\n  return sub_804DB13(v4, v6 + 1 - v4);\n}\n"
    ],
    "sub_80B2402": [
        "0x80b2402",
        "_BYTE *__usercall sub_80B2402@<eax>(int a1@<eax>, unsigned int *a2@<edx>)\n{\n  size_t v3; // ebx\n  unsigned int v4; // esi\n  void *v5; // edi\n  unsigned int v6; // eax\n  _BYTE *result; // eax\n  unsigned int v8; // [esp+0h] [ebp-78h]\n\n  v8 = 2147479552;\n  if ( a2 )\n    v8 = *a2;\n  fstat64();\n  v3 = 1024;\n  v4 = 0;\n  v5 = 0;\n  while ( 1 )\n  {\n    if ( v3 > v8 )\n      v3 = v8;\n    v5 = sub_804DB13(v5, v4 + v3 + 1);\n    v6 = sub_804E5E3(a1, (char *)v5 + v4, v3);\n    if ( v6 == -1 )\n    {\n      free(v5);\n      return 0;\n    }\n    v4 += v6;\n    if ( v8 <= v6 || v3 > v6 )\n      break;\n    v8 -= v6;\n    v3 = ((v4 >> 3) | 0x3FF) + 1;\n    if ( v3 > 0x10000 )\n      v3 = 0x10000;\n  }\n  result = sub_804DB13(v5, v4 + 1);\n  result[v4] = 0;\n  if ( a2 )\n    *a2 = v4;\n  return result;\n}\n"
    ],
    "sub_80B24C7": [
        "0x80b24c7",
        "_BYTE *__fastcall sub_80B24C7(int a1, unsigned int *a2)\n{\n  int v2; // eax\n  _BYTE *v3; // esi\n  int v4; // ebx\n\n  v2 = open64();\n  v3 = 0;\n  if ( v2 >= 0 )\n  {\n    v4 = v2;\n    v3 = sub_80B2402(v2, a2);\n    close(v4);\n  }\n  return v3;\n}\n"
    ],
    "sub_80B24F6": [
        "0x80b24f6",
        "int __usercall sub_80B24F6@<eax>(int result@<eax>, char *a2@<edx>, size_t a3@<ecx>)\n{\n  if ( a3 )\n  {\n    result = sub_804E5E3(result, a2, a3);\n    if ( result != a3 )\n      sub_804D5E0(\"short read\");\n  }\n  return result;\n}\n"
    ],
    "sub_80B2513": [
        "0x80b2513",
        "char __usercall sub_80B2513@<al>(int a1@<eax>, int a2@<edx>)\n{\n  char v3; // [esp+1h] [ebp-1h] BYREF\n\n  v3 = HIBYTE(a2);\n  sub_80B24F6(a1, &v3, 1u);\n  return v3;\n}\n"
    ],
    "sub_80B2528": [
        "0x80b2528",
        "_BYTE *__usercall sub_80B2528@<eax>(const char *a1@<eax>, unsigned int *a2@<edx>, int a3@<ecx>)\n{\n  _BYTE *result; // eax\n\n  result = sub_80B24C7(a3, a2);\n  if ( !result )\n    sub_804D3C9((int)\"can't read '%s'\", a1);\n  return result;\n}\n"
    ],
    "sub_80B2541": [
        "0x80b2541",
        "int __stdcall sub_80B2541(int a1)\n{\n  return 1;\n}\n"
    ],
    "sub_80B2549": [
        "0x80b2549",
        "int __userpurge sub_80B2549@<eax>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        int (__stdcall *a3)(int a1)@<ecx>,\n        int (__stdcall *a4)(int a1),\n        int a5,\n        int a6)\n{\n  int (__stdcall *v7)(int); // ebp\n  int (*v8)(); // ecx\n  int v10; // esi\n  int v11; // eax\n  int v12; // eax\n  int v13; // ecx\n  DIR *v16; // [esp+Ch] [ebp-7Ch]\n  char *v17; // [esp+10h] [ebp-78h]\n  DIR *dirp; // [esp+18h] [ebp-70h] BYREF\n  int v19; // [esp+28h] [ebp-60h]\n\n  v7 = sub_80B2541;\n  if ( a3 )\n    v7 = a3;\n  if ( !a4 )\n    a4 = sub_80B2541;\n  v8 = stat64;\n  if ( ((a6 == 0 ? 6 : 2) & a2) == 0 )\n    v8 = lstat64;\n  if ( v8() < 0 )\n  {\n    if ( (a2 & 0x40) != 0 && *(_DWORD *)dword_80DBB7C == 2 && !lstat64() )\n      return v7(a6);\n    goto LABEL_9;\n  }\n  if ( (v19 & 0xF000) != 0x4000 )\n    return v7(a6);\n  if ( (a2 & 1) == 0 )\n    return ((int (__fastcall *)(int, DIR **, int))a4)(a5, &dirp, a6);\n  if ( (a2 & 8) == 0 )\n  {\n    v11 = ((int (__fastcall *)(int, DIR **, int))a4)(a5, &dirp, a6);\n    if ( !v11 )\n    {\nLABEL_9:\n      if ( (a2 & 0x20) == 0 )\n        sub_804D3F1(a1);\n      return 0;\n    }\n    v10 = 1;\n    if ( v11 == 2 )\n      return v10;\n  }\n  v16 = opendir(a1);\n  v10 = 1;\n  if ( !v16 )\n    goto LABEL_9;\n  while ( 1 )\n  {\n    v12 = readdir64();\n    if ( !v12 )\n      break;\n    v17 = (char *)sub_80A9BF5((int)a1, (_BYTE *)(v12 + 19), v13);\n    if ( v17 )\n    {\n      if ( !sub_80B2549(v7, a2, a4, a5, a6 + 1) )\n        v10 = 0;\n      free(v17);\n    }\n  }\n  closedir(v16);\n  if ( (a2 & 8) != 0 && !((int (__fastcall *)(int, DIR **, int))a4)(a5, &dirp, a6) )\n    goto LABEL_9;\n  return v10;\n}\n"
    ],
    "sub_80B2709": [
        "0x80b2709",
        "int __usercall sub_80B2709@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v4; // edi\n  DIR *v5; // ebp\n  int v6; // eax\n  int v7; // eax\n  int v8; // ecx\n  void *ptr; // [esp+0h] [ebp-74h]\n  __int16 v11; // [esp+14h] [ebp-60h]\n\n  if ( lstat64() < 0 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n    {\n      sub_804D3A5((int)\"can't stat '%s'\", a1);\n      return -1;\n    }\n    if ( (a2 & 8) != 0 )\n      return 0;\nLABEL_8:\n    sub_804D3A5((int)\"can't remove '%s'\", a1);\n    return -1;\n  }\n  if ( (v11 & 0xF000) != 0x4000 )\n  {\n    if ( (a2 & 8) == 0 && access(a1, 2) < 0 && (v11 & 0xF000) != 40960 && isatty(0) || (a2 & 0x10) != 0 )\n    {\n      fprintf(stderr, \"%s: remove '%s'? \", ident, a1);\n      if ( !sub_80A96FD() )\n        return 0;\n    }\n    if ( unlink(a1) >= 0 )\n    {\n      if ( (a2 & 0x1000) != 0 )\n        printf(\"removed '%s'\\n\", a1);\n      return 0;\n    }\n    goto LABEL_8;\n  }\n  if ( (a2 & 4) == 0 )\n  {\n    sub_804D5F4(\"'%s' is a directory\", a1);\n    return -1;\n  }\n  if ( (a2 & 8) == 0 && access(a1, 2) < 0 && isatty(0) || (a2 & 0x10) != 0 )\n  {\n    fprintf(stderr, \"%s: descend into directory '%s'? \", ident, a1);\n    if ( !sub_80A96FD() )\n      return 0;\n  }\n  v5 = opendir(a1);\n  v4 = -1;\n  if ( !v5 )\n    return v4;\n  v4 = 0;\n  while ( 1 )\n  {\n    v6 = readdir64();\n    if ( !v6 )\n      break;\n    v7 = sub_80A9BF5((int)a1, (_BYTE *)(v6 + 19), (int)v5);\n    if ( v7 )\n    {\n      ptr = (void *)v7;\n      if ( sub_80B2709(v8, a2) < 0 )\n        v4 = -1;\n      free(ptr);\n    }\n  }\n  if ( closedir(v5) < 0 )\n  {\n    sub_804D3A5((int)\"can't close '%s'\", a1);\n    return -1;\n  }\n  if ( (a2 & 0x10) == 0 || (fprintf(stderr, \"%s: remove directory '%s'? \", ident, a1), sub_80A96FD()) )\n  {\n    if ( rmdir(a1) < 0 )\n      goto LABEL_8;\n    if ( (a2 & 0x1000) != 0 )\n      printf(\"removed directory: '%s'\\n\", a1);\n  }\n  return v4;\n}\n"
    ],
    "sub_80B2928": [
        "0x80b2928",
        "int __usercall sub_80B2928@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  size_t v4; // edi\n  int i; // esi\n  char *v6; // eax\n\n  v4 = strlen(a2);\n  for ( i = 0; ; ++i )\n  {\n    v6 = strstr(a1, a2);\n    if ( !v6 )\n      break;\n    a1 = &v6[v4];\n  }\n  return i;\n}\n"
    ],
    "sub_80B2955": [
        "0x80b2955",
        "void *__userpurge sub_80B2955@<eax>(char *needle@<ecx>, const char *a2@<eax>, int a3@<edx>, char *s)\n{\n  size_t v7; // ebp\n  size_t v8; // eax\n  void *v9; // esi\n  int v10; // edx\n  char *v11; // eax\n  size_t v13; // [esp+4h] [ebp-18h]\n  char *v14; // [esp+8h] [ebp-14h]\n  char *v15; // [esp+8h] [ebp-14h]\n\n  v13 = strlen(needle);\n  v7 = strlen(s);\n  v8 = strlen(a2);\n  v9 = sub_804DAFA(v8 + a3 * (v7 - v13) + 1);\n  v10 = (int)v9;\n  while ( 1 )\n  {\n    v14 = (char *)v10;\n    v11 = strstr(a2, needle);\n    if ( !v11 )\n      break;\n    v15 = v11;\n    mempcpy();\n    v10 = mempcpy();\n    a2 = &v15[v13];\n  }\n  strcpy(v14, a2);\n  return v9;\n}\n"
    ],
    "sub_80B29EC": [
        "0x80b29ec",
        "int __fastcall sub_80B29EC(int a1)\n{\n  int v1; // eax\n  int v2; // ebx\n  FILE *v3; // esi\n  char v5[136]; // [esp+0h] [ebp-88h] BYREF\n\n  v1 = sub_80B3D37(a1);\n  v2 = 0;\n  if ( v1 )\n  {\n    v3 = (FILE *)v1;\n    while ( fgets_unlocked() )\n    {\n      if ( sub_804D210(v5, \"UTC\") )\n      {\n        v2 = 1;\n        goto LABEL_7;\n      }\n    }\n    v2 = 0;\nLABEL_7:\n    fclose(v3);\n  }\n  return v2;\n}\n"
    ],
    "sub_80B2A42": [
        "0x80b2a42",
        "int __usercall sub_80B2A42@<eax>(const char **a1@<eax>)\n{\n  const char *i; // ebx\n  const char *v3; // edi\n  int result; // eax\n  int v5; // [esp+0h] [ebp-14h]\n\n  if ( !*a1 )\n  {\n    i = \"/dev/rtc\";\n    goto LABEL_11;\n  }\n  for ( i = &data; ; i += strlen(i) + 1 )\n  {\n    v3 = *a1;\n    v5 = 50;\n    while ( 1 )\n    {\n      *(_DWORD *)dword_80DBB7C = 0;\n      result = open64();\n      if ( *(_DWORD *)dword_80DBB7C != 16 )\n        break;\n      usleep(0x4E20u);\n      if ( !--v5 )\n      {\n        result = sub_804DBE1(v3);\n        break;\n      }\n    }\n    if ( result >= 0 )\n      break;\n    if ( !*i )\n      return sub_804DBE1(*a1);\nLABEL_11:\n    *a1 = i;\n  }\n  return result;\n}\n"
    ],
    "sub_80B2AC7": [
        "0x80b2ac7",
        "int __usercall sub_80B2AC7@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  memset(a1, 0, 0x2Cu);\n  result = sub_804E0BE(a2, 0x80247009, (int)a1, \"RTC_RD_TIME\");\n  a1[8] = -1;\n  return result;\n}\n"
    ],
    "sub_80B2AF7": [
        "0x80b2af7",
        "time_t __usercall sub_80B2AF7@<eax>(struct tm *a1@<eax>, int a2@<edx>, char *a3@<ebx>)\n{\n  time_t v5; // edi\n\n  if ( a2 )\n  {\n    a3 = getenv(\"TZ\");\n    putenv(\"TZ=UTC0\");\n    tzset();\n  }\n  v5 = mktime(a1);\n  if ( a2 )\n  {\n    unsetenv(\"TZ\");\n    if ( a3 )\n      putenv(a3 - 3);\n    tzset();\n  }\n  return v5;\n}\n"
    ],
    "sub_80B2B50": [
        "0x80b2b50",
        "void __userpurge __noreturn sub_80B2B50(const char *a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>, int a4, int a5)\n{\n  _DWORD *i; // eax\n  char **v9; // ebp\n  char *v10; // eax\n  int v11; // eax\n  char *v12; // edx\n\n  for ( i = a3; i && *i; ++i )\n    ;\n  v9 = (char **)sub_804DAFA(4 * (i - a3) + 8);\n  if ( !a1 || !*a1 )\n    a1 = \"-/bin/sh\" + 1;\n  v10 = sub_804D32D(a1);\n  *v9 = v10;\n  if ( a2 )\n    *v9 = sub_804DDBF((char *)\"-%s\", v10);\n  v9[1] = 0;\n  if ( a3 )\n  {\n    v11 = 1;\n    do\n    {\n      v12 = (char *)a3[++v11 - 2];\n      v9[v11 - 1] = v12;\n    }\n    while ( v12 );\n  }\n  execv(a1, v9);\n  sub_804D3C9((int)\"can't execute '%s'\", a1);\n}\n"
    ],
    "sub_80B2BD8": [
        "0x80b2bd8",
        "_BYTE *sub_80B2BD8()\n{\n  char *nodename; // eax\n  struct utsname name; // [esp+2h] [ebp-186h] BYREF\n\n  uname(&name);\n  nodename = (_BYTE *)(\"~`!$^&*()=|\\\\{}[];\\\"'<>?\" + 21);\n  if ( name.nodename[0] )\n    nodename = name.nodename;\n  return sub_804DB5D(nodename, 65);\n}\n"
    ],
    "sub_80B2C0A": [
        "0x80b2c0a",
        "int __usercall sub_80B2C0A@<eax>(int timeout@<ecx>, nfds_t nfds@<edx>, struct pollfd *a3@<eax>)\n{\n  int result; // eax\n  int v7; // [esp+0h] [ebp-10h]\n\n  while ( 1 )\n  {\n    result = poll(a3, nfds, timeout);\n    if ( result >= 0 )\n      break;\n    if ( timeout > 0 )\n      --timeout;\n    v7 = result;\n    if ( (*(_DWORD *)dword_80DBB7C & 0xFFFFFFF7) != 4 )\n    {\n      sub_804D3A5((int)\"poll\");\n      return v7;\n    }\n  }\n  return result;\n}\n"
    ],
    "sub_80B2C4E": [
        "0x80b2c4e",
        "char *__usercall sub_80B2C4E@<eax>(char *result@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  if ( a3 )\n  {\n    result[a3 - 1] = 0;\n    return strncpy(result, a2, a3 - 1);\n  }\n  return result;\n}\n"
    ],
    "sub_80B2C69": [
        "0x80b2c69",
        "int __usercall sub_80B2C69@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v3; // ecx\n  char v4; // bl\n\n  if ( result != a2 )\n  {\n    v3 = 0;\n    do\n    {\n      v4 = *(_BYTE *)(a2 + v3);\n      *(_BYTE *)(result + v3++) = v4;\n    }\n    while ( v4 );\n  }\n  return result;\n}\n"
    ],
    "sub_80B2C7E": [
        "0x80b2c7e",
        "_BOOL4 __usercall sub_80B2C7E@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  _DWORD *v3; // ebx\n  const char *v5; // [esp+0h] [ebp-Ch] BYREF\n\n  v5 = \"/etc/securetty\";\n  v3 = sub_80B0511(a2, (int (__fastcall *)(int, _DWORD))sub_80B3D37);\n  while ( sub_80B0560((int)v3, &v5, 4653313, \"# \\t\") && strcmp(v5, a1) )\n    v5 = 0;\n  sub_80B0536((int)v3);\n  return v5 != 0;\n}\n"
    ],
    "sub_80B2CE1": [
        "0x80b2ce1",
        "const char *__usercall sub_80B2CE1@<eax>(const char *result@<eax>, char a2@<dl>, int a3@<ecx>)\n{\n  const char *v5; // esi\n  const char *v6; // eax\n  char *v7; // edi\n  const char *v8; // edx\n\n  if ( !result || (v5 = result, !*result) )\n    v5 = \"-/bin/sh\" + 1;\n  if ( (a2 & 0x10) == 0 )\n  {\n    result = (const char *)chdir(*(const char **)(a3 + 20));\n    if ( result )\n    {\n      sub_804D5F4(\"can't change directory to '%s'\", *(const char **)(a3 + 20));\n      v6 = \"/tmp\";\n      if ( (a2 & 4) == 0 )\n        v6 = \" /\" + 1;\n      result = (const char *)sub_804DF04(v6);\n    }\n  }\n  if ( (a2 & 2) != 0 )\n  {\n    v7 = getenv(\"TERM\");\n    clearenv();\n    if ( v7 )\n      sub_804DDE4(\"TERM\", v7);\n    v8 = \"/bin:/usr/bin\";\n    if ( !*(_DWORD *)(a3 + 8) )\n      v8 = \"/sbin:/usr/sbin:/bin:/usr/bin\";\n    sub_804DDE4(\"PATH\", v8);\nLABEL_17:\n    sub_804DDE4(\"USER\", *(const char **)a3);\n    sub_804DDE4(\"LOGNAME\", *(const char **)a3);\n    goto LABEL_18;\n  }\n  if ( (a2 & 1) == 0 )\n    return result;\n  if ( *(_DWORD *)(a3 + 8) )\n    goto LABEL_17;\nLABEL_18:\n  sub_804DDE4(\"HOME\", *(const char **)(a3 + 20));\n  return (const char *)sub_804DDE4(\"SHELL\", v5);\n}\n"
    ],
    "sub_80B2DBC": [
        "0x80b2dbc",
        "_BYTE *__usercall sub_80B2DBC@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *v1; // esi\n  _BYTE *v2; // edx\n  _BYTE *v3; // ecx\n  char v4; // bl\n  _BYTE *v5; // edi\n  char v6; // al\n  char v7; // al\n\n  v1 = a1;\n  v2 = a1;\n  do\n  {\n    v3 = a1;\n    v4 = *a1;\n    v5 = a1 + 1;\n    if ( *v2 != 47 )\n      goto LABEL_13;\n    if ( v4 == 47 )\n      goto LABEL_14;\n    if ( v4 != 46 )\n    {\nLABEL_13:\n      *++v2 = v4;\n      goto LABEL_14;\n    }\n    v6 = a1[1];\n    if ( v6 && v6 != 47 )\n    {\n      if ( v6 != 46 )\n        goto LABEL_13;\n      v7 = v3[2];\n      if ( v7 )\n      {\n        if ( v7 != 47 )\n          goto LABEL_13;\n      }\n      v3 = v5;\n      if ( v2 > v1 )\n      {\n        do\n          --v2;\n        while ( *v2 != 47 );\n        v3 = v5;\n      }\n    }\nLABEL_14:\n    a1 = v3 + 1;\n  }\n  while ( v3[1] );\n  if ( v2 == v1 || *v2 != 47 )\n    ++v2;\n  *v2 = 0;\n  return v2;\n}\n"
    ],
    "sub_80B2E23": [
        "0x80b2e23",
        "char *__usercall sub_80B2E23@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char *v4; // ebx\n  void *v5; // esi\n  int v6; // ecx\n\n  if ( *a1 == 47 )\n  {\n    v4 = sub_804DB46(a1);\n  }\n  else\n  {\n    v5 = (void *)sub_80B46C0(a3, a2);\n    v4 = (char *)sub_804D2D1((int)v5, a1, v6);\n    free(v5);\n  }\n  sub_80B2DBC(v4);\n  return v4;\n}\n"
    ],
    "sub_80B2E5A": [
        "0x80b2e5a",
        "int __usercall sub_80B2E5A@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  const char *v2; // eax\n  int result; // eax\n\n  v1 = a1;\n  v2 = *(const char **)(a1 + 4);\n  if ( v2 && !strcmp(v2, \"--\") )\n    v1 += 4;\n  result = *(_DWORD *)(v1 + 4);\n  if ( !result || *(_DWORD *)(v1 + 8) )\n    sub_804CDC2();\n  return result;\n}\n"
    ],
    "sub_80B2E8C": [
        "0x80b2e8c",
        "_BYTE *__usercall sub_80B2E8C@<eax>(_BYTE *result@<eax>)\n{\n  while ( *result == 32 || (unsigned __int8)(*result - 9) <= 4u )\n    ++result;\n  return result;\n}\n"
    ],
    "sub_80B2E9F": [
        "0x80b2e9f",
        "_BYTE *__usercall sub_80B2E9F@<eax>(_BYTE *result@<eax>)\n{\n  while ( (*result & 0xDF) != 0 && (unsigned __int8)(*result - 9) > 4u )\n    ++result;\n  return result;\n}\n"
    ],
    "sub_80B2EB2": [
        "0x80b2eb2",
        "_BYTE *__usercall sub_80B2EB2@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = sub_804D210(a1, \"/dev/\");\n  if ( !result )\n    return a1;\n  return result;\n}\n"
    ],
    "sub_80B2EC7": [
        "0x80b2ec7",
        "int __usercall sub_80B2EC7@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  int result; // eax\n\n  v1 = 0;\n  while ( (unsigned __int16)word_80B7400[2 * v1] != a1 )\n  {\n    if ( ++v1 == 31 )\n      return 0;\n  }\n  result = (unsigned __int16)word_80B7402[2 * v1];\n  if ( (result & 0x8000u) != 0 )\n    return 200 * (result & 0x7FFF);\n  return result;\n}\n"
    ],
    "sub_80B2EFA": [
        "0x80b2efa",
        "int __usercall sub_80B2EFA@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // esi\n\n  v2 = 0;\n  while ( 1 )\n  {\n    v3 = (unsigned __int16)word_80B7400[2 * v2];\n    if ( sub_80B2EC7(v3) == a1 )\n      break;\n    if ( ++v2 == 31 )\n      return -1;\n  }\n  return v3;\n}\n"
    ],
    "sub_80B2F23": [
        "0x80b2f23",
        "char *__usercall sub_80B2F23@<eax>(char *result@<eax>)\n{\n  char *v1; // ecx\n  char i; // dl\n\n  v1 = result;\n  for ( i = *result; *v1; i = *v1 )\n  {\n    if ( (unsigned __int8)(i - 65) <= 0x19u )\n      i += 32;\n    *v1++ = i;\n  }\n  return result;\n}\n"
    ],
    "sub_80B2F43": [
        "0x80b2f43",
        "unsigned int sub_80B2F43()\n{\n  unsigned int result; // eax\n\n  result = sysconf(0);\n  if ( result > 0x4000000 )\n    return 0x4000000;\n  return result;\n}\n"
    ],
    "sub_80B2F58": [
        "0x80b2f58",
        "int sub_80B2F58()\n{\n  return sysconf(2);\n}\n"
    ],
    "sub_80B2F61": [
        "0x80b2f61",
        "char *__usercall sub_80B2F61@<eax>(char *a1@<eax>)\n{\n  size_t v2; // edi\n  size_t i; // esi\n  _BYTE *v4; // eax\n  char *result; // eax\n\n  v2 = strlen(a1);\n  for ( i = v2; i; --i )\n  {\n    if ( a1[i - 1] != 32 && (unsigned __int8)(a1[i - 1] - 9) > 4u )\n    {\n      v4 = sub_80B2E8C(a1);\n      if ( v4 != a1 )\n      {\n        i -= v4 - a1;\n        memmove(a1, v4, i);\n      }\n      break;\n    }\n  }\n  result = &a1[i];\n  if ( i != v2 )\n    *result = 0;\n  return result;\n}\n"
    ],
    "sub_80B2FB5": [
        "0x80b2fb5",
        "int __usercall sub_80B2FB5@<eax>(const char *a1@<eax>, int a2@<ebx>)\n{\n  const char *v2; // edi\n  unsigned int v3; // eax\n  _DWORD *v4; // esi\n  int i; // ebx\n  char v6; // al\n  char v7; // al\n  unsigned int v8; // eax\n  char v9; // al\n  unsigned int v10; // eax\n\n  v2 = a1;\n  v3 = sub_804ED6C(10, a1, 0, a2);\n  v4 = (_DWORD *)dword_80DBB7C;\n  if ( *(_DWORD *)dword_80DBB7C || (i = v3, v3 > 0x40) )\n  {\n    if ( !strncasecmp(v2, \"SIG\", 3u) )\n      v2 += 3;\n    for ( i = 0; i != 33; ++i )\n    {\n      if ( !strcasecmp(v2, (const char *)(7 * i + 135107574)) )\n        return i;\n    }\n    if ( (*v2 | 0x20) != 105\n      || (v2[1] | 0x20) != 111\n      || (v6 = v2[2], i = 29, v6) && (((unsigned __int8)v6 | 0x20) != 116 || (i = 6, v2[3])) )\n    {\n      if ( !strncasecmp(v2, \"RTMIN\", 5u) )\n      {\n        v7 = v2[5];\n        i = 32;\n        if ( v7 )\n        {\n          if ( v7 != 43 )\n            return -1;\n          v8 = sub_804ED6C(10, v2 + 6, 0, 32);\n          if ( *v4 )\n            return -1;\n          i = v8 + 32;\n          if ( v8 > 0x20 )\n            return -1;\n        }\n      }\n      else\n      {\n        if ( strncasecmp(v2, \"RTMAX\", 5u) )\n          return -1;\n        v9 = v2[5];\n        i = 64;\n        if ( v9 )\n        {\n          if ( v9 != 45 )\n            return -1;\n          v10 = sub_804ED6C(10, v2 + 6, 0, 64);\n          if ( *v4 || v10 > 0x20 )\n            return -1;\n          return 64 - v10;\n        }\n      }\n    }\n  }\n  return i;\n}\n"
    ],
    "sub_80B30D9": [
        "0x80b30d9",
        "char *__usercall sub_80B30D9@<eax>(unsigned int a1@<eax>)\n{\n  if ( a1 <= 0x20 && MEMORY[0x80D93F6][7 * a1] )\n    return &MEMORY[0x80D93F6][7 * a1];\n  else\n    return sub_804D70F(a1);\n}\n"
    ],
    "sub_80B30F8": [
        "0x80b30f8",
        "int sub_80B30F8()\n{\n  int i; // ebx\n\n  for ( i = 1; i != 33; ++i )\n  {\n    if ( MEMORY[0x80D93F6][7 * i] )\n      printf(\"%2u) %s\\n\", i, &MEMORY[0x80D93F6][7 * i]);\n  }\n  return printf(\"%2u) %s\\n\", 64, \"RTMAX\");\n}\n"
    ],
    "sub_80B313B": [
        "0x80b313b",
        "int __usercall sub_80B313B@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  int v4; // [esp+0h] [ebp-8h] BYREF\n\n  v4 = a2;\n  if ( sscanf(a1, \"/dev/ubi%u\", &v4) != 1 )\n    sub_804D5E0(\"not an UBI device: '%s'\", a1);\n  return v4;\n}\n"
    ],
    "sub_80B3162": [
        "0x80b3162",
        "int __usercall sub_80B3162@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int v3; // ebx\n  char s[53]; // [esp+7h] [ebp-C5h] BYREF\n  char s2[144]; // [esp+3Ch] [ebp-90h] BYREF\n\n  v3 = 0;\n  while ( 1 )\n  {\n    sprintf(s, \"/sys/class/ubi/ubi%u_%u/name\", a1, v3);\n    if ( sub_804E632(0x80u, s2) > 0 )\n    {\n      s2[127] = 0;\n      *(_BYTE *)strchrnul() = 0;\n      if ( !strcmp(a2, s2) )\n        break;\n    }\n    if ( ++v3 == 128 )\n      sub_804D5E0(\"volume '%s' not found\", a2);\n  }\n  return v3;\n}\n"
    ],
    "sub_80B31E3": [
        "0x80b31e3",
        "int sub_80B31E3()\n{\n  sub_80B4242(8, 0);\n  return sub_80B4242(49, 41);\n}\n"
    ],
    "sub_80B3204": [
        "0x80b3204",
        "ssize_t __userpurge sub_80B3204@<eax>(\n        size_t n@<ecx>,\n        void *buf@<edx>,\n        int a3@<eax>,\n        int flags,\n        struct sockaddr *addr,\n        int a6,\n        socklen_t addr_len)\n{\n  __int16 v7; // bp\n  int v9[2]; // [esp+0h] [ebp-54h] BYREF\n  struct msghdr message; // [esp+8h] [ebp-4Ch] BYREF\n  int v11[12]; // [esp+24h] [ebp-30h] BYREF\n\n  v7 = *(_WORD *)a6;\n  if ( (*(_WORD *)a6 & 0xFFF7) != 2 )\n    return sendto(a3, buf, n, flags, addr, addr_len);\n  v9[0] = (int)buf;\n  v9[1] = n;\n  memset(v11, 0, 0x20u);\n  message.msg_name = addr;\n  message.msg_namelen = addr_len;\n  message.msg_iov = (struct iovec *)v9;\n  message.msg_iovlen = 1;\n  message.msg_control = v11;\n  message.msg_flags = flags;\n  if ( v7 == 2 )\n  {\n    v11[2] = 8;\n    v11[0] = 24;\n    v11[4] = *(_DWORD *)(a6 + 4);\n  }\n  else if ( v7 == 10 )\n  {\n    v11[1] = 41;\n    v11[2] = 50;\n    v11[0] = 32;\n    qmemcpy(&v11[3], (const void *)(a6 + 8), 0x10u);\n  }\n  message.msg_controllen = v11[0];\n  return sendmsg(a3, &message, flags);\n}\n"
    ],
    "sub_80B32E8": [
        "0x80b32e8",
        "ssize_t __userpurge sub_80B32E8@<eax>(\n        int a1@<eax>,\n        int a2@<edx>,\n        int a3@<ecx>,\n        int flags,\n        void *a5,\n        int a6,\n        socklen_t a7)\n{\n  ssize_t v7; // ebx\n  struct cmsghdr *i; // eax\n  int cmsg_level; // edx\n  int v11[2]; // [esp+0h] [ebp-50h] BYREF\n  struct msghdr message; // [esp+8h] [ebp-48h] BYREF\n  char v13; // [esp+24h] [ebp-2Ch] BYREF\n\n  v11[0] = a2;\n  v11[1] = a3;\n  message.msg_flags = 0;\n  message.msg_name = a5;\n  message.msg_namelen = a7;\n  message.msg_iov = (struct iovec *)v11;\n  message.msg_iovlen = 1;\n  message.msg_control = &v13;\n  message.msg_controllen = 32;\n  v7 = recvmsg(a1, &message, flags);\n  if ( v7 >= 0 && message.msg_controllen > 0xB )\n  {\n    for ( i = (struct cmsghdr *)message.msg_control; i; i = __cmsg_nxthdr(&message, i) )\n    {\n      cmsg_level = i->cmsg_level;\n      if ( cmsg_level )\n      {\n        if ( cmsg_level == 41 && i->cmsg_type == 50 )\n        {\n          *(_WORD *)a6 = 10;\n          qmemcpy((void *)(a6 + 8), &i[1], 0x10u);\n          return v7;\n        }\n      }\n      else if ( i->cmsg_type == 8 )\n      {\n        *(_WORD *)a6 = 2;\n        *(_DWORD *)(a6 + 4) = i[1].cmsg_type;\n        return v7;\n      }\n    }\n  }\n  return v7;\n}\n"
    ],
    "sub_80B33A5": [
        "0x80b33a5",
        "int __usercall sub_80B33A5@<eax>(const char *a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  char *v5; // eax\n  char *v6; // esi\n  char *v7; // ebp\n  int v8; // ebx\n  int v9; // edi\n  _DWORD *v10; // ebx\n  int v11; // ecx\n  char *v12; // eax\n  char *v13; // edi\n  const char *v14; // eax\n  const char *v15; // ebp\n  unsigned int v16; // eax\n  int v17; // ebp\n  int v18; // edi\n  int v19; // ebp\n  int v21; // [esp-8h] [ebp-B0h]\n  char *from; // [esp+0h] [ebp-A8h]\n  FILE *stream; // [esp+4h] [ebp-A4h]\n  FILE *v24; // [esp+8h] [ebp-A0h]\n  char *ptr; // [esp+Ch] [ebp-9Ch]\n  int fd; // [esp+10h] [ebp-98h]\n  char *v28; // [esp+1Ch] [ebp-8Ch]\n  __int16 v29; // [esp+48h] [ebp-60h]\n  __uid_t owner; // [esp+50h] [ebp-58h]\n  __gid_t group; // [esp+54h] [ebp-54h]\n\n  v28 = strstr(a1, \"shadow\");\n  v5 = sub_804E1D0(a1);\n  from = v5;\n  if ( !v5 )\n    return -1;\n  v6 = sub_804DDBF(\"%s+\", v5);\n  v7 = &v6[strlen(v6) - 1];\n  if ( !a2 )\n    a2 = &data;\n  ptr = sub_804DDBF(\"%s:\", a2);\n  if ( v28 )\n  {\n    stream = (FILE *)fopen64();\n    v8 = 0;\n  }\n  else\n  {\n    stream = (FILE *)sub_80B3D18(v21, \"r+\");\n    v8 = -1;\n  }\n  if ( stream )\n  {\n    fileno_unlocked(stream);\n    v9 = 30;\n    while ( 1 )\n    {\n      fd = open64();\n      v10 = (_DWORD *)dword_80DBB7C;\n      if ( fd >= 0 )\n        break;\n      if ( *(_DWORD *)dword_80DBB7C == 17 )\n      {\n        usleep(0x186A0u);\n        if ( --v9 )\n          continue;\n      }\n      sub_804D3A5((int)\"can't create '%s'\", v6);\nLABEL_37:\n      v8 = -1;\n      goto LABEL_39;\n    }\n    if ( !fstat64() )\n    {\n      fchmod(fd, v29 & 0x1FF);\n      fchown(fd, owner, group);\n    }\n    *v10 = 0;\n    v24 = (FILE *)sub_80B3D6E();\n    *v7 = 45;\n    if ( unlink(v6) && *v10 != 2 || link(from, v6) )\n      sub_804D3A5((int)\"warning: can't create backup copy '%s'\", v6);\n    *v7 = 43;\n    if ( fcntl64() < 0 )\n      sub_804D3A5((int)\"warning: can't lock '%s'\", from);\n    v8 = 0;\n    while ( 1 )\n    {\n      v12 = sub_80AB85A((int)stream, v11);\n      v13 = v12;\n      if ( !v12 )\n        break;\n      if ( sub_804D210(v12, ptr) )\n      {\n        if ( *ident == 112 )\n        {\n          v14 = (const char *)strchrnul();\n          if ( v28 && *v14 == 58 )\n          {\n            v15 = (const char *)strchrnul();\n            v16 = time(0);\n            fprintf(v24, \"%s%s:%u%s\\n\", ptr, a3, v16 / 0x15180, v15);\n          }\n          else\n          {\n            fprintf(v24, \"%s%s%s\\n\", ptr, a3, v14);\n          }\n          ++v8;\n        }\n      }\n      else\n      {\n        fprintf(v24, \"%s\\n\", v13);\n      }\n      free(v13);\n    }\n    if ( !v8 && *ident == 97 )\n    {\n      fprintf(v24, \"%s%s\\n\", ptr, a3);\n      v8 = 1;\n    }\n    fcntl64();\n    *(_DWORD *)dword_80DBB7C = 0;\n    v17 = stream->_flags & 8;\n    v18 = fflush(v24);\n    v19 = fsync(fd) | v18 | v17;\n    if ( v19 | fclose(v24) || rename(v6, from) )\n    {\n      sub_80B47D4();\n      unlink(v6);\n      goto LABEL_37;\n    }\nLABEL_39:\n    fclose(stream);\n  }\n  free(v6);\n  free(from);\n  free(ptr);\n  return v8;\n}\n"
    ],
    "sub_80B371B": [
        "0x80b371b",
        "int sub_80B371B()\n{\n  int result; // eax\n  int v1; // eax\n\n  result = access(\"/var/run/utmp\", 6) + 1;\n  if ( !result )\n  {\n    v1 = open64();\n    return close(v1);\n  }\n  return result;\n}\n"
    ],
    "sub_80B3747": [
        "0x80b3747",
        "int __userpurge sub_80B3747@<eax>(__pid_t a1@<eax>, __int16 a2@<dx>, _BYTE *a3@<ecx>, const char *a4, const char *a5)\n{\n  const char *v5; // esi\n  size_t v6; // edi\n  char *ut_id; // ebp\n  struct utmpx v9; // [esp+0h] [ebp-190h] BYREF\n\n  memset(&v9, 0, sizeof(v9));\n  v9.ut_pid = a1;\n  v9.ut_type = a2;\n  v5 = sub_80B2EB2(a3);\n  sub_80B2C4E(v9.ut_line, v5, 32);\n  if ( a4 )\n    sub_80B2C4E(v9.ut_user, a4, 32);\n  if ( a5 )\n    sub_80B2C4E(v9.ut_host, a5, 256);\n  v9.ut_tv.tv_sec = time(0);\n  if ( *v5 == 112 )\n  {\n    v9.ut_id[0] = 112;\n    v6 = 3;\n    ut_id = &v9.ut_id[1];\n  }\n  else\n  {\n    v6 = 4;\n    ut_id = v9.ut_id;\n  }\n  if ( strlen(v5) > 3 )\n    v5 += 3;\n  strncpy(ut_id, v5, v6);\n  sub_80B371B();\n  setutxent();\n  pututxline(&v9);\n  endutxent();\n  return updwtmpx();\n}\n"
    ],
    "sub_80B3832": [
        "0x80b3832",
        "void __userpurge sub_80B3832(__pid_t a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, const char *a4, const char *a5)\n{\n  struct utmpx *v8; // eax\n  struct utmpx *v9; // esi\n  int ut_type; // eax\n  const char *v11; // eax\n  struct utmpx v12; // [esp+0h] [ebp-190h] BYREF\n\n  sub_80B371B();\n  setutxent();\n  while ( 1 )\n  {\n    v8 = getutxent();\n    v9 = v8;\n    if ( !v8 )\n    {\n      if ( a2 == 8 )\n        endutxent();\n      else\n        sub_80B3747(a1, a2, a3, a4, a5);\n      return;\n    }\n    if ( v8->ut_pid == a1 )\n    {\n      if ( v8->ut_id[0] )\n      {\n        ut_type = v8->ut_type;\n        if ( (unsigned __int16)(ut_type - 5) <= 3u )\n          break;\n      }\n    }\n  }\n  if ( ut_type >= a2 )\n    memset(v9->ut_host, 0, sizeof(v9->ut_host));\n  qmemcpy(&v12, v9, sizeof(v12));\n  v12.ut_type = a2;\n  if ( a3 )\n  {\n    v11 = sub_80B2EB2(a3);\n    sub_80B2C4E(v12.ut_line, v11, 32);\n  }\n  if ( a4 )\n    sub_80B2C4E(v12.ut_user, a4, 32);\n  if ( a5 )\n    sub_80B2C4E(v12.ut_host, a5, 256);\n  v12.ut_tv.tv_sec = time(0);\n  pututxline(&v12);\n  endutxent();\n  updwtmpx();\n}\n"
    ],
    "sub_80B3947": [
        "0x80b3947",
        "void __usercall sub_80B3947(__pid_t a1@<eax>)\n{\n  sub_80B3832(a1, 8, 0, 0, 0);\n}\n"
    ],
    "sub_80B3958": [
        "0x80b3958",
        "unsigned int __userpurge sub_80B3958@<eax>(\n        _BYTE *a1@<eax>,\n        _BYTE *a2@<edx>,\n        int a3@<ecx>,\n        unsigned int a4@<ebx>,\n        int a5)\n{\n  unsigned int v5; // esi\n  int i; // ebx\n\n  while ( a3 > 0 )\n  {\n    a3 -= 3;\n    if ( a3 == -2 )\n    {\n      v5 = 0;\n      a4 = 0;\n    }\n    else\n    {\n      a4 = (unsigned __int8)a2[1];\n      v5 = 0;\n      if ( a3 != -1 )\n        v5 = (unsigned __int8)a2[2];\n    }\n    *a1 = *(_BYTE *)(a5 + (*a2 >> 2));\n    a1[1] = *(_BYTE *)(a5 + ((16 * *a2) & 0x30) + (a4 >> 4));\n    a1[2] = *(_BYTE *)(a5 + ((4 * (_BYTE)a4) & 0x3C) + (v5 >> 6));\n    a1 += 4;\n    *(a1 - 1) = *(_BYTE *)(a5 + (v5 & 0x3F));\n    a2 += 3;\n  }\n  *a1 = 0;\n  for ( i = 0; a3 != i; --i )\n    a1[i - 1] = *(_BYTE *)(a5 + 64);\n  return a4;\n}\n"
    ],
    "sub_80B39F1": [
        "0x80b39f1",
        "_BYTE *__usercall sub_80B39F1@<eax>(_BYTE **a1@<eax>, _BYTE *a2@<edx>)\n{\n  _BYTE *v3; // ebx\n  _BYTE *v4; // edi\n  int v5; // esi\n  int v6; // eax\n  char *v7; // eax\n  int v8; // eax\n  unsigned __int8 v9; // al\n  unsigned __int8 v10; // cl\n  _BYTE *v12; // [esp+0h] [ebp-18h]\n  _BYTE *v13; // [esp+0h] [ebp-18h]\n  char v14; // [esp+4h] [ebp-14h]\n  unsigned __int8 v15; // [esp+5h] [ebp-13h]\n  unsigned __int8 v16; // [esp+6h] [ebp-12h]\n  char v17; // [esp+7h] [ebp-11h]\n\n  v3 = *a1;\nLABEL_2:\n  v4 = a2;\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = (unsigned __int8)*v4;\n    if ( !*v4 )\n      break;\n    v12 = a2;\n    ++v4;\n    v7 = strchr(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", v6);\n    a2 = v12;\n    if ( v7 )\n    {\n      v8 = v7 - \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      if ( v8 == 64 )\n      {\n        v13 = v3;\n        if ( v5 > 1 )\n        {\nLABEL_11:\n          v9 = v15;\n          v13 = v3 + 1;\n          *v3 = (v15 >> 4) | (4 * v14);\n          if ( v5 != 2 )\n          {\n            v10 = v16;\n            v13 = v3 + 2;\n            v3[1] = (v16 >> 2) | (16 * v9);\n            if ( v5 == 4 )\n            {\n              v13 = v3 + 3;\n              v3[2] = v17 | (v10 << 6);\n            }\n          }\n        }\n        v3 = v13;\n        a2 = v4;\n        goto LABEL_2;\n      }\n      *(&v14 + v5++) = v8;\n      if ( v5 == 4 )\n        goto LABEL_11;\n    }\n  }\n  if ( !v5 )\n    a2 = v4;\n  *a1 = v3;\n  return a2;\n}\n"
    ],
    "sub_80B3AAF": [
        "0x80b3aaf",
        "int __usercall sub_80B3AAF@<eax>(int a1@<eax>, FILE *a2@<edx>, __int16 a3@<cx>)\n{\n  int v4; // esi\n  unsigned __int8 *v5; // eax\n  int result; // eax\n  int v7; // edi\n  const char *v8; // ebp\n  FILE *v11; // [esp+Ch] [ebp-8Ch]\n  FILE *s; // [esp+10h] [ebp-88h] BYREF\n  int v13[2]; // [esp+14h] [ebp-84h] BYREF\n  char v14[4]; // [esp+46h] [ebp-52h] BYREF\n\n  v4 = 0;\n  v11 = (FILE *)(char)a3;\n  while ( 1 )\n  {\n    while ( v4 <= 63 )\n    {\n      v5 = *(unsigned __int8 **)(a1 + 16);\n      if ( (unsigned int)v5 >= *(_DWORD *)(a1 + 24) )\n      {\n        result = __fgetc_unlocked();\n      }\n      else\n      {\n        *(_DWORD *)(a1 + 16) = v5 + 1;\n        result = *v5;\n      }\n      if ( v11 == (FILE *)result )\n      {\n        if ( !v4 )\n          return result;\nLABEL_13:\n        v7 = 1;\n        goto LABEL_14;\n      }\n      if ( result == -1 )\n        goto LABEL_13;\n      if ( result <= 32 )\n        break;\n      v14[v4++] = result;\n    }\n    v7 = 0;\nLABEL_14:\n    v14[v4] = 0;\n    if ( (a3 & 0x100) != 0 )\n    {\n      result = strcmp(v14, \"====\");\n      if ( !result )\n        return result;\n    }\n    s = (FILE *)v13;\n    v8 = sub_80B39F1((_BYTE **)&s, v14);\n    result = fwrite(v13, (char *)s - (char *)v13, 1u, a2);\n    if ( v7 )\n      break;\n    v4 = strlen(v8);\n    memmove(v14, v8, v4);\n  }\n  if ( *v8 )\n    sub_804D5E0(\"truncated base64 input\");\n  return result;\n}\n"
    ],
    "sub_80B3BA2": [
        "0x80b3ba2",
        "__pid_t __usercall sub_80B3BA2@<eax>(const char **a1@<eax>)\n{\n  __pid_t result; // eax\n\n  sub_804DD8F();\n  result = vfork();\n  if ( !result )\n  {\n    execvp(*a1, (char *const *)a1);\n    _exit(111);\n  }\n  return result;\n}\n"
    ],
    "sub_80B3C03": [
        "0x80b3c03",
        "int __usercall sub_80B3C03@<eax>(const char **a1@<eax>)\n{\n  __pid_t v1; // eax\n  int v2; // ecx\n\n  v1 = sub_80B3BA2(a1);\n  return sub_804DA6B(v1, v2);\n}\n"
    ],
    "sub_80B3C0D": [
        "0x80b3c0d",
        "int __usercall sub_80B3C0D@<eax>(char a1@<al>)\n{\n  int result; // eax\n  int v3; // ebx\n  int v4; // [esp-4h] [ebp-10h]\n\n  if ( (a1 & 1) != 0 )\n    sub_804DF04(\"/\");\n  if ( (a1 & 2) != 0 )\n  {\n    close(0);\n    close(1);\n    close(2);\n  }\n  result = open64();\n  v3 = result;\n  if ( result < 0 )\n  {\n    result = sub_804DBE1(\"/\");\n    v3 = result;\n  }\n  while ( (unsigned int)v3 <= 1 )\n  {\n    result = dup(v3);\n    v3 = result;\n  }\n  if ( (a1 & 8) == 0 )\n  {\n    if ( sub_804E17C()\n      || (setsid(), dup2(v3, 0), dup2(v3, 1), result = dup2(v3, 2), (a1 & 0x10) != 0) && (result = sub_804E17C()) != 0 )\n    {\n      _exit(0);\n    }\n  }\n  while ( v3 > 2 )\n  {\n    close(v3);\n    result = v4;\n    if ( (a1 & 4) == 0 )\n      break;\n    --v3;\n  }\n  return result;\n}\n"
    ],
    "sub_80B3CDB": [
        "0x80b3cdb",
        "int sub_80B3CDB()\n{\n  return sub_80B3C0D(8);\n}\n"
    ],
    "sub_80B3CE5": [
        "0x80b3ce5",
        "int __usercall sub_80B3CE5@<eax>(int result@<eax>)\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  if ( result )\n  {\n    sub_804D5F4(\"ignoring all arguments\");\n    return v1;\n  }\n  return result;\n}\n"
    ],
    "sub_80B3D18": [
        "0x80b3d18",
        "int __usercall sub_80B3D18@<eax>(const char *a1@<eax>)\n{\n  int v2; // ebx\n\n  v2 = fopen64();\n  if ( !v2 )\n    sub_804D3F1(a1);\n  return v2;\n}\n"
    ],
    "sub_80B3D37": [
        "0x80b3d37",
        "int sub_80B3D37()\n{\n  return fopen64();\n}\n"
    ],
    "sub_80B3D45": [
        "0x80b3d45",
        "int __usercall sub_80B3D45@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBA5(a1);\n}\n"
    ],
    "sub_80B3D4F": [
        "0x80b3d4f",
        "int sub_80B3D4F()\n{\n  return fopen64();\n}\n"
    ],
    "sub_80B3D5D": [
        "0x80b3d5d",
        "int __usercall sub_80B3D5D@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBA5(a1);\n}\n"
    ],
    "sub_80B3D67": [
        "0x80b3d67",
        "FILE *__usercall sub_80B3D67@<eax>(int a1@<eax>)\n{\n  const char *v1; // edx\n  FILE *result; // eax\n  unsigned int v3; // eax\n  int v4; // [esp-8h] [ebp-8h]\n  int v5; // [esp-4h] [ebp-4h]\n\n  v3 = 2 * a1;\n  v1 = \"w\";\n  if ( (v3 & 1) == 0 )\n    v1 = \"r\";\n  result = fdopen(v3 >> 1, v1);\n  if ( !result )\n    sub_804DAC9(v5, v4);\n  return result;\n}\n"
    ],
    "sub_80B3D6E": [
        "0x80b3d6e",
        "FILE *__usercall sub_80B3D6E@<eax>(int a1@<eax>)\n{\n  const char *v1; // edx\n  FILE *result; // eax\n  unsigned int v3; // eax\n  int v4; // [esp-8h] [ebp-8h]\n  int v5; // [esp-4h] [ebp-4h]\n\n  v3 = 2 * a1 + 1;\n  v1 = \"w\";\n  if ( (v3 & 1) == 0 )\n    v1 = \"r\";\n  result = fdopen(v3 >> 1, v1);\n  if ( !result )\n    sub_804DAC9(v5, v4);\n  return result;\n}\n"
    ],
    "sub_80B3D76": [
        "0x80b3d76",
        "FILE *__usercall sub_80B3D76@<eax>(int a1@<eax>)\n{\n  if ( (char *)a1 == \"standard input\" || *(_BYTE *)a1 == 45 && !*(_BYTE *)(a1 + 1) )\n    return stdin;\n  else\n    return (FILE *)sub_80B3D18((const char *)a1);\n}\n"
    ],
    "sub_80B3D9B": [
        "0x80b3d9b",
        "FILE *__usercall sub_80B3D9B@<eax>(int a1@<eax>)\n{\n  FILE *result; // eax\n\n  result = sub_80B3D76(a1);\n  if ( !result )\n    sub_804D604();\n  return result;\n}\n"
    ],
    "sub_80B3DAA": [
        "0x80b3daa",
        "int __usercall sub_80B3DAA@<eax>(int a1@<eax>)\n{\n  if ( (char *)a1 == \"standard input\" || *(_BYTE *)a1 == 45 && !*(_BYTE *)(a1 + 1) )\n    return 0;\n  else\n    return sub_804DC14((const char *)a1);\n}\n"
    ],
    "sub_80B3DC6": [
        "0x80b3dc6",
        "int __usercall sub_80B3DC6@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = sub_80B3DAA(a1);\n  if ( result < 0 )\n    sub_804D604();\n  return result;\n}\n"
    ],
    "sub_80B3DD5": [
        "0x80b3dd5",
        "unsigned __int64 __userpurge sub_80B3DD5@<edx:eax>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        int a3,\n        unsigned __int64 a4,\n        unsigned __int64 a5,\n        int a6)\n{\n  int v6; // ebx\n  char v7; // al\n  unsigned __int8 v8; // al\n  _DWORD *v9; // esi\n  int v10; // edi\n  char *v11; // edx\n  unsigned int v12; // edi\n  int v13; // eax\n  int v14; // ecx\n  char *v16; // [esp+4h] [ebp-34h]\n  unsigned __int64 v18; // [esp+1Ch] [ebp-1Ch]\n  char *endptr; // [esp+24h] [ebp-14h] BYREF\n\n  v6 = a6;\n  v7 = *a1;\n  if ( ((v7 - 43) & 0xFD) == 0 )\n    goto LABEL_17;\n  v8 = v7 - 9;\n  if ( v8 <= 4u )\n    goto LABEL_17;\n  if ( v8 == 23 )\n    goto LABEL_17;\n  v9 = (_DWORD *)dword_80DBB7C;\n  v10 = *(_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v18 = strtoull(a1, &endptr, a2);\n  if ( *v9 )\n    goto LABEL_17;\n  v11 = endptr;\n  if ( endptr == a1 )\n    goto LABEL_17;\n  *v9 = v10;\n  if ( !a6 )\n  {\nLABEL_13:\n    if ( !*v11 )\n      goto LABEL_14;\nLABEL_17:\n    sub_804D5E0(\"invalid number '%s'\", a1);\n  }\n  while ( 1 )\n  {\n    v12 = *(_DWORD *)(v6 + 4);\n    if ( !v12 )\n      goto LABEL_13;\n    v16 = v11;\n    v13 = strcmp((const char *)v6, v11);\n    v11 = v16;\n    if ( !v13 )\n      break;\n    v6 += 8;\n  }\n  if ( HIDWORD(v18)\n    && (v12 * (unsigned __int64)HIDWORD(v18) + ((v12 * (unsigned __int64)(unsigned int)v18) >> 32)) >> 32 )\n  {\nLABEL_16:\n    sub_804D5E0(\"number %s is not in %llu..%llu range\", a1, a4, a5);\n  }\n  v14 = v12 * HIDWORD(v18);\n  v18 = v12 * (unsigned __int64)(unsigned int)v18;\n  HIDWORD(v18) += v14;\nLABEL_14:\n  if ( v18 < a4 || v18 > a5 )\n    goto LABEL_16;\n  return v18;\n}\n"
    ],
    "sub_80B3F1E": [
        "0x80b3f1e",
        "unsigned __int64 __userpurge sub_80B3F1E@<edx:eax>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        int a3,\n        unsigned __int64 a4,\n        unsigned int a5)\n{\n  int v6; // [esp+0h] [ebp-4h]\n\n  return sub_80B3DD5(a1, a2, a3, a4, a5, v6);\n}\n"
    ],
    "sub_80B3F3E": [
        "0x80b3f3e",
        "unsigned __int64 __usercall sub_80B3F3E@<edx:eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  unsigned __int64 v4; // [esp-8h] [ebp-Ch]\n  int v5; // [esp+0h] [ebp-4h]\n\n  HIDWORD(v4) = a3;\n  LODWORD(v4) = -1;\n  return sub_80B3DD5(a1, a2, 0, 0xFFFFFFFF00000000LL, v4, v5);\n}\n"
    ],
    "sub_80B3F55": [
        "0x80b3f55",
        "unsigned __int64 __usercall sub_80B3F55@<edx:eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v3; // [esp+0h] [ebp-4h]\n\n  return sub_80B3DD5(a1, a2, 0, 0xFFFFFFFF00000000LL, 0xFFFFFFFFuLL, v3);\n}\n"
    ],
    "sub_80B3F6D": [
        "0x80b3f6d",
        "unsigned __int64 __userpurge sub_80B3F6D@<edx:eax>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        unsigned int a3@<ecx>,\n        unsigned int a4,\n        unsigned int a5)\n{\n  int v6; // [esp+0h] [ebp-4h]\n\n  return sub_80B3DD5(a1, 10, a2, __PAIR64__(a4, a3), a5, v6);\n}\n"
    ],
    "sub_80B3F8E": [
        "0x80b3f8e",
        "unsigned __int64 __usercall sub_80B3F8E@<edx:eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  unsigned __int64 v3; // [esp-8h] [ebp-Ch]\n  int v4; // [esp+0h] [ebp-4h]\n\n  HIDWORD(v3) = a2;\n  LODWORD(v3) = -1;\n  return sub_80B3DD5(a1, 10, 0, 0xFFFFFFFF00000000LL, v3, v4);\n}\n"
    ],
    "sub_80B3FAA": [
        "0x80b3faa",
        "unsigned __int64 __usercall sub_80B3FAA@<edx:eax>(const char *a1@<eax>)\n{\n  return sub_80B3F8E(a1, 0);\n}\n"
    ],
    "sub_80B3FB7": [
        "0x80b3fb7",
        "unsigned int __userpurge sub_80B3FB7@<eax>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        unsigned int a3@<ecx>,\n        unsigned int a4,\n        char *s1)\n{\n  char *v6; // edi\n  char v7; // al\n  unsigned __int8 v8; // al\n  _DWORD *v9; // ebp\n  unsigned int v10; // ebx\n  char *v11; // edx\n  unsigned int v12; // ebp\n  int v13; // eax\n  bool v14; // of\n  int v17; // [esp+4h] [ebp-18h]\n  char *v18; // [esp+4h] [ebp-18h]\n  char *endptr; // [esp+8h] [ebp-14h] BYREF\n\n  v6 = s1;\n  v7 = *a1;\n  if ( ((v7 - 43) & 0xFD) == 0 )\n    goto LABEL_16;\n  v8 = v7 - 9;\n  if ( v8 <= 4u )\n    goto LABEL_16;\n  if ( v8 == 23 )\n    goto LABEL_16;\n  v9 = (_DWORD *)dword_80DBB7C;\n  v17 = *(_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v10 = strtoul(a1, &endptr, a2);\n  if ( *v9 )\n    goto LABEL_16;\n  v11 = endptr;\n  if ( endptr == a1 )\n    goto LABEL_16;\n  *v9 = v17;\n  if ( !s1 )\n  {\nLABEL_12:\n    if ( !*v11 )\n      goto LABEL_13;\nLABEL_16:\n    sub_804D5E0(\"invalid number '%s'\", a1);\n  }\n  while ( 1 )\n  {\n    v12 = *((_DWORD *)v6 + 1);\n    if ( !v12 )\n      goto LABEL_12;\n    v18 = v11;\n    v13 = strcmp(v6, v11);\n    v11 = v18;\n    if ( !v13 )\n      break;\n    v6 += 8;\n  }\n  v14 = (v12 * (unsigned __int64)v10) >> 32 != 0;\n  v10 *= v12;\n  if ( v14 )\nLABEL_15:\n    sub_804D5E0(\"number %s is not in %llu..%llu range\", a1, (unsigned __int64)a3, (unsigned __int64)a4);\nLABEL_13:\n  if ( v10 < a3 || v10 > a4 )\n    goto LABEL_15;\n  return v10;\n}\n"
    ],
    "sub_80B4093": [
        "0x80b4093",
        "unsigned int __userpurge sub_80B4093@<eax>(const char *a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4)\n{\n  return sub_80B3FB7(a1, a2, a3, a4, 0);\n}\n"
    ],
    "sub_80B40A1": [
        "0x80b40a1",
        "unsigned int __usercall sub_80B40A1@<eax>(const char *a1@<eax>, int a2@<edx>, char *a3@<ecx>)\n{\n  return sub_80B3FB7(a1, a2, 0, 0xFFFFFFFF, a3);\n}\n"
    ],
    "sub_80B40AC": [
        "0x80b40ac",
        "unsigned int __usercall sub_80B40AC@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  return sub_80B3FB7(a1, a2, 0, 0xFFFFFFFF, 0);\n}\n"
    ],
    "sub_80B40B8": [
        "0x80b40b8",
        "unsigned int __userpurge sub_80B40B8@<eax>(\n        const char *a1@<eax>,\n        unsigned int a2@<edx>,\n        unsigned int a3@<ecx>,\n        char *a4)\n{\n  return sub_80B3FB7(a1, 10, a2, a3, a4);\n}\n"
    ],
    "sub_80B40CC": [
        "0x80b40cc",
        "unsigned int __usercall sub_80B40CC@<eax>(const char *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)\n{\n  return sub_80B3FB7(a1, 10, a2, a3, 0);\n}\n"
    ],
    "sub_80B40DC": [
        "0x80b40dc",
        "unsigned int __usercall sub_80B40DC@<eax>(const char *a1@<eax>, char *a2@<edx>)\n{\n  return sub_80B3FB7(a1, 10, 0, 0xFFFFFFFF, a2);\n}\n"
    ],
    "sub_80B40EC": [
        "0x80b40ec",
        "unsigned int __usercall sub_80B40EC@<eax>(const char *a1@<eax>)\n{\n  return sub_80B40DC(a1, 0);\n}\n"
    ],
    "sub_80B40F3": [
        "0x80b40f3",
        "signed int __userpurge sub_80B40F3@<eax>(\n        const char *a1@<eax>,\n        int a2@<edx>,\n        signed int a3@<ecx>,\n        signed int a4,\n        char *a5)\n{\n  const char *v5; // ebx\n  unsigned int v7; // ecx\n  signed int result; // eax\n\n  v5 = a1;\n  if ( ((*a1 - 43) & 0xFD) != 0 )\n  {\n    v7 = 0x7FFFFFFF;\n  }\n  else\n  {\n    ++a1;\n    v7 = (v5[1] == 45) + 0x7FFFFFFF;\n  }\n  result = sub_80B3FB7(a1, a2, 0, v7, a5);\n  if ( *v5 == 45 )\n    result = -result;\n  if ( result > a4 || result < a3 )\n    sub_804D5E0(\"number %s is not in %lld..%lld range\", v5, (__int64)a3, (__int64)a4);\n  return result;\n}\n"
    ],
    "sub_80B4160": [
        "0x80b4160",
        "signed int __usercall sub_80B4160@<eax>(const char *a1@<eax>, signed int a2@<edx>, signed int a3@<ecx>)\n{\n  return sub_80B40F3(a1, 10, a2, a3, 0);\n}\n"
    ],
    "sub_80B4170": [
        "0x80b4170",
        "signed int __usercall sub_80B4170@<eax>(const char *a1@<eax>)\n{\n  return sub_80B40F3(a1, 10, 0x80000000, 0x7FFFFFFF, 0);\n}\n"
    ],
    "sub_80B4187": [
        "0x80b4187",
        "unsigned int __usercall sub_80B4187@<eax>(const char *a1@<eax>)\n{\n  return sub_80B40CC(a1, 0, 0x7FFFFFFFu);\n}\n"
    ],
    "sub_80B4193": [
        "0x80b4193",
        "unsigned int __usercall sub_80B4193@<eax>(const char *a1@<eax>)\n{\n  return sub_80B40CC(a1, 0, 0xFFFFu);\n}\n"
    ],
    "sub_80B41A0": [
        "0x80b41a0",
        "char *__usercall sub_80B41A0@<eax>(const struct sockaddr *a1@<eax>, int a2@<edx>)\n{\n  char v3; // bp\n  char serv[16]; // [esp+0h] [ebp-A0h] BYREF\n  char host[144]; // [esp+10h] [ebp-90h] BYREF\n\n  v3 = a2;\n  if ( getnameinfo(a1, a1->sa_family != 2 ? 28 : 16, host, 0x80u, serv, 0x10u, a2 | 2) )\n    return 0;\n  if ( (v3 & 2) != 0 )\n    return sub_804DB46(host);\n  if ( a1->sa_family == 10 && strchr(host, 58) )\n    return sub_804DDBF(\"[%s]:%s\", host, serv);\n  return sub_804DDBF((char *)\"%s:%s\", host, serv);\n}\n"
    ],
    "sub_80B422B": [
        "0x80b422b",
        "int __userpurge sub_80B422B@<eax>(int optname@<ecx>, int level@<edx>, int a3@<eax>, char optval)\n{\n  return setsockopt(a3, level, optname, &optval, 4u);\n}\n"
    ],
    "sub_80B4242": [
        "0x80b4242",
        "int __usercall sub_80B4242@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  return sub_80B422B(a3, a2, a1, 1);\n}\n"
    ],
    "sub_80B424A": [
        "0x80b424a",
        "int __usercall sub_80B424A@<eax>(char optval@<cl>, int optname@<edx>, int a3@<eax>)\n{\n  return sub_80B422B(optname, 1, a3, optval);\n}\n"
    ],
    "sub_80B4258": [
        "0x80b4258",
        "int __usercall sub_80B4258@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_80B424A(1, a2, a1);\n}\n"
    ],
    "sub_80B4262": [
        "0x80b4262",
        "int __usercall sub_80B4262@<eax>(int a1@<eax>)\n{\n  return sub_80B4258(a1, 2);\n}\n"
    ],
    "sub_80B426C": [
        "0x80b426c",
        "int __usercall sub_80B426C@<eax>(int a1@<eax>)\n{\n  return sub_80B4258(a1, 6);\n}\n"
    ],
    "sub_80B4276": [
        "0x80b4276",
        "int __usercall sub_80B4276@<eax>(int a1@<eax>)\n{\n  return sub_80B4258(a1, 9);\n}\n"
    ],
    "sub_80B4280": [
        "0x80b4280",
        "int __usercall sub_80B4280@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n  int v5; // [esp+0h] [ebp-30h]\n  char optval[44]; // [esp+4h] [ebp-2Ch] BYREF\n\n  sub_804D67E(optval, a2);\n  result = setsockopt(a1, 1, 25, optval, 0x20u);\n  if ( result )\n  {\n    v5 = result;\n    sub_804D3A5((int)\"can't bind to interface %s\", a2);\n    return v5;\n  }\n  return result;\n}\n"
    ],
    "sub_80B42C3": [
        "0x80b42c3",
        "int __usercall sub_80B42C3@<eax>(socklen_t len@<ecx>, struct sockaddr *addr@<edx>, int a3@<eax>)\n{\n  int result; // eax\n  char *v5; // eax\n\n  result = connect(a3, addr, len);\n  if ( result < 0 )\n  {\n    if ( addr->sa_family == 2 )\n    {\n      v5 = inet_ntoa(*(struct in_addr *)&addr->sa_data[2]);\n      sub_804D3C9(135061425, \"can't connect to remote host\", v5);\n    }\n    sub_804D3C9((int)\"can't connect to remote host\");\n  }\n  return result;\n}\n"
    ],
    "sub_80B42FF": [
        "0x80b42ff",
        "int __usercall sub_80B42FF@<eax>(const char *a1@<eax>, const char *a2@<edx>, __int16 a3@<cx>)\n{\n  unsigned __int16 v3; // bx\n  int v6; // edi\n  unsigned int v7; // edx\n  struct servent *v8; // eax\n\n  v3 = a3;\n  if ( a1 )\n  {\n    v6 = *(_DWORD *)dword_80DBB7C;\n    v7 = sub_804ED6C(10, a1, 0, a3);\n    if ( *(_DWORD *)dword_80DBB7C || v7 > 0xFFFF )\n    {\n      v8 = getservbyname(a1, a2);\n      LOWORD(v7) = v3;\n      if ( v8 )\n      {\n        BYTE1(v7) = v8->s_port;\n        LOBYTE(v7) = BYTE1(v8->s_port);\n      }\n    }\n    *(_DWORD *)dword_80DBB7C = v6;\n    return (unsigned __int16)v7;\n  }\n  return v3;\n}\n"
    ],
    "sub_80B435E": [
        "0x80b435e",
        "_WORD *__usercall sub_80B435E@<eax>(_WORD *result@<eax>, __int16 a2@<dx>)\n{\n  if ( *result == 10 || *result == 2 )\n    result[1] = a2;\n  return result;\n}\n"
    ],
    "sub_80B4372": [
        "0x80b4372",
        "_WORD *__usercall sub_80B4372@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4)\n{\n  char *v4; // ebx\n  char *v5; // eax\n  char *v6; // esi\n  char v7; // al\n  _WORD *v8; // ebx\n  struct addrinfo *v9; // esi\n  unsigned int ai_addrlen; // ecx\n  __int16 v11; // dx\n  void *v12; // esp\n  int v14; // [esp+0h] [ebp-3Ch] BYREF\n  unsigned int v15; // [esp+4h] [ebp-38h]\n  char *s; // [esp+8h] [ebp-34h]\n  struct addrinfo *pai; // [esp+Ch] [ebp-30h] BYREF\n  struct addrinfo buf; // [esp+10h] [ebp-2Ch] BYREF\n\n  s = a1;\n  v15 = a2;\n  v14 = a3;\n  pai = 0;\n  if ( *a1 == 91 )\n  {\n    v4 = a1 + 1;\n    v5 = strchr(a1 + 1, 93);\n    v6 = v5;\n    if ( !v5 || (v7 = v5[1]) != 0 && v7 != 58 )\n    {\n      sub_804D5F4(\"bad address '%s'\", s);\n      goto LABEL_6;\n    }\n  }\n  else\n  {\n    v6 = strrchr(s, 58);\n    if ( !v6 )\n    {\n      v4 = s;\n      goto LABEL_12;\n    }\n    v4 = s;\n    if ( strchr(s, 58) != v6 )\n      goto LABEL_12;\n  }\n  v12 = alloca(v6 - v4 + 16);\n  v4 = sub_80B2C4E((char *)&v14, v4, v6 - v4 + 1);\n  if ( *v6 != 58 )\n  {\n    if ( !v6[1] )\n      goto LABEL_12;\n    ++v6;\n  }\n  v15 = sub_804ED6C(10, v6 + 1, 0, (int)v4);\n  if ( !*(_DWORD *)dword_80DBB7C && v15 <= 0xFFFF )\n  {\nLABEL_12:\n    if ( (_WORD)v14 != 10 )\n    {\n      if ( inet_aton(v4, (struct in_addr *)&buf) )\n      {\n        v8 = sub_804DB2E(0x14u);\n        *(_DWORD *)v8 = 16;\n        v8[2] = 2;\n        *((_DWORD *)v8 + 2) = buf.ai_flags;\n        goto LABEL_27;\n      }\n      if ( (_WORD)v14 == 2 )\n        goto LABEL_18;\n    }\n    if ( inet_pton(10, v4, &buf) <= 0 )\n    {\nLABEL_18:\n      memset(&buf.ai_protocol, 0, 0x14u);\n      buf.ai_family = (unsigned __int16)v14;\n      buf.ai_socktype = 1;\n      buf.ai_flags = a4 & 0xFFFFFFFD;\n      if ( getaddrinfo(v4, 0, &buf, &pai) || !pai )\n      {\n        sub_804D5F4(\"bad address '%s'\", s);\n        v8 = 0;\n        if ( (a4 & 2) != 0 )\nLABEL_7:\n          sub_804D604();\n        goto LABEL_28;\n      }\n      v9 = pai;\n      while ( v9->ai_family != 2 )\n      {\n        v9 = v9->ai_next;\n        if ( !v9 )\n        {\n          v9 = pai;\n          break;\n        }\n      }\n      v8 = sub_804DAFA(v9->ai_addrlen + 4);\n      ai_addrlen = v9->ai_addrlen;\n      *(_DWORD *)v8 = ai_addrlen;\n      qmemcpy(v8 + 2, v9->ai_addr, ai_addrlen);\n    }\n    else\n    {\n      v8 = sub_804DB2E(0x20u);\n      *(_DWORD *)v8 = 28;\n      v8[2] = 10;\n      qmemcpy(v8 + 6, &buf, 0x10u);\n    }\nLABEL_27:\n    LOBYTE(v11) = BYTE1(v15);\n    HIBYTE(v11) = v15;\n    sub_80B435E(v8 + 2, v11);\nLABEL_28:\n    if ( pai )\n      freeaddrinfo(pai);\n    return v8;\n  }\n  sub_804D5F4(\"bad port spec '%s'\", s);\nLABEL_6:\n  v8 = 0;\n  if ( (a4 & 2) != 0 )\n    goto LABEL_7;\n  return v8;\n}\n"
    ],
    "sub_80B459A": [
        "0x80b459a",
        "_WORD *__usercall sub_80B459A@<eax>(char *a1@<eax>, unsigned int a2@<edx>, unsigned __int16 a3@<cx>)\n{\n  return sub_80B4372(a1, a2, a3, 0);\n}\n"
    ],
    "sub_80B45A6": [
        "0x80b45a6",
        "_WORD *__usercall sub_80B45A6@<eax>(char *a1@<eax>, unsigned int a2@<edx>, unsigned __int16 a3@<cx>)\n{\n  return sub_80B4372(a1, a2, a3, 2);\n}\n"
    ],
    "sub_80B45B2": [
        "0x80b45b2",
        "_WORD *__usercall sub_80B45B2@<eax>(char *a1@<eax>, unsigned int a2@<edx>)\n{\n  return sub_80B4372(a1, a2, 0, 0);\n}\n"
    ],
    "sub_80B45BD": [
        "0x80b45bd",
        "_WORD *__usercall sub_80B45BD@<eax>(char *a1@<eax>, unsigned int a2@<edx>)\n{\n  return sub_80B4372(a1, a2, 0, 2);\n}\n"
    ],
    "sub_80B45C8": [
        "0x80b45c8",
        "_WORD *__usercall sub_80B45C8@<eax>(char *a1@<eax>, unsigned int a2@<edx>)\n{\n  return sub_80B4372(a1, a2, 0, 6);\n}\n"
    ],
    "sub_80B45D3": [
        "0x80b45d3",
        "int __usercall sub_80B45D3@<eax>(int type@<ecx>, _DWORD *a2@<eax>, int a3@<edx>)\n{\n  int v5; // edi\n  int v6; // esi\n  int v7; // ebx\n  _WORD *v8; // eax\n\n  if ( a3 )\n  {\n    v6 = a3;\n  }\n  else\n  {\n    v5 = socket(10, type, 0);\n    v6 = 2;\n    if ( v5 >= 0 )\n    {\n      v7 = 28;\n      LOWORD(v6) = 10;\n      goto LABEL_7;\n    }\n  }\n  v5 = sub_804DF99(0, type, v6);\n  v7 = 110;\n  if ( v6 != 1 )\n    v7 = v6 == 10 ? 28 : 16;\nLABEL_7:\n  v8 = sub_804DB2E(v7 + 4);\n  *(_DWORD *)v8 = v7;\n  v8[2] = v6;\n  *a2 = v8;\n  return v5;\n}\n"
    ],
    "sub_80B4645": [
        "0x80b4645",
        "int __usercall sub_80B4645@<eax>(char *a1@<eax>, unsigned int a2@<edx>)\n{\n  _WORD *v2; // ebx\n  int v3; // esi\n\n  v2 = sub_80B45BD(a1, a2);\n  v3 = sub_804DF99(0, 1, (unsigned __int16)v2[2]);\n  sub_80B4262(v3);\n  sub_80B42C3(*(_DWORD *)v2, (struct sockaddr *)(v2 + 2), v3);\n  free(v2);\n  return v3;\n}\n"
    ],
    "sub_80B467D": [
        "0x80b467d",
        "int __usercall sub_80B467D@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n\n  v2 = sub_804DF99(0, 1, *(unsigned __int16 *)(a1 + 4));\n  sub_80B42C3(*(_DWORD *)a1, (struct sockaddr *)(a1 + 4), v2);\n  return v2;\n}\n"
    ],
    "sub_80B46A2": [
        "0x80b46a2",
        "char *__usercall sub_80B46A2@<eax>(const struct sockaddr *a1@<eax>)\n{\n  return sub_80B41A0(a1, 2);\n}\n"
    ],
    "sub_80B46AC": [
        "0x80b46ac",
        "char *__usercall sub_80B46AC@<eax>(const struct sockaddr *a1@<eax>)\n{\n  return sub_80B41A0(a1, 1);\n}\n"
    ],
    "sub_80B46B6": [
        "0x80b46b6",
        "char *__usercall sub_80B46B6@<eax>(const struct sockaddr *a1@<eax>)\n{\n  return sub_80B41A0(a1, 3);\n}\n"
    ],
    "sub_80B46C0": [
        "0x80b46c0",
        "void *__usercall sub_80B46C0@<eax>(void *a1@<eax>)\n{\n  size_t v2; // esi\n  size_t v4; // eax\n\n  v2 = 128;\n  while ( 1 )\n  {\n    v2 += 64;\n    a1 = sub_804DB13(a1, v2);\n    if ( getcwd((char *)a1, v2) )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 34 )\n    {\n      free(a1);\n      sub_804D3A5((int)\"getcwd\");\n      return 0;\n    }\n  }\n  v4 = strlen((const char *)a1);\n  return sub_804DB13(a1, v4 + 1);\n}\n"
    ],
    "sub_80B4718": [
        "0x80b4718",
        "struct hostent *__usercall sub_80B4718@<eax>(const char *a1@<eax>)\n{\n  struct hostent *result; // eax\n\n  result = gethostbyname(a1);\n  if ( !result )\n    sub_80AD05E(\"%s\", a1);\n  return result;\n}\n"
    ],
    "sub_80B4733": [
        "0x80b4733",
        "char *__usercall sub_80B4733@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)\n{\n  char *v3; // ebx\n  int v5; // esi\n  unsigned int v6; // ebp\n\n  v3 = a1;\n  v5 = 1 << a2;\n  if ( (a3 & ((1 << a2) - 1)) == 0 )\n  {\n    v6 = a2 >> 8;\n    v3 = (char *)sub_804DB13(a1, (a2 >> 8) * (v5 + a3 + 1));\n    memset(&v3[v6 * a3], 0, v6 * (v5 + 1));\n  }\n  return v3;\n}\n"
    ],
    "sub_80B477A": [
        "0x80b477a",
        "char *__usercall sub_80B477A@<eax>(int cflags@<ecx>, char *pattern@<edx>, regex_t *a3@<eax>)\n{\n  int v4; // eax\n  char *v5; // ebx\n  int v6; // esi\n  size_t v7; // ebp\n\n  v4 = regcomp(a3, pattern, cflags);\n  v5 = 0;\n  if ( v4 )\n  {\n    v6 = v4;\n    v7 = regerror(v4, a3, 0, 0);\n    v5 = (char *)sub_804DAFA(v7);\n    regerror(v6, a3, v5, v7);\n  }\n  return v5;\n}\n"
    ],
    "sub_80B47BA": [
        "0x80b47ba",
        "char *__usercall sub_80B47BA@<eax>(regex_t *a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  char *result; // eax\n\n  result = sub_80B477A(a3, a2, a1);\n  if ( result )\n    sub_804D5E0(\"bad regex '%s': %s\", a2, result);\n  return result;\n}\n"
    ],
    "sub_80B47D4": [
        "0x80b47d4",
        "int sub_80B47D4()\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  sub_804D3A5(0);\n  return v1;\n}\n"
    ],
    "sub_80B47DD": [
        "0x80b47dd",
        "int __usercall sub_80B47DD@<eax>(_DWORD *a1@<eax>, const char *a2@<edx>)\n{\n  const char *v3; // edi\n  char *v4; // eax\n  const char *v5; // ebx\n  void *v6; // esp\n  int v7; // edx\n  struct passwd *v8; // eax\n  __gid_t pw_gid; // edx\n  struct passwd *v10; // eax\n  int v11; // edi\n  int gr_gid; // eax\n  struct group *v13; // eax\n  int v15; // [esp-4h] [ebp-10h]\n  char v16[8]; // [esp+4h] [ebp-8h] BYREF\n\n  v3 = a2;\n  v4 = strchr(a2, 58);\n  v5 = v4;\n  if ( v4 )\n  {\n    v5 = v4 + 1;\n    v6 = alloca(v4 + 1 - v3 + 15);\n    sub_80B2C4E(v16, v3, v4 + 1 - v3);\n    v3 = v16;\n  }\n  v7 = sub_804ED6C(10, v3, 0, (int)v5);\n  if ( *(_DWORD *)dword_80DBB7C )\n  {\n    v10 = getpwnam(v3);\n    if ( !v10 )\n      return 0;\n    *a1 = v10->pw_uid;\n    a1[1] = v10->pw_gid;\n  }\n  else\n  {\n    *a1 = v7;\n    v15 = v7;\n    v8 = getpwuid(v7);\n    pw_gid = v15;\n    if ( v8 )\n      pw_gid = v8->pw_gid;\n    a1[1] = pw_gid;\n  }\n  v11 = 1;\n  if ( !v5 )\n    return v11;\n  gr_gid = sub_804ED6C(10, v5, 0, (int)v5);\n  if ( !*(_DWORD *)dword_80DBB7C )\n  {\nLABEL_14:\n    a1[1] = gr_gid;\n    return v11;\n  }\n  v13 = getgrnam(v5);\n  if ( v13 )\n  {\n    gr_gid = v13->gr_gid;\n    goto LABEL_14;\n  }\n  return 0;\n}\n"
    ],
    "sub_80B48BE": [
        "0x80b48be",
        "int __usercall sub_80B48BE@<eax>(int *a1@<eax>, const char *a2@<edx>)\n{\n  char *v4; // eax\n  int result; // eax\n\n  a1[1] = -1;\n  *a1 = -1;\n  v4 = strchr(a2, 46);\n  if ( v4 )\n  {\n    *v4 = 58;\n  }\n  else\n  {\n    v4 = strchr(a2, 58);\n    if ( !v4 )\n    {\n      result = sub_80A9A55(a2, (int (*)(void))sub_80A9A43);\n      *a1 = result;\n      return result;\n    }\n  }\n  if ( a2 == v4 )\n  {\n    result = sub_80A9A55(a2 + 1, (int (*)(void))sub_80A9A4C);\n    a1[1] = result;\n  }\n  else\n  {\n    if ( !v4[1] )\n      *v4 = 0;\n    result = sub_80B47DD(a1, a2);\n    if ( !result )\n      sub_804D5E0(\"unknown user/group %s\", a2);\n  }\n  return result;\n}\n"
    ],
    "sub_80B492D": [
        "0x80b492d",
        "__int64 __cdecl sub_80B492D(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n  unsigned int v3; // edi\n  unsigned int v4; // esi\n  unsigned int v5; // ebx\n  unsigned __int64 v6; // kr08_8\n  int v7; // eax\n  int v8; // ebx\n  unsigned int v9; // eax\n  bool v10; // cf\n  int v11; // edx\n  unsigned __int64 v12; // rtt\n  unsigned int v13; // esi\n  int v14; // edi\n  unsigned __int64 v15; // rax\n  __int64 result; // rax\n  unsigned int v17; // [esp+Ch] [ebp-2Ch]\n  int v18; // [esp+14h] [ebp-24h]\n  char v19; // [esp+1Ch] [ebp-1Ch]\n\n  v18 = 0;\n  v2 = a1;\n  v3 = HIDWORD(a2);\n  v4 = a2;\n  if ( a1 < 0 )\n  {\n    v18 = -1;\n    v2 = -a1;\n  }\n  if ( a2 < 0 )\n  {\n    v4 = -(int)a2;\n    v18 = ~v18;\n    v3 = (unsigned __int64)-a2 >> 32;\n  }\n  v5 = v4;\n  v6 = v2;\n  if ( !v3 )\n  {\n    if ( v4 <= HIDWORD(v2) )\n    {\n      if ( !v4 )\n        v5 = 1 / 0u;\n      v3 = HIDWORD(v2) / v5;\n      v7 = __PAIR64__(HIDWORD(v2) % v5, v2) / v5;\n    }\n    else\n    {\n      v7 = v2 / v4;\n    }\n    v8 = v7;\n    goto LABEL_24;\n  }\n  if ( v3 > HIDWORD(v2) )\n  {\n    v3 = 0;\nLABEL_22:\n    v8 = 0;\n    goto LABEL_24;\n  }\n  _BitScanReverse(&v9, v3);\n  v19 = v9 ^ 0x1F;\n  if ( v9 == 0x1F )\n  {\n    v10 = v3 < HIDWORD(v2);\n    v3 = 0;\n    if ( v10 || v4 <= (unsigned int)v6 )\n    {\n      v8 = 1;\n      goto LABEL_24;\n    }\n    goto LABEL_22;\n  }\n  v11 = (v3 << v19) | (v4 >> (32 - v19));\n  v17 = v4 << v19;\n  LODWORD(v12) = (HIDWORD(v6) << v19) | ((unsigned int)v6 >> (32 - v19));\n  HIDWORD(v12) = HIDWORD(v6) >> (32 - v19);\n  v13 = v12 % (unsigned int)v11;\n  v14 = v12 / (unsigned int)v11;\n  v8 = v14;\n  v15 = v17 * (unsigned __int64)(unsigned int)v14;\n  if ( v13 < HIDWORD(v15) || (_DWORD)v6 << v19 < v17 * v14 && v13 == HIDWORD(v15) )\n    v8 = v14 - 1;\n  v3 = 0;\nLABEL_24:\n  result = __PAIR64__(v3, v8);\n  if ( v18 )\n    return -__SPAIR64__(v3, v8);\n  return result;\n}\n"
    ],
    "sub_80B4A4A": [
        "0x80b4a4a",
        "int __cdecl sub_80B4A4A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n  unsigned int v3; // esi\n  int v4; // ebx\n  unsigned __int64 v5; // kr00_8\n  unsigned __int64 v6; // rax\n  unsigned __int64 v7; // kr08_8\n  unsigned __int64 v8; // rtt\n  unsigned __int64 v9; // rdi\n  unsigned __int64 v10; // rax\n  unsigned int v11; // ecx\n  unsigned int v12; // ebx\n  __int64 v13; // rax\n  unsigned __int64 v14; // rdi\n  __int64 v16; // [esp+4h] [ebp-34h]\n  int v17; // [esp+Ch] [ebp-2Ch]\n  __int64 v18; // [esp+10h] [ebp-28h]\n  unsigned int v19; // [esp+1Ch] [ebp-1Ch]\n\n  v17 = 0;\n  v18 = a1;\n  v2 = a2;\n  if ( a1 < 0 )\n  {\n    v17 = -1;\n    v18 = -a1;\n  }\n  if ( a2 < 0 )\n    v2 = -a2;\n  v3 = v2;\n  v5 = v18;\n  v4 = HIDWORD(v5);\n  LODWORD(v2) = v5;\n  v19 = v18;\n  if ( !HIDWORD(v2) )\n  {\n    HIDWORD(v2) = HIDWORD(v18);\n    if ( v3 <= HIDWORD(v18) )\n    {\n      if ( !v3 )\n        v3 = 1 / 0u;\n      HIDWORD(v2) = HIDWORD(v18) % v3;\n      LODWORD(v2) = v18;\n    }\n    v6 = v2 % v3;\n    goto LABEL_22;\n  }\n  if ( HIDWORD(v2) > HIDWORD(v18) )\n  {\n    LODWORD(v6) = v18;\nLABEL_18:\n    HIDWORD(v6) = v4;\n    goto LABEL_22;\n  }\n  _BitScanReverse((unsigned int *)&v2, HIDWORD(v2));\n  LOBYTE(v18) = v2 ^ 0x1F;\n  if ( (unsigned int)v2 == 0x1F )\n  {\n    if ( HIDWORD(v2) < HIDWORD(v18) || v3 <= v19 )\n    {\n      v7 = __PAIR64__(HIDWORD(v18), v19) - __PAIR64__(HIDWORD(v2), v3);\n      v4 = HIDWORD(v7);\n      v19 = v7;\n    }\n    LODWORD(v6) = v19;\n    goto LABEL_18;\n  }\n  LODWORD(v16) = v3 << v18;\n  HIDWORD(v16) = (HIDWORD(v2) << v18) | (v3 >> (32 - v18));\n  LODWORD(v8) = (HIDWORD(v18) << v18) | (v19 >> (32 - v18));\n  HIDWORD(v8) = HIDWORD(v18) >> (32 - v18);\n  HIDWORD(v9) = v8 % HIDWORD(v16);\n  LODWORD(v9) = v19 << v18;\n  v10 = (unsigned int)v16 * (unsigned __int64)(unsigned int)(v8 / HIDWORD(v16));\n  v11 = HIDWORD(v10);\n  v12 = v10;\n  if ( v9 < v10 )\n  {\n    v13 = v10 - v16;\n    v11 = HIDWORD(v13);\n    v12 = v13;\n  }\n  v14 = v9 - __PAIR64__(v11, v12);\n  LODWORD(v6) = ((unsigned int)v14 >> v18) | (HIDWORD(v14) << (32 - v18));\n  HIDWORD(v6) = HIDWORD(v14) >> v18;\nLABEL_22:\n  if ( v17 )\n    return -(__int64)v6;\n  return v6;\n}\n"
    ],
    "sub_80B4B88": [
        "0x80b4b88",
        "unsigned int __cdecl sub_80B4B88(unsigned __int64 a1, unsigned int a2, unsigned int a3)\n{\n  unsigned int v4; // ebx\n  unsigned int v5; // ebx\n  unsigned int v6; // eax\n  unsigned __int64 v7; // rtt\n  unsigned int v8; // esi\n  unsigned int v9; // edi\n  unsigned __int64 v10; // rax\n  int v12; // [esp+4h] [ebp-24h]\n  char v13; // [esp+Ch] [ebp-1Ch]\n\n  if ( !a3 )\n  {\n    if ( a2 > HIDWORD(a1) )\n      return a1 / a2;\n    v4 = a2;\n    if ( !a2 )\n      v4 = 1 / 0u;\n    return __PAIR64__(HIDWORD(a1) % v4, a1) / v4;\n  }\n  if ( a3 > HIDWORD(a1) )\n    return 0;\n  _BitScanReverse(&v6, a3);\n  v13 = v6 ^ 0x1F;\n  if ( v6 == 0x1F )\n    return a3 < HIDWORD(a1) || a2 <= (unsigned int)a1;\n  v12 = (a3 << v13) | (a2 >> (32 - v13));\n  LODWORD(v7) = (HIDWORD(a1) << v13) | ((unsigned int)a1 >> (32 - v13));\n  HIDWORD(v7) = HIDWORD(a1) >> (32 - v13);\n  v8 = v7 % (unsigned int)v12;\n  v9 = v7 / (unsigned int)v12;\n  v5 = v9;\n  v10 = (a2 << v13) * (unsigned __int64)v9;\n  if ( v8 < HIDWORD(v10) || (_DWORD)a1 << v13 < (a2 << v13) * v9 && v8 == HIDWORD(v10) )\n    return v9 - 1;\n  return v5;\n}\n"
    ],
    "sub_80B4C77": [
        "0x80b4c77",
        "int __cdecl sub_80B4C77(unsigned __int64 a1, __int64 a2)\n{\n  int result; // eax\n  unsigned int v4; // ecx\n  unsigned __int64 v5; // rtt\n  unsigned int v6; // ecx\n  unsigned __int64 v7; // rtt\n  unsigned __int64 v8; // rcx\n  unsigned __int64 v9; // rax\n  unsigned int v10; // edi\n  unsigned int v11; // esi\n  __int64 v12; // rax\n  __int64 v13; // [esp+0h] [ebp-28h]\n  char v14; // [esp+Ch] [ebp-1Ch]\n\n  result = a1;\n  if ( HIDWORD(a2) )\n  {\n    if ( HIDWORD(a2) <= HIDWORD(a1) )\n    {\n      _BitScanReverse(&v6, HIDWORD(a2));\n      v14 = v6 ^ 0x1F;\n      if ( v6 != 0x1F )\n      {\n        LODWORD(v13) = (_DWORD)a2 << v14;\n        HIDWORD(v13) = (HIDWORD(a2) << v14) | ((unsigned int)a2 >> (32 - v14));\n        LODWORD(v7) = (HIDWORD(a1) << v14) | ((unsigned int)a1 >> (32 - v14));\n        HIDWORD(v7) = HIDWORD(a1) >> (32 - v14);\n        HIDWORD(v8) = v7 % HIDWORD(v13);\n        LODWORD(v8) = (_DWORD)a1 << v14;\n        v9 = (unsigned int)((_DWORD)a2 << v14) * (unsigned __int64)(unsigned int)(v7 / HIDWORD(v13));\n        v10 = HIDWORD(v9);\n        v11 = v9;\n        if ( v8 < v9 )\n        {\n          v12 = v9 - v13;\n          v10 = HIDWORD(v12);\n          v11 = v12;\n        }\n        return (((unsigned int)v8 - v11) >> v14) | ((v8 - __PAIR64__(v10, v11)) >> 32 << (32 - v14));\n      }\n      else if ( HIDWORD(a2) < HIDWORD(a1) || (unsigned int)a2 <= (unsigned int)a1 )\n      {\n        return a1 - a2;\n      }\n    }\n  }\n  else\n  {\n    if ( (unsigned int)a2 > HIDWORD(a1) )\n      return a1 % (unsigned int)a2;\n    v4 = a2;\n    if ( !(_DWORD)a2 )\n      v4 = 1 / 0u;\n    LODWORD(v5) = a1;\n    HIDWORD(v5) = HIDWORD(a1) % v4;\n    return v5 % v4;\n  }\n  return result;\n}\n"
    ],
    "sub_80B4D6F": [
        "0x80b4d6f",
        "int __cdecl sub_80B4D6F(unsigned __int64 a1, __int64 a2, _DWORD *a3)\n{\n  unsigned int v3; // esi\n  unsigned __int64 v4; // rax\n  int v5; // eax\n  int v6; // edx\n  unsigned __int64 v7; // rt2\n  int v8; // esi\n  unsigned int v9; // esi\n  unsigned __int64 v10; // rtt\n  int v11; // ecx\n  unsigned __int64 v12; // rax\n  unsigned int v13; // ebx\n  unsigned int v14; // edi\n  unsigned __int64 v15; // rax\n  unsigned int v17; // [esp+8h] [ebp-30h]\n  unsigned int v18; // [esp+14h] [ebp-24h]\n  unsigned int v19; // [esp+18h] [ebp-20h]\n  char v20; // [esp+1Ch] [ebp-1Ch]\n\n  v3 = a2;\n  v4 = a1;\n  if ( HIDWORD(a2) )\n  {\n    if ( HIDWORD(a2) <= HIDWORD(a1) )\n    {\n      _BitScanReverse(&v9, HIDWORD(a2));\n      v20 = v9 ^ 0x1F;\n      if ( v9 != 0x1F )\n      {\n        v18 = (HIDWORD(a2) << v20) | ((unsigned int)a2 >> (32 - v20));\n        v17 = (_DWORD)a1 << v20;\n        LODWORD(v10) = (HIDWORD(a1) << v20) | ((unsigned int)a1 >> (32 - v20));\n        HIDWORD(v10) = HIDWORD(a1) >> (32 - v20);\n        v19 = v10 % v18;\n        v11 = v10 / v18;\n        v8 = v11;\n        v12 = (unsigned int)((_DWORD)a2 << v20) * (unsigned __int64)(unsigned int)v11;\n        v14 = HIDWORD(v12);\n        v13 = v12;\n        if ( __PAIR64__(v19, (_DWORD)a1 << v20) < v12 )\n        {\n          v15 = v12 - __PAIR64__(v18, (_DWORD)a2 << v20);\n          v8 = v11 - 1;\n          v14 = HIDWORD(v15);\n          v13 = v15;\n        }\n        if ( a3 )\n        {\n          *a3 = ((v17 - v13) >> v20) | ((__PAIR64__(v19, v17) - __PAIR64__(v14, v13)) >> 32 << (32 - v20));\n          a3[1] = (unsigned int)((__PAIR64__(v19, v17) - __PAIR64__(v14, v13)) >> 32) >> v20;\n        }\n      }\n      else\n      {\n        if ( HIDWORD(a2) < HIDWORD(a1) || (v8 = 0, (unsigned int)a2 <= (unsigned int)a1) )\n        {\n          v8 = 1;\n          v4 = a1 - a2;\n        }\n        if ( a3 )\n          *(_QWORD *)a3 = v4;\n      }\n    }\n    else\n    {\n      if ( a3 )\n        *(_QWORD *)a3 = a1;\n      return 0;\n    }\n  }\n  else\n  {\n    if ( (unsigned int)a2 <= HIDWORD(a1) )\n    {\n      if ( !(_DWORD)a2 )\n        v3 = 1 / 0u;\n      HIDWORD(v4) = HIDWORD(a1) % v3;\n      LODWORD(v4) = a1;\n    }\n    v7 = v4 % v3;\n    v5 = v4 / v3;\n    v6 = v7;\n    v8 = v5;\n    if ( a3 )\n    {\n      *a3 = v6;\n      a3[1] = 0;\n    }\n  }\n  return v8;\n}\n"
    ],
    "sub_80B4EE1": [
        "0x80b4ee1",
        "int __fastcall sub_80B4EE1(int a1, int a2)\n{\n  void (**i)(void); // ebx\n\n  for ( i = (void (**)(void))&dword_80DAF40; *i != (void (*)(void))-1; --i )\n    (*i)();\n  return a2;\n}\n"
    ]
}