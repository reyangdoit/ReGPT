{
    "call_graph": {
        "134532128": [
            134530176
        ],
        "134532162": [],
        "134532166": [],
        "134532260": [
            134532166
        ],
        "134532359": [],
        "134532413": [],
        "134532433": [
            134530736
        ],
        "134532546": [
            134532433,
            134534660,
            134535263
        ],
        "134532664": [
            134531264
        ],
        "134532684": [
            134529536,
            134617090,
            134765058,
            134578180,
            134534660,
            134847496,
            134741516,
            134663695,
            134546963,
            134755859,
            134553110,
            134805529,
            134808604,
            134804510,
            134756385,
            134835234,
            134817316,
            134540837,
            134620197,
            134844968,
            134564393,
            134763561,
            134733357,
            134618670,
            134841389,
            134606391,
            134848569,
            134841336,
            134817855,
            134661697,
            134606405,
            134837317,
            134758983,
            134621773,
            134825037,
            134814290,
            134606419,
            134718036,
            134765141,
            134553185,
            134606433,
            134834276,
            134834788,
            134717542,
            134623848,
            134586475,
            134745708,
            134606447,
            134662767,
            134824562,
            134819445,
            134608503,
            134733432,
            134806649,
            134812797,
            134606461,
            134843008,
            134857348,
            134612104,
            134606475,
            134852236,
            134580877,
            134740623,
            134753936,
            134806162,
            134818966,
            134812825,
            134826138,
            134749342,
            134906015,
            134825632,
            134855329,
            134588071,
            134765223,
            134852264,
            134770860,
            134740143,
            134530736,
            134527152,
            134567088,
            134589622,
            134847158,
            134736060,
            134908605,
            134733504,
            134832321,
            134576324,
            134664901,
            134667977,
            134808265,
            134826698,
            134581964,
            134582477,
            134806732,
            134831819,
            134849740,
            134823633,
            134904016,
            134834389,
            134806230,
            134825182,
            134546659,
            134829800,
            134807786,
            134542064,
            134849777,
            134546164,
            134574328,
            134578426,
            134807293,
            134804223,
            134531840,
            134591745,
            134733056,
            134805764,
            134885126,
            134734843,
            134847240,
            134848269,
            134735632,
            134582545,
            134739216,
            134718742,
            134747929,
            134716698,
            134654235,
            134813978,
            134566686,
            134610720,
            134834468,
            134661413,
            134901029,
            134820135,
            134744362,
            134804266,
            134825258,
            134850351,
            134871856,
            134757684,
            134826292,
            134532413,
            134804286,
            134569792,
            134745408,
            134752064,
            134585670,
            134590791,
            134777672,
            134578505,
            134606666,
            134550347,
            134878535,
            134579024,
            134577490,
            134667095,
            134568282,
            134806875,
            134720860,
            134545245,
            134741858,
            134834018,
            134820200,
            134562667,
            134542701,
            134756205,
            134817135,
            134820720,
            134840176,
            134848886,
            134625655,
            134849400,
            134596473,
            134735225,
            134764921,
            134812027,
            134818681,
            134876540,
            134835583,
            134807937,
            134776706,
            134804356,
            134730630,
            134774665,
            134549386,
            134671243,
            134659980,
            134758285,
            134718865,
            134615447,
            134541208,
            134847897,
            134710171,
            134753692,
            134907811,
            134544292,
            134734246,
            134715303,
            134853030,
            134806442,
            134669739,
            134584238,
            134870961,
            134816692,
            134807989,
            134582201,
            134578618,
            134847932,
            134662590,
            134764991,
            134526912,
            134834624,
            134532546,
            134845378,
            134753221,
            134542278,
            134601161,
            134852043,
            134667725,
            134810574,
            134753743,
            134757327,
            134749652,
            134817243,
            134833116,
            134534624,
            134807521,
            134759394,
            134846947,
            134910945,
            134825446,
            134718439,
            134846950,
            134851051,
            134576621,
            134717935,
            134806515,
            134826485,
            134813687,
            134846456,
            134719481,
            134580218,
            134809595,
            134850044,
            134591486
        ],
        "134532882": [
            134531584,
            134527936,
            134532032,
            134534624,
            134531296,
            134535558,
            134532684,
            134533933,
            134533648,
            134537616,
            134532882,
            134530736,
            134533841,
            134532433,
            134534129,
            134535263
        ],
        "134533551": [
            134530416,
            134527984,
            134532882,
            134533909,
            134532664
        ],
        "134533648": [
            134533648
        ],
        "134533666": [
            134530736,
            134531584
        ],
        "134533716": [
            134531584,
            134529648
        ],
        "134533812": [
            134531584
        ],
        "134533841": [
            134534008,
            134536639
        ],
        "134533909": [
            134528928
        ],
        "134533933": [
            134528928
        ],
        "134533967": [
            134534008,
            134533933
        ],
        "134534008": [
            134531584
        ],
        "134534053": [
            134527120,
            134534154
        ],
        "134534089": [
            134527120,
            134534154,
            134534660
        ],
        "134534129": [
            134534053
        ],
        "134534143": [
            134534089
        ],
        "134534154": [
            134531584,
            134532032,
            134528192,
            134538630,
            134536591,
            134529872,
            134531760,
            134527216,
            134526800,
            134530672
        ],
        "134534624": [
            134534154,
            134534660
        ],
        "134534644": [
            134534154
        ],
        "134534660": [
            134531296
        ],
        "134534684": [
            134527776
        ],
        "134534726": [
            134527776
        ],
        "134534768": [
            134527776
        ],
        "134534782": [
            134529728
        ],
        "134534795": [],
        "134534880": [
            134534795
        ],
        "134534903": [
            134534795
        ],
        "134534927": [
            134534880
        ],
        "134534951": [],
        "134535023": [],
        "134535216": [
            134528992
        ],
        "134535238": [
            134531584,
            134538630
        ],
        "134535263": [
            134531584,
            134538630
        ],
        "134535288": [
            134526880,
            134531936,
            134528080,
            134530448,
            134527440,
            134531440
        ],
        "134535558": [
            134535288
        ],
        "134535573": [
            134531888
        ],
        "134535587": [
            134530496
        ],
        "134535700": [
            134531888,
            134535587
        ],
        "134535732": [
            134526864
        ],
        "134535772": [
            134535732
        ],
        "134535787": [
            134535732
        ],
        "134535852": [
            134534089,
            134535732
        ],
        "134535881": [
            134534624
        ],
        "134535891": [
            134528064,
            134534644
        ],
        "134535930": [
            134528064,
            134535881
        ],
        "134535955": [
            134529872,
            134535881
        ],
        "134535982": [
            134535930
        ],
        "134536006": [
            134530208,
            134535881
        ],
        "134536029": [
            134535930
        ],
        "134536077": [
            134535930
        ],
        "134536101": [
            134532096,
            134534089
        ],
        "134536130": [
            134530448,
            134534089
        ],
        "134536161": [
            134536130
        ],
        "134536171": [
            134530448,
            134534053
        ],
        "134536212": [
            134536171
        ],
        "134536222": [
            134536161
        ],
        "134536232": [
            134529744,
            134534089
        ],
        "134536259": [
            134528912,
            134534089
        ],
        "134536293": [
            134528752,
            134534089
        ],
        "134536315": [
            134527936,
            134534089
        ],
        "134536343": [
            134531936,
            134536315
        ],
        "134536365": [
            134534089,
            134538630
        ],
        "134536404": [
            134531584,
            134536365
        ],
        "134536435": [
            134531936,
            134534089
        ],
        "134536457": [
            134531600,
            134534089
        ],
        "134536532": [
            134526848,
            134534089
        ],
        "134536559": [
            134534624
        ],
        "134536576": [
            134536559
        ],
        "134536591": [
            134528432
        ],
        "134536600": [
            134532064
        ],
        "134536639": [
            134531760,
            134535881
        ],
        "134536676": [
            134529776,
            134535881
        ],
        "134536698": [
            134531648,
            134528416,
            134532032,
            134526832,
            134536029
        ],
        "134536781": [
            134532032,
            134536698
        ],
        "134536798": [
            134529536,
            134534089
        ],
        "134536820": [
            134531840,
            134534089
        ],
        "134536842": [
            134531712,
            134534089
        ],
        "134536864": [
            134530688,
            134534089
        ],
        "134536886": [
            134536864,
            134536161,
            134536842,
            134527152,
            134527472
        ],
        "134536964": [
            134529248,
            134534089
        ],
        "134536991": [
            134527840,
            134534089
        ],
        "134537013": [
            134526784,
            134534089,
            134536964
        ],
        "134537049": [
            134530560,
            134534053
        ],
        "134537086": [
            134530560,
            134534089
        ],
        "134537113": [
            134528352,
            134534089
        ],
        "134537139": [
            134529120,
            134534089
        ],
        "134537165": [
            134529824,
            134534089
        ],
        "134537203": [
            134527200,
            134534089
        ],
        "134537232": [
            134528672,
            134534143
        ],
        "134537257": [
            134526880,
            134534154,
            134534660,
            134527120
        ],
        "134537314": [
            134526880,
            134534154,
            134527120
        ],
        "134537373": [
            134526880,
            134534129
        ],
        "134537406": [
            134526880,
            134534143
        ],
        "134537433": [
            134530160,
            134536006
        ],
        "134537473": [
            134529568,
            134529504,
            134531936,
            134530384,
            134530448,
            134527664,
            134540254
        ],
        "134537596": [
            134529984,
            134534089
        ],
        "134537616": [
            134527904,
            134535955,
            134532032
        ],
        "134537680": [
            134531584,
            134532032,
            134536006,
            134533967,
            134537616,
            134526800,
            134535955
        ],
        "134537825": [
            134537616,
            134534644,
            134527120
        ],
        "134537884": [
            134528448
        ],
        "134537895": [
            134528928,
            134531584,
            134526800,
            134535955,
            134537884
        ],
        "134538016": [
            134531152,
            134538684,
            134534053,
            134538630
        ],
        "134538477": [
            134538016
        ],
        "134538522": [
            134534624,
            134534660,
            134538477
        ],
        "134538610": [
            134538016
        ],
        "134538630": [
            134538845
        ],
        "134538684": [
            134529568
        ],
        "134538723": [
            134538684
        ],
        "134538802": [
            134530448,
            134538723,
            134531936
        ],
        "134538845": [
            134528992
        ],
        "134538894": [],
        "134538904": [
            134530080
        ],
        "134538917": [
            134532048
        ],
        "134538952": [
            134529552
        ],
        "134538996": [
            134538904
        ],
        "134539060": [
            134528480,
            134532048
        ],
        "134539105": [
            134529552,
            134532016,
            134539060,
            134531504
        ],
        "134539138": [
            134538904
        ],
        "134539188": [
            134538904
        ],
        "134539230": [
            134527280,
            134534624
        ],
        "134539261": [
            134528928,
            134531232,
            134531648,
            134534624,
            134540741,
            134530000,
            134530320,
            134531792
        ],
        "134540132": [
            134529440,
            134534624
        ],
        "134540160": [
            134530544,
            134530320,
            134531136
        ],
        "134540207": [
            134530544,
            134530320,
            134531136
        ],
        "134540254": [
            134539230
        ],
        "134540308": [
            134539230
        ],
        "134540362": [
            134539230
        ],
        "134540379": [],
        "134540446": [
            134530240,
            134540379
        ],
        "134540545": [
            134528176,
            134540379
        ],
        "134540652": [
            134528256,
            134540379
        ],
        "134540741": [
            134528720,
            134540379
        ],
        "134540837": [
            134534624,
            134531296,
            134921922,
            134527392,
            134951845,
            134955212,
            134534927,
            134527152,
            134531408,
            134536639
        ],
        "134541109": [
            134953987,
            134534903
        ],
        "134541208": [
            134529408,
            134528640,
            134534927,
            134528528,
            134530064,
            134527392,
            134951845,
            134527152,
            134530864,
            134541109,
            134536639,
            134530752,
            134531904,
            134921922,
            134955212,
            134912588,
            134531408,
            134534624,
            134807786,
            134530544,
            134534129,
            134913143,
            134920313
        ],
        "134542064": [
            134921922,
            134912136,
            134946089,
            134949966,
            134528080,
            134527920,
            134946134,
            134536343,
            134920282
        ],
        "134542278": [
            134534624,
            134532546,
            134921922,
            134951845,
            134948617,
            134527152,
            134531408,
            134531536,
            134912439,
            134912412
        ],
        "134542550": [
            134528128
        ],
        "134542559": [
            134950650,
            134540652
        ],
        "134542581": [
            134534089,
            134535573
        ],
        "134542609": [
            134542581,
            134538630
        ],
        "134542689": [
            134531504,
            134542609
        ],
        "134542701": [
            134530944,
            134528128,
            134538630,
            134937484,
            134530448,
            134529552,
            134531984,
            134542609,
            134530064,
            134526880,
            134527776,
            134937888,
            134529568,
            134921900,
            134535982,
            134527664,
            134529584,
            134950578,
            134953010,
            134539188,
            134528688,
            134538684,
            134536639,
            134530368,
            134530496,
            134536006,
            134534726,
            134535238,
            134534089,
            134527952,
            134942035,
            134537433,
            134542559,
            134531296,
            134531040,
            134534624,
            134531936,
            134536161,
            134536676,
            134527456,
            134527072,
            134528224,
            134531696,
            134527728,
            134527600,
            134542581,
            134536315
        ],
        "134544238": [
            134534726,
            134536591,
            134526960,
            134531504,
            134535573,
            134534684
        ],
        "134544292": [
            134530432,
            134953997,
            134536591,
            134529552,
            134531472,
            134531216,
            134912915,
            134530448,
            134536600,
            134937888,
            134921900,
            134527664,
            134527920,
            134528688,
            134529584,
            134950578,
            134530864,
            134953010,
            134954295,
            134536639,
            134530496,
            134531648,
            134536006,
            134949966,
            134528592,
            134528080,
            134527952,
            134526800,
            134937940,
            134949712,
            134537433,
            134534624,
            134531296,
            134528224,
            134527456,
            134950113,
            134531936,
            134530672,
            134914929,
            134527728,
            134538610,
            134912244,
            134950014
        ],
        "134545245": [
            134529408,
            134912136,
            134939402,
            134526992,
            134912412,
            134534053,
            134951845,
            134946089,
            134921900,
            134939565,
            134527920,
            134529584,
            134530736,
            134536639,
            134532546,
            134536006,
            134538952,
            134946134,
            134534624,
            134526816,
            134912493,
            134527984,
            134526960,
            134530672,
            134912244,
            134536820,
            134534644
        ],
        "134546164": [
            134529664,
            134530192,
            134912915,
            134912412,
            134921900,
            134529584,
            134530736,
            134950578,
            134530752,
            134536006,
            134527440,
            134949712,
            134537433,
            134534624,
            134950113,
            134527984,
            134530672,
            134914929,
            134912244,
            134534644
        ],
        "134546659": [
            134530784,
            134536161,
            134531936,
            134534624,
            134530752,
            134921900,
            134529584,
            134527440,
            134949712,
            134912244,
            134534644,
            134914841
        ],
        "134546916": [
            134526880
        ],
        "134546934": [
            134526880
        ],
        "134546963": [
            134526880,
            134530496,
            134539138,
            134536161,
            134918727,
            134538952,
            134921900,
            134527920,
            134527984,
            134912466,
            134526960,
            134539060,
            134535573,
            134914929,
            134536343,
            134912244,
            134536315,
            134537406
        ],
        "134547327": [
            134534154
        ],
        "134547366": [
            134547327
        ],
        "134547385": [
            134547327
        ],
        "134547404": [
            134536212,
            134536343
        ],
        "134547438": [
            134530736,
            134532032
        ],
        "134547566": [
            134528544,
            134529040,
            134535216,
            134528720,
            134534644
        ],
        "134547978": [
            134528464,
            134536781,
            134536639
        ],
        "134548025": [
            134531008,
            134529248,
            134534624,
            134536964,
            134534053,
            134547978,
            134530864,
            134529712,
            134527888,
            134912915,
            134534644,
            134547385
        ],
        "134548341": [
            134548025,
            134547366
        ],
        "134548440": [
            134547327
        ],
        "134548460": [
            134528672,
            134532032,
            134940000,
            134536006,
            134939948,
            134950540,
            134535982,
            134547438,
            134533648,
            134530864,
            134530736,
            134527312,
            134547566,
            134534644,
            134939958,
            134548440,
            134547385,
            134950559
        ],
        "134549256": [
            134530560,
            134531648,
            134529888,
            134534624,
            134536964,
            134531744,
            134548460,
            134547438,
            134529744
        ],
        "134549386": [
            134528128,
            134530432,
            134536964,
            134549256,
            134953997,
            134530448,
            134531472,
            134530320,
            134526864,
            134950559,
            134547366,
            134921900,
            134529584,
            134954295,
            134547385,
            134536006,
            134547404,
            134529744,
            134531936,
            134527200,
            134548460,
            134530544,
            134534644,
            134548341,
            134920313
        ],
        "134550215": [
            134531008,
            134950113,
            134534089,
            134535787,
            134527440,
            134530064,
            134912915
        ],
        "134550347": [
            134536964,
            134536457,
            134530448,
            134529424,
            134912412,
            134528672,
            134912164,
            134921900,
            134527664,
            134536886,
            134536639,
            134532546,
            134536130,
            134536259,
            134550215,
            134529744,
            134912466,
            134937940,
            134534624,
            134531936,
            134527984,
            134527728,
            134538610,
            134534768,
            134534644
        ],
        "134550911": [
            134534624
        ],
        "134550960": [
            134534624
        ],
        "134552384": [
            134528960,
            134534624,
            134950540,
            134533648,
            134550960
        ],
        "134552627": [
            134526960,
            134536600
        ],
        "134553110": [
            134552384,
            134920282,
            134532032
        ],
        "134553185": [
            134527648,
            134536161,
            134532546,
            134534624,
            134534089,
            134955244,
            134531792,
            134530992,
            134526960,
            134540446
        ],
        "134553611": [
            134955360
        ],
        "134553644": [
            134553611
        ],
        "134553656": [
            134553611
        ],
        "134553668": [
            134529648,
            134531584,
            134540741
        ],
        "134553756": [
            134948086
        ],
        "134553796": [
            134526960,
            134536600
        ],
        "134553895": [
            134526960
        ],
        "134554008": [
            134526960,
            134527920
        ],
        "134554049": [
            134534624,
            134531296,
            134553796,
            134553895,
            134957960,
            134527920,
            134526960,
            134533812,
            134536600
        ],
        "134558242": [
            134534624,
            134554049,
            134948086
        ],
        "134558382": [
            134941449,
            134526960,
            134527920,
            134533812,
            134941367,
            134536600
        ],
        "134559318": [
            134536457
        ],
        "134559335": [
            134531072,
            134528128,
            134526880,
            134534053,
            134537373
        ],
        "134559414": [
            134528128,
            134526880,
            134528704,
            134532032,
            134529760,
            134559335,
            134957960,
            134534089,
            134536591,
            134526960,
            134531568,
            134540254,
            134559318,
            134535930,
            134553756,
            134537406
        ],
        "134559825": [
            134526880,
            134537373
        ],
        "134559882": [
            134526960,
            134527920
        ],
        "134559923": [
            134526880,
            134554049,
            134531936,
            134534053,
            134559335,
            134559882,
            134558382,
            134527920,
            134559825,
            134526960,
            134559414,
            134536343,
            134554008,
            134537373,
            134536222
        ],
        "134562667": [
            134530304,
            134532546,
            134558242,
            134553668,
            134553611,
            134553644,
            134528080,
            134559923,
            134553656
        ],
        "134563448": [
            134530896
        ],
        "134563665": [
            134563448,
            134526960
        ],
        "134563744": [
            134526960,
            134563448
        ],
        "134563939": [
            134526960,
            134535573,
            134536591
        ],
        "134563968": [
            134539105,
            134563939
        ],
        "134564008": [
            134527296,
            134534089,
            134563939,
            134530992
        ],
        "134564186": [
            134564008
        ],
        "134564298": [
            134564008
        ],
        "134564393": [
            134527872,
            134536457,
            134536591,
            134532112,
            134535700,
            134540446,
            134563744,
            134564008,
            134921900,
            134535982,
            134538952,
            134564298,
            134947020,
            134563665,
            134564186,
            134933852,
            134532064,
            134536161,
            134563939,
            134526960,
            134535288,
            134535930
        ],
        "134565549": [
            134955155
        ],
        "134565567": [
            134530896,
            134536161,
            134534089,
            134530448
        ],
        "134565647": [
            134534624,
            134534644
        ],
        "134565686": [
            134534624,
            134537257,
            134565647
        ],
        "134565855": [
            134537257
        ],
        "134565887": [
            134531664,
            134911741,
            134534624
        ],
        "134565925": [
            134534624,
            134534644,
            134565887
        ],
        "134566020": [
            134526880
        ],
        "134566062": [
            134566020
        ],
        "134566099": [
            134566020
        ],
        "134566137": [
            134566020
        ],
        "134566175": [
            134529888,
            134532096,
            134527264,
            134530432,
            134530560,
            134531648,
            134531936,
            134531296,
            134537257,
            134533648,
            134531472,
            134530000,
            134526960,
            134537086,
            134565567
        ],
        "134566686": [
            134531936,
            134532546,
            134566020,
            134565925,
            134537257,
            134534089,
            134921900,
            134565549,
            134566062,
            134526960,
            134955155,
            134566099,
            134534644,
            134565686,
            134566137,
            134565855,
            134565567
        ],
        "134567088": [
            134566020,
            134565647,
            134955155,
            134565925,
            134537257,
            134921900,
            134565549,
            134566062,
            134527920,
            134565567,
            134532546,
            134534089,
            134566099,
            134565855,
            134534624,
            134526960,
            134534644,
            134566137,
            134565887
        ],
        "134568282": [
            134566020,
            134536591,
            134955155,
            134536600,
            134565925,
            134537257,
            134921900,
            134565549,
            134566062,
            134527920,
            134565686,
            134565567,
            134534089,
            134528720,
            134566099,
            134565855,
            134534624,
            134526960,
            134566137
        ],
        "134569792": [
            134526880,
            134534624,
            134532546,
            134566020,
            134537257,
            134534089,
            134921900,
            134565549,
            134566062,
            134536591,
            134527920,
            134565567,
            134526960,
            134955155,
            134534644,
            134536600,
            134565887,
            134566175
        ],
        "134570468": [],
        "134570531": [],
        "134570566": [],
        "134570606": [
            134531888,
            134536591
        ],
        "134570637": [
            134526960
        ],
        "134570662": [
            134531296,
            134539105,
            134534726,
            134570637,
            134570606
        ],
        "134570713": [
            134570662
        ],
        "134570724": [
            134526960,
            134570637
        ],
        "134570758": [
            134530528,
            134956851
        ],
        "134570869": [
            134531584,
            134527776,
            134532032,
            134570468,
            134570724,
            134570758,
            134526768,
            134530544,
            134531824,
            134535955,
            134956851,
            134535930,
            134538684,
            134534684
        ],
        "134571524": [
            134570869
        ],
        "134571615": [
            134571524,
            134570869
        ],
        "134571703": [
            134528672,
            134538684,
            134531936,
            134530448
        ],
        "134571886": [
            134570531,
            134570468,
            134570637,
            134526960,
            134571703
        ],
        "134572138": [
            134570468,
            134570637,
            134571886,
            134526960,
            134536600
        ],
        "134572249": [
            134531552,
            134530528,
            134532032,
            134570662,
            134572138,
            134526960,
            134526800,
            134530928,
            134527920,
            134536639
        ],
        "134572852": [
            134572249
        ],
        "134573020": [
            134532032,
            134536161,
            134536006,
            134572852,
            134570869,
            134536343
        ],
        "134573184": [
            134532032,
            134573020,
            134570724,
            134536006
        ],
        "134573275": [
            134571524,
            134570869,
            134572852,
            134571615
        ],
        "134573327": [
            134571524,
            134570869,
            134572852
        ],
        "134573388": [
            134571524,
            134570869,
            134572852,
            134571615
        ],
        "134573439": [
            134573388,
            134570869,
            134570724
        ],
        "134573534": [
            134570468,
            134570662,
            134949898,
            134947020,
            134570606,
            134536591,
            134531888,
            134526960,
            134572852,
            134570869
        ],
        "134573762": [
            134573534
        ],
        "134573817": [
            134535982,
            134526960,
            134535955,
            134536600,
            134573534
        ],
        "134573960": [
            134532032,
            134570724,
            134572138,
            134531216,
            134573817,
            134573020
        ],
        "134574074": [
            134532032,
            134570724,
            134570758,
            134570637,
            134531632,
            134573817,
            134536600,
            134572249,
            134956922,
            134573439
        ],
        "134574328": [
            134530432,
            134573184,
            134573960,
            134570637,
            134573327,
            134530448,
            134529040,
            134536600,
            134534684,
            134535587,
            134912164,
            134570662,
            134921900,
            134535982,
            134571703,
            134535930,
            134532032,
            134531648,
            134532546,
            134573762,
            134536006,
            134570566,
            134538952,
            134573388,
            134954319,
            134528080,
            134537433,
            134572249,
            134573275,
            134573020,
            134570724,
            134540652,
            134571886,
            134526960,
            134570869,
            134535288,
            134573817,
            134574074,
            134573439
        ],
        "134576268": [
            134950753,
            134538802
        ],
        "134576324": [
            134529888,
            134529248,
            134531648,
            134536964,
            134576268,
            134540652,
            134526960,
            134533812,
            134537086
        ],
        "134576621": [
            134529408,
            134528640,
            134536964,
            134528528,
            134939168,
            134534053,
            134921900,
            134939948,
            134527920,
            134938809,
            134536639,
            134526912,
            134532032,
            134530000,
            134912597,
            134940000,
            134527200,
            134526960,
            134527984,
            134527344,
            134534644
        ],
        "134577490": [
            134530944,
            134528000,
            134538630,
            134949898,
            134530448,
            134529424,
            134536212,
            134533909,
            134527776,
            134535587,
            134534053,
            134921900,
            134527664,
            134531888,
            134538684,
            134536639,
            134530624,
            134538952,
            134534089,
            134528080,
            134529744,
            134531936,
            134528992,
            134950650
        ],
        "134578180": [
            134534624,
            134536161,
            134532546,
            134533666,
            134955399,
            134537257,
            134530736,
            134526960
        ],
        "134578426": [
            134531936,
            134536161,
            134921900,
            134537257
        ],
        "134578505": [
            134528608,
            134527488,
            134527920,
            134526960,
            134529488
        ],
        "134578618": [
            134527680,
            134531584,
            134527168,
            134921900,
            134534129
        ],
        "134578811": [
            134529808,
            134531584
        ],
        "134578861": [
            134540741
        ],
        "134578870": [
            134526880,
            134534129,
            134531296,
            134531936
        ],
        "134579024": [
            134531296,
            134534624,
            134915140,
            134921900,
            134578861,
            134529808,
            134527920,
            134526960,
            134534129,
            134533812,
            134578870,
            134578811
        ],
        "134580218": [
            134532546,
            134536600,
            134918727,
            134921900,
            134955212,
            134535982,
            134528592,
            134526960,
            134529072,
            134954358,
            134918680,
            134536639
        ],
        "134580670": [],
        "134580708": [
            134531008,
            134529312,
            134534053,
            134534089,
            134918636,
            134529552,
            134540308
        ],
        "134580877": [
            134527648,
            134536161,
            134580708,
            134918727,
            134921900,
            134527440,
            134526960,
            134530928,
            134536600,
            134536315,
            134580670
        ],
        "134581964": [
            134534624,
            134536161,
            134532546,
            134951266,
            134535982,
            134528816,
            134526800,
            134951227,
            134537406
        ],
        "134582164": [
            134528992,
            134531936
        ],
        "134582189": [
            134531504,
            134582164
        ],
        "134582201": [
            134528992,
            134536161,
            134538952,
            134921900,
            134953997,
            134527600,
            134582164,
            134536343,
            134955228,
            134537373
        ],
        "134582477": [
            134532546,
            134585395,
            134534644,
            134585243,
            134585596
        ],
        "134582545": [
            134531584,
            134940000,
            134948039,
            134939948,
            134526960,
            134531440,
            134527920
        ],
        "134582764": [
            134948169
        ],
        "134582786": [
            134531584,
            134530896,
            134536006,
            134535955
        ],
        "134582864": [
            134940000,
            134937283,
            134536006,
            134585226,
            134533933,
            134939921,
            134939958,
            134534008,
            134584953
        ],
        "134583085": [
            134535982,
            134585026,
            134530736,
            134536006
        ],
        "134583102": [
            134533648,
            134583085,
            134937311
        ],
        "134583177": [
            134528928,
            134940000,
            134585026,
            134937283,
            134530336,
            134582786,
            134582764,
            134583085,
            134530736,
            134939921,
            134533909,
            134939958
        ],
        "134583602": [
            134532032,
            134937345,
            134582786,
            134531648,
            134534053,
            134948039,
            134533933,
            134583085,
            134533648,
            134531792,
            134526960,
            134585395,
            134534644,
            134585596,
            134937431,
            134585564
        ],
        "134584238": [
            134937345,
            134536964,
            134939921,
            134585243,
            134530336,
            134941219,
            134533933,
            134535982,
            134583085,
            134527920,
            134583602,
            134939958,
            134583102,
            134532032,
            134921922,
            134585026,
            134582864,
            134585564,
            134528864,
            134940000,
            134584935,
            134582764,
            134534008
        ],
        "134584935": [],
        "134584953": [
            134531040,
            134531584,
            134536006,
            134937311
        ],
        "134585026": [
            134536006
        ],
        "134585226": [
            134535982,
            134585026,
            134530736,
            134536006
        ],
        "134585243": [
            134531584,
            134531648,
            134535982,
            134530896,
            134531792,
            134535955
        ],
        "134585395": [
            134531936,
            134532032,
            134948039,
            134527280,
            134530448
        ],
        "134585564": [
            134527280
        ],
        "134585596": [
            134527120
        ],
        "134585670": [
            134585026,
            134532546,
            134534089,
            134921900,
            134533909,
            134585564
        ],
        "134585831": [
            134954309,
            134536006,
            134604715,
            134531472,
            134530000,
            134530736,
            134526960,
            134604756,
            134941367,
            134926430
        ],
        "134586475": [
            134526880,
            134534624,
            134604674,
            134533666,
            134532546,
            134585831,
            134537257,
            134534089,
            134604715,
            134921900,
            134534782,
            134530736,
            134526960,
            134926430,
            134534644,
            134536343,
            134537113,
            134537406
        ],
        "134587705": [
            134526960,
            134531296
        ],
        "134587791": [
            134528416,
            134529824,
            134528688,
            134587705,
            134540254
        ],
        "134588071": [
            134955648,
            134529920,
            134539138,
            134912394,
            134587791,
            134536591,
            134536343,
            134537113,
            134530464,
            134534053,
            134956454,
            134537257,
            134921900,
            134535982,
            134530224,
            134527920,
            134537139,
            134587705,
            134537406,
            134536639,
            134955715,
            134955212,
            134532048,
            134528208,
            134955608,
            134540254,
            134534624,
            134531936,
            134528480,
            134526960,
            134534644,
            134534782
        ],
        "134589585": [],
        "134589622": [
            134531584,
            134951428,
            134953997,
            134529808,
            134589585,
            134533648,
            134537113,
            134921900,
            134939948,
            134535982,
            134956716,
            134529584,
            134530224,
            134537139,
            134939958,
            134532032,
            134956488,
            134955212,
            134526800,
            134530896,
            134940000,
            134951395,
            134951656,
            134534644
        ],
        "134590791": [
            134530912,
            134532546,
            134534053,
            134537257,
            134534782,
            134921900,
            134955628,
            134537165,
            134530000,
            134528784,
            134534644,
            134537113,
            134537406
        ],
        "134591392": [
            134940000,
            134531584,
            134591392,
            134534089,
            134529680,
            134939921
        ],
        "134591486": [
            134530464,
            134591392,
            134921900,
            134531792,
            134956824,
            134526960,
            134527920,
            134949848,
            134536600
        ],
        "134591745": [
            134528256,
            134531648,
            134532546,
            134534624,
            134606084,
            134604647,
            134537257,
            134534782,
            134955212,
            134927439,
            134530736,
            134533716,
            134537113,
            134956477,
            134537406
        ],
        "134592712": [
            134531008,
            134527968,
            134536591,
            134531504,
            134527920,
            134535732
        ],
        "134592829": [
            134592712,
            134530736,
            134536639
        ],
        "134592908": [
            134949993,
            134536639
        ],
        "134593005": [
            134532032,
            134533666,
            134592908,
            134535982
        ],
        "134593291": [
            134593005,
            134592829
        ],
        "134593410": [
            134593005,
            134592829
        ],
        "134593529": [
            134530928,
            134950540
        ],
        "134593588": [
            134533648
        ],
        "134593626": [
            134529648
        ],
        "134593656": [
            134593626
        ],
        "134593766": [
            134531584,
            134535955,
            134949966
        ],
        "134593835": [
            134531584,
            134531648,
            134532032,
            134593766,
            134950540,
            134533648,
            134530224,
            134534903,
            134593656,
            134950559
        ],
        "134594915": [
            134529216,
            134593835
        ],
        "134595041": [
            134531008,
            134531936,
            134536293,
            134954343,
            134534089,
            134918636,
            134954350,
            134536591,
            134536343
        ],
        "134595228": [
            134530432,
            134937283,
            134530928,
            134920272,
            134954295
        ],
        "134595309": [
            134530432,
            134532032,
            134533666,
            134534624,
            134954309,
            134536006,
            134534089,
            134937450,
            134950540,
            134595309,
            134535982,
            134530736,
            134937311,
            134956851,
            134534008,
            134593529,
            134920282,
            134536639
        ],
        "134596473": [
            134530432,
            134531584,
            134937345,
            134529040,
            134530448,
            134536600,
            134595228,
            134937374,
            134530336,
            134921900,
            134530736,
            134593588,
            134535732,
            134937398,
            134536639,
            134531648,
            134532032,
            134532546,
            134536259,
            134536006,
            134534089,
            134527440,
            134920282,
            134937311,
            134595041,
            134595309,
            134954350,
            134526960,
            134527600,
            134534644,
            134920313
        ],
        "134597578": [],
        "134597609": [],
        "134597670": [
            134531936
        ],
        "134597682": [
            134532032
        ],
        "134597766": [
            134526816,
            134527792,
            134534644,
            134534053
        ],
        "134597932": [
            134597766
        ],
        "134598027": [
            134529744,
            134531296
        ],
        "134598070": [
            134534644,
            134597932,
            134535772
        ],
        "134598660": [
            134535982
        ],
        "134598704": [
            134528480,
            134532048
        ],
        "134598758": [
            134532048
        ],
        "134598772": [
            134528688
        ],
        "134598797": [
            134528352,
            134529120,
            134955618,
            134531936,
            134534053,
            134597932,
            134529744,
            134529936,
            134598772
        ],
        "134598950": [
            134598797
        ],
        "134599395": [
            134531584,
            134528928,
            134533666,
            134532032,
            134531648,
            134940000,
            134536006,
            134540652,
            134535982,
            134533648,
            134530736,
            134597682,
            134529648,
            134534644,
            134534008
        ],
        "134600315": [
            134529920,
            134598660,
            134598797,
            134956442,
            134597670,
            134939948,
            134597932,
            134535982,
            134530736,
            134598704,
            134597682,
            134939958,
            134532032,
            134530880,
            134536006,
            134597578,
            134949966,
            134529744,
            134955870,
            134599395,
            134598758,
            134540652,
            134534644
        ],
        "134601161": [
            134528128,
            134598660,
            134597766,
            134953997,
            134528400,
            134912915,
            134536343,
            134538904,
            134600315,
            134530080,
            134534053,
            134597670,
            134921900,
            134529584,
            134527792,
            134527024,
            134598704,
            134530864,
            134531504,
            134526912,
            134529984,
            134531008,
            134527040,
            134532032,
            134540362,
            134597578,
            134528208,
            134531408,
            134954203,
            134536798,
            134531680,
            134534624,
            134528480,
            134528352,
            134955618,
            134529120,
            134531936,
            134598758,
            134526816,
            134527984,
            134528368,
            134528880,
            134531696,
            134534644,
            134598772,
            134536315
        ],
        "134603064": [
            134530896,
            134535930,
            134911751
        ],
        "134603131": [
            134603064
        ],
        "134603162": [
            134928054,
            134911751
        ],
        "134603273": [
            134530736,
            134534782,
            134535982
        ],
        "134603371": [
            134529472,
            134530432,
            134603273,
            134950540,
            134531472,
            134530000,
            134530736,
            134954264
        ],
        "134603933": [
            134526880,
            134531936,
            134527120,
            134534644,
            134537113,
            134534782
        ],
        "134604557": [
            134526960
        ],
        "134604647": [
            134535023
        ],
        "134604674": [
            134530736
        ],
        "134604715": [
            134530736
        ],
        "134604756": [],
        "134604780": [
            134527744,
            134531584,
            134530432,
            134604557,
            134530736,
            134527920,
            134530896,
            134527184,
            134604756,
            134526960,
            134954295,
            134536600,
            134603162
        ],
        "134606084": [
            134531936,
            134532032,
            134603273,
            134603371,
            134604780,
            134535955,
            134537113,
            134603933,
            134537406
        ],
        "134606391": [
            134628117
        ],
        "134606405": [
            134628117
        ],
        "134606419": [
            134628117
        ],
        "134606433": [
            134628117
        ],
        "134606447": [
            134628117
        ],
        "134606461": [
            134628117
        ],
        "134606475": [
            134633890,
            134646089,
            134636777,
            134641674,
            134643309,
            134632433,
            134533716,
            134628117
        ],
        "134606524": [
            134531584,
            134530912,
            134534624,
            134536006,
            134950540,
            134535982,
            134533648,
            134535930
        ],
        "134606666": [
            134529920,
            134526880,
            134532546,
            134940000,
            134537257,
            134921900,
            134939948,
            134529584,
            134939921,
            134530736,
            134526800,
            134939958,
            134537113,
            134606524,
            134534782
        ],
        "134607124": [
            134912995,
            134530000,
            134529104,
            134526800,
            134526960,
            134941586,
            134536600
        ],
        "134607559": [
            134530000,
            134531376,
            134527184
        ],
        "134607638": [
            134532032,
            134956706,
            134534927,
            134530512,
            134956726,
            134536639
        ],
        "134607761": [
            134532032,
            134536600,
            134526960,
            134607638
        ],
        "134607924": [
            134532032,
            134530432,
            134918981,
            134534644,
            134954358
        ],
        "134608019": [
            134531584,
            134530000,
            134607559
        ],
        "134608176": [
            134607761,
            134608019,
            134534927
        ],
        "134608289": [
            134607761,
            134608019
        ],
        "134608427": [
            134607761,
            134608019
        ],
        "134608503": [
            134615047,
            134921900,
            134535982,
            134526960,
            134607924
        ],
        "134608908": [
            134528832,
            134956851
        ],
        "134608997": [
            134956851,
            134956477
        ],
        "134609063": [
            134529920,
            134528768,
            134911751,
            134540308,
            134536600,
            134534684,
            134529568,
            134530592,
            134534053,
            134956716,
            134531376,
            134530096,
            134537139,
            134532032,
            134530624,
            134527552,
            134955715,
            134529856,
            134956499,
            134528992,
            134531936,
            134526960
        ],
        "134610720": [
            134529920,
            134532096,
            134530432,
            134608908,
            134529808,
            134531472,
            134536600,
            134609063,
            134530736,
            134536639,
            134532546,
            134536006,
            134955212,
            134531792,
            134527184,
            134526800,
            134533716,
            134534624,
            134608997,
            134529904,
            134526960
        ],
        "134611583": [
            134529552,
            134531296,
            134957960,
            134526960
        ],
        "134611811": [
            134534624,
            134537165,
            134529552,
            134528688,
            134927572,
            134540254,
            134611583
        ],
        "134612104": [
            134955648,
            134536591,
            134529296,
            134529552,
            134955411,
            134955155,
            134536343,
            134530464,
            134534053,
            134956454,
            134955563,
            134921900,
            134535982,
            134527664,
            134527920,
            134537139,
            134956726,
            134529216,
            134956488,
            134534089,
            134955594,
            134528208,
            134540254,
            134528352,
            134534624,
            134611811,
            134955628,
            134526960,
            134534644,
            134611583
        ],
        "134613264": [],
        "134613298": [
            134530736,
            134532546
        ],
        "134613382": [
            134527744,
            134527264,
            134530432,
            134532032,
            134954309,
            134534089,
            134526960,
            134613264,
            134527184,
            134928054
        ],
        "134613799": [
            134531648,
            134927936,
            134532546,
            134534624,
            134955212,
            134955244,
            134530736,
            134613298,
            134537113,
            134537406,
            134534782
        ],
        "134614289": [
            134531648,
            134534624,
            134532546,
            134927622,
            134955212,
            134955244,
            134613298,
            134950744,
            134537113,
            134537406
        ],
        "134615047": [
            134527744,
            134530432,
            134530464,
            134532032,
            134954309,
            134534089,
            134927722,
            134526960,
            134613264
        ],
        "134615447": [
            134532546,
            134613382,
            134918727,
            134613799,
            134615047,
            134921900,
            134530736,
            134614289,
            134613298
        ],
        "134615685": [],
        "134615688": [
            134536639
        ],
        "134615761": [
            134527264,
            134526960,
            134534644,
            134536600,
            134647838
        ],
        "134616272": [
            134533666,
            134648549,
            134615688,
            134526960,
            134615761,
            134534644,
            134536600,
            134647838
        ],
        "134616741": [
            134533666,
            134648549,
            134615688,
            134526960,
            134615761,
            134534644,
            134536600,
            134647838
        ],
        "134617090": [
            134528256,
            134651104,
            134646562,
            134532546,
            134648645,
            134648678,
            134648618,
            134530736,
            134646705,
            134651026,
            134650960,
            134533716,
            134651092,
            134650938,
            134646363,
            134534143
        ],
        "134618059": [],
        "134618081": [
            134538630
        ],
        "134618113": [
            134618081,
            134618059
        ],
        "134618159": [
            134531888
        ],
        "134618186": [
            134531888
        ],
        "134618213": [
            134526960,
            134618186,
            134618159
        ],
        "134618300": [
            134529568,
            134618113,
            134529056,
            134618081,
            134531296,
            134618213,
            134535238,
            134618186,
            134618159
        ],
        "134618561": [
            134618300,
            134538630
        ],
        "134618670": [
            134528128,
            134618113,
            134531584,
            134538630,
            134529552,
            134536343,
            134921900,
            134530352,
            134618300,
            134538684,
            134530496,
            134530624,
            134532546,
            134618561,
            134956613,
            134535238,
            134618186,
            134618059,
            134527440,
            134531296,
            134618081,
            134618213,
            134955638,
            134535288,
            134955775
        ],
        "134620140": [
            134540652,
            134534644
        ],
        "134620197": [
            134531584,
            134538630,
            134949898,
            134529808,
            134537113,
            134528928,
            134527264,
            134528672,
            134921900,
            134533812,
            134538684,
            134956477,
            134532546,
            134955715,
            134537165,
            134526800,
            134530896,
            134528208,
            134529744,
            134536161,
            134955618,
            134538723,
            134620140,
            134534644,
            134535930,
            134955775
        ],
        "134621773": [
            134955648,
            134529920,
            134949898,
            134536077,
            134536591,
            134529296,
            134955411,
            134536343,
            134536600,
            134537113,
            134956706,
            134955563,
            134921900,
            134535982,
            134527664,
            134537139,
            134956726,
            134956477,
            134532032,
            134526912,
            134956488,
            134534089,
            134955594,
            134955212,
            134537165,
            134955608,
            134954203,
            134536798,
            134955870,
            134534624,
            134540254,
            134951656,
            134527984,
            134526960,
            134527600,
            134536820,
            134534644
        ],
        "134623804": [
            134529808,
            134532546
        ],
        "134623848": [
            134532546,
            134537257,
            134955212,
            134955244,
            134537113,
            134623804,
            134534782
        ],
        "134624064": [
            134534624
        ],
        "134624086": [
            134528688
        ],
        "134624113": [
            134529968,
            134535881,
            134956669,
            134624086
        ],
        "134624164": [
            134531584,
            134953304
        ],
        "134624217": [
            134534089,
            134531472,
            134529040,
            134531792,
            134624086
        ],
        "134624350": [
            134536457,
            134534644
        ],
        "134624395": [
            134532032,
            134528928,
            134531648,
            134534624,
            134529472,
            134536006,
            134941000,
            134530736
        ],
        "134624684": [
            134534624,
            134624217,
            134528592,
            134950540
        ],
        "134624866": [
            134943320,
            134535216,
            134943292
        ],
        "134625028": [
            134530240,
            134530400,
            134530144,
            134624866,
            134534624,
            134534726,
            134534089,
            134949898,
            134536365,
            134531600,
            134532112,
            134527312,
            134624217,
            134534684
        ],
        "134625522": [
            134529040,
            134624217,
            134528432,
            134955399
        ],
        "134625655": [
            134531584,
            134937345,
            134530432,
            134625028,
            134536457,
            134624395,
            134950540,
            134529552,
            134530448,
            134529040,
            134540446,
            134950559,
            134533666,
            134950691,
            134624164,
            134956716,
            134533933,
            134535982,
            134624684,
            134530736,
            134529072,
            134528432,
            134956477,
            134529472,
            134532032,
            134921922,
            134531648,
            134536006,
            134530896,
            134527440,
            134533841,
            134531664,
            134531792,
            134624217,
            134624350,
            134955870,
            134534624,
            134536161,
            134949993,
            134531440,
            134624113,
            134625522,
            134536435,
            134535930,
            134627964
        ],
        "134627964": [
            134528928,
            134955212
        ],
        "134628117": [
            134650960,
            134532546,
            134533666,
            134533716
        ],
        "134628274": [
            134648299,
            134535982
        ],
        "134628351": [
            134534053,
            134646446
        ],
        "134628405": [
            134529920,
            134531584,
            134530336,
            134649444,
            134648549,
            134651207,
            134651116,
            134529072,
            134526800,
            134530896,
            134526960,
            134534644,
            134536600,
            134647838,
            134628351
        ],
        "134629433": [
            134530336,
            134528352,
            134531936,
            134648549,
            134534782,
            134529072,
            134648785,
            134526960,
            134648595,
            134534644,
            134941367,
            134536600,
            134647934,
            134537373,
            134647838
        ],
        "134630220": [
            134531584,
            134650561,
            134533666,
            134647105,
            134651104,
            134648645,
            134534624,
            134650503,
            134649482,
            134648618,
            134533648,
            134647696,
            134650960,
            134651092,
            134650938,
            134646363
        ],
        "134631317": [
            134649482,
            134647838,
            134530336,
            134533666,
            134648618,
            134530736,
            134646705,
            134628405,
            134629433,
            134650938,
            134650561,
            134650960,
            134646363,
            134534624,
            134651104,
            134646498,
            134648549,
            134651116,
            134628351
        ],
        "134632433": [
            134650960,
            134630220,
            134631317,
            134533716
        ],
        "134632563": [
            134528352,
            134537113
        ],
        "134632617": [
            134647105,
            134534660,
            134648618,
            134647696,
            134646363
        ],
        "134632747": [
            134531584,
            134647105,
            134533666,
            134534624,
            134648645,
            134648618,
            134647696,
            134648081,
            134651026,
            134530736,
            134533812,
            134650960,
            134651092,
            134651031,
            134533716,
            134650938,
            134646363
        ],
        "134633890": [
            134912394,
            134648081,
            134631317,
            134537113,
            134533666,
            134632617,
            134648618,
            134632747,
            134530736,
            134537139,
            134650938,
            134537406,
            134650960,
            134533716,
            134651092,
            134650972,
            134651104,
            134534624,
            134531936,
            134531296,
            134632563,
            134534782
        ],
        "134635188": [
            134534053,
            134646446
        ],
        "134635242": [
            134534624,
            134650561,
            134646562,
            134646498,
            134534660,
            134648645,
            134534089,
            134648618,
            134530736,
            134646705,
            134527920,
            134526960,
            134635188,
            134533716,
            134650938,
            134646363
        ],
        "134635922": [
            134534624,
            134648549,
            134651207,
            134651116,
            134650127,
            134526960,
            134635188,
            134647838,
            134536600,
            134647934
        ],
        "134636777": [
            134650960,
            134635242,
            134533716
        ],
        "134636837": [],
        "134636874": [
            134534053,
            134646446
        ],
        "134636928": [
            134534624,
            134534660,
            134649444,
            134648549,
            134651207,
            134636874,
            134651116,
            134650127,
            134529040,
            134526960,
            134649651,
            134649720,
            134536600,
            134647838
        ],
        "134638522": [
            134636928,
            134650561,
            134533666,
            134647105,
            134534624,
            134636837,
            134648645,
            134648618,
            134647696,
            134647635,
            134650938,
            134646363,
            134647838
        ],
        "134639324": [
            134649482,
            134649363,
            134536212,
            134533666,
            134636837,
            134534053,
            134648618,
            134530736,
            134646705,
            134650938,
            134650561,
            134648645,
            134534089,
            134636874,
            134537165,
            134650960,
            134533716,
            134649689,
            134646363,
            134534624,
            134528992,
            134531936,
            134646498
        ],
        "134640501": [
            134650503,
            134649482,
            134647696,
            134651026,
            134649363,
            134648618,
            134530736,
            134650938,
            134650561,
            134647105,
            134648645,
            134650960,
            134649809,
            134647635,
            134533716,
            134649689,
            134646363,
            134650972,
            134647774,
            134651104
        ],
        "134641674": [
            134650960,
            134533716,
            134640501,
            134638522,
            134639324
        ],
        "134641833": [
            134531584,
            134650561,
            134650018,
            134532546,
            134650884,
            134647105,
            134647696,
            134650960,
            134651026,
            134649809,
            134649620,
            134647635,
            134533716,
            134649689,
            134650938,
            134646363
        ],
        "134642663": [
            134536600,
            134651207,
            134649544,
            134649582,
            134526960,
            134529072,
            134649651,
            134649720,
            134647838
        ],
        "134643309": [
            134646498,
            134954213,
            134641833,
            134650960,
            134646705,
            134533716,
            134646363
        ],
        "134643446": [
            134531936,
            134537113,
            134537373,
            134534782
        ],
        "134643520": [
            134531936,
            134537113,
            134537406,
            134534782
        ],
        "134643632": [
            134531936,
            134537113,
            134534782,
            134537406
        ],
        "134643707": [
            134529920,
            134531648,
            134533666,
            134534624,
            134650884,
            134651104,
            134531296,
            134531936,
            134534782,
            134650960,
            134649620,
            134643446,
            134537113,
            134650938,
            134650972,
            134537406
        ],
        "134644877": [
            134643520,
            134643707,
            134534624
        ],
        "134644979": [
            134531936,
            134532032,
            134651207,
            134649582,
            134526960,
            134531376,
            134537373,
            134537113,
            134536029
        ],
        "134645533": [
            134531648,
            134531936,
            134954264,
            134531472,
            134530000,
            134530736,
            134644979,
            134534644,
            134643446,
            134536600,
            134537113,
            134537373,
            134534782
        ],
        "134646089": [
            134644877,
            134650960,
            134643632,
            134644979,
            134533716,
            134643446,
            134536600,
            134643707,
            134645533
        ],
        "134646363": [
            134530544,
            134537113,
            134912394,
            134537139
        ],
        "134646446": [
            134537165
        ],
        "134646498": [
            134646446
        ],
        "134646562": [
            134529616
        ],
        "134646705": [
            134531776,
            134534624,
            134532032,
            134534053,
            134534644,
            134535930
        ],
        "134647105": [
            134531776,
            134534624,
            134532032,
            134534053,
            134529616,
            134534644,
            134535930
        ],
        "134647635": [],
        "134647696": [],
        "134647774": [],
        "134647838": [
            134534644
        ],
        "134647934": [
            134527264,
            134531376
        ],
        "134648081": [
            134531648,
            134534644,
            134650240,
            134530000
        ],
        "134648263": [],
        "134648299": [
            134526800,
            134535930,
            134535982,
            134647838
        ],
        "134648549": [
            134648263,
            134911751,
            134536639
        ],
        "134648595": [
            134648263
        ],
        "134648618": [
            134529216,
            134534624
        ],
        "134648645": [
            134646705,
            134646498
        ],
        "134648678": [
            134531584,
            134529808,
            134540652
        ],
        "134648785": [
            134531584,
            134530896
        ],
        "134648853": [
            134940000,
            134536006,
            134540652,
            134530896,
            134939921,
            134534644,
            134939958
        ],
        "134648992": [
            134648853,
            134535982
        ],
        "134649077": [
            134648853,
            134535982
        ],
        "134649122": [
            134648853,
            134535982
        ],
        "134649167": [
            134648853,
            134535982
        ],
        "134649242": [
            134530736,
            134540652
        ],
        "134649363": [
            134649242,
            134648853,
            134535982
        ],
        "134649444": [
            134648992,
            134534927
        ],
        "134649482": [
            134648992,
            134649242
        ],
        "134649513": [
            134649242,
            134649077
        ],
        "134649544": [
            134649077,
            134534927
        ],
        "134649582": [
            134649122,
            134534927
        ],
        "134649620": [
            134649122,
            134649242
        ],
        "134649651": [
            134649167,
            134534927
        ],
        "134649689": [
            134649242,
            134649167
        ],
        "134649720": [
            134534927
        ],
        "134649809": [
            134528256,
            134533716
        ],
        "134650018": [
            134531648,
            134649513
        ],
        "134650127": [
            134527744,
            134950744,
            134530432,
            134954295
        ],
        "134650240": [
            134531648,
            134530736,
            134527184
        ],
        "134650503": [
            134534624,
            134650240
        ],
        "134650561": [
            134534624,
            134531648,
            134650240,
            134540652,
            134530736
        ],
        "134650884": [
            134650240,
            134534624
        ],
        "134650938": [
            134534624
        ],
        "134650960": [
            134534624
        ],
        "134650972": [
            134528256,
            134650960
        ],
        "134651026": [
            134650972
        ],
        "134651031": [
            134528256,
            134650960
        ],
        "134651092": [
            134534624
        ],
        "134651104": [
            134534624
        ],
        "134651116": [
            134529920
        ],
        "134651207": [
            134531376,
            134535982,
            134911751
        ],
        "134651260": [
            134528816,
            134535982
        ],
        "134651319": [
            134529504,
            134656593,
            134540362,
            134658703
        ],
        "134651416": [
            134658674,
            134658782,
            134658703
        ],
        "134651625": [
            134656745
        ],
        "134651651": [
            134651625,
            134534644,
            134651319,
            134651416,
            134658782
        ],
        "134651739": [
            134530464,
            134651625,
            134534644,
            134651319,
            134651416,
            134658782
        ],
        "134651843": [
            134651625,
            134534644,
            134658782,
            134651319
        ],
        "134651930": [
            134530464,
            134651625,
            134534644,
            134651319,
            134651416,
            134657149
        ],
        "134652036": [
            134531776,
            134534644,
            134927572,
            134529696
        ],
        "134652421": [
            134941228,
            134953997
        ],
        "134652445": [
            134530896
        ],
        "134652482": [
            134531936,
            134955586,
            134657861,
            134537139,
            134537113
        ],
        "134652651": [
            134531584,
            134949966,
            134530896,
            134659828,
            134535930,
            134652445
        ],
        "134653311": [
            134531584,
            134532032,
            134953987,
            134534951,
            134652651,
            134536781,
            134535982,
            134658512,
            134528464,
            134530896,
            134535930,
            134652445,
            134536639
        ],
        "134654021": [
            134651625,
            134534644,
            134651319,
            134657149,
            134658782
        ],
        "134654123": [
            134530464,
            134652482,
            134654021,
            134526800,
            134534644,
            134653311
        ],
        "134654235": [
            134529152,
            134937345,
            134529920,
            134651651,
            134652036,
            134652421,
            134528128,
            134657551,
            134651930,
            134656670,
            134530464,
            134654123,
            134941228,
            134659247,
            134529584,
            134658878,
            134532032,
            134530624,
            134921922,
            134652482,
            134651843,
            134536006,
            134657606,
            134534089,
            134540362,
            134657486,
            134530384,
            134658512,
            134529744,
            134954203,
            134651739,
            134540254,
            134529504,
            134658017,
            134657642,
            134955244,
            134540652,
            134534644,
            134658420,
            134651260,
            134653311
        ],
        "134656593": [
            134658782
        ],
        "134656670": [
            134538684,
            134534644
        ],
        "134656745": [
            134528352,
            134529824,
            134529120,
            134531936,
            134534053,
            134658674,
            134927572
        ],
        "134657149": [
            134528352,
            134527040,
            134955618,
            134529120,
            134531936,
            134534053,
            134658674,
            134538845
        ],
        "134657426": [
            134528992,
            134534053
        ],
        "134657486": [
            134534768,
            134534684,
            134536293,
            134538952
        ],
        "134657551": [
            134534768
        ],
        "134657606": [
            134538684
        ],
        "134657642": [
            134531936,
            134537314,
            134537113,
            134537373,
            134534782
        ],
        "134657861": [
            134528928,
            134955648,
            134955618,
            134534660,
            134534089,
            134955628,
            134537139,
            134537113
        ],
        "134658017": [
            134528352,
            134529824,
            134531936,
            134529920,
            134534053,
            134949898,
            134955628,
            134949966,
            134540308,
            134538684
        ],
        "134658420": [
            134531584,
            134533666,
            134534624,
            134535982
        ],
        "134658512": [
            134534644
        ],
        "134658674": [],
        "134658703": [
            134658674,
            134534644
        ],
        "134658782": [
            134534644,
            134658703
        ],
        "134658878": [],
        "134658906": [
            134534624,
            134532032,
            134536006,
            134535023,
            134535955,
            134535930,
            134658878
        ],
        "134659205": [
            134532032,
            134956442
        ],
        "134659247": [
            134531648,
            134950753,
            134540741,
            134659205,
            134540652,
            134528816,
            134529904,
            134658420,
            134534008,
            134658906
        ],
        "134659828": [
            134530896,
            134534951
        ],
        "134659902": [
            134531472,
            134954309,
            134530432,
            134530000
        ],
        "134659980": [
            134528160,
            134532546,
            134957960,
            134526960,
            134659902
        ],
        "134660505": [],
        "134660579": [
            134535982
        ],
        "134660673": [
            134528352,
            134531584,
            134531936,
            134660579,
            134528672,
            134939168,
            134530432,
            134530000,
            134531472,
            134954295,
            134660505
        ],
        "134661034": [
            134530560,
            134529056,
            134531744,
            134532032,
            134660673,
            134534053,
            134529888,
            134527200,
            134661034,
            134540652,
            134526960,
            134533716,
            134913013,
            134660505
        ],
        "134661413": [
            134660673,
            134660579,
            134661034,
            134921900,
            134527664,
            134526800,
            134530000,
            134531216,
            134537203,
            134950837,
            134536600
        ],
        "134661697": [
            134531584,
            134529056,
            134530368,
            134942400,
            134532546,
            134534053,
            134532032,
            134540741,
            134540652,
            134527920,
            134527664,
            134526960,
            134919315,
            134534644,
            134950837,
            134951160,
            134951129
        ],
        "134662590": [
            134942400,
            134530560,
            134529888,
            134531744,
            134532032,
            134949966,
            134530896,
            134527664,
            134537616,
            134526960
        ],
        "134662767": [
            134532032,
            134937450,
            134921900,
            134955244,
            134530480,
            134526960,
            134919538,
            134919315,
            134534903,
            134536600
        ],
        "134662991": [
            134956851
        ],
        "134663154": [
            134529648,
            134530896,
            134534624
        ],
        "134663258": [
            134531648,
            134531584,
            134663154,
            134662991
        ],
        "134663659": [
            134942329,
            134949966
        ],
        "134663695": [
            134942400,
            134937345,
            134531584,
            134663258,
            134535558,
            134921900,
            134526800,
            134528080,
            134530896,
            134526960,
            134535930
        ],
        "134664193": [
            134531648,
            134532032,
            134947842,
            134531936,
            134532064,
            134534053,
            134536006,
            134530448,
            134527920,
            134526960,
            134536404,
            134534644
        ],
        "134664671": [
            134531584,
            134531216
        ],
        "134664742": [
            134527200,
            134530560,
            134529888,
            134531744,
            134532032,
            134664193,
            134664742,
            134536006,
            134913013
        ],
        "134664901": [
            134940000,
            134536161,
            134950753,
            134664193,
            134536964,
            134664742,
            134949993,
            134664671,
            134921900,
            134939948,
            134536991
        ],
        "134665172": [],
        "134665187": [],
        "134665211": [],
        "134665226": [],
        "134665252": [],
        "134665297": [
            134531472,
            134530000
        ],
        "134665474": [
            134534624,
            134530432,
            134532032,
            134954309,
            134665297,
            134535930
        ],
        "134665720": [
            134528256,
            134530432,
            134527264,
            134533666,
            134531648,
            134954309,
            134943046,
            134536591,
            134531472,
            134527920,
            134526768,
            134538802,
            134529072,
            134531792,
            134926674,
            134526960,
            134536600,
            134942329
        ],
        "134666678": [
            134528128,
            134947020
        ],
        "134667030": [
            134942264,
            134532032
        ],
        "134667058": [
            134535573
        ],
        "134667081": [
            134539105,
            134667058
        ],
        "134667095": [
            134528128,
            134665474,
            134536964,
            134955411,
            134535700,
            134667030,
            134536600,
            134535288,
            134921900,
            134535982,
            134667058,
            134956851,
            134666678,
            134942400,
            134538952,
            134526800,
            134921946,
            134527712,
            134955244,
            134527600,
            134534644,
            134665720
        ],
        "134667725": [
            134528160,
            134530320,
            134530544,
            134526960
        ],
        "134667977": [
            134532032,
            134528032,
            134528128,
            134535558,
            134921900,
            134540207,
            134526960,
            134536591,
            134536639
        ],
        "134668177": [
            134526960,
            134536600
        ],
        "134668251": [
            134668177
        ],
        "134668269": [
            134668177
        ],
        "134668287": [
            134527200,
            134912147,
            134534053,
            134526960
        ],
        "134668610": [
            134527200,
            134953890,
            134535732,
            134534053
        ],
        "134668768": [
            134531504,
            134534053
        ],
        "134668789": [
            134531936,
            134529568,
            134668269,
            134530448,
            134668177,
            134668251
        ],
        "134668996": [
            134529248,
            134526960,
            134668789,
            134536600,
            134668251,
            134668287
        ],
        "134669129": [
            134668610,
            134526960,
            134912147,
            134668789,
            134536600,
            134668287
        ],
        "134669541": [
            134531584,
            134528992,
            134531936,
            134668269,
            134530448,
            134668177,
            134668789,
            134668251
        ],
        "134669739": [
            134530448,
            134536600,
            134921900,
            134530736,
            134532546,
            134669129,
            134527440,
            134529248,
            134527840,
            134668768,
            134669541,
            134955244,
            134668269,
            134530544,
            134526960,
            134527600,
            134668789,
            134534008,
            134668287
        ],
        "134671243": [
            134532546,
            134536964,
            134534089,
            134530448,
            134534008
        ],
        "134671368": [],
        "134671413": [],
        "134671431": [],
        "134671456": [],
        "134671481": [],
        "134671532": [],
        "134671576": [
            134671481
        ],
        "134671593": [
            134671481
        ],
        "134671630": [],
        "134671709": [],
        "134671792": [],
        "134671840": [],
        "134671846": [],
        "134671849": [],
        "134671859": [],
        "134671878": [],
        "134671887": [
            134535982
        ],
        "134671918": [
            134535982
        ],
        "134672009": [
            134532032
        ],
        "134672064": [
            134532032
        ],
        "134672107": [
            134532032
        ],
        "134672123": [
            134531792
        ],
        "134672220": [
            134531584,
            134526800
        ],
        "134672262": [
            134672220,
            134672262,
            134672519
        ],
        "134672519": [
            134672262
        ],
        "134672578": [
            134530736
        ],
        "134672653": [
            134530736
        ],
        "134672669": [
            134531584,
            134530736,
            134526800,
            134535982
        ],
        "134672801": [
            134530736
        ],
        "134672816": [
            134672816,
            134530736
        ],
        "134672943": [
            134526752
        ],
        "134672969": [
            134672064,
            134535930,
            134536006
        ],
        "134673073": [
            134530080,
            134538904
        ],
        "134673373": [
            134529552
        ],
        "134673414": [
            134529552,
            134538917,
            134532016,
            134672943
        ],
        "134673476": [
            134673414
        ],
        "134673548": [
            134673414
        ],
        "134673573": [
            134673414
        ],
        "134673597": [
            134673573,
            134536591
        ],
        "134673620": [
            134532032,
            134673573
        ],
        "134673882": [
            134532032,
            134673573
        ],
        "134673958": [
            134672009,
            134672578,
            134673573
        ],
        "134674009": [
            134532032,
            134673573,
            134673958
        ],
        "134674167": [
            134531936,
            134674009,
            134673573,
            134532032
        ],
        "134674253": [
            134531584,
            134673573,
            134671887
        ],
        "134674314": [
            134531584,
            134673573,
            134535982
        ],
        "134674455": [
            134532032,
            134672107,
            134673573
        ],
        "134674507": [
            134673573,
            134535982
        ],
        "134674555": [
            134673573,
            134535982
        ],
        "134674636": [
            134532032,
            134673573
        ],
        "134674871": [
            134532032,
            134673573,
            134671630
        ],
        "134674960": [
            134532032,
            134673573
        ],
        "134675029": [
            134527776
        ],
        "134675078": [
            134532064,
            134673573,
            134528432
        ],
        "134675136": [
            134529040,
            134530736,
            134531952,
            134675078
        ],
        "134675287": [
            134675136,
            134673597,
            134672943
        ],
        "134675323": [
            134532032,
            134536006,
            134671593,
            134671532,
            134535982,
            134531792,
            134675287
        ],
        "134675635": [
            134675323,
            134673573
        ],
        "134675682": [
            134531584,
            134528416,
            134673573,
            134918440,
            134531792,
            134675287,
            134535930,
            134675323
        ],
        "134675965": [
            134675682
        ],
        "134675974": [
            134675682
        ],
        "134675981": [
            134671456,
            134531440,
            134675287
        ],
        "134676068": [
            134532032,
            134675981,
            134673573
        ],
        "134676212": [
            134675981
        ],
        "134676240": [
            134527936,
            134675287
        ],
        "134676275": [
            134531936,
            134676240,
            134673573,
            134532032
        ],
        "134676398": [
            134531984,
            134675287
        ],
        "134676422": [
            134535930,
            134673573,
            134675287
        ],
        "134676535": [
            134676422
        ],
        "134676566": [
            134676535
        ],
        "134676603": [
            134531584,
            134676422
        ],
        "134676635": [
            134527776,
            134531936,
            134673573,
            134671887,
            134530448,
            134675287,
            134535930
        ],
        "134676850": [
            134675287
        ],
        "134677054": [
            134676879
        ],
        "134677130": [
            134676879
        ],
        "134677282": [
            134676879
        ],
        "134677321": [
            134671456,
            134531440,
            134675287,
            134671431
        ],
        "134677601": [
            134527776,
            134531936,
            134675287
        ],
        "134677680": [
            134675981,
            134675287
        ],
        "134677761": [
            134675136
        ],
        "134677775": [
            134527776,
            134677761,
            134528800,
            134531936,
            134676398,
            134530448,
            134528080,
            134531248,
            134530128,
            134673073,
            134528560,
            134531984
        ],
        "134678130": [
            134673073,
            134677775
        ],
        "134678218": [
            134531648,
            134675682,
            134673573,
            134675974,
            134671593,
            134671532,
            134535982,
            134671481,
            134535930,
            134675323
        ],
        "134678488": [
            134678218,
            134675287
        ],
        "134678533": [
            134532032,
            134530816,
            134675682,
            134673573,
            134536006
        ],
        "134678695": [
            134529168,
            134673573
        ],
        "134678740": [
            134677761,
            134678695,
            134672969,
            134530736,
            134675287
        ],
        "134679343": [
            134677282
        ],
        "134679401": [
            134675078,
            134678695
        ],
        "134679495": [
            134529072,
            134673573,
            134673597
        ],
        "134679535": [
            134679495
        ],
        "134679587": [
            134679535,
            134675981,
            134672943
        ],
        "134679633": [
            134676422
        ],
        "134679657": [
            134679633
        ],
        "134679689": [
            134679633,
            134676603
        ],
        "134679731": [
            134527584
        ],
        "134679755": [
            134527584
        ],
        "134679779": [
            134528192,
            134673573
        ],
        "134679832": [
            134530848,
            134679779,
            134526800
        ],
        "134679972": [
            134532000,
            134673573,
            134679495,
            134671630,
            134526864,
            134532048,
            134679832
        ],
        "134680391": [
            134676879
        ],
        "134680596": [
            134679972,
            134673573,
            134676398,
            134532016,
            134674871,
            134671709
        ],
        "134680700": [
            134679779,
            134675078,
            134529040,
            134526800,
            134674871,
            134679832
        ],
        "134681087": [
            134679972,
            134680700
        ],
        "134681145": [
            134676879
        ],
        "134681227": [
            134676879
        ],
        "134681479": [
            134714871
        ],
        "134681486": [
            134530336
        ],
        "134681575": [
            134530336
        ],
        "134681709": [
            134713234,
            134673573,
            134675287
        ],
        "134681791": [
            134681709
        ],
        "134681838": [
            134681709,
            134675287
        ],
        "134681883": [
            134535930,
            134535955,
            134674871
        ],
        "134682147": [
            134535955,
            134673573,
            134676422,
            134675287
        ],
        "134682287": [
            134682147
        ],
        "134682328": [
            134531792,
            134528416,
            134682287
        ],
        "134682479": [
            134682328,
            134678695
        ],
        "134682509": [
            134531648,
            134532032,
            134672578,
            134673573,
            134536006,
            134535982,
            134682479,
            134529040
        ],
        "134682783": [
            134682328
        ],
        "134682841": [
            134672123,
            134682287
        ],
        "134682993": [
            134531584,
            134528416,
            134682287
        ],
        "134683032": [
            134679779,
            134682287
        ],
        "134683086": [
            134531968,
            134531584,
            134528416,
            134676422,
            134682287,
            134535930
        ],
        "134683485": [
            134531584,
            134682287
        ],
        "134683838": [
            134682147
        ],
        "134683862": [
            134683838
        ],
        "134683888": [
            134683838,
            134676422
        ],
        "134684028": [
            134531584,
            134528416,
            134682147,
            134676422,
            134526800
        ],
        "134684246": [
            134532032,
            134531936,
            134673573,
            134674167,
            134536077,
            134676398,
            134675287,
            134530448,
            134530736,
            134673073,
            134527664,
            134528560,
            134674871,
            134673373
        ],
        "134684858": [
            134527616
        ],
        "134684918": [
            134527120
        ],
        "134684940": [
            134676879
        ],
        "134685226": [
            134950744,
            134527408,
            134678695
        ],
        "134685322": [
            134527712,
            134678695,
            134918440,
            134683888,
            134682328
        ],
        "134685450": [
            134673573,
            134672969,
            134685322,
            134678130,
            134678740
        ],
        "134685528": [
            134676879
        ],
        "134685692": [
            134833116
        ],
        "134685702": [
            134677321,
            134661697,
            134530896,
            134530736
        ],
        "134685919": [
            134933812
        ],
        "134685932": [
            134813978
        ],
        "134685942": [
            134844968
        ],
        "134685952": [
            134530048,
            134530560,
            134530336,
            134529888,
            134531744,
            134685952,
            134679689,
            134526800,
            134526768,
            134535955
        ],
        "134686556": [
            134530896,
            134676850
        ],
        "134686687": [
            134531584,
            134686687
        ],
        "134686941": [
            134683485,
            134686941,
            134534903
        ],
        "134687572": [
            134529984,
            134679972,
            134536006,
            134671630,
            134675287,
            134528560,
            134684246,
            134674871,
            134686941
        ],
        "134687831": [
            134675136,
            134673597,
            134672943
        ],
        "134687860": [
            134531648,
            134683888,
            134671413,
            134684918,
            134687831,
            134684858,
            134684028
        ],
        "134688066": [
            134676879
        ],
        "134688176": [
            134529072,
            134673573
        ],
        "134688211": [
            134676879
        ],
        "134688493": [
            134671593,
            134679779,
            134671532
        ],
        "134688608": [
            134531648,
            134528864,
            134675682,
            134527200,
            134678533,
            134675974,
            134671532,
            134688493,
            134529552,
            134673073,
            134530480,
            134531440,
            134534903,
            134535930,
            134675323
        ],
        "134689023": [
            134531584,
            134688493,
            134682287,
            134531440,
            134683032,
            134682841
        ],
        "134689626": [
            134676879
        ],
        "134689856": [
            134531584,
            134675682,
            134675974,
            134688493,
            134534927,
            134529040,
            134675287,
            134675965
        ],
        "134690464": [
            134677282
        ],
        "134691154": [
            134528992,
            134703521,
            134679495,
            134688493,
            134527920,
            134532016,
            134691154,
            134674009,
            134531440,
            134527216,
            134536600,
            134947609,
            134933852,
            134673597
        ],
        "134691719": [
            134691154
        ],
        "134691732": [
            134531648,
            134671878,
            134691154,
            134671859,
            134695966,
            134695803,
            134692670
        ],
        "134691962": [
            134672578,
            134674314,
            134679755,
            134691732,
            134704152
        ],
        "134692119": [
            134679657,
            134540652,
            134683086,
            134691962,
            134686556
        ],
        "134692325": [
            134705957,
            134679633,
            134704152,
            134691962,
            134686556
        ],
        "134692670": [
            134695941,
            134671878,
            134691719,
            134671368,
            134674314,
            134695966,
            134528416,
            134682147,
            134682287,
            134941875,
            134531648,
            134676422,
            134674253,
            134679633,
            134691154,
            134683862,
            134686556,
            134672123,
            134692325,
            134531440,
            134676850,
            134671859,
            134674167,
            134691962,
            134695803
        ],
        "134695589": [
            134531456,
            134673414,
            134700299,
            134674253,
            134691154,
            134674167,
            134692670
        ],
        "134695803": [
            134532032,
            134695589,
            134536006,
            134674960,
            134676535
        ],
        "134695941": [
            134695803
        ],
        "134695966": [
            134691154,
            134695941,
            134671878
        ],
        "134696007": [
            134695803,
            134692325
        ],
        "134696060": [
            134531456,
            134526752,
            134696007,
            134674253,
            134674960,
            134696690,
            134671413,
            134676566,
            134674167,
            134676603
        ],
        "134696278": [
            134531456,
            134530400,
            134676422,
            134682993,
            134683862,
            134696060,
            134673597
        ],
        "134696585": [
            134696060
        ],
        "134696690": [
            134673573,
            134672262,
            134702472,
            134696585,
            134672107,
            134671918,
            134535982,
            134672943,
            134696690,
            134676275,
            134686687,
            134672669,
            134702334,
            134702687
        ],
        "134697230": [
            134531584,
            134529920,
            134673548,
            134676240,
            134674960,
            134680596,
            134683032,
            134947609,
            134681883,
            134528416,
            134699681,
            134673573,
            134682287,
            134530864,
            134676535,
            134674636,
            134683086,
            134687572,
            134675287,
            134682841,
            134673882,
            134531936,
            134688493,
            134681709,
            134530928,
            134528752,
            134696690,
            134674555
        ],
        "134698395": [
            134531648,
            134675974,
            134681575,
            134683086,
            134697230,
            134527216,
            134683862,
            134675287,
            134681791
        ],
        "134699681": [
            134531648,
            134674636,
            134697230,
            134676850,
            134698395,
            134683862,
            134675287,
            134683032,
            134674555,
            134689023
        ],
        "134700299": [
            134531968,
            134531584,
            134685952,
            134531648,
            134532032,
            134673573,
            134676422,
            134697230,
            134683086,
            134672816,
            134679633,
            134683862,
            134535930,
            134673882
        ],
        "134701254": [
            134531584,
            134534660,
            134538630,
            134700299,
            134529552,
            134530448,
            134676240,
            134528672,
            134673573,
            134531504,
            134687572,
            134675029,
            134675287,
            134673373,
            134531936,
            134527200,
            134677601,
            134528752,
            134684918
        ],
        "134702334": [
            134531456,
            134526752,
            134701254,
            134673414
        ],
        "134702472": [
            134671368,
            134700299,
            134540652,
            134676850,
            134675287
        ],
        "134702687": [
            134673573,
            134701254,
            134702472,
            134696690,
            134687572,
            134680596,
            134681883
        ],
        "134702894": [
            134530336,
            134700299,
            134683086,
            134697230,
            134674960,
            134696690,
            134676566,
            134673882,
            134683838
        ],
        "134703217": [
            134671792,
            134696690
        ],
        "134703326": [
            134675974,
            134700299,
            134671792,
            134674960,
            134696690,
            134676566
        ],
        "134703521": [
            134531456,
            134677775,
            134531504,
            134696060,
            134673597
        ],
        "134703636": [
            134679495,
            134696007,
            134679535,
            134674960,
            134696690,
            134676566,
            134681087
        ],
        "134703819": [
            134676879
        ],
        "134704115": [
            134676635,
            134703636,
            134695589,
            134674167
        ],
        "134704152": [
            134679633,
            134691154,
            134695803,
            134692670
        ],
        "134704287": [
            134692325,
            134918440,
            134530736,
            134679633,
            134676850,
            134679731,
            134692119,
            134691962,
            134686556,
            134704287
        ],
        "134705957": [
            134679633,
            134691962,
            134704287
        ],
        "134706124": [
            134532032,
            134675965,
            134678130,
            134673573
        ],
        "134706396": [
            134531456,
            134672064,
            134673573,
            134674507,
            134706124,
            134672107,
            134696690
        ],
        "134706667": [
            134531584,
            134677761,
            134703636,
            134674455,
            134676635,
            134672669,
            134673573,
            134679731,
            134671413,
            134531648,
            134529472,
            134676422,
            134671431,
            134675287,
            134706396,
            134527200,
            134684918,
            134674167,
            134684028
        ],
        "134707562": [
            134672578,
            134678695,
            134706667,
            134679755,
            134682479,
            134688176,
            134671413,
            134684028
        ],
        "134707875": [
            134707562
        ],
        "134707948": [
            134676879
        ],
        "134708019": [
            134531936,
            134527936,
            134673573,
            134918440,
            134706667,
            134528752,
            134696690,
            134687572,
            134680596,
            134675287,
            134681883
        ],
        "134708375": [
            134676879
        ],
        "134708664": [
            134675974,
            134702472,
            134700299,
            134673548,
            134529424,
            134674960,
            134680596,
            134681883,
            134682783,
            134526752,
            134679972,
            134695589,
            134673573,
            134918440,
            134671918,
            134672943,
            134679731,
            134675635,
            134676275,
            134673597,
            134676422,
            134678218,
            134674507,
            134679755,
            134706124,
            134531792,
            134687572,
            134676566,
            134696278,
            134682328,
            134706396,
            134538845,
            134671456,
            134706667,
            134688493,
            134531440,
            134687860,
            134671481,
            134702334
        ],
        "134710171": [
            134531456,
            134675078,
            134675974,
            134673548,
            134674960,
            134703636,
            134933781,
            134676635,
            134703521,
            134673573,
            134535982,
            134672943,
            134527664,
            134676275,
            134532032,
            134706124,
            134526800,
            134528080,
            134533841,
            134678740,
            134676566,
            134675287,
            134673882,
            134688608,
            134688493,
            134678130,
            134704115,
            134674167,
            134696060
        ],
        "134711232": [
            134530896,
            134957642,
            134713091,
            134957357
        ],
        "134712402": [
            134531584,
            134530240,
            134711232,
            134713091,
            134918440,
            134950540,
            134949966
        ],
        "134713091": [
            134530736,
            134712402
        ],
        "134713234": [
            134712402
        ],
        "134713258": [
            134527664,
            134540254
        ],
        "134713399": [
            134527920,
            134526960
        ],
        "134713478": [],
        "134713549": [
            134529568,
            134530624,
            134530496,
            134531648,
            134532032,
            134713478,
            134540652,
            134536591,
            134529072,
            134531888,
            134528080,
            134535955,
            134540308,
            134530928,
            134534644
        ],
        "134714871": [
            134530304,
            134526816,
            134534053,
            134527792,
            134526960,
            134530736,
            134534644,
            134713399,
            134532413,
            134540446
        ],
        "134715303": [
            134531328,
            134528256,
            134539105,
            134534053,
            134949993,
            134955212,
            134921900,
            134953997,
            134529584,
            134529552,
            134530672,
            134531792,
            134538996
        ],
        "134715783": [
            134532032,
            134528640,
            134949966,
            134526800,
            134529744,
            134537680,
            134537139,
            134537113
        ],
        "134715924": [
            134531440,
            134529808
        ],
        "134715983": [
            134531584,
            134527264,
            134528672,
            134529088,
            134915140,
            134531936,
            134538630,
            134530448,
            134528912,
            134530896,
            134529744,
            134530544
        ],
        "134716674": [
            134715983
        ],
        "134716698": [
            134937345,
            134716674,
            134715783,
            134953997,
            134529552,
            134536343,
            134537113,
            134529568,
            134529824,
            134534053,
            134921900,
            134535982,
            134956466,
            134539188,
            134532032,
            134937283,
            134540362,
            134955212,
            134715983,
            134531792,
            134949848,
            134531936,
            134539105,
            134540652
        ],
        "134717542": [
            134531584,
            134534624,
            134529632,
            134921900,
            134531472,
            134527152,
            134529584,
            134535955,
            134715924,
            134530896,
            134530672,
            134912535
        ],
        "134717935": [
            134760033,
            134760122
        ],
        "134717976": [
            134529840,
            134526960,
            134529952
        ],
        "134718036": [
            134527328,
            134529952,
            134532546,
            134918727,
            134534089,
            134955212,
            134921900,
            134918636,
            134528272,
            134526960,
            134529840,
            134955155,
            134528144,
            134717976
        ],
        "134718439": [
            134531328,
            134532064,
            134538630,
            134534089,
            134921900,
            134536600,
            134535930
        ],
        "134718742": [
            134526880,
            134537257,
            134921900,
            134536343,
            134536222
        ],
        "134718865": [
            134532546,
            134536130,
            134534089,
            134921900,
            134954894,
            134527376
        ],
        "134719032": [
            134530736
        ],
        "134719069": [
            134526960
        ],
        "134719422": [],
        "134719481": [
            134531584,
            134529472,
            134533666,
            134532546,
            134940000,
            134536161,
            134534624,
            134939948,
            134955244,
            134530736,
            134530000,
            134719422,
            134719032,
            134719069,
            134537406
        ],
        "134720860": [
            134534624,
            134536161,
            134534053,
            134921900,
            134526960,
            134527920,
            134537203,
            134535930,
            134538684,
            134537406
        ],
        "134721331": [],
        "134721359": [],
        "134721380": [],
        "134721544": [],
        "134721578": [],
        "134721664": [],
        "134721788": [
            134536161,
            134536343
        ],
        "134721810": [
            134526960
        ],
        "134722006": [
            134526960
        ],
        "134722048": [
            134526960,
            134527920
        ],
        "134722155": [
            134527920
        ],
        "134722378": [
            134526752,
            134721788,
            134534624
        ],
        "134722416": [
            134531600,
            134722378
        ],
        "134722460": [
            134722416,
            134722378,
            134538723,
            134535982
        ],
        "134722546": [],
        "134722567": [
            134722048,
            134722546
        ],
        "134722906": [
            134531296,
            134933852
        ],
        "134722977": [
            134722906
        ],
        "134723002": [
            134530896,
            134535982,
            134911751
        ],
        "134723072": [
            134529760,
            134531296,
            134537314,
            134528128,
            134536365,
            134527920,
            134722416
        ],
        "134723270": [
            134526960,
            134536600
        ],
        "134723418": [
            134528256,
            134957960,
            134527920,
            134526960,
            134722906
        ],
        "134723830": [
            134526960,
            134723418
        ],
        "134723904": [
            134526960,
            134723830,
            134527920,
            134721359
        ],
        "134724019": [
            134526960,
            134723830,
            134527920,
            134721359
        ],
        "134724121": [
            134526960
        ],
        "134724520": [
            134526960,
            134724121,
            134527920
        ],
        "134724750": [
            134722048,
            134724121,
            134721664,
            134526960
        ],
        "134725462": [
            134531584,
            134527264,
            134911751,
            134721578,
            134535982,
            134721359,
            134529072,
            134527920,
            134721810,
            134530736,
            134721331,
            134530896,
            134926674,
            134526960,
            134536600,
            134724121,
            134723002
        ],
        "134726513": [
            134722048,
            134722567,
            134721544,
            134957960,
            134530448,
            134531600,
            134536343,
            134722460,
            134915102,
            134526880,
            134527920,
            134722378,
            134728526,
            134722006,
            134538723,
            134915048,
            134526960,
            134722416,
            134722546,
            134534644,
            134535930,
            134721788
        ],
        "134728526": [
            134526960,
            134726513
        ],
        "134728632": [
            134531456,
            134527264,
            134530432,
            134527200,
            134534053,
            134722567,
            134533648,
            134531472,
            134726513,
            134721810,
            134526960,
            134725462,
            134954295,
            134721788
        ],
        "134728989": [
            134526880,
            134531584,
            134531936,
            134954264,
            134530896,
            134530448,
            134531472,
            134530000,
            134728632
        ],
        "134729213": [
            134721664,
            134527264,
            134721380,
            134535982,
            134527920,
            134526960,
            134723418
        ],
        "134730524": [
            134729213,
            134535982
        ],
        "134730630": [
            134722048,
            134723072,
            134722567,
            134721544,
            134724750,
            134536600,
            134730524,
            134728989,
            134527264,
            134722977,
            134724520,
            134721578,
            134921900,
            134535982,
            134527920,
            134721331,
            134724019,
            134728632,
            134723904,
            134532546,
            134723270,
            134728526,
            134725462,
            134722006,
            134723418,
            134531296,
            134721380,
            134722155,
            134540652,
            134527216,
            134726513,
            134526960,
            134723830,
            134721788,
            134729213
        ],
        "134733056": [
            134534624,
            134921922,
            134941219,
            134953987,
            134955399,
            134534089,
            134530448,
            134530736,
            134529520,
            134534129,
            134920313
        ],
        "134733357": [
            134536161,
            134950490,
            134537257
        ],
        "134733432": [
            134536161,
            134921922,
            134537406
        ],
        "134733504": [
            134921922,
            134954894,
            134526960,
            134536222,
            134537406
        ],
        "134733732": [
            134531584,
            134535930,
            134536006
        ],
        "134733894": [
            134531648,
            134733732,
            134527248,
            134530704,
            134526960,
            134536600
        ],
        "134734246": [
            134531584,
            134937345,
            134921922,
            134531552,
            134534624,
            134536006,
            134733894,
            134530736,
            134527920,
            134527440,
            134956851,
            134529904,
            134534644
        ],
        "134734843": [
            134530304,
            134531648,
            134532546,
            134530432,
            134532032,
            134954309,
            134916742,
            134955399,
            134916716,
            134950540,
            134918127,
            134954453,
            134920282
        ],
        "134735225": [
            134532032,
            134916742,
            134916716,
            134921900,
            134918127,
            134530896,
            134526768,
            134955155,
            134535930,
            134954782
        ],
        "134735632": [
            134531104,
            134528320,
            134529088,
            134921922,
            134949442,
            134531808,
            134912995,
            134949575,
            134534089,
            134949356,
            134530320,
            134530288,
            134528624,
            134526960,
            134949623,
            134537406
        ],
        "134736060": [
            134527104,
            134530304,
            134532546,
            134534053,
            134918727,
            134955180,
            134540652,
            134955244,
            134527632,
            134528016,
            134530608,
            134527920,
            134529328,
            134531920,
            134534644
        ],
        "134736749": [
            134527392,
            134526960,
            134530752
        ],
        "134736925": [
            134529088,
            134530752,
            134736749,
            134530608,
            134526960
        ],
        "134737716": [
            134527104,
            134529088,
            134530752,
            134736749,
            134526960
        ],
        "134738580": [
            134530752,
            134529088,
            134736749,
            134528016,
            134526960
        ],
        "134739216": [
            134527104,
            134529088,
            134532546,
            134534053,
            134918727,
            134534089,
            134921900,
            134955376,
            134526960,
            134528016,
            134530608,
            134737716,
            134738580,
            134536600,
            134736925
        ],
        "134740143": [
            134529088,
            134536161,
            134532546,
            134538723,
            134533666,
            134918727,
            134536457,
            134534089,
            134526960,
            134531600,
            134530736,
            134526800
        ],
        "134740623": [
            134532032,
            134534624,
            134532546,
            134938152,
            134954922,
            134921900,
            134526960,
            134530896,
            134527920,
            134938100,
            134938007,
            134534143
        ],
        "134741035": [
            134532032,
            134940000,
            134536006,
            134955180,
            134530736,
            134533841,
            134939921,
            134526960,
            134939958,
            134536600
        ],
        "134741516": [
            134948169,
            134921900
        ],
        "134741561": [
            134532032,
            134940000,
            134536006,
            134955180,
            134530736,
            134533841,
            134939921,
            134526960,
            134939958
        ],
        "134741858": [
            134948169
        ],
        "134741887": [],
        "134741901": [],
        "134741940": [
            134532032,
            134531632,
            134741901
        ],
        "134742036": [
            134529408,
            134938809
        ],
        "134742074": [
            134531584,
            134528640,
            134950540,
            134536077,
            134741901,
            134533648,
            134939921,
            134528528,
            134742036,
            134533909,
            134950559,
            134528928,
            134939168,
            134528032,
            134534053,
            134918440,
            134535982,
            134940591,
            134538802,
            134956851,
            134741940,
            134939958,
            134956986,
            134536639,
            134529472,
            134531648,
            134532032,
            134536006,
            134536781,
            134526800,
            134530000,
            134531792,
            134527440,
            134533841,
            134528464,
            134529744,
            134536029,
            134957021,
            134940000,
            134530528,
            134530272,
            134527344,
            134534644
        ],
        "134744050": [
            134531584,
            134528928,
            134527904,
            134532032,
            134536006,
            134536781,
            134526800,
            134530736,
            134528464,
            134742074,
            134536639
        ],
        "134744301": [
            134530288,
            134530896,
            134540160
        ],
        "134744362": [
            134529408,
            134536964,
            134536457,
            134530448,
            134533909,
            134536343,
            134531616,
            134527264,
            134533666,
            134529056,
            134535982,
            134530736,
            134527664,
            134742074,
            134536639,
            134529600,
            134942400,
            134532546,
            134948169,
            134528464,
            134527440,
            134532048,
            134530640,
            134536404,
            134954203,
            134528480,
            134531936,
            134744301,
            134527856,
            134528496,
            134534768,
            134537203,
            134534644,
            134534903,
            134535930
        ],
        "134745408": [
            134534624,
            134527456,
            134532546,
            134941219,
            134528080,
            134537232,
            134527920
        ],
        "134745556": [],
        "134745579": [],
        "134745668": [
            134536457,
            134536365
        ],
        "134745708": [
            134537473,
            134957960,
            134537232,
            134536343,
            134536600,
            134921900,
            134536365,
            134535982,
            134920375,
            134745668,
            134949966,
            134526800,
            134745556,
            134534624,
            134536161,
            134745579,
            134526960,
            134530544,
            134536435,
            134534644,
            134919029,
            134535930
        ],
        "134747929": [
            134526880,
            134529728,
            134534624,
            134536161,
            134957960,
            134921900,
            134536365,
            134535982,
            134537232,
            134529040,
            134526800,
            134530544,
            134534644,
            134920375,
            134537406
        ],
        "134749342": [
            134527648,
            134536161,
            134531072,
            134957960,
            134536457,
            134921900,
            134536365,
            134949966,
            134526960,
            134920375
        ],
        "134749590": [
            134535288
        ],
        "134749617": [
            134535216,
            134531888,
            134531504
        ],
        "134749652": [
            134527360,
            134530432,
            134536576,
            134957960,
            134536591,
            134535700,
            134749590,
            134954264,
            134528672,
            134912164,
            134921900,
            134531888,
            134954295,
            134538952,
            134528080,
            134527312,
            134528592,
            134532064,
            134526960
        ],
        "134750406": [
            134531648,
            134531584,
            134528544,
            134526800,
            134535955
        ],
        "134750636": [
            134531584,
            134531648,
            134532032,
            134536006,
            134529648,
            134536639
        ],
        "134750816": [
            134530720,
            134534644,
            134534624
        ],
        "134750929": [
            134950540,
            134533648,
            134950435,
            134534053,
            134938152,
            134530736,
            134956466,
            134956726,
            134954295,
            134956477,
            134536639,
            134529472,
            134531648,
            134532032,
            134750406,
            134536006,
            134920282,
            134937311,
            134750816,
            134527200,
            134531936,
            134530928,
            134534644,
            134938100
        ],
        "134752064": [
            134937345,
            134529808,
            134530720,
            134950435,
            134750636,
            134921900,
            134535982,
            134530736,
            134939186,
            134531648,
            134532032,
            134750406,
            134536006,
            134534089,
            134531792,
            134750929,
            134937940,
            134534624,
            134530032,
            134529136,
            134526960,
            134529648,
            134919029,
            134534143
        ],
        "134753221": [
            134527200,
            134530048,
            134534053,
            134921900,
            134528496,
            134527856,
            134526960,
            134919794,
            134536639
        ],
        "134753692": [
            134528240,
            134532546,
            134941219
        ],
        "134753733": [
            134534624
        ],
        "134753743": [
            134534624,
            134529088,
            134956613,
            134534089,
            134921900,
            134528688,
            134529552,
            134526960,
            134530544,
            134534644,
            134531312,
            134538684
        ],
        "134753936": [
            134531936,
            134536161,
            134534624,
            134954309,
            134957960,
            134948136,
            134921900,
            134536365,
            134531472,
            134530736,
            134530000,
            134526800,
            134526960,
            134534644
        ],
        "134755859": [
            134955360,
            134527520,
            134532546,
            134531648,
            134534053,
            134540652,
            134530864,
            134527504,
            134534644
        ],
        "134756205": [
            134532546,
            134534089,
            134918636,
            134921900,
            134533648,
            134527536
        ],
        "134756356": [
            134534624,
            134912680
        ],
        "134756385": [
            134531392,
            134534624,
            134532546,
            134921922,
            134756356,
            134534053,
            134534089,
            134918636,
            134531728,
            134527568,
            134527824,
            134526960,
            134529904,
            134912757,
            134536600,
            134912793,
            134912282
        ],
        "134757327": [
            134526880,
            134921900,
            134918636,
            134531696,
            134537596
        ],
        "134757412": [
            134529376,
            134527200,
            134530800,
            134534129,
            134534644,
            134760574
        ],
        "134757684": [
            134532032,
            134532546,
            134757412,
            134954309,
            134921900,
            134531792,
            134531184,
            134530736,
            134528048,
            134954295,
            134920282
        ],
        "134757949": [
            134531936,
            134536161,
            134534089,
            134529424,
            134530000,
            134538802
        ],
        "134758106": [
            134530048,
            134530560,
            134529888,
            134531744,
            134532032,
            134528336,
            134533841,
            134529744,
            134758106
        ],
        "134758285": [
            134536964,
            134531728,
            134531216,
            134536212,
            134536343,
            134912793,
            134530720,
            134912680,
            134921900,
            134527664,
            134537013,
            134757949,
            134527424,
            134532546,
            134534089,
            134527824,
            134758106,
            134527200,
            134534624,
            134530016,
            134529904,
            134537203,
            134534644,
            134536315
        ],
        "134758983": [
            134531584,
            134531648,
            134527296,
            134953987,
            134532064,
            134534089,
            134955594,
            134530992,
            134527664,
            134527920,
            134537139,
            134528464,
            134534768,
            134537113,
            134536698,
            134538684
        ],
        "134759394": [
            134529184,
            134530720,
            134530112,
            134532032,
            134532546,
            134534053,
            134536006,
            134534624,
            134921900,
            134535982,
            134530736,
            134530032,
            134939186,
            134529136,
            134534644,
            134938100,
            134537884
        ],
        "134759984": [
            134948169
        ],
        "134760033": [
            134759984,
            134536600,
            134526960
        ],
        "134760122": [
            134526880,
            134536006,
            134760774,
            134535982,
            134530448,
            134760661,
            134760757,
            134536029
        ],
        "134760364": [
            134527856,
            134760122,
            134529648,
            134533909
        ],
        "134760456": [
            134759984,
            134530736,
            134536006
        ],
        "134760518": [
            134759984,
            134529808,
            134536006
        ],
        "134760574": [
            134533648,
            134760456,
            134760518
        ],
        "134760661": [
            134761344,
            134762147,
            134760806,
            134761160,
            134762860,
            134762221,
            134762927,
            134761081
        ],
        "134760757": [
            134535982
        ],
        "134760774": [
            134531936,
            134762860,
            134532032
        ],
        "134760806": [
            134529920,
            134762570,
            134762539,
            134762927
        ],
        "134761081": [
            134762570,
            134762468,
            134762927
        ],
        "134761160": [
            134762570,
            134762539,
            134762927
        ],
        "134761257": [
            134761257
        ],
        "134761344": [
            134529920,
            134762468,
            134761257,
            134762570,
            134762927
        ],
        "134762147": [
            134762927
        ],
        "134762221": [
            134762570,
            134762927
        ],
        "134762283": [],
        "134762468": [
            134528816
        ],
        "134762539": [
            134762283
        ],
        "134762570": [
            134530896
        ],
        "134762860": [
            134532032
        ],
        "134762927": [
            134538723,
            134762860,
            134531600,
            134535955,
            134535930
        ],
        "134763254": [
            134529088,
            134939274,
            134526960
        ],
        "134763327": [
            134534624,
            134529424,
            134536365
        ],
        "134763488": [
            134538522,
            134763327
        ],
        "134763542": [
            134797402
        ],
        "134763561": [
            134531936,
            134937345,
            134532546,
            134536161,
            134536232,
            134536639,
            134921900,
            134536365,
            134537232,
            134800177,
            134530896,
            134937311,
            134803348,
            134533909,
            134537203,
            134538522,
            134763327
        ],
        "134764116": [
            134528928,
            134530736
        ],
        "134764170": [
            134528928,
            134530736,
            134536006
        ],
        "134764268": [
            134536639
        ],
        "134764284": [
            134531584,
            134532032,
            134527200,
            134803011,
            134534660,
            134534624,
            134957960,
            134536232,
            134536171,
            134529040,
            134529744,
            134528080,
            134527088,
            134534129,
            134536435,
            134534644,
            134536343
        ],
        "134764921": [
            134921922,
            134764284
        ],
        "134764991": [
            134921900,
            134764284
        ],
        "134765058": [
            134921900,
            134532546,
            134764284
        ],
        "134765141": [
            134921900,
            134532546,
            134764284
        ],
        "134765223": [
            134536161,
            134921922,
            134937283,
            134532546,
            134803630,
            134529040,
            134800177,
            134536343,
            134797560,
            134957246
        ],
        "134765588": [],
        "134765719": [],
        "134765920": [],
        "134766021": [
            134765920,
            134765719
        ],
        "134766861": [],
        "134767107": [],
        "134767408": [
            134538684,
            134915102
        ],
        "134767468": [
            134767408
        ],
        "134767711": [
            134536365
        ],
        "134767747": [
            134767711
        ],
        "134767843": [
            134767747
        ],
        "134767865": [
            134767843
        ],
        "134767929": [
            134767865
        ],
        "134768264": [
            134767865
        ],
        "134768587": [
            134767711
        ],
        "134768663": [
            134767843,
            134766021,
            134767865,
            134768264,
            134768587,
            134766861,
            134765588,
            134767929,
            134767711
        ],
        "134769162": [
            134767107,
            134767468,
            134768663
        ],
        "134770088": [
            134765920,
            134767843,
            134767747,
            134769162,
            134767468,
            134767408,
            134765588,
            134767711
        ],
        "134770860": [
            134915048,
            134921900,
            134535982,
            134764921,
            134764284
        ],
        "134771032": [],
        "134771072": [],
        "134771168": [
            134528928,
            134530736,
            134536639
        ],
        "134771250": [
            134948086
        ],
        "134771272": [
            134915102
        ],
        "134771288": [
            134771072,
            134771272
        ],
        "134771335": [
            134771288,
            134948086
        ],
        "134771363": [
            134534624,
            134771072,
            134532032,
            134771272,
            134536365,
            134535982,
            134802063,
            134771250,
            134948086
        ],
        "134771904": [
            134529920,
            134534624,
            134771363,
            134771335,
            134771250,
            134948086
        ],
        "134772362": [
            134771032,
            134527216
        ],
        "134773827": [
            134771072,
            134534624,
            134532032,
            134538723,
            134771272,
            134800968,
            134772362,
            134536365,
            134535982,
            134801875
        ],
        "134774380": [
            134534624,
            134773827,
            134771288,
            134536365
        ],
        "134774636": [
            134771904,
            134774380
        ],
        "134774665": [
            134915048,
            134921900,
            134764284
        ],
        "134774779": [
            134530432,
            134937345,
            134534008,
            134920282,
            134954395,
            134937311
        ],
        "134774879": [
            134531936,
            134948169,
            134536365,
            134537232,
            134534644
        ],
        "134775004": [
            134530896
        ],
        "134775066": [
            134526800,
            134775004,
            134536365
        ],
        "134775172": [
            134531584,
            134536365,
            134526800,
            134775066,
            134775004
        ],
        "134775381": [
            134531584,
            134529728,
            134532032,
            134537825,
            134775172,
            134942346,
            134949966,
            134529040,
            134527856,
            134528496,
            134534644,
            134942329,
            134775066,
            134775004
        ],
        "134776220": [
            134531584,
            134530336,
            134531936,
            134536365,
            134526800,
            134534644,
            134536212,
            134775381,
            134535930,
            134538522,
            134803423
        ],
        "134776706": [
            134536964,
            134529552,
            134798509,
            134803630,
            134535982,
            134527920,
            134800177,
            134530736,
            134536639,
            134531648,
            134921922,
            134536006,
            134528464,
            134797402,
            134937311,
            134534624,
            134536161,
            134774879,
            134527984,
            134534008,
            134920313,
            134774779
        ],
        "134777484": [
            134530048,
            134534089
        ],
        "134777535": [
            134532032,
            134534660,
            134536006,
            134527760,
            134938809
        ],
        "134777581": [
            134531600,
            134538522
        ],
        "134777631": [
            134531472,
            134534089,
            134536591
        ],
        "134777672": [
            134530304,
            134531584,
            134536964,
            134534660,
            134536457,
            134777484,
            134787855,
            134530448,
            134531600,
            134795024,
            134533909,
            134536343,
            134538522,
            134777631,
            134535982,
            134803630,
            134527920,
            134938809,
            134777535,
            134532032,
            134532546,
            134937283,
            134536130,
            134803524,
            134536006,
            134803011,
            134526800,
            134530896,
            134797402,
            134803423,
            134534624,
            134531936,
            134538723,
            134912995,
            134949993,
            134777581,
            134526960,
            134534644,
            134948086,
            134534008,
            134783481,
            134535930,
            134536315,
            134788732
        ],
        "134780178": [
            134530048,
            134528640,
            134528528,
            134538522,
            134528928,
            134534053,
            134781357,
            134530736,
            134938809,
            134531648,
            134531904,
            134536130,
            134803524,
            134534089,
            134529744,
            134531936,
            134534624,
            134527344,
            134527088,
            134534644
        ],
        "134780916": [
            134528464,
            134535881
        ],
        "134780933": [
            134531936,
            134534624,
            134536293,
            134534089,
            134535852,
            134529552,
            134527888,
            134780916,
            134538522,
            134536315,
            134537596,
            134536639
        ],
        "134781332": [
            134538522
        ],
        "134781357": [],
        "134781377": [
            134529568,
            134526752
        ],
        "134781542": [
            134781377
        ],
        "134783042": [
            134781542
        ],
        "134783280": [
            134532032,
            134781377,
            134534660,
            134535982,
            134535891,
            134914941
        ],
        "134783460": [
            134532032
        ],
        "134783481": [
            134531456,
            134532032,
            134783042,
            134803100,
            134783460,
            134783280,
            134803027,
            134534644,
            134535930,
            134538684
        ],
        "134783878": [
            134532032
        ],
        "134783902": [
            134535982
        ],
        "134784950": [
            134526752,
            134783878
        ],
        "134784994": [
            134538684,
            134784950
        ],
        "134785167": [
            134527216,
            134538723,
            134534644
        ],
        "134785274": [
            134784994,
            134783902,
            134784950,
            134783878
        ],
        "134786623": [
            134784994,
            134784950,
            134783878
        ],
        "134787251": [
            134531456,
            134532032,
            134784994,
            134915039,
            134534644,
            134784950,
            134535930,
            134785274,
            134803100,
            134915102,
            134786623
        ],
        "134787855": [
            134532032,
            134535930,
            134787251,
            134535982
        ],
        "134787972": [
            134532032,
            134535982,
            134785167,
            134527216,
            134803027,
            134787251,
            134534644,
            134535930
        ],
        "134788548": [
            134534624,
            134538684
        ],
        "134788631": [
            134788548
        ],
        "134788732": [
            134532032,
            134538723,
            134788548,
            134535982,
            134534644,
            134788631,
            134535930,
            134803100
        ],
        "134790243": [],
        "134790344": [],
        "134790794": [
            134790344,
            134790243
        ],
        "134793051": [],
        "134793213": [],
        "134793294": [],
        "134793371": [
            134915102
        ],
        "134793397": [
            134793371
        ],
        "134793439": [],
        "134793532": [
            134527216,
            134790794
        ],
        "134795024": [
            134529920,
            134532032,
            134528064,
            134793051,
            134803236,
            134915048,
            134793294,
            134526800,
            134534644,
            134793397,
            134793532,
            134535930,
            134793371,
            134538684,
            134793213,
            134793439
        ],
        "134797332": [
            134797402
        ],
        "134797351": [
            134797439
        ],
        "134797402": [
            134530336
        ],
        "134797439": [
            134530336
        ],
        "134797560": [
            134939168,
            134532032,
            134534624,
            134538723,
            134949993,
            134803725,
            134535982,
            134781357,
            134533648,
            134530736,
            134530000,
            134526800,
            134948086,
            134535930
        ],
        "134798408": [
            134530240,
            134534624
        ],
        "134798509": [
            134803725,
            134533648,
            134939168,
            134781357,
            134535982,
            134532032,
            134937283,
            134536006,
            134798408,
            134533841,
            134536029,
            134803423,
            134534624,
            134538723,
            134949993,
            134540652,
            134534644,
            134948086,
            134534008,
            134535930
        ],
        "134799972": [
            134527920
        ],
        "134799981": [
            134531104,
            134939274,
            134536600,
            134526960
        ],
        "134800177": [
            134535982
        ],
        "134800249": [],
        "134800968": [
            134800249
        ],
        "134801156": [],
        "134801875": [
            134801156
        ],
        "134802063": [],
        "134803011": [],
        "134803027": [
            134538723,
            134534644
        ],
        "134803100": [
            134532032,
            134535955,
            134534053,
            134538630
        ],
        "134803236": [
            134803100,
            134534660
        ],
        "134803257": [
            134531600,
            134803329,
            134534089
        ],
        "134803329": [
            134538522
        ],
        "134803348": [
            134533648,
            134803835,
            134534624,
            134948086
        ],
        "134803423": [
            134533648,
            134534644,
            134529472
        ],
        "134803524": [
            134529472,
            134530272,
            134534089,
            134536639,
            134937311
        ],
        "134803630": [
            134531584,
            134534624,
            134531280
        ],
        "134803725": [
            134957642
        ],
        "134803796": [],
        "134803806": [
            134534624,
            134540652
        ],
        "134803835": [
            134529568,
            134534624,
            134781357,
            134530928,
            134527216,
            134531600,
            134948115,
            134803835,
            134536029,
            134803806
        ],
        "134804222": [],
        "134804223": [
            134955212,
            134950490,
            134919891,
            134920060
        ],
        "134804266": [
            134535238
        ],
        "134804286": [
            134532546,
            134919891,
            134955212,
            134537406
        ],
        "134804356": [
            134528992,
            134532546,
            134919891,
            134537314
        ],
        "134804510": [
            134534624,
            134532032,
            134947842,
            134534089,
            134921900,
            134535982,
            134919891,
            134535930,
            134537406
        ],
        "134805529": [
            134534624,
            134526880,
            134532546,
            134533648,
            134919891,
            134948086,
            134535930
        ],
        "134805721": [
            134531008,
            134918636,
            134526880,
            134531696
        ],
        "134805764": [
            134526880,
            134536161,
            134531936,
            134534624,
            134920313,
            134534089,
            134955212,
            134921900,
            134953997,
            134530448,
            134530896,
            134535732,
            134805721,
            134536315,
            134920060,
            134537406
        ],
        "134806162": [
            134528080,
            134840176,
            134526960
        ],
        "134806209": [
            134531888,
            134531504
        ],
        "134806230": [
            134530496,
            134526880,
            134538952,
            134531888,
            134531664,
            134528688,
            134530960,
            134526960
        ],
        "134806442": [
            134536161,
            134921900,
            134537406
        ],
        "134806515": [
            134532546,
            134537257,
            134955212,
            134919891,
            134955155
        ],
        "134806649": [
            134536161,
            134955212,
            134537406,
            134536639
        ],
        "134806732": [
            134531584,
            134532546,
            134538630,
            134533967,
            134530736
        ],
        "134806875": [
            134529568,
            134912164,
            134918727,
            134954410,
            134921900,
            134526960,
            134529072,
            134941717,
            134941468
        ],
        "134807293": [
            134807786,
            134536639
        ],
        "134807351": [
            134527200,
            134528640,
            134534624,
            134939274,
            134940591,
            134526960,
            134534129
        ],
        "134807521": [
            134531648,
            134948169,
            134921900
        ],
        "134807663": [
            134526960,
            134534129
        ],
        "134807786": [
            134948169,
            134921900,
            134957246
        ],
        "134807937": [
            134920313,
            134532546,
            134918636,
            134537013
        ],
        "134807989": [
            134531936,
            134918727,
            134954410,
            134921900,
            134526960,
            134915059,
            134538684,
            134914941
        ],
        "134808265": [
            134534624,
            134532032,
            134849895,
            134921900,
            134533967,
            134849968,
            134533841,
            134913143
        ],
        "134808591": [],
        "134808604": [
            134531584,
            134531648,
            134532032,
            134534624,
            134531040,
            134527712,
            134532064,
            134955399,
            134918727,
            134921900,
            134535982,
            134527920,
            134529072,
            134956851,
            134954358,
            134918680,
            134920282
        ],
        "134809595": [
            134531104,
            134531232,
            134531136,
            134532546,
            134921922,
            134534053,
            134531552,
            134534624,
            134540132,
            134533648,
            134527920,
            134528464,
            134526800,
            134533716,
            134530544,
            134531312,
            134537203,
            134539261
        ],
        "134810325": [
            134531648,
            134533666,
            134534624
        ],
        "134810415": [
            134534053,
            134538630
        ],
        "134810506": [
            134529040
        ],
        "134810574": [
            134531072,
            134539138,
            134536457,
            134810506,
            134954894,
            134532112,
            134531600,
            134536343,
            134528672,
            134533666,
            134810415,
            134955192,
            134538684,
            134531648,
            134532546,
            134810325,
            134534624,
            134536161,
            134531936,
            134538723,
            134534129,
            134535930,
            134534143
        ],
        "134812027": [
            134530112,
            134534089,
            134921900,
            134530736,
            134527440,
            134528976,
            134526960,
            134530032,
            134531184,
            134534644,
            134919029,
            134534129,
            134926462,
            134536639
        ],
        "134812797": [
            134527760,
            134950490,
            134527920,
            134536591
        ],
        "134812825": [
            134530432,
            134532032,
            134527456,
            134941219,
            134536259,
            134954309,
            134532064,
            134921900,
            134954350,
            134537232,
            134537680,
            134527312,
            134528592,
            134529744,
            134536532,
            134527728,
            134534143,
            134536639
        ],
        "134813249": [
            134526960,
            134926462
        ],
        "134813306": [
            134530048,
            134531744,
            134529888,
            134532032,
            134527200,
            134813249,
            134928137,
            134534129,
            134928241,
            134913013,
            134537049,
            134813306
        ],
        "134813687": [
            134813249,
            134918727,
            134921900,
            134527440,
            134813306,
            134928380
        ],
        "134813978": [
            134531584,
            134532032,
            134534053,
            134538630,
            134526768,
            134941875,
            134535930
        ],
        "134814290": [
            134528512,
            134937345,
            134921922,
            134531648,
            134918727,
            134534089,
            134918636,
            134528464,
            134527920
        ],
        "134814473": [],
        "134814515": [
            134536639
        ],
        "134814551": [
            134535982,
            134536006
        ],
        "134814585": [
            134528176,
            134532032
        ],
        "134814679": [
            134534624,
            134814585,
            134957642,
            134957357
        ],
        "134814885": [
            134532032
        ],
        "134814911": [
            134530736
        ],
        "134814961": [
            134530528,
            134535982,
            134531632,
            134814515,
            134534644,
            134814551,
            134956986
        ],
        "134815198": [
            134814961,
            134814911,
            134814885,
            134816079
        ],
        "134815271": [
            134814885,
            134535982,
            134814679,
            134815198,
            134814911
        ],
        "134815400": [
            134814885,
            134815271,
            134535982,
            134814679,
            134814911
        ],
        "134815513": [
            134814885,
            134815400,
            134535982,
            134530736,
            134814515,
            134814585,
            134814911
        ],
        "134815889": [
            134814885,
            134814473,
            134535982,
            134815513,
            134814911
        ],
        "134816004": [
            134814473,
            134815889,
            134814885,
            134814911
        ],
        "134816079": [
            134531584,
            134534624,
            134533666,
            134816004,
            134814885,
            134535982,
            134816079,
            134530928,
            134814961,
            134814515,
            134814551,
            134814585,
            134535930,
            134536029,
            134814911
        ],
        "134816692": [
            134534624,
            134816004,
            134918727,
            134814473,
            134526960,
            134527920
        ],
        "134817070": [
            134532546,
            134958447,
            134526960,
            134928502,
            134536600,
            134540446
        ],
        "134817135": [
            134532032,
            134950540,
            134817070,
            134920282,
            134950559
        ],
        "134817243": [],
        "134817249": [],
        "134817297": [
            134531200
        ],
        "134817316": [
            134532064,
            134817249,
            134918727,
            134921900,
            134955212,
            134528592,
            134817297,
            134527216,
            134535955,
            134534129,
            134954358,
            134918680,
            134536639
        ],
        "134817855": [
            134530304,
            134536576,
            134532032,
            134532546,
            134532064,
            134918727,
            134535982,
            134529072,
            134528592,
            134920272,
            134526960,
            134534129,
            134534644,
            134954358,
            134918680,
            134535930,
            134955228
        ],
        "134818681": [
            134531856,
            134532546,
            134526960,
            134536591
        ],
        "134818719": [
            134530656,
            134530576
        ],
        "134818918": [
            134526960,
            134534644,
            134912501
        ],
        "134818942": [
            134526960,
            134534644,
            134912518
        ],
        "134818966": [
            134526912,
            134534624,
            134818918,
            134918727,
            134921900,
            134527152,
            134527472,
            134527984,
            134535955,
            134536600,
            134535930,
            134912412,
            134818942,
            134818719
        ],
        "134819445": [
            134528640,
            134528384,
            134526912,
            134953987,
            134532032,
            134534053,
            134921922,
            134532546,
            134536006,
            134527200,
            134940591,
            134527760,
            134533841,
            134527984,
            134533909,
            134912597,
            134913143,
            134938809
        ],
        "134820135": [
            134531280,
            134534089,
            134921900
        ],
        "134820200": [
            134534624,
            134530048,
            134527200,
            134532032,
            134536006,
            134921900,
            134533967,
            134528912,
            134533841,
            134534129,
            134529744,
            134526960,
            134928446,
            134536639
        ],
        "134820720": [
            134532546,
            134534089,
            134536591,
            134530192,
            134527920
        ],
        "134820783": [],
        "134820856": [],
        "134820945": [
            134535982
        ],
        "134820964": [
            134820856,
            134820945
        ],
        "134821069": [
            134527200,
            134530048,
            134532032,
            134535982,
            134527856,
            134534129,
            134528496
        ],
        "134821333": [
            134532064,
            134529072,
            134941784
        ],
        "134821552": [
            134527712
        ],
        "134821570": [
            134531520,
            134530736,
            134531792
        ],
        "134821777": [
            134530048,
            134531136,
            134529088,
            134531648,
            134532032,
            134527200,
            134537825,
            134532064,
            134939274,
            134942346,
            134820783,
            134530320,
            134526960,
            134821333,
            134942329,
            134926462
        ],
        "134822738": [
            134532064,
            134821777,
            134941784,
            134526960
        ],
        "134823113": [
            134531744,
            134532032,
            134529888,
            134820964,
            134820856,
            134823113,
            134821069,
            134821552,
            134533841,
            134820945,
            134822738,
            134526960,
            134533909,
            134536600,
            134537049
        ],
        "134823633": [
            134921922,
            134820964,
            134535558,
            134823113,
            134821069,
            134530544,
            134528080,
            134527440,
            134530736,
            134533716,
            134820945,
            134821552,
            134822738,
            134820856
        ],
        "134824184": [
            134532032,
            134534624,
            134531936,
            134534660,
            134925605,
            134534053,
            134534951,
            134535930,
            134954410,
            134535982,
            134926257,
            134925810,
            134925555,
            134925781,
            134925689,
            134538684,
            134925724
        ],
        "134824562": [
            134529472,
            134532032,
            134824184,
            134921900,
            134530736,
            134526960,
            134534644,
            134918680,
            134920282,
            134954395
        ],
        "134825037": [
            134534624,
            134921922,
            134532546,
            134940591,
            134938809
        ],
        "134825182": [
            134529200,
            134534129,
            134532546,
            134849978
        ],
        "134825258": [
            134531648,
            134939168,
            134532546,
            134955212,
            134528496,
            134527856,
            134527344,
            134849978,
            134534143
        ],
        "134825446": [
            134531168,
            134526848,
            134941219,
            134536006,
            134921900,
            134527440,
            134533841,
            134528304,
            134527920
        ],
        "134825632": [
            134532032,
            134921922,
            134534053,
            134849895,
            134948617,
            134533967,
            134528912,
            134531216,
            134529040,
            134849968,
            134528080,
            134533841,
            134529744,
            134526960,
            134534644,
            134913143,
            134911741
        ],
        "134826138": [
            134527520,
            134955360,
            134532546,
            134918727,
            134534089,
            134918636,
            134526960,
            134527504
        ],
        "134826292": [
            134531584,
            134921922,
            134918727,
            134941468,
            134536639
        ],
        "134826485": [
            134531936,
            134536161,
            134532546,
            134536130,
            134527936,
            134918636,
            134528080,
            134530448,
            134527440,
            134533841,
            134534644,
            134529552
        ],
        "134826698": [
            134531024,
            134526960
        ],
        "134826791": [],
        "134826792": [],
        "134826884": [
            134531648,
            134954814
        ],
        "134827011": [
            134526960
        ],
        "134827049": [
            134532064,
            134827011
        ],
        "134827160": [
            134827049,
            134827011
        ],
        "134827342": [
            134526960
        ],
        "134827409": [
            134526960
        ],
        "134827453": [
            134526960
        ],
        "134827493": [
            134526960
        ],
        "134827651": [
            134529072
        ],
        "134827866": [
            134529072
        ],
        "134828004": [
            134531648,
            134540652,
            134534624,
            134536639
        ],
        "134828774": [
            134956851,
            134828004
        ],
        "134828865": [
            134531360,
            134828865,
            134954358
        ],
        "134828937": [
            134918680,
            134534644,
            134534624
        ],
        "134829033": [
            134531872,
            134828865,
            134534624,
            134530144,
            134528672,
            134828937,
            134527312
        ],
        "134829282": [
            134530144,
            134828937,
            134828865
        ],
        "134829357": [
            134529920,
            134532064,
            134529072,
            134527920,
            134526960
        ],
        "134829800": [
            134530432,
            134937345,
            134826884,
            134828937,
            134535955,
            134955169,
            134826792,
            134829357,
            134529072,
            134954814,
            134531648,
            134828865,
            134921922,
            134532032,
            134534089,
            134526800,
            134528592,
            134534624,
            134532064,
            134829282,
            134828774,
            134829033,
            134534644,
            134535930
        ],
        "134831819": [
            134532032,
            134534624,
            134532064,
            134534660,
            134918727,
            134921900,
            134529072,
            134526960,
            134942035,
            134954358,
            134918680,
            134920282
        ],
        "134832321": [
            134527920,
            134527440,
            134918727
        ],
        "134832410": [
            134534644,
            134540741
        ],
        "134832453": [
            134540545
        ],
        "134832472": [
            134534644,
            134534903
        ],
        "134832552": [
            134529472,
            134531648,
            134832472,
            134526960
        ],
        "134832989": [
            134540545,
            134540446
        ],
        "134833038": [
            134528960
        ],
        "134833116": [
            134527776,
            134531648,
            134532032,
            134532546,
            134532064,
            134832552,
            134949993,
            134941875,
            134534644,
            134536600,
            134535930,
            134832410
        ],
        "134834018": [
            134527200,
            134532032,
            134956736,
            134921900,
            134536591,
            134527440,
            134527920
        ],
        "134834276": [
            134532032,
            134537825,
            134918727,
            134537895,
            134921900,
            134526960
        ],
        "134834389": [
            134532032,
            134532546,
            134918727,
            134537895,
            134527920,
            134534129
        ],
        "134834468": [
            134532546,
            134948617,
            134921900,
            134533967,
            134534644
        ],
        "134834624": [
            134921922,
            134532546,
            134534053,
            134526960,
            134528336,
            134527760
        ],
        "134834788": [
            134528960,
            134531584,
            134532546,
            134921900,
            134536591,
            134531792,
            134526960,
            134536600
        ],
        "134835234": [
            134528672,
            134536161,
            134532546,
            134528640,
            134529024,
            134536232,
            134536457,
            134921900,
            134538477,
            134530448,
            134532112,
            134536435
        ],
        "134835583": [
            134531552,
            134531648,
            134532546,
            134528960,
            134528944,
            134955228
        ],
        "134835985": [
            134534624,
            134528256
        ],
        "134836024": [
            134531584,
            134536029
        ],
        "134836537": [
            134531584,
            134531232,
            134528960,
            134532032,
            134534624,
            134530736,
            134529008,
            134836024
        ],
        "134837317": [
            134531584,
            134937345,
            134529040,
            134835985,
            134535955,
            134536343,
            134918680,
            134954395,
            134920105,
            134921900,
            134535982,
            134956851,
            134836537,
            134531648,
            134532032,
            134918727,
            134920282,
            134534624,
            134527712,
            134536161,
            134526960
        ],
        "134838169": [],
        "134838856": [
            134526960,
            134536600
        ],
        "134838924": [
            134528192,
            134529072,
            134536600
        ],
        "134839074": [
            134838924
        ],
        "134839095": [
            134533666
        ],
        "134839122": [
            134533666
        ],
        "134839150": [
            134955192,
            134530736
        ],
        "134839291": [
            134535288,
            134838924,
            134534053
        ],
        "134839393": [
            134528096,
            134527008,
            134838924,
            134950599
        ],
        "134839472": [
            134839393,
            134839074,
            134838924,
            134526800,
            134533812,
            134941717,
            134839291
        ],
        "134839835": [
            134530000
        ],
        "134839976": [
            134529344,
            134950650,
            134955244,
            134528896
        ],
        "134840030": [
            134534089
        ],
        "134840042": [
            134526880,
            134534053
        ],
        "134840176": [
            134529920,
            134535558,
            134536343,
            134838169,
            134839835,
            134536222,
            134533666,
            134839976,
            134531888,
            134839095,
            134955192,
            134530496,
            134534726,
            134839122,
            134955228,
            134840030,
            134534624,
            134839393,
            134840042,
            134955244,
            134839150,
            134950650,
            134839291
        ],
        "134841336": [
            134529760,
            134954213
        ],
        "134841356": [
            134955228
        ],
        "134841389": [
            134528128,
            134536457,
            134841356,
            134531600,
            134529424,
            134530448,
            134535955,
            134528672,
            134941219,
            134534053,
            134954410,
            134921900,
            134536365,
            134534624,
            134527200,
            134531936,
            134538723,
            134538477,
            134527216,
            134534644,
            134535930
        ],
        "134843008": [
            134531360,
            134531200,
            134918727,
            134921900,
            134535982,
            134536559,
            134529552,
            134954264,
            134538684
        ],
        "134843316": [
            134526752,
            134534644
        ],
        "134843371": [
            134528176,
            134843316,
            134950540
        ],
        "134843468": [
            134533666
        ],
        "134843534": [
            134527200,
            134843371,
            134843468,
            134530736,
            134843316
        ],
        "134844038": [
            134530048,
            134526912,
            134527200,
            134844038,
            134843371,
            134843468,
            134844877,
            134843534,
            134527152,
            134528080,
            134527472,
            134843316,
            134912282
        ],
        "134844781": [
            134843468,
            134844781,
            134844038
        ],
        "134844877": [
            134843468,
            134844877,
            134844781
        ],
        "134844968": [
            134531456,
            134532032,
            134843468,
            134844877,
            134535982,
            134843534,
            134530736,
            134534644,
            134533909
        ],
        "134845378": [
            134531104,
            134921922,
            134532546,
            134540132,
            134530544,
            134527088,
            134530448,
            134537203,
            134536435,
            134534129,
            134539261
        ],
        "134845708": [
            134529360
        ],
        "134845777": [
            134532032,
            134532546,
            134533666,
            134535955,
            134941875,
            134536029
        ],
        "134846456": [
            134534624,
            134534089,
            134921900,
            134845708,
            134535982,
            134536365,
            134845777,
            134535930,
            134538684
        ],
        "134846947": [],
        "134846950": [
            134534053,
            134921900,
            134954894,
            134530448,
            134532112,
            134536435
        ],
        "134847158": [
            134954213,
            134918727,
            134921900,
            134527920,
            134537433
        ],
        "134847240": [
            134528864,
            134921922,
            134532546,
            134918727,
            134527920,
            134526800,
            134526960,
            134536600
        ],
        "134847496": [
            134528544,
            134532032,
            134532546,
            134531936,
            134536161,
            134918727,
            134921900,
            134950540,
            134536559,
            134527920,
            134529648,
            134526960,
            134536343,
            134920282,
            134950559
        ],
        "134847897": [
            134536232,
            134921900
        ],
        "134847932": [
            134527600,
            134532546,
            134955244
        ],
        "134847963": [
            134532032,
            134531200,
            134534624,
            134530736,
            134919001
        ],
        "134848269": [
            134532032,
            134950753,
            134531648,
            134534624,
            134527456,
            134921900,
            134540652,
            134953647,
            134533648,
            134527312,
            134920282,
            134954395,
            134954333
        ],
        "134848569": [
            134529408,
            134536161,
            134528672,
            134538723,
            134953304,
            134918727,
            134534089,
            134921900,
            134536365,
            134526960,
            134528432,
            134536600
        ],
        "134848886": [
            134918727,
            134921900,
            134528592,
            134534129,
            134526960,
            134954358,
            134918680
        ],
        "134849400": [
            134527488,
            134529088,
            134527200,
            134921900,
            134949966,
            134527920,
            134526800,
            134529488,
            134530544,
            134530896,
            134526960
        ],
        "134849740": [
            134532546,
            134912493,
            134536591,
            134527152,
            134527920
        ],
        "134849777": [
            134532064,
            134529072,
            134941219
        ],
        "134849895": [
            134527200,
            134534053
        ],
        "134849968": [
            134849895
        ],
        "134849978": [
            134529408,
            134921900,
            134940591
        ],
        "134850044": [
            134530544,
            134535216,
            134538684,
            134538630
        ],
        "134850147": [
            134530736
        ],
        "134850351": [
            134529408,
            134937345,
            134921922,
            134953987,
            134527712,
            134534053,
            134534660,
            134948169,
            134527920,
            134955155,
            134534644
        ],
        "134850661": [
            134532032,
            134531584,
            134531648,
            134528928,
            134527200,
            134530896,
            134526800,
            134537616,
            134530736,
            134538802,
            134535930
        ],
        "134851051": [
            134531584,
            134527744,
            134530432,
            134953997,
            134528400,
            134527504,
            134912915,
            134531744,
            134529056,
            134527520,
            134534053,
            134941228,
            134527920,
            134950837,
            134954295,
            134957246,
            134536639,
            134532546,
            134921922,
            134912579,
            134534089,
            134912466,
            134536798,
            134529888,
            134534624,
            134955360,
            134531680,
            134850661,
            134540652,
            134526960,
            134535930,
            134537086
        ],
        "134852043": [
            134531648,
            134532032,
            134921900,
            134918543,
            134527440,
            134918481,
            134526800,
            134527920
        ],
        "134852236": [
            134948617
        ],
        "134852264": [
            134531648,
            134939168,
            134532546,
            134534624,
            134527200,
            134536161,
            134540652,
            134529648,
            134530000,
            134538802,
            134527856,
            134528496,
            134954837,
            134536404,
            134536639
        ],
        "134852722": [
            134530048,
            134534053,
            134853383,
            134853324,
            134853471
        ],
        "134852993": [
            134532032,
            134852722,
            134913013
        ],
        "134853030": [
            134531648,
            134534624,
            134532546,
            134955244,
            134852722
        ],
        "134853324": [
            134530560,
            134529888,
            134531744
        ],
        "134853383": [
            134530448,
            134531936,
            134526880
        ],
        "134853471": [
            134527200,
            134531936,
            134530448,
            134526880
        ],
        "134853618": [
            134529072,
            134531584,
            134532064
        ],
        "134853803": [
            134956851
        ],
        "134853848": [
            134531648,
            134536006,
            134535982
        ],
        "134854005": [
            134530112,
            134534053,
            134530032,
            134529136,
            134853848
        ],
        "134854122": [
            134531584,
            134529472
        ],
        "134854199": [
            134854122,
            134533666,
            134530736
        ],
        "134854386": [
            134532032,
            134533648,
            134950578,
            134536006
        ],
        "134854541": [
            134529056
        ],
        "134854602": [
            134531648,
            134532032,
            134953890,
            134536006,
            134535982,
            134530736,
            134533648,
            134526960,
            134534129,
            134854386,
            134536600,
            134536639
        ],
        "134855033": [
            134532032,
            134534053,
            134854541,
            134526960,
            134526864,
            134534644
        ],
        "134855296": [
            134855033
        ],
        "134855329": [
            134855296,
            134854541,
            134533648,
            134535955,
            134531360,
            134853803,
            134535982,
            134530736,
            134527920,
            134956851,
            134539188,
            134854199,
            134531648,
            134532032,
            134532546,
            134536006,
            134854602,
            134531792,
            134527440,
            134853848,
            134536029,
            134534624,
            134955376,
            134526960,
            134854386,
            134854005,
            134855033
        ],
        "134857015": [
            134534053,
            134853383,
            134526960,
            134853618,
            134536600,
            134853471
        ],
        "134857186": [
            134530048,
            134532032,
            134534053,
            134853324,
            134526960,
            134533841,
            134857015,
            134536600
        ],
        "134857348": [
            134530048,
            134534053,
            134921900,
            134853324,
            134857015
        ],
        "134857489": [],
        "134857509": [],
        "134857548": [],
        "134857567": [],
        "134857577": [],
        "134857618": [
            134535982
        ],
        "134857655": [
            134857618
        ],
        "134857693": [
            134535982
        ],
        "134857722": [
            134535982
        ],
        "134857865": [
            134535955
        ],
        "134857891": [
            134532032
        ],
        "134857938": [
            134535955,
            134857891
        ],
        "134858044": [
            134532032
        ],
        "134858134": [
            134858134,
            134857693,
            134536006
        ],
        "134858238": [
            134531632,
            134956986
        ],
        "134858344": [
            134530240,
            134528960
        ],
        "134858489": [
            134858344,
            134857509
        ],
        "134858615": [
            134858489
        ],
        "134858700": [
            134858489
        ],
        "134858804": [
            134530736,
            134857489
        ],
        "134858862": [
            134532032,
            134531584,
            134535982,
            134526800,
            134857489,
            134858804
        ],
        "134859117": [
            134531584,
            134857489,
            134530736,
            134532032
        ],
        "134859204": [
            134941875
        ],
        "134859253": [
            134859204
        ],
        "134859279": [
            134530000,
            134529440
        ],
        "134859398": [
            134534624
        ],
        "134859421": [
            134531648,
            134527264,
            134859398
        ],
        "134859662": [
            134859662,
            134859421,
            134536006
        ],
        "134859785": [
            134531584,
            134530528,
            134531968,
            134950540,
            134857548,
            134859662,
            134535982,
            134526800,
            134530928
        ],
        "134860305": [
            134532032,
            134857891,
            134859785,
            134857548,
            134859662,
            134857938
        ],
        "134860476": [
            134531584,
            134857865,
            134859662,
            134860305,
            134857938,
            134860918,
            134858615,
            134861142,
            134858489,
            134858238
        ],
        "134860918": [
            134857891,
            134860476
        ],
        "134860944": [
            134536006,
            134860918
        ],
        "134860975": [
            134860944
        ],
        "134860987": [
            134531648,
            134532032,
            134536006,
            134858862,
            134860975,
            134859253
        ],
        "134861102": [
            134860975,
            134534927,
            134858862,
            134857655
        ],
        "134861142": [
            134857891,
            134860476
        ],
        "134861201": [
            134858489,
            134861142
        ],
        "134861253": [
            134857891,
            134860476,
            134536006
        ],
        "134861333": [
            134530432,
            134860987,
            134858862,
            134859662,
            134860944,
            134861201,
            134857655,
            134858489,
            134954395
        ],
        "134861545": [
            134859204,
            134857509,
            134859398,
            134858344,
            134529648,
            134941875
        ],
        "134862334": [
            134532032,
            134857891,
            134859398,
            134857655,
            134858044
        ],
        "134862505": [
            134531648,
            134529472,
            134530528,
            134857865,
            134860944,
            134527312,
            134529360,
            134535955,
            134527216,
            134861142,
            134538684
        ],
        "134863163": [
            134859398,
            134864007,
            134861545,
            134535982,
            134858862,
            134860944,
            134858804,
            134861142,
            134956986,
            134863163,
            134857693,
            134857567
        ],
        "134864007": [
            134861545,
            134863163
        ],
        "134864067": [
            134864067,
            134859398,
            134864007,
            134861545,
            134864694,
            134858134,
            134863163,
            134857567
        ],
        "134864694": [
            134864067,
            134857693,
            134858134
        ],
        "134864811": [
            134864067,
            134861545,
            134858862,
            134858134,
            134863163,
            134858044,
            134857567
        ],
        "134865103": [
            134531584,
            134527232,
            134530432,
            134859398,
            134859662,
            134536591,
            134860944,
            134860305,
            134529808,
            134861201,
            134861333,
            134870939,
            134859421,
            134528032,
            134857891,
            134536101,
            134862334,
            134862505,
            134535982,
            134529072,
            134531632,
            134530736,
            134528432,
            134858804,
            134954295,
            134857655,
            134858044,
            134536639,
            134532032,
            134861253,
            134534089,
            134857548,
            134865103,
            134526800,
            134530384,
            134857938,
            134526928,
            134870485,
            134861142,
            134530528,
            134529504,
            134868324,
            134857577,
            134859117,
            134858862,
            134530544,
            134860918,
            134858615,
            134858489,
            134857722,
            134868221,
            134868990
        ],
        "134868221": [
            134527232,
            134531296,
            134865103
        ],
        "134868324": [
            134857722,
            134859662,
            134865103,
            134530256,
            134956986,
            134862334
        ],
        "134868451": [
            134531584,
            134530528,
            134868324,
            134857865,
            134859662,
            134526800,
            134531632,
            134860918
        ],
        "134868990": [
            134531584,
            134859398,
            134859785,
            134859662,
            134859279,
            134530320,
            134860944,
            134528544,
            134858238,
            134861102,
            134531632,
            134857655,
            134858044,
            134532032,
            134529472,
            134531136,
            134536006,
            134857548,
            134858700,
            134865103,
            134861142,
            134536029,
            134530528,
            134868451,
            134868324,
            134857577,
            134858862,
            134530544,
            134860918,
            134858489,
            134857722,
            134862334
        ],
        "134870485": [
            134531584,
            134532032,
            134859398,
            134536006,
            134857865,
            134857577,
            134859662,
            134865103,
            134530896,
            134535955,
            134858489,
            134857722,
            134859421,
            134862334
        ],
        "134870939": [
            134865103,
            134858615
        ],
        "134870961": [
            134530432,
            134937345,
            134859398,
            134860944,
            134861201,
            134857618,
            134535955,
            134527120,
            134861333,
            134954395,
            134862505,
            134864811,
            134921900,
            134535982,
            134860975,
            134861102,
            134857655,
            134860987,
            134860476,
            134531648,
            134532032,
            134532546,
            134857548,
            134865103,
            134861142,
            134530144,
            134858862,
            134534644,
            134859253,
            134535930,
            134868221
        ],
        "134871856": [
            134918727,
            134921900,
            134954861,
            134536591,
            134529040,
            134528592,
            134536559,
            134954395
        ],
        "134872504": [],
        "134872525": [
            134526960
        ],
        "134872590": [
            134956851,
            134536006
        ],
        "134872655": [
            134532032,
            134533841,
            134872590,
            134527200
        ],
        "134872785": [
            134531872
        ],
        "134872821": [
            134528592
        ],
        "134873009": [
            134531872,
            134532032,
            134527712,
            134535982,
            134872785,
            134535955,
            134872821,
            134928502,
            134535930
        ],
        "134874832": [
            134532064,
            134872785,
            134528592,
            134527920
        ],
        "134875211": [
            134534660,
            134536457,
            134530448,
            134531600,
            134536212,
            134918680,
            134529968,
            134873009,
            134527920,
            134956851,
            134532032,
            134529744,
            134874832,
            134536532,
            134531936,
            134536161,
            134530144,
            134526960,
            134538610
        ],
        "134876540": [
            134531584,
            134937345,
            134528672,
            134528928,
            134532032,
            134527200,
            134534624,
            134948169,
            134875211,
            134921900,
            134872525,
            134535982,
            134530736,
            134533841,
            134526960,
            134537203,
            134912662
        ],
        "134878115": [
            134535930
        ],
        "134878165": [
            134529424,
            134532032
        ],
        "134878252": [
            134531584,
            134532032,
            134536006,
            134528912,
            134538610,
            134536435
        ],
        "134878376": [
            134878165
        ],
        "134878404": [
            134532032,
            134531936,
            134878376,
            134529424,
            134529744
        ],
        "134878535": [
            134529424,
            134533648,
            134536343,
            134528672,
            134528928,
            134878115,
            134878376,
            134536232,
            134878252,
            134535982,
            134530736,
            134938809,
            134536639,
            134532032,
            134921922,
            134878404,
            134954438,
            134536006,
            134528720,
            134536532,
            134878165,
            134920282,
            134534624,
            134947681,
            134536161,
            134527456,
            134955376,
            134531440,
            134526960,
            134536435
        ],
        "134880457": [
            134534624
        ],
        "134880580": [
            134529744
        ],
        "134880597": [
            134531584
        ],
        "134880720": [
            134535930,
            134880597
        ],
        "134880785": [
            134532032,
            134534624,
            134880457,
            134535982,
            134528720,
            134880720,
            134956986
        ],
        "134880996": [
            134534624,
            134880457,
            134880720
        ],
        "134881102": [
            134534624,
            134536029
        ],
        "134881212": [
            134531584,
            134531968,
            134950540,
            134880785,
            134535982,
            134956986,
            134536639,
            134532032,
            134536006,
            134881102,
            134528720,
            134531792,
            134880720,
            134880597,
            134536029,
            134954333,
            134531552,
            134534624,
            134880996,
            134530928
        ],
        "134882344": [
            134531648,
            134881212,
            134536006,
            134532032
        ],
        "134882400": [
            134535955
        ],
        "134882467": [
            134532064,
            134529072,
            134534624
        ],
        "134882658": [
            134532032,
            134937345,
            134882467
        ],
        "134882708": [
            134954264,
            134882658,
            134920105,
            134528592,
            134527056,
            134918680
        ],
        "134882955": [
            134531584,
            134530432,
            134529040,
            134535955,
            134882708,
            134882467,
            134535982,
            134530736,
            134954295,
            134531648,
            134532032,
            134536006,
            134529104,
            134526800,
            134920282,
            134937311,
            134882400,
            134530528,
            134882658,
            134534624,
            134949993,
            134535930
        ],
        "134885126": [
            134530432,
            134937345,
            134882955,
            134918680,
            134954395,
            134882344,
            134530736,
            134527920,
            134881212,
            134536639,
            134532032,
            134921922,
            134532546,
            134536259,
            134536532,
            134920282,
            134534624,
            134527200,
            134527456,
            134954350,
            134527728,
            134534129
        ],
        "134885777": [],
        "134885825": [],
        "134885845": [],
        "134885886": [
            134532032,
            134536029
        ],
        "134885943": [
            134531648
        ],
        "134886044": [
            134529552,
            134528112
        ],
        "134886076": [
            134535700
        ],
        "134886112": [
            134535288
        ],
        "134886166": [],
        "134886186": [
            134532032,
            134535930,
            134886166
        ],
        "134886260": [
            134527216,
            134535955
        ],
        "134886430": [
            134887089,
            134535982,
            134886430
        ],
        "134886813": [
            134527216,
            134886430
        ],
        "134886990": [
            134886813,
            134885886
        ],
        "134887089": [
            134886430
        ],
        "134887151": [
            134887089
        ],
        "134887180": [
            134887089
        ],
        "134887212": [
            134526800,
            134526976,
            134529104
        ],
        "134887284": [
            134526800,
            134887212
        ],
        "134887495": [
            134526976
        ],
        "134887535": [
            134531584,
            134887495,
            134886260,
            134885845,
            134886430
        ],
        "134887650": [
            134531792
        ],
        "134887896": [
            134531584,
            134528544
        ],
        "134887983": [
            134528544,
            134529648
        ],
        "134888019": [
            134531936,
            134538630,
            134887212,
            134532112,
            134530448
        ],
        "134888122": [
            134529360
        ],
        "134888164": [
            134888122
        ],
        "134888190": [
            134888164
        ],
        "134888215": [
            134887089,
            134888164
        ],
        "134888240": [
            134888122
        ],
        "134888310": [
            134888122,
            134888164
        ],
        "134888348": [
            134887089,
            134888122
        ],
        "134888373": [
            134527136
        ],
        "134888415": [
            134888373
        ],
        "134888442": [
            134531584,
            134888415,
            134888164,
            134887983
        ],
        "134888574": [
            134887089,
            134888415
        ],
        "134888599": [
            134532032,
            134888240,
            134530000,
            134531792,
            134888373,
            134888442,
            134536029
        ],
        "134888853": [
            134888164,
            134887089,
            134885777,
            134888373,
            134888310,
            134888415
        ],
        "134888935": [
            134888373
        ],
        "134889019": [
            134887089,
            134888373
        ],
        "134889044": [
            134949898,
            134536591
        ],
        "134889101": [
            134535573,
            134536591
        ],
        "134889121": [
            134529072
        ],
        "134889136": [
            134530896,
            134889121
        ],
        "134889209": [
            134889136,
            134889121
        ],
        "134889235": [
            134529552,
            134889209,
            134529056,
            134889101
        ],
        "134889299": [
            134534624,
            134947020,
            134889101,
            134536591,
            134889209
        ],
        "134889365": [
            134532032,
            134889299,
            134887212
        ],
        "134889481": [
            134528672,
            134531936,
            134538723,
            134887212,
            134530448,
            134531216,
            134886260,
            134886813
        ],
        "134889802": [
            134888164,
            134888240,
            134888373,
            134888310,
            134888415
        ],
        "134890099": [
            134886112,
            134531200,
            134889802,
            134529360,
            134527216,
            134889136
        ],
        "134890680": [
            134531584,
            134889121,
            134526800,
            134890099,
            134889365,
            134536600,
            134889209
        ],
        "134890855": [
            134889121,
            134889136,
            134890962,
            134890099,
            134886166
        ],
        "134890907": [
            134889121,
            134889365,
            134890855
        ],
        "134890962": [
            134527264,
            134889121,
            134531584,
            134536591,
            134888240,
            134889136,
            134889209,
            134890907
        ],
        "134891352": [
            134529552,
            134886076,
            134890855
        ],
        "134891418": [
            134529552,
            134886186,
            134886112,
            134890855
        ],
        "134891478": [
            134889121,
            134889044,
            134890855
        ],
        "134891549": [
            134891478
        ],
        "134891600": [
            134531648,
            134885825,
            134531552,
            134887089,
            134890099,
            134886260,
            134889365,
            134891478,
            134885943,
            134889044,
            134886813,
            134886430,
            134888415
        ],
        "134892057": [
            134532032,
            134536006,
            134889481,
            134535982,
            134891600
        ],
        "134892222": [
            134531584,
            134889481,
            134950540,
            134889101,
            134529808,
            134885777,
            134888599,
            134536600,
            134892057,
            134890907,
            134891549,
            134886813,
            134950559,
            134528032,
            134889121,
            134887212,
            134888240,
            134527920,
            134888373,
            134888122,
            134886076,
            134532032,
            134531648,
            134536006,
            134887495,
            134886990,
            134888190,
            134526800,
            134530000,
            134888019,
            134885845,
            134887896,
            134888164,
            134887535,
            134526960,
            134529648,
            134887284,
            134534008,
            134889209,
            134888442,
            134885886
        ],
        "134895297": [
            134531584,
            134887180,
            134899855,
            134885777,
            134888853,
            134886166,
            134888215,
            134889365,
            134888348,
            134891549,
            134886430,
            134886813,
            134889121,
            134887212,
            134889136,
            134887089,
            134888240,
            134888373,
            134885943,
            134890680,
            134888122,
            134889019,
            134892222,
            134531648,
            134895297,
            134532032,
            134885825,
            134536006,
            134887495,
            134886990,
            134888190,
            134891600,
            134531792,
            134526800,
            134888019,
            134890962,
            134885845,
            134891478,
            134888415,
            134887650,
            134888164,
            134888935,
            134887535,
            134887151,
            134890099,
            134887284,
            134886260,
            134888310,
            134888442,
            134888574
        ],
        "134899855": [
            134531648,
            134895297,
            134888164,
            134531792,
            134888373,
            134888122,
            134889019,
            134888348
        ],
        "134900341": [
            134889101,
            134536591,
            134529552,
            134889365,
            134892057,
            134889121,
            134886186,
            134888373,
            134888122,
            134886076,
            134892222,
            134532032,
            134531648,
            134895297,
            134947020,
            134530896,
            134890962,
            134889044,
            134886112,
            134528736,
            134890855,
            134890099,
            134889209,
            134885886
        ],
        "134901029": [
            134530304,
            134889121,
            134532546,
            134535982,
            134527664,
            134527440,
            134527920,
            134900341,
            134536029
        ],
        "134901321": [],
        "134901406": [],
        "134901424": [],
        "134901475": [],
        "134901488": [],
        "134901501": [],
        "134901514": [
            134901321
        ],
        "134901530": [],
        "134901605": [],
        "134901611": [],
        "134901628": [
            134527920,
            134901321
        ],
        "134901831": [
            134527920
        ],
        "134901844": [
            134535955,
            134535982
        ],
        "134901929": [
            134530544
        ],
        "134901997": [
            134530544
        ],
        "134902074": [
            134530528
        ],
        "134902135": [
            134530336
        ],
        "134902280": [
            134532032,
            134953987,
            134536006,
            134534129,
            134949205
        ],
        "134902582": [
            134531584,
            134902280,
            134956851,
            134536006
        ],
        "134902685": [
            134526960
        ],
        "134902707": [
            134955399,
            134954894,
            134535955,
            134533666,
            134949160,
            134535982,
            134940591,
            134902707,
            134956986,
            134532546,
            134912579,
            134912588,
            134901844,
            134534624,
            134901611,
            134955244,
            134540652,
            134537203,
            134534644,
            134535930
        ],
        "134904016": [
            134531552,
            134527200,
            134950723,
            134902280,
            134948169,
            134921900,
            134535982,
            134902707
        ],
        "134904456": [
            134527920,
            134526960
        ],
        "134904630": [
            134531584,
            134529472,
            134532032,
            134530528,
            134531296,
            134920282,
            134904456,
            134527920,
            134529456,
            134526960,
            134956986
        ],
        "134905860": [
            134527200,
            134530432,
            134534129,
            134904630,
            134954295
        ],
        "134906015": [
            134532032,
            134527200,
            134532546,
            134937283,
            134948169,
            134921900,
            134535982,
            134534129,
            134904630,
            134954295,
            134918680,
            134920282,
            134954395
        ],
        "134906815": [
            134535955
        ],
        "134906875": [
            134532032,
            134949160,
            134528592,
            134949205,
            134906815
        ],
        "134907071": [
            134531584,
            134528592,
            134906815
        ],
        "134907173": [
            134531584,
            134534624,
            134530736,
            134528592,
            134906815
        ],
        "134907517": [
            134953890,
            134953987,
            134534129,
            134535732,
            134534644,
            134535772
        ],
        "134907811": [
            134531584,
            134534624,
            134921922,
            134950723,
            134536161,
            134949993,
            134955212,
            134535982,
            134529040,
            134535216,
            134536343,
            134907517,
            134906815
        ],
        "134908480": [
            134528864,
            134949966,
            134530544,
            134526800,
            134527696
        ],
        "134908605": [
            134528128,
            134529760,
            134529056,
            134908480,
            134941219,
            134921900,
            134531216,
            134529232,
            134919315
        ],
        "134908839": [
            134528128
        ],
        "134908851": [
            134530496,
            134535573
        ],
        "134908944": [
            134531584,
            134949966,
            134535982,
            134530736,
            134526800
        ],
        "134909091": [
            134528128,
            134529232,
            134531504,
            134531008
        ],
        "134909137": [
            134538952,
            134538917
        ],
        "134909159": [
            134953287
        ],
        "134909207": [
            134528128,
            134529552,
            134535772,
            134909159
        ],
        "134909292": [
            134528192,
            134529632,
            134538630,
            134530672,
            134529584
        ],
        "134909433": [
            134532032,
            134940000,
            134533666,
            134909292,
            134908944,
            134939921,
            134950578,
            134533841,
            134939958
        ],
        "134909810": [
            134531936,
            134527936,
            134915140,
            134909292,
            134908851
        ],
        "134909895": [
            134531584,
            134531040,
            134531680,
            134531968,
            134526880,
            134909292,
            134526800,
            134530896
        ],
        "134910188": [
            134529984,
            134531008,
            134538917,
            134538630,
            134909895,
            134909292,
            134531696,
            134909137,
            134909810,
            134527664,
            134531504,
            134538684
        ],
        "134910403": [
            134529056,
            134910188,
            134529392,
            134909159
        ],
        "134910508": [
            134529056,
            134529760,
            134528128,
            134910403,
            134909292
        ],
        "134910605": [
            134529056,
            134532032,
            134910403,
            134909091,
            134909895,
            134909292,
            134910508,
            134529232,
            134909137,
            134909810,
            134909433
        ],
        "134910945": [
            134531584,
            134528128,
            134536964,
            134939402,
            134910605,
            134530448,
            134908944,
            134531344,
            134526864,
            134536343,
            134538904,
            134526880,
            134529056,
            134538917,
            134530736,
            134527664,
            134908851,
            134527936,
            134529728,
            134910403,
            134529232,
            134527440,
            134528464,
            134954203,
            134534624,
            134536676,
            134909159,
            134909292,
            134531696,
            134538996,
            134909433
        ],
        "134911741": [
            134528592,
            134536591
        ],
        "134911751": [
            134532032
        ],
        "134911805": [],
        "134911806": [
            134530496,
            134530080,
            134529568,
            134532032,
            134939402,
            134538904,
            134536591,
            134527952,
            134529072,
            134531888,
            134528688,
            134535955,
            134536600
        ],
        "134912136": [
            134911806
        ],
        "134912147": [],
        "134912164": [
            134531936,
            134954410,
            134538610
        ],
        "134912244": [
            134530544,
            134528128
        ],
        "134912282": [
            134530576,
            134534089,
            134535955
        ],
        "134912394": [
            134532080
        ],
        "134912412": [
            134530864,
            134534624
        ],
        "134912439": [
            134531408,
            134534624
        ],
        "134912466": [
            134530752,
            134534624
        ],
        "134912493": [
            134912466
        ],
        "134912501": [
            134530752
        ],
        "134912518": [
            134527392
        ],
        "134912535": [
            134912501,
            134534903
        ],
        "134912557": [
            134912518,
            134534903
        ],
        "134912579": [
            134912412
        ],
        "134912588": [
            134912439
        ],
        "134912597": [
            134540652
        ],
        "134912637": [
            134530736
        ],
        "134912662": [
            134527712
        ],
        "134912680": [
            134530000,
            134529808,
            134534624
        ],
        "134912757": [
            134526960
        ],
        "134912793": [
            134528848,
            134534624,
            134534143
        ],
        "134912915": [
            134529280,
            134534089,
            134527984,
            134529264,
            134536820,
            134536798
        ],
        "134912995": [
            134534008
        ],
        "134913013": [
            134533841
        ],
        "134913048": [
            134529744,
            134529040,
            134911741,
            134534053
        ],
        "134913143": [
            134530048,
            134530560,
            134528384,
            134529408,
            134528640,
            134928137,
            134530448,
            134528528,
            134536212,
            134913048,
            134531744,
            134534053,
            134531904,
            134532032,
            134531280,
            134533841,
            134527200,
            134529888,
            134531936,
            134537825,
            134530272,
            134536171,
            134527344,
            134928241,
            134538610,
            134527088,
            134534644,
            134913013,
            134526960,
            134913143
        ],
        "134914668": [
            134526992
        ],
        "134914762": [
            134530736,
            134914668,
            134946134,
            134532032
        ],
        "134914841": [
            134914762,
            134939402,
            134914668,
            134911806
        ],
        "134914929": [
            134914841
        ],
        "134914941": [
            134535930
        ],
        "134915039": [
            134914941
        ],
        "134915048": [
            134915039
        ],
        "134915059": [],
        "134915102": [],
        "134915140": [
            134530448,
            134527776
        ],
        "134915219": [
            134531648,
            134534624,
            134535982,
            134531440,
            134535955,
            134536029
        ],
        "134916172": [
            134529792,
            134531872,
            134537232,
            134534129,
            134534143
        ],
        "134916441": [
            134531648,
            134531440
        ],
        "134916716": [
            134535982
        ],
        "134916742": [
            134529920,
            134531648,
            134530144,
            134916172,
            134535982,
            134527920,
            134530896,
            134526960,
            134915219,
            134534129,
            134916441,
            134535930
        ],
        "134918127": [
            134534624,
            134950540,
            134535982,
            134531440,
            134942035,
            134536029
        ],
        "134918440": [],
        "134918481": [
            134531216,
            134527200
        ],
        "134918543": [
            134531648,
            134533841,
            134918481,
            134532032
        ],
        "134918636": [
            134531680,
            134534089
        ],
        "134918680": [
            134530432
        ],
        "134918727": [
            134531584,
            134529920,
            134534660,
            134534089,
            134528432,
            134528592,
            134535955
        ],
        "134918981": [
            134918763
        ],
        "134919001": [
            134918763
        ],
        "134919029": [
            134527200,
            134530112,
            134530032,
            134531184,
            134530736
        ],
        "134919315": [
            134942400,
            134531584,
            134535982,
            134530736,
            134529648,
            134956851,
            134533909
        ],
        "134919538": [],
        "134919586": [
            134531584,
            134530560,
            134919586,
            134529888,
            134530048,
            134531744,
            134536006,
            134949966
        ],
        "134919794": [
            134527200,
            134919586,
            134526800
        ],
        "134919891": [
            134534624,
            134531936,
            134530448,
            134526880
        ],
        "134920060": [
            134537406
        ],
        "134920105": [
            134528592,
            134535881,
            134535955
        ],
        "134920272": [
            134920105
        ],
        "134920282": [
            134920105
        ],
        "134920313": [
            134527440,
            134527984,
            134530752
        ],
        "134920375": [
            134534624,
            134957960,
            134536457,
            134954861,
            134536365,
            134531600
        ],
        "134920595": [
            134531584,
            134534624,
            134532546,
            134955399,
            134949993,
            134527248,
            134526800,
            134532413,
            134937311
        ],
        "134921900": [
            134920595
        ],
        "134921922": [
            134920595
        ],
        "134921946": [
            134531584,
            134535930,
            134526800
        ],
        "134922004": [],
        "134922751": [],
        "134923253": [
            134912147
        ],
        "134923342": [
            134912147
        ],
        "134924757": [],
        "134925113": [],
        "134925555": [],
        "134925605": [],
        "134925689": [
            134923253
        ],
        "134925724": [],
        "134925781": [],
        "134925810": [],
        "134925865": [
            134923342
        ],
        "134925994": [
            134923253
        ],
        "134926060": [
            134912147,
            134923342
        ],
        "134926257": [],
        "134926283": [
            134922751
        ],
        "134926376": [
            134922751
        ],
        "134926430": [
            134530768,
            134531088,
            134534154,
            134534660
        ],
        "134926462": [
            134957960,
            134536639,
            134911751
        ],
        "134926674": [],
        "134927098": [],
        "134927439": [],
        "134927572": [],
        "134927622": [
            134530736,
            134530832,
            134530224
        ],
        "134927722": [
            134531584,
            134956706,
            134536006,
            134526800,
            134956726,
            134535930
        ],
        "134927936": [
            134531120,
            134528576,
            134534644
        ],
        "134928054": [
            134956706,
            134956726,
            134536006
        ],
        "134928137": [],
        "134928241": [
            134531584,
            134535930,
            134526800,
            134535982
        ],
        "134928380": [
            134532032
        ],
        "134928446": [
            134527200,
            134530048
        ],
        "134928502": [],
        "134928589": [],
        "134928632": [],
        "134928662": [
            134531584,
            134928632
        ],
        "134929221": [
            134536600
        ],
        "134929231": [
            134536600,
            134526960
        ],
        "134929375": [
            134929231
        ],
        "134929457": [
            134532032,
            134536006
        ],
        "134929508": [
            134929457,
            134929221
        ],
        "134929555": [
            134929457,
            134929221
        ],
        "134929602": [
            134532032
        ],
        "134929656": [
            134532032
        ],
        "134929707": [
            134532032,
            134531584,
            134530432,
            134954295,
            134920282
        ],
        "134929940": [
            134531792,
            134928589,
            134929231
        ],
        "134930100": [
            134531792,
            134929231
        ],
        "134930203": [
            134529072
        ],
        "134930260": [
            134540160,
            134528256,
            134531584,
            134528928,
            134956736,
            134532032,
            134949993,
            134535982,
            134533648,
            134527152,
            134531792,
            134535955,
            134941875,
            134529104,
            134949848,
            134930203
        ],
        "134931079": [
            134536600,
            134527920
        ],
        "134931160": [
            134931079
        ],
        "134931179": [
            134531792,
            134928589,
            134931160
        ],
        "134931348": [
            134931160
        ],
        "134931430": [
            134531792,
            134928589,
            134931160
        ],
        "134931590": [
            134931160
        ],
        "134931664": [
            134531792,
            134931160
        ],
        "134931754": [
            134931754,
            134931079
        ],
        "134931775": [
            134536600,
            134931754
        ],
        "134931808": [
            134931754,
            134929231,
            134526960,
            134536600,
            134930203
        ],
        "134931874": [
            134931808,
            134535558
        ],
        "134931929": [
            134931874,
            134536591
        ],
        "134931974": [
            134527216,
            134931754,
            134526960,
            134929231
        ],
        "134932098": [
            134931974,
            134929231
        ],
        "134932127": [
            134531584,
            134949966
        ],
        "134932158": [
            134531584,
            134531648,
            134535982
        ],
        "134932245": [
            134531584,
            134530560,
            134530048,
            134528928,
            134531744,
            134531648,
            134532032,
            134536006,
            134529888,
            134527200,
            134533648,
            134527440,
            134533841,
            134535955,
            134956851,
            134526800,
            134535930,
            134536029
        ],
        "134932876": [
            134947020,
            134536591
        ],
        "134932917": [
            134531584,
            134932245,
            134912662,
            134928662,
            134527920,
            134530736,
            134932158,
            134931775,
            134531648,
            134532032,
            134929602,
            134929221,
            134536006,
            134949966,
            134526800,
            134530896,
            134931808,
            134526960,
            134535930
        ],
        "134933781": [
            134535982
        ],
        "134933812": [
            134526960
        ],
        "134933852": [
            134531584,
            134530432,
            134932098,
            134931974,
            134931590,
            134931079,
            134536457,
            134535558,
            134538630,
            134932876,
            134536591,
            134529040,
            134531472,
            134530448,
            134929555,
            134929940,
            134933781,
            134528912,
            134931348,
            134538904,
            134535573,
            134536600,
            134932127,
            134530080,
            134931874,
            134535587,
            134931754,
            134929707,
            134535982,
            134527152,
            134530736,
            134527664,
            134930100,
            134932917,
            134931775,
            134530752,
            134536639,
            134929602,
            134529472,
            134532032,
            134929221,
            134536006,
            134929231,
            134931664,
            134930260,
            134931160,
            134929375,
            134931808,
            134531936,
            134929508,
            134931430,
            134931179,
            134954350,
            134527216,
            134526960,
            134929656
        ],
        "134937283": [
            134535930
        ],
        "134937311": [
            134535982
        ],
        "134937345": [
            134532032
        ],
        "134937374": [],
        "134937398": [
            134937345
        ],
        "134937431": [],
        "134937450": [
            134530736
        ],
        "134937484": [
            134528864,
            134530432,
            134531136,
            134540160,
            134536591,
            134530544,
            134527920,
            134528592,
            134530320,
            134529072,
            134954295
        ],
        "134937888": [
            134949848,
            134529072,
            134536591,
            134532032
        ],
        "134937940": [
            134531584,
            134528464,
            134526832,
            134527152,
            134527984
        ],
        "134938007": [
            134530448,
            134531936,
            134526880,
            134536639
        ],
        "134938100": [
            134530448,
            134531936,
            134526880
        ],
        "134938152": [
            134527200,
            134939168,
            134531936,
            134526880,
            134536006,
            134949966,
            134530448,
            134530896,
            134527344
        ],
        "134938809": [
            134529408,
            134531904,
            134528640,
            134527200,
            134534053,
            134526960
        ],
        "134939168": [
            134531424
        ],
        "134939186": [
            134533648,
            134531648
        ],
        "134939274": [],
        "134939402": [],
        "134939420": [
            134529456
        ],
        "134939466": [
            134531584,
            134532032,
            134536006,
            134939402,
            134939420
        ],
        "134939565": [
            134531584,
            134531648,
            134532032,
            134939466,
            134526960,
            134949848
        ],
        "134939921": [
            134954309,
            134535982
        ],
        "134939948": [
            134939921
        ],
        "134939958": [
            134530432,
            134532032
        ],
        "134940000": [
            134531488,
            134531648,
            134531552,
            134534660,
            134950540,
            134530928,
            134531792,
            134535955,
            134534644
        ],
        "134940591": [
            134528256,
            134529408
        ],
        "134941000": [],
        "134941219": [
            134534089
        ],
        "134941228": [
            134528672,
            134531936,
            134538630,
            134534795,
            134530448,
            134527664
        ],
        "134941367": [
            134526960,
            134531584
        ],
        "134941449": [
            134941367
        ],
        "134941468": [
            134532032,
            134530432,
            134529072,
            134526960,
            134954358,
            134920282
        ],
        "134941586": [
            134532064,
            134529072
        ],
        "134941717": [],
        "134941784": [
            134536006,
            134911751
        ],
        "134941875": [],
        "134942035": [
            134941875
        ],
        "134942098": [
            134956851,
            134949966
        ],
        "134942199": [
            134530448,
            134529568,
            134531936
        ],
        "134942264": [
            134532032
        ],
        "134942329": [
            134942098
        ],
        "134942346": [
            134942098
        ],
        "134942363": [
            134531744,
            134532032
        ],
        "134942400": [
            134528928,
            134527648,
            134531648,
            134532032,
            134529888,
            134527200,
            134536006,
            134540652,
            134536077,
            134535982,
            134949966,
            134537616,
            134530896,
            134526800,
            134530000,
            134942199,
            134942363,
            134537086
        ],
        "134943046": [
            134531584,
            134527264,
            134530896,
            134531792,
            134538802,
            134529648,
            134527216,
            134533909
        ],
        "134943292": [
            134540362
        ],
        "134943320": [
            134532064,
            134535558,
            134540362,
            134528080,
            134529040,
            134926674,
            134529072,
            134531664
        ],
        "134943909": [],
        "134943953": [],
        "134944007": [
            134943909
        ],
        "134944062": [
            134943953,
            134944007
        ],
        "134945387": [
            134531584,
            134925605,
            134943909,
            134925555,
            134925689
        ],
        "134946004": [
            134527664,
            134943909,
            134540254
        ],
        "134946089": [
            134946004
        ],
        "134946134": [
            134532032,
            134945387,
            134535982,
            134535930,
            134944062
        ],
        "134947020": [
            134528256,
            134949898,
            134538684,
            134527216
        ],
        "134947609": [
            134949898,
            134538684
        ],
        "134947681": [
            134532032,
            134947609,
            134535955
        ],
        "134947842": [
            134528672,
            134538723,
            134535955,
            134532032
        ],
        "134948039": [
            134530448,
            134947842,
            134531936
        ],
        "134948086": [
            134534624,
            134538723
        ],
        "134948115": [
            134948086
        ],
        "134948136": [
            134534089,
            134948039
        ],
        "134948161": [],
        "134948169": [
            134527200,
            134530048,
            134948161,
            134529888,
            134530560,
            134532032,
            134531744,
            134948169,
            134534129,
            134913013
        ],
        "134948617": [
            134530048,
            134530560,
            134531744,
            134532032,
            134529888,
            134534053,
            134948617,
            134529040,
            134531216,
            134528336,
            134528080,
            134529744,
            134526960,
            134534644,
            134913013,
            134911741
        ],
        "134949160": [
            134531584,
            134529472
        ],
        "134949205": [
            134531584,
            134528416,
            134529472,
            134526800,
            134535930
        ],
        "134949356": [
            134530432,
            134533648,
            134531472,
            134954295
        ],
        "134949442": [
            134531584,
            134536161,
            134527600,
            134530448
        ],
        "134949575": [
            134537406
        ],
        "134949623": [
            134531808,
            134529440,
            134528464,
            134526832,
            134527440
        ],
        "134949712": [
            134530016,
            134534089,
            134533933,
            134535930,
            134536639
        ],
        "134949848": [
            134528864,
            134536029
        ],
        "134949898": [
            134530624,
            134534053
        ],
        "134949966": [
            134529728
        ],
        "134949993": [],
        "134950014": [
            134940000,
            134939921,
            134939958,
            134530736
        ],
        "134950113": [
            134529248,
            134528512,
            134536964,
            134536676,
            134527440,
            134534644
        ],
        "134950332": [],
        "134950435": [
            134956736,
            134532032,
            134536006,
            134533841,
            134950332
        ],
        "134950490": [
            134530736,
            134532546
        ],
        "134950540": [
            134950540
        ],
        "134950559": [
            134950559
        ],
        "134950578": [
            134533648
        ],
        "134950599": [],
        "134950650": [
            134950599
        ],
        "134950691": [],
        "134950723": [
            134526944
        ],
        "134950744": [
            134526944
        ],
        "134950753": [
            134531584,
            134950540,
            134527216
        ],
        "134950837": [
            134528544,
            134529808,
            134540652
        ],
        "134951129": [
            134534927
        ],
        "134951160": [
            134526960
        ],
        "134951227": [
            134530000,
            134534624
        ],
        "134951266": [
            134534624,
            134530896,
            134530736,
            134538802,
            134531792
        ],
        "134951395": [
            134955586
        ],
        "134951428": [
            134529824,
            134529616
        ],
        "134951656": [
            134531776,
            134529696
        ],
        "134951845": [
            134531584,
            134532096,
            134531072,
            134530432,
            134530448,
            134533648,
            134529040,
            134528912,
            134954264,
            134528672,
            134527776,
            134534053,
            134528432,
            134536639,
            134529472,
            134532032,
            134537680,
            134527312,
            134529744,
            134531280,
            134531792,
            134957012,
            134920282,
            134527456,
            134954350,
            134527600,
            134527728,
            134530544
        ],
        "134952731": [
            134531216,
            134531936,
            134530448
        ],
        "134952775": [
            134531584,
            134527488,
            134528288,
            134529728,
            134949966,
            134530544,
            134526896,
            134950578,
            134527696,
            134952731
        ],
        "134953010": [
            134527488,
            134528288,
            134952775,
            134949966,
            134529488,
            134530544,
            134950578,
            134526896,
            134527696,
            134952731
        ],
        "134953287": [
            134953010
        ],
        "134953304": [],
        "134953457": [
            134531648
        ],
        "134953647": [
            134531200,
            134531584,
            134534624,
            134530736,
            134528592,
            134953457,
            134527216
        ],
        "134953890": [
            134531008,
            134531680,
            134536591,
            134531504,
            134535732
        ],
        "134953987": [
            134953890,
            134535787
        ],
        "134953997": [
            134531936,
            134536161,
            134530784,
            134527936,
            134536964,
            134530448,
            134531504,
            134531696,
            134537596
        ],
        "134954203": [
            134953997
        ],
        "134954213": [
            134534644
        ],
        "134954264": [
            134532096,
            134534129
        ],
        "134954295": [
            134532096
        ],
        "134954309": [
            134536101
        ],
        "134954319": [
            134532096
        ],
        "134954333": [
            134536101
        ],
        "134954343": [
            134529968,
            134535881
        ],
        "134954350": [
            134529968,
            134535881
        ],
        "134954358": [
            134954264
        ],
        "134954395": [
            134534660,
            134954358
        ],
        "134954410": [
            134536212
        ],
        "134954438": [
            134954410,
            134534660
        ],
        "134954453": [
            134530240,
            134530736,
            134534624
        ],
        "134954782": [
            134954453
        ],
        "134954814": [
            134954453
        ],
        "134954837": [
            134954453
        ],
        "134954861": [
            134954453
        ],
        "134954894": [
            134954453
        ],
        "134954922": [
            134954894
        ],
        "134954935": [
            134528256,
            134530736,
            134534624
        ],
        "134955155": [
            134954935
        ],
        "134955169": [
            134954935
        ],
        "134955180": [
            134954935
        ],
        "134955192": [
            134954935
        ],
        "134955212": [
            134954935
        ],
        "134955228": [
            134954935
        ],
        "134955244": [
            134955228
        ],
        "134955251": [
            134534624,
            134954935
        ],
        "134955360": [
            134955251
        ],
        "134955376": [
            134955251
        ],
        "134955399": [
            134955212
        ],
        "134955411": [
            134955212
        ],
        "134955424": [
            134531648,
            134528656,
            134536006,
            134536639
        ],
        "134955563": [
            134529296
        ],
        "134955586": [
            134955563
        ],
        "134955594": [
            134955563
        ],
        "134955608": [
            134955594
        ],
        "134955618": [
            134955608
        ],
        "134955628": [
            134955608
        ],
        "134955638": [
            134955608
        ],
        "134955648": [
            134529296,
            134534053,
            134534782
        ],
        "134955715": [
            134527040,
            134534089,
            134530464
        ],
        "134955775": [
            134530880,
            134540652
        ],
        "134955870": [],
        "134955890": [
            134531648,
            134528576,
            134528928,
            134534660,
            134540652,
            134535982,
            134949966,
            134527184,
            134530224,
            134531120,
            134534644,
            134535930,
            134955870
        ],
        "134956442": [
            134955890
        ],
        "134956454": [
            134955890
        ],
        "134956466": [
            134955890
        ],
        "134956477": [
            134955890
        ],
        "134956488": [
            134955890
        ],
        "134956499": [
            134528352,
            134537113,
            134535982
        ],
        "134956613": [
            134532032,
            134955618,
            134955715,
            134537113,
            134956477
        ],
        "134956669": [
            134537113,
            134955715
        ],
        "134956706": [
            134955424
        ],
        "134956716": [
            134955424
        ],
        "134956726": [
            134955424
        ],
        "134956736": [
            134530816,
            134531584,
            134532032,
            134534053,
            134535955
        ],
        "134956824": [
            134530832,
            134926430
        ],
        "134956851": [
            134535955
        ],
        "134956922": [
            134530256,
            134535930,
            134530976
        ],
        "134956986": [
            134534624,
            134956922
        ],
        "134957012": [
            134534053
        ],
        "134957021": [
            134531648,
            134530752,
            134540652,
            134949966,
            134530864,
            134531408
        ],
        "134957246": [
            134531648,
            134957021,
            134912597,
            134534624
        ],
        "134957357": [],
        "134957642": [],
        "134957960": [],
        "134958199": [],
        "134958447": [],
        "134958817": []
    },
    "pseudocode": {
        "134532128": [
            "start",
            "0x804cc20",
            "// positive sp value has been detected, the output may be wrong!\nvoid __usercall __noreturn start(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // [esp-4h] [ebp-4h] BYREF\n  void *retaddr; // [esp+0h] [ebp+0h] BYREF\n\n  v2 = v3;\n  v3 = a1;\n  ((void (__stdcall *)(void (__cdecl __noreturn *)(int, int), int, void **, int (*)(), int (*)(), int, int *))__uClibc_main)(\n    sub_804D1AF,\n    v2,\n    &retaddr,\n    init_proc,\n    term_proc,\n    a2,\n    &v3);\n  __halt();\n}\n"
        ],
        "134532162": [
            "sub_804CC42",
            "0x804cc42",
            "void sub_804CC42()\n{\n  ;\n}\n"
        ],
        "134532166": [
            "sub_804CC46",
            "0x804cc46",
            "void *sub_804CC46()\n{\n  return &unk_80DB564;\n}\n"
        ],
        "134532260": [
            "sub_804CCA4",
            "0x804cca4",
            "int sub_804CCA4()\n{\n  int result; // eax\n\n  if ( !byte_80DB62C )\n  {\n    while ( dword_80DB630 < (unsigned int)(&dword_80DAF4C - dword_80DAF48 - 1) )\n      ((void (*)(void))dword_80DAF48[++dword_80DB630])();\n    sub_804CC46();\n    result = 0;\n    byte_80DB62C = 1;\n  }\n  return result;\n}\n"
        ],
        "134532359": [
            "sub_804CD07",
            "0x804cd07",
            "__int64 sub_804CD07()\n{\n  return 0LL;\n}\n"
        ],
        "134532413": [
            "sub_804CD3D",
            "0x804cd3d",
            "int __usercall sub_804CD3D@<eax>(_DWORD *a1@<eax>)\n{\n  _DWORD *i; // edx\n\n  for ( i = a1; *i; ++i )\n    ;\n  return i - a1;\n}\n"
        ],
        "134532433": [
            "sub_804CD51",
            "0x804cd51",
            "unsigned int __usercall sub_804CD51@<eax>(const char *a1@<eax>)\n{\n  unsigned __int16 *v2; // ebp\n  unsigned int v3; // esi\n  const char *v4; // ebx\n  int v5; // eax\n  unsigned int v6; // edx\n  unsigned int v7; // esi\n  unsigned int result; // eax\n  const char *i; // ecx\n  char v10; // dl\n\n  v2 = (unsigned __int16 *)&unk_80B8510;\n  v3 = 2136;\n  while ( 1 )\n  {\n    v4 = (const char *)(v2[6] + 135033847);\n    v5 = strcmp(a1, v4);\n    v6 = v3 - 267;\n    if ( v5 >= 0 )\n      break;\n    --v2;\n    v3 -= 267;\n    if ( v6 == 267 )\n    {\n      v4 = \"[\";\n      v6 = 0;\n      break;\n    }\n  }\n  v7 = v3 >> 3;\n  for ( result = v6 >> 3; result < v7; ++result )\n  {\n    for ( i = a1; ; ++i )\n    {\n      v10 = *v4;\n      if ( *i != *v4 )\n        break;\n      if ( !v10 )\n        return result;\n      ++v4;\n    }\n    while ( 1 )\n    {\n      ++v4;\n      if ( !v10 )\n        break;\n      v10 = *v4;\n    }\n  }\n  return -1;\n}\n"
        ],
        "134532546": [
            "sub_804CDC2",
            "0x804cdc2",
            "void __noreturn sub_804CDC2()\n{\n  signed int v0; // eax\n  __int16 *v1; // ebx\n\n  v0 = sub_804CD51(ident);\n  if ( v0 >= 0 )\n  {\n    v1 = &asc_80B891C[1];\n    while ( v0 )\n    {\n      do\n        v1 = (__int16 *)((char *)v1 + 1);\n      while ( *((_BYTE *)v1 - 1) );\n      --v0;\n    }\n    sub_804D85F();\n    sub_804D85F();\n    if ( *(_BYTE *)v1 != 8 )\n    {\n      sub_804D85F();\n      sub_804D85F();\n      sub_804D85F();\n      sub_804D85F();\n    }\n    sub_804D85F();\n  }\n  sub_804D604();\n}\n"
        ],
        "134532664": [
            "sub_804CE38",
            "0x804ce38",
            "char *__cdecl sub_804CE38(char *a1)\n{\n  char *result; // eax\n\n  dword_80DBB7C = (int)__errno_location();\n  result = a1;\n  ident = a1;\n  return result;\n}\n"
        ],
        "134532684": [
            "sub_804CE4C",
            "0x804ce4c",
            "void __usercall __noreturn sub_804CE4C(char **argv@<ecx>, int a2@<eax>, char *a3@<edx>, int a4@<ebp>)\n{\n  int v7; // ecx\n  int v8; // ebp\n  __uid_t v9; // edi\n  int v10; // eax\n  __gid_t gida; // [esp+0h] [ebp-14h]\n\n  v8 = sub_804CD3D(argv);\n  ident = a3;\n  if ( a2 != 54 && a2 != 231 && a2 != 224 && v8 == 2 && !strcmp(*(const char **)(v7 + 4), \"--help\") )\n  {\n    byte_80DB560 = 0;\n    sub_804CDC2(a4);\n  }\n  v9 = uid;\n  if ( uid )\n  {\n    gida = getgid();\n    v10 = ((int)(unsigned __int8)byte_80C73B4[a2 / 4] >> (2 * (a2 % 4))) & 3;\n    if ( v10 == 2 )\n    {\n      if ( geteuid() )\n        sub_804D5E0(\"must be suid to work properly\", gida);\n    }\n    else if ( !v10 )\n    {\n      setgid(gida);\n      setuid(v9);\n    }\n  }\n  byte_80DB560 = funcs_804CF01[a2](v8, (int)argv);\n  sub_804D604();\n}\n"
        ],
        "134532882": [
            "sub_804CF12",
            "0x804cf12",
            "void __usercall __noreturn sub_804CF12(char *a1@<eax>, const char **a2@<edx>, int a3@<ecx>, int a4@<ebp>)\n{\n  int v6; // ecx\n  int v7; // ebx\n  int v8; // esi\n  const char *i; // ebx\n  size_t v10; // edi\n  const char *v11; // esi\n  int v12; // edi\n  const char *v13; // esi\n  int v14; // edi\n  char *v15; // esi\n  const char *v16; // eax\n  const char *v17; // edi\n  int j; // ebx\n  char *v19; // ebp\n  const char *v20; // eax\n  int v21; // eax\n  int v22; // [esp-8h] [ebp-20h]\n  int v23; // [esp-4h] [ebp-1Ch]\n  int v24; // [esp+0h] [ebp-18h]\n  int (*v25)(const char *, const char *); // [esp+4h] [ebp-14h]\n\n  if ( !sub_804D210(a3, \"busybox\") )\n  {\n    v21 = sub_804CD51(a1);\n    if ( v21 >= 0 )\n      sub_804CE4C((char **)a2, v21, a1, a4);\n    sub_804D85F();\n    sub_804D85F();\n    exit(127);\n  }\n  if ( !a2[1] )\n    goto LABEL_3;\n  if ( sub_804D210(v6, \"--list\") )\n  {\n    dup2(1, 2);\n    v11 = \"[\";\n    v12 = 0;\n    while ( *v11 )\n    {\n      if ( a2[1][6] )\n        sub_804D85F();\n      sub_804D85F();\n      sub_804D85F();\n      ++v12;\n      do\n        ++v11;\n      while ( *(v11 - 1) );\n    }\n  }\n  else\n  {\n    v13 = a2[1];\n    v14 = strcmp(v13, \"--install\");\n    if ( v14 )\n    {\n      if ( !strcmp(v13, \"--help\") )\n      {\n        v20 = a2[2];\n        if ( !v20 )\n        {\nLABEL_3:\n          v7 = sub_804D986();\n          dup2(1, 2);\n          sub_804D85F();\n          sub_804D85F();\n          sub_804D85F();\n          v24 = v7 - 1;\n          v8 = 0;\n          for ( i = \"[\"; ; i += v10 + 1 )\n          {\n            if ( !*i )\n            {\n              sub_804D85F();\n              goto LABEL_41;\n            }\n            v10 = strlen(i);\n            if ( (int)(v24 - (v10 + 2)) <= v8 )\n              break;\n            if ( !v8 )\n              goto LABEL_8;\n            sub_804D85F();\nLABEL_10:\n            sub_804D85F();\n            v8 += v10 + 2;\n          }\n          sub_804D85F();\nLABEL_8:\n          sub_804D85F();\n          v8 = 6;\n          goto LABEL_10;\n        }\n        *a2 = v20;\n        a2[2] = 0;\n      }\n      ident = (char *)sub_804D32D(v23, v22);\n      sub_804CF12();\n    }\n    v15 = (char *)sub_804E190();\n    if ( !v15 )\n    {\n      v15 = (char *)*a2;\n      if ( **a2 != 47 )\n        sub_804D5E0(\"'%s' is not an absolute path\", *a2);\n    }\n    v16 = a2[2];\n    if ( v16 && !strcmp(v16, \"-s\") )\n      v14 = a2 + 1 != 0;\n    v25 = symlink;\n    if ( !v14 )\n      v25 = link;\n    v17 = \"[\";\n    for ( j = 0; j != 267; ++j )\n    {\n      v19 = (char *)sub_804D2D1();\n      if ( v25(v15, v19) && *(_DWORD *)dword_80DBB7C != 17 )\n        sub_804D3F1();\n      free(v19);\n      do\n        ++v17;\n      while ( *(v17 - 1) );\n    }\n  }\nLABEL_41:\n  exit(0);\n}\n"
        ],
        "134533551": [
            "sub_804D1AF",
            "0x804d1af",
            "void __usercall __noreturn sub_804D1AF(int a1@<ebp>, int a2, const char **a3)\n{\n  const char *v3; // eax\n  int v4; // ecx\n\n  mallopt(-1, 0x2000);\n  mallopt(-3, 32512);\n  sub_804CE38(\"busybox\");\n  v3 = *a3;\n  ident = (char *)v3;\n  if ( *v3 == 45 )\n    ident = (char *)(v3 + 1);\n  ident = (char *)sub_804D315();\n  uid = getuid();\n  sub_804CF12(ident, a3, v4, a1);\n}\n"
        ],
        "134533648": [
            "sub_804D210",
            "0x804d210",
            "_BYTE *__usercall sub_804D210@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>)\n{\n  while ( *a2 )\n  {\n    if ( *result != *a2 )\n      return 0;\n    ++a2;\n    ++result;\n  }\n  return result;\n}\n"
        ],
        "134533666": [
            "sub_804D222",
            "0x804d222",
            "int __usercall sub_804D222@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // esi\n\n  v4 = 0;\n  while ( *a1 )\n  {\n    if ( !strcmp(a1, a2) )\n      return v4;\n    a1 += strlen(a1) + 1;\n    ++v4;\n  }\n  return -1;\n}\n"
        ],
        "134533716": [
            "sub_804D254",
            "0x804d254",
            "int __usercall sub_804D254@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  size_t v4; // eax\n  size_t v5; // edi\n  int v6; // ebx\n  int v8; // [esp+0h] [ebp-14h]\n\n  v4 = strlen(a2);\n  if ( !v4 )\n    return -1;\n  v5 = v4;\n  v8 = 0;\n  v6 = -1;\n  while ( *a1 )\n  {\n    if ( !strncmp(a1, a2, v5) )\n    {\n      if ( !a1[v5] )\n        return v8;\n      if ( v6 != -1 )\n        return -1;\n      v6 = v8;\n    }\n    a1 += strlen(a1) + 1;\n    ++v8;\n  }\n  return v6;\n}\n"
        ],
        "134533812": [
            "sub_804D2B4",
            "0x804d2b4",
            "const char *__usercall sub_804D2B4@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  while ( a2 )\n  {\n    --a2;\n    a1 += strlen(a1) + 1;\n  }\n  return a1;\n}\n"
        ],
        "134533841": [
            "sub_804D2D1",
            "0x804d2d1",
            "int __usercall sub_804D2D1@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  const char *v4; // ebx\n\n  v4 = &data;\n  if ( a1 )\n    LOBYTE(v4) = a1;\n  sub_804D378(a3, 47);\n  while ( *a2 == 47 )\n    ++a2;\n  return sub_804DDBF(\"%s%s%s\", (char)v4);\n}\n"
        ],
        "134533909": [
            "sub_804D315",
            "0x804d315",
            "char *__usercall sub_804D315@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  char *v2; // eax\n\n  v1 = a1;\n  v2 = strrchr(a1, 47);\n  if ( v2 )\n    return v2 + 1;\n  return (char *)v1;\n}\n"
        ],
        "134533933": [
            "sub_804D32D",
            "0x804d32d",
            "char *__usercall sub_804D32D@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  char *v2; // eax\n\n  v1 = a1;\n  v2 = strrchr(a1, 47);\n  if ( v2 && (v1 != v2 || v1[1]) )\n    return v2 + 1;\n  return (char *)v1;\n}\n"
        ],
        "134533967": [
            "sub_804D34F",
            "0x804d34f",
            "char *__usercall sub_804D34F@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // eax\n\n  v3 = (const char *)sub_804D378(a2, 47);\n  if ( v3 )\n  {\n    while ( *v3 == 47 && v3 != a1 )\n      *v3-- = 0;\n  }\n  return sub_804D32D(a1);\n}\n"
        ],
        "134534008": [
            "sub_804D378",
            "0x804d378",
            "const char *__usercall sub_804D378@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *result; // eax\n\n  if ( !a1 )\n    return 0;\n  result = 0;\n  if ( *a1 )\n  {\n    result = &a1[strlen(a1) - 1];\n    if ( *(unsigned __int8 *)result != a2 )\n      return 0;\n  }\n  return result;\n}\n"
        ],
        "134534053": [
            "sub_804D3A5",
            "0x804d3a5",
            "int sub_804D3A5(int a1, ...)\n{\n  char *v1; // eax\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v1 = 0;\n  if ( *(_DWORD *)dword_80DBB7C )\n    v1 = strerror(*(_DWORD *)dword_80DBB7C);\n  return sub_804D40A(v1, (char *)va);\n}\n"
        ],
        "134534089": [
            "sub_804D3C9",
            "0x804d3c9",
            "void __noreturn sub_804D3C9(int a1, ...)\n{\n  char *v1; // eax\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v1 = 0;\n  if ( *(_DWORD *)dword_80DBB7C )\n    v1 = strerror(*(_DWORD *)dword_80DBB7C);\n  sub_804D40A(v1, (char *)va);\n  sub_804D604();\n}\n"
        ],
        "134534129": [
            "sub_804D3F1",
            "0x804d3f1",
            "__int64 __usercall sub_804D3F1@<edx:eax>(const char *a1@<eax>)\n{\n  __int64 v2; // [esp-8h] [ebp-8h]\n\n  sub_804D3A5((int)\"%s\", a1);\n  return v2;\n}\n"
        ],
        "134534143": [
            "sub_804D3FF",
            "0x804d3ff",
            "void __usercall __noreturn sub_804D3FF(const char *a1@<eax>)\n{\n  sub_804D3C9((int)\"%s\", a1);\n}\n"
        ],
        "134534154": [
            "sub_804D40A",
            "0x804d40a",
            "char *__usercall sub_804D40A@<eax>(char *result@<eax>, va_list a2@<edx>, const char *a3@<ecx>)\n{\n  const char *v3; // edi\n  size_t v5; // esi\n  signed int v6; // ebx\n  size_t v7; // ebp\n  char *v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  size_t v11; // ebx\n  int v12; // eax\n  int v13; // [esp-8h] [ebp-80h]\n  int v14; // [esp-8h] [ebp-80h]\n  int v15; // [esp-4h] [ebp-7Ch]\n  int v16; // [esp-4h] [ebp-7Ch]\n  int v17; // [esp-4h] [ebp-7Ch]\n  size_t v18; // [esp+0h] [ebp-78h]\n  size_t v20; // [esp+8h] [ebp-70h]\n  size_t v21; // [esp+Ch] [ebp-6Ch]\n  size_t v22; // [esp+10h] [ebp-68h]\n  char *dest; // [esp+14h] [ebp-64h] BYREF\n  char v24[96]; // [esp+18h] [ebp-60h] BYREF\n\n  if ( !byte_80DB561 )\n    return result;\n  v3 = result;\n  if ( !result )\n    v3 = &data;\n  v20 = strlen(ident);\n  v5 = v20 + 2;\n  v22 = v20 + 2;\n  v18 = 0;\n  if ( a3 )\n    v18 = strlen(a3);\n  v21 = strlen(off_80DB54C);\n  if ( (int)(80 - v5) > 0 )\n  {\n    dest = v24;\n    v6 = v5 + vsnprintf(&v24[v5], 80 - v5, v3, a2);\n    if ( (int)(77 - v21 - v18) > v6 )\n      goto LABEL_12;\n  }\n  result = (char *)vasprintf(&dest, v3, a2);\n  v7 = (size_t)result;\n  if ( (int)result < 0 )\n    return result;\n  v6 = (signed int)&result[v5];\n  v8 = (char *)realloc(dest, (size_t)&result[v5 + 3 + v18 + v21]);\n  v9 = v13;\n  v10 = v15;\n  if ( v8 )\n  {\n    dest = v8;\n    memmove(&v8[v5], v8, v7);\nLABEL_12:\n    strcpy(dest, ident);\n    dest[v20] = 58;\n    dest[v20 + 1] = 32;\n    if ( a3 )\n    {\n      if ( *v3 )\n      {\n        v12 = v6 + 1;\n        dest[v6] = 58;\n        v6 += 2;\n        dest[v12] = 32;\n      }\n      strcpy(&dest[v6], a3);\n      v6 += v18;\n    }\n    strcpy(&dest[v6], off_80DB54C);\n    v11 = v21 + v6;\n    v9 = v14;\n    v10 = v16;\n    goto LABEL_17;\n  }\n  v11 = v7 + 1;\n  dest[v7] = 10;\n  v22 = 0;\nLABEL_17:\n  if ( (byte_80DB561 & 1) != 0 )\n  {\n    sub_804DD8F(v10, v9);\n    sub_804E586(v11, dest);\n  }\n  if ( (byte_80DB561 & 2) != 0 )\n    syslog(byte_80DB562, \"%s\", &dest[v22]);\n  result = dest;\n  if ( dest != v24 )\n  {\n    free(dest);\n    return (char *)v17;\n  }\n  return result;\n}\n"
        ],
        "134534624": [
            "sub_804D5E0",
            "0x804d5e0",
            "void __noreturn sub_804D5E0(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  sub_804D40A(a1, va, 0);\n  sub_804D604();\n}\n"
        ],
        "134534644": [
            "sub_804D5F4",
            "0x804d5f4",
            "char *sub_804D5F4(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_804D40A(a1, va, 0);\n}\n"
        ],
        "134534660": [
            "sub_804D604",
            "0x804d604",
            "void __noreturn sub_804D604()\n{\n  if ( dword_80DBB84 )\n    dword_80DBB84();\n  exit((unsigned __int8)byte_80DB560);\n}\n"
        ],
        "134534684": [
            "sub_804D61C",
            "0x804d61c",
            "int __usercall sub_804D61C@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n\n  v2 = fcntl64(a1, 3);\n  if ( (v2 & 0x800) == 0 )\n    fcntl64(a1, 4);\n  return v2;\n}\n"
        ],
        "134534726": [
            "sub_804D646",
            "0x804d646",
            "int __usercall sub_804D646@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n\n  v2 = fcntl64(a1, 3);\n  if ( (v2 & 0x800) != 0 )\n    fcntl64(a1, 4);\n  return v2;\n}\n"
        ],
        "134534768": [
            "sub_804D670",
            "0x804d670",
            "int __usercall sub_804D670@<eax>(int a1@<eax>)\n{\n  return fcntl64(a1, 2);\n}\n"
        ],
        "134534782": [
            "sub_804D67E",
            "0x804d67e",
            "char *__usercall sub_804D67E@<eax>(char *a1@<eax>, const char *a2@<edx>)\n{\n  return strncpy(a1, a2, 0x10u);\n}\n"
        ],
        "134534795": [
            "sub_804D68B",
            "0x804d68b",
            "_BYTE *__usercall sub_804D68B@<eax>(unsigned int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  int v4; // ebp\n  int v5; // edi\n  unsigned int v6; // ebx\n  int v7; // eax\n\n  if ( a3 )\n  {\n    v4 = 10;\n    v5 = 0;\n    v6 = 1000000000;\n    do\n    {\n      v7 = a1 / v6;\n      a1 %= v6;\n      if ( v5 | v7 || v6 == 1 )\n      {\n        if ( !--a3 )\n          return a2;\n        ++v5;\n        *a2++ = v7 + 48;\n      }\n      else\n      {\n        v5 = 0;\n      }\n      v6 /= 0xAu;\n      --v4;\n    }\n    while ( v4 );\n  }\n  return a2;\n}\n"
        ],
        "134534880": [
            "sub_804D6E0",
            "0x804d6e0",
            "_BYTE *__usercall sub_804D6E0@<eax>(signed int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  if ( !a3 )\n    return a2;\n  if ( a1 < 0 )\n  {\n    a1 = -a1;\n    *a2 = 45;\n    --a3;\n    ++a2;\n  }\n  return sub_804D68B(a1, a2, a3);\n}\n"
        ],
        "134534903": [
            "sub_804D6F7",
            "0x804d6f7",
            "_BYTE *__usercall sub_804D6F7@<eax>(unsigned int a1@<eax>)\n{\n  *sub_804D68B(a1, byte_80DB650, 11) = 0;\n  return byte_80DB650;\n}\n"
        ],
        "134534927": [
            "sub_804D70F",
            "0x804d70f",
            "_BYTE *__usercall sub_804D70F@<eax>(signed int a1@<eax>)\n{\n  *sub_804D6E0(a1, byte_80DB650, 11) = 0;\n  return byte_80DB650;\n}\n"
        ],
        "134534951": [
            "sub_804D727",
            "0x804d727",
            "int __usercall sub_804D727@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int i; // ebx\n  unsigned __int8 v5; // dl\n\n  for ( i = 0; i != a3; ++i )\n  {\n    v5 = *(_BYTE *)(a2 + i);\n    *(_BYTE *)(a1 + 2 * i) = byte_80C7B1E[v5 >> 4] | 0x20;\n    *(_BYTE *)(a1 + 2 * i + 1) = byte_80C7B1E[v5 & 0xF] | 0x20;\n  }\n  return 2 * i + a1;\n}\n"
        ],
        "134535023": [
            "sub_804D76F",
            "0x804d76f",
            "_BYTE *__usercall sub_804D76F@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // esi\n  int v4; // ecx\n  int v5; // esi\n  int v6; // edi\n  int v7; // edx\n  _BYTE *v8; // [esp+0h] [ebp-18h]\n  _BYTE *v9; // [esp+4h] [ebp-14h]\n\n  *(_DWORD *)dword_80DBB7C = 22;\n  v9 = &result[a3];\n  while ( 1 )\n  {\n    LOBYTE(a3) = *a2;\n    if ( !*a2 )\n    {\n      v7 = 0;\n      goto LABEL_21;\n    }\n    if ( result == v9 )\n    {\n      v7 = 34;\nLABEL_21:\n      *(_DWORD *)dword_80DBB7C = v7;\n      return result;\n    }\n    v8 = a2 + 1;\n    v3 = a3 - 48;\n    if ( (unsigned __int8)(a3 - 48) > 9u )\n    {\n      v4 = a3 | 0x20;\n      if ( (unsigned __int8)(v4 - 97) > 5u )\n        return 0;\n      v3 = v4 - 87;\n    }\n    a3 = 16 * v3;\n    v5 = (unsigned __int8)a2[1];\n    v6 = v5 - 48;\n    if ( (unsigned __int8)(v5 - 48) <= 9u )\n      goto LABEL_10;\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\nLABEL_10:\n      a3 |= v6;\n      goto LABEL_14;\n    }\n    if ( (_BYTE)v5 && (_BYTE)v5 != 58 )\n      return 0;\n    LOBYTE(a3) = (unsigned __int8)a3 >> 4;\nLABEL_14:\n    *result++ = a3;\n    if ( (_BYTE)v5 )\n      v8 = a2 + 2;\n    if ( *v8 == 58 )\n      ++v8;\n    a2 = v8;\n  }\n}\n"
        ],
        "134535216": [
            "sub_804D830",
            "0x804d830",
            "ssize_t __usercall sub_804D830@<eax>(char a1@<al>, int a2@<edx>)\n{\n  int buf; // [esp+0h] [ebp-4h] BYREF\n\n  buf = a2;\n  LOBYTE(buf) = a1;\n  return write(2, &buf, 1u);\n}\n"
        ],
        "134535238": [
            "sub_804D846",
            "0x804d846",
            "int __usercall sub_804D846@<eax>(char *a1@<eax>)\n{\n  size_t v2; // eax\n\n  v2 = strlen(a1);\n  return sub_804E586(v2, a1);\n}\n"
        ],
        "134535263": [
            "sub_804D85F",
            "0x804d85f",
            "int __usercall sub_804D85F@<eax>(char *a1@<eax>)\n{\n  size_t v2; // eax\n\n  v2 = strlen(a1);\n  return sub_804E586(v2, a1);\n}\n"
        ],
        "134535288": [
            "sub_804D878",
            "0x804d878",
            "_BOOL4 __usercall sub_804D878@<eax>(int a1@<eax>, int *a2@<edx>, int *a3@<ecx>)\n{\n  int v3; // esi\n  int v6; // ebx\n  int v7; // eax\n  _BOOL4 v8; // ebx\n  char *v9; // eax\n  int v10; // edx\n  int v11; // ebp\n  char *v12; // eax\n  int v14; // [esp+0h] [ebp-1Ch]\n  int v15; // [esp+4h] [ebp-18h] BYREF\n\n  v3 = a1;\n  if ( a1 == -1 )\n  {\n    v6 = 1;\n    if ( !isatty(1) )\n    {\n      v6 = isatty(2);\n      if ( v6 )\n      {\n        v6 = 2;\n      }\n      else if ( !isatty(0) )\n      {\n        v6 = open64(\"/dev/tty\");\n        v3 = v6;\n      }\n    }\n  }\n  else\n  {\n    v6 = a1;\n    v3 = -1;\n  }\n  v15 = 0;\n  v7 = ioctl(v6, 0x5413u, &v15);\n  v8 = 1;\n  if ( !v7 )\n    v8 = (_WORD)v15 == 0;\n  if ( a3 )\n  {\n    v14 = (unsigned __int16)v15;\n    v9 = getenv(\"LINES\");\n    v10 = v14;\n    if ( v9 )\n    {\n      v10 = atoi(v9);\n      v8 = 0;\n    }\n    if ( (unsigned int)(v10 - 2) > 0x752D )\n      v10 = 24;\n    *a3 = v10;\n  }\n  if ( a2 )\n  {\n    v11 = HIWORD(v15);\n    v12 = getenv(\"COLUMNS\");\n    if ( v12 )\n    {\n      v11 = atoi(v12);\n      v8 = 0;\n    }\n    if ( (unsigned int)(v11 - 2) > 0x752D )\n      v11 = 80;\n    *a2 = v11;\n  }\n  if ( v3 >= 0 )\n    close(v3);\n  return v8;\n}\n"
        ],
        "134535558": [
            "sub_804D986",
            "0x804d986",
            "int __usercall sub_804D986@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  v3 = a2;\n  sub_804D878(a1, &v3, 0);\n  return v3;\n}\n"
        ],
        "134535573": [
            "sub_804D995",
            "0x804d995",
            "int __usercall sub_804D995@<eax>(const struct termios *a1@<eax>)\n{\n  return tcsetattr(0, 0, a1);\n}\n"
        ],
        "134535587": [
            "sub_804D9A3",
            "0x804d9a3",
            "int __userpurge sub_804D9A3@<eax>(struct termios *termios_p@<ecx>, int a2@<eax>, struct termios *a3@<edx>, char a4)\n{\n  int result; // eax\n  tcflag_t c_lflag; // edx\n\n  memset(termios_p, 0, sizeof(struct termios));\n  result = tcgetattr(a2, termios_p);\n  qmemcpy(a3, termios_p, sizeof(struct termios));\n  c_lflag = a3->c_lflag;\n  a3->c_lflag = c_lflag & 0xFFFFFFB5;\n  if ( (a4 & 1) != 0 )\n    a3->c_lflag = c_lflag & 0xFFFFFFB4;\n  *(_WORD *)&a3->c_cc[5] = 256;\n  if ( (a4 & 2) != 0 )\n    a3->c_iflag &= 0xFFFFFAFF;\n  if ( (a4 & 4) != 0 )\n    a3->c_oflag &= ~4u;\n  if ( (a4 & 8) != 0 )\n    a3->c_iflag &= 0xFFFFC0BD;\n  return result;\n}\n"
        ],
        "134535700": [
            "sub_804DA14",
            "0x804da14",
            "int __usercall sub_804DA14@<eax>(char a1@<cl>, struct termios *termios_p@<edx>, int a3@<eax>)\n{\n  struct termios v5; // [esp+0h] [ebp-40h] BYREF\n\n  sub_804D9A3(termios_p, a3, &v5, a1);\n  return tcsetattr(a3, 0, &v5);\n}\n"
        ],
        "134535732": [
            "sub_804DA34",
            "0x804da34",
            "__pid_t __usercall sub_804DA34@<eax>(int options@<ecx>, int *stat_loc@<edx>, __pid_t a3@<eax>)\n{\n  __pid_t result; // eax\n\n  do\n    result = waitpid(a3, stat_loc, options);\n  while ( result == -1 && *(_DWORD *)dword_80DBB7C == 4 );\n  return result;\n}\n"
        ],
        "134535772": [
            "sub_804DA5C",
            "0x804da5c",
            "__pid_t __usercall sub_804DA5C@<eax>(int *a1@<eax>)\n{\n  return sub_804DA34(1, a1, -1);\n}\n"
        ],
        "134535787": [
            "sub_804DA6B",
            "0x804da6b",
            "int __usercall sub_804DA6B@<eax>(__pid_t a1@<eax>, int a2@<ecx>)\n{\n  int result; // eax\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  if ( a1 <= 0 )\n    return -1;\n  v3 = a2;\n  if ( sub_804DA34(0, &v3, a1) == -1 )\n    return -1;\n  if ( (v3 & 0x7F) == 0 )\n    return BYTE1(v3);\n  result = 0;\n  if ( (unsigned int)(unsigned __int16)v3 - 1 <= 0xFE )\n    return (v3 & 0x7F) + 384;\n  return result;\n}\n"
        ],
        "134535852": [
            "sub_804DAAC",
            "0x804daac",
            "int __usercall sub_804DAAC@<eax>(__pid_t a1@<eax>, int a2@<ecx>)\n{\n  int v3; // [esp+0h] [ebp-4h] BYREF\n\n  v3 = a2;\n  if ( sub_804DA34(0, &v3, a1) < 0 )\n    sub_804D3C9((int)\"waitpid\");\n  return v3;\n}\n"
        ],
        "134535881": [
            "sub_804DAC9",
            "0x804dac9",
            "void __noreturn sub_804DAC9()\n{\n  sub_804D5E0(\"out of memory\");\n}\n"
        ],
        "134535891": [
            "sub_804DAD3",
            "0x804dad3",
            "void *__usercall sub_804DAD3@<eax>(size_t a1@<eax>)\n{\n  void *result; // eax\n\n  result = malloc(a1);\n  if ( a1 )\n  {\n    if ( !result )\n    {\n      sub_804D5F4(\"out of memory\");\n      return 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134535930": [
            "sub_804DAFA",
            "0x804dafa",
            "void *__usercall sub_804DAFA@<eax>(size_t a1@<eax>)\n{\n  void *result; // eax\n\n  result = malloc(a1);\n  if ( !result )\n  {\n    if ( a1 )\n      sub_804DAC9();\n  }\n  return result;\n}\n"
        ],
        "134535955": [
            "sub_804DB13",
            "0x804db13",
            "void *__usercall sub_804DB13@<eax>(void *a1@<eax>, size_t a2@<edx>)\n{\n  void *result; // eax\n  int v4; // [esp-8h] [ebp-Ch]\n  int v5; // [esp-4h] [ebp-8h]\n\n  result = realloc(a1, a2);\n  if ( !result )\n  {\n    if ( a2 )\n      sub_804DAC9(v5, v4);\n  }\n  return result;\n}\n"
        ],
        "134535982": [
            "sub_804DB2E",
            "0x804db2e",
            "void *__usercall sub_804DB2E@<eax>(size_t a1@<eax>)\n{\n  void *v2; // edx\n\n  v2 = sub_804DAFA(a1);\n  memset(v2, 0, a1);\n  return v2;\n}\n"
        ],
        "134536006": [
            "sub_804DB46",
            "0x804db46",
            "char *__usercall sub_804DB46@<eax>(const char *a1@<eax>)\n{\n  char *result; // eax\n  int v2; // ecx\n  int v3; // [esp-4h] [ebp-4h]\n\n  if ( !a1 )\n    return 0;\n  result = strdup(a1);\n  if ( !result )\n    sub_804DAC9(v2, v3);\n  return result;\n}\n"
        ],
        "134536029": [
            "sub_804DB5D",
            "0x804db5d",
            "_BYTE *__usercall sub_804DB5D@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  _BYTE *v3; // ecx\n  int i; // eax\n  unsigned int v5; // ebx\n  _BYTE *result; // eax\n\n  v3 = a1;\n  for ( i = a2; i && *v3; --i )\n    ++v3;\n  v5 = a2 - i;\n  result = sub_804DAFA(a2 - i + 1);\n  result[v5] = 0;\n  qmemcpy(result, a1, v5);\n  return result;\n}\n"
        ],
        "134536077": [
            "sub_804DB8D",
            "0x804db8d",
            "void *__usercall sub_804DB8D@<eax>(const void *a1@<eax>, size_t a2@<edx>)\n{\n  void *result; // eax\n\n  result = sub_804DAFA(a2);\n  qmemcpy(result, a1, a2);\n  return result;\n}\n"
        ],
        "134536101": [
            "sub_804DBA5",
            "0x804dba5",
            "int __usercall sub_804DBA5@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = fopen64(a1, a2);\n  if ( !result )\n    sub_804D3C9((int)\"can't open '%s'\", a1);\n  return result;\n}\n"
        ],
        "134536130": [
            "sub_804DBC2",
            "0x804dbc2",
            "int __usercall sub_804DBC2@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = open64(a1);\n  if ( result < 0 )\n    sub_804D3C9((int)\"can't open '%s'\", a1);\n  return result;\n}\n"
        ],
        "134536161": [
            "sub_804DBE1",
            "0x804dbe1",
            "int __usercall sub_804DBE1@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBC2(a1);\n}\n"
        ],
        "134536171": [
            "sub_804DBEB",
            "0x804dbeb",
            "int __usercall sub_804DBEB@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n  int v3; // [esp+0h] [ebp-8h]\n\n  result = open64(a1);\n  if ( result < 0 )\n  {\n    v3 = result;\n    sub_804D3A5((int)\"can't open '%s'\", a1);\n    return v3;\n  }\n  return result;\n}\n"
        ],
        "134536212": [
            "sub_804DC14",
            "0x804dc14",
            "int __usercall sub_804DC14@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBEB(a1);\n}\n"
        ],
        "134536222": [
            "sub_804DC1E",
            "0x804dc1e",
            "int __usercall sub_804DC1E@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBE1(a1);\n}\n"
        ],
        "134536232": [
            "sub_804DC28",
            "0x804dc28",
            "int __usercall sub_804DC28@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = unlink(a1);\n  if ( result )\n    sub_804D3C9((int)\"can't remove file '%s'\", a1);\n  return result;\n}\n"
        ],
        "134536259": [
            "sub_804DC43",
            "0x804dc43",
            "int __usercall sub_804DC43@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n\n  result = rename(a1, a2);\n  if ( result )\n    sub_804D3C9((int)\"can't move '%s' to '%s'\", a1, a2);\n  return result;\n}\n"
        ],
        "134536293": [
            "sub_804DC65",
            "0x804dc65",
            "int __usercall sub_804DC65@<eax>(int *a1@<eax>)\n{\n  int result; // eax\n\n  result = pipe(a1);\n  if ( result )\n    sub_804D3C9((int)\"can't create pipe\");\n  return result;\n}\n"
        ],
        "134536315": [
            "sub_804DC7B",
            "0x804dc7b",
            "int __usercall sub_804DC7B@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = dup2(a1, a2);\n  if ( result != a2 )\n    sub_804D3C9((int)\"can't duplicate file descriptor\");\n  return result;\n}\n"
        ],
        "134536343": [
            "sub_804DC97",
            "0x804dc97",
            "int __usercall sub_804DC97@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  int v3; // [esp-8h] [ebp-8h]\n\n  if ( result != a2 )\n  {\n    v2 = result;\n    sub_804DC7B(result, a2);\n    close(v2);\n    return v3;\n  }\n  return result;\n}\n"
        ],
        "134536365": [
            "sub_804DCAD",
            "0x804dcad",
            "void __fastcall sub_804DCAD(size_t a1, void *a2)\n{\n  int v3; // eax\n  const char *v4; // edx\n\n  if ( a1 )\n  {\n    v3 = sub_804E586(a1, a2);\n    if ( v3 != a1 )\n    {\n      v4 = \"short write\";\n      if ( v3 < 0 )\n        v4 = \"write error\";\n      sub_804D3C9((int)v4);\n    }\n  }\n}\n"
        ],
        "134536404": [
            "sub_804DCD4",
            "0x804dcd4",
            "void __fastcall sub_804DCD4(int a1, char *a2)\n{\n  size_t v2; // eax\n\n  v2 = strlen(a2);\n  sub_804DCAD(v2, a2);\n}\n"
        ],
        "134536435": [
            "sub_804DCF3",
            "0x804dcf3",
            "int __usercall sub_804DCF3@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = close(a1);\n  if ( result )\n    sub_804D3C9((int)\"close failed\");\n  return result;\n}\n"
        ],
        "134536457": [
            "sub_804DD09",
            "0x804dd09",
            "int __userpurge sub_804DD09@<eax>(int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, int a4)\n{\n  int result; // eax\n  int v7; // edx\n\n  result = lseek64(a1, a2, a3, a4);\n  if ( v7 == -1 && result == -1 )\n  {\n    if ( !a4 )\n      sub_804D3C9((int)\"lseek(%llu)\", __PAIR64__(a3, a2));\n    sub_804D3C9((int)\"lseek\");\n  }\n  return result;\n}\n"
        ],
        "134536532": [
            "sub_804DD54",
            "0x804dd54",
            "int __usercall sub_804DD54@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = mkstemp64(a1);\n  if ( result < 0 )\n    sub_804D3C9((int)\"can't create temp file '%s'\", a1);\n  return result;\n}\n"
        ],
        "134536559": [
            "sub_804DD6F",
            "0x804dd6f",
            "_BYTE *__usercall sub_804DD6F@<eax>(_BYTE *result@<eax>, const char *a2@<edx>)\n{\n  if ( (*result & 8) != 0 )\n    sub_804D5E0(\"%s: I/O error\", a2);\n  return result;\n}\n"
        ],
        "134536576": [
            "sub_804DD80",
            "0x804dd80",
            "_BYTE *sub_804DD80()\n{\n  return sub_804DD6F(stdout, \"standard output\");\n}\n"
        ],
        "134536591": [
            "sub_804DD8F",
            "0x804dd8f",
            "int sub_804DD8F()\n{\n  return fflush(0);\n}\n"
        ],
        "134536600": [
            "sub_804DD98",
            "0x804dd98",
            "int __usercall sub_804DD98@<eax>(int result@<eax>)\n{\n  _BYTE *v1; // ecx\n\n  v1 = *(_BYTE **)(_stdout + 16);\n  if ( (unsigned int)v1 >= *(_DWORD *)(_stdout + 28) )\n    return __fputc_unlocked((_BYTE)result, _stdout);\n  *(_DWORD *)(_stdout + 16) = v1 + 1;\n  *v1 = result;\n  return (unsigned __int8)result;\n}\n"
        ],
        "134536639": [
            "sub_804DDBF",
            "0x804ddbf",
            "char *sub_804DDBF(char *a1, ...)\n{\n  char *v1; // ecx\n  int v2; // edx\n  int v3; // ecx\n  char *v5; // [esp+0h] [ebp-4h] BYREF\n  va_list va; // [esp+Ch] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v5 = v1;\n  if ( vasprintf(&v5, a1, va) < 0 )\n    sub_804DAC9(v3, v2);\n  return v5;\n}\n"
        ],
        "134536676": [
            "sub_804DDE4",
            "0x804dde4",
            "int __usercall sub_804DDE4@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n  int v3; // edx\n  int v4; // ecx\n\n  result = setenv(a1, a2, 1);\n  if ( result )\n    sub_804DAC9(v4, v3);\n  return result;\n}\n"
        ],
        "134536698": [
            "sub_804DDFA",
            "0x804ddfa",
            "void __usercall sub_804DDFA(const char *a1@<eax>)\n{\n  char *v1; // ebx\n  char *v2; // eax\n  char *v3; // esi\n  char *v4; // [esp-8h] [ebp-80h]\n  int v5; // [esp-4h] [ebp-7Ch]\n  char v6[120]; // [esp+0h] [ebp-78h] BYREF\n\n  v1 = (char *)a1;\n  v2 = strchr(a1, 61);\n  v3 = v2;\n  if ( v2 )\n  {\n    if ( (unsigned int)(v2 - v1) > 0x6F )\n    {\n      v1 = sub_804DB5D(v1, v2 - v1);\n      v3 = v1;\n    }\n    else\n    {\n      v5 = v2 - v1;\n      v4 = v1;\n      v1 = v6;\n      *(_BYTE *)mempcpy(v6, v4, v5) = 0;\n      v3 = 0;\n    }\n  }\n  unsetenv(v1);\n  free(v3);\n}\n"
        ],
        "134536781": [
            "sub_804DE4D",
            "0x804de4d",
            "int __usercall sub_804DE4D@<eax>(char *a1@<eax>)\n{\n  int v3; // [esp-4h] [ebp-8h]\n\n  sub_804DDFA(a1);\n  free(a1);\n  return v3;\n}\n"
        ],
        "134536798": [
            "sub_804DE5E",
            "0x804de5e",
            "int __usercall sub_804DE5E@<eax>(__gid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = setgid(a1);\n  if ( result )\n    sub_804D3C9((int)\"setgid\");\n  return result;\n}\n"
        ],
        "134536820": [
            "sub_804DE74",
            "0x804de74",
            "int __usercall sub_804DE74@<eax>(__uid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = setuid(a1);\n  if ( result )\n    sub_804D3C9((int)\"setuid\");\n  return result;\n}\n"
        ],
        "134536842": [
            "sub_804DE8A",
            "0x804de8a",
            "int __usercall sub_804DE8A@<eax>(__gid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = setegid(a1);\n  if ( result )\n    sub_804D3C9((int)\"setegid\");\n  return result;\n}\n"
        ],
        "134536864": [
            "sub_804DEA0",
            "0x804dea0",
            "int __usercall sub_804DEA0@<eax>(__uid_t a1@<eax>)\n{\n  int result; // eax\n\n  result = seteuid(a1);\n  if ( result )\n    sub_804D3C9((int)\"seteuid\");\n  return result;\n}\n"
        ],
        "134536886": [
            "sub_804DEB6",
            "0x804deb6",
            "int __userpurge sub_804DEB6@<eax>(const char *a1@<eax>, __uid_t a2@<ecx>, __gid_t a3)\n{\n  __uid_t v5; // edi\n  __gid_t v6; // esi\n  int v7; // ebx\n\n  v5 = geteuid();\n  v6 = getegid();\n  sub_804DE8A(a3);\n  sub_804DEA0(a2);\n  v7 = sub_804DBE1(a1);\n  sub_804DEA0(v5);\n  sub_804DE8A(v6);\n  return v7;\n}\n"
        ],
        "134536964": [
            "sub_804DF04",
            "0x804df04",
            "int __usercall sub_804DF04@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = chdir(a1);\n  if ( result )\n    sub_804D3C9((int)\"can't change directory to '%s'\", a1);\n  return result;\n}\n"
        ],
        "134536991": [
            "sub_804DF1F",
            "0x804df1f",
            "int __usercall sub_804DF1F@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = fchdir(a1);\n  if ( result )\n    sub_804D3C9((int)\"fchdir\");\n  return result;\n}\n"
        ],
        "134537013": [
            "sub_804DF35",
            "0x804df35",
            "int __usercall sub_804DF35@<eax>(const char *a1@<eax>)\n{\n  if ( chroot(a1) )\n    sub_804D3C9((int)\"can't change root directory to '%s'\", a1);\n  return sub_804DF04(\"/\");\n}\n"
        ],
        "134537049": [
            "sub_804DF59",
            "0x804df59",
            "DIR *__usercall sub_804DF59@<eax>(const char *a1@<eax>)\n{\n  DIR *result; // eax\n\n  result = opendir(a1);\n  if ( !result )\n  {\n    sub_804D3A5((int)\"can't open '%s'\", a1);\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134537086": [
            "sub_804DF7E",
            "0x804df7e",
            "DIR *__usercall sub_804DF7E@<eax>(const char *a1@<eax>)\n{\n  DIR *result; // eax\n\n  result = opendir(a1);\n  if ( !result )\n    sub_804D3C9((int)\"can't open '%s'\", a1);\n  return result;\n}\n"
        ],
        "134537113": [
            "sub_804DF99",
            "0x804df99",
            "int __usercall sub_804DF99@<eax>(int protocol@<ecx>, int type@<edx>, int a3@<eax>)\n{\n  int result; // eax\n\n  result = socket(a3, type, protocol);\n  if ( result < 0 )\n    sub_804D3C9((int)\"socket\");\n  return result;\n}\n"
        ],
        "134537139": [
            "sub_804DFB3",
            "0x804dfb3",
            "int __usercall sub_804DFB3@<eax>(socklen_t len@<ecx>, struct sockaddr *addr@<edx>, int a3@<eax>)\n{\n  int result; // eax\n\n  result = bind(a3, addr, len);\n  if ( result )\n    sub_804D3C9((int)\"bind\");\n  return result;\n}\n"
        ],
        "134537165": [
            "sub_804DFCD",
            "0x804dfcd",
            "ssize_t __userpurge sub_804DFCD@<eax>(\n        size_t n@<ecx>,\n        void *buf@<edx>,\n        int a3@<eax>,\n        struct sockaddr *addr,\n        socklen_t addr_len)\n{\n  ssize_t result; // eax\n\n  result = sendto(a3, buf, n, 0, addr, addr_len);\n  if ( result < 0 )\n    sub_804D3C9((int)\"sendto\");\n  return result;\n}\n"
        ],
        "134537203": [
            "sub_804DFF3",
            "0x804dff3",
            "int __usercall sub_804DFF3@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = stat64(a1, a2);\n  if ( result )\n    sub_804D3C9((int)\"can't stat '%s'\", a1);\n  return result;\n}\n"
        ],
        "134537232": [
            "sub_804E010",
            "0x804e010",
            "int __usercall sub_804E010@<eax>(int a1@<eax>, int a2@<edx>, const char *a3@<ecx>)\n{\n  int result; // eax\n\n  result = fstat64(a1, a2);\n  if ( result )\n    sub_804D3FF(a3);\n  return result;\n}\n"
        ],
        "134537257": [
            "sub_804E029",
            "0x804e029",
            "int sub_804E029(int fd, unsigned int request, int a3, char *a4, ...)\n{\n  int result; // eax\n  char *v5; // eax\n  va_list va; // [esp+14h] [ebp+14h] BYREF\n\n  va_start(va, a4);\n  result = ioctl(fd, request, a3);\n  if ( result < 0 )\n  {\n    v5 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D40A(a4, va, v5);\n    sub_804D604();\n  }\n  return result;\n}\n"
        ],
        "134537314": [
            "sub_804E062",
            "0x804e062",
            "int sub_804E062(int fd, unsigned int request, int a3, char *a4, ...)\n{\n  int v4; // ebx\n  char *v5; // eax\n  va_list va; // [esp+18h] [ebp+14h] BYREF\n\n  va_start(va, a4);\n  v4 = ioctl(fd, request, a3);\n  if ( v4 < 0 )\n  {\n    v5 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D40A(a4, va, v5);\n  }\n  return v4;\n}\n"
        ],
        "134537373": [
            "sub_804E09D",
            "0x804e09d",
            "int __userpurge sub_804E09D@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  int v4; // ebx\n\n  v4 = ioctl(a1, a2, a3);\n  if ( v4 < 0 )\n    sub_804D3F1(a4);\n  return v4;\n}\n"
        ],
        "134537406": [
            "sub_804E0BE",
            "0x804e0be",
            "int __userpurge sub_804E0BE@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  int result; // eax\n\n  result = ioctl(a1, a2, a3);\n  if ( result < 0 )\n    sub_804D3FF(a4);\n  return result;\n}\n"
        ],
        "134537433": [
            "sub_804E0D9",
            "0x804e0d9",
            "char *__usercall sub_804E0D9@<eax>(int a1@<eax>)\n{\n  char buf[132]; // [esp+0h] [ebp-84h] BYREF\n\n  if ( ttyname_r(a1, buf, 0x7Fu) )\n    return 0;\n  else\n    return sub_804DB46(buf);\n}\n"
        ],
        "134537473": [
            "sub_804E101",
            "0x804e101",
            "unsigned int __usercall sub_804E101@<eax>(_BYTE *a1@<eax>)\n{\n  int v2; // eax\n  int v3; // edx\n  int v4; // ecx\n  int v5; // esi\n  unsigned int v6; // eax\n  unsigned int i; // edi\n  int j; // esi\n  unsigned int result; // eax\n  int v10; // [esp-8h] [ebp-14h]\n\n  v2 = open64(\"/dev/urandom\");\n  v3 = v10;\n  v4 = 0;\n  if ( v2 >= 0 )\n  {\n    v5 = v2;\n    read(v2, a1, 0x10u);\n    close(v5);\n  }\n  v6 = sub_804EBDE(v4, v3);\n  srand(v6);\n  for ( i = getpid(); ; i = 0 )\n  {\n    for ( j = 0; j != 16; ++j )\n      a1[j] ^= rand() >> 5;\n    if ( !i )\n      break;\n    srand(i);\n  }\n  a1[6] = a1[6] & 0xF | 0x40;\n  result = a1[8] & 0x3F | 0xFFFFFF80;\n  a1[8] = result;\n  return result;\n}\n"
        ],
        "134537596": [
            "sub_804E17C",
            "0x804e17c",
            "__pid_t sub_804E17C()\n{\n  __pid_t result; // eax\n\n  result = fork();\n  if ( result < 0 )\n    sub_804D3C9((int)\"fork\");\n  return result;\n}\n"
        ],
        "134537616": [
            "sub_804E190",
            "0x804e190",
            "void *__usercall sub_804E190@<eax>(const char *a1@<eax>)\n{\n  signed int v2; // esi\n  void *v3; // ebx\n  ssize_t v4; // eax\n\n  v2 = 0;\n  v3 = 0;\n  do\n  {\n    v2 += 80;\n    v3 = sub_804DB13(v3, v2);\n    v4 = readlink(a1, (char *)v3, v2);\n    if ( v4 == -1 )\n    {\n      free(v3);\n      return 0;\n    }\n  }\n  while ( v2 <= v4 );\n  *((_BYTE *)v3 + v4) = 0;\n  return v3;\n}\n"
        ],
        "134537680": [
            "sub_804E1D0",
            "0x804e1d0",
            "char *__usercall sub_804E1D0@<eax>(const char *a1@<eax>)\n{\n  char *v1; // ebx\n  int v2; // ebp\n  size_t v3; // edi\n  char *v4; // eax\n  char *v5; // esi\n  int v6; // ecx\n  char *v7; // eax\n\n  v1 = sub_804DB46(a1);\n  v2 = 21;\nLABEL_2:\n  v3 = strlen(v1) + 1;\n  while ( 1 )\n  {\n    v4 = (char *)sub_804E190(v1);\n    v5 = v4;\n    if ( !v4 )\n      break;\n    if ( !--v2 )\n    {\n      free(v4);\nLABEL_9:\n      free(v1);\n      return 0;\n    }\n    if ( *v4 == 47 )\n    {\n      free(v1);\n      v1 = v5;\n      goto LABEL_2;\n    }\n    v3 += strlen(v4);\n    v1 = (char *)sub_804DB13(v1, v3);\n    v7 = sub_804D34F(v1, v6);\n    strcpy(v7, v5);\n    free(v5);\n  }\n  if ( *(_DWORD *)dword_80DBB7C != 2 && *(_DWORD *)dword_80DBB7C != 22 )\n    goto LABEL_9;\n  return v1;\n}\n"
        ],
        "134537825": [
            "sub_804E261",
            "0x804e261",
            "void *__usercall sub_804E261@<eax>(const char *a1@<eax>)\n{\n  void *v2; // ebx\n  char *v3; // eax\n\n  v2 = sub_804E190(a1);\n  if ( !v2 )\n  {\n    v3 = \"not a symlink\";\n    if ( *(_DWORD *)dword_80DBB7C != 22 )\n      v3 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D5F4(\"%s: cannot read link: %s\", a1, v3);\n  }\n  return v2;\n}\n"
        ],
        "134537884": [
            "sub_804E29C",
            "0x804e29c",
            "char *__usercall sub_804E29C@<eax>(const char *a1@<eax>)\n{\n  return realpath(a1, 0);\n}\n"
        ],
        "134537895": [
            "sub_804E2A7",
            "0x804e2a7",
            "_BYTE *__usercall sub_804E2A7@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v2; // edi\n  _BYTE *v3; // ebx\n  char *v4; // eax\n  const char *v5; // ebp\n  char *s; // eax\n  char *v7; // edi\n  size_t v8; // esi\n  size_t v9; // eax\n\n  v2 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v3 = sub_804E29C(a1);\n  if ( !v3 && *v2 == 2 )\n  {\n    v4 = strrchr(a1, 47);\n    if ( v4 )\n    {\n      v5 = v4 + 1;\n      *v4 = 0;\n      s = sub_804E29C(a1);\n      v7 = s;\n      if ( s )\n      {\n        v8 = strlen(s);\n        v9 = strlen(v5);\n        v3 = sub_804DB13(v7, v9 + v8 + 2);\n        v3[v8] = 47;\n        strcpy(&v3[v8 + 1], v5);\n      }\n    }\n  }\n  return v3;\n}\n"
        ],
        "134538016": [
            "sub_804E320",
            "0x804e320",
            "__int64 __usercall sub_804E320@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  unsigned __int64 v3; // rdi\n  int v4; // ecx\n  size_t v5; // ecx\n  signed int v6; // eax\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // eax\n  int v11; // [esp+0h] [ebp-1028h]\n  char v12; // [esp+7h] [ebp-1021h]\n  int v13; // [esp+8h] [ebp-1020h]\n  __int64 v16; // [esp+14h] [ebp-1014h]\n  char buf[4108]; // [esp+1Ch] [ebp-100Ch] BYREF\n\n  v3 = __PAIR64__(a3, HIDWORD(a3));\n  if ( a3 < 0 )\n  {\n    HIDWORD(v3) = -(int)a3;\n    LODWORD(v3) = (unsigned __int64)-a3 >> 32;\n    v16 = -1LL;\n    if ( a1 < 0 )\n      return v16;\n    v12 = 1;\n    goto LABEL_7;\n  }\n  v16 = -1LL;\n  if ( a1 < 0 )\n    return v16;\n  v12 = 0;\n  if ( a3 )\n  {\nLABEL_7:\n    v13 = -1;\n    goto LABEL_8;\n  }\n  v13 = 1;\n  v3 = 0x100000000000000LL;\nLABEL_8:\n  v4 = 0x1000000;\n  v16 = 0LL;\n  while ( 1 )\n  {\n    if ( v4 )\n    {\n      v8 = v4;\n      if ( v4 > __SPAIR64__(v3, HIDWORD(v3)) )\n        v8 = HIDWORD(v3);\n      v11 = v4;\n      v9 = sendfile64(a2, a1, 0, v8);\n      v7 = v9;\n      v4 = v11;\n      if ( v9 >= 0 )\n      {\n        if ( !v9 )\n          return v16;\n        goto LABEL_28;\n      }\n    }\n    v5 = HIDWORD(v3);\n    if ( (v3 & 0x80000000) == 0LL && ((int)v3 > 0 || HIDWORD(v3) > 0x1000) )\n      v5 = 4096;\n    v6 = sub_804E5BC(v5, buf);\n    v7 = v6;\n    if ( v6 < 0 )\n    {\n      sub_804D3A5((int)\"read error\");\n      return -1LL;\n    }\n    if ( !v6 )\n      return v16;\n    if ( a2 < 0 || v6 <= sub_804E586(v6, buf) )\n    {\n      v4 = 0;\n      goto LABEL_28;\n    }\n    if ( !v12 )\n      break;\n    v4 = 0;\n    a2 = -1;\nLABEL_28:\n    v16 += v7;\n    if ( v13 == -1 )\n    {\n      LODWORD(v3) = (__PAIR64__(v3, HIDWORD(v3)) - v7) >> 32;\n      HIDWORD(v3) -= v7;\n      if ( !v3 )\n        return v16;\n    }\n  }\n  sub_804D3A5((int)\"write error\");\n  return -1LL;\n}\n"
        ],
        "134538477": [
            "sub_804E4ED",
            "0x804e4ed",
            "__int64 __userpurge sub_804E4ED@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  __int64 result; // rax\n\n  result = a3;\n  if ( a3 )\n    return sub_804E320(a1, a2, a3);\n  return result;\n}\n"
        ],
        "134538522": [
            "sub_804E51A",
            "0x804e51a",
            "__int64 __userpurge sub_804E51A@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  __int64 result; // rax\n\n  result = sub_804E4ED(a1, a2, a3);\n  if ( abs64(a3) != result )\n  {\n    if ( result == -1 )\n      sub_804D604();\n    sub_804D5E0(\"short read\");\n  }\n  return result;\n}\n"
        ],
        "134538610": [
            "sub_804E572",
            "0x804e572",
            "__int64 __usercall sub_804E572@<edx:eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_804E320(a1, a2, 0LL);\n}\n"
        ],
        "134538630": [
            "sub_804E586",
            "0x804e586",
            "int __fastcall sub_804E586(size_t n, char *buf)\n{\n  int v4; // ebx\n  int v5; // eax\n\n  v4 = 0;\n  while ( n )\n  {\n    v5 = sub_804E65D(n, buf);\n    if ( v5 < 0 )\n    {\n      if ( !v4 )\n        return v5;\n      return v4;\n    }\n    v4 += v5;\n    buf += v5;\n    n -= v5;\n  }\n  return v4;\n}\n"
        ],
        "134538684": [
            "sub_804E5BC",
            "0x804e5bc",
            "ssize_t __usercall sub_804E5BC@<eax>(size_t nbytes@<ecx>, void *buf@<edx>, int a3@<eax>)\n{\n  ssize_t result; // eax\n\n  do\n    result = read(a3, buf, nbytes);\n  while ( result < 0 && *(_DWORD *)dword_80DBB7C == 4 );\n  return result;\n}\n"
        ],
        "134538723": [
            "sub_804E5E3",
            "0x804e5e3",
            "ssize_t __usercall sub_804E5E3@<eax>(size_t nbytes@<ecx>, char *buf@<edx>, int a3@<eax>)\n{\n  int v6; // ebx\n  ssize_t v7; // eax\n\n  v6 = 0;\n  while ( nbytes )\n  {\n    v7 = sub_804E5BC(nbytes, buf, a3);\n    if ( v7 < 0 )\n    {\n      if ( !v6 )\n        return v7;\n      return v6;\n    }\n    if ( !v7 )\n      return v6;\n    buf += v7;\n    v6 += v7;\n    nbytes -= v7;\n  }\n  return v6;\n}\n"
        ],
        "134538802": [
            "sub_804E632",
            "0x804e632",
            "int __usercall sub_804E632@<eax>(int a1@<eax>, char *a2@<edx>, size_t a3@<ecx>)\n{\n  int v3; // ebx\n  ssize_t v4; // esi\n  int result; // eax\n\n  result = open64(a1);\n  if ( result >= 0 )\n  {\n    v3 = result;\n    v4 = sub_804E5E3(a3, a2, result);\n    close(v3);\n    return v4;\n  }\n  return result;\n}\n"
        ],
        "134538845": [
            "sub_804E65D",
            "0x804e65d",
            "ssize_t __usercall sub_804E65D@<eax>(size_t n@<ecx>, void *buf@<edx>, int a3@<eax>)\n{\n  ssize_t result; // eax\n\n  while ( 1 )\n  {\n    result = write(a3, buf, n);\n    if ( result >= 0 || *(_DWORD *)dword_80DBB7C != 4 )\n      break;\n    *(_DWORD *)dword_80DBB7C = 0;\n  }\n  return result;\n}\n"
        ],
        "134538894": [
            "sub_804E68E",
            "0x804e68e",
            "void __cdecl sub_804E68E(char a1)\n{\n  byte_80DBBA4 = a1;\n}\n"
        ],
        "134538904": [
            "sub_804E698",
            "0x804e698",
            "int __usercall sub_804E698@<eax>(int a1@<eax>, const struct sigaction *a2@<edx>)\n{\n  return sigaction(a1, a2, 0);\n}\n"
        ],
        "134538917": [
            "sub_804E6A5",
            "0x804e6a5",
            "int __usercall sub_804E6A5@<eax>(int a1@<eax>)\n{\n  int v2[2]; // [esp+0h] [ebp-8h] BYREF\n\n  v2[0] = -1;\n  v2[1] = -1;\n  return sigprocmask(a1, (const sigset_t *)v2, 0);\n}\n"
        ],
        "134538952": [
            "sub_804E6C8",
            "0x804e6c8",
            "int __usercall sub_804E6C8@<eax>(int result@<eax>, void (*a2)(int)@<edx>)\n{\n  int v2; // esi\n  int v4; // ebx\n  int v5; // edi\n  int v6; // [esp-8h] [ebp-18h]\n\n  v2 = result;\n  v4 = 1;\n  v5 = 0;\n  while ( v2 )\n  {\n    if ( (v4 & v2) != 0 )\n    {\n      v2 -= v4;\n      signal(v5, a2);\n      result = v6;\n    }\n    ++v5;\n    v4 *= 2;\n  }\n  return result;\n}\n"
        ],
        "134538996": [
            "sub_804E6F4",
            "0x804e6f4",
            "int __usercall sub_804E6F4@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  int v4; // ebx\n  int v5; // edi\n  int v6[8]; // [esp+0h] [ebp-20h] BYREF\n\n  result = 0;\n  memset(&v6[1], 0, 0x10u);\n  v6[0] = a2;\n  v4 = 1;\n  v5 = 0;\n  while ( a1 )\n  {\n    if ( (v4 & a1) != 0 )\n    {\n      a1 -= v4;\n      result = sub_804E698(v5, (const struct sigaction *)v6);\n    }\n    ++v5;\n    v4 *= 2;\n  }\n  return result;\n}\n"
        ],
        "134539060": [
            "sub_804E734",
            "0x804e734",
            "int __usercall sub_804E734@<eax>(int a1@<eax>)\n{\n  int v2[3]; // [esp+0h] [ebp-Ch] BYREF\n\n  v2[0] = 0;\n  v2[1] = 0;\n  sigaddset((sigset_t *)v2, a1);\n  return sigprocmask(1, (const sigset_t *)v2, 0);\n}\n"
        ],
        "134539105": [
            "sub_804E761",
            "0x804e761",
            "void __usercall __noreturn sub_804E761(int a1@<eax>)\n{\n  int v1; // ebx\n\n  v1 = a1;\n  signal(a1, 0);\n  sub_804E734(v1);\n  raise(v1);\n  LOBYTE(v1) = v1 | 0x80;\n  _exit(v1);\n}\n"
        ],
        "134539138": [
            "sub_804E782",
            "0x804e782",
            "int __usercall sub_804E782@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3[8]; // [esp+0h] [ebp-20h] BYREF\n\n  memset(&v3[2], 0, 0xCu);\n  v3[1] = 0x10000000;\n  v3[0] = a2;\n  return sub_804E698(a1, (const struct sigaction *)v3);\n}\n"
        ],
        "134539188": [
            "sub_804E7B4",
            "0x804e7b4",
            "int __usercall sub_804E7B4@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3[8]; // [esp+0h] [ebp-20h] BYREF\n\n  memset(&v3[1], 0, 0x10u);\n  v3[0] = a2;\n  return sub_804E698(a1, (const struct sigaction *)v3);\n}\n"
        ],
        "134539230": [
            "sub_804E7DE",
            "0x804e7de",
            "int __usercall sub_804E7DE@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = syscall(265, 1, a1);\n  if ( result )\n    sub_804D5E0(\"clock_gettime(MONOTONIC) failed\");\n  return result;\n}\n"
        ],
        "134539261": [
            "sub_804E7FD",
            "0x804e7fd",
            "int __usercall sub_804E7FD@<eax>(const char *a1@<eax>, struct tm *a2@<edx>)\n{\n  int v4; // eax\n  int result; // eax\n  bool v6; // zf\n  int v7; // eax\n  char *v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  struct tm *v11; // esi\n  int v12; // eax\n  int v13; // eax\n  bool v14; // of\n  char v15; // cc\n  unsigned int v16; // eax\n  unsigned int v17; // edx\n  char *v18; // eax\n  int v19; // [esp-8h] [ebp-34h]\n  int v20; // [esp-4h] [ebp-30h]\n  int v21; // [esp-4h] [ebp-30h]\n  int *p_tm_hour; // [esp+0h] [ebp-2Ch]\n  int tm_year; // [esp+0h] [ebp-2Ch]\n  int *p_tm_mon; // [esp+4h] [ebp-28h]\n  char *v25; // [esp+8h] [ebp-24h]\n  char v26; // [esp+17h] [ebp-15h] BYREF\n  time_t timer; // [esp+18h] [ebp-14h] BYREF\n\n  v26 = 0;\n  v25 = strrchr(a1, 58);\n  if ( !v25 )\n  {\n    v8 = strchr(a1, 45);\n    v9 = v19;\n    v10 = v20;\n    if ( v8 )\n    {\n      result = sscanf(a1, \"%u-%u-%u %u%c\", &a2->tm_year, &a2->tm_mon, &a2->tm_mday, &a2->tm_hour, &v26);\n      if ( result > 3 || (result = sscanf(a1, \"%u-%u-%u%c\", &a2->tm_year, &a2->tm_mon, &a2->tm_mday, &v26), result > 2) )\n      {\n        a2->tm_year -= 1900;\n        --a2->tm_mon;\n        goto LABEL_50;\n      }\n    }\n    if ( *a1 == 64 )\n    {\n      timer = sub_804EDC5(10);\n      result = dword_80DBB7C;\n      if ( !*(_DWORD *)dword_80DBB7C )\n      {\n        v11 = localtime(&timer);\n        result = v21;\n        if ( v11 )\n        {\n          qmemcpy(a2, v11, sizeof(struct tm));\n          return result;\n        }\n      }\n      v26 = 49;\n      goto LABEL_50;\n    }\n    tm_year = a2->tm_year;\n    v12 = strchrnul(v10, v9, a1, 46) - (_DWORD)a1;\n    if ( v12 == 2 )\n    {\n      result = sscanf(a1, \"%2u%c\", &a2->tm_min, &v26);\n      if ( result <= 0 )\n        goto LABEL_11;\nLABEL_48:\n      a2->tm_sec = 0;\n      if ( v26 == 46 )\n      {\n        v18 = strchr(a1, 46);\n        v7 = sscanf(v18 + 1, \"%u%c\", a2, &v26);\nLABEL_14:\n        result = v7 - 1;\n        if ( !result )\n          v26 = 0;\n      }\nLABEL_50:\n      v6 = v26 == 0;\n      goto LABEL_10;\n    }\n    if ( v12 == 4 )\n    {\n      v13 = sscanf(a1, \"%2u%2u%c\", &a2->tm_hour, &a2->tm_min, &v26);\n      v14 = __OFSUB__(v13, 1);\n      result = v13 - 1;\n      v15 = (result < 0) ^ v14 | (result == 0);\n    }\n    else\n    {\n      if ( v12 != 6 )\n      {\n        if ( v12 == 8 )\n        {\n          result = sscanf(a1, \"%2u%2u%2u%2u%c\", &a2->tm_mon, &a2->tm_mday, &a2->tm_hour, &a2->tm_min, &v26);\n          if ( result <= 3 )\n            goto LABEL_11;\n        }\n        else\n        {\n          if ( v12 == 10 )\n          {\n            result = sscanf(\n                       a1,\n                       \"%2u%2u%2u%2u%2u%c\",\n                       &a2->tm_year,\n                       &a2->tm_mon,\n                       &a2->tm_mday,\n                       &a2->tm_hour,\n                       &a2->tm_min,\n                       &v26);\n            if ( result <= 4 )\n              goto LABEL_11;\n            --a2->tm_mon;\n            if ( tm_year > 49 )\n            {\n              v16 = a2->tm_year + 100 * (tm_year / 0x64u);\n              a2->tm_year = v16;\n              if ( v16 < tm_year - 50 )\n                a2->tm_year = v16 + 100;\n              v17 = a2->tm_year;\n              result = tm_year + 50;\n              if ( v17 > tm_year + 50 )\n                a2->tm_year = v17 - 100;\n            }\n            goto LABEL_48;\n          }\n          if ( v12 != 12\n            || (result = sscanf(\n                           a1,\n                           \"%4u%2u%2u%2u%2u%c\",\n                           &a2->tm_year,\n                           &a2->tm_mon,\n                           &a2->tm_mday,\n                           &a2->tm_hour,\n                           &a2->tm_min,\n                           &v26),\n                result <= 4) )\n          {\nLABEL_11:\n            sub_804D5E0(\"invalid date '%s'\", a1);\n          }\n          a2->tm_year -= 1900;\n        }\n        --a2->tm_mon;\n        goto LABEL_48;\n      }\n      result = sscanf(a1, \"%2u%2u%2u%c\", &a2->tm_mday, &a2->tm_hour, &a2->tm_min, &v26);\n      v15 = result <= 2;\n    }\n    if ( !v15 )\n      goto LABEL_48;\n    goto LABEL_11;\n  }\n  p_tm_hour = &a2->tm_hour;\n  v4 = sscanf(a1, \"%u:%u%c\", &a2->tm_hour, &a2->tm_min, &v26);\n  v15 = v4 <= 1;\n  result = v4 - 1;\n  if ( !v15 )\n    goto LABEL_12;\n  p_tm_mon = &a2->tm_mon;\n  result = sscanf(a1, \"%u.%u-%u:%u%c\", &a2->tm_mon, &a2->tm_mday, p_tm_hour, &a2->tm_min, &v26);\n  if ( result > 3 )\n  {\nLABEL_6:\n    --a2->tm_mon;\nLABEL_12:\n    if ( v26 == 58 )\n    {\n      v7 = sscanf(v25 + 1, \"%u%c\", a2, &v26);\n      goto LABEL_14;\n    }\n    goto LABEL_50;\n  }\n  result = sscanf(a1, \"%u.%u.%u-%u:%u%c\", &a2->tm_year, p_tm_mon, &a2->tm_mday, p_tm_hour, &a2->tm_min, &v26);\n  if ( result > 4\n    || (result = sscanf(a1, \"%u-%u-%u %u:%u%c\", &a2->tm_year, p_tm_mon, &a2->tm_mday, p_tm_hour, &a2->tm_min, &v26),\n        result > 4) )\n  {\n    a2->tm_year -= 1900;\n    goto LABEL_6;\n  }\n  result = strptime(a1, \"%b %d %T %Y\", a2);\n  if ( !result )\n    goto LABEL_11;\n  v6 = *(_BYTE *)result == 0;\nLABEL_10:\n  if ( !v6 )\n    goto LABEL_11;\n  return result;\n}\n"
        ],
        "134540132": [
            "sub_804EB64",
            "0x804eb64",
            "time_t __usercall sub_804EB64@<eax>(const char *a1@<eax>, struct tm *a2@<edx>)\n{\n  time_t result; // eax\n\n  result = mktime(a2);\n  if ( result == -1 )\n    sub_804D5E0(\"invalid date '%s'\", a1);\n  return result;\n}\n"
        ],
        "134540160": [
            "sub_804EB80",
            "0x804eb80",
            "char *__usercall sub_804EB80@<eax>(time_t *timer@<ecx>, size_t maxsize@<edx>, char *a3@<eax>, time_t a4@<ebx>)\n{\n  struct tm *v6; // eax\n  time_t v8; // [esp-4h] [ebp-Ch] BYREF\n\n  v8 = a4;\n  if ( !timer )\n  {\n    time(&v8);\n    timer = &v8;\n  }\n  v6 = localtime(timer);\n  return &a3[strftime(a3, maxsize, \"%H:%M:%S\", v6)];\n}\n"
        ],
        "134540207": [
            "sub_804EBAF",
            "0x804ebaf",
            "char *__usercall sub_804EBAF@<eax>(time_t *timer@<ecx>, size_t maxsize@<edx>, char *a3@<eax>, time_t a4@<ebx>)\n{\n  struct tm *v6; // eax\n  time_t v8; // [esp-4h] [ebp-Ch] BYREF\n\n  v8 = a4;\n  if ( !timer )\n  {\n    time(&v8);\n    timer = &v8;\n  }\n  v6 = localtime(timer);\n  return &a3[strftime(a3, maxsize, \"%Y-%m-%d %H:%M:%S\", v6)];\n}\n"
        ],
        "134540254": [
            "sub_804EBDE",
            "0x804ebde",
            "__int64 sub_804EBDE()\n{\n  int v1[5]; // [esp+0h] [ebp-14h] BYREF\n\n  sub_804E7DE((int)v1);\n  return 1000000LL * v1[0] + v1[1] / 1000;\n}\n"
        ],
        "134540308": [
            "sub_804EC14",
            "0x804ec14",
            "__int64 sub_804EC14()\n{\n  int v1[5]; // [esp+0h] [ebp-14h] BYREF\n\n  sub_804E7DE((int)v1);\n  return 1000LL * v1[0] + v1[1] / 1000000;\n}\n"
        ],
        "134540362": [
            "sub_804EC4A",
            "0x804ec4a",
            "int sub_804EC4A()\n{\n  int v1; // [esp+0h] [ebp-8h] BYREF\n\n  sub_804E7DE((int)&v1);\n  return v1;\n}\n"
        ],
        "134540379": [
            "sub_804EC5B",
            "0x804ec5b",
            "__int64 __fastcall sub_804EC5B(char **a1)\n{\n  char v1; // cl\n  __int64 result; // rax\n\n  v1 = **a1;\n  if ( v1 )\n  {\n    if ( (unsigned __int8)(v1 - 48) <= 9u || (unsigned __int8)((v1 | 0x20) - 97) <= 0x19u || *(_DWORD *)dword_80DBB7C )\n    {\n      *(_DWORD *)dword_80DBB7C = 34;\n      return -1LL;\n    }\n    else\n    {\n      *(_DWORD *)dword_80DBB7C = 22;\n    }\n  }\n  return result;\n}\n"
        ],
        "134540446": [
            "sub_804EC9E",
            "0x804ec9e",
            "__int64 __usercall sub_804EC9E@<edx:eax>(const char *a1@<eax>, char **a2@<edx>, int a3@<ecx>)\n{\n  char **p_endptr; // ebx\n  char *endptr; // [esp+4h] [ebp-10h] BYREF\n\n  p_endptr = &endptr;\n  if ( a2 )\n    p_endptr = a2;\n  *p_endptr = (char *)a1;\n  if ( (unsigned __int8)(*a1 - 48) <= 9u || (unsigned __int8)((*a1 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtoull(a1, p_endptr, a3);\n    return sub_804EC5B(p_endptr);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1LL;\n  }\n}\n"
        ],
        "134540545": [
            "sub_804ED01",
            "0x804ed01",
            "__int64 __usercall sub_804ED01@<edx:eax>(char *a1@<eax>, char **a2@<edx>, int a3@<ecx>)\n{\n  char **p_endptr; // ebx\n  char v4; // dl\n  char *endptr; // [esp+4h] [ebp-10h] BYREF\n\n  p_endptr = &endptr;\n  if ( a2 )\n    p_endptr = a2;\n  *p_endptr = a1;\n  v4 = *a1;\n  if ( *a1 == 45 )\n    v4 = a1[1];\n  if ( (unsigned __int8)(v4 - 48) <= 9u || (unsigned __int8)((v4 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtoll(a1, p_endptr, a3);\n    return sub_804EC5B(p_endptr);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1LL;\n  }\n}\n"
        ],
        "134540652": [
            "sub_804ED6C",
            "0x804ed6c",
            "int __usercall sub_804ED6C@<eax>(int base@<ecx>, const char *a2@<eax>, char **a3@<edx>, int a4@<ebx>)\n{\n  char **v4; // esi\n  int v6; // [esp-4h] [ebp-14h] BYREF\n\n  v6 = a4;\n  v4 = (char **)&v6;\n  if ( a3 )\n    v4 = a3;\n  *v4 = (char *)a2;\n  if ( (unsigned __int8)(*a2 - 48) <= 9u || (unsigned __int8)((*a2 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtoul(a2, v4, base);\n    return sub_804EC5B(v4);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1;\n  }\n}\n"
        ],
        "134540741": [
            "sub_804EDC5",
            "0x804edc5",
            "int __usercall sub_804EDC5@<eax>(int base@<ecx>, char *a2@<eax>, char **a3@<edx>, int a4@<ebx>)\n{\n  char **v4; // esi\n  char v5; // bl\n  int v7; // [esp-4h] [ebp-14h] BYREF\n\n  v7 = a4;\n  v4 = (char **)&v7;\n  if ( a3 )\n    v4 = a3;\n  *v4 = a2;\n  v5 = *a2;\n  if ( *a2 == 45 )\n    v5 = a2[1];\n  if ( (unsigned __int8)(v5 - 48) <= 9u || (unsigned __int8)((v5 | 0x20) - 97) <= 0x19u )\n  {\n    *(_DWORD *)dword_80DBB7C = 0;\n    strtol(a2, v4, base);\n    return sub_804EC5B(v4);\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 34;\n    return -1;\n  }\n}\n"
        ],
        "134540837": [
            "sub_804EE25",
            "0x804ee25",
            "int __cdecl sub_804EE25(int a1, int a2)\n{\n  const char **v2; // esi\n  int v3; // ebx\n  const char *v4; // edi\n  int v5; // esi\n  const char *v7; // [esp-4h] [ebp-14h]\n  char *v8; // [esp+0h] [ebp-10h] BYREF\n\n  v8 = \"0\";\n  if ( geteuid() )\n    sub_804D5E0(\"permission denied (are you root?)\");\n  sub_80ABEC2(a2, \"^g:S\", \"gid\", (char)&v8);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = sub_80B40CC(60000, 0);\n  v4 = *v2;\n  if ( getgrnam(*v2) )\n    sub_804D5E0(\"%s '%s' in use\", \"group\", v4);\n  v5 = 60000;\n  if ( (dword_80DBB9C & 1) == 0 )\n  {\n    v3 = (dword_80DBB9C & 2) == 0 ? 1000 : 100;\n    v5 = (dword_80DBB9C & 2) == 0 ? 60000 : 999;\n  }\n  while ( getgrgid(v3) )\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n    {\n      v7 = sub_804D70F(v3);\n      sub_804D5E0(\"%s '%s' in use\", \"gid\", v7);\n    }\n    if ( v3 == v5 )\n      sub_804D5E0(\"no %cids left\", 103);\n    ++v3;\n  }\n  sub_804DDBF(\"x:%u:\", v3);\n  if ( ((int (*)(void))sub_80B33A5)() < 0 )\n    exit(1);\n  sub_80B33A5(\"!::\", v4);\n  return 0;\n}\n"
        ],
        "134541109": [
            "sub_804EF35",
            "0x804ef35",
            "int __usercall sub_804EF35@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  const char *v4; // [esp+0h] [ebp-1Ch]\n  const char *v5; // [esp+4h] [ebp-18h]\n  _BYTE *v6; // [esp+8h] [ebp-14h]\n  const char *v7; // [esp+Ch] [ebp-10h]\n  _BYTE *v8; // [esp+10h] [ebp-Ch]\n  int v9; // [esp+14h] [ebp-8h]\n\n  v4 = \"addgroup\";\n  if ( a2 )\n  {\n    v5 = \"--\";\n    v6 = *(_BYTE **)a1;\n    v7 = a2;\n    v8 = 0;\n  }\n  else\n  {\n    v5 = \"--gid\";\n    v6 = sub_804D6F7(*(_DWORD *)(a1 + 12));\n    v7 = \"--\";\n    v8 = *(_BYTE **)a1;\n    v9 = 0;\n  }\n  return sub_80B3C03(v4, v5, v6, v7, v8, v9);\n}\n"
        ],
        "134541208": [
            "sub_804EF98",
            "0x804ef98",
            "int __cdecl sub_804EF98(int a1, int a2)\n{\n  int v2; // ebx\n  const char **v3; // edx\n  const char *v4; // eax\n  const char *v5; // edx\n  __gid_t v7; // edx\n  int v8; // esi\n  char *v9; // eax\n  unsigned int v10; // eax\n  char *v11; // eax\n  const char *v12; // [esp-4h] [ebp-48h]\n  const char *v13; // [esp+0h] [ebp-44h] BYREF\n  int v14; // [esp+4h] [ebp-40h] BYREF\n  const char *v15; // [esp+8h] [ebp-3Ch] BYREF\n  int v16[5]; // [esp+Ch] [ebp-38h] BYREF\n  char *name[2]; // [esp+20h] [ebp-24h] BYREF\n  __uid_t uid; // [esp+28h] [ebp-1Ch]\n  __gid_t group; // [esp+2Ch] [ebp-18h]\n  const char *v20; // [esp+30h] [ebp-14h] BYREF\n  char *path; // [esp+34h] [ebp-10h] BYREF\n  const char *v22; // [esp+38h] [ebp-Ch] BYREF\n\n  v13 = 0;\n  v15 = \"/etc/skel\";\n  if ( geteuid() )\n    sub_804D5E0(\"permission denied (are you root?)\");\n  v20 = \"Linux User,,,\";\n  v22 = (const char *)sub_80AB879();\n  path = 0;\n  v2 = sub_80ABEC2(a2, \"^h:g:s:G:DSHu:k:\", \"home\", &path, &v20, &v22, &v13, &v14, &v15);\n  if ( (v2 & 0x80u) != 0 )\n    uid = sub_80B40CC(60000, 0);\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = *v3;\n  name[0] = (char *)*v3;\n  if ( !v2 )\n  {\n    v5 = v3[1];\n    if ( v5 )\n      return sub_804EF35((int)name, v5);\n  }\n  if ( !path )\n    path = sub_804DDBF(\"/home/%s\", v4);\n  name[1] = \"x\";\n  if ( (v2 & 0x20) != 0 )\n  {\n    if ( !v13 )\n      v13 = \"nogroup\";\n    if ( (v2 & 4) == 0 )\n      v22 = \"/bin/false\";\n  }\n  v7 = -1;\n  if ( v13 )\n    v7 = sub_80A9A4C();\n  group = v7;\n  if ( getpwnam(name[0]) )\n    sub_804D5E0(\"%s '%s' in use\", \"user\", name[0]);\n  v8 = 60000;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    if ( (dword_80DBB9C & 0x20) != 0 )\n    {\n      uid = 100;\n      v8 = 999;\n    }\n    else\n    {\n      uid = 1000;\n    }\n  }\n  while ( getpwuid(uid) || group == -1 && getgrgid(uid) )\n  {\n    if ( (dword_80DBB9C & 0x80u) != 0 )\n    {\n      v12 = sub_804D70F(uid);\n      sub_804D5E0(\"%s '%s' in use\", \"uid\", v12);\n    }\n    if ( v8 == uid )\n      sub_804D5E0(\"no %cids left\", 117);\n    ++uid;\n  }\n  if ( group == -1 )\n  {\n    group = uid;\n    if ( getgrnam(name[0]) )\n      sub_804D5E0(\"%s '%s' in use\", \"group\", name[0]);\n  }\n  v9 = sub_804DDBF(\"x:%u:%u:%s:%s:%s\", uid, group, v20, path, v22);\n  if ( sub_80B33A5(v9, name[0]) < 0 )\n    return 1;\n  v10 = time(0);\n  v11 = sub_804DDBF(\"!:%u:0:99999:7:::\", v10 / 0x15180);\n  sub_80B33A5(v11, name[0]);\n  sub_804EF35((int)name, v13);\n  umask(0);\n  if ( (v2 & 0x40) == 0 )\n  {\n    if ( mkdir(path, 0x1EDu) )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 17 )\n      {\nLABEL_43:\n        sub_804D3F1(path);\n        goto LABEL_45;\n      }\n    }\n    else\n    {\n      v16[0] = (int)\"chown\";\n      v16[1] = (int)\"-R\";\n      v16[2] = (int)sub_804DDBF(\"%u:%u\", uid, group);\n      v16[3] = (int)path;\n      v16[4] = 0;\n      if ( (v2 & 0x100) == 0 )\n        byte_80DB561 = 0;\n      sub_80A9C77(4);\n      byte_80DB561 = 1;\n      sub_80900EA(4, v16);\n    }\n    if ( !chown(path, uid, group) && !chmod(path, 0x5EDu) )\n      goto LABEL_45;\n    goto LABEL_43;\n  }\nLABEL_45:\n  if ( (v2 & 0x10) == 0 )\n  {\n    execlp(\"passwd\", \"passwd\", \"--\", name[0], 0);\n    sub_804D5E0(\"can't execute passwd, you must set password manually\");\n  }\n  return 0;\n}\n"
        ],
        "134542064": [
            "sub_804F2F0",
            "0x804f2f0",
            "int __cdecl sub_804F2F0(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  int v3; // eax\n  const char *v4; // eax\n  void *v6; // [esp+0h] [ebp-38h] BYREF\n  int v7; // [esp+4h] [ebp-34h] BYREF\n  int v8; // [esp+8h] [ebp-30h] BYREF\n  char v9[42]; // [esp+Eh] [ebp-2Ah] BYREF\n\n  v8 = 0;\n  v6 = &unk_80C8018;\n  v7 = 0;\n  sub_80ABEC2(a2, \"^sP:+S:m:a:\", \"stdin\", &v8, &v7, &v6, &v6);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( *v2 && !v7 )\n    v7 = v2[1];\n  sub_80B1D29();\n  if ( v7 )\n    sub_80B2C4E(35);\n  sub_804DC97(v8, 0);\n  if ( *v2 || (*ident != 109 || !isatty(0) ? (v3 = sub_80AB85A()) : (v3 = sub_80A9888()), v3) )\n  {\n    v4 = (const char *)sub_80B1D56(1, v9);\n    puts(v4);\n  }\n  return 0;\n}\n"
        ],
        "134542278": [
            "sub_804F3C6",
            "0x804f3c6",
            "int __usercall sub_804F3C6@<eax>(int a1@<ebx>, int a2, int a3)\n{\n  int v3; // ebp\n  int v4; // esi\n  char v5; // bl\n  int v6; // edi\n  const char *v7; // esi\n  struct group *v8; // edx\n  int v9; // edi\n  struct passwd *v10; // eax\n  const char *v11; // ebp\n  struct group *v14; // [esp+0h] [ebp-14h]\n\n  v3 = a2;\n  v4 = a3;\n  v5 = ident[3];\n  v6 = 0;\n  if ( v5 == 117 )\n  {\n    v6 = sub_80ABEC2(a3, &data, \"remove-home\");\n    v4 = a3 + 4 * v6;\n    v3 = a2 - v6;\n  }\n  if ( geteuid() )\n    sub_804D5E0(\"permission denied (are you root?)\");\n  v7 = *(const char **)(v4 + 4);\n  if ( v3 != 2 )\n    sub_804CDC2(a1);\n  if ( v5 != 117 )\n  {\n    v8 = (struct group *)sub_80A99B7();\n    v9 = 0;\n    goto LABEL_13;\n  }\n  sub_80A999C();\n  if ( v6 )\n    sub_80B2709();\n  v9 = 1;\n  v11 = \"/etc/shadow\";\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      if ( sub_80B33A5(0, v7) == -1 )\n        return 1;\n      if ( !v11 )\n        break;\n      v11 = 0;\n    }\n    if ( v9 != 1 )\n      return 0;\n    if ( sub_80B33A5(0, 0) == -1 )\n      return 1;\n    v8 = getgrnam(v7);\n    v9 = -1;\n    if ( !v8 )\n      break;\nLABEL_13:\n    while ( 1 )\n    {\n      v14 = v8;\n      v10 = getpwent();\n      v11 = \"/etc/gshadow\";\n      v8 = v14;\n      if ( !v10 )\n        break;\n      if ( v10->pw_gid == v14->gr_gid )\n        sub_804D5E0(\"'%s' still has '%s' as their primary group!\", v10->pw_name, v7);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134542550": [
            "sub_804F4D6",
            "0x804f4d6",
            "int sub_804F4D6()\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  sleep(0xAu);\n  return v1;\n}\n"
        ],
        "134542559": [
            "sub_804F4DF",
            "0x804f4df",
            "int __usercall sub_804F4DF@<eax>(const char *a1@<eax>, int a2@<ebx>)\n{\n  int result; // eax\n\n  result = sub_804ED6C(10, a1, 0, a2);\n  if ( result >= 0 )\n    return sub_80B2EFA();\n  return result;\n}\n"
        ],
        "134542581": [
            "sub_804F4F5",
            "0x804f4f5",
            "int sub_804F4F5()\n{\n  int result; // eax\n\n  result = sub_804D995((const struct termios *)(dword_80DBB80 + 72));\n  if ( result < 0 )\n    sub_804D3C9((int)\"tcsetattr\");\n  return result;\n}\n"
        ],
        "134542609": [
            "sub_804F511",
            "0x804f511",
            "int sub_804F511()\n{\n  int v0; // eax\n  int v1; // edx\n  int v2; // ecx\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 72);\n  v2 = v1;\n  BYTE1(v2) = BYTE1(v1) | 0x14;\n  *(_DWORD *)(dword_80DBB80 + 72) = v2;\n  if ( *(_BYTE *)(v0 + 68) == 13 )\n  {\n    BYTE1(v1) |= 0x15u;\n    *(_DWORD *)(v0 + 72) = v1;\n  }\n  *(_DWORD *)(v0 + 84) |= 0xA3Bu;\n  *(_WORD *)(v0 + 89) = 7171;\n  *(_BYTE *)(v0 + 100) = 10;\n  *(_BYTE *)(v0 + 96) = 0;\n  *(_WORD *)(v0 + 92) = 1045;\n  sub_804F4F5();\n  return sub_804E586(1u, (char *)\"\\n\");\n}\n"
        ],
        "134542689": [
            "handler",
            "0x804f561",
            "void __cdecl __noreturn handler(int a1)\n{\n  sub_804F511();\n  _exit(0);\n}\n"
        ],
        "134542701": [
            "sub_804F56D",
            "0x804f56d",
            "void __cdecl __noreturn sub_804F56D(int a1, int a2)\n{\n  char *v2; // ebx\n  int v3; // esi\n  char *v4; // edx\n  char *v5; // eax\n  char *v6; // edi\n  int v7; // ebp\n  int v8; // eax\n  int v9; // eax\n  const char *v10; // edx\n  int v11; // esi\n  __pid_t v12; // ebp\n  int v13; // ebp\n  int v14; // ebp\n  int v15; // eax\n  char v16; // al\n  char *v17; // eax\n  const char *v18; // eax\n  int v19; // eax\n  speed_t v20; // esi\n  int v21; // eax\n  char v22; // dl\n  const char *v23; // esi\n  ssize_t v24; // eax\n  const char *v25; // eax\n  int v26; // eax\n  bool i; // zf\n  unsigned __int8 *v28; // esi\n  int v29; // ecx\n  __sighandler_t handler; // [esp+0h] [ebp-20h]\n  int handlera; // [esp+0h] [ebp-20h]\n  unsigned __int8 buf; // [esp+Bh] [ebp-15h] BYREF\n  char *stringp; // [esp+Ch] [ebp-14h] BYREF\n\n  v2 = (char *)sub_804DB2E(0x104u);\n  dword_80DBB80 = (int)v2;\n  *((_DWORD *)v2 + 1) = \"/bin/login\";\n  *((_DWORD *)v2 + 5) = \"/etc/issue\";\n  v2[68] = 13;\n  if ( (sub_80ABEAC(a2, \"^I:LH:f:hil:mt:+wn\", v2 + 16, v2 + 8, v2 + 20, v2 + 4, v2) & 1) != 0 )\n  {\n    *((_DWORD *)v2 + 4) = sub_804DB46(*((const char **)v2 + 4));\n    sub_80B0D53();\n  }\n  v3 = a2 + 4 * optind;\n  v4 = *(char **)v3;\n  *((_DWORD *)v2 + 3) = *(_DWORD *)v3;\n  v5 = *(char **)(v3 + 4);\n  if ( (unsigned __int8)(*v4 - 48) <= 9u )\n  {\n    *((_DWORD *)v2 + 3) = v5;\n    v5 = v4;\n  }\n  stringp = v5;\n  while ( 1 )\n  {\n    v6 = strsep(&stringp, \",\");\n    if ( !v6 )\n      break;\n    v7 = *((_DWORD *)v2 + 6);\n    *(_DWORD *)&v2[4 * v7 + 28] = sub_804F4DF(v6, (int)v2);\n    v8 = *((_DWORD *)v2 + 6);\n    if ( *(int *)&v2[4 * v8 + 28] < 0 )\n      sub_804D5E0(\"bad speed: %s\", v6);\n    v9 = v8 + 1;\n    *((_DWORD *)v2 + 6) = v9;\n    if ( v9 > 10 )\n      sub_804D5E0(\"too many alternate speeds\");\n  }\n  v10 = *(const char **)(v3 + 8);\n  if ( v10 )\n    sub_804DDE4(\"TERM\", v10);\n  v11 = setsid();\n  if ( v11 < 0 )\n  {\n    v12 = getpid();\n    v11 = getsid(0);\n    if ( v11 != v12 )\n      sub_804D3C9((int)\"setsid\");\n    v13 = open64(\"/dev/tty\");\n    if ( v13 >= 0 )\n    {\n      handler = signal(1, (__sighandler_t)1);\n      ioctl(v13, 0x5422u);\n      close(v13);\n      signal(1, handler);\n    }\n  }\n  v14 = sub_804DBE1(\"/dev/null\");\n  sub_804DC7B(v14, 1);\n  sub_804DC7B(v14, 2);\n  while ( v14 > 2 )\n  {\n    handler = (__sighandler_t)(v14 - 1);\n    close(v14--);\n  }\n  dword_80DBB84 = sub_804F4D6;\n  off_80DB54C = (char *)\"\\r\\n\";\n  openlog(ident, 1, 32);\n  byte_80DB561 = 3;\n  v15 = *((_DWORD *)v2 + 3);\n  if ( *(_BYTE *)v15 == 45 )\n  {\n    if ( !*(_BYTE *)(v15 + 1) )\n    {\n      v16 = fcntl64(0, 3);\n      if ( (v16 & 3) != 2 )\n        sub_804D5E0(\"stdin is not open for read/write\", handler);\n      v17 = sub_804E0D9(0);\n      if ( v17 )\n        *((_DWORD *)v2 + 3) = v17;\n      goto LABEL_31;\n    }\n  }\n  else if ( *(_BYTE *)v15 == 47 )\n  {\nLABEL_26:\n    close(0);\n    sub_804DBE1(*((const char **)v2 + 3));\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\nLABEL_31:\n    v18 = (const char *)sub_80B2EB2();\n    ident = sub_804DDBF(\"getty: %s\", v18);\n    sub_804D646(0);\n    sub_804DC7B(0, 1);\n    sub_804DC7B(0, 2);\n    v19 = tcgetsid(0);\n    if ( (v11 != v19 || v19 < 0) && ioctl(0, 0x540Eu, 1) < 0 )\n      sub_804D3C9((int)\"TIOCSCTTY\", handler);\n    if ( tcsetpgrp(0, v11) < 0 )\n      sub_804D3C9((int)\"tcsetpgrp\", handler);\n    if ( tcgetattr(0, (struct termios *)(v2 + 72)) < 0 )\n      sub_804D3C9((int)\"tcgetattr\", handler);\n    sub_80B3832(\"LOGIN\", *((_DWORD *)v2 + 2));\n    v20 = *((_DWORD *)v2 + 7);\n    sub_804E7B4(14, (int)sub_804E68E);\n    alarm(5u);\n    tcdrain(0);\n    alarm(0);\n    tcflush(0, 2);\n    if ( v20 )\n      cfsetspeed((struct termios *)(v2 + 72), v20);\n    v21 = *((_DWORD *)v2 + 20) & 0x500F134F;\n    *((_DWORD *)v2 + 20) = v21 | 0x4B0;\n    v22 = dword_80DBB9C;\n    if ( (dword_80DBB9C & 2) != 0 )\n      *((_DWORD *)v2 + 20) = v21 | 0xCB0;\n    if ( (v22 & 0x10) != 0 )\n      *((_DWORD *)v2 + 20) |= 0x80000000;\n    *((_DWORD *)v2 + 18) = 0;\n    *((_DWORD *)v2 + 21) = 0;\n    *((_DWORD *)v2 + 19) = 5;\n    *((_WORD *)v2 + 47) = 256;\n    v2[88] = 0;\n    sub_804F4F5();\n    if ( (dword_80DBB9C & 1) != 0 )\n      sub_804D846(*((char **)v2 + 4));\n    if ( (dword_80DBB9C & 0x80u) != 0 )\n    {\n      v2[95] = 0;\n      sub_804F4F5();\n      sleep(1u);\n      v23 = v2 + 132;\n      v24 = sub_804E5BC(0x7Fu, v2 + 132, 0);\n      if ( v24 > 0 )\n      {\n        v2[v24 + 132] = 0;\n        v25 = &v23[v24];\n        while ( 1 )\n        {\n          if ( v23 >= v25 )\n            goto LABEL_55;\n          if ( (unsigned __int8)(*v23 - 48) <= 9u )\n            break;\n          ++v23;\n        }\n        v26 = sub_804F4DF(v23, (int)v2);\n        if ( v26 > 0 )\n          cfsetspeed((struct termios *)(v2 + 72), v26);\n      }\nLABEL_55:\n      v2[95] = 1;\n      sub_804F4F5();\n    }\n    signal(14, (__sighandler_t)::handler);\n    alarm(*(_DWORD *)v2);\n    for ( i = (dword_80DBB9C & 0x200) == 0; !i && sub_804E5BC(1u, &buf, 0) == 1 && buf != 10; i = buf == 13 )\n      ;\n    if ( (dword_80DBB9C & 0x400) != 0 )\n    {\nLABEL_94:\n      alarm(0);\n      sub_804F511();\n      execlp(*((const char **)v2 + 1), *((const char **)v2 + 1), \"--\", v6, 0);\n      sub_804D5E0(\"can't execute '%s'\", *((const char **)v2 + 1));\n    }\n    handlera = 0;\nLABEL_63:\n    usleep(0x186A0u);\n    tcflush(0, 0);\nLABEL_64:\n    if ( (dword_80DBB9C & 0x20) == 0 )\n      sub_80AFB8C();\n    sub_80AFD20();\n    v6 = v2 + 132;\n    v28 = (unsigned __int8 *)(v2 + 132);\n    while ( 1 )\n    {\n      *(_DWORD *)dword_80DBB7C = 4;\n      if ( read(0, &buf, 1u) <= 0 )\n      {\n        sub_804F511();\n        if ( (unsigned int)(*(_DWORD *)dword_80DBB7C - 4) > 1 )\n          sub_804D3C9((int)\"read error\", handlera);\nLABEL_88:\n        exit(0);\n      }\n      if ( buf == 8 )\n        goto LABEL_84;\n      if ( buf > 8u )\n      {\n        if ( buf == 13 )\n          goto LABEL_82;\n        if ( buf <= 0xDu )\n        {\n          if ( buf == 10 )\n          {\nLABEL_82:\n            *v28 = 0;\n            v2[68] = buf;\n            if ( v2[132] )\n              goto LABEL_94;\n            goto LABEL_64;\n          }\n          goto LABEL_91;\n        }\n        if ( buf == 21 )\n        {\n          while ( v6 < (char *)v28 )\n          {\n            sub_804E586(3u, \"\\b \\b\");\n            --v28;\n          }\n        }\n        else\n        {\n          if ( buf != 127 )\n            goto LABEL_91;\nLABEL_84:\n          v2[91] = buf;\n          if ( v6 < (char *)v28 )\n          {\n            sub_804E586(3u, \"\\b \\b\");\n            --v28;\n          }\n        }\n      }\n      else if ( buf )\n      {\n        if ( (unsigned __int8)(buf - 3) <= 1u )\n        {\n          sub_804F511();\n          goto LABEL_88;\n        }\nLABEL_91:\n        if ( buf > 0x1Fu && (unsigned int)(v28 - (unsigned __int8 *)v6) <= 0x7E )\n        {\n          sub_804E586(1u, (char *)&buf);\n          *v28++ = buf;\n        }\n      }\n      else\n      {\n        v29 = *((_DWORD *)v2 + 6);\n        if ( v29 > 1 )\n        {\n          handlera = (handlera + 1) % v29;\n          cfsetspeed((struct termios *)(v2 + 72), *(_DWORD *)&v2[4 * handlera + 28]);\n          sub_804F4F5();\n          goto LABEL_63;\n        }\n      }\n    }\n  }\n  *((_DWORD *)v2 + 3) = sub_804DDBF(\"/dev/%s\", (const char *)v15);\n  goto LABEL_26;\n}\n"
        ],
        "134544238": [
            "sub_804FB6E",
            "0x804fb6e",
            "void __cdecl __noreturn sub_804FB6E(int a1)\n{\n  sub_804D61C(1);\n  sub_804D995((const struct termios *)&buf);\n  printf(\"\\r\\nLogin timed out after %u seconds\\r\\n\", 60);\n  sub_804DD8F();\n  sub_804D646(1);\n  _exit(0);\n}\n"
        ],
        "134544292": [
            "sub_804FBA4",
            "0x804fba4",
            "int __cdecl sub_804FBA4(int a1, int a2)\n{\n  const char *v2; // edi\n  int v3; // esi\n  int v4; // ebx\n  unsigned __int8 *v5; // edx\n  int v6; // eax\n  char *v7; // ebx\n  struct passwd *v8; // eax\n  struct passwd *v9; // ebx\n  char v10; // al\n  FILE *v11; // esi\n  int i; // edi\n  char *IO_write_base; // eax\n  int v14; // ebx\n  const char *v15; // esi\n  int v16; // esi\n  int v18; // [esp-8h] [ebp-6Ch]\n  int v19; // [esp-4h] [ebp-68h]\n  char v20; // [esp+0h] [ebp-64h]\n  char *v21; // [esp+4h] [ebp-60h]\n  int v22; // [esp+8h] [ebp-5Ch]\n  const char *v23; // [esp+Ch] [ebp-58h] BYREF\n  int v24; // [esp+10h] [ebp-54h] BYREF\n  char name; // [esp+14h] [ebp-50h] BYREF\n  char s[79]; // [esp+15h] [ebp-4Fh] BYREF\n\n  v23 = 0;\n  v22 = sub_80AFD54();\n  sub_80B3C0D();\n  name = 0;\n  v20 = sub_80ABEAC(a2, \"f:h:p\", &v24, &v23);\n  if ( (v20 & 1) != 0 )\n  {\n    if ( v22 )\n      sub_804D5E0(\"-f is for root only\");\n    sub_80B2C4E(64);\n  }\n  if ( *(_DWORD *)(a2 + 4 * optind) )\n    sub_80B2C4E(64);\n  if ( tcgetattr(0, (struct termios *)&buf) >= 0 && isatty(1) )\n  {\n    signal(14, (__sighandler_t)sub_804FB6E);\n    alarm(0x3Cu);\n    if ( !sub_804E0D9(0) )\n      sub_804DB46(\"UNKNOWN\");\n    v2 = (const char *)sub_80B2EB2();\n    if ( v23 )\n      v21 = sub_804DDBF(\" on '%s' from '%s'\", v2, v23);\n    else\n      v21 = sub_804DDBF(\" on '%s'\", v2);\n    openlog(ident, 3, 32);\n    v3 = 3;\n    while ( 1 )\n    {\n      tcflush(0, 0);\n      if ( name )\n        goto LABEL_32;\n      v4 = 10;\n      while ( 1 )\n      {\n        sub_80AFD20();\nLABEL_18:\n        v5 = *(unsigned __int8 **)(_stdin + 16);\n        if ( (unsigned int)v5 >= *(_DWORD *)(_stdin + 24) )\n        {\n          v6 = __fgetc_unlocked(_stdin);\n          if ( v6 == -1 )\n            goto LABEL_21;\n        }\n        else\n        {\n          *(_DWORD *)(_stdin + 16) = v5 + 1;\n          v6 = *v5;\n        }\n        if ( v6 != 10 )\n          break;\n        if ( !--v4 )\n          goto LABEL_21;\n      }\n      if ( (unsigned __int8)(v6 - 9) <= 4u || (_BYTE)v6 == 32 )\n        goto LABEL_18;\n      name = v6;\n      v7 = s;\n      if ( !fgets_unlocked(s, 62, stdin) || !strchr(s, 10) )\nLABEL_21:\n        exit(1);\n      while ( (unsigned __int8)*v7 > 0x20u )\n        ++v7;\n      *v7 = 0;\nLABEL_32:\n      v8 = getpwnam(&name);\n      v9 = v8;\n      if ( !v8 )\n      {\n        strcpy(&name, \"UNKNOWN\");\n        goto LABEL_44;\n      }\n      v10 = *v8->pw_passwd;\n      if ( v10 != 33 && v10 != 42 )\n      {\n        if ( (v20 & 1) == 0 )\n        {\n          if ( !v9->pw_uid && !sub_80B2C7E() )\n            goto LABEL_36;\n          if ( *v9->pw_passwd )\n          {\nLABEL_44:\n            if ( sub_80AA371() <= 0 )\n              goto LABEL_36;\n          }\n        }\n        alarm(0);\n        if ( v9->pw_uid )\n        {\n          v11 = (FILE *)sub_80B3D37();\n          if ( v11 )\n          {\n            for ( i = 1; ; i = 0 )\n            {\n              IO_write_base = v11->_IO_write_base;\n              if ( IO_write_base >= v11->_IO_write_end )\n              {\n                v14 = __fgetc_unlocked(v11);\n                if ( v14 == -1 )\n                {\n                  if ( i )\n                    puts(\"\\r\\nSystem closed for routine maintenance\\r\");\n                  fclose(v11);\n                  sub_804DD8F();\n                  tcdrain(1);\n                  exit(1);\n                }\n              }\n              else\n              {\n                v11->_IO_write_base = IO_write_base + 1;\n                v14 = (unsigned __int8)*IO_write_base;\n              }\n              if ( v14 == 10 )\n                sub_804DD98(13);\n              sub_804DD98(v14);\n            }\n          }\n        }\n        fchown(0, v9->pw_uid, v9->pw_gid);\n        fchmod(0, 0x180u);\n        v15 = 0;\n        if ( !v22 )\n          v15 = v23;\n        getpid();\n        sub_80B3832(&name, v15);\n        sub_80A9B93();\n        sub_80B2CE1(v9, (v20 & 4) == 0 ? 3 : 1);\n        if ( access(\".hushlogin\", 0) )\n        {\n          v16 = open64(\"/etc/motd\");\n          if ( v16 >= 0 )\n          {\n            sub_804DD8F();\n            sub_804E572(v16, 1);\n            close(v16);\n          }\n        }\n        if ( !v9->pw_uid )\n          syslog(6, \"root login%s\", v21);\n        signal(2, 0);\n        sub_80B2B50(0, 1, v18, v19);\n      }\nLABEL_36:\n      v20 &= ~1u;\n      sub_80A98F4();\n      puts(\"Login incorrect\");\n      if ( !--v3 )\n      {\n        syslog(4, \"invalid password for '%s'%s\", &name, v21);\n        return 1;\n      }\n      name = 0;\n    }\n  }\n  return 1;\n}\n"
        ],
        "134545245": [
            "sub_804FF5D",
            "0x804ff5d",
            "int __cdecl sub_804FF5D(int a1, int a2)\n{\n  const char **v2; // ebx\n  __uid_t v3; // edi\n  const char *v4; // eax\n  char *v5; // eax\n  const char *v6; // esi\n  int v7; // eax\n  const char **v8; // ebx\n  struct spwd *v9; // ebp\n  const char *v10; // eax\n  const char *v11; // eax\n  int v12; // eax\n  const char *v13; // ebp\n  const char *v14; // eax\n  char *v15; // ebx\n  const char *v16; // eax\n  int v17; // eax\n  const char *v18; // eax\n  int v20; // [esp-4h] [ebp-164h]\n  char v21; // [esp+4h] [ebp-15Ch]\n  const char *v22; // [esp+8h] [ebp-158h]\n  void *v23; // [esp+10h] [ebp-150h]\n  void *v24; // [esp+14h] [ebp-14Ch] BYREF\n  struct spwd *result[5]; // [esp+18h] [ebp-148h] BYREF\n  struct spwd result_buf; // [esp+2Ch] [ebp-134h] BYREF\n  char buffer[272]; // [esp+50h] [ebp-110h] BYREF\n\n  v24 = &unk_80C8018;\n  byte_80DB561 = 3;\n  openlog(ident, 0, 32);\n  v21 = sub_80ABEAC(a2, \"a:lud\", &v24);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = getuid();\n  if ( (v21 & 0xE) != 0 && (v3 || !*v2) )\n    sub_804CDC2(v21 & 0xE);\n  v4 = (const char *)sub_80A99ED();\n  v5 = sub_804DB46(v4);\n  v22 = v5;\n  v6 = *v2;\n  if ( !*v2 )\n    v6 = v5;\n  v7 = sub_80A999C();\n  v8 = (const char **)v7;\n  if ( v3 && *(_DWORD *)(v7 + 8) != v3 )\n    sub_804D5E0(\"%s can't change password for %s\", v22, v6);\n  result[0] = 0;\n  *(_DWORD *)dword_80DBB7C = 0;\n  if ( !getspnam_r(*(const char **)v7, &result_buf, buffer, 0x100u, result)\n    && (v9 = result[0]) != 0\n    && !strcmp(result[0]->sp_namp, *v8) )\n  {\n    v8[1] = v9->sp_pwdp;\n  }\n  else if ( *(_DWORD *)dword_80DBB7C != 2 )\n  {\n    sub_804D3A5((int)\"no record of %s in %s, using %s\", v6, \"/etc/shadow\", \"/etc/passwd\");\n  }\n  v10 = v8[1];\n  if ( (v21 & 0xE) == 0 )\n  {\n    if ( *v10 == 33 && v3 )\n      sub_804D5E0(\"can't change locked password for %s\", v6);\n    printf(\"Changing password for %s\\n\", v6);\n    v23 = v24;\n    if ( v3 && *v8[1] )\n    {\n      if ( !sub_80A9888() )\n      {\nLABEL_32:\n        v15 = 0;\nLABEL_34:\n        sub_80B030A();\n        sub_80B030A();\n        sub_80B030A();\n        if ( !v15 )\n        {\n          byte_80DB561 = 1;\n          sub_804D5E0(\"password for %s is unchanged\", v6);\n        }\n        goto LABEL_46;\n      }\n      v11 = (const char *)sub_80B1D56(1, v8[1]);\n      if ( strcmp(v11, v8[1]) )\n      {\n        syslog(4, \"incorrect password for %s\", *v8);\n        sub_80A98F4();\n        puts(\"Incorrect password\");\n        goto LABEL_32;\n      }\n    }\n    v12 = sub_80A9888();\n    v13 = (const char *)v12;\n    if ( !v12 || sub_80B03AD(v8, v12) && v3 )\n    {\n      v15 = 0;\n    }\n    else\n    {\n      v14 = (const char *)sub_80A9888();\n      v15 = 0;\n      if ( v14 )\n      {\n        if ( !strcmp(v14, v13) )\n        {\n          sub_80B1D29(v20, v23);\n          v15 = (char *)sub_80B1D56(1, result);\n        }\n        else\n        {\n          puts(\"Passwords don't match\");\n        }\n      }\n    }\n    goto LABEL_34;\n  }\n  if ( (v21 & 2) != 0 )\n  {\n    if ( *v10 == 33 )\n      goto LABEL_38;\n    v15 = sub_804DDBF(\"!%s\", v10);\n  }\n  else if ( (v21 & 4) != 0 )\n  {\n    if ( *v10 != 33 )\n      goto LABEL_38;\n    v15 = sub_804DB46(v10 + 1);\n  }\n  else\n  {\n    v15 = 0;\n    if ( (v21 & 8) != 0 )\n      v15 = (char *)&data;\n  }\nLABEL_46:\n  result[2] = (struct spwd *)15360000;\n  result[3] = 0;\n  result[0] = (struct spwd *)15360000;\n  result[1] = 0;\n  setrlimit64(1, result);\n  sub_804E6C8(14, (void (*)(int))1);\n  umask(0x3Fu);\n  sub_804DE74(0);\n  v17 = sub_80B33A5(v15, v6);\n  if ( v17 > 0 )\n  {\n    v15 = \"x\";\n  }\n  else if ( v17 )\n  {\n    v18 = \"/etc/shadow\";\nLABEL_53:\n    sub_804D5E0(\"can't update password file %s\", v18);\n  }\n  if ( sub_80B33A5(v15, v6) < 0 )\n  {\n    v18 = \"/etc/passwd\";\n    goto LABEL_53;\n  }\n  sub_804D5F4(\"password for %s changed by %s\", v6, v22);\n  if ( !v15 )\n  {\nLABEL_38:\n    v16 = \"un\";\n    if ( (v21 & 4) == 0 )\n      v16 = &data;\n    sub_804D5E0(\"password for %s is already %slocked\", v6, v16);\n  }\n  return 0;\n}\n"
        ],
        "134546164": [
            "sub_80502F4",
            "0x80502f4",
            "void __cdecl __noreturn sub_80502F4(int a1, int a2)\n{\n  __uid_t v2; // ebp\n  const char **v3; // ebx\n  const char *v4; // eax\n  const char *v5; // edi\n  int v6; // eax\n  char *v7; // edx\n  struct passwd *v8; // eax\n  int v9; // esi\n  const char *v10; // edx\n  int v11; // eax\n  const char *v12; // ebp\n  bool i; // zf\n  char *v14; // eax\n  int v15; // [esp+0h] [ebp-64h]\n  const char *v16; // [esp+4h] [ebp-60h]\n  const char *v17; // [esp+8h] [ebp-5Ch]\n  char *v18; // [esp+Ch] [ebp-58h] BYREF\n  const char *v19; // [esp+10h] [ebp-54h] BYREF\n  char name[80]; // [esp+14h] [ebp-50h] BYREF\n\n  v18 = 0;\n  v19 = 0;\n  v2 = getuid();\n  v15 = sub_80ABEAC(a2, \"mplc:s:\", &v19, &v18);\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = *v3;\n  if ( *v3 && *v4 == 45 && !v4[1] )\n  {\n    v15 |= 4u;\n    ++v3;\n  }\n  v5 = *v3;\n  if ( *v3 )\n    ++v3;\n  else\n    v5 = \"root\";\n  sub_804E0D9(0);\n  v16 = (const char *)sub_80B2EB2();\n  v6 = getlogin_r(name, 0x40u);\n  v7 = name;\n  if ( v6 )\n  {\n    v8 = getpwuid(v2);\n    v7 = (char *)&data;\n    if ( v8 )\n      v7 = sub_804DB46(v8->pw_name);\n  }\n  v17 = v7;\n  openlog(ident, 0, 32);\n  v9 = sub_80A999C();\n  v10 = v17;\n  if ( v2 )\n  {\n    v11 = sub_80AA371();\n    v10 = v17;\n    if ( v11 <= 0 )\n    {\n      syslog(5, \"%c %s %s:%s\", 45, v16, v17, v5);\n      sub_80A98F4();\n      sub_804D5E0(\"incorrect password\");\n    }\n  }\n  syslog(5, \"%c %s %s:%s\", 43, v16, v10, v5);\n  if ( !v18 && (v15 & 3) != 0 )\n    v18 = getenv(\"SHELL\");\n  if ( v18 && v2 )\n  {\n    v12 = *(const char **)(v9 + 24);\n    for ( i = v12 == 0; ; i = strcmp(v14, v12) == 0 )\n    {\n      if ( i )\n        goto LABEL_25;\n      v14 = getusershell();\n      if ( !v14 )\n        break;\n    }\n    sub_804D5F4(\"using restricted shell\");\n    v18 = 0;\n  }\nLABEL_25:\n  if ( !v18 )\n    v18 = *(char **)(v9 + 24);\n  sub_80A9B93();\n  sub_80B2CE1(v9, ((v15 & 4) == 0 ? 0x10 : 0) + ((v15 & 3) == 0) + 2 * ((unsigned __int8)(v15 & 4) >> 2));\n  if ( v19 )\n  {\n    *(v3 - 1) = v19;\n    *(v3 - 2) = \"-c\";\n    v3 -= 2;\n  }\n  sub_80B2B50(v3, v15 & 4, v15, v16);\n}\n"
        ],
        "134546659": [
            "sub_80504E3",
            "0x80504e3",
            "int __cdecl sub_80504E3(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // eax\n  int v4; // eax\n  int v6[2]; // [esp+4h] [ebp-8h] BYREF\n\n  v6[0] = 0;\n  byte_80DB561 = 3;\n  openlog(ident, 0, 32);\n  sub_80ABEAC(a2, \"t:+\", v6);\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( *v2 )\n  {\n    close(0);\n    close(1);\n    v3 = sub_804DBE1(*v2);\n    dup(v3);\n    close(2);\n    dup(0);\n  }\n  if ( !getpwuid(0) )\n    sub_804D5E0(\"no password entry for root\");\n  while ( 1 )\n  {\n    v4 = sub_80AA319(\"Give root password for system maintenance\\n(or type Control-D for normal startup):\", v6[0]);\n    if ( v4 < 0 )\n      break;\n    if ( v4 )\n    {\n      sub_804D5F4(\"starting shell for system maintenance\");\n      if ( !getenv(\"SUSHELL\") )\n        getenv(\"sushell\");\n      sub_80B2B50(0, 1, v6[0], v6[1]);\n    }\n    sub_80A98F4();\n    sub_804D5F4(\"Login incorrect\");\n  }\n  sub_804D5F4(\"normal startup\");\n  return 0;\n}\n"
        ],
        "134546916": [
            "sub_80505E4",
            "0x80505e4",
            "int sub_80505E4()\n{\n  return ioctl(0, 0x5605u, 2);\n}\n"
        ],
        "134546934": [
            "sub_80505F6",
            "0x80505f6",
            "int sub_80505F6()\n{\n  return ioctl(0, 0x5605u, dword_80DBB9C == 0);\n}\n"
        ],
        "134546963": [
            "sub_8050613",
            "0x8050613",
            "void __cdecl __noreturn sub_8050613(int a1, int a2)\n{\n  const char **v2; // ebp\n  int v3; // eax\n  const char *v4; // eax\n  int v5; // [esp-Ch] [ebp-A4h]\n  __int64 v6; // [esp+0h] [ebp-98h] BYREF\n  __int64 v7; // [esp+8h] [ebp-90h] BYREF\n  struct termios v8; // [esp+10h] [ebp-88h] BYREF\n  struct termios termios_p; // [esp+4Ch] [ebp-4Ch] BYREF\n\n  getuid();\n  v2 = (const char **)sub_80A99D2();\n  sub_80ABEAC(a2, \"^a\");\n  sub_804E6C8(7471118, (void (*)(int))1);\n  sub_804E782(10, (int)sub_80505F6);\n  sub_804E782(12, (int)sub_80505E4);\n  sub_804E734(10);\n  sub_804E734(12);\n  v3 = sub_804DBE1(\"/dev/tty\");\n  sub_804DC97(v3, 0);\n  sub_804DC7B(0, 1);\n  sub_804E0BE(0, 0x5601u, (int)&v6, \"VT_GETMODE\");\n  v7 = v6;\n  LOBYTE(v6) = 1;\n  *(_DWORD *)((char *)&v6 + 2) = 786442;\n  ioctl(0, 0x5602u, &v6);\n  tcgetattr(0, &termios_p);\n  qmemcpy(&v8, &termios_p, sizeof(v8));\n  v8.c_iflag = v8.c_iflag & 0xFFFFFFFC | 1;\n  v8.c_lflag &= 0xFFFFFDF6;\n  sub_804D995(&v8);\n  while ( 1 )\n  {\n    v4 = \"\";\n    if ( dword_80DBB9C )\n      v4 = \"s\";\n    printf(\"Virtual console%s locked by %s.\\n\", v4, *v2);\n    if ( sub_80AA371() > 0 )\n    {\n      ioctl(0, 0x5602u, &v7);\n      sub_804D995(&termios_p);\n      sub_80AB247(v5);\n    }\n    sub_80A98F4();\n    puts(\"Incorrect password\");\n  }\n}\n"
        ],
        "134547327": [
            "sub_805077F",
            "0x805077f",
            "char *__usercall sub_805077F@<eax>(char *result@<eax>, char *a2@<edx>, va_list a3@<ecx>)\n{\n  if ( buf <= (unsigned int)result )\n  {\n    byte_80DB562 = 6;\n    result = sub_804D40A(a2, a3, 0);\n    byte_80DB562 = 3;\n  }\n  return result;\n}\n"
        ],
        "134547366": [
            "sub_80507A6",
            "0x80507a6",
            "char *sub_80507A6(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_805077F((char *)8, a1, va);\n}\n"
        ],
        "134547385": [
            "sub_80507B9",
            "0x80507b9",
            "char *sub_80507B9(char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_805077F((char *)4, a1, va);\n}\n"
        ],
        "134547404": [
            "sub_80507CC",
            "0x80507cc",
            "int sub_80507CC()\n{\n  int result; // eax\n\n  result = *(&buf + 2);\n  if ( *(&buf + 2) )\n  {\n    result = sub_804DC14((const char *)*(&buf + 2));\n    if ( result >= 0 )\n      return sub_804DC97(result, 2);\n  }\n  return result;\n}\n"
        ],
        "134547438": [
            "sub_80507EE",
            "0x80507ee",
            "int **__usercall sub_80507EE@<eax>(const char *a1@<eax>, int **a2@<ebx>)\n{\n  size_t *v3; // edi\n  _BYTE *v4; // ebx\n  int **v5; // eax\n  int *v6; // esi\n\n  v3 = &buf + 4;\n  while ( 1 )\n  {\n    v4 = (_BYTE *)*v3;\n    if ( !*v3 )\n      return a2;\n    if ( strcmp(a1, *((const char **)v4 + 2)) )\n      goto LABEL_11;\n    v5 = (int **)(v4 + 4);\n    *(_WORD *)(v4 + 13) = 256;\n    while ( 1 )\n    {\n      v6 = *v5;\n      if ( !*v5 )\n        break;\n      if ( v6[2] <= 0 )\n      {\n        *v5 = (int *)*v6;\n        a2 = v5;\n        free((void *)v6[1]);\n        free(v6);\n        v5 = a2;\n      }\n      else\n      {\n        v4[13] = 1;\n        v5 = (int **)v6;\n      }\n    }\n    if ( v4[13] )\n    {\nLABEL_11:\n      v3 = (size_t *)v4;\n    }\n    else\n    {\n      *v3 = *(_DWORD *)v4;\n      free(*((void **)v4 + 2));\n      free(v4);\n    }\n  }\n}\n"
        ],
        "134547566": [
            "sub_805086E",
            "0x805086e",
            "unsigned __int8 __usercall sub_805086E@<al>(\n        const char *a1@<eax>,\n        unsigned __int8 *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        char *s2,\n        char *nptr)\n{\n  char *v6; // ebp\n  int v7; // edi\n  int v8; // ebx\n  int v9; // esi\n  char *v10; // ecx\n  char *v11; // esi\n  int v12; // eax\n  unsigned __int8 result; // al\n  int v14; // ebp\n  int v15; // eax\n  int v16; // ebx\n  int v17; // edi\n  int v18; // edx\n  unsigned __int8 *v19; // ebx\n  int v20; // edx\n  int v23; // [esp+8h] [ebp-1Ch]\n  char *endptr[5]; // [esp+10h] [ebp-14h] BYREF\n\n  v6 = nptr;\n  v7 = -1;\n  v8 = -1;\n  while ( 1 )\n  {\n    if ( *v6 == 42 )\n    {\n      v9 = a3 - 1;\n      v10 = v6 + 1;\n      v8 = 0;\n      goto LABEL_17;\n    }\n    if ( (unsigned __int8)(*v6 - 48) > 9u )\n      break;\n    if ( v8 >= 0 )\n      v7 = a4 + strtol(v6, endptr, 10);\n    else\n      v8 = a4 + strtol(v6, endptr, 10);\n    v10 = endptr[0];\nLABEL_16:\n    v9 = v7;\nLABEL_17:\n    if ( *v10 != 45 )\n    {\n      if ( v9 < 0 )\n        v9 = v8;\n      v14 = 1;\n      if ( *v10 == 47 )\n      {\n        v14 = strtol(v10 + 1, endptr, 10);\n        v10 = endptr[0];\n      }\nLABEL_25:\n      v15 = v8 - 1;\n      v16 = 1024;\n      v17 = 1;\n      while ( 1 )\n      {\n        v18 = (v15 + 1) % a3;\n        v15 = v18;\n        if ( !--v17 )\n        {\n          a2[v18] = 1;\n          v17 = v14;\n        }\n        if ( !--v16 )\n          return (unsigned __int8)sub_804D5F4(\"user %s: parse error at %s\", a1, nptr);\n        if ( v9 == v18 )\n        {\n          result = *v10;\n          if ( *v10 == 44 )\n          {\n            v6 = v10 + 1;\n            v9 = -1;\n            v8 = -1;\n            goto LABEL_19;\n          }\n          if ( !result )\n          {\n            if ( buf <= 5 && byte_80DB561 != 2 )\n            {\n              v19 = a2;\n              do\n                fprintf(stderr, \"%d\", *v19++);\n              while ( &a2[a3] != v19 );\n              return sub_804D830(10, v20);\n            }\n            return result;\n          }\n          return (unsigned __int8)sub_804D5F4(\"user %s: parse error at %s\", a1, nptr);\n        }\n      }\n    }\n    v6 = v10 + 1;\n    if ( v9 >= 0 )\n    {\n      v14 = 1;\n      goto LABEL_25;\n    }\nLABEL_19:\n    v7 = v9;\n  }\n  if ( s2 )\n  {\n    v11 = s2;\n    while ( 1 )\n    {\n      v23 = v11 - s2;\n      if ( !*v11 )\n        break;\n      v12 = strncasecmp(v6, v11, 3u);\n      v11 += 3;\n      if ( !v12 )\n      {\n        v10 = v6 + 3;\n        v9 = v23 / 3;\n        if ( v8 >= 0 )\n          goto LABEL_17;\n        v8 = v23 / 3;\n        goto LABEL_16;\n      }\n    }\n  }\n  return (unsigned __int8)sub_804D5F4(\"user %s: parse error at %s\", a1, nptr);\n}\n"
        ],
        "134547978": [
            "sub_8050A0A",
            "0x8050a0a",
            "int __usercall sub_8050A0A@<eax>(char **a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  char *v6; // eax\n  char *v7; // eax\n\n  v6 = *a1;\n  if ( v6 )\n    sub_804DE4D(v6);\n  v7 = sub_804DDBF(\"%s=%s\", a2, a3);\n  *a1 = v7;\n  return putenv(v7);\n}\n"
        ],
        "134548025": [
            "sub_8050A39",
            "0x8050a39",
            "__pid_t __usercall sub_8050A39@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>)\n{\n  __pid_t result; // eax\n  char *path; // [esp+0h] [ebp-10h]\n  struct passwd *v4; // [esp+4h] [ebp-Ch]\n\n  v4 = getpwnam(a1);\n  if ( !v4 )\n  {\n    sub_804D5F4(\"can't get uid for %s\", a1);\nLABEL_3:\n    result = 0;\n    goto LABEL_12;\n  }\n  path = (char *)a2[3];\n  if ( !path )\n    path = (char *)*(&buf + 5);\n  sub_8050A0A((char **)&buf + 9, \"LOGNAME\", v4->pw_name);\n  sub_8050A0A((char **)&buf + 6, \"USER\", v4->pw_name);\n  sub_8050A0A((char **)&buf + 7, \"HOME\", v4->pw_dir);\n  sub_8050A0A((char **)&buf + 8, \"SHELL\", path);\n  result = vfork();\n  if ( !result )\n  {\n    sub_80A9B93();\n    if ( chdir(v4->pw_dir) < 0 )\n    {\n      sub_804D5F4(\"can't change directory to '%s'\", v4->pw_dir);\n      sub_804DF04(\"/var/spool/cron\");\n    }\n    sub_80507B9(\"child running %s\", path);\n    setpgrp();\n    execl(path, path, \"-c\", a2[1], 0);\n    sub_804D5E0(\"can't execute '%s' for user %s\", path, a1);\n  }\n  if ( result < 0 )\n  {\n    sub_804D3A5((int)&unk_80C7DA0);\n    goto LABEL_3;\n  }\nLABEL_12:\n  a2[2] = result;\n  return result;\n}\n"
        ],
        "134548341": [
            "sub_8050B75",
            "0x8050b75",
            "char *__usercall sub_8050B75@<eax>(char *result@<eax>)\n{\n  char *v1; // ebp\n  int *i; // ebx\n  int **j; // esi\n  __pid_t v4; // edi\n\n  v1 = result;\n  for ( i = (int *)*(&buf + 4); i; i = (int *)*i )\n  {\n    if ( *((_BYTE *)i + 12) )\n    {\n      *((_BYTE *)i + 12) = 0;\n      for ( j = (int **)i[1]; j; j = (int **)*j )\n      {\n        if ( j[2] == (int *)v1 )\n        {\n          v4 = sub_8050A39((const char *)i[2], j);\n          result = sub_80507A6(\"USER %s pid %3d cmd %s\", (const char *)i[2], v4, (const char *)j[1]);\n          if ( v4 >= 0 )\n          {\n            if ( v4 )\n              *((_BYTE *)i + 13) = 1;\n          }\n          else\n          {\n            *((_BYTE *)i + 12) = 1;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"
        ],
        "134548440": [
            "sub_8050BD8",
            "0x8050bd8",
            "char *sub_8050BD8(int a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_805077F((char *)7, \"ignoring file '%s' (no such user)\", va);\n}\n"
        ],
        "134548460": [
            "sub_8050BEC",
            "0x8050bec",
            "char *__usercall sub_8050BEC@<eax>(const char *a1@<eax>, int **a2@<ebx>)\n{\n  char *result; // eax\n  int v4; // eax\n  char *v5; // esi\n  _DWORD *v6; // edi\n  int v7; // ebx\n  char **i; // ebx\n  int v9; // edx\n  int v10; // ecx\n  unsigned __int8 *v11; // eax\n  unsigned __int8 *v12; // ebx\n  int v13; // eax\n  int v14; // edx\n  int v15; // eax\n  int v16; // eax\n  int v17; // [esp-8h] [ebp-A0h]\n  int v18; // [esp-4h] [ebp-9Ch]\n  int v19; // [esp-4h] [ebp-9Ch]\n  char *v20; // [esp+0h] [ebp-98h]\n  char *ptr; // [esp+4h] [ebp-94h]\n  int v22; // [esp+8h] [ebp-90h]\n  char *nptr; // [esp+10h] [ebp-88h]\n  char *v24; // [esp+14h] [ebp-84h]\n  char *v25; // [esp+18h] [ebp-80h]\n  char *v26; // [esp+1Ch] [ebp-7Ch]\n  char *v27; // [esp+20h] [ebp-78h]\n  const char *v28; // [esp+24h] [ebp-74h]\n  char v29[24]; // [esp+28h] [ebp-70h] BYREF\n  int v30; // [esp+40h] [ebp-58h]\n\n  sub_80507EE(a1, a2);\n  if ( !getpwnam(a1) )\n    return sub_8050BD8((int)\"ignoring file '%s' (no such user)\", a1);\n  result = (char *)sub_80B052C();\n  v20 = result;\n  if ( result )\n  {\n    v22 = strcmp(a1, \"root\") == 0 ? 0xFFFF : 256;\n    v4 = fileno_unlocked(*(FILE **)v20);\n    ptr = 0;\n    if ( fstat64(v4, v29) || v30 )\n      goto LABEL_40;\n    v5 = (char *)sub_804DB2E(0x10u);\n    *((_DWORD *)v5 + 2) = sub_804DB46(a1);\n    v6 = v5 + 4;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          do\n          {\nLABEL_7:\n            if ( !--v22 )\n            {\n              sub_804D5F4(\"user %s: too many lines\", a1);\nLABEL_39:\n              *v6 = 0;\n              *(_DWORD *)v5 = *(&buf + 4);\n              *(&buf + 4) = (size_t)v5;\nLABEL_40:\n              sub_80B0536();\n              free(ptr);\n              return (char *)v19;\n            }\n            v7 = sub_80B0560(\"# \\t\");\n            if ( !v7 )\n              goto LABEL_39;\n            sub_80507B9(\"user:%s entry:%s\", a1, *((const char **)v20 + 1));\n          }\n          while ( sub_804D210(nptr, \"MAILTO=\") );\n          if ( !sub_804D210(nptr, \"SHELL=\") )\n            break;\n          free(ptr);\n          ptr = sub_804DB46(nptr + 6);\n        }\n        if ( *nptr == 64 )\n          break;\n        if ( v7 > 5 )\n          goto LABEL_22;\n      }\n      if ( v7 > 1 )\n      {\n        for ( i = &off_80B5360; strcmp(*i, nptr + 1); i += 3 )\n        {\n          if ( !*((_BYTE *)i + 4) )\n            goto LABEL_7;\n        }\n        sub_80B2E8C(v18, v17);\n        sub_80B2E9F();\n        v28 = (const char *)sub_80B2E8C(v10, v9);\n        if ( *((_BYTE *)i + 4) )\n        {\n          nptr = \"0\";\n          v24 = (char *)(i + 1);\n          v25 = (char *)i + 6;\n          v26 = (char *)(i + 2);\n          v27 = (char *)i + 10;\n        }\nLABEL_22:\n        v11 = (unsigned __int8 *)sub_804DB2E(0x98u);\n        v12 = v11;\n        *v6 = v11;\n        if ( *nptr == 64 )\n        {\n          v5[12] = 1;\n          *((_DWORD *)v11 + 2) = -2;\n        }\n        else\n        {\n          sub_805086E(*((const char **)v5 + 2), v11 + 91, 60, 0, 0, nptr);\n          sub_805086E(*((const char **)v5 + 2), v12 + 35, 24, 0, 0, v24);\n          sub_805086E(*((const char **)v5 + 2), v12 + 59, 32, 0, 0, v25);\n          sub_805086E(*((const char **)v5 + 2), v12 + 23, 12, -1, \"janfebmaraprmayjunjulaugsepoctnovdec\", v26);\n          sub_805086E(*((const char **)v5 + 2), v12 + 16, 7, 0, \"sunmontuewedthufrisat\", v27);\n          v13 = 0;\n          while ( v12[v13 + 16] )\n          {\n            if ( ++v13 == 7 )\n            {\n              v14 = 0;\n              goto LABEL_29;\n            }\n          }\n          v14 = 1;\nLABEL_29:\n          v15 = 0;\n          while ( v12[v15 + 59] )\n          {\n            if ( ++v15 == 32 )\n            {\n              v16 = 0;\n              goto LABEL_34;\n            }\n          }\n          v16 = 1;\nLABEL_34:\n          if ( v14 != v16 )\n          {\n            if ( v14 )\n              memset(v12 + 59, 0, 0x20u);\n            else\n              memset(v12 + 16, 0, 7u);\n          }\n        }\n        *((_DWORD *)v12 + 3) = sub_804DB46(ptr);\n        *((_DWORD *)v12 + 1) = sub_804DB46(v28);\n        v6 = v12;\n      }\n    }\n  }\n  return result;\n}\n"
        ],
        "134549256": [
            "sub_8050F08",
            "0x8050f08",
            "int __usercall sub_8050F08@<eax>(int **a1@<ebx>)\n{\n  int *i; // eax\n  int v2; // edx\n  DIR *v3; // esi\n  int v4; // ecx\n  char *v5; // ebx\n  char *v6; // eax\n  int v7; // eax\n  int v9; // [esp-8h] [ebp-10h]\n  int v10; // [esp-8h] [ebp-10h]\n  int v11; // [esp-4h] [ebp-Ch]\n  int v12; // [esp-4h] [ebp-Ch]\n\nLABEL_1:\n  for ( i = (int *)*(&buf + 4); i; i = (int *)*i )\n  {\n    if ( !*((_BYTE *)i + 14) )\n    {\n      sub_80507EE((const char *)i[2], a1);\n      goto LABEL_1;\n    }\n  }\n  unlink(\"cron.update\");\n  sub_804DF04((const char *)*(&buf + 3));\n  v3 = opendir(\".\");\n  v4 = v9;\n  if ( !v3 )\n    sub_804D5E0(\"can't open '%s'\", (const char *)*(&buf + 3));\n  while ( 1 )\n  {\n    v7 = readdir64(v4, v2, v3);\n    if ( !v7 )\n      break;\n    v5 = (char *)(v7 + 19);\n    v6 = strchr((const char *)(v7 + 19), 46);\n    v4 = v10;\n    v2 = v11;\n    if ( !v6 )\n      sub_8050BEC(v5, (int **)v5);\n  }\n  closedir(v3);\n  return v12;\n}\n"
        ],
        "134549386": [
            "sub_8050F8A",
            "0x8050f8a",
            "void __usercall __noreturn sub_8050F8A(int **a1@<ebx>, int a2, int a3)\n{\n  const char *v3; // eax\n  int v4; // eax\n  unsigned int v5; // ebx\n  int v6; // edi\n  unsigned int v7; // eax\n  int v8; // esi\n  FILE *v9; // ebp\n  struct tm *v10; // ebp\n  int *i; // esi\n  int *j; // ebx\n  int *v13; // ebx\n  int v14; // ebp\n  _DWORD *k; // esi\n  __pid_t v16; // eax\n  __pid_t v17; // eax\n  time_t v18; // [esp+0h] [ebp-178h]\n  time_t v19; // [esp+4h] [ebp-174h]\n  char v20[72]; // [esp+8h] [ebp-170h] BYREF\n  size_t v21; // [esp+50h] [ebp-128h]\n  time_t timer[68]; // [esp+68h] [ebp-110h] BYREF\n\n  buf = 8;\n  *(&buf + 3) = (size_t)\"/var/spool/cron/crontabs\";\n  if ( (sub_80ABEAC(a3, \"^l:L:fbSc:\", &buf, &buf + 2, 135116676) & 4) == 0 )\n    sub_80B3C0D();\n  if ( !*(&buf + 2) )\n  {\n    openlog(ident, 3, 72);\n    byte_80DB561 = 2;\n  }\n  sub_80507CC();\n  sub_804DF04((const char *)*(&buf + 3));\n  v3 = (const char *)sub_80AB879();\n  *(&buf + 5) = (size_t)sub_804DB46(v3);\n  sub_80507A6(\"crond (busybox 1.29.2) started, log level %d\", buf);\n  sub_8050F08(a1);\n  v4 = open64(\"/crond.reboot\");\n  if ( v4 >= 0 )\n  {\n    close(v4);\n    sub_8050B75((char *)0xFFFFFFFE);\n  }\n  v18 = time(0);\n  v5 = 60;\n  v6 = 60;\n  while ( 1 )\n  {\n    v7 = time(0);\n    sleep(v5 - v7 % v5);\n    v19 = time(0);\n    v8 = v19 - v18;\n    sub_80507CC();\n    if ( stat64(*(&buf + 3), v20) )\n      v21 = 0;\n    if ( *(&buf + 1) != v21 )\n    {\n      *(&buf + 1) = v21;\n      v6 = 1;\n    }\n    if ( !--v6 )\n    {\n      sub_8050F08((int **)v5);\n      v6 = 60;\n    }\n    v9 = (FILE *)sub_80B3D37();\n    if ( v9 )\n    {\n      unlink(\"cron.update\");\n      while ( fgets_unlocked(timer, 256, v9) )\n      {\n        *(_BYTE *)sub_80B2E9F() = 0;\n        sub_8050BEC((const char *)timer, (int **)v5);\n      }\n      fclose(v9);\n    }\n    sub_80507B9(\"wakeup dt=%ld\", v8);\n    if ( (unsigned int)(v8 + 3600) <= 0x1C20 )\n    {\n      if ( v8 > 0 )\n      {\n        for ( timer[0] = v18 - v18 % 60; v19 >= timer[0]; timer[0] += 60 )\n        {\n          if ( v18 < timer[0] )\n          {\n            v10 = localtime(timer);\n            for ( i = (int *)*(&buf + 4); i; i = (int *)*i )\n            {\n              sub_80507B9(\"file %s:\", (const char *)i[2]);\n              if ( !*((_BYTE *)i + 14) )\n              {\n                for ( j = (int *)i[1]; j; j = (int *)*j )\n                {\n                  sub_80507B9(\" line %s\", (const char *)j[1]);\n                  if ( *((_BYTE *)j + v10->tm_min + 91)\n                    && *((_BYTE *)j + v10->tm_hour + 35)\n                    && (*((_BYTE *)j + v10->tm_mday + 59) || *((_BYTE *)j + v10->tm_wday + 16)) )\n                  {\n                    if ( *((_BYTE *)j + v10->tm_mon + 23) )\n                    {\n                      sub_80507B9(\" job: %d %s\", j[2], (const char *)j[1]);\n                      if ( j[2] <= 0 )\n                      {\n                        if ( !j[2] )\n                        {\n                          j[2] = -1;\n                          *((_BYTE *)i + 12) = 1;\n                        }\n                      }\n                      else\n                      {\n                        sub_80507A6(\"user %s: process already running: %s\", (const char *)i[2], (const char *)j[1]);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        sub_8050B75((char *)0xFFFFFFFF);\n        v13 = (int *)*(&buf + 4);\n        v14 = 0;\n        while ( v13 )\n        {\n          if ( *((_BYTE *)v13 + 13) )\n          {\n            *((_BYTE *)v13 + 13) = 0;\n            for ( k = (_DWORD *)v13[1]; k; k = (_DWORD *)*k )\n            {\n              v16 = k[2];\n              if ( v16 > 0 )\n              {\n                v17 = waitpid(v16, 0, 1);\n                if ( v17 < 0 || v17 == k[2] )\n                  k[2] = 0;\n                else\n                  *((_BYTE *)v13 + 13) = 1;\n              }\n            }\n            v14 += *((char *)v13 + 13);\n          }\n          v13 = (int *)*v13;\n        }\n        v5 = v14 <= 0 ? 60 : 10;\n      }\n    }\n    else\n    {\n      sub_804D5F4(\"time disparity of %ld minutes detected\", v8 / 60);\n    }\n    v18 = v19;\n  }\n}\n"
        ],
        "134550215": [
            "sub_80512C7",
            "0x80512c7",
            "int __usercall sub_80512C7@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // eax\n  int v3; // ecx\n  char *v5; // ebx\n\n  v2 = vfork();\n  if ( v2 < 0 )\n    sub_804D3C9((int)&unk_80C7DA0);\n  if ( !v2 )\n  {\n    sub_80A9B93();\n    sub_80B2CE1(a1, 5);\n    v5 = getenv(\"VISUAL\");\n    if ( !v5 )\n    {\n      v5 = getenv(\"EDITOR\");\n      if ( !v5 )\n        v5 = \"vi\";\n    }\n    execlp(v5, v5, a2, 0);\n    sub_804D3C9((int)\"can't execute '%s'\", v5);\n  }\n  return sub_804DA6B(v2, v3);\n}\n"
        ],
        "134550347": [
            "sub_805134B",
            "0x805134b",
            "int __cdecl sub_805134B(int a1, int a2)\n{\n  char v2; // di\n  int *v3; // esi\n  int v4; // eax\n  const char **v5; // ebx\n  int v6; // edi\n  int v7; // eax\n  int v8; // esi\n  __pid_t v9; // eax\n  char *v10; // edi\n  int v11; // eax\n  int v12; // ebp\n  char *v13; // ebp\n  int v14; // eax\n  int v15; // eax\n  int v16; // esi\n  int v18; // [esp+0h] [ebp-80h]\n  int fd; // [esp+4h] [ebp-7Ch]\n  char v20[4]; // [esp+8h] [ebp-78h] BYREF\n  int v21; // [esp+Ch] [ebp-74h] BYREF\n  int v22[28]; // [esp+10h] [ebp-70h] BYREF\n\n  *(_DWORD *)v20 = \"/var/spool/cron/crontabs\";\n  v2 = sub_80ABEAC(a2, \"^u:c:lerd\", &v21, v20);\n  v3 = (int *)(a2 + 4 * optind);\n  if ( sub_80AFD54() && (v2 & 3) != 0 )\n    sub_804D5E0(\"you must be root\");\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = sub_80A999C();\n  }\n  else\n  {\n    getuid();\n    v4 = sub_80A99D2();\n  }\n  v5 = (const char **)v4;\n  v6 = v2 & 0x1C;\n  v18 = v6 & (v6 - 1);\n  if ( v18 )\nLABEL_8:\n    sub_804CDC2(v18);\n  if ( v6 )\n  {\n    v8 = 0;\n  }\n  else\n  {\n    v7 = *v3;\n    if ( !*v3 )\n      goto LABEL_8;\n    if ( *(_BYTE *)v7 != 45 || (v8 = 0, *(_BYTE *)(v7 + 1)) )\n      v8 = sub_804DEB6((const char *)v7, (__uid_t)v5[2], (__gid_t)v5[3]);\n  }\n  sub_804DF04(*(const char **)v20);\n  if ( v6 == 4 )\n  {\n    v22[0] = (int)*v5;\n    v22[1] = 0;\n    return sub_80A98A4();\n  }\n  else\n  {\n    if ( v6 == 8 )\n    {\n      v9 = getpid();\n      v10 = sub_804DDBF(\"%s.%u\", *(const char **)v20, v9);\n      v8 = sub_804DBC2(v10);\n      fchown(v8, (__uid_t)v5[2], (__gid_t)v5[3]);\n      v11 = open64(*v5);\n      v12 = v11;\n      if ( v11 >= 0 )\n      {\n        sub_804E572(v11, v8);\n        close(v12);\n        sub_804DD09(v8, 0, 0, 0);\n      }\n      sub_804D670(v8);\n      sub_80512C7((int)v5, (int)v10);\n    }\n    else\n    {\n      if ( v6 )\n      {\n        unlink(*v5);\n        goto LABEL_29;\n      }\n      v10 = 0;\n    }\n    v13 = sub_804DDBF(\"%s.new\", *v5);\n    v14 = open64(v13);\n    if ( v14 < 0 )\n    {\n      sub_804D5F4(\"can't create %s/%s\", *(const char **)v20, v13);\n    }\n    else\n    {\n      fd = v14;\n      sub_804E572(v8, v14);\n      close(fd);\n      sub_804DC43(v13, *v5);\n    }\n    if ( v10 )\n      unlink(v10);\nLABEL_29:\n    while ( 1 )\n    {\n      v15 = open64(\"cron.update\");\n      v16 = v15;\n      if ( v15 < 0 )\n        break;\n      dprintf(v15, \"%s\\n\", *v5);\n      if ( fstat64(v16, v22) || v22[5] )\n        return v18;\n      close(v16);\n    }\n    sub_804D5F4(\"can't append to %s/%s\", *(const char **)v20, \"cron.update\");\n  }\n  return v18;\n}\n"
        ],
        "134550911": [
            "sub_805157F",
            "0x805157f",
            "long double __usercall sub_805157F@<st0>(int a1@<ebp>, int a2@<edi>, char a3)\n{\n  void *retaddr; // [esp+0h] [ebp+0h]\n\n  if ( !buf )\n    sub_804D5E0(\"stack underflow\", buf, &a3, a1, retaddr, a2);\n  --buf;\n  return *((double *)&buf + buf + 1);\n}\n"
        ],
        "134550960": [
            "sub_80515B0",
            "0x80515b0",
            "size_t __cdecl sub_80515B0(int a1, double a2)\n{\n  size_t result; // eax\n\n  result = buf;\n  if ( buf > 0x7E )\n    sub_804D5E0(\"stack overflow\");\n  ++buf;\n  *((double *)&buf + result + 1) = a2;\n  return result;\n}\n"
        ],
        "134552384": [
            "sub_8051B40",
            "0x8051b40",
            "_BYTE *__usercall sub_8051B40@<eax>(const char *a1@<eax>)\n{\n  int v1; // edx\n  int v2; // ecx\n  long double v3; // fst7\n  char *v4; // esi\n  _BYTE *result; // eax\n  _BYTE *v6; // edi\n  void (**v7)(void); // ebx\n  long double v8; // [esp-8h] [ebp-20h]\n  char *endptr; // [esp+4h] [ebp-14h] BYREF\n\n  while ( 1 )\n  {\n    HIDWORD(v8) = a1;\n    v3 = strtod(a1, &endptr);\n    v4 = endptr;\n    if ( endptr != (char *)HIDWORD(v8) )\n    {\n      *(double *)&v8 = v3;\n      sub_80515B0(COERCE_UNSIGNED_INT64(v3), *(double *)((char *)&v8 + 4));\n      goto LABEL_3;\n    }\n    result = (_BYTE *)sub_80B2E8C(v2, v1);\n    v6 = result;\n    if ( !*result )\n      return result;\n    v7 = (void (**)(void))&unk_80B53C0;\n    while ( 1 )\n    {\n      v4 = sub_804D210(v6, v7);\n      if ( v4 )\n        break;\n      v7 += 2;\n      if ( v7 == (void (**)(void))&unk_80B5450 )\n        sub_804D5E0(\"syntax error at '%s'\", v6);\n    }\n    v7[1]();\nLABEL_3:\n    a1 = v4;\n  }\n}\n"
        ],
        "134552627": [
            "sub_8051C33",
            "0x8051c33",
            "int __cdecl sub_8051C33(int a1, double a2)\n{\n  long double v2; // fst6\n  unsigned int v3; // edi\n  unsigned int v4; // esi\n  unsigned __int64 v6; // rax\n  int v7; // [esp+0h] [ebp-30h]\n  unsigned __int64 v8; // [esp+4h] [ebp-2Ch]\n\n  v2 = a2;\n  if ( a2 >= 9.223372e18 )\n  {\n    v4 = (__int64)(v2 - 9.223372e18);\n    v3 = ((unsigned __int64)(__int64)(v2 - 9.223372e18) >> 32) + 0x80000000;\n  }\n  else\n  {\n    v3 = (unsigned __int64)(__int64)v2 >> 32;\n    v4 = (__int64)v2;\n  }\n  switch ( *(&buf + 1) )\n  {\n    case 0xAu:\n      if ( (double)__PAIR64__(v3, v4) == a2 )\n        return printf(\"%llu\\n\", __PAIR64__(v3, v4));\n      else\n        return printf(\"%g\\n\", a2);\n    case 8u:\n      return printf(\"%llo\\n\", __PAIR64__(v3, v4));\n    case 0x10u:\n      return printf(\"%llx\\n\", __PAIR64__(v3, v4));\n    default:\n      v7 = 63;\n      v6 = 0x8000000000000000LL;\n      while ( 1 )\n      {\n        v8 = v6 >> 1;\n        if ( v4 & (unsigned int)v6 | v3 & HIDWORD(v6) )\n          break;\n        v6 >>= 1;\n        if ( !--v7 )\n          goto LABEL_17;\n      }\n      v8 = v6;\n      do\n      {\nLABEL_17:\n        sub_804DD98(49 - ((v4 & (unsigned int)v8 | v3 & HIDWORD(v8)) == 0));\n        v8 >>= 1;\n      }\n      while ( v8 );\n      return sub_804DD98(10);\n  }\n}\n"
        ],
        "134553110": [
            "sub_8051E16",
            "0x8051e16",
            "int __cdecl sub_8051E16(int a1, int a2)\n{\n  const char **v2; // ebx\n  const char *v3; // eax\n  char *v4; // ebx\n\n  *(&buf + 1) = 10;\n  v2 = (const char **)(a2 + 4);\n  if ( *(_DWORD *)(a2 + 4) )\n  {\n    do\n      sub_8051B40(*v2++);\n    while ( *v2 );\n  }\n  else\n  {\n    while ( 1 )\n    {\n      v3 = (const char *)sub_80AB85A();\n      v4 = (char *)v3;\n      if ( !v3 )\n        break;\n      sub_8051B40(v3);\n      free(v4);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134553185": [
            "sub_8051E61",
            "0x8051e61",
            "int __cdecl sub_8051E61(int a1, _DWORD *a2)\n{\n  _DWORD *v2; // esi\n  const char *v3; // eax\n  _DWORD *v4; // edi\n  __int64 v5; // kr00_8\n  __int64 v6; // rax\n  unsigned int v7; // ebx\n  const char *v8; // eax\n  unsigned int v9; // eax\n  unsigned int v10; // ebp\n  int v11; // eax\n  _WORD *v12; // edi\n  __int64 v13; // rax\n  __int64 v15; // [esp+0h] [ebp-28h]\n  int v16; // [esp+8h] [ebp-20h]\n  int v17; // [esp+10h] [ebp-18h]\n\n  v2 = a2;\n  v3 = (const char *)a2[1];\n  if ( !v3 )\n    goto LABEL_2;\n  v4 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v6 = sub_804EC9E(v3, 0, 0);\n  v5 = v6;\n  LODWORD(v6) = a2[2];\n  if ( (_DWORD)v6 )\n  {\n    if ( (unsigned __int8)(*(_BYTE *)v6 - 48) <= 9u || *(_BYTE *)(v6 + 1) )\n    {\n      v7 = sub_80B40EC();\n    }\n    else\n    {\n      BYTE4(v6) = *(_BYTE *)v6;\n      v7 = (unsigned __int8)byte_80C8834[strchrnul(HIDWORD(v6) - 48, *(_BYTE *)v6 | 0x20, \"bhwl\", *(_BYTE *)v6 | 0x20)\n                                       - (_DWORD)\"bhwl\"];\n    }\n    v8 = (const char *)a2[3];\n    if ( v8 )\n      v15 = sub_804EC9E(v8, 0, 0);\n  }\n  else\n  {\n    v2 = a2 - 1;\n    v7 = 32;\n  }\n  if ( *v4 )\nLABEL_2:\n    sub_804CDC2(v15);\n  v17 = sub_804DBE1(\"/dev/mem\");\n  v9 = getpagesize();\n  v10 = v9 - 1;\n  v16 = (v9 - 1) & v5;\n  if ( v7 + v16 > v9 )\n    v9 *= 2;\n  v11 = mmap64(0, v9, v2[3] == 0 ? 1 : 3, 1, v17, ~v10 & v5, HIDWORD(v5));\n  if ( v11 == -1 )\n    sub_804D3C9((int)\"mmap\");\n  v12 = (_WORD *)(v11 + v16);\n  if ( v2[3] )\n  {\n    if ( v7 == 16 )\n    {\n      *v12 = v15;\n      return 0;\n    }\n    if ( v7 > 0x10 )\n    {\n      if ( v7 == 32 )\n      {\n        *(_DWORD *)v12 = v15;\n        return 0;\n      }\n      if ( v7 == 64 )\n      {\n        *(_QWORD *)v12 = v15;\n        return 0;\n      }\n    }\n    else if ( v7 == 8 )\n    {\n      *(_BYTE *)v12 = v15;\n      return 0;\n    }\n    goto LABEL_27;\n  }\n  if ( v7 == 16 )\n  {\n    LODWORD(v13) = (unsigned __int16)*v12;\n    goto LABEL_26;\n  }\n  if ( v7 <= 0x10 )\n  {\n    if ( v7 == 8 )\n    {\n      LODWORD(v13) = *(unsigned __int8 *)v12;\nLABEL_26:\n      HIDWORD(v13) = 0;\n      goto LABEL_28;\n    }\nLABEL_27:\n    sub_804D5E0(\"bad width\");\n  }\n  if ( v7 == 32 )\n  {\n    LODWORD(v13) = *(_DWORD *)v12;\n    goto LABEL_26;\n  }\n  if ( v7 != 64 )\n    goto LABEL_27;\n  v13 = *(_QWORD *)v12;\nLABEL_28:\n  printf(\"0x%0*llX\\n\", v7 >> 2, v13);\n  return 0;\n}\n"
        ],
        "134553611": [
            "sub_805200B",
            "0x805200b",
            "int __usercall sub_805200B@<eax>(_DWORD *a1@<eax>)\n{\n  if ( !optarg )\n    return 1;\n  *a1 = sub_80B4160();\n  return 2;\n}\n"
        ],
        "134553644": [
            "sub_805202C",
            "0x805202c",
            "int __usercall sub_805202C@<eax>(_DWORD *a1@<eax>)\n{\n  return sub_805200B(a1);\n}\n"
        ],
        "134553656": [
            "sub_8052038",
            "0x8052038",
            "int __usercall sub_8052038@<eax>(_DWORD *a1@<eax>)\n{\n  return sub_805200B(a1);\n}\n"
        ],
        "134553668": [
            "sub_8052044",
            "0x8052044",
            "int __usercall sub_8052044@<eax>(char *a1@<eax>)\n{\n  int i; // ebx\n  int result; // eax\n\n  for ( i = 0; i != 32; ++i )\n  {\n    if ( !strncmp(a1, (const char *)(5 * i + 135043390), 5u) && strlen(a1) <= 5 )\n      return (unsigned __int8)byte_80C99DE[i];\n  }\n  result = sub_804EDC5(10, a1, 0, 32);\n  if ( *(_DWORD *)dword_80DBB7C )\n    return -1;\n  return result;\n}\n"
        ],
        "134553756": [
            "sub_805209C",
            "0x805209c",
            "int __usercall sub_805209C@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  sub_80B24F6(0x100000, a1);\n  for ( result = 0; result != 0x100000; result += 512 )\n    *(_BYTE *)(a1 + result) &= 1u;\n  return result;\n}\n"
        ],
        "134553796": [
            "sub_80520C4",
            "0x80520c4",
            "int __usercall sub_80520C4@<eax>(int result@<eax>, int a2@<edx>, const char *a3@<ecx>, int a4)\n{\n  _WORD *v4; // edi\n  int v5; // ecx\n  int v6; // esi\n  _WORD *v7; // eax\n  char *v8; // edi\n  char *v9; // ebx\n  int v10; // eax\n\n  v4 = (_WORD *)(result + 2 * a2);\n  if ( *v4 )\n  {\n    printf(\"\\t%-20s\", a3);\n    v5 = 2 * a4;\n    v6 = 1;\n    v7 = &v4[a4];\n    while ( 1 )\n    {\n      v8 = (char *)v7 - v5;\n      if ( *((_BYTE *)v7 + v6 - v5) == 32 )\n        break;\n      v6 = -v6;\n      if ( !--v5 )\n        return sub_804DD98(10);\n    }\n    v9 = (char *)v7;\n    while ( v9 != v8 )\n    {\n      v10 = (unsigned __int8)v8[v6];\n      if ( !(_BYTE)v10 )\n        break;\n      sub_804DD98(v10);\n      ++v8;\n      v6 = -v6;\n    }\n    return sub_804DD98(10);\n  }\n  return result;\n}\n"
        ],
        "134553895": [
            "sub_8052127",
            "0x8052127",
            "int __usercall sub_8052127@<eax>(unsigned __int16 a1@<ax>, unsigned __int16 a2@<dx>, int a3@<ecx>, _BYTE *a4)\n{\n  int v6; // ebp\n  int v7; // edi\n  int v9; // [esp+0h] [ebp-14h]\n  int v10; // [esp+0h] [ebp-14h]\n\n  v6 = 0;\n  v7 = 0;\n  do\n  {\n    if ( (a2 & 1) != 0 )\n    {\n      v9 = a3;\n      printf(\"*%cdma%u \", a3, v6);\n      a3 = v9;\n      if ( *a4 )\n        v7 = 1;\n      *a4 = 1;\n    }\n    else if ( (a1 & 1) != 0 )\n    {\n      v10 = a3;\n      printf(\"%cdma%u \", a3, v6);\n      a3 = v10;\n    }\n    a1 >>= 1;\n    a2 >>= 1;\n    ++v6;\n  }\n  while ( v6 != 8 );\n  return v7;\n}\n"
        ],
        "134554008": [
            "sub_8052198",
            "0x8052198",
            "int __usercall sub_8052198@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  int v5; // [esp-4h] [ebp-8h]\n\n  printf(\" %s\\t= %2lu\", a1, a2);\n  v3 = \" (off)\";\n  if ( a2 )\n    v3 = \" (on)\";\n  puts(v3);\n  return v5;\n}\n"
        ],
        "134554049": [
            "sub_80521C1",
            "0x80521c1",
            "void __usercall __noreturn sub_80521C1(int a1@<eax>)\n{\n  unsigned __int16 v2; // ax\n  unsigned __int16 v3; // si\n  const char *v4; // eax\n  const char *v5; // eax\n  __int16 v6; // ax\n  __int16 v7; // ax\n  int v8; // edx\n  unsigned __int16 v9; // bx\n  const char *v10; // eax\n  __int16 v11; // ax\n  int v12; // ecx\n  __int16 v13; // ax\n  __int16 v14; // ax\n  __int16 v15; // ax\n  __int16 v16; // ax\n  __int16 v17; // ax\n  __int16 v18; // dx\n  unsigned __int16 v19; // bx\n  int i; // esi\n  const char *v21; // eax\n  __int16 v22; // ax\n  unsigned __int16 v23; // bx\n  int j; // esi\n  const char *v25; // eax\n  const char *v26; // edx\n  __int16 v27; // ax\n  const char *v28; // edx\n  unsigned __int16 v29; // si\n  unsigned int v30; // esi\n  int v31; // ecx\n  __int16 v32; // bx\n  int v33; // edx\n  int v34; // eax\n  int v35; // edx\n  unsigned __int64 v36; // rcx\n  int v37; // esi\n  int v38; // ebx\n  __int64 v39; // rax\n  __int16 v40; // cx\n  const char *v41; // edx\n  const char *v42; // eax\n  int v43; // eax\n  const char *v44; // ecx\n  const char *v45; // edx\n  int v46; // eax\n  const char *v47; // eax\n  __int16 v48; // dx\n  const char *v49; // eax\n  __int16 v50; // ax\n  __int16 v51; // ax\n  __int16 v52; // dx\n  __int16 v53; // cx\n  __int16 v54; // ax\n  __int16 v55; // ax\n  unsigned __int16 v56; // ax\n  int v57; // ebx\n  unsigned __int16 v58; // ax\n  unsigned __int16 v59; // ax\n  __int16 v60; // bx\n  unsigned __int16 v61; // bx\n  int k; // esi\n  int m; // ebx\n  __int16 v64; // si\n  int v65; // ecx\n  unsigned __int16 n; // bx\n  const char *v67; // eax\n  int v68; // ecx\n  const char *v69; // edx\n  int v70; // eax\n  const char *v71; // eax\n  int v72; // eax\n  unsigned __int16 v73; // si\n  int ii; // ebx\n  const char *v75; // eax\n  const char *v76; // edx\n  __int16 v77; // dx\n  const char *v78; // eax\n  __int16 v79; // ax\n  unsigned __int16 v80; // si\n  __int16 v81; // dx\n  unsigned __int16 v82; // bx\n  int v83; // eax\n  int v84; // eax\n  unsigned __int16 v85; // ax\n  __int16 v86; // dx\n  __int16 v87; // dx\n  const char *v88; // ecx\n  const char *v89; // ebx\n  __int16 v90; // ax\n  const char *v91; // ecx\n  const char *v92; // edx\n  unsigned __int16 v93; // ax\n  const char *v94; // eax\n  unsigned __int16 v95; // [esp+4h] [ebp-34h]\n  __int64 v96; // [esp+4h] [ebp-34h]\n  int v97; // [esp+Ch] [ebp-2Ch]\n  __int16 v98; // [esp+10h] [ebp-28h]\n  unsigned int v99; // [esp+10h] [ebp-28h]\n  unsigned __int64 v100; // [esp+10h] [ebp-28h]\n  unsigned __int64 v101; // [esp+10h] [ebp-28h]\n  __int16 v102; // [esp+1Ah] [ebp-1Eh]\n  unsigned __int16 v103; // [esp+1Ch] [ebp-1Ch]\n  int v104; // [esp+1Ch] [ebp-1Ch]\n  unsigned __int16 v105; // [esp+20h] [ebp-18h]\n  unsigned __int16 v106; // [esp+22h] [ebp-16h]\n  unsigned __int16 v107; // [esp+22h] [ebp-16h]\n  char v108[17]; // [esp+27h] [ebp-11h] BYREF\n\n  v108[0] = 0;\n  sub_804DD98(10);\n  v2 = *(_WORD *)a1;\n  if ( *(__int16 *)a1 < 0 )\n  {\n    if ( v2 == 0x848A )\n    {\n      printf(\"CompactFlash ATA device, with \");\n      v105 = -1;\n      v102 = 0;\n      v3 = 4;\n    }\n    else\n    {\n      if ( (v2 & 0x4000) != 0 )\n        sub_804D5E0(\"unknown device type\");\n      v105 = ((int)v2 >> 8) & 0x1F;\n      v4 = \"unknown\";\n      if ( v105 <= 0xFu )\n        v4 = sub_804D2B4(\"Direct-access device\", v105);\n      printf(\"ATAPI %s, with \", v4);\n      v102 = 1;\n      v3 = 3;\n    }\n  }\n  else\n  {\n    printf(\"ATA device, with \");\n    v105 = -1;\n    v102 = 0;\n    v3 = 1;\n  }\n  v5 = &data;\n  if ( *(char *)a1 >= 0 )\n    v5 = \"non-\";\n  printf(\"%sremovable media\\n\", v5);\n  v6 = *(_WORD *)(a1 + 4);\n  if ( v6 == 14280 )\n    goto LABEL_16;\n  if ( v6 != 29580 && v6 != -29581 && v6 != -14281 )\n    goto LABEL_21;\n  if ( v6 == 29580 )\nLABEL_16:\n    puts(\"powers-up in standby; SET FEATURES subcmd spins-up.\");\n  v7 = *(_WORD *)(a1 + 4);\n  if ( v7 == 14280 || (v3 = 5, v7 == -29581) )\n  {\n    v3 = 5;\n    if ( (*(_BYTE *)a1 & 4) != 0 )\n      puts(\"\\n\\tWARNING: ID response incomplete.\\n\\tFollowing data may be incorrect.\\n\");\n  }\nLABEL_21:\n  sub_80520C4(a1, 27, \"Model Number:\", 20);\n  sub_80520C4(a1, 10, \"Serial Number:\", 10);\n  sub_80520C4(a1, 23, \"Firmware Revision:\", 4);\n  sub_80520C4(a1, 176, \"Media Serial Num:\", 20);\n  sub_80520C4(a1, 196, \"Media Manufacturer:\", 10);\n  printf(\"Standards:\");\n  if ( v105 != 5 )\n  {\n    v8 = *(unsigned __int16 *)(a1 + 162);\n    v9 = 0;\n    if ( (unsigned __int16)(v8 - 1) <= 0x21u )\n    {\n      if ( v3 < 3u )\n        v3 = 3;\n      v9 = (unsigned __int8)byte_80C9E53[v8];\n      if ( byte_80C9E53[v8] )\n      {\n        v10 = sub_804D2B4(\"Unspecified\", v8);\n        printf(\"\\n\\tUsed: %s \", v10);\n      }\n    }\n    v103 = -1;\n    if ( (unsigned __int16)(*(_WORD *)(a1 + 160) - 1) <= 0xFFFDu )\n    {\n      printf(\"\\n\\tSupported: \");\n      v98 = 2 * *(_WORD *)(a1 + 160);\n      v11 = v3;\n      if ( v3 < 4u )\n        v11 = 4;\n      v106 = v11 - 4;\n      v12 = 14;\n      v103 = -1;\n      do\n      {\n        if ( (unsigned __int16)v12 <= v106 )\n          break;\n        if ( v98 < 0 )\n        {\n          v95 = v12;\n          v97 = v12;\n          printf(\"%u \", v12);\n          v12 = v97;\n          if ( v95 > v3 )\n          {\n            v13 = v97;\n            if ( v95 < 4u )\n              v13 = 4;\n            v106 = v13 - 4;\n            v3 = v95;\n          }\n          if ( v103 > v95 )\n            v103 = v95;\n        }\n        v98 *= 2;\n        --v12;\n      }\n      while ( v12 );\n      if ( v3 < 3u )\n        v3 = 3;\n    }\n    v107 = v3;\n    if ( v3 < v9 )\n      v107 = v9;\n    if ( v9 == 5 || !v9 && v107 <= 5u )\n    {\n      if ( (v14 = *(_WORD *)(a1 + 166), (v14 & 0xC000) == 0x4000) && (v14 & 0x3FFFu) > 0xFF\n        || (v15 = *(_WORD *)(a1 + 168), (v15 & 0xC000) == 0x4000) && (v15 & 0x2F) != 0 )\n      {\n        v107 = 6;\n        goto LABEL_84;\n      }\n    }\n    if ( v9 != 4 && (v9 || v107 > 4u) )\n    {\n      if ( v9 == 3 )\n      {\nLABEL_62:\n        v17 = *(_WORD *)(a1 + 166);\n        if ( (v17 & 0xC000) == 0x4000 && ((v17 & 0x3FFF) != 0 || (*(_WORD *)(a1 + 164) & 0x77FFu) > 0xF)\n          || (*(_WORD *)(a1 + 100) & 0xC000) == 0x4000\n          || (*(_BYTE *)(a1 + 106) & 4) != 0 && *(_WORD *)(a1 + 176)\n          || (*(_WORD *)(a1 + 254) & 3) == 1 )\n        {\n          v107 = 4;\n          goto LABEL_84;\n        }\nLABEL_69:\n        if ( (v9 == 2 || !v9 && v107 <= 2u) && (*(_WORD *)(a1 + 166) & 0xC000) == 0x4000 )\n        {\n          v107 = 3;\n        }\n        else if ( (v9 == 1 || !v9 && v107 == 1)\n               && ((*(_WORD *)(a1 + 98) & 0xC00) != 0 || (*(_BYTE *)(a1 + 106) & 2) != 0) )\n        {\n          v107 = 2;\n        }\nLABEL_84:\n        if ( v9 )\n        {\n          if ( v107 <= v9 )\n            sub_804DD98(10);\n          else\n            printf(\"& some of %u\\n\", v107);\n        }\n        else\n        {\n          printf(\"\\n\\tLikely used: %u\\n\", v107);\n        }\n        if ( v103 != 0xFFFF )\n          goto LABEL_104;\n        goto LABEL_101;\n      }\n    }\n    else if ( *(_BYTE *)(a1 + 510) == 0xA5\n           || (*(_WORD *)(a1 + 186) & 0xC000) == 0x4000\n           || (v16 = *(_WORD *)(a1 + 166), (v16 & 0xC000) == 0x4000) && (v16 & 0x3FFFu) > 0x1F )\n    {\n      v107 = 5;\n      goto LABEL_84;\n    }\n    if ( v107 > 3u || v9 )\n      goto LABEL_69;\n    goto LABEL_62;\n  }\n  v18 = 0;\n  if ( *(_WORD *)(a1 + 148) == 9 )\n  {\n    printf(\"\\n\\tUsed: ATAPI for CD-ROMs, SFF-8020i, r2.5\");\n    v18 = 1;\n  }\n  if ( (unsigned __int16)(*(_WORD *)(a1 + 146) - 1) > 0xFFFDu )\n  {\n    if ( !v18 )\n    {\n      v21 = \"\\n\\tLikely used CD-ROM ATAPI-1\";\n      goto LABEL_99;\n    }\n  }\n  else\n  {\n    printf(\"\\n\\tSupported: CD-ROM ATAPI\");\n    v19 = *(_WORD *)(a1 + 146) >> 1;\n    for ( i = 1; i != 15; ++i )\n    {\n      if ( (v19 & 1) != 0 )\n        printf(\"-%u \", i);\n      v19 >>= 1;\n    }\n  }\n  v21 = &data;\nLABEL_99:\n  puts(v21);\n  v107 = 2;\nLABEL_101:\n  v22 = v107;\n  if ( v107 < 4u )\n    v22 = 4;\n  v103 = v22 - 3;\nLABEL_104:\n  puts(\"Configuration:\");\n  if ( v107 == 1 && v105 != 5 )\n  {\n    v23 = *(_WORD *)a1 >> 1;\n    for ( j = 1; j != 15; ++j )\n    {\n      if ( (v23 & 1) != 0 )\n      {\n        v25 = sub_804D2B4(\"reserved\", j);\n        printf(\"\\t%s\\n\", v25);\n      }\n      v23 >>= 1;\n    }\n  }\n  if ( v102 == 1 )\n  {\n    v26 = \"3ms\";\n    v27 = *(_WORD *)a1 & 0x60;\n    if ( v27 )\n    {\n      v26 = \"<=10ms with INTRQ\";\n      if ( v27 != 32 )\n      {\n        v26 = \"unknown\";\n        if ( v27 == 64 )\n          v26 = \"50us\";\n      }\n    }\n    printf(\"\\tDRQ response: %s\\n\\tPacket size: \", v26);\n    v28 = \"12 bytes\";\n    if ( (*(_WORD *)a1 & 3) != 0 )\n    {\n      v28 = \"unknown\";\n      if ( (*(_WORD *)a1 & 3) == 1 )\n        v28 = \"16 bytes\";\n    }\n    puts(v28);\n  }\n  else\n  {\n    v99 = *(_DWORD *)(a1 + 120);\n    v29 = *(_WORD *)(a1 + 2);\n    if ( v99 <= 0xFBFC10 || v29 )\n    {\n      v31 = 0;\n      v32 = *(_WORD *)(a1 + 106) & 1;\n      if ( v32 )\n        v31 = *(unsigned __int16 *)(a1 + 112);\n      v33 = 0;\n      if ( v32 )\n        v33 = *(unsigned __int16 *)(a1 + 110);\n      v34 = 0;\n      if ( v32 )\n        v34 = *(unsigned __int16 *)(a1 + 108);\n      printf(\n        \"\\tLogical\\t\\tmax\\tcurrent\\n\\tcylinders\\t%u\\t%u\\n\\theads\\t\\t%u\\t%u\\n\\tsectors/track\\t%u\\t%u\\n\\t--\\n\",\n        v29,\n        v34,\n        *(unsigned __int16 *)(a1 + 6),\n        v33,\n        *(unsigned __int16 *)(a1 + 12),\n        v31);\n      if ( v103 == 1 && *(_DWORD *)(a1 + 8) )\n        printf(\"\\tbytes/track: %u\\tbytes/sector: %u\\n\", *(unsigned __int16 *)(a1 + 8), *(unsigned __int16 *)(a1 + 10));\n      v30 = 0;\n      if ( v32 )\n      {\n        v30 = *(_DWORD *)(a1 + 114);\n        if ( v107 <= 2u )\n        {\n          v35 = *(unsigned __int16 *)(a1 + 112) * *(unsigned __int16 *)(a1 + 108) * *(unsigned __int16 *)(a1 + 110);\n          if ( (int)abs32(v30 - v35) > (int)abs32(\n                                              (*(unsigned __int16 *)(a1 + 116) | (*(unsigned __int16 *)(a1 + 114) << 16))\n                                            - v35) )\n            v30 = *(unsigned __int16 *)(a1 + 116) | (*(unsigned __int16 *)(a1 + 114) << 16);\n        }\n        printf(\"\\tCHS current addressable sectors:%11u\\n\", v30);\n      }\n    }\n    else\n    {\n      puts(\"\\tCHS addressing not supported\");\n      v30 = 0;\n    }\n    printf(\"\\tLBA    user addressable sectors:%11u\\n\", v99);\n    if ( (*(_WORD *)(a1 + 166) & 0xC400) != 17408\n      || (v96 = *(_QWORD *)(a1 + 200), printf(\"\\tLBA48  user addressable sectors:%11llu\\n\", v96), (v36 = v96) == 0) )\n    {\n      if ( v30 < v99 )\n        v30 = v99;\n      v36 = v30;\n    }\n    v100 = v36;\n    printf(\"\\tdevice size with M = 1024*1024: %11llu MBytes\\n\", v36 >> 11);\n    v37 = v100 >> 23;\n    v38 = (_DWORD)v100 << 9;\n    v101 = sub_80B4B88((_DWORD)v100 << 9, v37, 1000000, 0);\n    printf(\"\\tdevice size with M = 1000*1000: %11llu MBytes \", v101);\n    if ( v101 <= 0x3E8 )\n    {\n      sub_804DD98(10);\n    }\n    else\n    {\n      v39 = sub_80B4B88(v38, v37, 1000000000, 0);\n      printf(\"(%llu GB)\\n\", v39);\n    }\n  }\n  printf(\"Capabilities:\\n\\t\");\n  if ( v102 == 1 )\n  {\n    if ( v105 != 5 && (*(_WORD *)(a1 + 98) & 0x4000) != 0 )\n      printf(\"Cmd queuing, \");\n    if ( (*(_BYTE *)(a1 + 99) & 0x20) != 0 )\n      printf(\"Cmd overlap, \");\n  }\n  if ( (*(_BYTE *)(a1 + 99) & 2) != 0 )\n    printf(\"LBA, \");\n  if ( v107 != 1 )\n  {\n    v40 = *(_WORD *)(a1 + 98);\n    v41 = \"not\";\n    if ( (v40 & 0x400) != 0 )\n      v41 = &data;\n    v42 = &data;\n    if ( (v40 & 0x800) == 0 )\n      v42 = \"(may be)\";\n    printf(\"IORDY%s(can%s be disabled)\\n\", v42, v41);\nLABEL_165:\n    if ( v103 == 1 )\n    {\n      v46 = *(unsigned __int16 *)(a1 + 42);\n      if ( (unsigned __int16)(v46 - 1) <= 0xFFFDu )\n        printf(\"\\tBuffer size: %.1fkB\\n\", (double)(0.5 * (long double)v46));\n    }\n    else if ( v103 > 3u )\n    {\n      goto LABEL_171;\n    }\n    if ( *(_WORD *)(a1 + 44) )\n      printf(\"\\tbytes avail on r/w long: %u\\n\", *(unsigned __int16 *)(a1 + 44));\nLABEL_171:\n    if ( v105 == 5 )\n    {\n      if ( v102 )\n      {\nLABEL_202:\n        if ( *(_WORD *)(a1 + 142) || *(_WORD *)(a1 + 144) )\n        {\n          printf(\"\\tOverlap support:\");\n          if ( *(_WORD *)(a1 + 142) )\n            printf(\" %uus to release bus.\", *(unsigned __int16 *)(a1 + 142));\n          if ( *(_WORD *)(a1 + 144) )\n            printf(\" %uus to clear BSY after SERVICE cmd.\", *(unsigned __int16 *)(a1 + 144));\n          sub_804DD98(10);\n        }\n        goto LABEL_209;\n      }\n    }\n    else\n    {\n      if ( v107 > 3u )\n      {\n        printf(\"\\tQueue depth: %u\\n\", (*(_WORD *)(a1 + 150) & 0x1F) + 1);\n        if ( v102 )\n        {\nLABEL_200:\n          if ( (*(_BYTE *)(a1 + 99) & 0x10) != 0 )\n            puts(\"\\tATA sw reset required\");\n          goto LABEL_202;\n        }\n        goto LABEL_177;\n      }\n      if ( v102 )\n        goto LABEL_200;\n    }\n    if ( v107 == 1 )\n    {\n      v94 = &data;\n      if ( !*(_WORD *)(a1 + 96) )\n        v94 = \"not\";\n      printf(\"\\tCan%s perform double-word IO\\n\", v94);\n      goto LABEL_185;\n    }\nLABEL_177:\n    v47 = \"vendor\";\n    if ( (*(_BYTE *)(a1 + 99) & 0x20) != 0 )\n      v47 = \"standard\";\n    printf(\"\\tStandby timer values: spec'd by %s\", v47);\n    if ( v107 > 3u && (v48 = *(_WORD *)(a1 + 100), (v48 & 0xC000) == 0x4000) )\n    {\n      v49 = \"no\";\n      if ( (v48 & 1) != 0 )\n        v49 = \"with\";\n      printf(\", %s device specific minimum\\n\", v49);\n    }\n    else\n    {\n      sub_804DD98(10);\n    }\nLABEL_185:\n    printf(\"\\tR/W multiple sector transfer: \");\n    v50 = *(_WORD *)(a1 + 94);\n    if ( v107 > 2u || (_BYTE)v50 )\n    {\n      printf(\"Max = %u\\tCurrent = \", (unsigned __int8)v50);\n      v51 = *(_WORD *)(a1 + 118);\n      if ( (v51 & 0x100) != 0 )\n        printf(\"%u\\n\", (unsigned __int8)v51);\n      else\n        puts(\"?\");\n      if ( v107 > 3u )\n      {\n        if ( (*(_BYTE *)(a1 + 166) & 8) != 0 )\n        {\n          printf(\"\\tAdvancedPM level: \");\n          v52 = *(_WORD *)(a1 + 182);\n          HIBYTE(v53) = HIBYTE(v52);\n          LOBYTE(v53) = 0;\n          if ( v53 == 0x4000 )\n            printf(\"%u (0x%x)\\n\", (unsigned __int8)v52, (unsigned __int8)v52);\n          else\n            printf(\"unknown setting (0x%04x)\\n\", *(unsigned __int16 *)(a1 + 182));\n        }\n        if ( v107 > 5u )\n        {\n          v54 = *(_WORD *)(a1 + 188);\n          if ( v54 )\n            printf(\n              \"\\tRecommended acoustic management value: %u, current value: %u\\n\",\n              HIBYTE(v54),\n              (unsigned __int8)v54);\n        }\n      }\n    }\n    else\n    {\n      puts(\"not supported\");\n    }\nLABEL_209:\n    printf(\"\\tDMA: \");\n    if ( (*(_BYTE *)(a1 + 99) & 1) != 0 )\n    {\n      v55 = *(_WORD *)(a1 + 104);\n      if ( v55 && !*(_WORD *)(a1 + 124) && !*(_WORD *)(a1 + 126) )\n        printf(\" sdma%u\\n\", HIBYTE(v55));\n      v56 = *(_WORD *)(a1 + 124);\n      v57 = 0;\n      if ( v56 )\n        LOBYTE(v57) = sub_8052127(v56, HIBYTE(v56), 115, v108);\n      v58 = *(_WORD *)(a1 + 126);\n      if ( v58 )\n        v57 += sub_8052127(v58, HIBYTE(v58), 109, v108);\n      if ( (*(_BYTE *)(a1 + 106) & 4) != 0 )\n      {\n        v59 = *(_WORD *)(a1 + 176);\n        if ( v59 )\n          v57 += sub_8052127(v59, HIBYTE(v59), 117, v108);\n      }\n      if ( (_BYTE)v57 || !v108[0] )\n        printf(\"(?)\");\n      sub_804DD98(10);\n      if ( v102 && v105 != 5 && *(__int16 *)(a1 + 98) < 0 )\n        puts(\"\\t\\tInterleaved DMA support\");\n      if ( (*(_BYTE *)(a1 + 106) & 2) != 0 && (*(_WORD *)(a1 + 130) || *(_WORD *)(a1 + 132)) )\n      {\n        printf(\"\\t\\tCycle time:\");\n        if ( *(_WORD *)(a1 + 130) )\n          printf(\" min=%uns\", *(unsigned __int16 *)(a1 + 130));\n        if ( *(_WORD *)(a1 + 132) )\n          printf(\" recommended=%uns\", *(unsigned __int16 *)(a1 + 132));\n        sub_804DD98(10);\n      }\n    }\n    else\n    {\n      puts(\"not supported\");\n    }\n    printf(\"\\tPIO: \");\n    if ( (*(_BYTE *)(a1 + 106) & 2) != 0 && (v60 = *(_WORD *)(a1 + 128), (_BYTE)v60) )\n    {\n      v61 = (8 * v60) & 0x7F8 | 7;\n      for ( k = 0; k != 9; ++k )\n      {\n        if ( (v61 & 1) != 0 )\n          printf(\"pio%d \", k);\n        v61 >>= 1;\n      }\n    }\n    else\n    {\n      if ( v105 != 5 && v103 > 4u || (*(_WORD *)(a1 + 102) & 0xFF00) == 0 )\n      {\n        puts(\"unknown\");\n        goto LABEL_251;\n      }\n      for ( m = 0; *(unsigned __int8 *)(a1 + 103) >= (unsigned __int16)m; ++m )\n        printf(\"pio%d \", m);\n    }\n    sub_804DD98(10);\nLABEL_251:\n    if ( (*(_BYTE *)(a1 + 106) & 2) != 0 && (*(_WORD *)(a1 + 134) || *(_WORD *)(a1 + 136)) )\n    {\n      printf(\"\\t\\tCycle time:\");\n      if ( *(_WORD *)(a1 + 134) )\n        printf(\" no flow control=%uns\", *(unsigned __int16 *)(a1 + 134));\n      if ( *(_WORD *)(a1 + 136) )\n        printf(\"  IORDY flow control=%uns\", *(unsigned __int16 *)(a1 + 136));\n      sub_804DD98(10);\n    }\n    if ( (*(_WORD *)(a1 + 166) & 0xC000) == 0x4000 )\n    {\n      puts(\"Commands/features:\\n\\tEnabled\\tSupported:\");\n      v64 = *(_WORD *)(a1 + 164);\n      LOWORD(v65) = *(_WORD *)(a1 + 170);\n      for ( n = 0; n != 48; ++n )\n      {\n        v104 = v65;\n        v67 = sub_804D2B4(byte_80C9B07, n);\n        v68 = v104;\n        if ( v64 < 0 && *v67 )\n        {\n          v69 = &data;\n          if ( (v104 & 0x8000u) != 0 )\n            v69 = \"   *\";\n          printf(\"\\t%s\\t%s\\n\", v69, v67);\n          v68 = v104;\n        }\n        v64 *= 2;\n        v65 = 2 * v68;\n        if ( (n & 0xF) == 15 )\n        {\n          v70 = 2 * ((n >> 4) + 83);\n          v64 = *(_WORD *)(a1 + v70);\n          LOWORD(v65) = *(_WORD *)(a1 + v70 + 6);\n        }\n        if ( n == 31 && (*(_WORD *)(a1 + 168) & 0xC000) != 0x4000 )\n          n = 47;\n      }\n    }\n    if ( (*(_WORD *)(a1 + 254) & 3) == 1 )\n    {\n      v71 = sub_804D2B4(byte_80C9B07, 27);\n      printf(\"\\t%s supported\\n\", v71);\n    }\n    if ( v107 > 3u && v105 != 5 && (*(_WORD *)(a1 + 256) || *(_WORD *)(a1 + 178) || *(_WORD *)(a1 + 180)) )\n    {\n      puts(\"Security:\");\n      v72 = *(unsigned __int16 *)(a1 + 184);\n      if ( (unsigned __int16)(v72 - 1) <= 0xFFFDu )\n        printf(\"\\tMaster password revision code = %u\\n\", v72);\n      v73 = *(_WORD *)(a1 + 256);\n      if ( v73 )\n      {\n        for ( ii = 0; ii != 6; ++ii )\n        {\n          v75 = sub_804D2B4(\"supported\", ii);\n          v76 = &data;\n          if ( (v73 & 1) == 0 )\n            v76 = \"not\";\n          printf(\"\\t%s\\t%s\\n\", v76, v75);\n          v73 >>= 1;\n        }\n        v77 = *(_WORD *)(a1 + 256);\n        if ( (v77 & 2) != 0 )\n        {\n          v78 = \"high\";\n          if ( (v77 & 0x10) != 0 )\n            v78 = \"maximum\";\n          printf(\"\\tSecurity level %s\\n\", v78);\n        }\n      }\n      v79 = *(_WORD *)(a1 + 178);\n      v80 = (unsigned __int8)v79;\n      v81 = *(_WORD *)(a1 + 180);\n      v82 = (unsigned __int8)v81;\n      if ( (unsigned __int8)v81 | (unsigned __int8)v79 )\n      {\n        sub_804DD98(9);\n        if ( v80 )\n        {\n          v83 = 508;\n          if ( v80 != 255 )\n            v83 = 2 * v80;\n          printf(\"%umin for %sSECURITY ERASE UNIT. \", v83, &data);\n        }\n        if ( v82 )\n        {\n          v84 = 508;\n          if ( v82 != 255 )\n            v84 = 2 * v82;\n          printf(\"%umin for %sSECURITY ERASE UNIT. \", v84, \"ENHANCED \");\n        }\n        sub_804DD98(10);\n      }\n    }\n    v85 = *(_WORD *)(a1 + 186);\n    if ( (v85 & 0xC000) == 0x4000 )\n    {\n      LOBYTE(v86) = *(_WORD *)(a1 + 186);\n      if ( (v85 & 1) == 0 )\n        v86 = HIBYTE(v85);\n      v87 = v86 & 6;\n      v88 = \" determined by the jumper\";\n      if ( v87 != 2 )\n      {\n        v88 = &data;\n        if ( v87 == 4 )\n          v88 = \" determined by CSEL\";\n      }\n      v89 = \"below\";\n      if ( (v85 & 0x2000) != 0 )\n        v89 = \"above\";\n      printf(\"HW reset results:\\n\\tCBLID- %s Vih\\n\\tDevice num = %i%s\\n\", v89, (v85 & 1) == 0, v88);\n    }\n    if ( v107 > 4u && v105 != 5 )\n    {\n      v90 = *(_WORD *)(a1 + 320);\n      if ( v90 < 0 )\n      {\n        v91 = &data;\n        if ( (v90 & 0x2000) != 0 )\n          v91 = \" and required by some commands\";\n        v92 = \"enabled\";\n        if ( (v90 & 0x1000) != 0 )\n          v92 = \"disabled\";\n        printf(\"CFA power mode 1:\\n\\t%s%s\\n\", v92, v91);\n        v93 = *(_WORD *)(a1 + 320) & 0xFFF;\n        if ( v93 )\n          printf(\"\\tMaximum current = %uma\\n\", v93);\n      }\n      if ( *(_BYTE *)(a1 + 510) == 0xA5 )\n        printf(\"Checksum: %scorrect\\n\", &data);\n    }\n    exit(0);\n  }\n  puts(\"no IORDY\");\n  v43 = *(unsigned __int16 *)(a1 + 40);\n  if ( !(_WORD)v43 )\n    goto LABEL_165;\n  if ( (unsigned __int16)v43 > 2u )\n  {\n    v44 = \" with read caching ability\";\n  }\n  else\n  {\n    v44 = &data;\n    v45 = \"single port, single-sector\";\n    if ( (_WORD)v43 == 1 )\n    {\nLABEL_164:\n      printf(\"\\tBuffer type: %04x: %s%s\\n\", v43, v45, v44);\n      goto LABEL_165;\n    }\n  }\n  v45 = \"dual port, multi-sector\";\n  goto LABEL_164;\n}\n"
        ],
        "134558242": [
            "sub_8053222",
            "0x8053222",
            "void __noreturn sub_8053222()\n{\n  int v0; // ecx\n  char *v1; // eax\n  char *v2; // edi\n  unsigned __int8 v3; // si\n  __int16 v4; // dx\n  __int16 v5[256]; // [esp+4h] [ebp-710h] BYREF\n  char v6[1296]; // [esp+204h] [ebp-510h] BYREF\n\n  sub_80B24F6(1280, v6);\n  v0 = 0;\n  v1 = v6;\n  while ( 1 )\n  {\n    v2 = v1 + 4;\n    do\n    {\n      v3 = *v1++;\n      if ( (unsigned __int8)(v3 - 48) > 9u )\n      {\n        if ( (unsigned __int8)(v3 - 97) > 5u )\n          sub_804D5E0(\"bad char: '%c' 0x%02x\", v3, (unsigned __int8)*(v1 - 1));\n        v4 = v3 - 87;\n      }\n      else\n      {\n        v4 = v3 - 48;\n      }\n      v5[v0] = 16 * v5[v0] + v4;\n    }\n    while ( v2 != v1 );\n    if ( ++v0 == 256 )\n      sub_80521C1((int)v5);\n  }\n}\n"
        ],
        "134558382": [
            "sub_80532AE",
            "0x80532ae",
            "int __usercall sub_80532AE@<eax>(unsigned __int16 *a1@<eax>)\n{\n  unsigned int i; // esi\n  int v3; // eax\n  const char *v4; // eax\n  int v5; // edi\n  int v6; // esi\n  int v7; // edx\n  const char *v8; // eax\n  const char *v9; // eax\n  char v10; // dl\n  const char *v11; // eax\n  unsigned __int16 v12; // ax\n  unsigned __int16 v13; // ax\n  const char *v14; // eax\n  unsigned __int16 v15; // ax\n  __int16 v16; // dx\n  const char *v17; // eax\n  int v18; // edx\n  const char *v19; // eax\n  unsigned int j; // esi\n  int v21; // eax\n  int v23; // [esp-4h] [ebp-10h]\n\n  printf(\n    \"\\n Model=%.40s, FwRev=%.8s, SerialNo=%.20s\\n Config={\",\n    (const char *)a1 + 54,\n    (const char *)a1 + 46,\n    (const char *)a1 + 20);\n  for ( i = 0; i != 16; ++i )\n  {\n    v3 = *a1;\n    if ( _bittest(&v3, i) )\n    {\n      v4 = sub_804D2B4(byte_80C9A23, i);\n      printf(\" %s\", v4);\n    }\n  }\n  v5 = *((unsigned __int8 *)a1 + 94);\n  v6 = a1[21] >> 1;\n  v7 = a1[20];\n  if ( (unsigned __int16)v7 > 3u )\n    v7 = 0;\n  v8 = sub_804D2B4(\"unknown\", v7);\n  printf(\n    \" }\\n RawCHS=%u/%u/%u, TrkSize=%u, SectSize=%u, ECCbytes=%u\\n BuffType=(%u) %s, BuffSize=%ukB, MaxMultSect=%u\",\n    a1[1],\n    a1[3],\n    a1[6],\n    a1[4],\n    a1[5],\n    a1[22],\n    a1[20],\n    v8,\n    v6,\n    v5);\n  if ( *((_BYTE *)a1 + 94) )\n  {\n    printf(\", MultSect=\");\n    if ( (*((_BYTE *)a1 + 119) & 1) != 0 )\n    {\n      if ( *((_BYTE *)a1 + 118) )\n        printf(\"%u\", *((unsigned __int8 *)a1 + 118));\n      else\n        printf(\"off\");\n    }\n    else\n    {\n      printf(\"?%u?\", *((unsigned __int8 *)a1 + 118));\n    }\n  }\n  sub_804DD98(10);\n  if ( (a1[53] & 1) == 0 )\n    printf(\" (maybe):\");\n  v9 = \"yes\";\n  if ( (*((_BYTE *)a1 + 99) & 2) == 0 )\n    v9 = \"no\";\n  printf(\" CurCHS=%u/%u/%u, CurSects=%lu, LBA=%s\", a1[54], a1[55], a1[56], *(_DWORD *)(a1 + 57), v9);\n  if ( (*((_BYTE *)a1 + 99) & 2) != 0 )\n    printf(\", LBAsects=%u\", *((_DWORD *)a1 + 30));\n  v10 = *((_BYTE *)a1 + 99);\n  v11 = \"no\";\n  if ( (v10 & 8) != 0 )\n  {\n    v11 = \"yes\";\n    if ( (v10 & 4) != 0 )\n      v11 = \"on/off\";\n  }\n  printf(\"\\n IORDY=%s\", v11);\n  v12 = a1[53];\n  if ( ((*((_BYTE *)a1 + 99) & 8) != 0 || (v12 & 2) != 0) && (v12 & 2) != 0 )\n    printf(\", tPIO={min:%u,w/IORDY:%u}\", a1[67], a1[68]);\n  if ( (*((_BYTE *)a1 + 99) & 1) != 0 && (a1[53] & 2) != 0 )\n    printf(\", tDMA={min:%u,rec:%u}\", a1[65], a1[66]);\n  printf(\"\\n PIO modes:  \");\n  if ( *((_BYTE *)a1 + 103) <= 5u )\n  {\n    printf(\"pio0 \");\n    if ( *((_BYTE *)a1 + 103) )\n      printf(\"pio1 \");\n    if ( *((_BYTE *)a1 + 103) > 1u )\n      printf(\"pio2 \");\n  }\n  if ( (a1[53] & 2) != 0 )\n    sub_80B0B09();\n  if ( (*((_BYTE *)a1 + 99) & 1) != 0 && *((_DWORD *)a1 + 31) )\n  {\n    printf(\"\\n DMA modes:  \");\n    sub_80B0AB7(a1[62], \"*\", 0);\n    sub_80B0AB7(a1[63], \"*\", 0);\n  }\n  v13 = a1[53];\n  if ( ((*((_BYTE *)a1 + 99) & 8) != 0 || (v13 & 2) != 0) && (v13 & 4) != 0 )\n  {\n    printf(\"\\n UDMA modes: \");\n    sub_80B0B09();\n    if ( (*((_BYTE *)a1 + 187) & 0x20) != 0 )\n      sub_80B0B09();\n  }\n  v14 = \"yes\";\n  if ( (a1[83] & 8) == 0 )\n    v14 = \"no\";\n  printf(\"\\n AdvancedPM=%s\", v14);\n  if ( (a1[83] & 8) != 0 )\n  {\n    if ( (a1[86] & 8) != 0 )\n    {\n      v15 = a1[91];\n      HIBYTE(v16) = HIBYTE(v15);\n      LOBYTE(v16) = 0;\n      if ( v16 == 0x4000 )\n        printf(\": mode=0x%02X (%u)\", (unsigned __int8)v15, (unsigned __int8)v15);\n      else\n        printf(\": unknown setting\");\n    }\n    else\n    {\n      printf(\": disabled (255)\");\n    }\n  }\n  if ( (a1[82] & 0x20) != 0 )\n  {\n    v17 = \"disabled\";\n    if ( (a1[85] & 0x20) != 0 )\n      v17 = \"enabled\";\n    printf(\" WriteCache=%s\", v17);\n  }\n  v18 = a1[81];\n  if ( (unsigned __int16)(v18 - 1) <= 0x1Eu || a1[80] && (unsigned __int16)v18 <= 0x1Fu )\n  {\n    v19 = sub_804D2B4(\"Unspecified\", v18);\n    printf(\"\\n Drive conforms to: %s: \", v19);\n    if ( (unsigned __int16)(a1[80] - 1) <= 0xFFFDu )\n    {\n      for ( j = 0; j != 16; ++j )\n      {\n        v21 = a1[80];\n        if ( _bittest(&v21, j) )\n          printf(\" ATA/ATAPI-%u\", j);\n      }\n    }\n  }\n  puts(\"\\n\\n * current active mode\\n\");\n  return v23;\n}\n"
        ],
        "134559318": [
            "sub_8053656",
            "0x8053656",
            "int sub_8053656()\n{\n  return sub_804DD09(3, 0, 0, 0);\n}\n"
        ],
        "134559335": [
            "sub_8053667",
            "0x8053667",
            "int sub_8053667()\n{\n  int result; // eax\n  int v1; // [esp-4h] [ebp-4h]\n\n  fsync(3);\n  sub_804E09D(3, 0x1261u, 0, \"BLKFLSBUF\");\n  sleep(1u);\n  result = ioctl(3, 0x31Fu, 0);\n  if ( result )\n  {\n    result = dword_80DBB7C;\n    if ( *(_DWORD *)dword_80DBB7C != 22 )\n    {\n      sub_804D3A5((int)\"HDIO_DRIVE_CMD\");\n      return v1;\n    }\n  }\n  return result;\n}\n"
        ],
        "134559414": [
            "sub_80536B6",
            "0x80536b6",
            "void __usercall sub_80536B6(int a1@<eax>)\n{\n  void *v2; // ebp\n  unsigned int v3; // edi\n  unsigned int v4; // ebx\n  unsigned int v5; // eax\n  int v6; // esi\n  unsigned int v7; // edi\n  int v8; // eax\n  int v9; // eax\n  unsigned int v10; // [esp+0h] [ebp-24h]\n  unsigned int v11; // [esp+4h] [ebp-20h]\n  int v12; // [esp+8h] [ebp-1Ch]\n  __int64 v13[3]; // [esp+Ch] [ebp-18h] BYREF\n\n  v2 = sub_804DAFA(0x100000u);\n  if ( mlock(v2, 0x100000u) )\n    sub_804D3C9((int)\"mlock\");\n  sync();\n  sleep(1u);\n  if ( a1 )\n  {\n    sub_8053656();\n    sub_805209C((int)v2);\n    printf(\"Timing buffer-cache reads: \");\n  }\n  else\n  {\n    printf(\"Timing buffered disk reads:\");\n  }\n  sub_804DD8F();\n  if ( a1 )\n  {\n    v11 = 510000;\n    v3 = -1;\n  }\n  else\n  {\n    if ( ioctl(3, 0x80041272, v13) )\n    {\n      sub_804E0BE(3, 0x1260u, (int)v13, \"BLKGETSIZE\");\n      v13[0] = LODWORD(v13[0]) >> 11;\n    }\n    else\n    {\n      v13[0] = (unsigned __int64)v13[0] >> 20;\n    }\n    v3 = v13[0];\n    if ( HIDWORD(v13[0]) )\n      v3 = -1;\n    v11 = 3000000;\n  }\n  v12 = sub_804EBDE();\n  v4 = 0;\n  do\n  {\n    if ( a1 )\n      sub_8053656();\n    sub_805209C((int)v2);\n    v5 = sub_804EBDE() - v12;\n    v10 = v5;\n    ++v4;\n  }\n  while ( v3 > v4 && v11 > v5 );\n  if ( a1 )\n  {\n    v6 = sub_804EBDE();\n    v7 = v4;\n    do\n    {\n      sub_8053656();\n      v8 = sub_804EBDE();\n      --v7;\n    }\n    while ( v7 );\n    v10 -= v8 - v6;\n    v4 *= 2;\n    sub_8053667();\n  }\n  v9 = sub_80B4B88(1024000000 * v4, (1024000000 * (unsigned __int64)v4) >> 32, v10 | 1, 0);\n  printf(\"%5u MB in %u.%02u seconds = %u kB/s\\n\", v4, v10 / 0xF4240, v10 % 0xF4240 / 0x2710, v9);\n  munlock(v2, 0x100000u);\n  free(v2);\n}\n"
        ],
        "134559825": [
            "sub_8053851",
            "0x8053851",
            "int __usercall sub_8053851@<eax>(_BYTE *a1@<eax>, char a2@<dl>)\n{\n  int result; // eax\n\n  result = ioctl(3, 0x31Fu, a1);\n  if ( result )\n  {\n    *a1 = a2;\n    return sub_804E09D(3, 0x31Fu, (int)a1, \"HDIO_DRIVE_CMD\");\n  }\n  return result;\n}\n"
        ],
        "134559882": [
            "sub_805388A",
            "0x805388a",
            "int __usercall sub_805388A@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  int v5; // [esp-4h] [ebp-8h]\n\n  printf(\" setting %s to %lu\", a1, a2);\n  v3 = \" (off)\";\n  if ( a2 )\n    v3 = \" (on)\";\n  puts(v3);\n  return v5;\n}\n"
        ],
        "134559923": [
            "sub_80538B3",
            "0x80538b3",
            "int __usercall sub_80538B3@<eax>(const char *a1@<eax>)\n{\n  int v2; // eax\n  size_t v3; // ebx\n  unsigned int v4; // ebx\n  const char *v5; // eax\n  unsigned __int8 buffer; // bl\n  int buffer_low; // esi\n  const char *v8; // eax\n  const char *v9; // eax\n  char v10; // al\n  int v12; // [esp+0h] [ebp-21Ch] BYREF\n  int v13; // [esp+4h] [ebp-218h] BYREF\n  int v14; // [esp+8h] [ebp-214h] BYREF\n  int v15[132]; // [esp+Ch] [ebp-210h] BYREF\n\n  v14 = 239;\n  v2 = sub_804DC1E(a1);\n  sub_804DC97(v2, 3);\n  printf(\"\\n%s:\\n\", a1);\n  if ( *((_BYTE *)&buf + 8) == 2 )\n  {\n    printf(\" setting %s to %lu\\n\", \"fs readahead\", *(&buf + 5));\n    sub_804E09D(3, 0x1262u, *(&buf + 5), \"BLKRASET\");\n  }\n  if ( *((_BYTE *)&buf + 6) )\n  {\n    if ( *((_BYTE *)&buf + 7) )\n    {\n      printf(\" attempting to \");\n      if ( *(&buf + 4) == 255 )\n      {\n        puts(\"auto-tune PIO mode\");\n      }\n      else if ( (int)*(&buf + 4) > 99 )\n      {\n        if ( (int)*(&buf + 4) > 199 )\n          printf(\"set UDMA mode to %d\\n\");\n        else\n          printf(\"set MDMA mode to %d\\n\");\n      }\n      else\n      {\n        printf(\"set PIO mode to %d\\n\");\n      }\n    }\n    sub_804E09D(3, 0x327u, *(&buf + 4), \"HDIO_SET_PIO_MODE\");\n  }\n  if ( *((_BYTE *)&buf + 15) == 2 )\n  {\n    printf(\" setting %s to %lu\\n\", \"32-bit IO_support flag\", *(&buf + 12));\n    sub_804E09D(3, 0x324u, *(&buf + 12), \"HDIO_SET_32BIT\");\n  }\n  if ( *((_BYTE *)&buf + 11) == 2 )\n  {\n    printf(\" setting %s to %lu\\n\", \"multcount\", *(&buf + 8));\n    sub_804E09D(3, 0x321u, *(&buf + 8), \"HDIO_SET_MULTCOUNT\");\n  }\n  if ( *((_BYTE *)&buf + 9) == 2 )\n  {\n    sub_805388A(\"readonly\", *(&buf + 6));\n    sub_804E09D(3, 0x125Du, (int)(&buf + 6), \"BLKROSET\");\n  }\n  if ( *((_BYTE *)&buf + 10) == 2 )\n  {\n    sub_805388A(\"unmaskirq\", *(&buf + 7));\n    sub_804E09D(3, 0x322u, *(&buf + 7), \"HDIO_SET_UNMASKINTR\");\n  }\n  if ( *((_BYTE *)&buf + 12) == 2 )\n  {\n    sub_805388A(\"DMA queue_depth\", *(&buf + 9));\n    sub_804E09D(3, 0x32Eu, *(&buf + 9), \"HDIO_SET_QDMA\");\n  }\n  if ( *((_BYTE *)&buf + 13) == 2 )\n  {\n    sub_805388A(\"nowerr\", *(&buf + 10));\n    sub_804E09D(3, 0x325u, *(&buf + 10), \"HDIO_SET_NOWERR\");\n  }\n  if ( *((_BYTE *)&buf + 14) == 2 )\n  {\n    sub_805388A(\"keep_settings\", *(&buf + 11));\n    sub_804E09D(3, 0x323u, *(&buf + 11), \"HDIO_SET_KEEPSETTINGS\");\n  }\n  if ( (_BYTE)dword_80DB7B4 == 2 )\n  {\n    LOBYTE(v14) = (preg.translate == 0) - 34;\n    BYTE2(v14) = 0;\n    sub_805388A(\"drive doorlock\", (int)preg.translate);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    LOBYTE(v14) = -17;\n  }\n  if ( *((_BYTE *)&buf + 54) == 2 )\n  {\n    sub_805388A(\"drive keep features\", (int)dword_80DB7C0);\n    BYTE2(v14) = dword_80DB7C0 == 0 ? -52 : 102;\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( *((_BYTE *)&buf + 58) == 2 )\n  {\n    BYTE2(v14) = preg.syntax == 0 ? -124 : 4;\n    printf(\" setting %s to %lu\\n\", \"drive defect-mgmt\", preg.syntax);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( *((_BYTE *)&buf + 57) == 2 )\n  {\n    BYTE1(v14) = preg.used;\n    BYTE2(v14) = -85;\n    printf(\" setting %s to %lu\\n\", \"drive prefetch\", preg.used);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( *((_BYTE *)&buf + 52) )\n  {\n    BYTE1(v14) = n;\n    BYTE2(v14) = 3;\n    printf(\" setting %s to %lu\\n\", \"xfermode\", n);\n    v3 = n;\n    printf(\" (\");\n    if ( v3 )\n    {\n      if ( v3 == 1 )\n      {\n        printf(\"default PIO mode, disable IORDY\");\n      }\n      else if ( v3 - 8 > 7 )\n      {\n        if ( v3 - 16 > 7 )\n        {\n          if ( v3 - 32 > 7 )\n          {\n            v4 = v3 - 64;\n            if ( v4 > 7 )\n              printf(\"unknown\");\n            else\n              printf(\"UltraDMA mode%u\", v4);\n          }\n          else\n          {\n            printf(\"multiword DMA mode%u\", v3 - 32);\n          }\n        }\n        else\n        {\n          printf(\"singleword DMA mode%u\", v3 - 16);\n        }\n      }\n      else\n      {\n        printf(\"PIO flow control mode%u\", v3 - 8);\n      }\n    }\n    else\n    {\n      printf(\"default PIO mode\");\n    }\n    puts(\")\");\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( *((_BYTE *)&buf + 56) == 2 )\n  {\n    BYTE2(v14) = preg.allocated == 0 ? 85 : -86;\n    sub_805388A(\"drive read-lookahead\", preg.allocated);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( BYTE1(seconds) == 2 )\n  {\n    BYTE2(v14) = preg.re_nsub != 255 ? 5 : -123;\n    BYTE1(v14) = preg.re_nsub;\n    v5 = &data;\n    if ( preg.re_nsub == 255 )\n      v5 = \"disabled\";\n    printf(\" setting APM level to %s 0x%02lX (%ld)\\n\", v5, preg.re_nsub, preg.re_nsub);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( *((_BYTE *)&buf + 59) == 2 )\n  {\n    BYTE2(v14) = preg.fastmap == 0 ? -126 : 2;\n    sub_805388A(\"drive write-caching\", (int)preg.fastmap);\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  BYTE2(v14) = 0;\n  if ( BYTE2(dword_80DB7B4) )\n  {\n    puts(\" issuing standby command\");\n    LOBYTE(v14) = -32;\n    sub_8053851(&v14, 148);\n  }\n  if ( HIBYTE(dword_80DB7B4) )\n  {\n    puts(\" issuing sleep command\");\n    LOBYTE(v14) = -26;\n    sub_8053851(&v14, 153);\n  }\n  if ( BYTE1(dword_80DB7B4) )\n  {\n    LOBYTE(v14) = -5;\n    puts(\" disabling Seagate auto powersaving mode\");\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n  }\n  if ( *((_BYTE *)&buf + 55) == 2 )\n  {\n    LOBYTE(v14) = -29;\n    BYTE1(v14) = preg.buffer;\n    printf(\" setting %s to %lu\\n\", \"standby\", preg.buffer);\n    buffer = (unsigned __int8)preg.buffer;\n    buffer_low = LOBYTE(preg.buffer);\n    printf(\" (\");\n    if ( buffer )\n    {\n      if ( buffer == 0xFC || buffer <= 0xF0u || buffer == 0xFF )\n      {\n        printf(\"%u minutes %u seconds\", 5 * buffer_low / 0x3Cu, 5 * buffer_low % 0x3Cu);\n      }\n      else if ( buffer <= 0xFBu )\n      {\n        printf(\"%u.%c hours\", (unsigned int)(buffer_low - 240) >> 1, (((_BYTE)buffer_low + 16) & 1) == 0 ? 48 : 53);\n      }\n      if ( buffer == 0xFD )\n      {\n        printf(\"vendor-specific\");\n      }\n      else if ( buffer == 0xFE )\n      {\n        printf(\"reserved\");\n      }\n    }\n    else\n    {\n      printf(\"off\");\n    }\n    puts(\")\");\n    sub_804E09D(3, 0x31Fu, (int)&v14, \"HDIO_DRIVE_CMD\");\n    BYTE1(v14) = 0;\n  }\n  if ( *((_BYTE *)&buf + 11) || (_BYTE)buf )\n  {\n    v13 = -1;\n    if ( ioctl(3, 0x304u, &v13) )\n    {\n      if ( *((_BYTE *)&buf + 11) )\n        sub_804D3A5((int)\"HDIO_GET_MULTCOUNT\");\n      else\n        sub_804D3A5((int)\"ioctl %#x failed\", 772);\n    }\n    else if ( *((_BYTE *)&buf + 11) )\n    {\n      printf(\" %s\\t= %2ld\", \"multcount\", v13);\n      v8 = \" (off)\";\n      if ( v13 )\n        v8 = \" (on)\";\n      puts(v8);\n    }\n  }\n  if ( *((_BYTE *)&buf + 15) && !sub_804E09D(3, 0x309u, (int)&v12, \"HDIO_GET_32BIT\") )\n  {\n    printf(\" IO_support\\t=%3ld (\", v12);\n    if ( v12 )\n    {\n      switch ( v12 )\n      {\n        case 2:\n          puts(\"16-bit)\");\n          break;\n        case 1:\n          puts(\"32-bit)\");\n          break;\n        case 3:\n          puts(\"32-bit w/sync)\");\n          break;\n        case 8:\n          puts(\"Request-Queue-Bypass)\");\n          break;\n        default:\n          puts(\"???)\");\n          break;\n      }\n    }\n    else\n    {\n      puts(\"default 16-bit)\");\n    }\n  }\n  if ( *((_BYTE *)&buf + 10) && !sub_804E09D(3, 0x302u, (int)&v12, \"HDIO_GET_UNMASKINTR\") )\n    sub_8052198(\"unmaskirq\", v12);\n  if ( *((_BYTE *)&buf + 12) && !sub_804E09D(3, 0x305u, (int)&v12, \"HDIO_GET_QDMA\") )\n    sub_8052198(\"queue_depth\", v12);\n  if ( *((_BYTE *)&buf + 14) && !sub_804E09D(3, 0x308u, (int)&v12, \"HDIO_GET_KEEPSETTINGS\") )\n    sub_8052198(\"keepsettings\", v12);\n  if ( *((_BYTE *)&buf + 13) && !sub_804E09D(3, 0x30Au, (int)&v12, \"HDIO_GET_NOWERR\") )\n    sub_8052198(\"nowerr\", v12);\n  if ( *((_BYTE *)&buf + 9) && !sub_804E09D(3, 0x125Eu, (int)&v12, \"BLKROGET\") )\n    sub_8052198(\"readonly\", v12);\n  if ( *((_BYTE *)&buf + 8) && !sub_804E09D(3, 0x1263u, (int)&v12, \"BLKRAGET\") )\n    sub_8052198(\"readahead\", v12);\n  if ( BYTE1(buf)\n    && !sub_804E09D(3, 0x1260u, (int)&v12, \"BLKGETSIZE\")\n    && !sub_804E09D(3, 0x301u, (int)v15, \"HDIO_GETGEO\") )\n  {\n    printf(\n      \" geometry\\t= %u/%u/%u, sectors = %ld, start = %ld\\n\",\n      HIWORD(v15[0]),\n      LOBYTE(v15[0]),\n      BYTE1(v15[0]),\n      v12,\n      v15[1]);\n  }\n  if ( (_BYTE)seconds )\n  {\n    LOBYTE(v14) = -27;\n    if ( sub_8053851(&v14, 152) )\n    {\n      v9 = \"unknown\";\n      if ( *(_DWORD *)dword_80DBB7C == 5 && !(_BYTE)v14 )\n      {\n        v9 = \"sleeping\";\n        if ( BYTE1(v14) )\n          v9 = \"unknown\";\n      }\n    }\n    else\n    {\n      v9 = \"standby\";\n      if ( BYTE2(v14) == 0xFF )\n        v9 = \"active/idle\";\n    }\n    *(_WORD *)((char *)&v14 + 1) = 0;\n    printf(\" drive state is:  %s\\n\", v9);\n  }\n  if ( (_BYTE)buf )\n  {\n    if ( ioctl(3, 0x30Du, v15) )\n    {\n      if ( *(_DWORD *)dword_80DBB7C == -42 )\n        puts(\" no identification info available\");\n      else\n        sub_804D3A5((int)\"HDIO_GET_IDENTITY\");\n    }\n    else\n    {\n      if ( v13 == -1 )\n      {\n        v10 = HIBYTE(v15[29]) & 0xFE;\n      }\n      else\n      {\n        BYTE2(v15[29]) = v13;\n        v10 = HIBYTE(v15[29]) | 1;\n      }\n      HIBYTE(v15[29]) = v10;\n      sub_80532AE((unsigned __int16 *)v15);\n    }\n  }\n  if ( *((_BYTE *)&preg + 28) )\n  {\n    memset(v15, 0, 0x204u);\n    LOBYTE(v15[0]) = -20;\n    HIBYTE(v15[0]) = 1;\n    if ( !sub_8053851(v15, 161) )\n      sub_80521C1((int)&v15[1]);\n  }\n  if ( *((_BYTE *)&buf + 5) )\n    sub_804E09D(3, 0x125Fu, 0, \"BLKRRPART\");\n  if ( HIBYTE(buf) )\n    sub_80536B6(1);\n  if ( *((_BYTE *)&buf + 4) )\n    sub_80536B6(0);\n  if ( BYTE2(buf) )\n    sub_8053667();\n  return close(3);\n}\n"
        ],
        "134562667": [
            "sub_805436B",
            "0x805436b",
            "int __cdecl sub_805436B(int argc, char **argv)\n{\n  int v2; // esi\n  int v3; // eax\n  int v4; // ebx\n  char **v5; // ebx\n\n  v2 = 0;\n  while ( 1 )\n  {\n    v3 = getopt(argc, argv, \"gfu::n::p:r::m::c::k::a::B:tTiIS:D:P:X:K:A:L:W:CyYzZQ:\");\n    v4 = v3;\n    if ( v3 < 0 )\n      break;\n    ++v2;\n    *((_BYTE *)&preg + 28) |= v3 == 73;\n    LOBYTE(buf) = (v3 == 105) | buf;\n    BYTE1(buf) |= v3 == 103;\n    BYTE2(buf) |= v3 == 102;\n    switch ( v3 )\n    {\n      case 'u':\n        *((_BYTE *)&buf + 10) = sub_805202C(&buf + 7);\n        break;\n      case 'n':\n        *((_BYTE *)&buf + 13) = sub_805202C(&buf + 10);\n        break;\n      case 'p':\n        *((_BYTE *)&buf + 7) = 1;\n        if ( optarg )\n        {\n          *(&buf + 4) = sub_8052044(optarg);\n          *((_BYTE *)&buf + 6) = (*(&buf + 4) & 0x80000000) == 0;\n        }\n        break;\n      case 'r':\n        *((_BYTE *)&buf + 9) = sub_805202C(&buf + 6);\n        break;\n      case 'm':\n        *((_BYTE *)&buf + 11) = sub_8052038(&buf + 8);\n        break;\n      case 'c':\n        *((_BYTE *)&buf + 15) = sub_8052038(&buf + 12);\n        break;\n      case 'k':\n        *((_BYTE *)&buf + 14) = sub_805202C(&buf + 11);\n        break;\n      case 'a':\n        *((_BYTE *)&buf + 8) = sub_8052038(&buf + 5);\n        break;\n      case 'B':\n        BYTE1(seconds) = sub_805200B(&preg.re_nsub);\n        break;\n    }\n    *((_BYTE *)&buf + 4) |= v4 == 116;\n    HIBYTE(buf) |= v4 == 84;\n    BYTE2(buf) |= HIBYTE(buf) | *((_BYTE *)&buf + 4);\n    switch ( v4 )\n    {\n      case 'S':\n        *((_BYTE *)&buf + 55) = sub_805200B(&preg);\n        break;\n      case 'D':\n        *((_BYTE *)&buf + 58) = sub_8052038(&preg.syntax);\n        break;\n      case 'P':\n        *((_BYTE *)&buf + 57) = sub_8052038(&preg.used);\n        break;\n      case 'X':\n        *((_BYTE *)&buf + 53) = 1;\n        if ( optarg )\n        {\n          n = sub_8052044(optarg);\n          *((_BYTE *)&buf + 52) = (n & 0x80000000) == 0;\n        }\n        break;\n      case 'K':\n        *((_BYTE *)&buf + 54) = sub_805202C(&preg.used);\n        break;\n      case 'A':\n        *((_BYTE *)&buf + 56) = sub_805202C(&preg.allocated);\n        break;\n      case 'L':\n        LOBYTE(dword_80DB7B4) = sub_805202C(&preg.translate);\n        break;\n      case 'W':\n        *((_BYTE *)&buf + 59) = sub_805202C(&preg.fastmap);\n        break;\n    }\n    LOBYTE(seconds) = (v4 == 67) | (unsigned __int8)seconds;\n    BYTE2(dword_80DB7B4) |= v4 == 121;\n    HIBYTE(dword_80DB7B4) |= v4 == 89;\n    *((_BYTE *)&buf + 5) |= v4 == 122;\n    BYTE1(dword_80DB7B4) |= v4 == 90;\n    if ( v4 == 81 )\n      *((_BYTE *)&buf + 12) = sub_8052038(&buf + 9);\n  }\n  if ( !v2 )\n  {\n    BYTE1(buf) = 1;\n    *((_WORD *)&buf + 7) = 257;\n    *(&buf + 2) = 16843009;\n  }\n  v5 = &argv[optind];\n  if ( !*v5 )\n  {\n    if ( !isatty(0) )\n      sub_8053222();\n    sub_804CDC2();\n  }\n  do\n    sub_80538B3(*v5++);\n  while ( *v5 );\n  return 0;\n}\n"
        ],
        "134563448": [
            "sub_8054678",
            "0x8054678",
            "int __usercall sub_8054678@<eax>(char *a1@<eax>, unsigned __int8 *a2@<edx>, __int64 a3)\n{\n  char *v5; // ecx\n  unsigned __int8 *v6; // esi\n  unsigned int v7; // edi\n  unsigned int v8; // ebp\n  __int64 v9; // rax\n  unsigned __int8 *v10; // edi\n  unsigned __int8 v11; // dl\n  int v13; // [esp+0h] [ebp-18h]\n  unsigned __int8 *v14; // [esp+4h] [ebp-14h]\n\n  v13 = sprintf(a1, \"%08llx \", a3);\n  v5 = &a1[v13];\n  v6 = (unsigned __int8 *)&a1[v13 + 48];\n  v14 = a2 + 15;\n  v7 = *(_DWORD *)(dword_80DBB80 + 32);\n  v8 = *(_DWORD *)(dword_80DBB80 + 36);\n  v9 = __PAIR64__(v8, v7) - a3;\n  if ( (int)((__PAIR64__(v8, v7) - a3) >> 32) > 0 )\n    goto LABEL_6;\n  if ( (((__PAIR64__(v8, v7) - a3) >> 32) & 0x80000000) != 0LL || !(_DWORD)v9 )\n    goto LABEL_11;\n  if ( v9 > 15 )\nLABEL_6:\n    v10 = a2 + 15;\n  else\n    v10 = &a2[v7 - 1 - a3];\n  while ( a2 <= v10 )\n  {\n    v11 = *a2++;\n    *v5 = byte_80C7B1E[v11 >> 4];\n    v5[1] = byte_80C7B1E[v11 & 0xF];\n    v5 += 3;\n    *(v5 - 1) = 32;\n    if ( (unsigned __int8)(v11 - 32) > 0x5Eu )\n      v11 = 46;\n    *v6++ = v11;\n  }\nLABEL_11:\n  while ( a2 <= v14 )\n  {\n    *v5 = 32;\n    v5[1] = 32;\n    v5 += 3;\n    *(v5 - 1) = 32;\n    *v6++ = 32;\n    ++a2;\n  }\n  *v6 = 0;\n  return v13;\n}\n"
        ],
        "134563665": [
            "sub_8054751",
            "0x8054751",
            "int sub_8054751()\n{\n  int v0; // ebx\n  unsigned __int8 *v1; // ecx\n  int v2; // ebx\n  int v3; // eax\n  char v5[100]; // [esp+0h] [ebp-64h] BYREF\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 24) & 0xF;\n  v1 = (unsigned __int8 *)(*(_DWORD *)(dword_80DBB80 + 24) - v0);\n  v2 = *(char *)dword_80DBB80 + 3 * v0;\n  v3 = sub_8054678(v5, v1, (__int64)&v1[*(_QWORD *)(dword_80DBB80 + 40) - *(_DWORD *)(dword_80DBB80 + 20)]);\n  return printf(\"%s\\r%.*s\", &v5[v3 + v2], v3 + v2, v5);\n}\n"
        ],
        "134563744": [
            "sub_80547A0",
            "0x80547a0",
            "int __usercall sub_80547A0@<eax>(unsigned int a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // eax\n  int v4; // eax\n  unsigned int v5; // edi\n  int v6; // esi\n  int v7; // edx\n  unsigned int i; // ebp\n  int v9; // edx\n  const char *v10; // eax\n  unsigned __int8 *v12; // [esp+0h] [ebp-74h]\n  unsigned int v13; // [esp+4h] [ebp-70h]\n  int v14; // [esp+8h] [ebp-6Ch]\n  char v15[104]; // [esp+Ch] [ebp-68h] BYREF\n\n  printf(\"\\x1B[H\\x1B[J\");\n  v2 = dword_80DBB80;\n  v3 = (a1 >> 4) + 1 - *(_DWORD *)(dword_80DBB80 + 8);\n  if ( v3 < 0 )\n    v3 = 0;\n  v4 = 16 * v3;\n  v12 = (unsigned __int8 *)(v4 + *(_DWORD *)(dword_80DBB80 + 20));\n  v5 = (*(_QWORD *)(dword_80DBB80 + 40) + (unsigned __int64)(unsigned int)v4) >> 32;\n  v6 = *(_DWORD *)(dword_80DBB80 + 40) + v4;\n  v13 = a1 - v4;\n  v7 = 0;\n  for ( i = 0; *(_DWORD *)(v2 + 8) > i; ++i )\n  {\n    v9 = sub_8054678(v15, v12, __SPAIR64__(v5, v6));\n    v10 = \"%s\";\n    if ( i )\n      v10 = \"\\r\\n%s\";\n    v14 = v9;\n    printf(v10, v15);\n    v12 += 16;\n    v5 = (__PAIR64__(v5, v6) + 16) >> 32;\n    v6 += 16;\n    v7 = v14;\n  }\n  *(_DWORD *)(v2 + 12) = v13 >> 4;\n  return printf(\"\\x1B[%u;%uH\", (v13 >> 4) + 1, v7 + 3 * (v13 & 0xF) + 1);\n}\n"
        ],
        "134563939": [
            "sub_8054863",
            "0x8054863",
            "int sub_8054863()\n{\n  sub_804D995((const struct termios *)(dword_80DBB80 + 64));\n  printf(\"\\x1B[?1049l\");\n  return sub_804DD8F();\n}\n"
        ],
        "134563968": [
            "sub_8054880",
            "0x8054880",
            "int __usercall sub_8054880@<eax>(int a1@<edx>, int a2)\n{\n  if ( *(_BYTE *)(dword_80DBB80 + 1) )\n  {\n    sub_8054863();\n    sub_804E761(a2);\n  }\n  byte_80DBBA4 = a2;\n  return a1;\n}\n"
        ],
        "134564008": [
            "sub_80548A8",
            "0x80548a8",
            "int __usercall sub_80548A8@<eax>(int a1@<eax>)\n{\n  void *v2; // eax\n  int v3; // ebp\n  int v4; // edx\n  unsigned int v5; // esi\n  unsigned int v6; // edi\n  __int64 v7; // rax\n\n  v2 = *(void **)(dword_80DBB80 + 20);\n  if ( v2 )\n    munmap(v2, 0x10000u);\n  v3 = mmap64(\n         0,\n         0x10000,\n         3,\n         1,\n         *(_DWORD *)(dword_80DBB80 + 4),\n         *(_DWORD *)(dword_80DBB80 + 40),\n         *(_DWORD *)(dword_80DBB80 + 44));\n  *(_DWORD *)(dword_80DBB80 + 20) = v3;\n  if ( v3 == -1 )\n  {\n    sub_8054863();\n    sub_804D3C9((int)\"mmap\");\n  }\n  *(_DWORD *)(dword_80DBB80 + 24) = v3 + a1;\n  v4 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 28) = v3 + 0x10000;\n  v5 = *(_DWORD *)(v4 + 32);\n  v6 = *(_DWORD *)(v4 + 36);\n  v7 = *(_QWORD *)(v4 + 40);\n  if ( (__int64)(__PAIR64__(v6, v5) - v7) <= 0xFFFF )\n    *(_DWORD *)(dword_80DBB80 + 28) = v3 + v5 - v7;\n  return 1;\n}\n"
        ],
        "134564186": [
            "sub_805495A",
            "0x805495a",
            "int sub_805495A()\n{\n  int v0; // esi\n  __int64 v1; // rcx\n  unsigned int v2; // eax\n\n  v0 = dword_80DBB80;\n  v1 = *(_QWORD *)(dword_80DBB80 + 40);\n  if ( *(_QWORD *)(dword_80DBB80 + 32) - v1 <= 0xFFFF )\n    return 0;\n  v2 = *(_DWORD *)(dword_80DBB80 + 24) - *(_DWORD *)(dword_80DBB80 + 20);\n  if ( v2 <= 0xFFF )\n    return 0;\n  do\n  {\n    v1 += 4096LL;\n    if ( !v1 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 40) = -4096;\n      *(_DWORD *)(v0 + 44) = -1;\n      return sub_80548A8(v2);\n    }\n    v2 -= 4096;\n  }\n  while ( v2 > 0xFFF );\n  *(_DWORD *)(dword_80DBB80 + 40) = v1;\n  *(_DWORD *)(v0 + 44) = HIDWORD(v1);\n  return sub_80548A8(v2);\n}\n"
        ],
        "134564298": [
            "sub_80549CA",
            "0x80549ca",
            "int sub_80549CA()\n{\n  int v0; // edx\n  unsigned int v2; // eax\n  __int64 v3; // rcx\n\n  v0 = dword_80DBB80;\n  if ( !*(_QWORD *)(dword_80DBB80 + 40) )\n    return 0;\n  v2 = *(_DWORD *)(dword_80DBB80 + 24) - *(_DWORD *)(dword_80DBB80 + 20) + 4096;\n  if ( v2 > 0xFFFF )\n    return sub_80548A8(*(_DWORD *)(dword_80DBB80 + 24) - *(_DWORD *)(dword_80DBB80 + 20));\n  do\n  {\n    v2 += 4096;\n    v3 = *(_QWORD *)(v0 + 40) - 4096LL;\n    *(_QWORD *)(v0 + 40) = v3;\n  }\n  while ( v3 && v2 <= 0xFFFF );\n  return sub_80548A8(v2 - 4096);\n}\n"
        ],
        "134564393": [
            "sub_8054A29",
            "0x8054a29",
            "int __usercall sub_8054A29@<eax>(int a1@<esi>, int a2, int a3)\n{\n  char *v3; // ebx\n  size_t v4; // edi\n  char *v5; // eax\n  int v6; // eax\n  int v7; // edx\n  int v8; // ebx\n  int v9; // edi\n  __int64 v10; // rax\n  _BYTE *v11; // edx\n  char v12; // al\n  unsigned __int8 *v13; // edx\n  unsigned __int8 *v14; // ecx\n  unsigned __int8 v15; // al\n  _BYTE *v16; // ecx\n  int v17; // eax\n  unsigned __int8 *v18; // edx\n  int v19; // edi\n  _BYTE *v20; // ecx\n  int v21; // eax\n  _BYTE *v22; // edx\n  unsigned int v23; // eax\n  unsigned int v24; // eax\n  unsigned int v25; // eax\n  _BYTE *v26; // edx\n  int v27; // eax\n  int v28; // eax\n  int v29; // eax\n  __int64 v30; // rax\n  unsigned int v31; // edi\n  unsigned int v32; // ebp\n  unsigned int v33; // edi\n  __int64 v34; // rax\n  unsigned int v36; // [esp+0h] [ebp-34h]\n  int v37; // [esp+4h] [ebp-30h]\n  char v38[44]; // [esp+8h] [ebp-2Ch] BYREF\n\n  v3 = (char *)sub_804DB2E(0x7Cu);\n  dword_80DBB80 = (int)v3;\n  sub_804D878(-1, 0, (int *)v3 + 2);\n  v4 = 88 * (*((_DWORD *)v3 + 2) | 0xF);\n  v5 = (char *)sub_804DAFA(v4);\n  setvbuf(stdout, v5, 0, v4);\n  sub_80ABEAC(a3, \"^\");\n  v6 = sub_804DBE1(*(const char **)(a3 + 4 * optind));\n  *((_DWORD *)v3 + 1) = v6;\n  *((_DWORD *)v3 + 8) = sub_804DD09(v6, 0, 0, 2);\n  *((_DWORD *)v3 + 9) = v7;\n  printf(\"\\x1B[?1049h\");\n  sub_804DA14(6, (struct termios *)(v3 + 64), 0);\n  sub_804E6C8(117503054, (void (*)(int))sub_8054880);\n  sub_80548A8(0);\n  sub_80547A0(0);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\nLABEL_2:\n      sub_804DD8F();\n      v8 = dword_80DBB80;\n      *(_BYTE *)(dword_80DBB80 + 1) = 1;\n      if ( !byte_80DBBA4 )\n        a1 = sub_80B20CC(-1, v8 + 48, v36, v37);\n      *(_BYTE *)(v8 + 1) = 0;\n      if ( byte_80DBBA4 )\n        a1 = 24;\n      if ( (unsigned int)(a1 - 65) <= 0x19 )\n        a1 |= 0x20u;\n      if ( a1 == 10 )\n        break;\n      if ( a1 > 10 )\n      {\n        if ( a1 > 57 )\n        {\n          if ( (unsigned int)(a1 - 97) <= 5 )\n          {\n            a1 -= 39;\n            goto LABEL_26;\n          }\n        }\n        else if ( a1 >= 48 )\n        {\nLABEL_26:\n          if ( *(_DWORD *)(v8 + 24) != *(_DWORD *)(v8 + 28) || sub_805495A() )\n            goto LABEL_32;\n          v10 = *(_QWORD *)(v8 + 32) + 1LL;\n          *(_QWORD *)(v8 + 32) = v10;\n          if ( v10 <= 0 || ftruncate64(*(_DWORD *)(v8 + 4), v10, HIDWORD(v10)) )\n          {\n            --*(_QWORD *)(v8 + 32);\n          }\n          else\n          {\n            ++*(_DWORD *)(v8 + 28);\nLABEL_32:\n            a1 -= 48;\n            v11 = *(_BYTE **)(v8 + 24);\n            v12 = *v11 & 0xF0;\n            if ( !*(_BYTE *)v8 )\n            {\n              v12 = *v11 & 0xF;\n              a1 *= 16;\n            }\n            *v11 = a1 + v12;\n            sub_8054751();\nLABEL_35:\n            v13 = *(unsigned __int8 **)(v8 + 24);\n            v14 = *(unsigned __int8 **)(v8 + 28);\n            if ( v13 != v14 )\n            {\n              v15 = *v13;\n              if ( *(_BYTE *)v8 )\n              {\n                *(_BYTE *)v8 = 0;\n                v18 = v13 + 1;\n                *(_DWORD *)(v8 + 24) = v18;\n                if ( ((unsigned __int8)v18 & 0xF) != 0 )\n                {\n                  v20 = *(_BYTE **)(_stdout + 16);\n                  v21 = (unsigned __int8)byte_80C7B1E[v15 & 0xF];\n                  if ( (unsigned int)v20 >= *(_DWORD *)(_stdout + 28) )\n                  {\n                    __fputc_unlocked(v21, _stdout);\n                  }\n                  else\n                  {\n                    *(_DWORD *)(_stdout + 16) = v20 + 1;\n                    *v20 = v21;\n                  }\n                  v22 = *(_BYTE **)(_stdout + 16);\n                  if ( (unsigned int)v22 >= *(_DWORD *)(_stdout + 28) )\n                  {\n                    __fputc_unlocked(32, _stdout);\n                  }\n                  else\n                  {\n                    *(_DWORD *)(_stdout + 16) = v22 + 1;\n                    *v22 = 32;\n                  }\n                }\n                else\n                {\n                  if ( v14 == v18 )\n                    sub_805495A();\n                  printf(\"\\x1B[46D\");\n                  v19 = 1;\n                  while ( 1 )\n                  {\n                    v26 = *(_BYTE **)(_stdout + 16);\n                    if ( (unsigned int)v26 >= *(_DWORD *)(_stdout + 28) )\n                    {\n                      __fputc_unlocked(10, _stdout);\n                    }\n                    else\n                    {\n                      *(_DWORD *)(_stdout + 16) = v26 + 1;\n                      *v26 = 10;\n                    }\n                    v27 = *(_DWORD *)(v8 + 12);\n                    *(_DWORD *)(v8 + 12) = v27 + 1;\n                    if ( (unsigned int)(v27 + 1) >= *(_DWORD *)(v8 + 8) )\n                    {\n                      *(_DWORD *)(v8 + 12) = v27;\n                      sub_8054751();\n                    }\n                    if ( !--v19 )\n                      break;\nLABEL_52:\n                    v23 = *(_DWORD *)(v8 + 24) + 16;\n                    *(_DWORD *)(v8 + 24) = v23;\n                    if ( v23 >= *(_DWORD *)(v8 + 28) )\n                    {\n                      sub_805495A();\n                      v24 = *(_DWORD *)(v8 + 24);\n                      if ( v24 > *(_DWORD *)(v8 + 28) )\n                      {\n                        v25 = v24 - 16;\n                        *(_DWORD *)(v8 + 24) = v25;\n                        if ( v25 < *(_DWORD *)(v8 + 20) )\n                          sub_80549CA();\n                        goto LABEL_2;\n                      }\n                    }\n                  }\n                }\n              }\n              else\n              {\n                *(_BYTE *)v8 = 1;\n                v16 = *(_BYTE **)(_stdout + 16);\n                v17 = (unsigned __int8)byte_80C7B1E[v15 >> 4];\n                if ( (unsigned int)v16 >= *(_DWORD *)(_stdout + 28) )\n                {\n                  __fputc_unlocked(v17, _stdout);\n                }\n                else\n                {\n                  *(_DWORD *)(_stdout + 16) = v16 + 1;\n                  *v16 = v17;\n                }\n              }\n            }\n          }\n        }\n        else\n        {\n          if ( a1 == 13 )\n            break;\n          if ( a1 == 24 )\n            goto LABEL_88;\n        }\n      }\n      else if ( a1 == -5 )\n      {\n        if ( *(_BYTE *)v8 )\n        {\n          *(_BYTE *)v8 = 0;\n          printf(\"\\x1B[D\");\n        }\n        else\n        {\n          v28 = *(_DWORD *)(v8 + 24);\n          if ( (v28 & 0xF) != 0 )\n          {\n            *(_BYTE *)v8 = 1;\n            *(_DWORD *)(v8 + 24) = v28 - 1;\n            printf(\"\\x1B[2D\");\n          }\n          else if ( v28 != *(_DWORD *)(v8 + 20) || sub_80549CA() )\n          {\n            *(_BYTE *)v8 = 1;\n            --*(_DWORD *)(v8 + 24);\n            printf(\"\\x1B[46C\");\n            v9 = 1;\n            while ( 1 )\n            {\n              v29 = *(_DWORD *)(v8 + 12);\n              if ( v29 )\n              {\n                *(_DWORD *)(v8 + 12) = v29 - 1;\n                printf(\"\\x1B[A\");\n              }\n              else\n              {\n                printf(\"\\x1BM\");\n                sub_8054751();\n              }\n              if ( !--v9 )\n                break;\nLABEL_76:\n              if ( *(_DWORD *)(v8 + 24) - *(_DWORD *)(v8 + 20) <= 15 && !sub_80549CA() )\n                goto LABEL_2;\n              *(_DWORD *)(v8 + 24) -= 16;\n            }\n          }\n        }\n      }\n      else if ( a1 > -5 )\n      {\n        if ( a1 == -3 )\n        {\n          v19 = 1;\n          goto LABEL_52;\n        }\n        if ( a1 < -3 )\n          goto LABEL_35;\n        if ( a1 == -2 )\n        {\n          v9 = 1;\n          goto LABEL_76;\n        }\n      }\n      else\n      {\n        if ( a1 == -11 )\n        {\n          v19 = *(_DWORD *)(v8 + 8);\n          goto LABEL_52;\n        }\n        if ( a1 == -10 )\n        {\n          v9 = *(_DWORD *)(v8 + 8);\n          goto LABEL_76;\n        }\n      }\n    }\n    printf(\"\\x1B[999;1H\\x1B[K\");\n    if ( (int)sub_80AED5C(28) <= 0 )\n      break;\n    v30 = sub_804EC9E(v38, 0, 0);\n    v31 = *(_DWORD *)(v8 + 32);\n    v32 = *(_DWORD *)(v8 + 36);\n    if ( __SPAIR64__(v32, v31) <= v30 )\n      v30 = __PAIR64__(v32, v31) - 1;\n    v33 = v30 & 0xFFF;\n    v36 = v33;\n    v37 = 0;\n    v34 = v30 - (v30 & 0xFFF);\n    if ( v34 < 0 )\n    {\n      v33 = 0;\n      v34 = 0LL;\n    }\n    else if ( v34 && v33 <= 0x1FE )\n    {\n      v34 -= 4096LL;\n      v33 += 4096;\n    }\n    *(_QWORD *)(v8 + 40) = v34;\n    sub_80548A8(v33);\n    sub_80547A0(v33);\n  }\nLABEL_88:\n  sub_8054863();\n  return 0;\n}\n"
        ],
        "134565549": [
            "sub_8054EAD",
            "0x8054ead",
            "int sub_8054EAD()\n{\n  return sub_80B4093(0xFFFFF);\n}\n"
        ],
        "134565567": [
            "sub_8054EBF",
            "0x8054ebf",
            "int __usercall sub_8054EBF@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  char s[28]; // [esp+0h] [ebp-1Ch] BYREF\n\n  sprintf(s, \"/dev/i2c-%d\", a1);\n  result = open64(s);\n  if ( result < 0 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n      sub_804D3C9((int)\"can't open '%s'\", s);\n    s[8] = 47;\n    return sub_804DBE1(s);\n  }\n  return result;\n}\n"
        ],
        "134565647": [
            "sub_8054F0F",
            "0x8054f0f",
            "int __usercall sub_8054F0F@<eax>(int result@<eax>, int a2@<edx>, const char *a3@<ecx>)\n{\n  int v4; // [esp-4h] [ebp-8h]\n\n  if ( a2 && (result & 9) == 0 )\n  {\n    sub_804D5F4(\"warning: adapter does not support PEC\");\n    result = v4;\n  }\n  if ( a3 )\n    sub_804D5E0(\"adapter has no %s capability\", a3);\n  return result;\n}\n"
        ],
        "134565686": [
            "sub_8054F36",
            "0x8054f36",
            "int __usercall sub_8054F36@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5)\n{\n  const char *v7; // ecx\n  int v9; // [esp+0h] [ebp-Ch] BYREF\n\n  v9 = a4;\n  sub_804E029(a1, 0x705u, (int)&v9, \"can't get adapter functionality matrix\");\n  switch ( a2 )\n  {\n    case 1:\n      v7 = \"SMBus receive byte\";\n      if ( (v9 & 0x20000) != 0 )\n      {\n        v7 = 0;\n        if ( a3 >= 0 && (v9 & 0x40000) == 0 )\n          v7 = \"SMBus send byte\";\n      }\n      break;\n    case 2:\n      v7 = 0;\n      if ( (v9 & 0x80000) == 0 )\n        v7 = \"SMBus read byte\";\n      break;\n    case 3:\n      v7 = 0;\n      if ( (v9 & 0x200000) == 0 )\n        v7 = \"SMBus read word\";\n      break;\n    case 5:\n      v7 = 0;\n      if ( (v9 & 0x1000000) == 0 )\n        v7 = \"SMBus block read\";\n      break;\n    case 8:\n      v7 = 0;\n      if ( (v9 & 0x4000000) == 0 )\n        v7 = \"I2C block read\";\n      break;\n    default:\n      sub_804D5E0(\"internal error\");\n  }\n  sub_8054F0F(v9, a5, v7);\n  return v9;\n}\n"
        ],
        "134565855": [
            "sub_8054FDF",
            "0x8054fdf",
            "int __usercall sub_8054FDF@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  return sub_804E029(a1, a3 == 0 ? 1795 : 1798, a2, \"can't set address to 0x%02x\", a2);\n}\n"
        ],
        "134565887": [
            "sub_8054FFF",
            "0x8054fff",
            "int sub_8054FFF()\n{\n  int result; // eax\n\n  fputs(\"Continue? [y/N] \", stderr);\n  result = sub_80A96FD();\n  if ( !result )\n    sub_804D5E0(\"aborting\");\n  return result;\n}\n"
        ],
        "134565925": [
            "sub_8055025",
            "0x8055025",
            "int __usercall sub_8055025@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)\n{\n  sub_804D5F4(\"WARNING! This program can confuse your I2C bus\");\n  if ( (unsigned int)(a1 - 80) > 7 )\n  {\n    if ( a2 == 1 && a3 >= 0 )\n    {\n      if ( !a4 )\n        return sub_8054FFF();\n      sub_804D5F4(\"WARNING! May interpret a write byte command with PEC as a write byte data command\");\n    }\n    else if ( !a4 )\n    {\n      return sub_8054FFF();\n    }\n    sub_804D5F4(\"PEC checking enabled\");\n    return sub_8054FFF();\n  }\n  if ( a4 )\n    sub_804D5E0(\"this is I2C not smbus - using PEC on I2C devices may result in data loss, aborting\");\n  return sub_8054FFF();\n}\n"
        ],
        "134566020": [
            "sub_8055084",
            "0x8055084",
            "int __usercall sub_8055084@<eax>(int a1@<eax>, char a2@<dl>, char a3@<cl>, int a4, int a5)\n{\n  char v6[4]; // [esp+0h] [ebp-Ch] BYREF\n  int v7; // [esp+4h] [ebp-8h]\n  int v8; // [esp+8h] [ebp-4h]\n\n  v6[0] = a2;\n  v6[1] = a3;\n  v7 = a4;\n  v8 = a5;\n  return ioctl(a1, 0x720u, v6);\n}\n"
        ],
        "134566062": [
            "sub_80550AE",
            "0x80550ae",
            "int __usercall sub_80550AE@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  char v2[34]; // [esp+2h] [ebp-22h] BYREF\n\n  result = sub_8055084(a1, 1, 0, 1, (int)v2);\n  if ( result >= 0 )\n    return (unsigned __int8)v2[0];\n  return result;\n}\n"
        ],
        "134566099": [
            "sub_80550D3",
            "0x80550d3",
            "int __usercall sub_80550D3@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int result; // eax\n  unsigned __int16 v3[17]; // [esp+2h] [ebp-22h] BYREF\n\n  result = sub_8055084(a1, 1, a2, 3, (int)v3);\n  if ( result >= 0 )\n    return v3[0];\n  return result;\n}\n"
        ],
        "134566137": [
            "sub_80550F9",
            "0x80550f9",
            "int __usercall sub_80550F9@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int result; // eax\n  char v3[34]; // [esp+2h] [ebp-22h] BYREF\n\n  result = sub_8055084(a1, 1, a2, 2, (int)v3);\n  if ( result >= 0 )\n    return (unsigned __int8)v3[0];\n  return result;\n}\n"
        ],
        "134566175": [
            "sub_805511F",
            "0x805511f",
            "void __noreturn sub_805511F()\n{\n  int v0; // edx\n  FILE *v1; // ecx\n  DIR *v2; // esi\n  int v3; // eax\n  const char *v4; // ebx\n  DIR *v5; // edi\n  int v6; // eax\n  _BYTE *v7; // eax\n  int v8; // edi\n  char *v9; // eax\n  int v10; // ebx\n  int v11; // edi\n  int v12; // [esp-4h] [ebp-1A0h]\n  FILE *v13; // [esp-4h] [ebp-1A0h]\n  FILE *stream; // [esp+0h] [ebp-19Ch]\n  FILE *streama; // [esp+0h] [ebp-19Ch]\n  int v16; // [esp+4h] [ebp-198h] BYREF\n  int v17; // [esp+8h] [ebp-194h] BYREF\n  char v18[128]; // [esp+Dh] [ebp-18Fh] BYREF\n  char s[271]; // [esp+8Dh] [ebp-10Fh] BYREF\n\n  v2 = sub_804DF7E(\"/sys/class/i2c-dev\");\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      do\n      {\nLABEL_2:\n        v3 = readdir64(v1, v0, v2);\n        v0 = v12;\n        if ( !v3 )\n          exit(0);\n      }\n      while ( *(_BYTE *)(v3 + 19) == 46 );\n      v4 = (const char *)(v3 + 19);\n      snprintf(s, 0xFFu, \"%s/%s/name\", \"/sys/class/i2c-dev\", (const char *)(v3 + 19));\n      v0 = fopen64(s, \"r\");\n      if ( v0 )\n        break;\n      snprintf(s, 0xFFu, \"%s/%s/device/name\", \"/sys/class/i2c-dev\", v4);\n      v0 = fopen64(s, \"r\");\n      if ( v0 )\n        break;\n      snprintf(s, 0xFFu, \"%s/%s/device/name\", \"/sys/class/i2c-dev\", v4);\n      v5 = opendir(s);\n      if ( v5 )\n      {\n        while ( 1 )\n        {\n          v6 = readdir64(v1, v0, v5);\n          v1 = v13;\n          if ( !v6 )\n            goto LABEL_2;\n          if ( *(_BYTE *)(v6 + 19) != 46 )\n          {\n            stream = (FILE *)(v6 + 19);\n            v7 = sub_804D210((_BYTE *)(v6 + 19), \"i2c-\");\n            v1 = stream;\n            if ( v7 )\n              break;\n          }\n        }\n        snprintf(s, 0xFFu, \"%s/%s/device/%s/name\", \"/sys/class/i2c-dev\", v4, (const char *)stream);\n        v0 = fopen64(s, \"r\");\n        if ( v0 )\n          break;\n      }\n    }\n    memset(v18, 0, sizeof(v18));\n    streama = (FILE *)v0;\n    v8 = fgets_unlocked(v18, 128, v0);\n    fclose(streama);\n    if ( v8 )\n    {\n      v9 = strchr(v18, 10);\n      if ( v9 )\n        *v9 = 0;\n      if ( sscanf(v4, \"i2c-%d\", &v16) == 1 )\n      {\n        v10 = 1;\n        if ( !sub_804D210(v18, \"ISA\") )\n        {\n          v11 = sub_8054EBF(v16);\n          sub_804E029(v11, 0x705u, (int)&v17, \"can't get adapter functionality matrix\");\n          v10 = 2;\n          if ( (v17 & 1) == 0 )\n            v10 = (v17 & 0x7E0000) != 0 ? 3 : 0;\n          close(v11);\n        }\n        printf(\"i2c-%d\\t%-10s\\t%-32s\\t%s\\n\", v16, off_80B5500[2 * v10], v18, off_80B5504[2 * v10]);\n      }\n    }\n  }\n}\n"
        ],
        "134566686": [
            "sub_805531E",
            "0x805531e",
            "int __cdecl sub_805531E(int a1, int a2)\n{\n  int v2; // esi\n  int v3; // edi\n  int v4; // ebx\n  char *v5; // eax\n  char v6; // dl\n  int v7; // esi\n  int v8; // ebp\n  int v9; // edi\n  int v10; // eax\n  int v11; // ebx\n  char v13; // [esp+0h] [ebp-18h]\n  int v14; // [esp+4h] [ebp-14h]\n\n  v13 = sub_80ABEAC(a2, \"^fy\");\n  v2 = a2 + 4 * optind;\n  v3 = sub_8054EAD();\n  v14 = sub_80B4093(119);\n  if ( *(_DWORD *)(v2 + 8) )\n  {\n    v4 = sub_80B4093(255);\n    v5 = *(char **)(v2 + 12);\n    if ( v5 )\n    {\n      v6 = *v5;\n      if ( *v5 == 99 )\n      {\n        v7 = 1;\n      }\n      else if ( v6 == 119 )\n      {\n        v7 = 3;\n      }\n      else\n      {\n        if ( v6 != 98 )\n        {\n          sub_804D5F4(\"invalid mode\");\n          sub_804CDC2();\n        }\n        v7 = 2;\n      }\n      v8 = v5[1] == 112;\n    }\n    else\n    {\n      v8 = 0;\n      v7 = 2;\n    }\n  }\n  else\n  {\n    v8 = 0;\n    v7 = 1;\n    v4 = -1;\n  }\n  v9 = sub_8054EBF(v3);\n  sub_8054F36(v9, v7, v4, v4, v8);\n  sub_8054FDF(v9, v14, v13 & 1);\n  if ( (v13 & 2) == 0 )\n    sub_8055025(v14, v7, v4, v8);\n  if ( v8 )\n    sub_804E029(v9, 0x708u, 1, \"can't set PEC\");\n  if ( v7 == 1 )\n  {\n    if ( v4 >= 0 && sub_8055084(v9, 0, v4, 1, 0) < 0 )\n      sub_804D5F4(\"warning - write failed\");\n    v10 = sub_80550AE(v9);\n  }\n  else if ( v7 == 3 )\n  {\n    v10 = sub_80550D3(v9, v4);\n  }\n  else\n  {\n    v10 = sub_80550F9(v9, v4);\n  }\n  v11 = v10;\n  close(v9);\n  if ( v11 < 0 )\n    sub_804D3C9((int)\"read failed\");\n  printf(\"0x%0*x\\n\", 2 * (v7 == 3) + 2, v11);\n  return 0;\n}\n"
        ],
        "134567088": [
            "sub_80554B0",
            "0x80554b0",
            "int __cdecl sub_80554B0(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // edi\n  _BYTE *v4; // eax\n  char *v5; // ecx\n  char v6; // dl\n  int v7; // ebp\n  int v8; // ebx\n  int i; // esi\n  int v10; // edi\n  const char *v11; // ecx\n  int v12; // eax\n  int v13; // eax\n  int v14; // eax\n  int fd; // [esp+0h] [ebp-74h]\n  int fda; // [esp+0h] [ebp-74h]\n  unsigned int v18; // [esp+4h] [ebp-70h]\n  int v19; // [esp+8h] [ebp-6Ch]\n  int v20; // [esp+Ch] [ebp-68h]\n  char v21; // [esp+10h] [ebp-64h]\n  int v22; // [esp+14h] [ebp-60h]\n  int v23; // [esp+1Ch] [ebp-58h] BYREF\n  char v24[32]; // [esp+20h] [ebp-54h] BYREF\n  int v25[13]; // [esp+40h] [ebp-34h] BYREF\n\n  v23 = 0;\n  v21 = sub_80ABEAC(a2, \"^fym:r\", &v23);\n  v2 = a2 + 4 * optind;\n  v3 = a1 - optind - 1;\n  fd = sub_8054EAD();\n  v22 = sub_80B4093(119);\n  v20 = sub_80B4093(255);\n  v4 = *(_BYTE **)(v2 + 12);\n  if ( v4 )\n  {\n    if ( *(_DWORD *)(v2 + 16) || *v4 == 99 )\n    {\n      v5 = *(char **)(v2 + 4 * v3);\n      v6 = *v5;\n      if ( *v5 == 105 )\n      {\n        v7 = 8;\n      }\n      else if ( (unsigned __int8)*v5 > 0x69u )\n      {\n        if ( v6 == 115 )\n        {\n          v7 = 5;\n        }\n        else\n        {\n          v7 = 3;\n          if ( v6 != 119 )\n          {\nLABEL_14:\n            sub_804D5F4(\"invalid mode\", fd);\n            sub_804CDC2();\n          }\n        }\n      }\n      else if ( v6 == 98 )\n      {\n        v7 = 2;\n      }\n      else\n      {\n        if ( v6 != 99 )\n          goto LABEL_14;\n        v7 = 1;\n      }\n      v19 = v5[1] == 112;\n      switch ( v7 )\n      {\n        case 5:\n          goto LABEL_23;\n        case 8:\n          if ( v5[1] == 112 )\n            sub_804D5E0(\"PEC not supported for I2C block writes\", fd);\nLABEL_23:\n          if ( (v21 & 4) != 0 )\n            sub_804D5E0(\"mask not supported for block writes\", fd);\n          for ( i = 3; ; ++i )\n          {\n            v18 = i - 3;\n            if ( i >= v3 )\n              break;\n            v24[i - 3] = sub_80B4093(255);\n          }\n          goto LABEL_37;\n        case 3:\n          v8 = sub_80B4093(0xFFFF);\n          v7 = 3;\n          goto LABEL_32;\n      }\n      if ( v7 != 2 )\n        goto LABEL_36;\n    }\n    else\n    {\n      v19 = 0;\n    }\n    v8 = sub_80B4093(255);\n    v7 = 2;\nLABEL_32:\n    v18 = 0;\n    goto LABEL_38;\n  }\n  v19 = 0;\n  v7 = 1;\nLABEL_36:\n  v18 = 0;\nLABEL_37:\n  v8 = -1;\nLABEL_38:\n  v10 = 0;\n  if ( (v21 & 4) != 0 )\n    v10 = sub_80B4093((unsigned int)(v7 - 1) < 2 ? 255 : 0xFFFF);\n  fda = sub_8054EBF(fd);\n  sub_804E029(fda, 0x705u, (int)v25, \"can't get adapter functionality matrix\");\n  v11 = 0;\n  switch ( v7 )\n  {\n    case 1:\n      if ( (v25[0] & 0x40000) == 0 )\n        v11 = \"SMBus send byte\";\n      break;\n    case 2:\n      if ( (v25[0] & 0x100000) == 0 )\n        v11 = \"SMBus write byte\";\n      break;\n    case 3:\n      if ( (v25[0] & 0x400000) == 0 )\n        v11 = \"SMBus write word\";\n      break;\n    case 5:\n      if ( (v25[0] & 0x2000000) == 0 )\n        v11 = \"SMBus block write\";\n      break;\n    case 8:\n      if ( (v25[0] & 0x8000000) == 0 )\n        v11 = \"I2C block write\";\n      break;\n    default:\n      break;\n  }\n  sub_8054F0F(v25[0], v19, v11);\n  sub_8054FDF(fda, v22, v21 & 1);\n  if ( (v21 & 2) == 0 )\n    sub_8055025(v22, v7, v20, v19);\n  if ( (v21 & 4) != 0 )\n  {\n    if ( v7 == 1 )\n    {\n      v12 = sub_80550AE(fda);\n    }\n    else if ( v7 == 3 )\n    {\n      v12 = sub_80550D3(fda, v20);\n    }\n    else\n    {\n      v12 = sub_80550F9(fda, v20);\n    }\n    if ( v12 < 0 )\n      sub_804D3C9((int)\"can't read old value\");\n    v8 = v12 ^ v10 & (v12 ^ v8);\n    if ( (v21 & 2) == 0 )\n    {\n      sub_804D5F4(\n        \"old value 0x%0*x, write mask 0x%0*x, will write 0x%0*x to register 0x%02x\",\n        2 * (v7 == 3) + 2,\n        v12,\n        2 * (v7 == 3) + 2,\n        v10,\n        2 * (v7 == 3) + 2,\n        v8,\n        v20);\n      sub_8054FFF();\n    }\n  }\n  if ( v19 )\n    sub_804E029(fda, 0x708u, 1, \"can't set PEC\");\n  if ( v7 == 3 )\n  {\n    LOWORD(v25[0]) = v8;\n    v13 = sub_8055084(fda, 0, v20, 3, (int)v25);\n  }\n  else if ( v7 > 3 )\n  {\n    qmemcpy((char *)v25 + 1, v24, v18);\n    LOBYTE(v25[0]) = v18;\n    if ( v7 == 5 )\n      v13 = sub_8055084(fda, 0, v20, 5, (int)v25);\n    else\n      v13 = sub_8055084(fda, 0, v20, 6, (int)v25);\n  }\n  else if ( v7 == 1 )\n  {\n    v13 = sub_8055084(fda, 0, v20, 1, 0);\n  }\n  else\n  {\n    LOBYTE(v25[0]) = v8;\n    v13 = sub_8055084(fda, 0, v20, 2, (int)v25);\n  }\n  if ( v13 < 0 )\n    sub_804D3C9(135047154);\n  if ( v19 )\n    sub_804E029(fda, 0x708u, 0, \"can't set PEC\");\n  if ( (v21 & 8) != 0 )\n  {\n    if ( v7 == 1 )\n    {\n      v14 = sub_80550AE(fda);\n      v8 = v20;\n    }\n    else if ( v7 == 3 )\n    {\n      v14 = sub_80550D3(fda, v20);\n    }\n    else\n    {\n      v14 = sub_80550F9(fda, v20);\n    }\n    if ( v14 >= 0 )\n    {\n      if ( v8 == v14 )\n        printf(\"Value 0x%0*x written, readback matched\\n\", 2 * (v7 == 3) + 2, v8);\n      else\n        printf(\n          \"Warning - data mismatch - wrote 0x%0*x, read back 0x%0*x\\n\",\n          2 * (v7 == 3) + 2,\n          v8,\n          2 * (v7 == 3) + 2,\n          v14);\n    }\n    else\n    {\n      puts(\"Warning - readback failed\");\n    }\n  }\n  return 0;\n}\n"
        ],
        "134568282": [
            "sub_805595A",
            "0x805595a",
            "int __cdecl sub_805595A(int a1, int a2)\n{\n  char v2; // di\n  int v3; // ebx\n  char *v4; // edx\n  char v5; // al\n  int v6; // ebx\n  int v7; // ebp\n  int v8; // esi\n  unsigned int v9; // eax\n  int v10; // ebx\n  int i; // eax\n  int j; // esi\n  int k; // eax\n  int m; // eax\n  int n; // edi\n  int ii; // esi\n  int v17; // eax\n  int v18; // eax\n  int v19; // eax\n  unsigned int v20; // esi\n  int v21; // eax\n  unsigned int v22; // esi\n  int v23; // eax\n  unsigned int v25; // [esp+0h] [ebp-560h]\n  int fd; // [esp+4h] [ebp-55Ch]\n  int fda; // [esp+4h] [ebp-55Ch]\n  unsigned int v28; // [esp+8h] [ebp-558h]\n  int v29; // [esp+Ch] [ebp-554h]\n  int *v30; // [esp+Ch] [ebp-554h]\n  int v31; // [esp+10h] [ebp-550h]\n  int *v32; // [esp+1Ch] [ebp-544h]\n  char *nptr; // [esp+28h] [ebp-538h] BYREF\n  char *endptr[73]; // [esp+2Ch] [ebp-534h] BYREF\n  int v35[260]; // [esp+150h] [ebp-410h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^fyr:\", &nptr);\n  v3 = a2 + 4 * optind;\n  fd = sub_8054EAD();\n  v29 = sub_80B4093(119);\n  v4 = *(char **)(v3 + 8);\n  if ( !v4 )\n  {\n    v8 = 0;\n    v6 = 0;\n    v7 = 2;\n    goto LABEL_25;\n  }\n  v5 = *v4;\n  if ( *v4 == 99 )\n  {\n    v6 = 0;\n    v7 = 1;\n  }\n  else\n  {\n    if ( (unsigned __int8)*v4 <= 0x63u )\n    {\n      if ( v5 != 87 )\n      {\n        if ( v5 != 98 )\nLABEL_15:\n          sub_804D5E0(\"invalid mode\");\n        v6 = 0;\n        v7 = 2;\n        goto LABEL_18;\n      }\n      v6 = 1;\nLABEL_13:\n      v7 = 3;\n      goto LABEL_18;\n    }\n    if ( v5 != 115 )\n    {\n      if ( v5 != 119 )\n      {\n        if ( v5 != 105 )\n          goto LABEL_15;\n        v6 = 0;\n        v7 = 8;\n        goto LABEL_18;\n      }\n      v6 = 0;\n      goto LABEL_13;\n    }\n    v6 = 0;\n    v7 = 5;\n  }\nLABEL_18:\n  if ( v4[1] == 112 )\n  {\n    if ( v5 == 87 || v5 == 105 )\n      sub_804D5E0(\"pec not supported for -W and -i\");\n    v8 = 1;\n  }\n  else\n  {\n    v8 = 0;\n  }\nLABEL_25:\n  v25 = v2 & 4;\n  if ( (v2 & 4) != 0 )\n  {\n    v25 = strtol(nptr, endptr, 0);\n    if ( endptr[0] == nptr || *endptr[0] != 45 || v25 > 0xFF )\n      sub_804D5E0(\"invalid range\");\n    ++endptr[0];\n    v9 = sub_80B4093(255);\n    v28 = v9;\n    if ( v7 > 2 && (v7 != 3 || v6 && ((v25 & 1) != 0 || (v9 & 1) == 0)) )\n      sub_804D5E0(\"range not compatible with selected mode\");\n  }\n  else\n  {\n    v28 = 255;\n  }\n  fda = sub_8054EBF(fd);\n  sub_8054F36(fda, v7, -1, v6, v8);\n  sub_8054FDF(fda, v29, v2 & 1);\n  if ( v8 )\n    sub_804E029(fda, 0x708u, 1, \"can't set PEC\");\n  if ( (v2 & 2) == 0 )\n    sub_8055025(v29, v7, -1, v8);\n  switch ( v7 )\n  {\n    case 3:\n      if ( !v6 )\n      {\n        puts(\"     0,8  1,9  2,a  3,b  4,c  5,d  6,e  7,f\");\n        do\n        {\n          if ( v6 >> 3 >= v25 >> 3 )\n          {\n            if ( v6 >> 3 > v28 >> 3 )\n              return 0;\n            printf(\"%02x: \", v6);\n            v22 = v6;\n            do\n            {\n              if ( v25 <= v22 && v28 >= v22 )\n              {\n                v23 = sub_80550D3(fda, v22);\n                if ( v23 >= 0 )\n                  printf(\"%04x \", (unsigned __int16)v23);\n                else\n                  printf(\"XXXX \");\n              }\n              else\n              {\n                printf(\"     \");\n              }\n              ++v22;\n            }\n            while ( v6 + 8 != v22 );\n            sub_804DD98(10);\n          }\n          v6 += 8;\n        }\n        while ( v6 != 256 );\n        return 0;\n      }\n      break;\n    case 5:\n      v10 = sub_8055084(fda, 1, 0, 5, (int)v35);\n      if ( v10 < 0 )\n        goto LABEL_64;\n      v10 = LOBYTE(v35[0]);\n      for ( i = 1; i <= v10; ++i )\n        *((_BYTE *)endptr + i + 3) = *((_BYTE *)v35 + i);\n      if ( !v10 )\nLABEL_64:\n        sub_804D5E0(\"block read failed: %d\", v10);\n      goto LABEL_68;\n    case 8:\n      for ( j = 0; j <= 255; j += v10 )\n      {\n        LOBYTE(v35[0]) = 32;\n        v10 = sub_8055084(fda, 1, j, 6, (int)v35);\n        if ( v10 < 0 )\n          goto LABEL_64;\n        v10 = LOBYTE(v35[0]);\n        for ( k = 1; k <= v10; ++k )\n          *((_BYTE *)endptr + j + k + 3) = *((_BYTE *)v35 + k);\n        if ( !v10 )\n          goto LABEL_64;\n      }\n      for ( m = 0; m != 256; ++m )\n        v35[m] = *((unsigned __int8 *)&endptr[1] + m);\n      break;\n    default:\n      v10 = 0;\n      if ( v7 == 1 && sub_8055084(fda, 0, v25, 1, 0) < 0 )\n        sub_804D3C9((int)\"write start address\");\n      goto LABEL_68;\n  }\n  v10 = 0;\nLABEL_68:\n  puts(\"     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef\");\n  for ( n = 0; n != 256; n += 16 )\n  {\n    if ( v10 <= n && v7 == 5 )\n      break;\n    if ( n >> 4 < v25 >> 4 )\n      continue;\n    if ( n >> 4 > v28 >> 4 )\n      break;\n    printf(\"%02x: \", n);\n    for ( ii = 0; ii <= 15; ++ii )\n    {\n      sub_804DD8F();\n      v17 = n + ii;\n      if ( v28 < n + ii || v25 > v17 )\n      {\n        printf(\"   \");\n        if ( v7 != 3 )\n          continue;\n        printf(\"   \");\nLABEL_96:\n        ++ii;\n        continue;\n      }\n      v31 = v17;\n      v30 = &v35[v17];\n      switch ( v7 )\n      {\n        case 2:\n          v18 = sub_80550F9(fda, n + ii);\n          break;\n        case 3:\n          v19 = sub_80550D3(fda, n + ii);\n          v32 = &v35[v31 + 1];\n          if ( v19 < 0 )\n          {\n            *v30 = v19;\n            *v32 = v19;\nLABEL_92:\n            printf(\"XX \");\n            if ( v7 != 3 )\n              continue;\n            printf(\"XX \");\n            goto LABEL_96;\n          }\n          *v30 = (unsigned __int8)v19;\n          *v32 = v19 >> 8;\nLABEL_94:\n          printf(\"%02x \", *v30);\n          if ( v7 != 3 )\n            continue;\n          printf(\"%02x \", v35[v31 + 1]);\n          goto LABEL_96;\n        case 1:\n          v18 = sub_80550AE(fda);\n          break;\n        default:\n          if ( v17 >= v10 && v7 == 5 )\n          {\n            printf(\"   \");\n            continue;\n          }\n          if ( *v30 < 0 )\n            goto LABEL_92;\n          goto LABEL_94;\n      }\n      *v30 = v18;\n      if ( v18 >= 0 )\n        printf(\"%02x \", v18);\n      else\n        printf(\"XX \");\n    }\n    printf(\"   \");\n    v20 = n;\n    do\n    {\n      if ( v7 == 5 && v10 <= (int)v20 )\n        break;\n      if ( v28 >= v20 && v25 <= v20 )\n      {\n        v21 = v35[v20];\n        if ( v21 >= 0 )\n        {\n          if ( v21 && v21 != 255 )\n          {\n            if ( (unsigned int)(v21 - 32) > 0x5E )\n              v21 = 63;\n          }\n          else\n          {\n            v21 = 46;\n          }\n        }\n        else\n        {\n          v21 = 88;\n        }\n      }\n      else\n      {\n        v21 = 32;\n      }\n      sub_804DD98(v21);\n      ++v20;\n    }\n    while ( n + 16 != v20 );\n    sub_804DD98(10);\n  }\n  return 0;\n}\n"
        ],
        "134569792": [
            "sub_8055F40",
            "0x8055f40",
            "int __cdecl sub_8055F40(int a1, int a2)\n{\n  unsigned int v2; // ebx\n  _DWORD *v3; // ebp\n  int v4; // esi\n  const char **i; // ebx\n  const char *v6; // edx\n  int v7; // esi\n  unsigned int v8; // edi\n  unsigned int j; // ebp\n  unsigned int v10; // ebx\n  int v11; // edx\n  bool v12; // cf\n  int v13; // eax\n  unsigned int v15; // [esp+0h] [ebp-24h]\n  int fd; // [esp+4h] [ebp-20h]\n  int v17; // [esp+Ch] [ebp-18h]\n  int v18; // [esp+10h] [ebp-14h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^yaqrFl\");\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v2 & 0x20) != 0 )\n    sub_805511F();\n  if ( !*v3 )\n    sub_804CDC2();\n  v4 = sub_8054EAD();\n  fd = sub_8054EBF(v4);\n  sub_804E029(fd, 0x705u, (int)&v18, \"can't get adapter functionality matrix\");\n  v15 = v2 & 0x10;\n  if ( (v2 & 0x10) != 0 )\n  {\n    printf(\"Functionalities implemented by bus #%d\\n\", v4);\n    for ( i = (const char **)&unk_80B5480; *i; i += 2 )\n    {\n      v6 = \"no\";\n      if ( ((unsigned int)*i & v18) != 0 )\n        v6 = \"yes\";\n      printf(\"%-32s %s\\n\", i[1], v6);\n    }\n  }\n  else\n  {\n    v7 = 2;\n    if ( (v2 & 8) == 0 )\n      v7 = (v2 >> 2) & 1;\n    v8 = 127;\n    if ( (v2 & 2) == 0 )\n    {\n      v8 = 119;\n      v15 = 3;\n    }\n    if ( v3[1] )\n    {\n      v15 = sub_80B4093(v8);\n      if ( v3[2] )\n        v8 = sub_80B4093(v8);\n    }\n    if ( (v18 & 0x30000) == 0 )\n      sub_804D5E0(\"bus doesn't support %s\", \"detection commands\");\n    if ( v7 == 1 )\n    {\n      if ( (v18 & 0x10000) == 0 )\n        sub_804D5E0(\"bus doesn't support %s\", \"SMBus quick write\");\n    }\n    else if ( v7 == 2 )\n    {\n      if ( (v18 & 0x20000) == 0 )\n        sub_804D5E0(\"bus doesn't support %s\", \"SMBus receive byte\");\n    }\n    else\n    {\n      if ( (v18 & 0x10000) == 0 )\n        sub_804D5F4(\"warning: can't use %s command, will skip some addresses\", \"SMBus quick write\");\n      if ( (v18 & 0x20000) == 0 )\n        sub_804D5F4(\"warning: can't use %s command, will skip some addresses\", \"SMBus receive byte\");\n    }\n    if ( (v2 & 1) == 0 )\n    {\n      sub_804D5F4(\"WARNING! This program can confuse your I2C bus\");\n      sub_8054FFF();\n    }\n    puts(\"     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\");\n    for ( j = 0; j != 128; j += 16 )\n    {\n      printf(\"%02x: \", j);\n      v10 = j;\n      do\n      {\n        sub_804DD8F();\n        v11 = v7;\n        if ( !v7 )\n        {\n          v11 = 2;\n          if ( v10 - 48 > 7 )\n            v11 = 2 - (v10 - 80 >= 0x10);\n        }\n        if ( v8 >= v10 && v15 <= v10 && (v11 != 2 ? (v12 = (v18 & 0x10000) != 0) : (v12 = (v18 & 0x20000) != 0), v12) )\n        {\n          v17 = v11;\n          if ( ioctl(fd, 0x703u, v10) >= 0 )\n          {\n            if ( v17 == 2 )\n              v13 = sub_80550AE(fd);\n            else\n              v13 = sub_8055084(fd, 0, 0, 0, 0);\n            if ( v13 >= 0 )\n              printf(\"%02x \", v10);\n            else\n              printf(\"-- \");\n          }\n          else\n          {\n            if ( *(_DWORD *)dword_80DBB7C != 16 )\n              sub_804D3C9((int)\"can't set address to 0x%02x\", v10);\n            printf(\"UU \");\n          }\n        }\n        else\n        {\n          printf(\"   \");\n        }\n        ++v10;\n      }\n      while ( j + 16 != v10 );\n      sub_804DD98(10);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134570468": [
            "sub_80561E4",
            "0x80561e4",
            "int sub_80561E4()\n{\n  unsigned int v0; // ebx\n  unsigned int v1; // ecx\n  int result; // eax\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 20);\n  v1 = *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    LOBYTE(result) = *(_DWORD *)(dword_80DBB80 + 28) + v1 >= v0;\n  }\n  else\n  {\n    result = 1;\n    if ( v0 < v1 )\n      return result;\n    LOBYTE(result) = *(_DWORD *)(dword_80DBB80 + 24) <= (unsigned int)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52)\n                                                                                             + 4 * v1)\n                                                                                 - 4)\n                                                                     + *(_DWORD *)(dword_80DBB80 + 28));\n  }\n  return (unsigned __int8)result;\n}\n"
        ],
        "134570531": [
            "sub_8056223",
            "0x8056223",
            "int __usercall sub_8056223@<eax>(int a1@<eax>)\n{\n  unsigned int v1; // edx\n  int v2; // edx\n\n  v1 = *(_DWORD *)(dword_80DBB80 + 20);\n  if ( v1 <= a1 )\n    a1 = v1 - 1;\n  v2 = 0;\n  if ( a1 >= 0 )\n    return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * a1) - 4) + 1;\n  return v2;\n}\n"
        ],
        "134570566": [
            "sub_8056246",
            "0x8056246",
            "int __usercall sub_8056246@<eax>(int result@<eax>)\n{\n  if ( (_BYTE)result == 91 )\n    goto LABEL_10;\n  if ( (unsigned __int8)result <= 0x5Bu )\n  {\n    if ( (_BYTE)result != 40 )\n    {\n      if ( (_BYTE)result != 41 )\n        return result;\nLABEL_13:\n      --result;\n      return result;\n    }\nLABEL_11:\n    ++result;\n    return result;\n  }\n  if ( (_BYTE)result == 123 )\n  {\nLABEL_10:\n    ++result;\n    goto LABEL_11;\n  }\n  if ( (_BYTE)result == 125 || (_BYTE)result == 93 )\n  {\n    --result;\n    goto LABEL_13;\n  }\n  return result;\n}\n"
        ],
        "134570606": [
            "sub_805626E",
            "0x805626e",
            "int sub_805626E()\n{\n  sub_804DD8F();\n  return tcsetattr(*(_DWORD *)(dword_80DBB80 + 4), 0, (const struct termios *)(dword_80DBB80 + 132));\n}\n"
        ],
        "134570637": [
            "sub_805628D",
            "0x805628d",
            "__int64 sub_805628D()\n{\n  __int64 v1; // [esp-8h] [ebp-8h]\n\n  printf(\"\\x1B[%u;0H\\x1B[K\", *(_DWORD *)(dword_80DBB80 + 28) + 2);\n  return v1;\n}\n"
        ],
        "134570662": [
            "sub_80562A6",
            "0x80562a6",
            "void __usercall __noreturn sub_80562A6(int a1@<eax>)\n{\n  sub_805626E();\n  if ( (*(_BYTE *)(dword_80DBB80 + 9) & 8) == 0 )\n    sub_804D646(*(_DWORD *)(dword_80DBB80 + 4));\n  sub_805628D();\n  if ( a1 < 0 )\n    sub_804E761(-a1);\n  exit(a1);\n}\n"
        ],
        "134570713": [
            "sub_80562D9",
            "0x80562d9",
            "void __cdecl __noreturn sub_80562D9(int a1)\n{\n  sub_80562A6(-a1);\n}\n"
        ],
        "134570724": [
            "sub_80562E4",
            "0x80562e4",
            "int __usercall sub_80562E4@<eax>(const char *a1@<eax>)\n{\n  sub_805628D();\n  return printf(\"\\x1B[7m%.*s\\x1B[m\", *(_DWORD *)(dword_80DBB80 + 32) - 1, a1);\n}\n"
        ],
        "134570758": [
            "sub_8056306",
            "0x8056306",
            "int __usercall sub_8056306@<eax>(int result@<eax>)\n{\n  int v1; // ebx\n  unsigned int v2; // esi\n  int v3; // edi\n  int v4; // ecx\n  int v5; // edx\n\n  v1 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 128) )\n  {\n    v2 = result;\n    v3 = 4 * result;\n    while ( *(_DWORD *)(v1 + 20) >= v2 )\n    {\n      result = regexec((const regex_t *)(v1 + 96), *(const char **)(*(_DWORD *)(v1 + 52) + v3), 0, 0, 0);\n      if ( !result )\n      {\n        v4 = *(_DWORD *)(v1 + 92);\n        result = *(_DWORD *)(v1 + 80);\n        if ( !v4 || *(_DWORD *)(result + 4 * v4 - 4) != v2 )\n        {\n          result = sub_80B4733();\n          *(_DWORD *)(v1 + 80) = result;\n          v5 = *(_DWORD *)(v1 + 92);\n          *(_DWORD *)(v1 + 92) = v5 + 1;\n          *(_DWORD *)(result + 4 * v5) = v2;\n        }\n      }\n      ++v2;\n      v3 += 4;\n    }\n  }\n  return result;\n}\n"
        ],
        "134570869": [
            "sub_8056375",
            "0x8056375",
            "int sub_8056375()\n{\n  _DWORD *v0; // ebx\n  int result; // eax\n  char *v2; // eax\n  const char *v3; // ebp\n  int v4; // ebx\n  _BYTE *v5; // esi\n  int v6; // ebx\n  _DWORD *v7; // edi\n  time_t v8; // eax\n  time_t v9; // edi\n  int v10; // eax\n  int v11; // edx\n  char v12; // cl\n  int v13; // eax\n  signed int v14; // edi\n  int v15; // ebx\n  size_t v16; // eax\n  _DWORD *v17; // eax\n  int v18; // [esp+0h] [ebp-28h]\n  signed int v19; // [esp+4h] [ebp-24h]\n  char v20; // [esp+8h] [ebp-20h]\n  time_t v21; // [esp+8h] [ebp-20h]\n  int v22; // [esp+10h] [ebp-18h]\n\n  v0 = (_DWORD *)dword_80DBB80;\n  v19 = *(_DWORD *)(dword_80DBB80 + 32);\n  v18 = *(_DWORD *)(dword_80DBB80 + 20);\n  result = v18 + 1;\n  if ( (unsigned int)(v18 + 1) <= 0x98967F )\n  {\n    if ( (dword_80DBB9C & 8) != 0 )\n      v19 -= 8;\n    v20 = *(_BYTE *)(dword_80DBB80 + 129);\n    v2 = (char *)sub_804DAFA(v19 + 5);\n    v3 = v2 + 4;\n    if ( v20 )\n    {\n      ++v0[5];\n      v0[4] = 0;\n      v5 = v2 + 4;\n    }\n    else\n    {\n      v4 = *(_DWORD *)(v0[13] + 4 * v0[5]);\n      v5 = (_BYTE *)stpcpy(v3, v4);\n      free((void *)(v4 - 4));\n    }\n    v22 = 2;\n    v21 = 0;\n    while ( 1 )\n    {\n      *v5 = 0;\n      v6 = dword_80DBB80;\n      *(_BYTE *)(dword_80DBB80 + 129) = 0;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          if ( *(_DWORD *)(v6 + 40) >= *(_DWORD *)(v6 + 44) )\n          {\n            sub_804D61C(0);\n            while ( 1 )\n            {\n              v7 = (_DWORD *)dword_80DBB7C;\n              *(_DWORD *)dword_80DBB7C = 0;\n              *(_DWORD *)(v6 + 36) = sub_804E5BC(0x400u, &buf, 0);\n              if ( *v7 != 11 )\n                break;\n              v8 = time(0);\n              v9 = v8;\n              if ( v21 != v8 && --v22 < 0 )\n              {\n                v21 = v8;\n                break;\n              }\n              sched_yield();\n              v21 = v9;\n            }\n            fcntl64(0, 4);\n            *(_DWORD *)(v6 + 40) = 0;\n            v10 = *(_DWORD *)(v6 + 36);\n            *(_DWORD *)(v6 + 44) = v10;\n            if ( v10 <= 0 )\n              goto LABEL_33;\n            v22 = 1;\n          }\n          v11 = *(_DWORD *)(v6 + 40);\n          v12 = *((_BYTE *)&buf + v11);\n          v13 = *(_DWORD *)(v6 + 16);\n          if ( v12 != 8 || !v13 || *(v5 - 1) == 9 )\n            break;\n          *(_DWORD *)(v6 + 40) = v11 + 1;\n          *(_DWORD *)(v6 + 16) = v13 - 1;\n          *--v5 = 0;\n        }\n        v14 = v13 + 1;\n        if ( v12 == 9 )\n          v14 = (v13 + 8) & 0xFFFFFFF8;\n        if ( v14 > v19 )\n          goto LABEL_33;\n        *(_DWORD *)(v6 + 16) = v14;\n        *(_DWORD *)(v6 + 40) = v11 + 1;\n        if ( v12 == 10 )\n          break;\n        if ( !v12 )\n          v12 = 10;\n        *v5 = v12;\n        *++v5 = 0;\n      }\n      *(_BYTE *)(v6 + 129) = 1;\n      *(_DWORD *)(v6 + 16) = 0;\nLABEL_33:\n      v15 = dword_80DBB80;\n      *(_DWORD *)(v15 + 52) = sub_80B4733(*(_DWORD *)(dword_80DBB80 + 20), 1032);\n      v16 = strlen(v3);\n      v17 = sub_804DB13((void *)(v3 - 4), v16 + 5);\n      *(_DWORD *)(*(_DWORD *)(v15 + 52) + 4 * *(_DWORD *)(v15 + 20)) = v17 + 1;\n      *v17 = *(_DWORD *)(v15 + 24);\n      if ( *(_BYTE *)(v15 + 129) )\n        ++*(_DWORD *)(v15 + 24);\n      if ( *(_DWORD *)(v15 + 20) > 0x98967Eu )\n        break;\n      if ( !sub_80561E4() )\n      {\n        if ( *(_DWORD *)(v15 + 88) >= *(_DWORD *)(v15 + 92) )\n        {\n          sub_8056306(v18);\n          v18 = *(_DWORD *)(v15 + 20);\n        }\n        if ( *(_DWORD *)(v15 + 88) < *(_DWORD *)(v15 + 92) )\n          goto LABEL_40;\n      }\n      if ( *(int *)(v15 + 36) <= 0 )\n        goto LABEL_40;\n      ++*(_DWORD *)(v15 + 20);\n      v3 = (char *)sub_804DAFA(v19 + 5) + 4;\n      *(_DWORD *)(v15 + 16) = 0;\n      v5 = v3;\n    }\n    *(_DWORD *)(v15 + 36) = 0;\nLABEL_40:\n    if ( *(int *)(v15 + 36) >= 0 )\n    {\n      if ( !*(_DWORD *)(v15 + 36) )\n        *(_DWORD *)(v15 + 76) = *(_DWORD *)(v15 + 24);\n    }\n    else if ( *(_DWORD *)dword_80DBB7C == 11 )\n    {\n      *(_DWORD *)(v15 + 36) = 1;\n    }\n    else\n    {\n      sub_80562E4(\"read error\");\n    }\n    result = sub_8056306(v18);\n    *(_DWORD *)(v15 + 88) = -1;\n  }\n  return result;\n}\n"
        ],
        "134571524": [
            "sub_8056604",
            "0x8056604",
            "int __usercall sub_8056604@<eax>(int result@<eax>)\n{\n  int *v1; // ebx\n  int v2; // esi\n  int v3; // edx\n\n  v1 = (int *)dword_80DBB80;\n  if ( result > 0 )\n  {\n    v2 = result;\n    v3 = *(_DWORD *)(dword_80DBB80 + 52);\n    if ( *(_DWORD *)(*(_DWORD *)(v3 + 4 * *(_DWORD *)dword_80DBB80) - 4) >= (unsigned int)result )\n    {\n      while ( 1 )\n      {\n        result = *v1;\n        if ( *(_DWORD *)(*(_DWORD *)(v3 + 4 * *v1) - 4) == v2 || result <= 0 )\n          break;\n        *v1 = result - 1;\n      }\n    }\n    else\n    {\n      while ( 1 )\n      {\n        result = *v1;\n        if ( v2 == *(_DWORD *)(*(_DWORD *)(v1[13] + 4 * *v1) - 4) )\n          break;\n        if ( result >= (unsigned int)v1[5] )\n        {\n          if ( v1[9] <= 0 )\n            return result;\n          sub_8056375();\n        }\n        else\n        {\n          *v1 = result + 1;\n        }\n      }\n    }\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB80 = 0;\n  }\n  return result;\n}\n"
        ],
        "134571615": [
            "sub_805665F",
            "0x805665f",
            "unsigned int sub_805665F()\n{\n  int *v0; // edx\n  unsigned int v1; // ebx\n  int v2; // ecx\n  unsigned int v3; // eax\n  unsigned int result; // eax\n\n  v0 = (int *)dword_80DBB80;\n  v1 = *(_DWORD *)dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 28);\n  v3 = *(_DWORD *)(dword_80DBB80 + 20);\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    result = v3 + 1;\n    if ( v2 + v1 > result )\n    {\n      result -= v2;\n      *(_DWORD *)dword_80DBB80 = result;\n    }\n    if ( *v0 < 0 )\n      *v0 = 0;\n  }\n  else\n  {\n    if ( v1 > v3 )\n      *(_DWORD *)dword_80DBB80 = v3;\n    result = v0[6] + 1;\n    if ( v2 + *(_DWORD *)(*(_DWORD *)(v0[13] + 4 * *v0) - 4) > result )\n    {\n      sub_8056604(result - v2);\n      return sub_8056375();\n    }\n  }\n  return result;\n}\n"
        ],
        "134571703": [
            "sub_80566B7",
            "0x80566b7",
            "void sub_80566B7()\n{\n  int v0; // esi\n  int v1; // ebx\n  int v2; // edi\n  ssize_t v3; // eax\n  int v4; // edx\n  _WORD v5[48]; // [esp+0h] [ebp-106Ch] BYREF\n  char buf[4108]; // [esp+60h] [ebp-100Ch] BYREF\n\n  v0 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 76) >= 0xFFFFFFFE )\n  {\n    v1 = open64(\"/proc/self/fd/0\");\n    if ( v1 >= 0 || *(_DWORD *)(v0 + 76) == -1 && (v1 = open64(*(_DWORD *)(v0 + 68)), v1 >= 0) )\n    {\n      if ( !fstat64(v1, v5) && (v5[8] & 0xF000) == 0x8000 )\n      {\n        v2 = 0;\nLABEL_10:\n        v3 = sub_804E5BC(0x1000u, buf, v1);\n        if ( v3 > 0 )\n        {\n          v4 = 0;\n          while ( buf[v4] != 10 || ++v2 != 9999999 )\n          {\n            if ( v3 == ++v4 )\n              goto LABEL_10;\n          }\n        }\n        *(_DWORD *)(v0 + 76) = v2;\n      }\n      else\n      {\n        *(_DWORD *)(v0 + 76) = -3;\n      }\n      close(v1);\n    }\n    else\n    {\n      *(_DWORD *)(v0 + 76) = -3;\n    }\n  }\n}\n"
        ],
        "134571886": [
            "sub_805676E",
            "0x805676e",
            "void sub_805676E()\n{\n  int v0; // esi\n  unsigned int v1; // eax\n  int v2; // ebx\n  int v3; // edi\n  int v4; // eax\n  unsigned int v5; // eax\n  unsigned int v6; // ebx\n  unsigned int v7; // edx\n  int v8; // eax\n  int v9; // ecx\n  unsigned int v10; // eax\n\n  v0 = dword_80DBB80;\n  if ( *(int *)(dword_80DBB80 + 12) >= 0 )\n    return;\n  sub_805628D();\n  printf(\"\\x1B[7m%s\", *(const char **)(v0 + 68));\n  v1 = *(_DWORD *)(v0 + 60);\n  if ( v1 > 1 )\n    printf(\" (file %i of %i)\", *(_DWORD *)(v0 + 64), v1);\n  v2 = *(_DWORD *)v0;\n  v3 = sub_8056223(*(_DWORD *)v0);\n  v4 = *(_DWORD *)(v0 + 28);\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    v5 = sub_8056223(v2 + v4);\nLABEL_8:\n    v6 = v5;\n    goto LABEL_9;\n  }\n  v5 = v3 + v4;\n  v6 = *(_DWORD *)(v0 + 24);\n  if ( v6 > v5 )\n    goto LABEL_8;\nLABEL_9:\n  printf(\" lines %i-%i\", v3, v6);\n  sub_80566B7();\n  if ( *(int *)(v0 + 76) >= 0 )\n    printf(\"/%i\", *(_DWORD *)(v0 + 76));\n  if ( sub_80561E4() )\n  {\n    printf(\" (END)\");\n    v7 = *(_DWORD *)(v0 + 60);\n    if ( v7 > 1 )\n    {\n      v8 = *(_DWORD *)(v0 + 64);\n      if ( v7 != v8 )\n        printf(\" - next: %s\", *(_DWORD *)(*(_DWORD *)(v0 + 72) + 4 * v8));\n    }\n  }\n  else\n  {\n    v9 = *(_DWORD *)(v0 + 76);\n    if ( v9 > 0 )\n    {\n      v10 = (int)((v9 >> 1) + 100 * v6) / v9;\n      if ( v10 > 0x64 )\n        v10 = 100;\n      printf(\" %i%%\", v10);\n    }\n  }\n  printf(\"\\x1B[m\");\n}\n"
        ],
        "134572138": [
            "sub_805686A",
            "0x805686a",
            "void sub_805686A()\n{\n  _DWORD *v0; // ebx\n  const char *v1; // eax\n\n  v0 = (_DWORD *)dword_80DBB80;\n  if ( *(int *)(dword_80DBB80 + 12) < 0 )\n  {\n    if ( (dword_80DBB9C & 6) != 0 )\n    {\n      sub_805676E();\n      return;\n    }\n    sub_805628D();\n    if ( *v0 )\n    {\n      if ( !sub_80561E4() )\n      {\n        sub_804DD98(58);\n        return;\n      }\n      v1 = \" (END)\" + 1;\n    }\n    else\n    {\n      v1 = (const char *)v0[17];\n    }\n    if ( v0[15] <= 1u )\n      printf(\"\\x1B[7m%s\\x1B[m\", v1);\n    else\n      printf(\"\\x1B[7m%s (file %i of %i)\\x1B[m\", v1, v0[16], v0[15]);\n  }\n}\n"
        ],
        "134572249": [
            "sub_80568D9",
            "0x80568d9",
            "void sub_80568D9()\n{\n  int v0; // ebx\n  unsigned int v1; // edx\n  int v2; // esi\n  int v3; // edx\n  const char *v4; // eax\n  int v5; // eax\n  void *v6; // esp\n  int **v7; // edi\n  char *j; // esi\n  unsigned int v9; // eax\n  unsigned int v10; // ecx\n  char *v11; // esi\n  int k; // edx\n  const char *v13; // edi\n  char *v14; // edi\n  const char *v15; // eax\n  void *v16; // esp\n  size_t v17; // eax\n  char *v18; // edi\n  size_t v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int v22; // ecx\n  int *v23; // [esp+0h] [ebp-28h] BYREF\n  int v24; // [esp+4h] [ebp-24h]\n  const char *v25; // [esp+8h] [ebp-20h]\n  unsigned int i; // [esp+Ch] [ebp-1Ch]\n  char *s; // [esp+10h] [ebp-18h]\n  regmatch_t v28; // [esp+14h] [ebp-14h] BYREF\n\n  printf(\"\\x1B[%u;%uH\", 0, 0);\n  for ( i = 0; ; ++i )\n  {\n    v0 = dword_80DBB80;\n    v1 = *(_DWORD *)(dword_80DBB80 + 28);\n    if ( v1 < i )\n      break;\n    printf(\"\\x1B[K\");\n    v2 = 4 * i;\n    if ( (dword_80DBB9C & 8) != 0 )\n    {\n      v3 = *(_DWORD *)(*(_DWORD *)(v0 + 48) + 4 * i);\n      v4 = \"        \";\n      if ( v3 != *(_DWORD *)(v0 + 56) )\n      {\n        v24 = *(_DWORD *)(v3 - 4) + 1;\n        v4 = \"%7u \";\n      }\n      printf(v4, v24, v23);\n    }\n    s = *(char **)(*(_DWORD *)(v0 + 48) + v2);\n    v5 = *(_DWORD *)(v0 + 32) + 4;\n    if ( *(_BYTE *)(v0 + 128) )\n    {\n      v23 = (int *)&v23;\n      v6 = alloca(v5 & 0xFFFFFFFC);\n      v25 = (const char *)&v23;\n      v7 = &v23;\n      for ( j = s; *j; j += v10 )\n      {\n        v9 = strcspn(j, &reject);\n        if ( v9 )\n        {\n          if ( !j[v9] )\n            break;\n          qmemcpy(v7, j, v9);\n          j += v9;\n          v7 = (int **)((char *)v7 + v9);\n        }\n        v10 = strspn(j, &reject);\n        memset(v7, 46, v10);\n        v7 = (int **)((char *)v7 + v10);\n      }\n      strcpy((char *)v7, j);\n      v11 = 0;\n      for ( k = 0; !regexec((const regex_t *)(v0 + 96), s, 1u, &v28, k) && v28.rm_so < v28.rm_eo; k = 1 )\n      {\n        v13 = &data;\n        if ( v11 )\n          v13 = v11;\n        v14 = sub_804DDBF(\"%s%.*s\\x1B[7m%.*s\\x1B[m\", v13, v28.rm_so, v25, v28.rm_eo - v28.rm_so, &v25[v28.rm_so]);\n        free(v11);\n        v25 += v28.rm_eo;\n        s += v28.rm_eo;\n        v11 = v14;\n      }\n      v15 = &data;\n      if ( v11 )\n        v15 = v11;\n      printf(\"%s%s\\n\", v15, v25);\n      free(v11);\n    }\n    else\n    {\n      v16 = alloca(*(_DWORD *)(v0 + 32) + 1);\n      while ( *s )\n      {\n        v17 = strcspn(s, &reject);\n        if ( v17 )\n        {\n          v18 = &s[v17];\n          if ( !s[v17] )\n            break;\n          printf(\"%.*s\", v17, s);\n          s = v18;\n        }\n        v19 = strspn(s, &reject);\n        v20 = 0;\n        do\n        {\n          v21 = (unsigned __int8)s[v20];\n          if ( (_BYTE)v21 == 127 )\n          {\n            *((_BYTE *)&v23 + v20) = 63;\n          }\n          else if ( (_BYTE)v21 == 0x9B )\n          {\n            *((_BYTE *)&v23 + v20) = 123;\n          }\n          else\n          {\n            *((_BYTE *)&v23 + v20) = byte_80CAD52[v21];\n          }\n          ++v20;\n        }\n        while ( v20 != v19 );\n        s += v20;\n        *((_BYTE *)&v23 + v20) = 0;\n        printf(\"\\x1B[7m%s\\x1B[m\", (const char *)&v23);\n      }\n      puts(s);\n    }\n  }\n  if ( (dword_80DBB9C & 0x41) != 0 && *(int *)(dword_80DBB80 + 36) <= 0 )\n  {\n    v22 = 0;\n    if ( (dword_80DBB9C & 0x40) == 0 )\n      v22 = *(_DWORD *)dword_80DBB80;\n    if ( v1 >= *(_DWORD *)(dword_80DBB80 + 20) - v22 )\n      sub_80562A6(0);\n  }\n  sub_805686A();\n}\n"
        ],
        "134572852": [
            "sub_8056B34",
            "0x8056b34",
            "void sub_8056B34()\n{\n  _DWORD *v0; // ecx\n  unsigned int v1; // eax\n  int v2; // edx\n  unsigned int v3; // edx\n  int v4; // ebx\n  int v5; // esi\n  int v6; // ebx\n  int v7; // esi\n  _DWORD *v8; // edi\n  unsigned int v9; // ebx\n  int v10; // esi\n  int v11; // edx\n  int v12; // ebp\n  unsigned int v13; // [esp+0h] [ebp-1Ch]\n  unsigned int v14; // [esp+4h] [ebp-18h]\n  int v15; // [esp+8h] [ebp-14h]\n\n  v0 = (_DWORD *)dword_80DBB80;\n  v1 = *(_DWORD *)dword_80DBB80;\n  v15 = dword_80DBB9C & 0x80;\n  v2 = 4 * *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80) != 0 )\n  {\n    while ( v1 )\n    {\n      v4 = *(_DWORD *)(dword_80DBB80 + 52);\n      v5 = *(_DWORD *)(v4 + v2);\n      v6 = *(_DWORD *)(v4 + v2 - 4);\n      v2 -= 4;\n      if ( *(_DWORD *)(v5 - 4) != *(_DWORD *)(v6 - 4) )\n        break;\n      --v1;\n    }\n  }\n  v13 = *(_DWORD *)(dword_80DBB80 + 28);\n  v3 = 0;\n  while ( v13 >= v3 )\n  {\n    v14 = v0[5];\n    v7 = v0[12];\n    v8 = (_DWORD *)(v7 + 4 * v3);\n    v9 = v3 + 1;\n    if ( v14 < v1 )\n    {\n      do\n        *(_DWORD *)(v7 + 4 * v3++) = v0[14];\n      while ( v13 >= v3 );\n      break;\n    }\n    v10 = v0[13];\n    v11 = *(_DWORD *)(v10 + 4 * v1);\n    v12 = *(_DWORD *)(v11 - 4);\n    *v8 = v11;\n    do\n    {\n      ++v1;\n      v3 = v9;\n    }\n    while ( v15 && v14 >= v1 && v12 == *(_DWORD *)(*(_DWORD *)(v10 + 4 * v1) - 4) );\n  }\n  sub_80568D9();\n}\n"
        ],
        "134573020": [
            "sub_8056BDC",
            "0x8056bdc",
            "void sub_8056BDC()\n{\n  int v0; // ebx\n  unsigned int i; // esi\n  const char *v2; // eax\n  int v3; // eax\n\n  v0 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 52) )\n  {\n    for ( i = 0; *(_DWORD *)(v0 + 20) >= i; ++i )\n      free((void *)(*(_DWORD *)(*(_DWORD *)(v0 + 52) + 4 * i) - 4));\n    free(*(void **)(v0 + 52));\n    *(_DWORD *)(v0 + 52) = 0;\n  }\n  *(_DWORD *)(v0 + 20) = -1;\n  *(_DWORD *)v0 = 0;\n  *(_DWORD *)(v0 + 24) = 0;\n  v2 = *(const char **)(v0 + 68);\n  if ( v2 )\n  {\n    v3 = sub_804DBE1(v2);\n    sub_804DC97(v3, 0);\n    *(_DWORD *)(v0 + 76) = -1;\n  }\n  else\n  {\n    *(_DWORD *)(v0 + 68) = sub_804DB46(\"standard input\");\n    *(_DWORD *)(v0 + 76) = -2;\n  }\n  *(_DWORD *)(v0 + 40) = 0;\n  *(_DWORD *)(v0 + 44) = 0;\n  *(_DWORD *)(v0 + 16) = 0;\n  *(_BYTE *)(v0 + 129) = 1;\n  sub_8056375();\n  sub_8056B34();\n}\n"
        ],
        "134573184": [
            "sub_8056C80",
            "0x8056c80",
            "void __usercall sub_8056C80(int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // edx\n  int v3; // ecx\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 64);\n  if ( a1 == 1 )\n  {\n    if ( v2 == *(_DWORD *)(dword_80DBB80 + 60) )\n    {\n      sub_80562E4(\"No next file\");\n      return;\n    }\n    goto LABEL_6;\n  }\n  if ( v2 != 1 )\n  {\n    v3 = 1;\n    if ( !a1 )\n    {\nLABEL_7:\n      *(_DWORD *)(dword_80DBB80 + 64) = v3;\n      free(*(void **)(v1 + 68));\n      *(_DWORD *)(v1 + 68) = sub_804DB46(*(const char **)(*(_DWORD *)(v1 + 72) + 4 * *(_DWORD *)(v1 + 64) - 4));\n      sub_8056BDC();\n      return;\n    }\nLABEL_6:\n    v3 = a1 + v2;\n    goto LABEL_7;\n  }\n  sub_80562E4(\"No previous file\");\n}\n"
        ],
        "134573275": [
            "sub_8056CDB",
            "0x8056cdb",
            "void __usercall sub_8056CDB(int a1@<eax>)\n{\n  int v1; // ecx\n\n  v1 = *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n    *(_DWORD *)dword_80DBB80 = v1 + a1;\n  else\n    sub_8056604(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * v1) - 4) + a1);\n  sub_8056375();\n  sub_805665F();\n  sub_8056B34();\n}\n"
        ],
        "134573327": [
            "sub_8056D0F",
            "0x8056d0f",
            "void __usercall sub_8056D0F(int a1@<eax>)\n{\n  _DWORD *v1; // ecx\n  int v2; // edx\n  int v3; // edx\n\n  v1 = (_DWORD *)dword_80DBB80;\n  v2 = *(_DWORD *)dword_80DBB80;\n  if ( (dword_80DBB9C & 0x80u) == 0 )\n  {\n    v3 = v2 - a1;\n    *(_DWORD *)dword_80DBB80 = v3;\n    if ( v3 < 0 )\n      *v1 = 0;\n  }\n  else\n  {\n    sub_8056604(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * v2) - 4) - a1);\n  }\n  sub_8056375();\n  sub_8056B34();\n}\n"
        ],
        "134573388": [
            "sub_8056D4C",
            "0x8056d4c",
            "void __usercall sub_8056D4C(int a1@<eax>, int a2@<edx>)\n{\n  if ( a1 > 0 )\n  {\n    if ( a2 )\n      sub_8056604(a1);\n    else\n      *(_DWORD *)dword_80DBB80 = a1;\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB80 = 0;\n  }\n  sub_8056375();\n  sub_805665F();\n  sub_8056B34();\n}\n"
        ],
        "134573439": [
            "sub_8056D7F",
            "0x8056d7f",
            "void __usercall sub_8056D7F(int a1@<eax>)\n{\n  _DWORD *v1; // esi\n  int v2; // ebx\n  int v3; // eax\n\n  v1 = (_DWORD *)dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 128) )\n  {\n    v2 = a1;\n    if ( a1 < 0 )\n      v2 = 0;\n    if ( *(_DWORD *)(dword_80DBB80 + 92) <= v2 && *(int *)(dword_80DBB80 + 36) > 0 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 88) = v2;\n      sub_8056375();\n    }\n    v3 = v1[23];\n    if ( v3 )\n    {\n      if ( v3 <= v2 )\n      {\n        v2 = v3 - 1;\n        if ( v3 - 1 < 0 )\n          v2 = 0;\n      }\n      v1[21] = v2;\n      sub_8056D4C(*(_DWORD *)(v1[20] + 4 * v2), 0);\n    }\n    else\n    {\n      sub_80562E4(\"No matches found\");\n    }\n  }\n}\n"
        ],
        "134573534": [
            "sub_8056DDE",
            "0x8056dde",
            "int sub_8056DDE()\n{\n  int v0; // ebx\n  _BOOL4 v1; // esi\n  int v2; // eax\n  int v3; // eax\n  int v5; // [esp+0h] [ebp-24h]\n  int v6; // [esp+4h] [ebp-20h]\n  int v7; // [esp+4h] [ebp-20h]\n\n  v0 = dword_80DBB80;\n  while ( 1 )\n  {\n    tcsetattr(*(_DWORD *)(v0 + 4), 0, (const struct termios *)(v0 + 192));\n    v1 = 1;\n    if ( sub_80561E4() )\n      v1 = *(_DWORD *)(v0 + 36) <= 0;\n    v2 = *(_DWORD *)(v0 + 12);\n    if ( v2 >= 0 )\n      printf(\"\\x1B[%u;%uH\", *(_DWORD *)(v0 + 28) + 2, v2 + 1);\n    sub_804DD8F();\n    if ( !*(_BYTE *)(v0 + 252) )\n      sub_80B2C0A(-1, 2 - v1);\n    v3 = sub_80B20CC(-2, v0 + 252, v5, v6);\n    if ( v3 != -1 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 11 )\n      sub_80562A6(0);\n    sub_8056375();\n    sub_8056B34();\n  }\n  v7 = v3;\n  sub_805626E();\n  return v7;\n}\n"
        ],
        "134573762": [
            "sub_8056EC2",
            "0x8056ec2",
            "unsigned int __usercall sub_8056EC2@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n  unsigned int result; // eax\n\n  do\n  {\n    v2 = dword_80DBB80;\n    *(_DWORD *)(dword_80DBB80 + 12) = a1;\n    result = sub_8056DDE();\n    *(_DWORD *)(v2 + 12) = -1;\n  }\n  while ( result <= 0x1F && result != 13 && result != 8 );\n  return result;\n}\n"
        ],
        "134573817": [
            "sub_8056EF9",
            "0x8056ef9",
            "_BYTE *__usercall sub_8056EF9@<eax>(int a1@<eax>)\n{\n  _BYTE *v2; // esi\n  unsigned int v3; // ebx\n  int v4; // ebp\n  int v5; // eax\n  char v7; // [esp+0h] [ebp-14h]\n\n  v2 = sub_804DB2E(1u);\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = dword_80DBB80;\n    *(_DWORD *)(dword_80DBB80 + 12) = a1 + v3;\n    v5 = sub_8056DDE();\n    if ( v5 == 13 )\n      break;\n    if ( v5 == 8 || v5 == 127 )\n    {\n      if ( v3 )\n      {\n        printf(\"\\b \\b\");\n        --v3;\n      }\n    }\n    else if ( v5 > 31 && *(_DWORD *)(v4 + 32) + ~a1 > v3 )\n    {\n      v7 = v5;\n      sub_804DD98(v5);\n      v2[v3] = v7;\n      v2 = sub_804DB13(v2, v3 + 2);\n      ++v3;\n    }\n  }\n  v2[v3] = 0;\n  *(_DWORD *)(v4 + 12) = -1;\n  return v2;\n}\n"
        ],
        "134573960": [
            "sub_8056F88",
            "0x8056f88",
            "void sub_8056F88()\n{\n  const char *v0; // eax\n  char *v1; // esi\n  int v2; // ebx\n\n  sub_80562E4(\"Examine: \");\n  v0 = sub_8056EF9(9);\n  v1 = (char *)v0;\n  if ( !*v0 )\n  {\n    sub_805686A();\nLABEL_3:\n    free(v1);\n    return;\n  }\n  if ( access(v0, 4) )\n  {\n    sub_80562E4(\"Cannot read this file\");\n    goto LABEL_3;\n  }\n  v2 = dword_80DBB80;\n  free(*(void **)(dword_80DBB80 + 68));\n  *(_DWORD *)(v2 + 68) = v1;\n  **(_DWORD **)(v2 + 72) = v1;\n  *(_DWORD *)(v2 + 64) = 1;\n  *(_DWORD *)(v2 + 60) = 1;\n  sub_8056BDC();\n}\n"
        ],
        "134574074": [
            "sub_8056FFA",
            "0x8056ffa",
            "void sub_8056FFA()\n{\n  int v0; // ebx\n  char *v1; // eax\n  char *v2; // esi\n  char *v3; // edi\n  int v4; // edx\n  int v5; // eax\n\n  v0 = dword_80DBB80;\n  free(*(void **)(dword_80DBB80 + 80));\n  *(_DWORD *)(v0 + 80) = 0;\n  *(_DWORD *)(v0 + 84) = 0;\n  *(_DWORD *)(v0 + 92) = 0;\n  if ( *(_BYTE *)(v0 + 128) )\n  {\n    regfree((regex_t *)(v0 + 96));\n    *(_BYTE *)(v0 + 128) = 0;\n  }\n  sub_805628D();\n  sub_804DD98((dword_80DBB9C & 0x8000) == 0 ? 47 : 63);\n  v1 = sub_8056EF9(1);\n  v2 = v1;\n  if ( *v1 )\n  {\n    v3 = (char *)sub_80B477A(((unsigned int)dword_80DBB9C >> 4) & 2, v1);\n    free(v2);\n    if ( v3 )\n    {\n      sub_80562E4(v3);\n      free(v3);\n    }\n    else\n    {\n      *(_BYTE *)(v0 + 128) = 1;\n      *(_DWORD *)(v0 + 84) = 0;\n      sub_8056306(0);\n      v4 = *(_DWORD *)(v0 + 92);\n      while ( 1 )\n      {\n        v5 = *(_DWORD *)(v0 + 84);\n        if ( v5 >= v4 || *(_DWORD *)(*(_DWORD *)(v0 + 80) + 4 * v5) > *(_DWORD *)v0 )\n          break;\n        *(_DWORD *)(v0 + 84) = v5 + 1;\n      }\n      if ( (dword_80DBB9C & 0x8000) != 0 )\n        *(_DWORD *)(v0 + 84) = v5 - 1;\n      sub_8056D7F(*(_DWORD *)(v0 + 84));\n    }\n  }\n  else\n  {\n    free(v1);\n    sub_80568D9();\n  }\n}\n"
        ],
        "134574328": [
            "sub_80570F8",
            "0x80570f8",
            "int __cdecl sub_80570F8(int a1, int a2)\n{\n  void *v2; // ebx\n  int v3; // edi\n  char *v4; // eax\n  char *v5; // ebx\n  int v6; // esi\n  int v7; // ebx\n  unsigned int v8; // eax\n  signed int v10; // eax\n  signed int v11; // ebx\n  bool v12; // zf\n  bool v13; // zf\n  bool v14; // zf\n  bool v15; // zf\n  int v16; // eax\n  int v17; // eax\n  int v18; // eax\n  int v19; // eax\n  int *v20; // esi\n  _BYTE *v21; // edi\n  const char *v22; // eax\n  FILE *v23; // ebp\n  unsigned int v24; // esi\n  int v25; // esi\n  int v26; // edi\n  int v27; // ebp\n  const char *v28; // eax\n  int v29; // ecx\n  char *v30; // eax\n  unsigned int v31; // eax\n  int v32; // esi\n  int v33; // edi\n  int v34; // ebp\n  _DWORD *v35; // esi\n  unsigned int v36; // eax\n  int v37; // edx\n  unsigned int j; // ecx\n  unsigned int v39; // eax\n  int v40; // edx\n  unsigned int i; // ecx\n  int v42; // eax\n  int v43; // esi\n  int v44; // edi\n  unsigned int v45; // eax\n  int v46; // ebx\n  int v47; // eax\n  bool v48; // zf\n  bool v49; // zf\n  int v50; // eax\n  int v51; // edx\n  unsigned int v52; // [esp+0h] [ebp-28h]\n  int v53; // [esp+0h] [ebp-28h]\n  int v54; // [esp+4h] [ebp-24h]\n  char v55[32]; // [esp+8h] [ebp-20h] BYREF\n\n  v2 = sub_804DB2E(0x10Cu);\n  dword_80DBB80 = (int)v2;\n  *((_DWORD *)v2 + 3) = -1;\n  *((_DWORD *)v2 + 14) = \"~\";\n  *((_DWORD *)v2 + 16) = 1;\n  *((_DWORD *)v2 + 9) = 1;\n  *((_BYTE *)v2 + 129) = 1;\n  *((_DWORD *)v2 + 22) = -1;\n  sub_80ABEAC(a2, \"EMmN~IFSs\");\n  v3 = a2 + 4 * optind;\n  *((_DWORD *)v2 + 15) = a1 - optind;\n  *((_DWORD *)v2 + 18) = v3;\n  if ( isatty(1) )\n  {\n    if ( *((_DWORD *)v2 + 15) )\n    {\n      *((_DWORD *)v2 + 17) = sub_804DB46(**((const char ***)v2 + 18));\n    }\n    else if ( isatty(0) )\n    {\n      sub_804CDC2();\n    }\n    if ( (dword_80DBB9C & 0x10) != 0 )\n      *((_DWORD *)v2 + 14) = &data;\n    v4 = sub_804E0D9(1);\n    v5 = v4;\n    if ( !v4 || (v6 = open64(v4), free(v5), v6 < 0) )\n    {\n      v6 = open64(\"/dev/tty\");\n      if ( v6 < 0 )\n        v6 = 1;\n    }\n    v7 = dword_80DBB80;\n    *(_DWORD *)(v7 + 8) = sub_804D61C(v6);\n    *(_DWORD *)(v7 + 4) = v6;\n    sub_804D9A3((struct termios *)(v7 + 132), v6, (struct termios *)(v7 + 192), 2);\n    sub_804D878(v6, (int *)(v7 + 32), (int *)(v7 + 28));\n    if ( *(_DWORD *)(v7 + 32) > 0x13u )\n    {\n      v8 = *(_DWORD *)(v7 + 28);\n      if ( v8 > 2 )\n      {\n        *(_DWORD *)(v7 + 28) = v8 - 2;\n        sub_804E6C8(117503054, (void (*)(int))sub_80562D9);\n        *(_DWORD *)(v7 + 48) = sub_804DAFA(4 * *(_DWORD *)(v7 + 28) + 4);\n        sub_8056BDC();\n        while ( 1 )\n        {\n          v10 = sub_8056EC2(-1);\n          v11 = v10;\n          if ( v10 == 81 )\nLABEL_96:\n            sub_80562A6(0);\n          if ( v10 > 81 )\n          {\n            if ( v10 == 110 )\n            {\n              v16 = *(_DWORD *)(dword_80DBB80 + 84) + 1;\n              goto LABEL_108;\n            }\n            if ( v10 > 110 )\n            {\n              if ( v10 == 117 )\n              {\n                v17 = (unsigned int)(*(_DWORD *)(dword_80DBB80 + 28) + 1) >> 1;\n                goto LABEL_90;\n              }\n              if ( v10 <= 117 )\n              {\n                if ( v10 == 113 )\n                  goto LABEL_96;\n                if ( v10 > 113 )\n                {\n                  if ( v10 != 114 )\n                  {\n                    if ( v10 == 115 )\n                    {\n                      sub_80562E4(\"Log file: \");\n                      v21 = sub_8056EF9(10);\n                      v22 = &data;\n                      if ( *v21 )\n                      {\n                        v23 = (FILE *)sub_80B3D4F();\n                        v22 = \"Error opening log file\";\n                        v24 = 0;\n                        if ( v23 )\n                        {\n                          while ( v24 <= *(_DWORD *)(dword_80DBB80 + 20) )\n                            fprintf(v23, \"%s\\n\", *(const char **)(*(_DWORD *)(dword_80DBB80 + 52) + 4 * v24++));\n                          fclose(v23);\n                          v22 = \"Done\";\n                        }\n                      }\n                      sub_80562E4(v22);\n                      free(v21);\n                    }\n                    goto LABEL_142;\n                  }\nLABEL_97:\n                  sub_80568D9();\n                  goto LABEL_142;\n                }\n                v13 = v10 == 112;\n                goto LABEL_32;\n              }\n              if ( v10 == 122 )\n                goto LABEL_87;\n              if ( v10 > 122 )\n              {\n                if ( v10 == 123 )\n                {\nLABEL_110:\n                  v25 = dword_80DBB80;\n                  v26 = *(_DWORD *)dword_80DBB80;\n                  v52 = *(_DWORD *)(dword_80DBB80 + 20);\n                  if ( *(_DWORD *)dword_80DBB80 >= v52\n                    || (v27 = *(_DWORD *)(dword_80DBB80 + 52),\n                        !strchr(*(const char **)(v27 + 4 * v26), (unsigned __int8)v10)) )\n                  {\n                    v28 = \"No bracket in top line\";\n                    goto LABEL_121;\n                  }\n                  v29 = (unsigned __int8)sub_8056246((unsigned __int8)v11);\n                  while ( 1 )\n                  {\n                    v54 = v29;\n                    v30 = strchr(*(const char **)(v27 + 4 * v26), v29);\n                    v29 = v54;\n                    if ( v30 )\n                      break;\n                    if ( v52 <= ++v26 )\n                    {\nLABEL_117:\n                      v28 = \"No matching bracket found\";\n                      goto LABEL_121;\n                    }\n                  }\n                  v19 = v26 - *(_DWORD *)(v25 + 28);\n                }\n                else\n                {\n                  v15 = v10 == 125;\nLABEL_84:\n                  if ( !v15 )\n                    goto LABEL_142;\nLABEL_118:\n                  v31 = *(_DWORD *)dword_80DBB80 + *(_DWORD *)(dword_80DBB80 + 28);\n                  v32 = v31;\n                  if ( v31 >= *(_DWORD *)(dword_80DBB80 + 20)\n                    || (v33 = *(_DWORD *)(dword_80DBB80 + 52),\n                        !strchr(*(const char **)(v33 + 4 * v31), (unsigned __int8)v11)) )\n                  {\n                    v28 = \"No bracket in bottom line\";\nLABEL_121:\n                    sub_80562E4(v28);\n                    goto LABEL_142;\n                  }\n                  v34 = (unsigned __int8)sub_8056246((unsigned __int8)v11);\n                  while ( 1 )\n                  {\n                    if ( v32 < 0 )\n                      goto LABEL_117;\n                    if ( strchr(*(const char **)(v33 + 4 * v32), v34) )\n                      break;\n                    --v32;\n                  }\n                  v19 = v32;\n                }\n                goto LABEL_95;\n              }\n              if ( v10 == 119 )\n                goto LABEL_89;\n              v14 = v10 == 121;\n            }\n            else\n            {\n              if ( v10 == 100 )\n              {\n                v18 = (unsigned int)(*(_DWORD *)(dword_80DBB80 + 28) + 1) >> 1;\n                goto LABEL_88;\n              }\n              if ( v10 <= 100 )\n              {\n                if ( v10 == 91 )\n                  goto LABEL_110;\n                if ( v10 <= 91 )\n                {\n                  if ( v10 != 82 )\n                    goto LABEL_142;\n                  goto LABEL_97;\n                }\n                if ( v10 == 93 )\n                  goto LABEL_118;\n                if ( v10 != 98 )\n                  goto LABEL_142;\nLABEL_89:\n                v17 = *(_DWORD *)(dword_80DBB80 + 28) + 1;\nLABEL_90:\n                sub_8056D0F(v17);\n                goto LABEL_142;\n              }\n              if ( v10 == 103 )\n                goto LABEL_93;\n              if ( v10 <= 103 )\n              {\n                if ( v10 != 101 )\n                {\n                  v12 = v10 == 102;\nLABEL_64:\n                  if ( !v12 )\n                    goto LABEL_142;\n                  goto LABEL_87;\n                }\nLABEL_86:\n                v18 = 1;\nLABEL_88:\n                sub_8056CDB(v18);\n                goto LABEL_142;\n              }\n              if ( v10 == 106 )\n                goto LABEL_86;\n              v14 = v10 == 107;\n            }\n          }\n          else\n          {\n            if ( v10 == 40 )\n              goto LABEL_110;\n            if ( v10 > 40 )\n            {\n              if ( v10 == 61 )\n              {\nLABEL_105:\n                sub_805676E();\n                goto LABEL_142;\n              }\n              if ( v10 <= 61 )\n              {\n                if ( v10 == 47 )\n                {\n                  dword_80DBB9C &= ~0x8000u;\n                  goto LABEL_109;\n                }\n                if ( v10 <= 47 )\n                {\n                  v15 = v10 == 41;\n                  goto LABEL_84;\n                }\n                if ( v10 == 58 )\n                {\n                  sub_80562E4(\" :\");\n                  switch ( sub_8056EC2(2) )\n                  {\n                    case 'd':\n                      v35 = (_DWORD *)dword_80DBB80;\n                      if ( *(_DWORD *)(dword_80DBB80 + 60) > 1u )\n                      {\n                        if ( *(_DWORD *)(dword_80DBB80 + 64) == 1 )\n                        {\n                          sub_8056C80(1);\n                          v39 = v35[15];\n                          v40 = 4;\n                          for ( i = 2; i <= v39; ++i )\n                          {\n                            *(_DWORD *)(v35[18] + v40 - 4) = *(_DWORD *)(v35[18] + v40);\n                            v40 += 4;\n                          }\n                          v35[15] = v39 - 1;\n                          --v35[16];\n                        }\n                        else\n                        {\n                          sub_8056C80(-1);\n                          v36 = v35[15];\n                          v37 = 8;\n                          for ( j = 3; j <= v36; ++j )\n                          {\n                            *(_DWORD *)(v35[18] + v37 - 4) = *(_DWORD *)(v35[18] + v37);\n                            v37 += 4;\n                          }\n                          v35[15] = v36 - 1;\n                        }\n                      }\n                      goto LABEL_142;\n                    case 'e':\n                      goto LABEL_104;\n                    case 'f':\n                      goto LABEL_105;\n                    case 'n':\n                      v42 = 1;\n                      goto LABEL_141;\n                    case 'p':\n                      v42 = -1;\n                      goto LABEL_141;\n                    case 'q':\n                      goto LABEL_96;\n                    case 'x':\n                      v42 = 0;\nLABEL_141:\n                      sub_8056C80(v42);\n                      break;\n                    default:\n                      goto LABEL_142;\n                  }\n                  goto LABEL_142;\n                }\n                v13 = v10 == 60;\nLABEL_32:\n                if ( !v13 )\n                  goto LABEL_142;\nLABEL_93:\n                v19 = 0;\nLABEL_95:\n                sub_8056D4C(v19, 0);\n                goto LABEL_142;\n              }\n              if ( v10 == 69 )\n              {\nLABEL_104:\n                sub_8056F88();\n                goto LABEL_142;\n              }\n              if ( v10 > 69 )\n              {\n                if ( v10 == 71 )\n                  goto LABEL_94;\n                if ( v10 == 78 )\n                {\n                  v16 = *(_DWORD *)(dword_80DBB80 + 84) - 1;\nLABEL_108:\n                  sub_8056D7F(v16);\n                  goto LABEL_142;\n                }\n              }\n              else\n              {\n                if ( v10 == 62 )\n                  goto LABEL_94;\n                if ( v10 == 63 )\n                {\n                  dword_80DBB9C |= 0x8000u;\nLABEL_109:\n                  sub_8056FFA();\n                  goto LABEL_142;\n                }\n              }\n              goto LABEL_142;\n            }\n            if ( v10 == -3 )\n              goto LABEL_86;\n            if ( v10 <= -3 )\n            {\n              if ( v10 == -10 )\n                goto LABEL_89;\n              if ( v10 > -10 )\n              {\n                if ( v10 != -7 )\n                {\n                  v13 = v10 == -6;\n                  goto LABEL_32;\n                }\nLABEL_94:\n                v20 = (int *)dword_80DBB80;\n                *(_DWORD *)dword_80DBB80 = 9999999;\n                sub_8056375();\n                v19 = *v20;\n                goto LABEL_95;\n              }\n              v12 = v10 == -11;\n              goto LABEL_64;\n            }\n            if ( v10 == 13 )\n              goto LABEL_86;\n            if ( v10 > 13 )\n            {\n              if ( v10 != 32 )\n              {\n                v13 = v10 == 37;\n                goto LABEL_32;\n              }\nLABEL_87:\n              v18 = *(_DWORD *)(dword_80DBB80 + 28) + 1;\n              goto LABEL_88;\n            }\n            v14 = v10 == -2;\n          }\n          if ( v14 )\n          {\n            v17 = 1;\n            goto LABEL_90;\n          }\nLABEL_142:\n          if ( (unsigned __int8)(v11 - 48) <= 9u )\n          {\n            v55[0] = v11;\n            sub_805628D();\n            printf(\":%c\", v11);\n            v43 = 1;\n            do\n            {\n              v44 = v43 + 1;\n              v45 = sub_8056EC2(v43 + 1);\n              v46 = v45;\n              if ( v45 > 0xFF )\n                break;\n              if ( (unsigned __int8)(v45 - 48) > 9u )\n                break;\n              v55[v43] = v45;\n              sub_804DD98(v45);\n              ++v43;\n            }\n            while ( v44 != 15 );\n            v55[v43] = 0;\n            v47 = sub_804ED6C(10, v55, 0, v46);\n            if ( (unsigned int)(v47 - 1) <= 0x98967E )\n            {\n              if ( v46 == 71 )\n                goto LABEL_183;\n              if ( v46 > 71 )\n              {\n                if ( v46 == 110 )\n                {\n                  sub_8056D7F(*(_DWORD *)(dword_80DBB80 + 84) + v47);\n                }\n                else if ( v46 > 110 )\n                {\n                  if ( v46 == 119 )\n                    goto LABEL_182;\n                  if ( v46 > 119 )\n                  {\n                    if ( v46 == 121 )\n                      goto LABEL_182;\n                    v48 = v46 == 122;\nLABEL_180:\n                    if ( v48 )\nLABEL_181:\n                      sub_8056CDB(v47);\n                  }\n                  else\n                  {\n                    if ( v46 == 112 )\n                      goto LABEL_184;\n                    v49 = v46 == 117;\nLABEL_176:\n                    if ( v49 )\n                      goto LABEL_182;\n                  }\n                }\n                else\n                {\n                  if ( v46 <= 101 )\n                  {\n                    if ( v46 >= 100 )\n                      goto LABEL_181;\n                    v49 = v46 == 98;\n                    goto LABEL_176;\n                  }\n                  if ( v46 == 103 )\n                  {\nLABEL_183:\n                    v50 = v47 - 1;\n                    goto LABEL_187;\n                  }\n                }\n              }\n              else if ( v46 == 37 )\n              {\nLABEL_184:\n                v53 = v47;\n                sub_80566B7();\n                v51 = *(_DWORD *)(dword_80DBB80 + 76);\n                if ( v51 <= 0 )\n                  v51 = *(_DWORD *)(dword_80DBB80 + 24);\n                v50 = v51 * v53 / 0x64u;\nLABEL_187:\n                sub_8056D4C(v50, 1);\n              }\n              else if ( v46 > 37 )\n              {\n                if ( v46 == 60 )\n                  goto LABEL_183;\n                if ( v46 > 60 )\n                {\n                  if ( v46 == 62 )\n                    goto LABEL_183;\n                  if ( v46 == 63 )\n                  {\n                    dword_80DBB9C |= 0x8000u;\nLABEL_189:\n                    sub_8056FFA();\n                  }\n                }\n                else if ( v46 == 47 )\n                {\n                  dword_80DBB9C &= ~0x8000u;\n                  goto LABEL_189;\n                }\n              }\n              else\n              {\n                if ( v46 != -2 )\n                {\n                  if ( v46 > -2 )\n                  {\n                    if ( v46 == 13 )\n                      goto LABEL_181;\n                    v48 = v46 == 32;\n                  }\n                  else\n                  {\n                    v48 = v46 == -3;\n                  }\n                  goto LABEL_180;\n                }\nLABEL_182:\n                sub_8056D0F(v47);\n              }\n            }\n            else\n            {\n              sub_80568D9();\n            }\n          }\n        }\n      }\n    }\n  }\n  return sub_80A98A4();\n}\n"
        ],
        "134576268": [
            "sub_805788C",
            "0x805788c",
            "char *__usercall sub_805788C@<eax>(int a1@<eax>, char *a2@<edx>, int *a3@<ecx>)\n{\n  char *v3; // ebx\n  int v5; // esi\n  signed int v6; // ecx\n  int v7; // eax\n  int v8; // eax\n\n  v3 = a2;\n  v5 = *a3;\n  v6 = *a3 - 2;\n  if ( v6 > 0 )\n  {\n    v7 = sub_804E632(a1, a2, v6);\n    if ( v7 < 0 )\n      v7 = 0;\n    v3[v7] = 0;\n    v8 = sub_80B2F61() - (_DWORD)v3 + 1;\n    v3 += v8;\n    *v3 = 0;\n    *a3 = v5 - v8;\n  }\n  return v3;\n}\n"
        ],
        "134576324": [
            "sub_80578C4",
            "0x80578c4",
            "int sub_80578C4()\n{\n  int v0; // edx\n  int v1; // ecx\n  int result; // eax\n  int v3; // edi\n  const char *v4; // ebx\n  char *v5; // esi\n  char *v6; // edi\n  char *v7; // ebp\n  unsigned int v8; // eax\n  DIR *v9; // [esp+0h] [ebp-118h]\n  int v10; // [esp+4h] [ebp-114h] BYREF\n  char v11[272]; // [esp+8h] [ebp-110h] BYREF\n\n  sub_804DF04(\"/sys/bus/scsi/devices\");\n  v9 = sub_804DF7E(\".\");\n  while ( 1 )\n  {\n    result = readdir64(v1, v0, v9);\n    if ( !result )\n      break;\n    v3 = *(unsigned __int8 *)(result + 19);\n    v0 = v3 - 48;\n    if ( (unsigned __int8)(v3 - 48) <= 9u )\n    {\n      v4 = (const char *)(result + 19);\n      if ( strchr((const char *)(result + 19), 58) )\n      {\n        if ( !chdir(v4) )\n        {\n          v10 = 256;\n          v5 = sub_805788C((int)\"vendor\", v11, &v10);\n          v6 = sub_805788C((int)\"type\", v5, &v10);\n          v7 = sub_805788C((int)\"model\", v6, &v10);\n          sub_805788C((int)\"rev\", v7, &v10);\n          printf(\"[%s]\\t\", v4);\n          v8 = sub_804ED6C(10, v5, 0, (int)v4);\n          if ( *(_DWORD *)dword_80DBB7C || v8 > 0x1F || !*sub_804D2B4(\"disk\", v8) )\n            printf(\"(%s)\\t\");\n          else\n            printf(\"%s\\t\");\n          printf(\"%s\\t%s\\t%s\\n\", v11, v6, v7);\n          sub_804DF04(\"/sys/bus/scsi/devices\");\n        }\n      }\n    }\n  }\n  return result;\n}\n"
        ],
        "134576621": [
            "sub_80579ED",
            "0x80579ed",
            "int __cdecl sub_80579ED(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // ebp\n  int v4; // esi\n  __gid_t v5; // eax\n  __uid_t v6; // eax\n  char *v7; // ebx\n  __mode_t v8; // edx\n  char *v9; // edi\n  __dev_t v10; // rax\n  unsigned int v12; // [esp+0h] [ebp-F8h]\n  __gid_t group; // [esp+4h] [ebp-F4h]\n  __uid_t owner; // [esp+8h] [ebp-F0h]\n  int v15; // [esp+Ch] [ebp-ECh]\n  unsigned __int8 v16; // [esp+13h] [ebp-E5h] BYREF\n  char *s; // [esp+14h] [ebp-E4h] BYREF\n  __mode_t mode; // [esp+18h] [ebp-E0h] BYREF\n  unsigned int v19; // [esp+1Ch] [ebp-DCh] BYREF\n  int v20; // [esp+20h] [ebp-D8h] BYREF\n  unsigned int v21; // [esp+24h] [ebp-D4h] BYREF\n  int v22; // [esp+28h] [ebp-D0h] BYREF\n  int v23; // [esp+2Ch] [ebp-CCh] BYREF\n  int v24; // [esp+30h] [ebp-C8h] BYREF\n  char v25; // [esp+36h] [ebp-C2h] BYREF\n  char v26; // [esp+5Fh] [ebp-99h] BYREF\n  char v27[16]; // [esp+88h] [ebp-70h] BYREF\n  int v28; // [esp+98h] [ebp-60h]\n\n  s = \"-\";\n  sub_80ABEAC(a2, \"^d:\", &s);\n  v2 = (const char **)(a2 + 4 * optind);\n  sub_804DF04(*v2);\n  umask(0);\n  printf(\"rootdir=%s\\ntable=\", *v2);\n  if ( *s == 45 && !s[1] )\n    puts(\"<stdin>\");\n  else\n    printf(\"'%s'\\n\", s);\n  v15 = sub_80B052C();\n  v3 = 0;\nLABEL_6:\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    mode = 493;\n    v19 = 0;\n    v20 = 0;\n    v21 = 0;\n    v22 = 0;\n    v23 = 0;\n    v4 = *(_DWORD *)(v15 + 24);\n    if ( sscanf(s, \"%*s%n %c %o %40s %40s %u %u %u %u %u\", &v24, &v16, &mode, &v25, &v26, &v19, &v20, &v23, &v22, &v21) <= 0\n      || (v22 | v21 | v23 | v20 | v19) > 0xFF )\n    {\n      sub_804D5F4(\"invalid line %d: '%s'\", v4, s);\n      goto LABEL_36;\n    }\n    if ( v26 )\n      v5 = sub_80A9A55();\n    else\n      v5 = getgid();\n    group = v5;\n    if ( v25 )\n      v6 = sub_80A9A55();\n    else\n      v6 = getuid();\n    owner = v6;\n    s[v24] = 0;\n    v7 = s;\n    if ( *s == 47 )\n      v7 = s + 1;\n    if ( v16 == 100 )\n    {\n      v8 = mode;\n      BYTE1(v8) = BYTE1(mode) | 0x40;\n      sub_80B00B9(4, v8);\n      if ( chown(v7, owner, group) == -1 )\n        goto LABEL_20;\nLABEL_25:\n      if ( chmod(v7, mode) < 0 )\n      {\n        sub_804D3A5((int)\"line %d: can't chmod %s\", v4, v7);\n        goto LABEL_36;\n      }\n    }\n    else\n    {\n      switch ( v16 )\n      {\n        case 'f':\n          if ( stat64(v7, v27) >= 0 && (v28 & 0xF000) == 0x8000 )\n          {\n            if ( chown(v7, owner, group) < 0 )\n            {\nLABEL_20:\n              sub_804D3A5((int)\"line %d: can't chown %s\", v4, v7);\n              break;\n            }\n            goto LABEL_25;\n          }\n          sub_804D3A5((int)\"line %d: regular file '%s' does not exist\", v4, v7);\n          break;\n        case 'p':\n          mode |= 0x1000u;\n          goto LABEL_37;\n        case 'c':\n          mode |= 0x2000u;\n          goto LABEL_37;\n        case 'b':\n          mode |= 0x6000u;\nLABEL_37:\n          if ( v21 )\n            --v21;\n          v12 = 0;\n          while ( 2 )\n          {\n            if ( v21 < v12 )\n              goto LABEL_6;\n            v9 = v7;\n            if ( v21 )\n              v9 = sub_804DDBF(\"%s%u\", v7, v23 + v12);\n            v10 = sub_80B0220();\n            if ( mknod(v9, mode, v10) && *(_DWORD *)dword_80DBB7C != 17 )\n            {\n              sub_804D3A5((int)\"line %d: can't create node %s\", v4, v9);\n              goto LABEL_50;\n            }\n            if ( chown(v9, owner, group) < 0 )\n            {\n              sub_804D3A5((int)\"line %d: can't chown %s\", v4, v9);\n              goto LABEL_50;\n            }\n            if ( chmod(v9, mode) < 0 )\n            {\n              sub_804D3A5((int)\"line %d: can't chmod %s\", v4, v9);\nLABEL_50:\n              v3 = 1;\n            }\n            if ( v21 )\n              free(v9);\n            ++v12;\n            continue;\n          }\n        default:\n          sub_804D5F4(\"line %d: unsupported file type %c\", v4, v16);\n          break;\n      }\nLABEL_36:\n      v3 = 1;\n    }\n  }\n  return v3;\n}\n"
        ],
        "134577490": [
            "sub_8057D52",
            "0x8057d52",
            "int __cdecl sub_8057D52(int a1, int a2)\n{\n  const char **v2; // ebp\n  char *v3; // eax\n  char *v4; // esi\n  int v5; // eax\n  int v6; // ebx\n  __pid_t v7; // eax\n  int v8; // eax\n  int v9; // ebx\n  speed_t v10; // eax\n  const char *v11; // ebp\n  nfds_t v12; // edi\n  signed int v13; // eax\n  char v15; // [esp+0h] [ebp-E8h]\n  char buf; // [esp+7h] [ebp-E1h] BYREF\n  int v17; // [esp+8h] [ebp-E0h] BYREF\n  int v18; // [esp+Ch] [ebp-DCh] BYREF\n  int timeout; // [esp+10h] [ebp-D8h] BYREF\n  struct pollfd fds; // [esp+14h] [ebp-D4h] BYREF\n  int v21; // [esp+1Ch] [ebp-CCh]\n  __int16 v22; // [esp+20h] [ebp-C8h]\n  __int16 v23; // [esp+22h] [ebp-C6h]\n  struct termios v24; // [esp+24h] [ebp-C4h] BYREF\n  struct termios v25; // [esp+60h] [ebp-88h] BYREF\n  struct termios termios_p; // [esp+9Ch] [ebp-4Ch] BYREF\n\n  v17 = 9600;\n  v18 = -1;\n  timeout = -1;\n  v15 = sub_80ABEAC(a2, \"^Xs:+d:+t:+\", &v17, &v18, &timeout);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = sub_804D315(*v2);\n  v4 = sub_804DDBF(\"/var/lock/LCK..%s\", v3);\n  v5 = open64(v4);\n  if ( v5 >= 0 )\n  {\n    v6 = v5;\n    v7 = getpid();\n    dprintf(v6, \"%4d\\n\", v7);\n    close(v6);\n  }\n  else\n  {\n    if ( *(_DWORD *)dword_80DBB7C == 17 )\n      sub_804D3C9((int)\"can't create '%s'\", v4);\n    v4 = 0;\n  }\n  sub_804E6C8(40966, (void (*)(int))sub_804E68E);\n  byte_80DBBA4 = 1;\n  v8 = sub_804DC14(*v2);\n  v9 = v8;\n  if ( v8 >= 0 )\n  {\n    fcntl64(v8, 4);\n    sub_804D9A3(&v25, v9, &termios_p, 15);\n    v10 = sub_80B2EFA();\n    cfsetspeed(&termios_p, v10);\n    v11 = *v2;\n    if ( tcsetattr(v9, 2, &termios_p) )\n    {\n      sub_804D3A5((int)\"can't tcsetattr for %s\", v11);\n      goto LABEL_15;\n    }\n    if ( isatty(0) )\n    {\n      sub_804D9A3(&v24, 0, &termios_p, 15);\n      if ( tcsetattr(0, 2, &termios_p) )\n      {\n        sub_804D3A5((int)\"can't tcsetattr for %s\", \"stdin\");\n        goto LABEL_15;\n      }\n    }\n    fds.fd = v9;\n    fds.events = 1;\n    v21 = 0;\n    v22 = 1;\n    byte_80DBBA4 = 0;\n    v12 = 2;\n    while ( 1 )\n    {\n      if ( byte_80DBBA4 || poll(&fds, v12, timeout) <= 0 )\n      {\nLABEL_13:\n        tcsetattr(v9, 2, &v25);\n        if ( isatty(0) )\n          tcsetattr(0, 2, &v24);\n        goto LABEL_15;\n      }\n      if ( v12 != 2 )\n        break;\n      if ( v23 )\n      {\n        if ( sub_804E5BC(1u, &buf, 0) <= 0 )\n          break;\n        if ( (v15 & 1) != 0 )\n          goto LABEL_26;\n        if ( buf )\n        {\n          if ( buf == 24 )\n            goto LABEL_13;\nLABEL_26:\n          write(v9, &buf, 1u);\n          if ( v18 >= 0 )\n            sub_80B2C0A(v18, 1u);\n          goto LABEL_29;\n        }\n        tcsendbreak(v9, 0);\n      }\nLABEL_29:\n      if ( fds.revents )\n      {\n        v13 = sub_804E5BC(0x400u, &::buf, v9);\n        if ( v13 <= 0 )\n        {\n          byte_80DBBA4 = 1;\n          goto LABEL_13;\n        }\n        sub_804E586(v13, (char *)&::buf);\n      }\n    }\n    v12 = 1;\n    goto LABEL_29;\n  }\nLABEL_15:\n  if ( v4 )\n    unlink(v4);\n  return byte_80DBBA4;\n}\n"
        ],
        "134578180": [
            "sub_8058004",
            "0x8058004",
            "int __cdecl sub_8058004(int a1, _DWORD *a2)\n{\n  _DWORD *v2; // ebx\n  const char *v3; // eax\n  const char *v4; // esi\n  int v5; // eax\n  __int16 v6; // di\n  int v7; // eax\n  int v9; // [esp+0h] [ebp-18h] BYREF\n  int v10; // [esp+4h] [ebp-14h] BYREF\n  int v11; // [esp+8h] [ebp-10h]\n\n  v2 = a2;\n  v3 = (const char *)a2[1];\n  if ( !v3 )\nLABEL_2:\n    sub_804CDC2();\n  if ( !strcmp(v3, \"-f\") )\n  {\n    v4 = (const char *)a2[2];\n    if ( !v4 || !a2[3] )\n      goto LABEL_2;\n    v2 = a2 + 2;\n  }\n  else\n  {\n    v4 = \"/dev/tape\";\n  }\n  v5 = sub_804D222(\"bsf\", (const char *)v2[1]);\n  if ( v5 < 0 )\n    sub_804D5E0(\"unrecognized opcode %s\", (const char *)v2[1]);\n  v6 = word_80B5520[v5];\n  LOWORD(v10) = v6;\n  if ( v2[2] )\n    v11 = sub_80B4187();\n  else\n    v11 = 1;\n  v7 = sub_804DBE1(v4);\n  if ( v6 == 23 )\n  {\n    sub_804E029(v7, 0x80046D03, (int)&v9, \"%s\", v4);\n    printf(\"At block %d\\n\", v9);\n  }\n  else\n  {\n    sub_804E029(v7, 0x40086D01u, (int)&v10, \"%s\", v4);\n  }\n  return 0;\n}\n"
        ],
        "134578426": [
            "sub_80580FA",
            "0x80580fa",
            "const char *__cdecl sub_80580FA(int a1, int a2)\n{\n  const char **i; // ebx\n  const char *result; // eax\n  int v4; // esi\n\n  sub_80ABEAC(a2, &data);\n  for ( i = (const char **)(a2 + 4 * optind); ; ++i )\n  {\n    result = *i;\n    if ( !*i )\n      break;\n    v4 = sub_804DBE1(result);\n    sub_804E029(v4, 0x125Fu, 0, \"%s\", *i);\n    close(v4);\n  }\n  return result;\n}\n"
        ],
        "134578505": [
            "sub_8058149",
            "0x8058149",
            "int __cdecl sub_8058149(int a1, int a2)\n{\n  struct utmpx *v2; // eax\n  __pid_t ut_pid; // ecx\n  int v4; // ebx\n\n  if ( *(_DWORD *)(a2 + 4) )\n    utmpxname(*(_DWORD *)(a2 + 4));\n  setutxent();\n  do\n  {\n    v2 = getutxent();\n    if ( !v2 )\n    {\n      puts(\"unknown\");\n      return 1;\n    }\n  }\n  while ( v2->ut_type != 1 );\n  ut_pid = v2->ut_pid;\n  v4 = (unsigned __int8)(ut_pid / 256);\n  if ( !(unsigned __int8)(ut_pid / 256) )\n    v4 = 78;\n  printf(\"%c %c\\n\", v4, ut_pid % 256);\n  return 0;\n}\n"
        ],
        "134578618": [
            "sub_80581BA",
            "0x80581ba",
            "int __cdecl sub_80581BA(int a1, int a2)\n{\n  const char **v2; // ebx\n  int (*v3)(const char *, const char *, const void *, size_t, int); // esi\n  int (*v4)(const char *, const char *); // edi\n  const char *v5; // ebp\n  int v6; // eax\n  size_t v7; // eax\n  char v9; // [esp+4h] [ebp-28h]\n  int v10; // [esp+8h] [ebp-24h]\n  char *value; // [esp+Ch] [ebp-20h]\n  const char *v12; // [esp+10h] [ebp-1Ch]\n  char *name; // [esp+14h] [ebp-18h] BYREF\n  char *s; // [esp+18h] [ebp-14h] BYREF\n\n  s = (char *)&data;\n  v9 = sub_80ABEAC(a2, \"^hx:n:v:\", &name, &name, &s);\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( (v9 & 1) != 0 )\n  {\n    v3 = lsetxattr;\n    v4 = lremovexattr;\n  }\n  else\n  {\n    v3 = setxattr;\n    v4 = removexattr;\n  }\n  v10 = 0;\n  do\n  {\n    v5 = *v2;\n    if ( (v9 & 2) != 0 )\n    {\n      v6 = v4(v5, name);\n    }\n    else\n    {\n      v12 = name;\n      value = s;\n      v7 = strlen(s);\n      v6 = v3(v5, v12, value, v7, 0);\n    }\n    if ( v6 )\n    {\n      sub_804D3F1(*v2);\n      v10 = 1;\n    }\n    ++v2;\n  }\n  while ( *v2 );\n  return v10;\n}\n"
        ],
        "134578811": [
            "sub_805827B",
            "0x805827b",
            "int __usercall sub_805827B@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // esi\n\n  v4 = 0;\n  while ( *a1 )\n  {\n    if ( !strcasecmp(a1, a2) )\n      return v4;\n    a1 += strlen(a1) + 1;\n    ++v4;\n  }\n  return -1;\n}\n"
        ],
        "134578861": [
            "sub_80582AD",
            "0x80582ad",
            "int __usercall sub_80582AD@<eax>(char *a1@<eax>, int a2@<ebx>)\n{\n  return sub_804EDC5(0, a1, 0, a2);\n}\n"
        ],
        "134578870": [
            "sub_80582B6",
            "0x80582b6",
            "int __usercall sub_80582B6@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>)\n{\n  int v6; // ebx\n  const char *v7; // eax\n\n  v6 = a2 & 1;\n  if ( (a2 & 1) != 0 && (v6 = ioctl(a1, 0x541Fu, a3), v6 < 0) )\n  {\n    v7 = \"can't set serial info\";\n  }\n  else if ( (a2 & 2) != 0 && (v6 = ioctl(a1, 0x5453u), v6 < 0) )\n  {\n    v7 = \"can't autoconfigure port\";\n  }\n  else\n  {\n    if ( (a2 & 4) == 0 )\n      goto LABEL_7;\n    v6 = ioctl(a1, 0x541Eu, a3);\n    if ( v6 >= 0 )\n      goto LABEL_7;\n    v7 = \"can't get serial info\";\n  }\n  sub_804D3F1(v7);\n  if ( (a2 & 0x10) == 0 )\n    exit(1);\nLABEL_7:\n  if ( (a2 & 8) != 0 )\n    close(a1);\n  return v6;\n}\n"
        ],
        "134579024": [
            "sub_8058350",
            "0x8058350",
            "int __cdecl sub_8058350(int a1, int a2)\n{\n  int v2; // esi\n  const char *v3; // ebx\n  int v4; // eax\n  int v5; // ebp\n  char **i; // ecx\n  char **v7; // ebx\n  char *v8; // edi\n  bool j; // zf\n  const char *v10; // ebx\n  int v11; // eax\n  const char *v12; // eax\n  const char *v13; // edi\n  const char *v14; // ebx\n  int v15; // eax\n  int v16; // ecx\n  int v17; // edx\n  int k; // ebp\n  const char *v19; // edi\n  int v20; // eax\n  char *v21; // edi\n  int v22; // eax\n  char *v23; // edi\n  int v24; // edx\n  int v25; // eax\n  const char *v26; // eax\n  const char *v27; // eax\n  int v29; // [esp+0h] [ebp-5Ch]\n  char v30; // [esp+0h] [ebp-5Ch]\n  char v31; // [esp+4h] [ebp-58h]\n  unsigned __int16 v32; // [esp+8h] [ebp-54h]\n  char **v33; // [esp+8h] [ebp-54h]\n  const char *v34; // [esp+Ch] [ebp-50h]\n  int v35[2]; // [esp+10h] [ebp-4Ch] BYREF\n  int v36; // [esp+18h] [ebp-44h]\n  int v37; // [esp+1Ch] [ebp-40h]\n  int v38; // [esp+20h] [ebp-3Ch]\n  int v39; // [esp+28h] [ebp-34h]\n  int v40; // [esp+2Ch] [ebp-30h]\n  unsigned __int16 v41; // [esp+30h] [ebp-2Ch]\n  unsigned __int16 v42; // [esp+38h] [ebp-24h]\n\n  v31 = sub_80ABEAC(a2, \"^bGavzgq\");\n  v2 = a2 + 4 * optind;\n  if ( !*(_DWORD *)(v2 + 4) )\n    v31 |= 0x20u;\n  if ( (v31 & 0x20) == 0 )\n  {\n    v3 = *(const char **)v2;\n    v4 = sub_80AA444();\n    v5 = v4;\n    if ( v4 < 0 )\n    {\n      sub_804D3F1(v3);\n      exit(201);\n    }\n    sub_80582B6(v4, 4, (int)v35);\n    if ( (v31 & 0x10) != 0 )\n      v38 = 0;\n    for ( i = (char **)v2; ; i = v7 )\n    {\n      v7 = i + 1;\n      v8 = i[1];\n      if ( !v8 )\n        break;\n      v33 = i;\n      v30 = *v8;\n      v19 = &v8[*v8 == 94];\n      v20 = sub_805827B(\"spd_normal\", v19);\n      if ( v20 < 0 )\n        sub_804D5E0(\"invalid flag: %s\", v19);\n      if ( (unsigned int)(v20 - 16) <= 6 )\n      {\n        v7 = v33 + 2;\n        if ( !v33[2] )\n          sub_804D5E0(\"%s requires an argument\", v19);\n      }\n      if ( v30 == 94 )\n      {\n        if ( (unsigned int)(v20 - 6) > 9 )\n          sub_804D5E0(\"can't invert %s\", v19);\n        v38 &= ~(unsigned __int16)word_80B5580[v20];\n      }\n      else\n      {\n        switch ( v20 )\n        {\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n            v38 &= 0xFFFFEFCF;\n            goto LABEL_45;\n          case 6:\n          case 7:\n          case 8:\n          case 9:\n          case 10:\n          case 11:\n          case 12:\n          case 13:\n          case 14:\n          case 15:\nLABEL_45:\n            v38 |= (unsigned __int16)word_80B5580[v20];\n            break;\n          case 16:\n            v36 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 17:\n            v37 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 18:\n            v39 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 19:\n            v21 = *v7;\n            v22 = sub_805827B(\"unknown\", *v7);\n            if ( v22 < 0 )\n              sub_804D5E0(\"illegal UART type: %s\", v21);\n            v35[0] = v22;\n            break;\n          case 20:\n            v40 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 21:\n            v41 = sub_80582AD(*v7, (int)v7);\n            break;\n          case 22:\n            v23 = *v7;\n            v24 = strcasecmp(*v7, \"none\");\n            LOWORD(v25) = -1;\n            if ( v24 )\n            {\n              v25 = strcasecmp(v23, \"infinite\");\n              if ( v25 )\n                LOWORD(v25) = sub_80582AD(v23, (int)v7);\n            }\n            v42 = v25;\n            break;\n          case 23:\n            sub_80582B6(v5, 7, (int)v35);\n            break;\n          default:\n            continue;\n        }\n      }\n    }\n    sub_80582B6(v5, 9, (int)v35);\n    *(_DWORD *)(v2 + 4) = 0;\n  }\n  for ( j = (v31 & 0x28) == 0; !j; j = *(_DWORD *)v2 == 0 )\n  {\n    v29 = v31 & 7;\n    v10 = *(const char **)v2;\n    v11 = sub_80AA444();\n    if ( v11 < 0 )\n    {\n      if ( v29 != 1 )\n        sub_804D3F1(v10);\n      goto LABEL_33;\n    }\n    if ( sub_80582B6(v11, 28, (int)v35) < 0 )\n      goto LABEL_33;\n    v12 = \"undefined\";\n    if ( v35[0] <= 19 )\n      v12 = sub_804D2B4(\"unknown\", v35[0]);\n    if ( v29 == 1 )\n    {\n      if ( !v35[0] )\n        goto LABEL_33;\n      printf(\"%s at 0x%.4x (irq = %d) is a %s\", v10, v36, v37, v12);\n      v13 = \")\";\n      v14 = \" IO_support\\t=%3ld (\" + 17;\n    }\n    else\n    {\n      if ( (v31 & 7u) <= 1 )\n      {\n        printf(\"%s, UART: %s, Port: 0x%.4x, IRQ: %d\", v10, v12, v36, v37);\nLABEL_72:\n        v13 = &data;\n        v14 = \", Flags: \";\n        goto LABEL_22;\n      }\n      if ( v29 == 2 )\n      {\n        printf(\"%s uart %s port 0x%.4x irq %d baud_base %d\", v10, v12, v36, v37, v40);\n        v13 = &data;\n        v14 = \"     \" + 4;\n        goto LABEL_22;\n      }\n      if ( v29 != 4 )\n        goto LABEL_72;\n      printf(\"%s, Line %d, UART: %s, Port: 0x%.4x, IRQ: %d\\n\", v10, v35[1], v12, v36, v37);\n      printf(\"\\tBaud_base: %d, close_delay: %u, divisor: %d\\n\", v40, v41, v39);\n      printf(\"\\tclosing_wait: \");\n      if ( v42 )\n      {\n        if ( v42 == 0xFFFF )\n          puts(\"none\");\n        else\n          printf(\"%u\\n\", v42);\n      }\n      else\n      {\n        puts(\"infinite\");\n      }\n      v13 = \"\\n\";\n      v14 = \"\\tFlags: \";\n    }\nLABEL_22:\n    v32 = v38;\n    v15 = v38 & 0x1030;\n    if ( v15 == 48 )\n    {\n      v17 = 5;\n      goto LABEL_80;\n    }\n    if ( (v38 & 0x1030u) > 0x30 )\n    {\n      if ( v15 == 4096 )\n      {\n        v17 = 3;\n        goto LABEL_80;\n      }\n      if ( v15 == 4112 )\n      {\n        v17 = 4;\n        goto LABEL_80;\n      }\n    }\n    else\n    {\n      if ( v15 == 16 )\n      {\n        v17 = 1;\n        goto LABEL_80;\n      }\n      if ( v15 == 32 )\n      {\n        v17 = 2;\nLABEL_80:\n        v26 = sub_804D2B4(\"spd_normal\", v17);\n        v16 = (int)v14;\n        if ( v26 )\n        {\n          printf(\"%s%s\", v14, v26);\n          v16 = 135056574;\n        }\n        goto LABEL_27;\n      }\n    }\n    v16 = (int)v14;\n    v17 = 0;\n    if ( (v31 & 7u) > 1 )\n      goto LABEL_80;\nLABEL_27:\n    for ( k = 6; k != 16; ++k )\n    {\n      if ( ((unsigned __int16)word_80B5580[k] & v32) != 0 && ((v31 & 7u) > 1 || (unsigned int)(k - 9) > 5) )\n      {\n        v34 = (const char *)v16;\n        v27 = sub_804D2B4(\"spd_normal\", k);\n        printf(\"%s%s\", v34, v27);\n        v16 = 135056574;\n      }\n    }\n    if ( v14 == (const char *)v16 )\n      v13 = &data;\n    puts(v13);\nLABEL_33:\n    v2 += 4;\n  }\n  return 0;\n}\n"
        ],
        "134580218": [
            "sub_80587FA",
            "0x80587fa",
            "void __cdecl __noreturn sub_80587FA(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  int v3; // esi\n  int v4; // eax\n  unsigned int v5; // eax\n  int v6; // ecx\n  int v7; // edi\n  unsigned int v8; // esi\n  unsigned __int8 *v9; // eax\n  int v10; // ebp\n  int v11; // [esp+0h] [ebp-3Ch]\n  _BYTE *v12; // [esp+8h] [ebp-34h]\n  char *format; // [esp+Ch] [ebp-30h]\n  __int64 v14; // [esp+10h] [ebp-2Ch]\n  const char *v15; // [esp+18h] [ebp-24h]\n  __int64 v16; // [esp+1Ch] [ebp-20h]\n  char *v17; // [esp+24h] [ebp-18h] BYREF\n  char v18[4]; // [esp+28h] [ebp-14h] BYREF\n\n  v17 = \"4\";\n  *(_DWORD *)v18 = \"o\";\n  sub_80ABEAC(a2, \"afon:t:\", &v17, v18);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  v3 = sub_80B40CC(0x7FFFFFFF, 1);\n  v12 = sub_804DB2E(v3 + 1);\n  v4 = v3 - 1;\n  v11 = v3 - 1;\n  LOBYTE(v4) = **(_BYTE **)v18;\n  v5 = v4 - 100;\n  if ( (unsigned __int8)v5 > 0x14u || (v6 = 1050625, !_bittest(&v6, v5)) || *(_BYTE *)(*(_DWORD *)v18 + 1) )\n    sub_804CDC2();\n  v15 = sub_804DDBF(\"%%7ll%s \", *(const char **)v18);\n  format = (_BYTE *)(\"\\n Drive conforms to: %s: \" + 21);\n  if ( !*v2 )\n  {\n    *--v2 = \"standard input\";\n    format = \"{%s}: \";\n  }\n  LODWORD(v16) = v3 - 1;\n  while ( 1 )\n  {\n    v7 = sub_80B3D76();\n    if ( v7 )\n    {\n      HIDWORD(v16) = v11 >> 31;\n      v14 = -v16;\n      v8 = 0;\n      do\n      {\n        v9 = *(unsigned __int8 **)(v7 + 16);\n        if ( (unsigned int)v9 >= *(_DWORD *)(v7 + 24) )\n        {\n          v10 = __fgetc_unlocked(v7);\n        }\n        else\n        {\n          *(_DWORD *)(v7 + 16) = v9 + 1;\n          v10 = *v9;\n        }\n        if ( (unsigned int)(v10 - 32) <= 0x5E || v10 == 9 )\n        {\n          if ( v8 <= v11 )\n          {\n            v12[v8] = v10;\n            if ( v8 == v11 )\n            {\n              if ( (dword_80DBB9C & 2) != 0 )\n                printf(format);\n              if ( (dword_80DBB9C & 0x14) != 0 )\n                printf(v15, v14);\n              fputs_unlocked(v12, stdout);\n            }\n            ++v8;\n          }\n          else\n          {\n            sub_804DD98(v10);\n          }\n        }\n        else\n        {\n          if ( v8 > v11 )\n            sub_804DD98(10);\n          v8 = 0;\n        }\n        ++v14;\n      }\n      while ( v10 != -1 );\n      sub_80AB218();\n    }\n    if ( !*++v2 )\n      sub_80AB247(v11);\n  }\n}\n"
        ],
        "134580670": [
            "sub_80589BE",
            "0x80589be",
            "unsigned int __usercall sub_80589BE@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>)\n{\n  if ( 0x7FFFFFFF / a1 >= a2 )\n    return (a2 * a1) >> 10;\n  else\n    return a1 * (a2 >> 10);\n}\n"
        ],
        "134580708": [
            "sub_80589E4",
            "0x80589e4",
            "__sighandler_t __fastcall sub_80589E4(int a1, int a2)\n{\n  __pid_t v2; // eax\n  __pid_t v3; // edi\n  void (*v4)(int); // esi\n  void (*v5)(int); // ebx\n  __pid_t v6; // eax\n\n  *(_DWORD *)(a2 + 76) = sub_804EC14();\n  v2 = vfork();\n  if ( v2 < 0 )\n    sub_804D3C9((int)&unk_80C7DA0);\n  if ( !v2 )\n    sub_80AB1EC();\n  v3 = v2;\n  v4 = signal(2, (__sighandler_t)1);\n  v5 = signal(3, (__sighandler_t)1);\n  while ( 1 )\n  {\n    v6 = wait3((void *)a2, 0, (struct rusage *)(a2 + 4));\n    if ( v3 == v6 )\n      break;\n    if ( v6 == -1 && *(_DWORD *)dword_80DBB7C != 4 )\n    {\n      sub_804D3A5((int)\"wait\");\n      goto LABEL_11;\n    }\n  }\n  *(_DWORD *)(a2 + 76) = sub_804EC14() - *(_DWORD *)(a2 + 76);\nLABEL_11:\n  signal(2, v4);\n  return signal(3, v5);\n}\n"
        ],
        "134580877": [
            "sub_8058A8D",
            "0x8058a8d",
            "void __cdecl __noreturn sub_8058A8D(int a1, int a2)\n{\n  char *v2; // eax\n  char v3; // al\n  int v4; // ecx\n  int v5; // ebx\n  char *v6; // esi\n  int v7; // ebx\n  unsigned int v8; // ebp\n  size_t v9; // eax\n  size_t v10; // edi\n  _DWORD *v11; // esi\n  const char *v12; // eax\n  unsigned int v13; // esi\n  unsigned int v14; // edx\n  unsigned int v15; // esi\n  unsigned int v16; // eax\n  unsigned int v17; // eax\n  int v18; // ecx\n  int v19; // edi\n  int v20; // eax\n  unsigned int v21; // edx\n  unsigned int v22; // [esp-Ch] [ebp-84h]\n  unsigned int v23; // [esp-Ch] [ebp-84h]\n  unsigned int v24; // [esp-8h] [ebp-80h]\n  unsigned int v25; // [esp-8h] [ebp-80h]\n  unsigned int v26; // [esp-4h] [ebp-7Ch]\n  unsigned int v27; // [esp-4h] [ebp-7Ch]\n  int v28; // [esp-4h] [ebp-7Ch]\n  int v29; // [esp-4h] [ebp-7Ch]\n  int v30; // [esp+0h] [ebp-78h]\n  _DWORD *v31; // [esp+4h] [ebp-74h]\n  char *v32; // [esp+8h] [ebp-70h]\n  unsigned int v33; // [esp+Ch] [ebp-6Ch]\n  char *s; // [esp+10h] [ebp-68h] BYREF\n  const char *v35; // [esp+14h] [ebp-64h] BYREF\n  int v36; // [esp+18h] [ebp-60h] BYREF\n  int v37; // [esp+1Ch] [ebp-5Ch]\n  int v38; // [esp+20h] [ebp-58h]\n  int v39; // [esp+24h] [ebp-54h]\n  int v40; // [esp+28h] [ebp-50h]\n  unsigned int v41; // [esp+2Ch] [ebp-4Ch]\n  unsigned int v42; // [esp+30h] [ebp-48h]\n  unsigned int v43; // [esp+34h] [ebp-44h]\n  unsigned int v44; // [esp+38h] [ebp-40h]\n  int v45; // [esp+3Ch] [ebp-3Ch]\n  int v46; // [esp+40h] [ebp-38h]\n  int v47; // [esp+44h] [ebp-34h]\n  int v48; // [esp+48h] [ebp-30h]\n  int v49; // [esp+4Ch] [ebp-2Ch]\n  int v50; // [esp+50h] [ebp-28h]\n  int v51; // [esp+54h] [ebp-24h]\n  int v52; // [esp+58h] [ebp-20h]\n  int v53; // [esp+5Ch] [ebp-1Ch]\n  int v54; // [esp+60h] [ebp-18h]\n  unsigned int v55; // [esp+64h] [ebp-14h]\n\n  v2 = getenv(\"TIME\");\n  if ( !v2 )\n    v2 = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n  s = v2;\n  v3 = sub_80ABEAC(a2, \"^+vpao:f:\", &v35, &s);\n  v31 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v3 & 1) != 0 )\n    s = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n        \"\\tUser time (seconds): %U\\n\"\n        \"\\tSystem time (seconds): %S\\n\"\n        \"\\tPercent of CPU this job got: %P\\n\"\n        \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n        \"\\tAverage shared text size (kbytes): %X\\n\"\n        \"\\tAverage unshared data size (kbytes): %D\\n\"\n        \"\\tAverage stack size (kbytes): %p\\n\"\n        \"\\tAverage total size (kbytes): %K\\n\"\n        \"\\tMaximum resident set size (kbytes): %M\\n\"\n        \"\\tAverage resident set size (kbytes): %t\\n\"\n        \"\\tMajor (requiring I/O) page faults: %F\\n\"\n        \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n        \"\\tVoluntary context switches: %w\\n\"\n        \"\\tInvoluntary context switches: %c\\n\"\n        \"\\tSwaps: %W\\n\"\n        \"\\tFile system inputs: %I\\n\"\n        \"\\tFile system outputs: %O\\n\"\n        \"\\tSocket messages sent: %s\\n\"\n        \"\\tSocket messages received: %r\\n\"\n        \"\\tSignals delivered: %k\\n\"\n        \"\\tPage size (bytes): %Z\\n\"\n        \"\\tExit status: %x\";\n  if ( (v3 & 2) != 0 )\n    s = \"real %e\\nuser %U\\nsys %S\";\n  v5 = 2;\n  if ( (v3 & 8) != 0 )\n    v5 = sub_804DBE1(v35);\n  sub_80589E4(v4, (int)&v36);\n  sub_804DC7B(v5, 1);\n  v6 = s;\n  v7 = getpagesize();\n  if ( (unsigned int)(unsigned __int16)v36 - 1 > 0xFE )\n  {\n    if ( (v36 & 0x7F) == 0 && BYTE1(v36) )\n      printf(\"Command exited with non-zero status %u\\n\", BYTE1(v36));\n  }\n  else\n  {\n    printf(\"Command terminated by signal %u\\n\", v36 & 0x7F);\n  }\n  v8 = (1000 * (v37 + v39) + (v38 + v40) / 1000) / 0xAu;\n  if ( !v8 )\n    v8 = 1;\n  v33 = 100 * (1000 * (v37 + v39) + (v38 + v40) / 1000);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      if ( !*v6 )\n      {\n        sub_804DD98(10);\n        sub_80AB247(v30);\n      }\n      LOBYTE(v30) = *v6;\n      v9 = strcspn(v6, \"%\\\\\");\n      v10 = v9;\n      if ( !v9 )\n        break;\n      printf(\"%.*s\", v9, v6);\n      v6 += v10;\n    }\n    v32 = v6 + 1;\n    if ( (_BYTE)v30 == 37 )\n    {\n      switch ( v6[1] )\n      {\n        case 'C':\n          v11 = v31;\n          v12 = \"%s\";\n          do\n          {\n            printf(v12, *v11++);\n            v12 = \" %s\";\n          }\n          while ( *v11 );\n          goto LABEL_68;\n        case 'D':\n          v13 = sub_80589BE(v7, v43);\n          v14 = v44;\n          goto LABEL_34;\n        case 'E':\n          v30 = v55;\n          if ( v55 / 0x3E8 <= 0xE0F )\n          {\n            v27 = v55 / 0xA % 0x64;\n            v25 = v55 / 0x3E8 % 0x3C;\n            v23 = v55 / 0xEA60;\nLABEL_29:\n            printf(\"%um %u.%02us\", v23, v25, v27);\n            goto LABEL_68;\n          }\n          v26 = v55 / 0x3E8 % 0x3C;\n          v24 = v55 / 0x3E8 % 0xE10 / 0x3C;\n          v22 = v55 / 0x36EE80;\n          break;\n        case 'F':\n          v28 = v46;\n          goto LABEL_31;\n        case 'I':\n          v28 = v48;\n          goto LABEL_31;\n        case 'K':\n          v15 = sub_80589BE(v7, v43);\n          v13 = sub_80589BE(v7, v44) + v15;\n          v14 = v42;\nLABEL_34:\n          v16 = v13 + sub_80589BE(v7, v14);\n          goto LABEL_62;\n        case 'M':\n          v17 = sub_80589BE(v7, v41);\n          goto LABEL_63;\n        case 'O':\n          v28 = v49;\n          goto LABEL_31;\n        case 'P':\n          if ( v55 )\n            printf(\"%u%%\", v33 / v55);\n          else\n            printf(\"?%%\");\n          goto LABEL_68;\n        case 'R':\n          v28 = v45;\n          goto LABEL_31;\n        case 'S':\n          printf(\"%u.%02u\", v39, v40 / 10000);\n          goto LABEL_68;\n        case 'T':\n          v18 = v39;\n          v19 = v39 % 60;\n          v30 = v39 / 60;\n          if ( v39 > 3599 )\n            goto LABEL_46;\n          v20 = v40;\n          goto LABEL_49;\n        case 'U':\n          printf(\"%u.%02u\", v37, v38 / 10000);\n          goto LABEL_68;\n        case 'W':\n          v28 = v47;\n          goto LABEL_31;\n        case 'X':\n          v21 = v42;\n          goto LABEL_61;\n        case 'Z':\n          v29 = v7;\n          goto LABEL_66;\n        case 'c':\n          v28 = v54;\n          goto LABEL_31;\n        case 'e':\n          printf(\"%u.%02u\", v55 / 0x3E8, v55 / 0xA % 0x64);\n          goto LABEL_68;\n        case 'k':\n          v28 = v52;\n          goto LABEL_31;\n        case 'p':\n          v21 = v44;\n          goto LABEL_61;\n        case 'r':\n          v28 = v51;\n          goto LABEL_31;\n        case 's':\n          v28 = v50;\n          goto LABEL_31;\n        case 't':\n          v21 = v43;\nLABEL_61:\n          v16 = sub_80589BE(v7, v21);\nLABEL_62:\n          v17 = v16 / v8;\nLABEL_63:\n          v28 = v17;\n          goto LABEL_31;\n        case 'u':\n          v18 = v37;\n          v19 = v37 % 60;\n          v30 = v37 / 60;\n          if ( v37 <= 3599 )\n          {\n            v20 = v38;\nLABEL_49:\n            v27 = v20 / 10000;\n            v25 = v19;\n            v23 = v30;\n            goto LABEL_29;\n          }\nLABEL_46:\n          v26 = v19;\n          v24 = v18 % 3600 / 0x3Cu;\n          v22 = v18 / 3600;\n          break;\n        case 'w':\n          v28 = v53;\nLABEL_31:\n          printf(\"%lu\", v28);\n          goto LABEL_68;\n        case 'x':\n          v29 = BYTE1(v36);\nLABEL_66:\n          printf(\"%u\", v29);\n          goto LABEL_68;\n        default:\n          goto LABEL_68;\n      }\n      printf(\"%uh %um %02us\", v22, v24, v26);\n    }\n    else\n    {\n      v32 = v6;\n    }\nLABEL_68:\n    v6 = v32 + 1;\n  }\n}\n"
        ],
        "134581964": [
            "sub_8058ECC",
            "0x8058ecc",
            "int __cdecl sub_8058ECC(int a1, int a2)\n{\n  _DWORD *v2; // edi\n  int v3; // esi\n  const char *v4; // ebp\n  _DWORD *v5; // ebx\n  char *v6; // esi\n  unsigned __int16 v7; // ax\n  int v8; // eax\n  char *src; // [esp+4h] [ebp-14h]\n\n  if ( (a1 & 1) != 0 || a1 >> 1 <= 1 )\n    sub_804CDC2();\n  v2 = sub_804DB2E(0x1110u);\n  v3 = (a1 >> 1) - 1;\n  *v2 = v3;\n  if ( v3 > 32 )\n    sub_804D5E0(\"too many renames requested\");\n  v4 = *(const char **)(a2 + 4);\n  sub_80B313B();\n  v5 = (_DWORD *)(a2 + 8);\n  v6 = (char *)(v2 + 6);\n  while ( *v5 )\n  {\n    *((_DWORD *)v6 - 2) = sub_80B3162();\n    src = (char *)v5[1];\n    v7 = strnlen(src);\n    *((_WORD *)v6 - 2) = v7;\n    if ( v7 > 0x7Fu )\n      sub_804D5E0(\"new name '%s' is too long\", src);\n    strcpy(v6, src);\n    v5 += 2;\n    v6 += 136;\n  }\n  v8 = sub_804DBE1(v4);\n  sub_804E0BE(v8, 0x51106F03u, (int)v2, \"UBI_IOCRNVOL\");\n  return 0;\n}\n"
        ],
        "134582164": [
            "sub_8058F94",
            "0x8058f94",
            "int sub_8058F94()\n{\n  write(3, \"Vcan't insert '%s': %s\", 1u);\n  return close(3);\n}\n"
        ],
        "134582189": [
            "sub_8058FAD",
            "0x8058fad",
            "void __noreturn sub_8058FAD()\n{\n  sub_8058F94();\n  _exit(0);\n}\n"
        ],
        "134582201": [
            "sub_8058FB9",
            "0x8058fb9",
            "void __cdecl __noreturn sub_8058FB9(int a1, int a2)\n{\n  char v2; // si\n  unsigned int v3; // ebx\n  const char *v4; // esi\n  int v5; // eax\n  int v6; // eax\n  __useconds_t i; // ebx\n  unsigned int v8; // [esp+0h] [ebp-18h] BYREF\n  int v9; // [esp+4h] [ebp-14h] BYREF\n  int v10[4]; // [esp+8h] [ebp-10h] BYREF\n\n  v8 = 60000;\n  v2 = sub_80ABEAC(a2, \"^Ft:T:\", &v9, v10);\n  if ( (v2 & 1) == 0 )\n    sub_80B3C0D();\n  if ( (v2 & 4) != 0 )\n    v8 = sub_80B40DC();\n  v3 = v8 >> 1;\n  if ( (v2 & 2) != 0 )\n    v3 = sub_80B40DC();\n  sub_804E6C8(117503054, (void (*)(int))sub_8058FAD);\n  v4 = *(const char **)(a2 + 4 * optind);\n  v5 = sub_804DBE1(v4);\n  sub_804DC97(v5, 3);\n  sub_8058F94();\n  v6 = sub_804DBE1(v4);\n  sub_804DC97(v6, 3);\n  v8 /= 0x3E8u;\n  sub_804E09D(3, 0x80045704, (int)&unk_80B77F8, \"WDIOC_SETOPTIONS\");\n  sub_804E09D(3, 0xC0045706, (int)&v8, \"WDIOC_SETTIMEOUT\");\n  for ( i = 1000 * v3; ; usleep(i) )\n    write(3, &data, 1u);\n}\n"
        ],
        "134582477": [
            "sub_80590CD",
            "0x80590cd",
            "int __cdecl sub_80590CD(int a1, int a2)\n{\n  int v2; // ecx\n  const char *v3; // esi\n  int v4; // ebx\n  const char *v5; // eax\n\n  v3 = *(const char **)(a2 + 4);\n  if ( !v3 )\n    sub_804CDC2();\n  sub_8059B9B(v2, 0);\n  v4 = sub_8059C33();\n  if ( v4 )\n  {\n    v5 = (const char *)sub_8059CFC();\n    sub_804D5F4(\"can't insert '%s': %s\", v3, v5);\n  }\n  return v4;\n}\n"
        ],
        "134582545": [
            "sub_8059111",
            "0x8059111",
            "int sub_8059111()\n{\n  const char *v0; // eax\n  int v1; // eax\n  int result; // eax\n  const char *v3; // [esp+0h] [ebp-18h]\n  const char *v4; // [esp+4h] [ebp-14h]\n  const char *v5; // [esp+8h] [ebp-10h]\n  char *s; // [esp+Ch] [ebp-Ch]\n\n  sub_80B052C();\n  printf(\"%-24sSize  Used by\", \"Module\");\n  v0 = (const char *)sub_80B24C7();\n  if ( v0 && (v1 = atoi(v0)) != 0 )\n    printf(\"    Tainted: %c%c%c\\n\", (v1 & 1) == 0 ? 71 : 80, (v1 & 2) == 0 ? 32 : 70, (v1 & 4) == 0 ? 32 : 83);\n  else\n    puts(\"    Not tainted\");\n  while ( 1 )\n  {\n    result = sub_80B0560(\"# \\t\");\n    if ( !result )\n      break;\n    if ( *s )\n      s[strlen(s) - 1] = 0;\n    printf(\"%-19s %8s %2s %s\\n\", v3, v4, v5, s);\n  }\n  return result;\n}\n"
        ],
        "134582764": [
            "sub_80591EC",
            "0x80591ec",
            "int sub_80591EC()\n{\n  return sub_80B2549(0, 0, 0);\n}\n"
        ],
        "134582786": [
            "sub_8059202",
            "0x8059202",
            "char *__usercall sub_8059202@<eax>(const char *s@<eax>, const char *a2@<edx>)\n{\n  void *v2; // ebx\n  size_t v5; // esi\n  size_t v6; // eax\n\n  v2 = (void *)s;\n  if ( a2 )\n  {\n    if ( !s )\n      return sub_804DB46(a2);\n    v5 = strlen(s);\n    v6 = strlen(a2);\n    v2 = sub_804DB13(v2, v5 + v6 + 2);\n    sprintf((char *)v2 + v5, \" %s\", a2);\n  }\n  return (char *)v2;\n}\n"
        ],
        "134582864": [
            "sub_8059250",
            "0x8059250",
            "int __fastcall sub_8059250(int a1)\n{\n  int v1; // esi\n  const char *v3; // eax\n  int v4; // eax\n  int v5; // edx\n  const char *v6; // [esp+0h] [ebp-14h]\n  int v7; // [esp+4h] [ebp-10h]\n\n  sub_80B0511(a1, sub_80B3D45);\n  while ( 1 )\n  {\n    v1 = dword_80DBB80;\n    if ( !*(_DWORD *)(dword_80DBB80 + 8) || !sub_80B0560(\"# \\t\") )\n      break;\n    v3 = sub_804D378(v6, 58);\n    if ( v3 )\n    {\n      *v3 = 0;\n      sub_804D32D(v6);\n      v4 = sub_8059B8A();\n      if ( v4 )\n      {\n        v5 = *(_DWORD *)(v4 + 20);\n        if ( (v5 & 1) == 0 || (dword_80DBB9C & 0x60) != 0 )\n        {\n          *(_DWORD *)(v4 + 20) = v5 | 4;\n          if ( (v5 & 2) != 0 && !*(_DWORD *)(v4 + 12) )\n          {\n            --*(_DWORD *)(v1 + 8);\n            sub_804DB46(v6);\n            sub_80AFAC3();\n            if ( v7 )\n              sub_8059A79((char *)\" \\t\");\n          }\n        }\n      }\n    }\n  }\n  return sub_80B0536();\n}\n"
        ],
        "134583085": [
            "sub_805932D",
            "0x805932d",
            "const char **sub_805932D()\n{\n  int v0; // ebx\n  char *v1; // ecx\n  unsigned __int8 i; // al\n  char v3; // dl\n  const char ***v4; // edi\n  const char **j; // ebx\n  char v7[268]; // [esp-10Ch] [ebp-10Ch] BYREF\n\n  v0 = dword_80DBB80 + 404;\n  sub_8059AC2();\n  v1 = v7;\n  for ( i = 0; ; i += 32 * i + v3 )\n  {\n    v3 = *v1++;\n    if ( !v3 )\n      break;\n  }\n  v4 = (const char ***)(v0 + 4 * i);\n  for ( j = *v4; j; j = (const char **)*j )\n  {\n    if ( !strcmp(j[2], v7) )\n      return j;\n  }\n  j = (const char **)sub_804DB2E(0x20u);\n  j[2] = sub_804DB46(v7);\n  *j = (const char *)*v4;\n  *v4 = j;\n  return j;\n}\n"
        ],
        "134583102": [
            "sub_805933E",
            "0x805933e",
            "_DWORD *__usercall sub_805933E@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n  _DWORD *v3; // ebx\n  int v4; // esi\n\n  result = sub_805932D();\n  v3 = result;\n  if ( (dword_80DBB9C & 0x60) != 0 || (result[5] & 0x11) == 0 )\n  {\n    result[6] = a1;\n    result[5] |= 2u;\n    v4 = dword_80DBB80;\n    sub_80AFADF();\n    ++*(_DWORD *)(v4 + 8);\n    result = sub_804D210((_BYTE *)v3[2], \"symbol:\");\n    if ( result )\n      *(_BYTE *)(v4 + 12) = 1;\n  }\n  return result;\n}\n"
        ],
        "134583177": [
            "sub_8059389",
            "0x8059389",
            "int __userpurge sub_8059389@<eax>(const char *a1@<eax>, int a2)\n{\n  char *v2; // eax\n  int v3; // ecx\n  int v4; // ebx\n  char *v5; // eax\n  int v6; // ebx\n  _DWORD *i; // esi\n  int v8; // ebp\n  int v9; // ecx\n  int v10; // eax\n  const char **v11; // eax\n  unsigned int v12; // edx\n  const char **v13; // ebx\n  int v15; // [esp-4h] [ebp-124h]\n  char *s1; // [esp+4h] [ebp-11Ch]\n  const char *v17; // [esp+Ch] [ebp-114h]\n  char pattern[272]; // [esp+10h] [ebp-110h] BYREF\n\n  v2 = sub_804D315(a1);\n  if ( *v2 == 46 )\n    return 1;\n  v4 = 2;\n  if ( a2 <= 1 )\n  {\n    if ( !a2 || (v5 = strrchr(v2, 46), v4 = 1, v5) && !strcmp(v5 + 1, \"conf\") )\n    {\n      v4 = 0;\n      if ( sub_80B0511(v3, sub_80B3D37) )\n      {\n        while ( sub_80B0560(\"# \\t\") )\n        {\n          if ( !strcmp(s1, \"alias\") )\n          {\n            if ( v17 )\n            {\n              sub_8059AC2(v15, pattern);\n              v6 = dword_80DBB80;\n              for ( i = *(_DWORD **)dword_80DBB80; i; i = (_DWORD *)*i )\n              {\n                v8 = i[1];\n                if ( !fnmatch(pattern, *(const char **)(v8 + 8), 0) )\n                {\n                  sub_8059AC2(v9, 0);\n                  sub_80AFAC3();\n                  v10 = *(_DWORD *)(v8 + 20);\n                  if ( (v10 & 2) != 0 )\n                  {\n                    *(_DWORD *)(v8 + 20) = v10 & 0xFFFFFFFD;\n                    --*(_DWORD *)(v6 + 8);\n                  }\n                  v11 = sub_805932D();\n                  v12 = (unsigned int)v11[5];\n                  if ( (v12 & 2) == 0 )\n                  {\n                    v11[5] = (const char *)(v12 | 2);\n                    ++*(_DWORD *)(v6 + 8);\n                  }\n                }\n              }\n            }\n          }\n          else if ( !strcmp(s1, \"options\") )\n          {\n            if ( v17 )\n            {\n              v13 = sub_805932D();\n              v13[7] = sub_8059202(v13[7], v17);\n            }\n          }\n          else if ( !strcmp(s1, \"include\") )\n          {\n            sub_80591EC();\n          }\n        }\n        sub_80B0536();\n        return 1;\n      }\n    }\n  }\n  return v4;\n}\n"
        ],
        "134583602": [
            "sub_8059532",
            "0x8059532",
            "int __usercall sub_8059532@<eax>(const char **a1@<eax>)\n{\n  const char *v2; // ecx\n  int v3; // ebp\n  const char *v4; // eax\n  char *v5; // edx\n  const char **v6; // eax\n  const char **v7; // ebx\n  const char *v8; // eax\n  char *v9; // esi\n  const char *v10; // edx\n  _BYTE *v11; // ebp\n  _BYTE *v12; // ecx\n  _BYTE *i; // eax\n  const char *v14; // edx\n  const char *v15; // eax\n  const char *v16; // edx\n  _BYTE *v17; // eax\n  char *v18; // eax\n  _BYTE *v20; // [esp-4h] [ebp-28h]\n  const char *v21; // [esp+0h] [ebp-24h]\n  int v22; // [esp+4h] [ebp-20h]\n  _BYTE *v23; // [esp+8h] [ebp-1Ch]\n  _BYTE *v24; // [esp+8h] [ebp-1Ch]\n  char *v25; // [esp+Ch] [ebp-18h]\n  const char *v26; // [esp+10h] [ebp-14h]\n\n  v2 = a1[5];\n  if ( ((unsigned __int8)v2 & 4) == 0 )\n  {\n    v3 = -2;\n    if ( (dword_80DBB9C & 2) == 0 )\n    {\n      v4 = a1[6];\n      if ( !v4 )\n        v4 = a1[2];\n      v5 = (char *)&unk_80CB88C;\n      if ( ((unsigned __int8)v2 & 0x10) != 0 )\n        v5 = \"module %s is builtin\";\n      sub_804D5F4(v5, v4);\n      return -2;\n    }\n    return v3;\n  }\n  if ( (dword_80DBB9C & 0x20) == 0 )\n    a1[3] = (const char *)sub_80AFB57();\n  v22 = 1;\nLABEL_11:\n  while ( 2 )\n  {\n    while ( 2 )\n    {\n      v3 = 0;\n      while ( 1 )\n      {\nLABEL_12:\n        if ( !a1[3] )\n          return v3;\n        v21 = (const char *)sub_80AFB01();\n        sub_804D32D(v21);\n        v6 = sub_805932D();\n        v7 = v6;\n        if ( (dword_80DBB9C & 0x20) == 0 )\n          break;\n        if ( ((_BYTE)v6[5] & 1) == 0 )\n        {\n          v22 = 0;\n          goto LABEL_11;\n        }\n        v3 = sub_8059CDC();\n        if ( v3 )\n        {\n          if ( v22 )\n          {\n            v8 = v7[6];\n            if ( !v8 )\n              v8 = v7[2];\n            sub_804D3A5((int)\"can't unload module '%s'\", v8);\n            return v3;\n          }\n        }\n        else\n        {\n          v7[5] = (const char *)((unsigned int)v7[5] & 0xFFFFFFFE);\n          v22 = 0;\n        }\n      }\n      v9 = (char *)v6[7];\n      v6[7] = 0;\n      v25 = (char *)v6[2];\n      v11 = (_BYTE *)sub_80B24C7();\n      v12 = v11;\n      if ( !v11 )\n        goto LABEL_35;\n      while ( 2 )\n      {\n        for ( i = v12; ; ++i )\n        {\n          LOBYTE(v10) = *i;\n          if ( *i > 0xAu )\n            break;\n          if ( (unsigned __int8)v10 >= 9u || !(_BYTE)v10 )\n            goto LABEL_31;\nLABEL_33:\n          ;\n        }\n        if ( (_BYTE)v10 == 32 )\n          goto LABEL_31;\n        if ( (_BYTE)v10 != 34 )\n          goto LABEL_33;\n        v23 = v12;\n        i = (_BYTE *)strchrnul(v12, v10, i + 1, 34);\n        v12 = v23;\n        if ( *i )\n          ++i;\nLABEL_31:\n        v24 = 0;\n        if ( *i )\n        {\n          *i = 0;\n          v24 = i + 1;\n        }\n        v17 = sub_804D210(v12, v25);\n        if ( v17 )\n        {\n          if ( *v17 == 46 )\n          {\n            v26 = v17 + 1;\n            v18 = strchr(v17 + 1, 61);\n            v10 = v26;\n            if ( v18 )\n              v9 = sub_8059202(v9, v26);\n          }\n        }\n        if ( v24 )\n        {\n          v12 = v24;\n          continue;\n        }\n        break;\n      }\n      free(v11);\n      v12 = v20;\nLABEL_35:\n      if ( a1 == v7 )\n        v9 = sub_8059202(v9, *(const char **)(dword_80DBB80 + 4));\n      if ( (dword_80DBB9C & 0x40) != 0 )\n      {\n        v14 = \"insmod %s/%s/%s\\n\";\n        if ( v9 )\n          v14 = \"insmod %s/%s/%s %s\\n\";\n        printf(v14, \"/lib/modules\", dword_80DBB80 + 143, v21, v9);\n        free(v9);\n        continue;\n      }\n      break;\n    }\n    if ( ((_BYTE)v7[5] & 1) != 0 )\n    {\n      free(v9);\n      continue;\n    }\n    break;\n  }\n  v3 = sub_8059C33(v12, v9);\n  if ( v3 == 17 )\n    v3 = 0;\n  free(v9);\n  if ( !v3 )\n  {\n    v7[5] = (const char *)((unsigned int)v7[5] | 1);\n    goto LABEL_12;\n  }\n  v15 = (const char *)sub_8059CFC();\n  v16 = v7[6];\n  if ( !v16 )\n    v16 = v7[2];\n  sub_804D5F4(\"can't load module %s (%s): %s\", v16, v21, v15);\n  return v3;\n}\n"
        ],
        "134584238": [
            "sub_80597AE",
            "0x80597ae",
            "int __cdecl sub_80597AE(int a1, int a2)\n{\n  char *v2; // ebx\n  char v3; // bp\n  int *v4; // edi\n  int v5; // ecx\n  int *v6; // ebx\n  const char *v7; // eax\n  int result; // eax\n  int v9; // ecx\n  const char **i; // ebx\n  const char **v11; // eax\n  int v12; // ecx\n  int v13; // esi\n  const char **v14; // eax\n  int v15; // ecx\n  int v16; // ecx\n  int v17; // ecx\n  int v18; // eax\n  int v19; // edi\n  const char **v20; // eax\n  const char *v21; // edx\n  void *ptr; // [esp+0h] [ebp-11Ch]\n  char *s; // [esp+4h] [ebp-118h]\n  char name[4]; // [esp+Ch] [ebp-110h] BYREF\n\n  v2 = (char *)sub_804DB2E(0x594u);\n  dword_80DBB80 = (int)v2;\n  v3 = sub_80ABEC2(a2, \"^vqsalrDb\", \"show-depends\");\n  v4 = (int *)(a2 + 4 * optind);\n  sub_804DF04(\"/lib/modules\");\n  uname((struct utsname *)(v2 + 13));\n  sub_804DF04(v2 + 143);\n  if ( (v3 & 0x10) != 0 )\n  {\n    sub_80B0511(v5, sub_80B3D45);\n    v6 = v4;\n    while ( *v6++ )\n      sub_8059A67(95, 45);\n    while ( 1 )\n    {\n      result = sub_80B0560(\"# \\t\");\n      if ( !result )\n        break;\n      v7 = sub_804D378(s, 58);\n      if ( v7 )\n      {\n        *v7 = 0;\n        if ( *v4 )\n        {\n          sub_804D32D(s);\n          sub_8059AC2(v9, name);\n          for ( i = (const char **)v4; *i; ++i )\n          {\n            if ( !fnmatch(*i, name, 0) )\n              puts(s);\n          }\n        }\n        else\n        {\n          puts(s);\n        }\n      }\n    }\n    return result;\n  }\n  if ( (v3 & 4) != 0 )\n    byte_80DB561 = 2;\n  if ( !*v4 )\n  {\n    if ( (v3 & 0x20) != 0 && sub_8059CDC() )\n      sub_80B0A23();\n    return 0;\n  }\n  sub_80B0511(v5, sub_80B3D37);\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    v11 = sub_805932D();\n    v11[5] = (const char *)((unsigned int)v11[5] | 1);\n  }\n  sub_80B0536();\n  sub_80B0511(v12, sub_80B3D37);\n  while ( 1 )\n  {\n    v13 = sub_80B0560(\"# \\t\");\n    if ( !v13 )\n      break;\n    v14 = sub_805932D();\n    v14[5] = (const char *)((unsigned int)v14[5] | 0x10);\n  }\n  sub_80B0536();\n  if ( (v3 & 0x28) != 0 )\n  {\n    do\n      sub_805933E(*v4++);\n    while ( *v4 );\n  }\n  else\n  {\n    sub_805933E(*v4);\n    *((_DWORD *)v2 + 1) = sub_8059B9B(v15, 1);\n  }\n  if ( !*(_DWORD *)v2 )\n    return 0;\n  sub_80591EC();\n  sub_80591EC();\n  if ( v2[12] )\n    sub_80591EC();\n  sub_8059250(v16);\n  if ( *((_DWORD *)v2 + 2) )\n  {\n    sub_80591EC();\n    sub_8059250(v17);\n  }\n  while ( 1 )\n  {\n    v18 = sub_80AFB01();\n    v19 = v18;\n    if ( !v18 )\n      break;\n    if ( *(_DWORD *)(v18 + 16) )\n    {\n      do\n      {\n        ptr = (void *)sub_80AFB01();\n        v20 = sub_805932D();\n        v21 = v20[5];\n        if ( ((unsigned __int8)v21 & 8) == 0 && (((unsigned __int8)v21 & 1) == 0 || (v3 & 0x60) != 0) )\n          v13 |= sub_8059532(v20);\n        free(ptr);\n      }\n      while ( *(_DWORD *)(v19 + 16) );\n    }\n    else\n    {\n      v13 |= sub_8059532((const char **)v18);\n    }\n  }\n  return v13 != 0;\n}\n"
        ],
        "134584935": [
            "sub_8059A67",
            "0x8059a67",
            "_BYTE *__usercall sub_8059A67@<eax>(_BYTE *result@<eax>, char a2@<dl>, char a3@<cl>)\n{\n  while ( *result )\n  {\n    if ( *result == a2 )\n      *result = a3;\n    ++result;\n  }\n  return result;\n}\n"
        ],
        "134584953": [
            "sub_8059A79",
            "0x8059a79",
            "int __usercall sub_8059A79@<eax>(char *delim@<ecx>, char *a2@<eax>)\n{\n  int v3; // esi\n  char *v4; // ebx\n  char *stringp; // [esp+0h] [ebp-14h] BYREF\n\n  stringp = a2;\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = strsep(&stringp, delim);\n    if ( !v4 )\n      break;\n    if ( *v4 )\n    {\n      sub_804DB46(v4);\n      sub_80AFADF();\n      v3 += strlen(v4);\n    }\n  }\n  return v3;\n}\n"
        ],
        "134585026": [
            "sub_8059AC2",
            "0x8059ac2",
            "char *__usercall sub_8059AC2@<eax>(int a1@<eax>, char *a2@<edx>)\n{\n  char *result; // eax\n  int i; // edx\n  char v5; // cl\n  _BYTE v6[260]; // [esp+0h] [ebp-104h] BYREF\n\n  result = 0;\n  if ( a1 )\n  {\n    result = a2;\n    if ( !a2 )\n      result = v6;\n    for ( i = 0; i != 255; ++i )\n    {\n      v5 = *(_BYTE *)(a1 + i);\n      if ( v5 == 46 || !v5 )\n        break;\n      if ( v5 == 45 )\n        v5 = 95;\n      result[i] = v5;\n    }\n    result[i] = 0;\n    if ( result == v6 )\n      return sub_804DB46(result);\n  }\n  return result;\n}\n"
        ],
        "134585226": [
            "sub_8059B8A",
            "0x8059b8a",
            "int **__usercall sub_8059B8A@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  char *v3; // ecx\n  unsigned __int8 i; // al\n  char v5; // dl\n  int **j; // ebx\n  char v8[268]; // [esp-10Ch] [ebp-10Ch] BYREF\n\n  sub_8059AC2(a2, v8);\n  v3 = v8;\n  for ( i = 0; ; i += 32 * i + v5 )\n  {\n    v5 = *v3++;\n    if ( !v5 )\n      break;\n  }\n  for ( j = *(int ***)(a1 + 4 * i); j && strcmp((const char *)j[2], v8); j = (int **)*j )\n    ;\n  return j;\n}\n"
        ],
        "134585243": [
            "sub_8059B9B",
            "0x8059b9b",
            "char *__usercall sub_8059B9B@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  char *v3; // esi\n  int i; // edi\n  const char *v5; // ebx\n  size_t v6; // eax\n  int v7; // edx\n  int v8; // ecx\n  int v9; // eax\n  int v10; // edx\n  const char *v11; // ecx\n  char *v12; // eax\n  int v15; // [esp+4h] [ebp-18h]\n\n  v3 = (char *)sub_804DB2E(1u);\n  for ( i = 0; ; i += sprintf(&v3[i], v11, v10 - (_DWORD)v5, v5, v10) )\n  {\n    v5 = *++a1;\n    if ( !*a1 )\n      break;\n    v6 = strlen(*a1);\n    v3 = (char *)sub_804DB13(v3, v6 + i + 4);\n    v9 = strchrnul(v8, v7, v5, 61);\n    v10 = v9;\n    v11 = \"%.*s%s \";\n    if ( a2 && *(_BYTE *)v9 )\n    {\n      v15 = v9 + 1;\n      v12 = strchr((const char *)(v9 + 1), 32);\n      v10 = v15;\n      v11 = \"%.*s%s \";\n      if ( v12 )\n        v11 = \"%.*s\\\"%s\\\" \";\n    }\n  }\n  return v3;\n}\n"
        ],
        "134585395": [
            "sub_8059C33",
            "0x8059c33",
            "int __usercall sub_8059C33@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  const char *v2; // esi\n  int v3; // ebp\n  int *v4; // ebx\n  int v5; // eax\n  void *v6; // edi\n  int v7; // ebx\n  int v9; // [esp+0h] [ebp-18h]\n\n  v2 = &data;\n  if ( a2 )\n    v2 = a2;\n  v3 = open64(a1);\n  if ( v3 < 0 || (v9 = syscall(350, v3, v2, 0), v7 = v9 != 0, close(v3), v9) )\n  {\n    v4 = (int *)dword_80DBB7C;\n    *(_DWORD *)dword_80DBB7C = 12;\n    v5 = sub_80B24C7();\n    v6 = (void *)v5;\n    if ( v5 )\n    {\n      *v4 = 0;\n      syscall(128, v5, 2147479552, v2);\n      v7 = *v4;\n      free(v6);\n    }\n    else\n    {\n      return -*v4;\n    }\n  }\n  return v7;\n}\n"
        ],
        "134585564": [
            "sub_8059CDC",
            "0x8059cdc",
            "int __usercall sub_8059CDC@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n\n  v2 = dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  syscall(129, a1, a2);\n  return *(_DWORD *)v2;\n}\n"
        ],
        "134585596": [
            "sub_8059CFC",
            "0x8059cfc",
            "char *__usercall sub_8059CFC@<eax>(int a1@<eax>)\n{\n  char *result; // eax\n  bool v3; // zf\n\n  if ( a1 == 3 )\n    return \"module has wrong symbol version\";\n  if ( a1 > 3 )\n  {\n    result = \"invalid module format\";\n    if ( a1 == 8 )\n      return result;\n    result = \"kernel does not support requested operation\";\n    v3 = a1 == 38;\n  }\n  else\n  {\n    result = \"no such module\";\n    if ( a1 == -1 )\n      return result;\n    result = \"unknown symbol in module, or unknown parameter\";\n    v3 = a1 == 2;\n  }\n  if ( !v3 )\n    return strerror(abs32(a1));\n  return result;\n}\n"
        ],
        "134585670": [
            "sub_8059D46",
            "0x8059d46",
            "int __cdecl sub_8059D46(int a1, int a2)\n{\n  char v2; // al\n  const char **v3; // esi\n  int v4; // ebx\n  int v5; // eax\n  const char *v6; // eax\n  char *v7; // eax\n  char v9[264]; // [esp+0h] [ebp-108h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"wfas\");\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = (v2 & 1) == 0 ? 2176 : 128;\n  if ( (v2 & 2) != 0 )\n    BYTE1(v4) |= 2u;\n  if ( (v2 & 4) != 0 )\n  {\n    v5 = sub_8059CDC(0, v4);\n    if ( v5 && v5 != 14 )\n      sub_804D3C9((int)\"rmmod\");\n  }\n  else\n  {\n    if ( !*v3 )\n      sub_804CDC2();\n    while ( 1 )\n    {\n      v6 = *v3;\n      if ( !*v3 )\n        break;\n      ++v3;\n      v7 = sub_804D315(v6);\n      sub_8059AC2((int)v7, v9);\n      if ( sub_8059CDC((int)v9, v4) )\n        sub_804D3C9((int)\"can't unload module '%s'\", v9);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134585831": [
            "sub_8059DE7",
            "0x8059de7",
            "int __usercall sub_8059DE7@<eax>(const char *a1@<eax>)\n{\n  const char *v2; // eax\n  char *v3; // esi\n  int v4; // ebp\n  int v5; // edx\n  int v6; // ecx\n  int v7; // eax\n  int v8; // eax\n  char *v9; // edi\n  int v10; // edx\n  int v11; // eax\n  int v12; // ebx\n  int v13; // edx\n  int v15; // [esp-8h] [ebp-2BCh]\n  int v16; // [esp-8h] [ebp-2BCh]\n  int v17; // [esp-4h] [ebp-2B8h]\n  int v18; // [esp-4h] [ebp-2B8h]\n  int v19; // [esp-4h] [ebp-2B8h]\n  int i; // [esp+0h] [ebp-2B4h]\n  int v21; // [esp+4h] [ebp-2B0h]\n  char *s; // [esp+8h] [ebp-2ACh]\n  int v23; // [esp+Ch] [ebp-2A8h] BYREF\n  int v24; // [esp+10h] [ebp-2A4h] BYREF\n  char v25[16]; // [esp+14h] [ebp-2A0h] BYREF\n  char s1[128]; // [esp+24h] [ebp-290h] BYREF\n  char v27[128]; // [esp+A4h] [ebp-210h] BYREF\n  __int16 v28[64]; // [esp+124h] [ebp-190h] BYREF\n  char v29[128]; // [esp+1A4h] [ebp-110h] BYREF\n  char v30[144]; // [esp+224h] [ebp-90h] BYREF\n\n  if ( a1 )\n  {\n    if ( (*(int (__fastcall **)(size_t, char *))(buf + 24))(buf, v25) < 0 )\n      sub_80AD05E(\"%s\", a1);\n    v2 = (const char *)(*(int (__fastcall **)(size_t, int))(buf + 20))(buf, 1);\n    v3 = sub_804DB46(v2);\n  }\n  else\n  {\n    v3 = 0;\n  }\n  v4 = sub_80B3D45();\n  fgets_unlocked(v29, 128, v4);\n  v21 = 0;\n  for ( i = 0; fgets_unlocked(v29, 128, v4); ++i )\n  {\n    v28[0] = 45;\n    strcpy(v30, \"-\");\n    if ( sscanf(v29, \"%s 0x%x 0x%x %s %s %s\\n\", s1, &v23, &v24, v27, v28, v30) <= 3 )\n      break;\n    if ( *((_BYTE *)&buf + 12) )\n    {\n      v6 = v23;\n      if ( *(_DWORD *)(*(&buf + 1) + 8) != v23 )\n        continue;\n    }\n    if ( v3 )\n    {\n      v7 = strcmp(s1, v3);\n      v6 = v15;\n      v5 = v17;\n      if ( v7 )\n        continue;\n    }\n    if ( *(_BYTE *)*(&buf + 2) )\n    {\n      v8 = strcmp(v30, (const char *)*(&buf + 2));\n      v5 = v18;\n      if ( v8 )\n        continue;\n    }\n    ++v21;\n    if ( (dword_80DBB9C & 0x80u) != 0 )\n      goto LABEL_21;\n    v9 = s1;\n    if ( (*(int (__fastcall **)(size_t, char *))(buf + 24))(buf, v25) >= 0 )\n    {\n      v10 = dword_80DBB9C & 0x80;\n      BYTE1(v10) = 0x80;\n      v9 = (char *)(*(int (__fastcall **)(size_t, int))(buf + 20))(buf, v10);\n    }\n    v11 = strcmp(v9, s1);\n    v5 = v16;\n    v6 = v19;\n    if ( !v11 )\nLABEL_21:\n      v9 = (char *)\"?\";\n    v12 = v24;\n    v13 = sub_805E7D4(v6, v5);\n    if ( !v13 )\n      v13 = sub_805E7AB();\n    s = (char *)v13;\n    printf(\"%s (%s) at \", v9, s1);\n    if ( (v12 & 2) != 0 )\n    {\n      printf(\"%s [%s] \", v27, *(const char **)s);\n    }\n    else if ( (v12 & 8) != 0 )\n    {\n      printf(\"* \");\n    }\n    else\n    {\n      printf(\"<incomplete> \");\n    }\n    if ( (v12 & 0x20) != 0 )\n      printf(\"netmask %s \", (const char *)v28);\n    sub_80B0AB7(v12, \"PERM\", 135056574);\n    printf(\" on %s\\n\", v30);\n  }\n  if ( !v21 && (*((_BYTE *)&buf + 12) || v3 || *(_BYTE *)*(&buf + 2)) )\n    printf(\"No match found in %u entries\\n\", i);\n  return 0;\n}\n"
        ],
        "134586475": [
            "sub_805A06B",
            "0x805a06b",
            "int __cdecl sub_805A06B(int a1, int a2)\n{\n  int v2; // eax\n  __int16 v3; // di\n  const char **v4; // ebx\n  const char *v5; // ebp\n  const char *v6; // esi\n  const char **v7; // ebx\n  int v8; // ebp\n  const char *v9; // edi\n  const char **v10; // ebx\n  int v11; // eax\n  int v13; // [esp-8h] [ebp-D0h]\n  const char *v14; // [esp-4h] [ebp-CCh]\n  int v15; // [esp+0h] [ebp-C8h]\n  char *s1; // [esp+4h] [ebp-C4h]\n  int v17; // [esp+8h] [ebp-C0h] BYREF\n  int v18; // [esp+Ch] [ebp-BCh] BYREF\n  char v19[16]; // [esp+10h] [ebp-B8h] BYREF\n  char v20[16]; // [esp+20h] [ebp-A8h] BYREF\n  _DWORD v21[17]; // [esp+30h] [ebp-98h] BYREF\n  int v22[21]; // [esp+74h] [ebp-54h] BYREF\n\n  *(&buf + 2) = (size_t)&data;\n  v2 = sub_804DF99(0, 2, 2);\n  sub_804DC97(v2, 3);\n  buf = sub_805E782();\n  *(&buf + 1) = sub_805E7AB();\n  v3 = sub_80ABEAC(a2, \"A:p:H:t:i:adnDsv\", &v18, &v18, &v17, &v17, &buf + 2);\n  v4 = (const char **)(a2 + 4 * optind);\n  if ( (v3 & 3) != 0 )\n  {\n    buf = sub_805E782();\n    if ( !buf )\n    {\n      v14 = \"address family\";\n      v13 = v18;\n      goto LABEL_7;\n    }\n  }\n  if ( (v3 & 0xC) != 0 )\n  {\n    *(&buf + 1) = sub_805E7AB();\n    if ( !*(&buf + 1) )\n    {\n      v14 = \"hardware type\";\n      v13 = v17;\nLABEL_7:\n      sub_804D5E0(\"%s: unknown %s\", v13, v14);\n    }\n    *((_BYTE *)&buf + 12) = 1;\n  }\n  if ( *(_DWORD *)(buf + 8) != 2 )\n    sub_804D5E0(\"%s: kernel only supports 'inet'\", *(const char **)buf);\n  if ( *(int *)(*(&buf + 1) + 12) <= 0 )\n    sub_804D5E0(\"%s: %s without ARP support\", *(_DWORD *)*(&buf + 1), \"hardware type\");\n  v5 = *v4;\n  if ( (v3 & 0x240) != 0 )\n  {\n    if ( !v5 )\n      sub_804D5E0(\"need host name\");\n    if ( (v3 & 0x200) != 0 )\n    {\n      memset(v21, 0, sizeof(v21));\n      if ( (*(int (**)(void))(buf + 24))() >= 0 )\n      {\n        qmemcpy(v21, v19, 0x10u);\n        v6 = v4[1];\n        if ( !v6 )\n          sub_804D5E0(\"need hardware address\");\n        v7 = v4 + 2;\n        if ( (dword_80DBB9C & 0x100) != 0 )\n        {\n          sub_804D67E((char *)v22, v6);\n          sub_804E029(3, 0x8927u, (int)v22, \"can't get HW-Address for '%s'\", v6);\n          if ( *((_BYTE *)&buf + 12) && LOWORD(v22[4]) != *(_DWORD *)(*(&buf + 1) + 8) )\n            sub_804D5E0(\"protocol type mismatch\");\n          qmemcpy(&v21[4], &v22[4], 0x10u);\n        }\n        else if ( (*(int (__fastcall **)(_DWORD, _DWORD *))(*(&buf + 1) + 20))(*(&buf + 1), &v21[4]) < 0 )\n        {\n          sub_804D5E0(\"invalid hardware address\");\n        }\n        v8 = 6;\nLABEL_30:\n        while ( *v7 )\n        {\n          switch ( sub_804D222(\"pub\", *v7) )\n          {\n            case 0:\n              v8 |= 8u;\n              goto LABEL_29;\n            case 1:\n              v8 &= ~8u;\n              goto LABEL_29;\n            case 2:\n              v8 &= ~4u;\n              goto LABEL_29;\n            case 3:\n              v8 |= 0x10u;\nLABEL_29:\n              ++v7;\n              goto LABEL_30;\n            case 4:\n              sub_804D5F4(\"feature ATF_DONTPUB is not supported\");\n              goto LABEL_37;\n            case 5:\n              sub_804D5F4(\"feature ATF_MAGIC is not supported\");\nLABEL_37:\n              ++v7;\n              goto LABEL_30;\n            case 6:\n              if ( !v7[1] )\n                goto LABEL_52;\n              *(&buf + 2) = (size_t)v7[1];\n              break;\n            case 7:\n              v9 = v7[1];\n              if ( !v9 )\n                goto LABEL_52;\n              if ( strcmp(v9, \"255.255.255.255\") )\n              {\n                if ( (*(int (__fastcall **)(size_t, char *))(buf + 24))(buf, v19) < 0 )\n                  sub_80AD05E(\"%s\", v9);\n                qmemcpy(&v21[9], v19, 0x10u);\n                v8 |= 0x20u;\n              }\n              break;\n            default:\n              goto LABEL_52;\n          }\n          v7 += 2;\n        }\n        v21[8] = v8;\n        sub_804D67E((char *)&v21[13], (const char *)*(&buf + 2));\n        sub_804E0BE(3, 0x8955u, (int)v21, \"SIOCSARP\");\n        return 0;\n      }\nLABEL_54:\n      sub_80AD05E(\"%s\", v5);\n    }\n    memset32(v22, v3 & 0x200, 0x11u);\n    if ( (*(int (**)(void))(buf + 24))() < 0 )\n      goto LABEL_54;\n    qmemcpy(v22, v20, 0x10u);\n    if ( *((_BYTE *)&buf + 12) )\n      LOWORD(v22[4]) = *(_DWORD *)(*(&buf + 1) + 8);\n    v22[8] = 4;\n    v10 = v4 + 1;\n    v15 = 0;\nLABEL_50:\n    while ( *v10 )\n    {\n      switch ( sub_804D222(\"pub\", *v10) )\n      {\n        case 0:\n          v15 |= 1u;\n          goto LABEL_62;\n        case 1:\n          v15 |= 2u;\n          goto LABEL_62;\n        case 2:\n          v22[8] &= ~4u;\n          goto LABEL_62;\n        case 3:\n          v22[8] |= 0x10u;\nLABEL_62:\n          ++v10;\n          goto LABEL_50;\n        case 4:\n          sub_804D5F4(\"feature ATF_DONTPUB is not supported\");\n          goto LABEL_67;\n        case 5:\n          sub_804D5F4(\"feature ATF_MAGIC is not supported\");\nLABEL_67:\n          ++v10;\n          goto LABEL_50;\n        case 6:\n          if ( !v10[1] )\n            goto LABEL_52;\n          *(&buf + 2) = (size_t)v10[1];\n          break;\n        case 7:\n          s1 = (char *)v10[1];\n          if ( !s1 )\n            goto LABEL_52;\n          if ( strcmp(s1, \"255.255.255.255\") )\n          {\n            if ( (*(int (__fastcall **)(size_t, char *))(buf + 24))(buf, v20) < 0 )\n              sub_80AD05E(\"%s\", s1);\n            qmemcpy(&v22[9], v20, 0x10u);\n            v22[8] |= 0x20u;\n            v5 = s1;\n          }\n          break;\n        default:\nLABEL_52:\n          sub_804CDC2();\n      }\n      v10 += 2;\n    }\n    if ( !v15 )\n      LOBYTE(v15) = 3;\n    sub_804D67E((char *)&v22[13], (const char *)*(&buf + 2));\n    if ( (v15 & 2) != 0 )\n    {\n      v11 = ioctl(3, 0x8953u, v22);\n      if ( v11 < 0 )\n      {\n        if ( *(_DWORD *)dword_80DBB7C != 6 )\n          sub_804D3C9((int)\"SIOCDARP(priv)\");\n        if ( (v15 & 1) == 0 )\n          goto LABEL_86;\n        goto LABEL_78;\n      }\n    }\n    else\n    {\n      v11 = -1;\n    }\n    if ( !v11 || (v15 & 1) == 0 )\n      return 0;\nLABEL_78:\n    v22[8] |= 8u;\n    if ( ioctl(3, 0x8953u, v22) >= 0 )\n      return 0;\n    if ( *(_DWORD *)dword_80DBB7C != 6 )\n      sub_804D3C9((int)\"SIOCDARP(pub)\");\nLABEL_86:\n    printf(\"No ARP entry for %s\\n\", v5);\n    return -1;\n  }\n  return sub_8059DE7(*v4);\n}\n"
        ],
        "134587705": [
            "sub_805A539",
            "0x805a539",
            "void __noreturn sub_805A539()\n{\n  int v0; // ebx\n  bool v1; // al\n\n  v0 = dword_80DBB80;\n  if ( (dword_80DBB9C & 8) == 0 )\n    printf(\n      \"Sent %u probe(s) (%u broadcast(s))\\nReceived %u response(s) (%u request(s), %u broadcast(s))\\n\",\n      *(_DWORD *)(dword_80DBB80 + 64),\n      *(_DWORD *)(dword_80DBB80 + 68),\n      *(_DWORD *)(dword_80DBB80 + 72),\n      *(_DWORD *)(dword_80DBB80 + 80),\n      *(_DWORD *)(dword_80DBB80 + 76));\n  if ( (dword_80DBB9C & 2) != 0 )\n  {\n    v1 = *(_DWORD *)(v0 + 72) != 0;\n  }\n  else\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n      exit(0);\n    v1 = *(_DWORD *)(v0 + 72) == 0;\n  }\n  exit(v1);\n}\n"
        ],
        "134587791": [
            "sub_805A58F",
            "0x805a58f",
            "unsigned int sub_805A58F()\n{\n  int v0; // eax\n  int v1; // ebx\n  int v2; // edx\n  unsigned int v3; // ecx\n  int v4; // edx\n  int v5; // eax\n  __int16 v6; // dx\n  int v7; // esi\n  _DWORD *v8; // eax\n  _DWORD *v9; // eax\n  _DWORD *v10; // eax\n  int v12; // [esp+0h] [ebp-110h] BYREF\n  unsigned __int8 v13; // [esp+4h] [ebp-10Ch]\n  char v14; // [esp+5h] [ebp-10Bh]\n  __int16 v15; // [esp+6h] [ebp-10Ah]\n  char v16[264]; // [esp+8h] [ebp-108h] BYREF\n\n  v0 = sub_804EBDE();\n  v1 = dword_80DBB80;\n  if ( !*(_DWORD *)(dword_80DBB80 + 60) )\n    *(_DWORD *)(dword_80DBB80 + 60) = v0;\n  v2 = *(_DWORD *)(v1 + 48);\n  if ( !v2 )\n    goto LABEL_6;\n  v3 = *(_DWORD *)(v1 + 56);\n  if ( v3 )\n  {\n    if ( v3 < v0 - *(_DWORD *)(v1 + 60) )\n      goto LABEL_6;\n  }\n  if ( v2 > 0 )\n    *(_DWORD *)(v1 + 48) = v2 - 1;\n  v4 = *(_DWORD *)(v1 + 52);\n  if ( !v4 || (unsigned int)(v0 - v4) > 0x7A120 )\n  {\n    v12 = 524544;\n    v5 = *(unsigned __int8 *)(v1 + 19);\n    v13 = *(_BYTE *)(v1 + 19);\n    v14 = 4;\n    v6 = 512;\n    v7 = dword_80DBB9C & 4;\n    if ( (dword_80DBB9C & 4) == 0 )\n      v6 = 256;\n    v15 = v6;\n    v8 = (_DWORD *)mempcpy(v16, v1 + 20, v5);\n    *v8 = *(_DWORD *)v1;\n    v9 = v8 + 1;\n    v10 = (_DWORD *)(v7 ? mempcpy(v9, v1 + 20, v13) : mempcpy(v9, v1 + 40, v13));\n    *v10 = *(_DWORD *)(v1 + 4);\n    if ( (char *)(v10 + 1) - (char *)&v12 == sendto(\n                                               3,\n                                               &v12,\n                                               (char *)(v10 + 1) - (char *)&v12,\n                                               0,\n                                               (const struct sockaddr *)(v1 + 28),\n                                               0x14u) )\n    {\n      *(_DWORD *)(v1 + 52) = sub_804EBDE();\n      ++*(_DWORD *)(v1 + 64);\n      if ( (dword_80DBB9C & 0x40) == 0 )\n        ++*(_DWORD *)(v1 + 68);\n    }\n    if ( !*(_DWORD *)(v1 + 48) && (dword_80DBB9C & 1) != 0 )\nLABEL_6:\n      sub_805A539(v12);\n  }\n  return alarm(1u);\n}\n"
        ],
        "134588071": [
            "sub_805A6A7",
            "0x805a6a7",
            "int __cdecl sub_805A6A7(int a1, int a2)\n{\n  char *v2; // ebx\n  int v3; // eax\n  char *v4; // edi\n  int v5; // eax\n  char v6; // al\n  int v7; // esi\n  unsigned __int8 v8; // al\n  char *v10; // eax\n  const char *v11; // esi\n  char *v12; // eax\n  ssize_t v13; // ebp\n  char *v14; // esi\n  __int16 v15; // ax\n  __int16 v16; // cx\n  size_t v17; // eax\n  _DWORD *v18; // edi\n  struct in_addr v19; // ebp\n  bool v20; // zf\n  char *v21; // eax\n  const char *v22; // ebp\n  const char *v23; // edx\n  int v24; // edx\n  char *v25; // eax\n  unsigned __int8 *v26; // ebp\n  int v27; // eax\n  int v28; // ecx\n  int v29; // eax\n  sigset_t *set; // [esp+0h] [ebp-50h]\n  struct in_addr in; // [esp+4h] [ebp-4Ch]\n  struct in_addr ina; // [esp+4h] [ebp-4Ch]\n  char v33; // [esp+8h] [ebp-48h]\n  int v34; // [esp+8h] [ebp-48h]\n  int v35; // [esp+Ch] [ebp-44h]\n  int v36; // [esp+10h] [ebp-40h]\n  int v37; // [esp+14h] [ebp-3Ch]\n  int v38; // [esp+18h] [ebp-38h]\n  int v39; // [esp+1Ch] [ebp-34h]\n  char v40[4]; // [esp+20h] [ebp-30h] BYREF\n  char *cp; // [esp+24h] [ebp-2Ch] BYREF\n  socklen_t addr_len; // [esp+28h] [ebp-28h] BYREF\n  struct sockaddr addr; // [esp+2Ch] [ebp-24h] BYREF\n\n  *(_DWORD *)v40 = \"eth0\";\n  cp = 0;\n  v2 = (char *)sub_804DB2E(0x108Cu);\n  dword_80DBB80 = (int)v2;\n  *((_DWORD *)v2 + 12) = -1;\n  v3 = sub_804DF99(0, 2, 17);\n  sub_804DC97(v3, 3);\n  if ( (sub_80ABEAC(a2, \"^UDAqfbc:+w:I:s:\", v2 + 48, &addr, v40, &cp) & 0x80u) != 0 )\n    *((_DWORD *)v2 + 14) = 1000000 * sub_80B40CC(1073, 0) + 500000;\n  v4 = sub_804DDBF(\"interface %s %%s\", *(const char **)v40);\n  byte_80DB560 = 2;\n  sub_804D67E(v2 + 84, *(const char **)v40);\n  sub_804E029(3, 0x8933u, (int)(v2 + 84), v4, \"not found\");\n  *((_DWORD *)v2 + 3) = *((_DWORD *)v2 + 25);\n  sub_804E0BE(3, 0x8913u, (int)(v2 + 84), \"SIOCGIFFLAGS\");\n  v5 = *((_DWORD *)v2 + 25);\n  if ( (v5 & 1) == 0 )\n    sub_804D5E0(v4, \"is down\");\n  if ( (v5 & 0x88) == 0 )\n  {\n    *((_DWORD *)v2 + 1) = *(_DWORD *)(sub_80B45A6(2, 0) + 8);\n    if ( cp && !inet_aton(cp, (struct in_addr *)v2) )\n      sub_804D5E0(\"invalid source address %s\", cp);\n    v6 = dword_80DBB9C;\n    if ( (dword_80DBB9C & 3) == 1 && !*(_DWORD *)v2 )\n      *(_DWORD *)v2 = *((_DWORD *)v2 + 1);\n    if ( (v6 & 2) == 0 || *(_DWORD *)v2 )\n    {\n      v7 = sub_804DF99(0, 2, 2);\n      sub_80B4280();\n      *((_WORD *)v2 + 58) = 2;\n      if ( *(_DWORD *)v2 )\n      {\n        *((_DWORD *)v2 + 30) = *(_DWORD *)v2;\n        sub_804DFB3(0x10u, (struct sockaddr *)(v2 + 116), v7);\n      }\n      else\n      {\n        *((_WORD *)v2 + 59) = 260;\n        *((_DWORD *)v2 + 30) = *((_DWORD *)v2 + 1);\n        if ( sub_80B4258() )\n          sub_804D3A5((int)\"setsockopt(%s)\", \"SO_DONTROUTE\");\n        sub_80B42C3(0x10u, (struct sockaddr *)(v2 + 116));\n        sub_80A998A(16, v2 + 116);\n        if ( *((_WORD *)v2 + 58) != 2 )\n          sub_804D5E0(\"no IP address configured\");\n        *(_DWORD *)v2 = *((_DWORD *)v2 + 30);\n      }\n      close(v7);\n    }\n    *((_DWORD *)v2 + 2) = 101187601;\n    sub_804DFB3(0x14u, (struct sockaddr *)(v2 + 8), 3);\n    sub_80A998A(20, v2 + 8);\n    v8 = v2[19];\n    if ( v8 )\n    {\n      qmemcpy(v2 + 28, v2 + 8, 0x14u);\n      memset(v2 + 40, 255, v8);\n      if ( (dword_80DBB9C & 8) == 0 )\n      {\n        v10 = inet_ntoa(*(struct in_addr *)(v2 + 4));\n        printf(\"ARPING %s\", v10);\n        v11 = *(const char **)v40;\n        v12 = inet_ntoa(*(struct in_addr *)v2);\n        printf(\" from %s %s\\n\", v12, v11);\n      }\n      set = (sigset_t *)(v2 + 132);\n      sigaddset((sigset_t *)(v2 + 132), 14);\n      sigaddset((sigset_t *)(v2 + 132), 2);\n      sub_804E782(2, (int)sub_805A539);\n      sub_804E782(14, (int)sub_805A58F);\n      sub_805A58F();\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            while ( 1 )\n            {\n              addr_len = 20;\n              sigprocmask(1, set, 0);\n              v13 = recvfrom(3, v2 + 140, 0x1000u, 0, &addr, &addr_len);\n              sigprocmask(0, set, 0);\n              if ( v13 >= 0 )\n                break;\n              sub_804D3A5((int)\"recvfrom\");\n            }\n            v14 = v2 + 148;\n            if ( addr.sa_data[8] <= 2u && ((*((_WORD *)v2 + 73) - 256) & 0xFEFF) == 0 )\n            {\n              v15 = *((_WORD *)v2 + 70);\n              HIBYTE(v16) = addr.sa_data[6];\n              LOBYTE(v16) = addr.sa_data[7];\n              if ( (v15 == v16 || *(_WORD *)&addr.sa_data[6] == 774 && v15 == 256)\n                && *((_WORD *)v2 + 71) == 8\n                && v2[145] == 4 )\n              {\n                v17 = (unsigned __int8)v2[144];\n                v18 = (_DWORD *)dword_80DBB80;\n                if ( (_BYTE)v17 == *(_BYTE *)(dword_80DBB80 + 19) && (int)(2 * (v17 + 4) + 8) <= v13 )\n                {\n                  v19.s_addr = *(_DWORD *)&v2[v17 + 148];\n                  in.s_addr = *(_DWORD *)&v14[2 * v17 + 4];\n                  if ( v19.s_addr == *(_DWORD *)(dword_80DBB80 + 4) )\n                    break;\n                }\n              }\n            }\n          }\n          v33 = dword_80DBB9C;\n          if ( (dword_80DBB9C & 2) != 0 )\n            break;\n          if ( in.s_addr == *(_DWORD *)dword_80DBB80 )\n          {\n            v20 = memcmp(&v14[v17 + 4], (const void *)(dword_80DBB80 + 20), v17) == 0;\nLABEL_45:\n            if ( v20 )\n            {\nLABEL_46:\n              if ( (v33 & 8) == 0 )\n              {\n                v39 = (unsigned __int8)v2[153];\n                v34 = (unsigned __int8)v2[152];\n                v35 = (unsigned __int8)v2[151];\n                v36 = (unsigned __int8)v2[150];\n                v37 = (unsigned __int8)v2[149];\n                v38 = (unsigned __int8)v2[148];\n                v21 = inet_ntoa(v19);\n                v22 = \"quest\";\n                if ( *((_WORD *)v2 + 73) == 512 )\n                  v22 = \"ply\";\n                v23 = \"Broad\";\n                if ( !addr.sa_data[8] )\n                  v23 = \"Uni\";\n                printf(\n                  \"%scast re%s from %s [%02x:%02x:%02x:%02x:%02x:%02x]\",\n                  v23,\n                  v22,\n                  v21,\n                  v38,\n                  v37,\n                  v36,\n                  v35,\n                  v34,\n                  v39);\n                v24 = 0;\n                if ( in.s_addr != *v18 )\n                {\n                  v25 = inet_ntoa(in);\n                  printf(\"for %s\", v25);\n                  v24 = 1;\n                }\n                ina.s_addr = v24;\n                v26 = (unsigned __int8 *)&v14[(unsigned __int8)v2[144] + 4];\n                if ( memcmp(v26, v18 + 5, (unsigned __int8)v2[144]) )\n                {\n                  if ( !ina.s_addr )\n                    printf(\" for\");\n                  printf(\" [%02x:%02x:%02x:%02x:%02x:%02x]\", *v26, v26[1], v26[2], v26[3], v26[4], v26[5]);\n                }\n                if ( v18[13] )\n                {\n                  v27 = sub_804EBDE();\n                  printf(\" %u.%03ums\\n\", (v27 - v18[13]) / 0x3E8u, (v27 - v18[13]) % 0x3E8u);\n                }\n                else\n                {\n                  puts(\" UNSOLICITED?\");\n                }\n                sub_804DD8F();\n              }\n              v28 = dword_80DBB80;\n              ++*(_DWORD *)(dword_80DBB80 + 72);\n              if ( addr.sa_data[8] )\n                ++*(_DWORD *)(v28 + 76);\n              if ( *((_WORD *)v2 + 73) == 256 )\n                ++*(_DWORD *)(v28 + 80);\n              v29 = dword_80DBB9C;\n              if ( (dword_80DBB9C & 0x10) != 0 )\n                sub_805A539(set);\n              if ( (dword_80DBB9C & 0x20) == 0 )\n              {\n                qmemcpy((void *)(v28 + 40), v14, *(unsigned __int8 *)(v28 + 19));\n                dword_80DBB9C = v29 | 0x40;\n              }\n            }\n          }\n        }\n        if ( memcmp(v2 + 148, (const void *)(dword_80DBB80 + 20), v17) )\n        {\n          if ( !*v18 )\n            goto LABEL_46;\n          v20 = in.s_addr == *v18;\n          goto LABEL_45;\n        }\n      }\n    }\n  }\n  sub_804D5F4(v4);\n  return ~(_BYTE)dword_80DBB9C & 2;\n}\n"
        ],
        "134589585": [
            "sub_805AC91",
            "0x805ac91",
            "int __usercall sub_805AC91@<eax>(int result@<eax>)\n{\n  int i; // edx\n  int v2; // edx\n  char v3; // cl\n\n  for ( i = 0; *(_BYTE *)(result + i); ++i )\n    ;\n  v2 = result + i;\n  v3 = 0;\n  while ( v2 != result )\n  {\n    if ( *(_BYTE *)(v2 - 1) == 46 )\n    {\n      *(_BYTE *)(v2 - 1) = v3;\n      v3 = 0;\n    }\n    else\n    {\n      ++v3;\n    }\n    --v2;\n  }\n  return result;\n}\n"
        ],
        "134589622": [
            "sub_805ACB6",
            "0x805acb6",
            "void __cdecl __noreturn sub_805ACB6(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // edi\n  int *v4; // ebx\n  size_t v5; // eax\n  void *v6; // eax\n  unsigned int s_addr; // eax\n  unsigned __int32 v8; // eax\n  _DWORD *v9; // ebp\n  char *v10; // ebx\n  int v11; // ebx\n  char v12; // bl\n  size_t v13; // edi\n  char *v14; // eax\n  __int16 v15; // si\n  int i; // ebx\n  int v17; // eax\n  const char *v18; // ebx\n  unsigned __int16 v19; // ax\n  __int16 v20; // bx\n  const char *v21; // eax\n  unsigned int v22; // edx\n  const char *v23; // edx\n  char *v24; // edi\n  __int16 v25; // ax\n  char v26; // t0\n  char *v27; // edi\n  int v28; // [esp+0h] [ebp-254h]\n  char *v29; // [esp+4h] [ebp-250h]\n  size_t v30; // [esp+8h] [ebp-24Ch]\n  unsigned int v31; // [esp+14h] [ebp-240h]\n  char *v32; // [esp+18h] [ebp-23Ch]\n  char *v33; // [esp+1Ch] [ebp-238h]\n  int v34; // [esp+20h] [ebp-234h]\n  unsigned int v35; // [esp+24h] [ebp-230h]\n  const char *v36; // [esp+28h] [ebp-22Ch] BYREF\n  void *v37; // [esp+2Ch] [ebp-228h] BYREF\n  int v38; // [esp+30h] [ebp-224h] BYREF\n  int v39; // [esp+34h] [ebp-220h] BYREF\n  int v40; // [esp+38h] [ebp-21Ch] BYREF\n  struct in_addr inp; // [esp+3Ch] [ebp-218h] BYREF\n  char *s; // [esp+40h] [ebp-214h] BYREF\n  char *cp; // [esp+44h] [ebp-210h]\n  int v44; // [esp+48h] [ebp-20Ch]\n  char s2[504]; // [esp+4Ch] [ebp-208h] BYREF\n  char v46; // [esp+244h] [ebp-10h] BYREF\n\n  v36 = \"0.0.0.0\";\n  v37 = &unk_80CBEAB;\n  v2 = sub_80ABEAC(a2, \"vsi:c:t:p:d\", &v36, &v37, &v38, &v39);\n  v31 = 120;\n  if ( (v2 & 0x10) != 0 )\n    v31 = sub_80B40CC(-1, 1);\n  if ( (v2 & 0x20) != 0 )\n    sub_80B40CC(0xFFFF, 1);\n  if ( (v2 & 0x40) != 0 )\n  {\n    sub_80B3C0D();\n    openlog(ident, 1, 24);\n    byte_80DB561 = 2;\n  }\n  v40 = 0;\n  v3 = sub_80B052C();\n  v4 = &v40;\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    if ( inet_aton(cp, &inp) )\n    {\n      if ( (dword_80DBB9C & 1) != 0 )\n        sub_804D5F4(\"name:%s, ip:%s\", s, cp);\n      v5 = strlen(s);\n      v6 = sub_804DB2E(v5 + 29);\n      *v4 = (int)v6;\n      v4 = (int *)v6;\n      *((_BYTE *)v6 + 25) = 46;\n      strcpy((char *)v6 + 26, s);\n      sub_805AC91((int)v4 + 25);\n      s_addr = inp.s_addr;\n      v4[1] = inp.s_addr;\n      v8 = _byteswap_ulong(s_addr);\n      sprintf((char *)v4 + 8, \".%u.%u.%u.%u\", (unsigned __int8)v8, BYTE1(v8), BYTE2(v8), HIBYTE(v8));\n      sub_805AC91((int)(v4 + 2));\n    }\n    else\n    {\n      sub_804D5F4(\"error at line %u, skipping\", *(_DWORD *)(v3 + 24));\n    }\n  }\n  sub_80B0536();\n  v34 = v40;\n  v9 = (_DWORD *)sub_80B45C8();\n  v28 = sub_804DF99(0, 2, *((unsigned __int16 *)v9 + 2));\n  sub_804DFB3(*v9, (struct sockaddr *)(v9 + 1), v28);\n  sub_80B31E3();\n  v30 = *v9 + 4;\n  v33 = (char *)sub_804DB2E(v30);\n  v32 = (char *)sub_804DB2E(v30);\n  v10 = (char *)sub_80B46AC();\n  sub_804D5F4(\"accepting UDP packets on %s\", v10);\n  free(v10);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          qmemcpy(v32, v9, v30);\n          v11 = sub_80B32E8(513, &s, 0, v33 + 4, v32 + 4, *v9);\n          if ( (unsigned int)(v11 - 12) <= 0x1F4 )\n            break;\n          sub_804D5F4(\"packet size %d, ignored\", v11);\n        }\n        if ( (dword_80DBB9C & 1) != 0 )\n          sub_804D5F4(\"got UDP packet\");\n        *((_BYTE *)&s + v11) = 0;\n        if ( (_WORD)cp )\n          break;\n        sub_804D5F4(\"packet has 0 queries, ignored\");\n      }\n      v12 = BYTE2(s);\n      if ( SBYTE2(s) >= 0 )\n        break;\n      sub_804D5F4(\"response packet, ignored\");\n    }\n    v13 = strlen(s2);\n    v14 = &s2[v13 + 1];\n    v35 = v13 + 5;\n    v29 = &s2[v13 + 5];\n    if ( (v12 & 0x78) != 0 )\n    {\n      v20 = 1152;\n      v21 = \"opcode != 0\";\n      goto LABEL_46;\n    }\n    if ( *(_WORD *)&s2[v13 + 3] != 256 )\n    {\n      v20 = 1152;\n      v21 = \"class != 1\";\n      goto LABEL_46;\n    }\n    v15 = *(_WORD *)v14;\n    if ( *(_WORD *)v14 != 256 && v15 != 3072 )\n    {\n      v20 = 1152;\n      v21 = \"type is !REQ_A and !REQ_PTR\";\n      goto LABEL_46;\n    }\n    for ( i = v34; ; i = *(_DWORD *)i )\n    {\n      if ( !i )\n        goto LABEL_45;\n      v17 = *(unsigned __int8 *)(i + 25);\n      if ( v15 != 256 )\n        break;\n      if ( v17 == 1 && *(_BYTE *)(i + 26) == 42 || !strcasecmp((const char *)(i + 25), s2) )\n      {\n        v18 = (const char *)(i + 4);\n        goto LABEL_38;\n      }\nLABEL_39:\n      ;\n    }\n    if ( v17 == 1 && *(_BYTE *)(i + 26) == 42 || !sub_804D210(s2, (_BYTE *)(i + 8)) )\n      goto LABEL_39;\n    v18 = (const char *)(i + 25);\n    if ( v15 == 3072 )\n      v19 = strlen(v18) + 1;\n    else\nLABEL_38:\n      v19 = 4;\n    v22 = v19;\n    if ( v19 + v29 - &v46 + v13 + 527 <= 0x200 )\n    {\n      qmemcpy(v29, s2, v35);\n      v24 = &v29[v35];\n      *(_DWORD *)v24 = _byteswap_ulong(v31);\n      v26 = HIBYTE(v19);\n      HIBYTE(v25) = v19;\n      LOBYTE(v25) = v26;\n      *((_WORD *)v24 + 2) = v25;\n      v27 = &v29[v35 + 6];\n      qmemcpy(v27, v18, v22);\n      v29 = &v27[v22];\n      if ( (dword_80DBB9C & 1) != 0 )\n        sub_804D5F4(\"returning positive reply\");\n      HIWORD(cp) = 256;\n      v20 = 132;\n      v21 = 0;\n    }\n    else\n    {\nLABEL_45:\n      v20 = 900;\n      v21 = \"name is not found\";\n    }\nLABEL_46:\n    if ( (v20 & 0x700) != 0 )\n    {\n      if ( (dword_80DBB9C & 1) != 0 )\n      {\n        v23 = \"sending error reply\";\n        if ( (dword_80DBB9C & 2) != 0 )\n          v23 = \"dropping query\";\n        sub_804D5F4(\"%s, %s\", v21, v23);\n      }\n      if ( (dword_80DBB9C & 2) != 0 )\n        continue;\n    }\n    HIWORD(s) |= v20;\n    v44 = 0;\n    LOWORD(cp) = 256;\n    if ( v29 - (char *)&s > 0 )\n      sub_80B3204(v29 - (char *)&s, &s, 0, (struct sockaddr *)(v33 + 4), (int)(v32 + 4), *v9);\n  }\n}\n"
        ],
        "134590791": [
            "sub_805B147",
            "0x805b147",
            "int __cdecl sub_805B147(int a1, int a2)\n{\n  int v2; // ebp\n  char *v3; // ebx\n  int i; // edx\n  const char *v5; // ebx\n  int v6; // edx\n  int j; // eax\n  char *v8; // ecx\n  size_t v9; // esi\n  char fd; // [esp+0h] [ebp-F0h]\n  int fda; // [esp+0h] [ebp-F0h]\n  int v13; // [esp+4h] [ebp-ECh]\n  char v14[4]; // [esp+Ch] [ebp-E4h] BYREF\n  char *s; // [esp+10h] [ebp-E0h] BYREF\n  char v16[6]; // [esp+14h] [ebp-DCh] BYREF\n  struct ether_addr addr; // [esp+1Ah] [ebp-D6h] BYREF\n  _DWORD v18[5]; // [esp+20h] [ebp-D0h] BYREF\n  char v19[16]; // [esp+34h] [ebp-BCh] BYREF\n  __int64 v20; // [esp+44h] [ebp-ACh]\n  struct ether_addr buf; // [esp+54h] [ebp-9Ch] BYREF\n  struct ether_addr v22; // [esp+5Ah] [ebp-96h] BYREF\n  __int16 v23; // [esp+60h] [ebp-90h] BYREF\n  int v24; // [esp+62h] [ebp-8Eh] BYREF\n  __int16 v25; // [esp+66h] [ebp-8Ah]\n  char v26[96]; // [esp+68h] [ebp-88h] BYREF\n  char v27[40]; // [esp+C8h] [ebp-28h] BYREF\n\n  *(_DWORD *)v14 = \"eth0\";\n  fd = sub_80ABEAC(a2, \"^bi:p:\", v14, &s);\n  v2 = 0;\n  if ( (fd & 4) != 0 )\n  {\n    v3 = s;\n    v2 = sscanf(\n           s,\n           \"%2x:%2x:%2x:%2x:%2x:%2x\",\n           &buf,\n           &buf.ether_addr_octet[4],\n           &v22.ether_addr_octet[2],\n           &v23,\n           (char *)&v24 + 2,\n           v26);\n    if ( v2 > 3\n      || (v2 = sscanf(v3, \"%u.%u.%u.%u\", &buf, &buf.ether_addr_octet[4], &v22.ether_addr_octet[2], &v23), v2 > 3) )\n    {\n      for ( i = 0; i < v2; ++i )\n        v16[i] = *(_DWORD *)&buf.ether_addr_octet[4 * i];\n    }\n    else\n    {\n      sub_804D5F4(\"can't read Wake-On-LAN pass\");\n      v2 = 0;\n    }\n  }\n  v13 = fd & 1;\n  fda = sub_804DF99(0, 3, 17);\n  v5 = *(const char **)(a2 + 4 * optind);\n  if ( !ether_aton_r(v5, &addr) && ether_hostton(v5, &addr) )\n    sub_804CDC2();\n  *(_DWORD *)buf.ether_addr_octet = -1;\n  *(_WORD *)&buf.ether_addr_octet[4] = -1;\n  v6 = *(_DWORD *)addr.ether_addr_octet;\n  if ( !v13 )\n    buf = addr;\n  v22 = addr;\n  v23 = 16904;\n  v24 = -1;\n  v25 = -1;\n  for ( j = 0; j != 96; j += 6 )\n  {\n    v8 = &v26[j];\n    *(_DWORD *)v8 = v6;\n    *((_WORD *)v8 + 2) = *(_WORD *)&addr.ether_addr_octet[4];\n  }\n  sub_804D67E(v19, *(const char **)v14);\n  sub_804E029(fda, 0x8927u, (int)v19, \"SIOCGIFHWADDR on %s failed\", *(const char **)v14);\n  v22 = *(struct ether_addr *)((char *)&v20 + 2);\n  v9 = 116;\n  if ( v2 )\n  {\n    qmemcpy(v27, v16, v2);\n    v9 = v2 + 116;\n  }\n  if ( v13 && sub_80B426C() )\n    sub_804D3A5((int)\"SO_BROADCAST\");\n  sub_804D67E(v19, *(const char **)v14);\n  sub_804E0BE(fda, 0x8933u, (int)v19, \"SIOCGIFINDEX\");\n  memset((char *)v18 + 2, 0, 0x12u);\n  LOWORD(v18[0]) = 17;\n  v18[1] = v20;\n  HIBYTE(v18[2]) = 6;\n  *(struct ether_addr *)&v18[3] = buf;\n  sub_804DFCD(v9, &buf, fda, (struct sockaddr *)v18, 0x14u);\n  return 0;\n}\n"
        ],
        "134591392": [
            "sub_805B3A0",
            "0x805b3a0",
            "const char *__usercall sub_805B3A0@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  size_t len; // eax\n\n  if ( a2 )\n  {\n    sub_80B0511(a3, sub_80B3D45);\n    while ( sub_80B0560(\"# \\t\") )\n      sub_805B3A0();\n  }\n  else\n  {\n    len = strlen(a1);\n    if ( sethostname(a1, len) )\n      sub_804D3C9((int)\"sethostname\");\n  }\n  return a1;\n}\n"
        ],
        "134591486": [
            "sub_805B3FE",
            "0x805b3fe",
            "int __usercall sub_805B3FE@<eax>(int a1@<ebx>, int a2, int a3)\n{\n  char v3; // bl\n  const char **v4; // edi\n  int v5; // edx\n  int v6; // ecx\n  const char *v7; // esi\n  __int64 v8; // rax\n  int v9; // esi\n  const char *v10; // edi\n  int v11; // ecx\n  int v12; // eax\n  int i; // ebx\n  char *v14; // eax\n  const char *v15; // edx\n  int v16; // edx\n  const char *v17; // eax\n  const char *v19; // [esp+0h] [ebp-10h] BYREF\n\n  v19 = (const char *)a1;\n  v3 = sub_80ABEAC(a3, \"dfisF:v\", &v19, \"domain\");\n  v4 = (const char **)(a3 + 4 * optind);\n  v7 = (const char *)sub_80B2BD8();\n  if ( *ident == 100 )\n    v3 = 1;\n  if ( (v3 & 7) == 0 )\n  {\n    if ( (v3 & 8) != 0 )\n    {\n      *(_BYTE *)strchrnul(v6, v5, v7, 46) = 0;\nLABEL_25:\n      puts(v7);\n      return 0;\n    }\n    if ( (v3 & 0x10) != 0 )\n    {\n      v16 = 1;\n      v17 = v19;\n    }\n    else\n    {\n      v17 = *v4;\n      if ( !*v4 )\n        goto LABEL_25;\n      v16 = 0;\n    }\n    sub_805B3A0(v17, v16, v6);\n    return 0;\n  }\n  v8 = sub_80B4718();\n  v9 = v8;\n  v10 = *(const char **)v8;\n  v12 = strchrnul(v11, HIDWORD(v8), *(_DWORD *)v8, 46);\n  if ( (v3 & 2) != 0 )\n  {\n    puts(v10);\n  }\n  else if ( (v3 & 8) != 0 )\n  {\n    *(_BYTE *)v12 = 0;\n    puts(*(const char **)v9);\n  }\n  else if ( (v3 & 1) != 0 )\n  {\n    if ( *(_BYTE *)v12 )\n      puts((const char *)(v12 + 1));\n  }\n  else if ( *(_DWORD *)(v9 + 12) == 4 )\n  {\n    for ( i = *(_DWORD *)(v9 + 16); *(_DWORD *)i; i += 4 )\n    {\n      v14 = inet_ntoa((struct in_addr)(*(struct in_addr **)i)->s_addr);\n      v15 = \"%s \";\n      if ( !*(_DWORD *)(i + 4) )\n        v15 = \"\\r\\n%s\" + 2;\n      printf(v15, v14);\n    }\n    sub_804DD98(10);\n  }\n  return 0;\n}\n"
        ],
        "134591745": [
            "sub_805B501",
            "0x805b501",
            "int __cdecl sub_805B501(int a1, int a2)\n{\n  int v2; // ecx\n  int v3; // ebx\n  int v4; // edx\n  const char *v6; // edi\n  char v7; // si\n  char v8; // al\n  char v9; // si\n  const char **v10; // ebp\n  const char *v11; // ebx\n  char *v12; // eax\n  int v13; // ecx\n  char *v14; // edi\n  int v15; // eax\n  int v16; // esi\n  char v17; // al\n  int v18; // ebx\n  int v19; // eax\n  int *v20; // esi\n  unsigned int v21; // edi\n  char *v22; // esi\n  __int16 v23; // dx\n  int *j; // eax\n  __int16 v25; // ax\n  int v26; // ebx\n  int v27; // [esp-4h] [ebp-80h]\n  char **i; // [esp+0h] [ebp-7Ch]\n  int v29; // [esp+4h] [ebp-78h]\n  int fd; // [esp+8h] [ebp-74h]\n  char v31; // [esp+Eh] [ebp-6Eh]\n  unsigned __int8 v32; // [esp+Fh] [ebp-6Dh]\n  int v33; // [esp+10h] [ebp-6Ch]\n  int v34; // [esp+14h] [ebp-68h] BYREF\n  int v35; // [esp+18h] [ebp-64h]\n  char v36; // [esp+24h] [ebp-58h] BYREF\n  int v37[6]; // [esp+34h] [ebp-48h] BYREF\n  char v38[16]; // [esp+4Ch] [ebp-30h] BYREF\n  int v39; // [esp+5Ch] [ebp-20h]\n\n  v3 = a2 + 4;\n  v4 = *(_DWORD *)(a2 + 4);\n  if ( v4 )\n  {\n    if ( *(_BYTE *)v4 == 45 && *(_BYTE *)(v4 + 1) == 97 && !*(_BYTE *)(v4 + 2) )\n    {\n      v3 = a2 + 8;\n      v4 = 1;\n    }\n    else\n    {\n      v4 = 0;\n    }\n  }\n  if ( !*(_DWORD *)v3 || !*(_DWORD *)(v3 + 4) )\n    return sub_805ED04(v2, v4);\n  fd = sub_804DF99(0, 2, 2);\n  sub_804D67E(v38, *(const char **)v3);\n  v32 = 0;\n  while ( 1 )\n  {\n    v29 = v3 + 4;\n    v6 = *(const char **)(v3 + 4);\n    if ( !v6 )\n      return 0;\n    v7 = 21;\n    if ( *v6 == 45 )\n    {\n      ++v6;\n      v7 = 42;\n    }\n    for ( i = &off_80B55A0; ; i += 2 )\n    {\n      if ( !*i )\n      {\n        v31 = *((_BYTE *)i + 5);\n        v10 = (const char **)&off_80B56D8;\n        goto LABEL_28;\n      }\n      if ( !strcmp(v6, *i) )\n        break;\n    }\n    v8 = (_BYTE)i[1] & v7;\n    v9 = v8;\n    if ( !v8 )\n      sub_804D5E0(\"bad: '%s'\", v6 - 1);\n    if ( (v8 & 0x30) == 0 )\n      goto LABEL_63;\n    v31 = *((_BYTE *)i + 5);\n    if ( ((unsigned __int8)v31 & v32) != 0 )\n      goto LABEL_23;\n    v10 = (const char **)((char *)&off_80B5660 + (char *)i - (char *)&off_80B55A0);\n    if ( !*(_DWORD *)(v3 + 8) )\n    {\n      if ( (v31 & 0x10) == 0 )\n      {\n        v31 &= 0x40u;\n        goto LABEL_61;\n      }\nLABEL_23:\n      sub_804CDC2();\n    }\n    v29 = v3 + 8;\nLABEL_28:\n    v32 |= v31 & 0x20;\n    v11 = *(const char **)v29;\n    if ( (v31 & 2) != 0 )\n    {\n      if ( (v31 & 1) != 0 )\n      {\n        if ( !strcmp(v11, \"inet\") )\n          goto LABEL_67;\n        v34 = 2;\n        if ( strcmp(v11, \"default\") )\n        {\n          v12 = strchr(v11, 47);\n          v13 = v27;\n          v14 = v12;\n          v33 = 0;\n          if ( v12 )\n          {\n            v33 = sub_80B40CC(128, 0);\n            *v14 = 0;\n          }\n          while ( 1 )\n          {\n            v15 = sub_80B45BD(v13, 0);\n            v16 = v15;\n            if ( *(_WORD *)(v15 + 4) == 10 )\n              break;\n            if ( !v14 )\n            {\n              v35 = *(_DWORD *)(v15 + 8);\n              goto LABEL_70;\n            }\n            *v14 = 47;\n          }\n          v26 = sub_804DF99(0, 2, 10);\n          sub_804E0BE(v26, 0x8933u, (int)v38, \"SIOCGIFINDEX\");\n          v37[5] = v39;\n          v37[4] = v33;\n          qmemcpy(v37, (const void *)(v16 + 12), 0x10u);\n          sub_804E029(v26, *((unsigned __int16 *)v10 + 2), (int)v37, \"SIOC%s\", *v10);\n          goto LABEL_67;\n        }\n        v35 = 0;\nLABEL_70:\n        v20 = &v34;\n      }\n      else\n      {\n        v17 = sub_804D254(\"ether\", *(const char **)v29) + 1;\n        if ( !v17 )\n          goto LABEL_23;\n        v18 = *(_DWORD *)(v29 + 4);\n        if ( !v18 )\n          goto LABEL_23;\n        if ( v17 == 1 )\n          v19 = sub_80AD44F();\n        else\n          v19 = sub_805E767();\n        if ( v19 )\n          sub_804D5E0(\"invalid hw-addr %s\", v18);\n        v29 += 4;\n        v20 = (int *)&v36;\n      }\n      qmemcpy(&v38[*((unsigned __int16 *)v10 + 3)], v20, 0x10u);\n    }\n    else\n    {\n      v21 = strtoul(v11, 0, 0);\n      v22 = &v38[*((unsigned __int16 *)v10 + 3)];\n      if ( (v31 & 0xC) == 0 )\n        goto LABEL_52;\n      sub_804E0BE(fd, 0x8970u, (int)v38, \"SIOCGIFMAP\");\n      if ( (v31 & 0xC) == 12 )\n      {\n        *v22 = v21;\n      }\n      else\n      {\n        if ( (v31 & 8) == 0 )\n        {\nLABEL_52:\n          *(_DWORD *)v22 = v21;\n          goto LABEL_53;\n        }\n        *(_WORD *)v22 = v21;\n      }\n    }\nLABEL_53:\n    sub_804E029(fd, *((unsigned __int16 *)v10 + 2), (int)v38, \"SIOC%s\", *v10);\n    if ( v31 >= 0 )\n      goto LABEL_61;\n    v23 = 0;\n    for ( j = (int *)v38; *(_BYTE *)j; j = (int *)((char *)j + 1) )\n    {\n      if ( *(_BYTE *)j == 58 )\n        ++v23;\n    }\n    if ( !v23 || *((_BYTE *)j - 1) != 45 )\n    {\nLABEL_61:\n      if ( (v31 & 0x40) == 0 )\n        goto LABEL_67;\n      v9 = 4;\nLABEL_63:\n      sub_804E0BE(fd, 0x8913u, (int)v38, \"SIOCGIFFLAGS\");\n      v25 = *((_WORD *)i + 3);\n      if ( (v9 & 0xC) != 0 )\n        LOWORD(v39) = v25 | v39;\n      else\n        LOWORD(v39) = ~v25 & v39;\n      sub_804E0BE(fd, 0x8914u, (int)v38, \"SIOCSIFFLAGS\");\n    }\nLABEL_67:\n    v3 = v29;\n  }\n}\n"
        ],
        "134592712": [
            "sub_805B8C8",
            "0x805b8c8",
            "_BOOL4 __usercall sub_805B8C8@<eax>(int a1@<eax>, char *s)\n{\n  int v2; // eax\n  int v4; // [esp+0h] [ebp-4h] BYREF\n\n  v4 = a1;\n  if ( (dword_80DBB9C & 6) != 0 )\n    puts(s);\n  if ( (dword_80DBB9C & 2) != 0 )\n    return 1;\n  sub_804DD8F();\n  v2 = vfork();\n  if ( v2 < 0 )\n    return 0;\n  if ( !v2 )\n  {\n    execle((const char *)*(&buf + 2), (const char *)*(&buf + 2), \"-c\", s, 0, buf);\n    _exit(127);\n  }\n  sub_804DA34(0, &v4, v2);\n  return (v4 & 0x7F) == 0 && !BYTE1(v4);\n}\n"
        ],
        "134592829": [
            "sub_805B93D",
            "0x805b93d",
            "_BOOL4 __usercall sub_805B93D@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int i; // ebx\n  int v5; // ebp\n  _BOOL4 result; // eax\n  char *v7; // eax\n\n  for ( i = 0; *(_DWORD *)(a1 + 12) > i; ++i )\n  {\n    v5 = *(_DWORD *)(a1 + 16) + 8 * i;\n    if ( !strcmp(*(const char **)v5, a2) )\n    {\n      result = sub_805B8C8(0, *(char **)(v5 + 4));\n      if ( !result )\n        return result;\n    }\n  }\n  v7 = sub_804DDBF(\"run-parts /etc/network/if-%s.d\", a2);\n  return sub_805B8C8((int)v7, v7);\n}\n"
        ],
        "134592908": [
            "sub_805B98C",
            "0x805b98c",
            "char *__usercall sub_805B98C@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char *v3; // ebx\n  char *v4; // edx\n  char *v5; // edi\n  char v6; // cl\n\n  v3 = sub_804DDBF(a1, a2, a3);\n  v4 = v3;\n  v5 = v3;\n  while ( 1 )\n  {\n    v6 = *v4;\n    if ( !*v4 || v6 == 61 )\n      break;\n    if ( v6 == 45 )\n      v6 = 95;\n    if ( (unsigned __int8)(v6 - 97) <= 0x19u )\n      v6 -= 32;\n    if ( (unsigned __int8)(v6 - 48) <= 9u || (unsigned __int8)((v6 | 0x20) - 97) <= 0x19u || v6 == 95 )\n      *v5++ = v6;\n    ++v4;\n  }\n  sub_80B2C69();\n  return v3;\n}\n"
        ],
        "134593005": [
            "sub_805B9ED",
            "0x805b9ed",
            "char *__usercall sub_805B9ED@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  void **v4; // ebx\n  char **v5; // ebx\n  int i; // edi\n  char *result; // eax\n\n  v4 = (void **)buf;\n  if ( buf )\n  {\n    while ( *v4 )\n      free(*v4++);\n    free((void *)buf);\n  }\n  v5 = (char **)sub_804DB2E(4 * *(_DWORD *)(a1 + 12) + 28);\n  buf = (size_t)v5;\n  for ( i = 0; *(_DWORD *)(a1 + 12) > i; ++i )\n  {\n    if ( sub_804D222(\"up\", *(const char **)(*(_DWORD *)(a1 + 16) + 8 * i)) < 0 )\n      *v5++ = sub_805B98C(\n                \"IF_%s=%s\",\n                *(_DWORD *)(8 * i + *(_DWORD *)(a1 + 16)),\n                *(_DWORD *)(8 * i + *(_DWORD *)(a1 + 16) + 4));\n  }\n  *v5 = sub_805B98C(\"%s=%s\", (int)\"IFACE\", *(_DWORD *)(a1 + 8));\n  v5[1] = sub_805B98C(\"%s=%s\", (int)\"ADDRFAM\", **(_DWORD **)a1);\n  v5[2] = sub_805B98C(\"%s=%s\", (int)\"METHOD\", **(_DWORD **)(a1 + 4));\n  v5[3] = sub_805B98C(\"%s=%s\", 135038156, a2);\n  result = sub_805B98C(\"%s=%s\", (int)\"PHASE\", a3);\n  v5[4] = result;\n  if ( *(&buf + 1) )\n  {\n    result = sub_805B98C(\"%s=%s\", (int)\"PATH\", *(&buf + 1));\n    v5[5] = result;\n  }\n  return result;\n}\n"
        ],
        "134593291": [
            "sub_805BB0B",
            "0x805bb0b",
            "_BOOL4 __cdecl sub_805BB0B(int a1)\n{\n  int v1; // eax\n  int v2; // edx\n\n  v1 = (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 8))();\n  v2 = -1;\n  if ( v1 )\n  {\n    sub_805B9ED(a1, (int)\"stop\", (int)\"pre-down\");\n    if ( sub_805B93D(a1, \"down\") && (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 8))() )\n    {\n      sub_805B9ED(a1, (int)\"stop\", (int)\"post-down\");\n      return sub_805B93D(a1, \"post-down\");\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v2;\n}\n"
        ],
        "134593410": [
            "sub_805BB82",
            "0x805bb82",
            "_BOOL4 __cdecl sub_805BB82(int a1)\n{\n  int v1; // eax\n  int v2; // edx\n\n  v1 = (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 4))();\n  v2 = -1;\n  if ( v1 )\n  {\n    sub_805B9ED(a1, (int)\"start\", (int)\"pre-up\");\n    if ( sub_805B93D(a1, \"pre-up\") && (*(int (**)(void))(*(_DWORD *)(a1 + 4) + 4))() )\n    {\n      sub_805B9ED(a1, (int)\"start\", (int)\"post-up\");\n      return sub_805B93D(a1, \"up\");\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v2;\n}\n"
        ],
        "134593529": [
            "sub_805BBF9",
            "0x805bbf9",
            "const char *__usercall sub_805BBF9@<eax>(_DWORD *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  const char *v4; // eax\n  const char *v5; // ebx\n  const char *v6; // edx\n  int v8; // [esp-4h] [ebp-Ch]\n\n  v4 = (const char *)sub_80B2E8C(a3, a2);\n  v5 = 0;\n  if ( *v4 )\n  {\n    v5 = v4;\n    v6 = &v4[strcspn(v4, \" \\t\\n\")];\n    if ( *v6 )\n      *v6 = 0;\n    *a1 = sub_80B2E8C(v8, v6);\n  }\n  return v5;\n}\n"
        ],
        "134593588": [
            "sub_805BC34",
            "0x805bc34",
            "int **__usercall sub_805BC34@<eax>(int **a1@<eax>, _BYTE *a2@<edx>)\n{\n  _BYTE *v4; // eax\n\n  while ( a1 )\n  {\n    v4 = sub_804D210(a1[1], a2);\n    if ( v4 )\n    {\n      if ( *v4 == 61 )\n        break;\n    }\n    a1 = (int **)*a1;\n  }\n  return a1;\n}\n"
        ],
        "134593626": [
            "sub_805BC5A",
            "0x805bc5a",
            "int __usercall sub_805BC5A@<eax>(size_t n@<ecx>, char *s2@<edx>, const char *a3@<eax>)\n{\n  int result; // eax\n\n  result = strncmp(a3, s2, n);\n  if ( !result )\n    return -(unsigned __int8)s2[n];\n  return result;\n}\n"
        ],
        "134593656": [
            "sub_805BC78",
            "0x805bc78",
            "int __usercall sub_805BC78@<eax>(const char *a1@<eax>, size_t a2@<edx>, _DWORD *a3@<ecx>)\n{\n  int i; // ebx\n  int v7; // ebp\n  int v9; // [esp+4h] [ebp-14h]\n\n  if ( !sub_805BC5A(a2, \"iface\", a1) || !sub_805BC5A(a2, \"label\", a1) )\n    return a3[2];\n  v9 = a3[3];\n  for ( i = 0; v9 > i; ++i )\n  {\n    v7 = a3[4] + 8 * i;\n    if ( !sub_805BC5A(a2, *(char **)v7, a1) )\n      return *(_DWORD *)(v7 + 4);\n  }\n  return 0;\n}\n"
        ],
        "134593766": [
            "sub_805BCE6",
            "0x805bce6",
            "int __usercall sub_805BCE6@<eax>(char **a1@<eax>, int a2@<ecx>)\n{\n  char *v3; // edi\n  size_t v4; // ebx\n  char *v5; // edi\n  int v7; // [esp+0h] [ebp-14h]\n  int v8; // [esp+0h] [ebp-14h]\n\n  v3 = *a1;\n  v4 = 0;\n  if ( *a1 )\n  {\n    v7 = a2;\n    v4 = strlen(v3);\n    a2 = v7;\n  }\n  v8 = a2 + 1;\n  v5 = (char *)sub_804DB13(v3, v4 + a2 + 1);\n  sub_80B2C4E(v8);\n  *a1 = v5;\n  return v8;\n}\n"
        ],
        "134593835": [
            "sub_805BD2B",
            "0x805bd2b",
            "_BOOL4 __usercall sub_805BD2B@<eax>(char *a1@<eax>, _DWORD *a2@<edx>, int (__cdecl *a3)(char *)@<ecx>)\n{\n  int v4; // esi\n  char v5; // al\n  char *v6; // edi\n  int v7; // ecx\n  size_t v8; // eax\n  char *v9; // ebx\n  char *v10; // eax\n  const char *v11; // ebp\n  int v12; // edx\n  int v13; // ecx\n  const char *v14; // eax\n  int v15; // eax\n  unsigned int v16; // ecx\n  unsigned __int32 v17; // edx\n  unsigned int v18; // eax\n  const char *v19; // edi\n  int v20; // eax\n  char *v21; // ebx\n  _BOOL4 result; // eax\n  char *s; // [esp+8h] [ebp-4Ch] BYREF\n  struct in_addr inp; // [esp+Ch] [ebp-48h] BYREF\n  char v28[10]; // [esp+12h] [ebp-42h] BYREF\n  int v29[14]; // [esp+1Ch] [ebp-38h] BYREF\n\n  memset(v29, 0, 0x28u);\n  memset(v28, 0, sizeof(v28));\n  v28[0] = 1;\n  s = 0;\n  v4 = 1;\n  while ( 1 )\n  {\n    v5 = *a1;\n    if ( !*a1 )\n      break;\n    if ( v5 == 91 )\n    {\n      if ( a1[1] != 91 || v4 > 9 )\n        goto LABEL_23;\n      v8 = 0;\n      if ( s )\n        v8 = strlen(s);\n      v29[v4] = v8;\n      v28[v4++] = 1;\nLABEL_22:\n      a1 += 2;\n    }\n    else if ( (unsigned __int8)v5 > 0x5Bu )\n    {\n      if ( v5 == 92 )\n      {\n        v6 = a1 + 1;\n        if ( !a1[1] )\n          v6 = a1;\n        v7 = 1;\n        goto LABEL_29;\n      }\n      if ( v5 == 93 && a1[1] == 93 && v4 != 1 )\n      {\n        if ( !v28[--v4] )\n          s[v29[v4]] = 0;\n        goto LABEL_22;\n      }\nLABEL_23:\n      sub_805BCE6(&s, 1);\n      ++a1;\n    }\n    else\n    {\n      if ( v5 != 37 )\n        goto LABEL_23;\n      v9 = a1 + 1;\n      v10 = strchr(v9, 37);\n      v6 = v10;\n      if ( !v10 )\n        goto LABEL_42;\n      v11 = (const char *)sub_805BC78(v9, v10 - v9, a2);\n      if ( v11 )\n      {\n        if ( sub_804D210(v9, \"hwaddress\") )\n        {\n          sub_80B2E9F();\n          v11 = (const char *)sub_80B2E8C(v13, v12);\n        }\n        v7 = strlen(v11);\nLABEL_29:\n        sub_805BCE6(&s, v7);\n        goto LABEL_40;\n      }\n      if ( !sub_804D210(v9, \"bnmask\") )\n        goto LABEL_39;\n      v14 = (const char *)sub_805BC78(\"netmask\", 7u, a2);\n      if ( !v14 )\n        goto LABEL_39;\n      v15 = inet_aton(v14, &inp);\n      v16 = -1;\n      if ( v15 )\n      {\n        v17 = _byteswap_ulong(inp.s_addr);\n        v18 = ~v17;\n        if ( (~v17 & -v17) == 0 )\n        {\n          v16 = 32;\n          while ( v18 )\n          {\n            v18 >>= 1;\n            --v16;\n          }\n        }\n      }\n      a1 = v6 + 1;\n      if ( v16 )\n      {\n        v19 = sub_804D6F7(v16);\n        v20 = strlen(v19);\n        sub_805BCE6(&s, v20);\n      }\n      else\n      {\nLABEL_39:\n        v28[v4 - 1] = 0;\nLABEL_40:\n        a1 = v6 + 1;\n      }\n    }\n  }\n  v21 = s;\n  if ( v4 != 1 || !v28[0] )\n  {\nLABEL_42:\n    free(s);\n    return 0;\n  }\n  result = 0;\n  if ( s )\n  {\n    if ( *s )\n      v4 = a3(s);\n    free(v21);\n    return v4 == 1;\n  }\n  return result;\n}\n"
        ],
        "134594915": [
            "sub_805C163",
            "0x805c163",
            "int __usercall sub_805C163@<eax>(_DWORD *a1@<eax>, int (__cdecl *a2)(char *)@<edx>)\n{\n  _BOOL4 v5; // ebx\n\n  if ( !if_nametoindex(a1[2]) )\n    return 2;\n  v5 = sub_805BD2B(\"ip addr flush dev %iface%[[ label %label%]]\", a1, a2);\n  if ( sub_805BD2B(\"ip link set %iface% down\", a1, a2) + v5 == 2 )\n    return 2;\n  else\n    return 0;\n}\n"
        ],
        "134595041": [
            "sub_805C1E1",
            "0x805c1e1",
            "__pid_t __usercall sub_805C1E1@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4)\n{\n  __pid_t v4; // eax\n  __pid_t v5; // ebx\n  int v9[2]; // [esp+8h] [ebp-20h] BYREF\n  int v10; // [esp+10h] [ebp-18h] BYREF\n  int v11; // [esp+14h] [ebp-14h]\n  int v12; // [esp+18h] [ebp-10h]\n  int v13; // [esp+1Ch] [ebp-Ch]\n  int v14; // [esp+20h] [ebp-8h]\n\n  v12 = a3;\n  v13 = a4;\n  v14 = 0;\n  sub_804DC65(v9);\n  sub_804DC65(&v10);\n  sub_804DD8F();\n  v4 = vfork();\n  if ( v4 < 0 )\n    sub_804D3C9((int)&unk_80C7DA0);\n  if ( !v4 )\n  {\n    close(v9[1]);\n    close(v10);\n    sub_804DC97(v9[0], 0);\n    sub_804DC97(v11, 1);\n    sub_80AB1EC();\n  }\n  v5 = v4;\n  close(v9[0]);\n  close(v11);\n  *a1 = sub_80B3D6E();\n  *a2 = sub_80B3D67();\n  return v5;\n}\n"
        ],
        "134595228": [
            "sub_805C29C",
            "0x805c29c",
            "__int64 sub_805C29C()\n{\n  int v0; // eax\n  FILE *v1; // esi\n  const char *v2; // eax\n  const char *v3; // ebx\n  int v5; // [esp-4h] [ebp-10h]\n\n  v0 = sub_80B3D37();\n  if ( v0 )\n  {\n    v1 = (FILE *)v0;\n    while ( 1 )\n    {\n      v2 = (const char *)sub_80AB850();\n      v3 = v2;\n      if ( !v2 )\n        break;\n      v2[strcspn(v2, \" \\t\\n\")] = 0;\n      sub_80AFAC3(v5, v3);\n    }\n    fclose(v1);\n  }\n  return 0LL;\n}\n"
        ],
        "134595309": [
            "sub_805C2ED",
            "0x805c2ed",
            "_DWORD *__usercall sub_805C2ED@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v2; // ebp\n  _DWORD *v3; // esi\n  _DWORD *v4; // ebx\n  const char *i; // eax\n  int v6; // edx\n  int v7; // ecx\n  void *v8; // eax\n  const char *v9; // eax\n  const char *v10; // edi\n  char *v11; // edi\n  int v12; // edx\n  int v13; // ecx\n  const char *v14; // edi\n  int v15; // eax\n  int v16; // edx\n  _DWORD *v17; // edx\n  _DWORD *j; // eax\n  int v19; // edx\n  int v20; // ecx\n  const char *v21; // ebp\n  int v22; // edx\n  int v23; // ecx\n  const char *v24; // edi\n  int v25; // edx\n  int v26; // ecx\n  int v27; // edx\n  int v28; // ecx\n  int v29; // ecx\n  char ***v30; // ebp\n  int v31; // eax\n  char **v32; // edx\n  int v33; // edi\n  const char **v34; // ebp\n  int v35; // eax\n  int v36; // eax\n  int v37; // edx\n  int v38; // ecx\n  const char *v39; // edi\n  int v40; // ecx\n  char *k; // edx\n  int v42; // eax\n  int v43; // eax\n  int v44; // edi\n  const char *v45; // eax\n  int v46; // edx\n  int v47; // ecx\n  const char *v48; // eax\n  char **v49; // edi\n  int v51; // [esp-4h] [ebp-38h]\n  int v52; // [esp-4h] [ebp-38h]\n  int v53; // [esp-4h] [ebp-38h]\n  int v54; // [esp+0h] [ebp-34h]\n  int v55; // [esp+0h] [ebp-34h]\n  int v56; // [esp+0h] [ebp-34h]\n  int v57; // [esp+0h] [ebp-34h]\n  int v58; // [esp+0h] [ebp-34h]\n  char *ptr; // [esp+4h] [ebp-30h]\n  _DWORD *v60; // [esp+8h] [ebp-2Ch]\n  int v61; // [esp+Ch] [ebp-28h]\n  int v62; // [esp+Ch] [ebp-28h]\n  char **v63; // [esp+Ch] [ebp-28h]\n  FILE *stream; // [esp+10h] [ebp-24h]\n  char *s2; // [esp+14h] [ebp-20h]\n  char *s2a; // [esp+14h] [ebp-20h]\n  char **v68; // [esp+1Ch] [ebp-18h]\n  char **v69; // [esp+1Ch] [ebp-18h]\n  int v70; // [esp+1Ch] [ebp-18h]\n  void *v71[5]; // [esp+20h] [ebp-14h] BYREF\n\n  v60 = a2;\n  if ( !a2 )\n    v60 = sub_804DB2E(0xCu);\n  stream = (FILE *)sub_80B3D45();\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    ptr = (char *)sub_80AB85A();\n    if ( !ptr )\n      break;\n    for ( i = sub_804D378(ptr, 92); i; i = sub_804D378(v11, 92) )\n    {\n      *i = 0;\n      v8 = (void *)sub_80AB85A();\n      v71[0] = v8;\n      if ( !v8 )\n        break;\n      v11 = sub_804DDBF(\"%s%s\", ptr, (const char *)v8);\n      free(ptr);\n      free(v71[0]);\n      ptr = v11;\n    }\n    v71[0] = ptr;\n    v9 = sub_805BBF9(v71, v6, v7);\n    v10 = v9;\n    if ( v9 && *v9 != 35 )\n    {\n      if ( !strcmp(v9, \"mapping\") )\n      {\n        v4 = sub_804DB2E(0x1Cu);\n        while ( 1 )\n        {\n          v14 = sub_805BBF9(v71, v12, v13);\n          if ( !v14 )\n            break;\n          v15 = sub_80B4733(v4[2], 1028);\n          v4[3] = v15;\n          v16 = v4[2];\n          v4[2] = v16 + 1;\n          *(_DWORD *)(v15 + 4 * v16) = sub_804DB46(v14);\n        }\n        v17 = v60 + 2;\n        for ( j = (_DWORD *)v60[2]; j; j = (_DWORD *)*j )\n          v17 = j;\n        *v17 = v4;\n        v2 = 2;\n      }\n      else\n      {\n        v61 = strcmp(v10, \"iface\");\n        if ( v61 )\n        {\n          v36 = strcmp(v10, \"auto\");\n          v37 = v51;\n          v38 = v56;\n          if ( v36 )\n          {\n            if ( !strcmp(v10, \"source\") )\n            {\n              sub_805BBF9(v71, v52, v57);\n              sub_805C2ED();\n            }\n            else if ( v2 == 1 )\n            {\n              if ( !*(_BYTE *)v71[0] )\n                sub_804D5E0(\"option with empty value \\\"%s\\\"\", ptr);\n              if ( !strcmp(v10, \"post-up\") )\n              {\n                v10 += 5;\n              }\n              else if ( !strcmp(v10, \"pre-down\") )\n              {\n                v10 += 4;\n              }\n              if ( sub_804D222(\"up\", v10) < 0 )\n              {\n                v62 = v3[3];\n                v40 = v3[4];\n                for ( k = 0; v62 > (int)k; k = s2a + 1 )\n                {\n                  v70 = v40;\n                  s2a = k;\n                  v42 = strcmp(*(const char **)(v40 + 8 * (_DWORD)k), v10);\n                  v40 = v70;\n                  if ( !v42 )\n                    sub_804D5E0(\"duplicate option \\\"%s\\\"\", ptr);\n                }\n              }\n              v43 = sub_80B4733(v3[3], 2052);\n              v3[4] = v43;\n              v63 = (char **)(v43 + 8 * v3[3]);\n              *v63 = sub_804DB46(v10);\n              v44 = v3[4] + 8 * v3[3];\n              *(_DWORD *)(v44 + 4) = sub_804DB46((const char *)v71[0]);\n              ++v3[3];\n            }\n            else\n            {\n              if ( v2 != 2 )\n                goto LABEL_70;\n              if ( !strcmp(v10, \"script\") )\n              {\n                if ( v4[4] )\n                  sub_804D5E0(\"duplicate script in mapping \\\"%s\\\"\", ptr);\n                v45 = sub_805BBF9(v71, v53, v58);\n                v4[4] = sub_804DB46(v45);\n              }\n              else\n              {\n                if ( strcmp(v10, \"map\") )\nLABEL_70:\n                  sub_804D5E0(\"misplaced option \\\"%s\\\"\", ptr);\n                v4[6] = sub_80B4733(v4[5], 1026);\n                v48 = sub_805BBF9(v71, v46, v47);\n                v49 = (char **)(v4[6] + 4 * v4[5]);\n                *v49 = sub_804DB46(v48);\n                ++v4[5];\n              }\n            }\n          }\n          else\n          {\n            while ( 1 )\n            {\n              v39 = sub_805BBF9(v71, v37, v38);\n              if ( !v39 )\n                break;\n              if ( sub_80AFB6A() )\n                sub_804D3C9((int)\"interface declared auto twice \\\"%s\\\"\", ptr);\n              sub_804DB46(v39);\n              ((void (*)(void))sub_80AFADF)();\n            }\n            v2 = 0;\n          }\n        }\n        else\n        {\n          v3 = sub_804DB2E(0x14u);\n          v21 = sub_805BBF9(v71, v19, v20);\n          v24 = sub_805BBF9(v71, v22, v23);\n          s2 = (char *)sub_805BBF9(v71, v25, v26);\n          if ( !s2 )\n            sub_804D5E0(\"too few parameters for line \\\"%s\\\"\", ptr);\n          v71[0] = (void *)sub_80B2E8C(v28, v27);\n          if ( *(_BYTE *)v71[0] )\n            sub_804D5E0(\"too many parameters \\\"%s\\\"\", ptr);\n          v3[2] = sub_804DB46(v21);\n          if ( !v24 )\n          {\n            *v3 = 0;\nLABEL_32:\n            sub_804D5E0(\"unknown address type \\\"%s\\\"\", v24);\n          }\n          v30 = off_80B7860;\n          do\n          {\n            v32 = *v30;\n            if ( !*v30 )\n              break;\n            v68 = *v30;\n            v31 = strcmp(*v32, v24);\n            v29 = v54;\n            ++v30;\n            v32 = v68;\n          }\n          while ( v31 );\n          *v3 = v32;\n          if ( !v32 )\n            goto LABEL_32;\n          v33 = (int)v32[1];\n          while ( v61 < v33 )\n          {\n            v34 = (const char **)&v32[2][12 * v61];\n            v69 = v32;\n            v35 = strcmp(*v34, s2);\n            v29 = v55;\n            v32 = v69;\n            if ( !v35 )\n              goto LABEL_37;\n            ++v61;\n          }\n          v34 = 0;\nLABEL_37:\n          v3[1] = v34;\n          if ( !v34 )\n            sub_804D5E0(\"unknown method \\\"%s\\\"\", s2);\n          sub_80AFADF(v29, v3);\n          v2 = 1;\n        }\n      }\n    }\n    free(ptr);\n  }\n  if ( (stream->_flags & 8) != 0 )\n    sub_804D5E0(\"%s: I/O error\", a1);\n  fclose(stream);\n  return v60;\n}\n"
        ],
        "134596473": [
            "sub_805C779",
            "0x805c779",
            "int __cdecl sub_805C779(int a1, int a2)\n{\n  const char *v2; // eax\n  _DWORD *v3; // ebx\n  _DWORD *v4; // eax\n  int v5; // ecx\n  char *v6; // ebp\n  char *v7; // eax\n  const char *v8; // eax\n  char *v9; // ebx\n  int **v10; // esi\n  int **v11; // eax\n  _DWORD *i; // esi\n  int j; // edx\n  int v14; // edi\n  const char *v15; // eax\n  char *v16; // edi\n  const char *k; // eax\n  _DWORD *v18; // esi\n  int v19; // edi\n  int v20; // eax\n  signed int v21; // esi\n  int v22; // edi\n  FILE *v23; // esi\n  int v24; // ecx\n  char *v25; // edi\n  void *v26; // eax\n  FILE *m; // edi\n  _BOOL4 (__cdecl *v29)(int); // [esp+0h] [ebp-38h]\n  int v30; // [esp+4h] [ebp-34h]\n  __pid_t v31; // [esp+4h] [ebp-34h]\n  char v32; // [esp+4h] [ebp-34h]\n  _DWORD *v33; // [esp+8h] [ebp-30h]\n  const char *v34; // [esp+Ch] [ebp-2Ch]\n  unsigned __int8 v35; // [esp+12h] [ebp-26h]\n  char v36; // [esp+13h] [ebp-25h]\n  int **v37; // [esp+14h] [ebp-24h]\n  const char *v38; // [esp+18h] [ebp-20h] BYREF\n  FILE *stream; // [esp+1Ch] [ebp-1Ch] BYREF\n  FILE *v40; // [esp+20h] [ebp-18h] BYREF\n  int stat_loc; // [esp+24h] [ebp-14h] BYREF\n\n  v37 = 0;\n  v38 = \"/etc/network/interfaces\";\n  *(&buf + 1) = (size_t)getenv(\"PATH\");\n  v2 = (const char *)sub_80AB879();\n  *(&buf + 2) = (size_t)sub_804DB46(v2);\n  v29 = sub_805BB0B;\n  if ( ident[2] == 117 )\n    v29 = sub_805BB82;\n  sub_80ABEAC(a2, \"anvfmi:\", &v38);\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( *v3 )\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n      goto LABEL_5;\n  }\n  else if ( (dword_80DBB9C & 1) == 0 )\n  {\nLABEL_5:\n    sub_804CDC2();\n  }\n  v4 = sub_805C2ED((int)v38, 0);\n  v33 = v4;\n  if ( (dword_80DBB9C & 1) != 0 )\n    v37 = (int **)*v4;\n  else\n    sub_80AFADF(v5, *v3);\n  v35 = 0;\nLABEL_11:\n  if ( v37 )\n  {\n    v6 = sub_804DB46((const char *)v37[1]);\n    v37 = (int **)*v37;\n    v7 = strchr(v6, 61);\n    if ( v7 )\n    {\n      *v7 = 0;\n      v8 = v7 + 1;\n    }\n    else\n    {\n      v8 = v6;\n    }\n    v9 = sub_804DB46(v8);\n    if ( (dword_80DBB9C & 8) == 0 )\n    {\n      v10 = (int **)sub_805C29C();\n      v11 = sub_805BC34(v10, v6);\n      if ( v29 == sub_805BB82 )\n      {\n        if ( v11 )\n        {\n          sub_804D5F4(\"interface %s already configured\", v6);\n          goto LABEL_81;\n        }\n      }\n      else if ( !v11 )\n      {\n        sub_804D5F4(\"interface %s not configured\", v6);\n        goto LABEL_81;\n      }\n      sub_80AFB36();\n    }\n    if ( v29 == sub_805BB82 && (dword_80DBB9C & 0x10) == 0 )\n    {\n      for ( i = (_DWORD *)v33[2]; i; i = (_DWORD *)*i )\n      {\n        for ( j = 0; i[2] > j; j = v30 + 1 )\n        {\n          v30 = j;\n          v14 = fnmatch(*(const char **)(i[3] + 4 * j), v9, 0);\n          if ( !v14 )\n          {\n            if ( (dword_80DBB9C & 4) != 0 )\n              printf(\"Running mapping script %s on %s\\n\", (const char *)i[4], v9);\n            v9 = sub_804DB46(v6);\n            v31 = sub_805C1E1(&stream, &v40, i[4], (int)v6);\n            while ( v14 < i[5] )\n              fprintf(stream, \"%s\\n\", *(const char **)(i[6] + 4 * v14++));\n            fclose(stream);\n            sub_804DA34(0, &stat_loc, v31);\n            if ( (stat_loc & 0x7F) == 0 && !BYTE1(stat_loc) )\n            {\n              v15 = (const char *)sub_80AB85A();\n              v16 = (char *)v15;\n              if ( v15 )\n              {\n                for ( k = &v15[strlen(v15) - 1];\n                      v16 <= k && (*k == 32 || (unsigned __int8)(*k - 9) <= 4u);\n                      *((_BYTE *)k + 1) = 0 )\n                {\n                  --k;\n                }\n                free(v9);\n                v9 = v16;\n              }\n            }\n            fclose(v40);\n            break;\n          }\n        }\n      }\n    }\n    v18 = (_DWORD *)v33[1];\n    v32 = 0;\n    v36 = 0;\n    while ( 1 )\n    {\n      if ( !v18 )\n      {\n        if ( (dword_80DBB9C & 4) != 0 )\n          sub_804DD98(10);\n        if ( v36 || (dword_80DBB9C & 8) != 0 )\n        {\n          if ( (dword_80DBB9C & 2) == 0 )\n          {\n            v21 = 0;\n            v22 = 193;\n            while ( open64(\"/var/run/ifstate.new\") < 0 )\n            {\n              if ( *(_DWORD *)dword_80DBB7C != 17 || v22 == 577 )\n                sub_804D3C9((int)\"can't open '%s'\", \"/var/run/ifstate.new\");\n              if ( v21 <= 30000 )\n              {\n                usleep(v21);\n                v21 += 1000;\n              }\n              else\n              {\n                v22 = 577;\n              }\n            }\n            v23 = (FILE *)sub_80B3D6E();\n            v40 = (FILE *)sub_805C29C();\n            stat_loc = (int)sub_805BC34((int **)v40, v6);\n            if ( v29 != sub_805BB82 || v32 )\n            {\n              sub_80AFB1E();\n              v26 = (void *)sub_80AFB01();\n              free(v26);\n            }\n            else\n            {\n              v25 = sub_804DDBF(\"%s=%s\", v6, v9);\n              if ( stat_loc )\n              {\n                free(*(void **)(stat_loc + 4));\n                *(_DWORD *)(stat_loc + 4) = v25;\n              }\n              else\n              {\n                sub_80AFADF(v24, v25);\n              }\n            }\n            for ( m = v40; m; m = (FILE *)m->_flags )\n            {\n              if ( m->_IO_read_ptr )\n                fprintf(v23, \"%s\\n\", m->_IO_read_ptr);\n            }\n            fclose(v23);\n            sub_804DC43(\"/var/run/ifstate.new\", \"/var/run/ifstate\");\n            sub_80AFB36();\n          }\n        }\n        else\n        {\n          sub_804D5F4(\"ignoring unknown interface %s\", v9);\n          v35 = 1;\n        }\nLABEL_81:\n        free(v6);\n        free(v9);\n        goto LABEL_11;\n      }\n      v19 = v18[1];\n      v34 = *(const char **)(v19 + 8);\n      if ( !strcmp(v9, v34) )\n        break;\nLABEL_54:\n      v18 = (_DWORD *)*v18;\n    }\n    *(_DWORD *)(v19 + 8) = v6;\n    v20 = v29(v19);\n    if ( v20 == -1 )\n    {\n      sub_804D5F4(\"don't have all variables for %s/%s\", v9, **(const char ***)v19);\n    }\n    else if ( v20 )\n    {\nLABEL_53:\n      *(_DWORD *)(v19 + 8) = v34;\n      v36 = 1;\n      goto LABEL_54;\n    }\n    v32 = 1;\n    v35 = 1;\n    goto LABEL_53;\n  }\n  return v35;\n}\n"
        ],
        "134597578": [
            "sub_805CBCA",
            "0x805cbca",
            "signed int __usercall sub_805CBCA@<eax>(signed int result@<eax>)\n{\n  unsigned int v1; // edx\n\n  if ( result >= 0 )\n  {\n    v1 = (unsigned int)result >> 5;\n    result &= 0x1Fu;\n    _bittestandreset(&dword_80DB840[v1], result);\n    *(&buf + 8) = -1;\n  }\n  return result;\n}\n"
        ],
        "134597609": [
            "sub_805CBE9",
            "0x805cbe9",
            "int sub_805CBE9()\n{\n  int result; // eax\n  _BYTE *v1; // edx\n\n  seconds = &dword_80DB7C0;\n  for ( result = 32; result != 127; ++result )\n  {\n    v1 = seconds;\n    seconds = (char *)seconds + 1;\n    *v1 = result;\n  }\n  return result;\n}\n"
        ],
        "134597670": [
            "sub_805CC26",
            "0x805cc26",
            "int __usercall sub_805CC26@<eax>(int result@<eax>)\n{\n  int v1; // [esp-4h] [ebp-4h]\n\n  if ( result >= 0 )\n  {\n    close(result);\n    return v1;\n  }\n  return result;\n}\n"
        ],
        "134597682": [
            "sub_805CC32",
            "0x805cc32",
            "int __usercall sub_805CC32@<eax>(void **a1@<eax>)\n{\n  int i; // esi\n  int result; // eax\n  int v4; // [esp-4h] [ebp-Ch]\n\n  free(a1[1]);\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[9]);\n  free(a1[10]);\n  free(a1[13]);\n  free(a1[14]);\n  for ( i = 0; i != 20; ++i )\n  {\n    free(a1[i + 15]);\n    result = v4;\n  }\n  return result;\n}\n"
        ],
        "134597766": [
            "sub_805CC86",
            "0x805cc86",
            "int sub_805CC86()\n{\n  unsigned __int64 v0; // rax\n  unsigned __int64 v1; // rax\n  int result; // eax\n  int v3; // [esp-4h] [ebp-18h]\n  int v4; // [esp-4h] [ebp-18h]\n  unsigned __int64 v5; // [esp+0h] [ebp-14h] BYREF\n  unsigned __int64 v6; // [esp+8h] [ebp-Ch]\n\n  getrlimit64(7, &v5);\n  v0 = v5 + 32;\n  if ( v5 + 32 > v6 )\n    v0 = v6;\n  v1 = v0 + 32;\n  if ( v1 > 0x400 )\n    v1 = 1024LL;\n  v5 = v1;\n  if ( v1 > *(_QWORD *)&buf )\n  {\n    if ( setrlimit64(7, &v5) >= 0 )\n    {\n      result = v5;\n      *(_QWORD *)&buf = v5;\n    }\n    else\n    {\n      sub_804D3A5((int)\"setrlimit\");\n      return v4;\n    }\n  }\n  else\n  {\n    sub_804D5F4(\"can't extend file limit, max = %d\", (_DWORD)v1);\n    return v3;\n  }\n  return result;\n}\n"
        ],
        "134597932": [
            "sub_805CD2C",
            "0x805cd2c",
            "int __usercall sub_805CD2C@<eax>(int result@<eax>)\n{\n  if ( result >= 0 )\n  {\n    _bittestandset(&dword_80DB840[(unsigned int)result >> 5], result & 0x1F);\n    if ( (*(&buf + 8) & 0x80000000) == 0 && (int)*(&buf + 8) < result )\n    {\n      *(&buf + 8) = result;\n      *(&buf + 9) = result;\n      if ( result > (unsigned __int64)(*(_QWORD *)&buf - 8LL) )\n        return sub_805CC86();\n    }\n  }\n  return result;\n}\n"
        ],
        "134598027": [
            "sub_805CD8B",
            "0x805cd8b",
            "void __noreturn sub_805CD8B()\n{\n  int i; // ebx\n\n  for ( i = *(&buf + 6); i; i = *(_DWORD *)(i + 48) )\n  {\n    if ( *(_DWORD *)i != -1 && *(_BYTE *)(i + 21) == 1 )\n      unlink(*(const char **)(i + 8));\n  }\n  exit(0);\n}\n"
        ],
        "134598070": [
            "sub_805CDB6",
            "0x805cdb6",
            "int __fastcall sub_805CDB6(int a1, int a2)\n{\n  _DWORD *v2; // esi\n  int v3; // edi\n  __pid_t v4; // eax\n  int *i; // ebx\n  int v7; // [esp+0h] [ebp-10h] BYREF\n\n  v7 = a2;\n  v2 = (_DWORD *)dword_80DBB7C;\n  v3 = *(_DWORD *)dword_80DBB7C;\nLABEL_2:\n  while ( 1 )\n  {\n    v4 = sub_804DA5C(&v7);\n    if ( v4 <= 0 )\n      break;\n    for ( i = (int *)*(&buf + 6); i; i = (int *)i[12] )\n    {\n      if ( i[4] == v4 )\n      {\n        if ( (v7 & 0x7F) != 0 || !BYTE1(v7) )\n        {\n          if ( (unsigned int)(unsigned __int16)v7 - 1 <= 0xFE )\n            sub_804D5F4(\"%s: exit signal %u\", i[14], v7 & 0x7F);\n        }\n        else\n        {\n          sub_804D5F4(\"%s: exit status %u\", i[14], BYTE1(v7));\n        }\n        i[4] = 1;\n        sub_805CD2C(*i);\n        goto LABEL_2;\n      }\n    }\n  }\n  *v2 = v3;\n  return v7;\n}\n"
        ],
        "134598660": [
            "sub_805D004",
            "0x805d004",
            "_WORD *__usercall sub_805D004@<eax>(int a1@<eax>)\n{\n  __int16 v1; // si\n  int v2; // ebx\n  _WORD *result; // eax\n\n  v1 = a1;\n  v2 = 110;\n  if ( a1 != 1 )\n    v2 = a1 == 10 ? 28 : 16;\n  result = sub_804DB2E(v2 + 4);\n  *(_DWORD *)result = v2;\n  result[2] = v1;\n  return result;\n}\n"
        ],
        "134598704": [
            "sub_805D030",
            "0x805d030",
            "int __usercall sub_805D030@<eax>(sigset_t *a1@<eax>)\n{\n  a1->__val[0] = 0;\n  a1->__val[1] = 0;\n  sigaddset(a1, 17);\n  sigaddset(a1, 1);\n  sigaddset(a1, 14);\n  return sigprocmask(0, a1, a1);\n}\n"
        ],
        "134598758": [
            "sub_805D066",
            "0x805d066",
            "int __usercall sub_805D066@<eax>(const sigset_t *a1@<eax>)\n{\n  return sigprocmask(2, a1, 0);\n}\n"
        ],
        "134598772": [
            "sub_805D074",
            "0x805d074",
            "int sub_805D074()\n{\n  int result; // eax\n  int v1; // [esp-4h] [ebp-4h]\n\n  if ( !*((_BYTE *)&buf + 44) )\n  {\n    *((_BYTE *)&buf + 44) = 1;\n    alarm(0x3Cu);\n    return v1;\n  }\n  return result;\n}\n"
        ],
        "134598797": [
            "sub_805D08D",
            "0x805d08d",
            "int __usercall sub_805D08D@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // esi\n\n  v2 = socket(*(char *)(a1 + 21), *(char *)(a1 + 20), 0);\n  if ( v2 < 0 )\n    return sub_804D3A5((int)\"socket\");\n  v4 = v2;\n  sub_80B4262();\n  if ( *(_BYTE *)(a1 + 21) == 1 )\n    unlink((const char *)(*(_DWORD *)(a1 + 52) + 6));\n  if ( bind(v4, (const struct sockaddr *)(*(_DWORD *)(a1 + 52) + 4), **(_DWORD **)(a1 + 52)) >= 0 )\n  {\n    if ( *(_BYTE *)(a1 + 20) == 1 )\n      listen(v4, *(&buf + 7));\n    result = sub_805CD2C(v4);\n    *(_DWORD *)a1 = v4;\n  }\n  else\n  {\n    sub_804D3A5((int)&unk_80CC99B, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));\n    close(v4);\n    return sub_805D074();\n  }\n  return result;\n}\n"
        ],
        "134598950": [
            "sub_805D126",
            "0x805d126",
            "int sub_805D126()\n{\n  _DWORD *v0; // esi\n  int v1; // edi\n  _DWORD *i; // ebx\n  int result; // eax\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  *((_BYTE *)&buf + 44) = 0;\n  for ( i = (_DWORD *)*(&buf + 6); i; i = (_DWORD *)i[12] )\n  {\n    if ( *i == -1 )\n      result = sub_805D08D((int)i);\n  }\n  *v0 = v1;\n  return result;\n}\n"
        ],
        "134599395": [
            "sub_805D2E3",
            "0x805d2e3",
            "_DWORD *sub_805D2E3()\n{\n  _DWORD *v0; // ebx\n  int v1; // ebp\n  const char *v2; // esi\n  char *v3; // eax\n  char *v4; // edi\n  char *v5; // esi\n  const char *v6; // eax\n  char *v7; // edi\n  const char *v8; // esi\n  char *v9; // eax\n  char *v10; // esi\n  char *v11; // eax\n  char *v12; // eax\n  const char *v13; // edi\n  char v14; // dl\n  const char *v15; // esi\n  int v16; // eax\n  int v17; // esi\n  const char *v18; // eax\n  char v19; // al\n  bool v20; // zf\n  int i; // esi\n  const char **v22; // ebp\n  char v24; // [esp+0h] [ebp-7Ch]\n  char *v25; // [esp+0h] [ebp-7Ch]\n  char *s; // [esp+4h] [ebp-78h]\n  const char *v27; // [esp+8h] [ebp-74h]\n  const char *v28; // [esp+Ch] [ebp-70h]\n  char *s1; // [esp+10h] [ebp-6Ch]\n  const char *v30; // [esp+14h] [ebp-68h]\n  const char *v31; // [esp+18h] [ebp-64h]\n  int v32[24]; // [esp+1Ch] [ebp-60h]\n\n  while ( 1 )\n  {\n    v0 = sub_804DB2E(0x90u);\n    *v0 = -1;\n    while ( 1 )\n    {\n      v1 = sub_80B0560(\"# \\t\");\n      if ( !v1 )\n      {\n        free(v0);\n        return 0;\n      }\n      v2 = s;\n      v3 = strrchr(s, 58);\n      v4 = v3;\n      if ( !v3 )\n        break;\n      *v3 = 0;\n      v0[1] = sub_804DB46(s);\n      if ( v4[1] || v1 != 1 )\n      {\n        v2 = v4 + 1;\n        goto LABEL_10;\n      }\n      free(dword_80DB7B4);\n      dword_80DB7B4 = (void *)v0[1];\n    }\n    v0[1] = sub_804DB46((const char *)dword_80DB7B4);\nLABEL_10:\n    v0[2] = sub_804DB46(v2);\n    if ( v1 <= 5 )\n      goto LABEL_11;\n    *((_BYTE *)v0 + 20) = byte_80CCB12[sub_804D222(\"stream\", v27)];\n    v5 = sub_804DB46(v28);\n    v0[3] = v5;\n    if ( !strcmp(v5, \"unix\") )\n    {\n      *((_BYTE *)v0 + 21) = 1;\n      goto LABEL_25;\n    }\n    *((_BYTE *)v0 + 21) = 2;\n    v6 = sub_804D378(v5, 54);\n    v7 = (char *)v6;\n    if ( v6 )\n    {\n      *v6 = 0;\n      *((_BYTE *)v0 + 21) = 10;\n    }\n    if ( !sub_804D210(v5, \"rpc/\") )\n      break;\n    sub_804D5F4(\"no support for rpc services\");\nLABEL_11:\n    sub_804D5F4(\"parse error on line %u, line is ignored\", *(_DWORD *)(*(&buf + 14) + 24));\n    sub_805CC32((void **)v0);\n    free(v0);\n  }\n  if ( !strcmp(v5, \"tcp\") )\n    *((_BYTE *)v0 + 22) = 6;\n  if ( !strcmp(v5, \"udp\") )\n  {\n    *((_BYTE *)v0 + 22) = 17;\n    if ( !v7 )\n      goto LABEL_25;\n    goto LABEL_22;\n  }\n  if ( v7 )\nLABEL_22:\n    *v7 = 54;\n  if ( !*((_BYTE *)v0 + 22) )\n    goto LABEL_11;\nLABEL_25:\n  v8 = s1;\n  v0[6] = *(&buf + 10);\n  v9 = strchr(s1, 46);\n  if ( v9 )\n  {\n    *v9 = 0;\n    v0[6] = sub_804ED6C(10, v9 + 1, 0, (int)v0);\n    if ( *(_DWORD *)dword_80DBB7C )\n      goto LABEL_11;\n  }\n  if ( *s1 == 110 && s1[1] == 111 )\n  {\n    v0[4] = 0;\n    v8 = s1 + 2;\n  }\n  else\n  {\n    v0[4] = 1;\n  }\n  if ( strcmp(v8, \"wait\") )\n    goto LABEL_11;\n  v10 = sub_804DB46(v30);\n  v0[9] = v10;\n  v11 = strchr(v10, 46);\n  if ( v11 || (v11 = strchr(v10, 58)) != 0 )\n  {\n    *v11 = 0;\n    v0[10] = sub_804DB46(v11 + 1);\n  }\n  v12 = sub_804DB46(v31);\n  v0[14] = v12;\n  if ( !strcmp(v12, \"internal\") )\n  {\n    v13 = (const char *)v0[2];\n    if ( strlen(v13) <= 7 )\n    {\n      v14 = *((_BYTE *)v0 + 20);\n      if ( (unsigned __int8)(v14 - 1) <= 1u )\n      {\n        v15 = \"echo\";\n        while ( 1 )\n        {\n          v24 = v14;\n          v16 = strncmp(v15, v13, 7u);\n          v14 = v24;\n          if ( !v16 )\n            break;\n          v15 += 16;\n          if ( &unk_80B57D0 == (_UNKNOWN *)v15 )\n          {\n            sub_804D5F4(\"unknown internal service %s\", v13);\n            goto LABEL_11;\n          }\n        }\n        v0[11] = v15;\n        if ( v0[4] != (v24 == 2) )\n          goto LABEL_11;\n      }\n    }\n  }\n  v17 = 0;\n  while ( 1 )\n  {\n    v18 = (const char *)v32[v17];\n    if ( !v18 )\n      break;\n    v0[++v17 + 14] = sub_804DB46(v18);\n    if ( v17 == 20 )\n      goto LABEL_51;\n  }\n  if ( !v17 )\n    v0[15] = sub_804DB46((const char *)v0[14]);\nLABEL_51:\n  v19 = *((_BYTE *)v0 + 20);\n  if ( v19 == 1 )\n  {\n    v20 = *((_BYTE *)v0 + 22) == 17;\n  }\n  else\n  {\n    if ( v19 != 2 )\n      goto LABEL_59;\n    v20 = *((_BYTE *)v0 + 22) == 6;\n  }\n  if ( v20 )\n    goto LABEL_11;\nLABEL_59:\n  while ( 1 )\n  {\n    v25 = strrchr((const char *)v0[1], 44);\n    if ( !v25 )\n      break;\n    v22 = (const char **)sub_804DB2E(0x90u);\n    qmemcpy(v22, v0, 0x90u);\n    v22[2] = sub_804DB46(v22[2]);\n    v22[3] = sub_804DB46(v22[3]);\n    v22[9] = sub_804DB46(v22[9]);\n    v22[10] = sub_804DB46(v22[10]);\n    v22[14] = sub_804DB46(v22[14]);\n    for ( i = 0; i != 21; ++i )\n      v22[i + 15] = sub_804DB46(v22[i + 15]);\n    *v25 = 0;\n    v22[1] = sub_804DB46(v25 + 1);\n    v22[12] = (const char *)v0[12];\n    v0[12] = v22;\n  }\n  return v0;\n}\n"
        ],
        "134600315": [
            "sub_805D67B",
            "0x805d67b",
            "int sub_805D67B()\n{\n  int i; // eax\n  unsigned int v1; // eax\n  int s_port; // edi\n  struct servent *v3; // eax\n  _DWORD *v4; // ebx\n  _DWORD *v5; // ebp\n  _DWORD *j; // ebx\n  int v7; // esi\n  int v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  _WORD *v12; // esi\n  _BYTE *v13; // eax\n  unsigned __int16 v14; // cx\n  _DWORD *v15; // eax\n  size_t *v16; // esi\n  size_t v17; // ebx\n  int result; // eax\n  int v19; // [esp+0h] [ebp-24h]\n  char v20[8]; // [esp+4h] [ebp-20h] BYREF\n  char proto[24]; // [esp+Ch] [ebp-18h] BYREF\n\n  v19 = *(_DWORD *)dword_80DBB7C;\n  free(dword_80DB7B4);\n  dword_80DB7B4 = sub_804DB46(\"*\");\n  if ( *(&buf + 14) )\n    sub_80B0536();\n  *(&buf + 14) = sub_80B052C();\n  if ( *(&buf + 14) )\n  {\n    for ( i = *(&buf + 6); i; i = *(_DWORD *)(i + 48) )\n      *(_BYTE *)(i + 23) = 0;\nLABEL_11:\n    v5 = sub_805D2E3();\n    if ( v5 )\n    {\n      while ( 1 )\n      {\n        for ( j = (_DWORD *)*(&buf + 6); ; j = (_DWORD *)j[12] )\n        {\n          if ( !j )\n          {\n            j = sub_804DB2E(0x90u);\n            *j = -1;\n            qmemcpy(j, v5, 0x90u);\n            *j = -1;\n            sub_805D030((sigset_t *)proto);\n            j[12] = *(&buf + 6);\n            *(&buf + 6) = (size_t)j;\n            sub_805D066((const sigset_t *)proto);\n            goto LABEL_24;\n          }\n          if ( !strcmp((const char *)j[1], (const char *)v5[1]) && !strcmp((const char *)j[2], (const char *)v5[2]) )\n          {\n            v7 = strcmp((const char *)j[3], (const char *)v5[3]);\n            if ( !v7 )\n              break;\n          }\n        }\n        sub_805D030((sigset_t *)v20);\n        if ( !v5[4] )\n          sub_805CD2C(*j);\n        j[4] = v5[4];\n        j[6] = v5[6];\n        v8 = j[9];\n        j[9] = v5[9];\n        v5[9] = v8;\n        v9 = j[10];\n        j[10] = v5[10];\n        v5[10] = v9;\n        v10 = j[14];\n        j[14] = v5[14];\n        v5[14] = v10;\n        do\n        {\n          v11 = j[v7 + 15];\n          j[v7 + 15] = v5[v7 + 15];\n          v5[v7++ + 15] = v11;\n        }\n        while ( v7 != 20 );\n        sub_805D066((const sigset_t *)v20);\n        sub_805CC32((void **)v5);\nLABEL_24:\n        *((_BYTE *)j + 23) = 1;\n        if ( *((_BYTE *)j + 21) == 1 )\n        {\n          v12 = sub_805D004(1);\n          sub_80B2C4E(108);\n          goto LABEL_34;\n        }\n        v1 = sub_804ED6C(10, (const char *)j[2], 0, (int)j);\n        LOWORD(s_port) = __ROL2__(v1, 8);\n        if ( *(_DWORD *)dword_80DBB7C || v1 > 0xFFFF )\n        {\n          sub_80B2C4E(4);\n          v3 = getservbyname((const char *)j[2], proto);\n          if ( !v3 )\n          {\n            sub_804D5F4(\"%s/%s: unknown service\", (const char *)j[2], (const char *)j[3]);\n            goto LABEL_10;\n          }\n          s_port = v3->s_port;\n        }\n        v13 = (_BYTE *)j[1];\n        v14 = *((char *)j + 21);\n        if ( *v13 == 42 && !v13[1] )\n        {\n          v12 = sub_805D004((char)v14);\n          sub_80B435E();\nLABEL_34:\n          v15 = (_DWORD *)j[13];\n          if ( v15 && *(_DWORD *)v12 == *v15 && !memcmp(v12 + 2, v15 + 1, *(_DWORD *)v12) )\n          {\n            free(v12);\n          }\n          else\n          {\n            sub_805CBCA(*j);\n            sub_805CC26(*j);\n            free((void *)j[13]);\n            j[13] = v12;\n            *j = -1;\n          }\n          if ( *j == -1 )\n            sub_805D08D((int)j);\n          goto LABEL_10;\n        }\n        v12 = (_WORD *)sub_80B459A(v14, (unsigned __int16)__ROL2__(s_port, 8));\n        if ( v12 )\n          goto LABEL_34;\n        sub_804D5F4(\"%s/%s: unknown host '%s'\", (const char *)j[2], (const char *)j[3], (const char *)j[1]);\nLABEL_10:\n        v4 = (_DWORD *)v5[12];\n        free(v5);\n        v5 = v4;\n        if ( !v4 )\n          goto LABEL_11;\n      }\n    }\n    if ( *(&buf + 14) )\n    {\n      sub_80B0536();\n      *(&buf + 14) = 0;\n    }\n    sub_805D030((sigset_t *)v20);\n    v16 = &buf + 6;\n    while ( 1 )\n    {\n      v17 = *v16;\n      if ( !*v16 )\n        break;\n      if ( *(_BYTE *)(v17 + 23) )\n      {\n        v16 = (size_t *)(v17 + 48);\n      }\n      else\n      {\n        *v16 = *(_DWORD *)(v17 + 48);\n        sub_805CBCA(*(_DWORD *)v17);\n        sub_805CC26(*(_DWORD *)v17);\n        if ( *(_BYTE *)(v17 + 21) == 1 )\n          unlink(*(const char **)(v17 + 8));\n        sub_805CC32((void **)v17);\n        free((void *)v17);\n      }\n    }\n    sub_805D066((const sigset_t *)v20);\n  }\n  result = dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = v19;\n  return result;\n}\n"
        ],
        "134601161": [
            "sub_805D9C9",
            "0x805d9c9",
            "void __cdecl __noreturn sub_805D9C9(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // eax\n  signed int v4; // ecx\n  size_t i; // eax\n  signed int v6; // ecx\n  unsigned int v7; // eax\n  int v8; // eax\n  int v9; // eax\n  int v10; // ebx\n  unsigned int v11; // edx\n  __pid_t v12; // eax\n  int v13; // ecx\n  struct passwd *v14; // ebx\n  _WORD *v15; // ebx\n  __uid_t pw_uid; // ecx\n  int v17; // edx\n  int *j; // ebx\n  int v19; // [esp+4h] [ebp-D8h]\n  int fd; // [esp+8h] [ebp-D4h]\n  int v21; // [esp+Ch] [ebp-D0h]\n  int v22; // [esp+10h] [ebp-CCh]\n  struct group *v23; // [esp+14h] [ebp-C8h]\n  int v24; // [esp+18h] [ebp-C4h]\n  int v25; // [esp+1Ch] [ebp-C0h]\n  char v26[8]; // [esp+20h] [ebp-BCh] BYREF\n  _BYTE v27[168]; // [esp+28h] [ebp-B4h] BYREF\n\n  *(_QWORD *)&buf = 64LL;\n  *(&buf + 7) = 128;\n  *(&buf + 13) = (size_t)\"/etc/inetd.conf\";\n  *(&buf + 12) = getuid();\n  if ( *(&buf + 12) )\n    *(&buf + 13) = 0;\n  v2 = sub_80ABEAC(a2, \"R:+feq:+\", &buf + 10, &buf + 7);\n  if ( *(_DWORD *)(a2 + 4 * optind) )\n    *(&buf + 13) = *(_DWORD *)(a2 + 4 * optind);\n  if ( !*(&buf + 13) )\n    sub_804D5E0(\"non-root must specify config file\");\n  if ( (v2 & 2) != 0 )\n    sub_80B3CDB();\n  else\n    sub_80B3C0D();\n  if ( (v2 & 4) == 0 )\n  {\n    openlog(ident, 9, 24);\n    byte_80DB561 = 2;\n  }\n  if ( !*(&buf + 12) )\n  {\n    *(_DWORD *)&v27[40] = getgid();\n    setgroups(1u, (const __gid_t *)&v27[40]);\n  }\n  getrlimit64(7, &buf + 2);\n  *(_QWORD *)&buf = *((_QWORD *)&buf + 1);\n  if ( *((_QWORD *)&buf + 1) == -1LL )\n    *(_QWORD *)&buf = 64LL;\n  memset(v27, 0, 0x14u);\n  sigaddset((sigset_t *)&v27[12], 14);\n  sigaddset((sigset_t *)&v27[12], 17);\n  sigaddset((sigset_t *)&v27[12], 1);\n  *(_DWORD *)v27 = sub_805D126;\n  sub_804E698(14, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805D67B;\n  sub_804E698(1, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805CDB6;\n  sub_804E698(17, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805CD8B;\n  sub_804E698(15, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = sub_805CD8B;\n  sub_804E698(2, (const struct sigaction *)v27);\n  *(_DWORD *)v27 = 1;\n  sigaction(13, (const struct sigaction *)v27, (struct sigaction *)&v27[20]);\n  sub_805D67B();\n  while ( 1 )\n  {\nLABEL_17:\n    if ( (*(&buf + 8) & 0x80000000) != 0 )\n    {\n      *(&buf + 8) = 0;\n      v4 = *(&buf + 9);\n      for ( i = 0; (int)i <= v4; ++i )\n      {\n        if ( _bittest((const signed __int32 *)&buf + (i >> 5) + 50, i & 0x1F) )\n          *(&buf + 8) = i;\n      }\n      v6 = *(&buf + 8);\n      *(&buf + 9) = v6;\n      if ( v6 > (unsigned __int64)(*(_QWORD *)&buf - 8LL) )\n        sub_805CC86();\n    }\n    qmemcpy(&v27[40], dword_80DB840, 0x80u);\n    v3 = select(*(&buf + 8) + 1, (fd_set *)&v27[40], 0, 0, 0);\n    if ( v3 >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 4 )\n    {\n      sub_804D3A5((int)\"select\");\n      sleep(1u);\n    }\n  }\n  v19 = *(&buf + 6);\n  v24 = v3;\n  while ( 1 )\n  {\n    if ( !v19 || !v24 )\n      goto LABEL_17;\n    v7 = *(_DWORD *)v19;\n    if ( *(_DWORD *)v19 != -1 && _bittest((const signed __int32 *)&v27[4 * (v7 >> 5) + 40], *(_DWORD *)v19 & 0x1F) )\n    {\n      --v24;\n      v21 = *(_DWORD *)v19;\n      v22 = -1;\n      fd = -1;\n      if ( *(_DWORD *)(v19 + 16) )\n        goto LABEL_45;\n      if ( *(_BYTE *)(v19 + 20) != 1 || (v22 = accept(v7, 0, 0), v21 = v22, v22 >= 0) )\n      {\n        if ( *(_BYTE *)(v19 + 20) == 2 )\n        {\n          v8 = *(char *)(v19 + 21);\n          if ( (_BYTE)v8 != 1 )\n          {\n            fd = socket(v8, 2, 0);\n            if ( fd < 0 )\n              goto LABEL_42;\n            sub_80B4262();\n            if ( bind(fd, (const struct sockaddr *)(*(_DWORD *)(v19 + 52) + 4), **(_DWORD **)(v19 + 52)) < 0 )\n            {\n              close(fd);\nLABEL_42:\n              recv(*(_DWORD *)v19, &stru_80DB894.c_cc[27], 0x2B8u, 64);\n              goto LABEL_108;\n            }\n          }\n        }\nLABEL_45:\n        sub_805D030((sigset_t *)v26);\n        v9 = *(_DWORD *)(v19 + 44);\n        if ( !v9 || (v10 = 0, *(_BYTE *)(v19 + 20) == 1) && *(_BYTE *)(v9 + 7) )\n        {\n          v11 = *(_DWORD *)(v19 + 24);\n          if ( !v11 )\n            goto LABEL_55;\n          v25 = *(_DWORD *)(v19 + 28);\n          *(_DWORD *)(v19 + 28) = v25 + 1;\n          if ( !v25 )\n          {\n            *(_DWORD *)(v19 + 32) = sub_804EC4A();\n            goto LABEL_55;\n          }\n          if ( v11 <= v25 + 1 )\n          {\n            if ( (unsigned int)(sub_804EC4A() - *(_DWORD *)(v19 + 32)) <= 0x3C )\n            {\n              sub_804D5F4(\"%s/%s: too many connections, pausing\", *(const char **)(v19 + 8), *(const char **)(v19 + 12));\n              sub_805CBCA(*(_DWORD *)v19);\n              close(*(_DWORD *)v19);\n              *(_DWORD *)v19 = -1;\n              *(_DWORD *)(v19 + 28) = 0;\n              sub_805D074();\n              goto LABEL_60;\n            }\n            *(_DWORD *)(v19 + 28) = 0;\n          }\nLABEL_55:\n          if ( *(_DWORD *)(v19 + 44) )\n            v12 = fork();\n          else\n            v12 = vfork();\n          if ( v12 < 0 )\n          {\n            sub_804D3A5((int)\"fork\");\n            sleep(1u);\nLABEL_60:\n            sub_805D066((const sigset_t *)v26);\n            sub_805CC26(fd);\nLABEL_61:\n            sub_805CC26(v22);\n            goto LABEL_108;\n          }\n          v10 = -1;\n          if ( v12 )\n          {\n            if ( *(_DWORD *)(v19 + 16) )\n            {\n              *(_DWORD *)(v19 + 16) = v12;\n              sub_805CBCA(*(_DWORD *)v19);\n            }\n            if ( fd >= 0 )\n              sub_804DC97(fd, *(_DWORD *)v19);\n            sub_805D066((const sigset_t *)v26);\n            goto LABEL_61;\n          }\n        }\n        if ( !*(_DWORD *)(v19 + 44) )\n        {\n          setsid();\n          if ( fd >= 0 )\n          {\n            close(fd);\n            v15 = sub_805D004(*(char *)(v19 + 21));\n            if ( recvfrom(v21, 0, 0, 66, (struct sockaddr *)(v15 + 2), (socklen_t *)v15) >= 0 )\n            {\n              connect(v21, (const struct sockaddr *)(v15 + 2), *(_DWORD *)v15);\n              free(v15);\n              goto LABEL_77;\n            }\n          }\n          else\n          {\nLABEL_77:\n            v14 = getpwnam(*(const char **)(v19 + 36));\n            if ( v14 )\n            {\n              if ( !*(_DWORD *)(v19 + 40) || (v23 = getgrnam(*(const char **)(v19 + 40))) != 0 )\n              {\n                pw_uid = v14->pw_uid;\n                if ( !*(&buf + 12) || *(&buf + 12) == pw_uid )\n                {\n                  v17 = *(_DWORD *)(v19 + 40);\n                  if ( *(&buf + 12) == pw_uid )\n                  {\n                    if ( v17 )\n                    {\n                      sub_804DE5E(v23->gr_gid);\n                      setgroups(1u, &v23->gr_gid);\n                    }\n                  }\n                  else\n                  {\n                    if ( v17 )\n                      v14->pw_gid = v23->gr_gid;\n                    sub_80A9B93();\n                  }\n                  if ( *((_QWORD *)&buf + 1) != *(_QWORD *)&buf && setrlimit64(7, &buf + 2) < 0 )\n                    sub_804D3A5((int)\"setrlimit\");\n                  sub_804DC97(v21, 0);\n                  sub_804DC7B(0, 1);\n                  if ( !*(_DWORD *)(v19 + 16) )\n                    sub_804DC7B(0, 2);\n                  for ( j = (int *)*(&buf + 6); j; j = (int *)j[12] )\n                  {\n                    if ( *j != v21 )\n                      sub_805CC26(*j);\n                  }\n                  sub_804E698(13, (const struct sigaction *)&v27[20]);\n                  sub_805D066((const sigset_t *)v26);\n                  execvp(*(const char **)(v19 + 56), (char *const *)(v19 + 60));\n                  sub_804D3A5((int)\"can't execute '%s'\", *(const char **)(v19 + 56));\n                }\n                else\n                {\n                  sub_804D5F4(\"non-root must run services as himself\");\n                }\n              }\n              else\n              {\n                sub_804D5F4(\"%s: no such %s\", *(const char **)(v19 + 40), \"group\");\n              }\n            }\n            else\n            {\n              sub_804D5F4(\"%s: no such %s\", *(const char **)(v19 + 36), \"user\");\n            }\n          }\n          if ( *(_BYTE *)(v19 + 20) != 1 )\n            recv(0, &stru_80DB894.c_cc[27], 0x2B8u, 64);\nLABEL_81:\n          _exit(1);\n        }\n        if ( v10 )\n        {\n          close(*(_DWORD *)v19);\n          byte_80DB561 = 0;\n        }\n        sub_805D066((const sigset_t *)v26);\n        v13 = *(_DWORD *)(v19 + 44);\n        if ( *(_BYTE *)(v19 + 20) == 1 )\n          (*(void (__fastcall **)(int, int))(v13 + 8))(v13, v19);\n        else\n          (*(void (__fastcall **)(int, int))(v13 + 12))(v13, v19);\n        if ( v10 )\n          goto LABEL_81;\n        goto LABEL_61;\n      }\n      if ( *(_DWORD *)dword_80DBB7C != 4 )\n        sub_804D3A5((int)\"accept (for %s)\", *(const char **)(v19 + 8));\n    }\nLABEL_108:\n    v19 = *(_DWORD *)(v19 + 48);\n  }\n}\n"
        ],
        "134603064": [
            "sub_805E138",
            "0x805e138",
            "int __usercall sub_805E138@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  char *v3; // edi\n  int i; // ebx\n\n  sub_804DAFA(0x31u);\n  v2 = sub_80A9707();\n  v3 = (char *)v2;\n  for ( i = 0; i != 16; ++i )\n  {\n    sprintf(v3, \"%02X-\", *(unsigned __int8 *)(a1 + i));\n    v3 += 3;\n  }\n  *(_BYTE *)(v2 + 47) = 0;\n  return v2;\n}\n"
        ],
        "134603131": [
            "sub_805E17B",
            "0x805e17b",
            "const char *__usercall sub_805E17B@<eax>(_WORD *a1@<eax>)\n{\n  if ( (unsigned __int16)(*a1 - 1) > 0xFFFDu )\n    return \"[NONE SET]\";\n  else\n    return (const char *)sub_805E138((int)(a1 + 1));\n}\n"
        ],
        "134603162": [
            "sub_805E19A",
            "0x805e19a",
            "const char *__usercall sub_805E19A@<eax>(_WORD *a1@<eax>)\n{\n  if ( (unsigned __int16)(*a1 - 1) > 0xFFFDu )\n    return \"[NONE SET]\";\n  sub_80AD6B6();\n  return (const char *)sub_80A9707();\n}\n"
        ],
        "134603273": [
            "sub_805E209",
            "0x805e209",
            "char *__usercall sub_805E209@<eax>(char **a1@<eax>, const char *a2@<edx>)\n{\n  char *i; // ebx\n  int v5; // eax\n  char *v6; // esi\n  char **v7; // eax\n  char *v8; // edx\n\n  for ( i = a1[1]; i; i = (char *)*((_DWORD *)i + 1) )\n  {\n    v5 = strcmp(i + 8, a2);\n    if ( !v5 )\n      return i;\n    if ( v5 < 0 )\n      break;\n  }\n  v6 = (char *)sub_804DB2E(0x108u);\n  sub_804D67E(v6 + 8, a2);\n  v7 = a1;\n  if ( i )\n    v7 = (char **)i;\n  *((_DWORD *)v6 + 1) = i;\n  v8 = *v7;\n  *(_DWORD *)v6 = *v7;\n  if ( v8 )\n    *((_DWORD *)v8 + 1) = v6;\n  else\n    a1[1] = v6;\n  *v7 = v6;\n  return v6;\n}\n"
        ],
        "134603371": [
            "sub_805E26B",
            "0x805e26b",
            "int __usercall sub_805E26B@<eax>(char **a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // eax\n  int v4; // ebx\n  unsigned int v5; // edx\n  char v6; // al\n  char *v7; // ebp\n  char *v8; // ebx\n  int v9; // edx\n  int v10; // ecx\n  char *v11; // esi\n  FILE *stream; // [esp+0h] [ebp-230h]\n  int v14; // [esp+4h] [ebp-22Ch]\n  char s2[16]; // [esp+10h] [ebp-220h] BYREF\n  char haystack[528]; // [esp+20h] [ebp-210h] BYREF\n\n  v3 = sub_80B3D18(a3, \"r\");\n  stream = (FILE *)v3;\n  v4 = 0;\n  if ( v3 )\n  {\n    fgets_unlocked(haystack, 512, v3);\n    fgets_unlocked(haystack, 512, stream);\n    v14 = 2;\n    if ( !strstr(haystack, \"compressed\") )\n      v14 = strstr(haystack, \"bytes\") != 0;\n    while ( fgets_unlocked(haystack, 512, stream) )\n    {\n      v11 = (char *)sub_80B2E8C(v10, v9);\n      v7 = v11;\n      do\n      {\n        v5 = v7 - v11;\n        if ( v7 - v11 > 15 )\n          break;\n        v6 = *v7++;\n        if ( v6 == 58 )\n        {\n          qmemcpy(s2, v11, v5);\n          s2[v5] = 0;\n          goto LABEL_8;\n        }\n      }\n      while ( (unsigned __int8)*v7 > 0x20u );\n      s2[0] = 0;\n      v7 = haystack;\nLABEL_8:\n      v8 = sub_805E209(a1, s2);\n      memset(v8 + 156, 0, 0x6Cu);\n      sscanf(\n        v7,\n        (&off_80B78BC)[v14],\n        v8 + 172,\n        v8 + 156,\n        v8 + 188,\n        v8 + 196,\n        v8 + 236,\n        v8 + 232,\n        v8 + 208,\n        v8 + 204,\n        v8 + 180,\n        v8 + 164,\n        v8 + 192,\n        v8 + 200,\n        v8 + 252,\n        v8 + 216,\n        v8 + 248,\n        v8 + 212);\n      if ( v14 != 2 )\n      {\n        if ( !v14 )\n        {\n          *((_DWORD *)v8 + 43) = 0;\n          *((_DWORD *)v8 + 44) = 0;\n          *((_DWORD *)v8 + 45) = 0;\n          *((_DWORD *)v8 + 46) = 0;\n        }\n        *((_DWORD *)v8 + 51) = 0;\n        *((_DWORD *)v8 + 52) = 0;\n        *((_DWORD *)v8 + 53) = 0;\n      }\n      v8[153] = 1;\n      if ( a2 && !strcmp(a2, s2) )\n      {\n        v4 = 1;\n        goto LABEL_19;\n      }\n    }\n    v4 = 0;\nLABEL_19:\n    fclose(stream);\n  }\n  return v4;\n}\n"
        ],
        "134603933": [
            "sub_805E49D",
            "0x805e49d",
            "int __usercall sub_805E49D@<eax>(int a1@<eax>)\n{\n  int v2; // ebp\n  char *v3; // eax\n  int v4; // edx\n  const char *v6; // [esp+0h] [ebp-34h]\n  char v7[16]; // [esp+4h] [ebp-30h] BYREF\n  int v8[4]; // [esp+14h] [ebp-20h] BYREF\n\n  v6 = (const char *)(a1 + 8);\n  v2 = sub_804DF99(0, 2, 2);\n  sub_804D67E(v7, (const char *)(a1 + 8));\n  if ( ioctl(v2, 0x8913u, v7) >= 0 )\n  {\n    *(_WORD *)(a1 + 26) = v8[0];\n    *(_DWORD *)(a1 + 28) = -1;\n    memset((void *)(a1 + 32), 0, 0x78u);\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x8927u, v7) >= 0 )\n    {\n      v4 = *(int *)((char *)&v8[1] + 2);\n      *(_DWORD *)(a1 + 120) = *(int *)((char *)v8 + 2);\n      *(_DWORD *)(a1 + 124) = v4;\n    }\n    *(_WORD *)(a1 + 24) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x891Du, v7) >= 0 )\n      *(_DWORD *)(a1 + 32) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x8921u, v7) >= 0 )\n      *(_DWORD *)(a1 + 36) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( !ioctl(v2, 0x8970u, v7) )\n      qmemcpy((void *)(a1 + 40), v8, 0x10u);\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    if ( ioctl(v2, 0x8942u, v7) >= 0 )\n      *(_DWORD *)(a1 + 28) = v8[0];\n    sub_804D67E(v7, (const char *)(a1 + 8));\n    LOWORD(v8[0]) = 2;\n    if ( !ioctl(v2, 0x8915u, v7) )\n    {\n      *(_BYTE *)(a1 + 152) = 1;\n      qmemcpy((void *)(a1 + 56), v8, 0x10u);\n      sub_804D67E(v7, (const char *)(a1 + 8));\n      if ( ioctl(v2, 0x8917u, v7) >= 0 )\n        qmemcpy((void *)(a1 + 72), v8, 0x10u);\n      sub_804D67E(v7, (const char *)(a1 + 8));\n      if ( ioctl(v2, 0x8919u, v7) >= 0 )\n        qmemcpy((void *)(a1 + 88), v8, 0x10u);\n      sub_804D67E(v7, (const char *)(a1 + 8));\n      if ( ioctl(v2, 0x891Bu, v7) >= 0 )\n        qmemcpy((void *)(a1 + 104), v8, 0x10u);\n    }\n    close(v2);\n    return 0;\n  }\n  else\n  {\n    close(v2);\n    v3 = \"Device not found\";\n    if ( *(_DWORD *)dword_80DBB7C != 19 )\n      v3 = strerror(*(_DWORD *)dword_80DBB7C);\n    sub_804D5F4(\"%s: error fetching interface information: %s\", v6, v3);\n    return -1;\n  }\n}\n"
        ],
        "134604557": [
            "sub_805E70D",
            "0x805e70d",
            "int __usercall sub_805E70D@<eax>(__int64 a1@<edx:eax>, const char *a2@<ecx>)\n{\n  unsigned int v2; // edi\n  unsigned int v3; // esi\n  unsigned int v4; // ebx\n  const char *v5; // ebp\n  int v7; // [esp+0h] [ebp-14h]\n\n  v2 = HIDWORD(a1);\n  v3 = a1;\n  v7 = 4;\n  v4 = 0;\n  v5 = (const char *)&unk_80CCE7B;\n  do\n  {\n    if ( v2 || v3 > 0x3FF )\n    {\n      v4 = (10 * (v3 & 0x3FF)) >> 10;\n      v3 = __PAIR64__(v2, v3) >> 10;\n      v2 >>= 10;\n      v5 += 3;\n    }\n    --v7;\n  }\n  while ( v7 );\n  return printf(\"X bytes:%llu (%llu.%u %sB)%s\", a1, __PAIR64__(v2, v3), v4, v5, a2);\n}\n"
        ],
        "134604647": [
            "sub_805E767",
            "0x805e767",
            "int __usercall sub_805E767@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  *(_WORD *)a2 = 32;\n  sub_804D76F((_BYTE *)(a2 + 2), a1, 20);\n  return 0;\n}\n"
        ],
        "134604674": [
            "sub_805E782",
            "0x805e782",
            "const char **__usercall sub_805E782@<eax>(const char *a1@<eax>)\n{\n  const char ***i; // esi\n  const char **v3; // ebx\n\n  for ( i = (const char ***)off_80B78C8; ; ++i )\n  {\n    v3 = *i;\n    if ( !*i || !strcmp(*v3, a1) )\n      break;\n  }\n  return v3;\n}\n"
        ],
        "134604715": [
            "sub_805E7AB",
            "0x805e7ab",
            "const char **__usercall sub_805E7AB@<eax>(const char *a1@<eax>)\n{\n  const char ***i; // esi\n  const char **v3; // ebx\n\n  for ( i = (const char ***)off_80B78A0; ; ++i )\n  {\n    v3 = *i;\n    if ( !*i || !strcmp(*v3, a1) )\n      break;\n  }\n  return v3;\n}\n"
        ],
        "134604756": [
            "sub_805E7D4",
            "0x805e7d4",
            "char **__usercall sub_805E7D4@<eax>(char *a1@<eax>)\n{\n  char ***i; // ecx\n\n  for ( i = off_80B78A0; *i && (*i)[2] != a1; ++i )\n    ;\n  return *i;\n}\n"
        ],
        "134604780": [
            "sub_805E7EC",
            "0x805e7ec",
            "int __usercall sub_805E7EC@<eax>(int a1@<eax>)\n{\n  char *v2; // edx\n  char ***i; // eax\n  char **v4; // esi\n  char ***j; // eax\n  char **v6; // edi\n  int (*v7)(void); // ecx\n  int k; // edx\n  const char *v9; // eax\n  const char *v10; // eax\n  const char *v11; // eax\n  int (*v12)(void); // ecx\n  const char *v13; // eax\n  const char *v14; // eax\n  int v15; // edi\n  const char *v16; // eax\n  unsigned int v17; // eax\n  const char *v18; // esi\n  unsigned __int16 *v19; // edi\n  int v20; // eax\n  int v21; // eax\n  int v22; // eax\n  FILE *stream; // [esp+0h] [ebp-B4h]\n  __int16 v25; // [esp+Ah] [ebp-AAh]\n  int v26; // [esp+10h] [ebp-A4h] BYREF\n  int v27; // [esp+14h] [ebp-A0h] BYREF\n  char v28; // [esp+18h] [ebp-9Ch] BYREF\n  char v29; // [esp+1Ch] [ebp-98h] BYREF\n  char v30[21]; // [esp+23h] [ebp-91h] BYREF\n  __int16 v31[14]; // [esp+38h] [ebp-7Ch] BYREF\n  char s[40]; // [esp+54h] [ebp-60h] BYREF\n  char v33[5]; // [esp+7Ch] [ebp-38h] BYREF\n  char v34[5]; // [esp+81h] [ebp-33h] BYREF\n  char v35[5]; // [esp+86h] [ebp-2Eh] BYREF\n  char v36[5]; // [esp+8Bh] [ebp-29h] BYREF\n  char v37[5]; // [esp+90h] [ebp-24h] BYREF\n  char v38[5]; // [esp+95h] [ebp-1Fh] BYREF\n  char v39[5]; // [esp+9Ah] [ebp-1Ah] BYREF\n  char v40[21]; // [esp+9Fh] [ebp-15h] BYREF\n\n  v2 = (char *)*(unsigned __int16 *)(a1 + 56);\n  for ( i = off_80B78C8; ; ++i )\n  {\n    v4 = *i;\n    if ( !*i )\n      break;\n    if ( v2 == v4[2] )\n      goto LABEL_9;\n  }\n  for ( j = off_80B78C8; ; ++j )\n  {\n    v4 = *j;\n    if ( !*j || !v4[2] )\n      break;\n  }\nLABEL_9:\n  v25 = *(_WORD *)(a1 + 24) & 0xFFFD;\n  v6 = sub_805E7D4((char *)*(__int16 *)(a1 + 24));\n  if ( !v6 )\n    v6 = sub_805E7D4((char *)0xFFFFFFFF);\n  printf(\"%-9s Link encap:%s  \", (const char *)(a1 + 8), v6[1]);\n  v7 = (int (*)(void))v6[4];\n  if ( v7 )\n  {\n    for ( k = 0; (int)v6[3] > k; ++k )\n    {\n      if ( *(_BYTE *)(a1 + 120 + k) )\n        goto LABEL_17;\n    }\n    if ( v6[7] )\n      goto LABEL_18;\nLABEL_17:\n    v9 = (const char *)v7();\n    printf(\"HWaddr %s  \", v9);\n  }\nLABEL_18:\n  if ( (*(_BYTE *)(a1 + 27) & 0x20) != 0 )\n  {\n    printf(\"Media:%s\", off_80B57E0[*(unsigned __int8 *)(a1 + 52)]);\n    if ( (*(_BYTE *)(a1 + 27) & 0x40) != 0 )\n      printf(\"(auto)\");\n  }\n  sub_804DD98(10);\n  if ( *(_BYTE *)(a1 + 152) )\n  {\n    v10 = (const char *)((int (*)(void))v4[5])();\n    printf(\"          %s addr:%s \", *v4, v10);\n    if ( (*(_BYTE *)(a1 + 26) & 0x10) != 0 )\n    {\n      v11 = (const char *)((int (*)(void))v4[5])();\n      printf(\" P-t-P:%s \", v11);\n    }\n    v12 = (int (*)(void))v4[5];\n    if ( (*(_BYTE *)(a1 + 26) & 2) != 0 )\n    {\n      v13 = (const char *)v12();\n      printf(\" Bcast:%s \", v13);\n    }\n    v14 = (const char *)((int (__fastcall *)(int (*)(void), int))v4[5])(v12, 1);\n    printf(\" Mask:%s\\n\", v14);\n  }\n  stream = (FILE *)sub_80B3D37();\n  if ( stream )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          do\n          {\n            if ( fscanf(\n                   stream,\n                   \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                   v33,\n                   v34,\n                   v35,\n                   v36,\n                   v37,\n                   v38,\n                   v39,\n                   v40,\n                   &v29,\n                   &v26,\n                   &v27,\n                   &v28,\n                   v30) == -1 )\n            {\n              fclose(stream);\n              goto LABEL_43;\n            }\n          }\n          while ( strcmp(v30, (const char *)(a1 + 8)) );\n          sprintf(s, \"%s:%s:%s:%s:%s:%s:%s:%s\", v33, v34, v35, v36, v37, v38, v39, v40);\n          memset(v31, 0, sizeof(v31));\n          inet_pton(10, s, &v31[4]);\n          v31[0] = 10;\n          v15 = v26;\n          v16 = sub_805E19A(v31);\n          printf(\"          inet6 addr: %s/%d\", v16, v15);\n          printf(\" Scope:\");\n          v17 = v27 & 0xF0;\n          if ( v17 != 32 )\n            break;\n          puts(\"Link\");\n        }\n        if ( v17 <= 0x20 )\n          break;\n        if ( v17 == 64 )\n        {\n          puts(\"Site\");\n        }\n        else if ( v17 == 128 )\n        {\n          puts(\"Compat\");\n        }\n        else\n        {\nLABEL_41:\n          puts(\"Unknown\");\n        }\n      }\n      if ( (v27 & 0xF0) != 0 )\n      {\n        if ( v17 != 16 )\n          goto LABEL_41;\n        puts(\"Host\");\n      }\n      else\n      {\n        puts(\"Global\");\n      }\n    }\n  }\nLABEL_43:\n  printf(\"          \");\n  if ( *(_WORD *)(a1 + 26) )\n  {\n    v18 = \"UP\";\n    v19 = (unsigned __int16 *)&unk_80B851E;\n    do\n    {\n      if ( (*v19 & *(__int16 *)(a1 + 26)) != 0 )\n        printf(\"%s \", v18);\n      ++v19;\n      v18 += strlen(v18) + 1;\n    }\n    while ( *v18 );\n  }\n  else\n  {\n    printf(\"[NO FLAGS] \");\n  }\n  v20 = *(_DWORD *)(a1 + 32);\n  if ( !v20 )\n    v20 = 1;\n  printf(\" MTU:%d  Metric:%d\", *(_DWORD *)(a1 + 36), v20);\n  sub_804DD98(10);\n  if ( *(_BYTE *)(a1 + 153) )\n  {\n    printf(\"          \");\n    printf(\n      \"RX packets:%llu errors:%lu dropped:%lu overruns:%lu frame:%lu\\n\",\n      *(_QWORD *)(a1 + 156),\n      *(_DWORD *)(a1 + 188),\n      *(_DWORD *)(a1 + 196),\n      *(_DWORD *)(a1 + 236),\n      *(_DWORD *)(a1 + 232));\n    if ( v25 == 257 )\n      printf(\"             compressed:%lu\\n\", *(_DWORD *)(a1 + 208));\n    printf(\"          \");\n    printf(\n      \"TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\\n\",\n      *(_QWORD *)(a1 + 164),\n      *(_DWORD *)(a1 + 192),\n      *(_DWORD *)(a1 + 200),\n      *(_DWORD *)(a1 + 252),\n      *(_DWORD *)(a1 + 248));\n    printf(\"          collisions:%lu \", *(_DWORD *)(a1 + 216));\n    if ( v25 == 257 )\n      printf(\"compressed:%lu \", *(_DWORD *)(a1 + 212));\n    if ( *(_DWORD *)(a1 + 28) != -1 )\n      printf(\"txqueuelen:%d \", *(_DWORD *)(a1 + 28));\n    printf(\"\\n          R\");\n    sub_805E70D(*(_QWORD *)(a1 + 172), \"  T\");\n    sub_805E70D(*(_QWORD *)(a1 + 180), \"\\n\");\n  }\n  if ( *(_BYTE *)(a1 + 50) || *(_DWORD *)(a1 + 40) || (*(_DWORD *)(a1 + 48) & 0xFF00FFFF) != 0 )\n  {\n    printf(\"          \");\n    v21 = *(unsigned __int8 *)(a1 + 50);\n    if ( (_BYTE)v21 )\n      printf(\"Interrupt:%d \", v21);\n    if ( *(_WORD *)(a1 + 48) > 0xFFu )\n      printf(\"Base address:0x%lx \", *(unsigned __int16 *)(a1 + 48));\n    v22 = *(_DWORD *)(a1 + 40);\n    if ( v22 )\n      printf(\"Memory:%lx-%lx \", v22, *(_DWORD *)(a1 + 44));\n    if ( *(_BYTE *)(a1 + 51) )\n      printf(\"DMA chan:%x \", *(unsigned __int8 *)(a1 + 51));\n    sub_804DD98(10);\n  }\n  return sub_804DD98(10);\n}\n"
        ],
        "134606084": [
            "sub_805ED04",
            "0x805ed04",
            "unsigned int __usercall sub_805ED04@<eax>(const char *a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // edx\n  int v4; // esi\n  int v5; // ebp\n  size_t v6; // edi\n  const char *v7; // edi\n  char *i; // edi\n  int v9; // esi\n  char *v11; // ebx\n  size_t v12; // [esp+0h] [ebp-24h]\n  char *v13[2]; // [esp+4h] [ebp-20h] BYREF\n  int v14; // [esp+Ch] [ebp-18h] BYREF\n  void *ptr; // [esp+10h] [ebp-14h]\n\n  v13[0] = 0;\n  v13[1] = 0;\n  v3 = 0;\n  if ( a1 != (const char *)1 )\n    v3 = a1;\n  v4 = sub_805E26B(v13, v3, a2);\n  if ( !v4 )\n  {\n    ptr = 0;\n    v5 = sub_804DF99(0, 2, 2);\n    v6 = 960;\n    do\n    {\n      v12 = v6;\n      v14 = v6;\n      ptr = sub_804DB13(ptr, v6);\n      sub_804E0BE(v5, 0x8912u, (int)&v14, \"SIOCGIFCONF\");\n      v6 += 320;\n    }\n    while ( v12 == v14 );\n    v7 = (const char *)ptr;\n    while ( v4 < v14 )\n    {\n      sub_805E209(v13, &v7[v4]);\n      v4 += 32;\n    }\n    close(v5);\n    free(ptr);\n  }\n  if ( (unsigned int)a1 > 1 )\n  {\n    v11 = sub_805E209(v13, a1);\n    v9 = sub_805E49D((int)v11);\n    if ( v9 >= 0 )\n      sub_805E7EC((int)v11);\n    return (unsigned int)v9 >> 31;\n  }\n  else\n  {\n    for ( i = v13[0]; i; i = *(char **)i )\n    {\n      v9 = sub_805E49D((int)i);\n      if ( v9 < 0 )\n        return (unsigned int)v9 >> 31;\n      if ( (i[26] & 1) != 0 || a1 )\n        sub_805E7EC((int)i);\n    }\n    return 0;\n  }\n}\n"
        ],
        "134606391": [
            "sub_805EE37",
            "0x805ee37",
            "int __cdecl sub_805EE37(int a1, int a2)\n{\n  sub_8064315();\n  return sub_80653F1();\n}\n"
        ],
        "134606405": [
            "sub_805EE45",
            "0x805ee45",
            "int __cdecl sub_805EE45(int a1, int a2)\n{\n  sub_8064315();\n  return sub_80659A2();\n}\n"
        ],
        "134606419": [
            "sub_805EE53",
            "0x805ee53",
            "int __cdecl sub_805EE53(int a1, int a2)\n{\n  sub_8064315();\n  return sub_806780A();\n}\n"
        ],
        "134606433": [
            "sub_805EE61",
            "0x805ee61",
            "int __cdecl sub_805EE61(int a1, int a2)\n{\n  sub_8064315();\n  return sub_8067E6D();\n}\n"
        ],
        "134606447": [
            "sub_805EE6F",
            "0x805ee6f",
            "int __cdecl sub_805EE6F(int a1, int a2)\n{\n  sub_8064315();\n  return sub_8068949();\n}\n"
        ],
        "134606461": [
            "sub_805EE7D",
            "0x805ee7d",
            "int __cdecl sub_805EE7D(int a1, int a2)\n{\n  sub_8064315();\n  return sub_80664E9();\n}\n"
        ],
        "134606475": [
            "sub_805EE8B",
            "0x805ee8b",
            "int __cdecl sub_805EE8B(int a1, int a2)\n{\n  const char *v2; // edx\n  int v3; // eax\n\n  v2 = *(const char **)sub_8064315();\n  v3 = -1;\n  if ( v2 )\n    v3 = sub_804D254(\"address\", v2);\n  return funcs_805EEBA[v3]();\n}\n"
        ],
        "134606524": [
            "sub_805EEBC",
            "0x805eebc",
            "int __usercall sub_805EEBC@<eax>(int *a1@<eax>, const char *a2@<edx>)\n{\n  _DWORD *v4; // edi\n  int v5; // edx\n  int v6; // ecx\n  _BYTE *v7; // ebx\n  struct ether_addr *v8; // ebp\n  _BYTE *v9; // eax\n  struct ether_addr *v10; // eax\n  int result; // eax\n\n  if ( strlen(a2) > 0xF )\n    sub_804D5E0(\"interface name '%s' too long\", a2);\n  v4 = sub_804DB2E(0x10u);\n  v4[2] = sub_804DB46(a2);\n  v7 = (_BYTE *)sub_80B2E8C(v6, v5);\n  v8 = (struct ether_addr *)sub_804DAFA(6u);\n  v9 = sub_804D210(v7, \"mac=\");\n  v10 = ether_aton_r(&v7[v9 != 0 ? 4 : 0], v8);\n  v4[3] = v10;\n  if ( !v10 )\n    sub_804D5E0(\"can't parse %s\", v7);\n  result = *a1;\n  *v4 = *a1;\n  if ( result )\n    *(_DWORD *)(result + 4) = v4;\n  *a1 = (int)v4;\n  return result;\n}\n"
        ],
        "134606666": [
            "sub_805EF4A",
            "0x805ef4a",
            "int __cdecl sub_805EF4A(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // ebp\n  int v4; // ecx\n  int v5; // esi\n  _DWORD *v6; // edi\n  char *v7; // edx\n  const void *v8; // eax\n  int v9; // eax\n  _DWORD *v10; // eax\n  char *srca; // [esp+0h] [ebp-44h]\n  char *src; // [esp+0h] [ebp-44h]\n  _DWORD *v14; // [esp+4h] [ebp-40h] BYREF\n  const char *v15; // [esp+8h] [ebp-3Ch] BYREF\n  const char *v16; // [esp+Ch] [ebp-38h]\n  char s1[48]; // [esp+14h] [ebp-30h] BYREF\n\n  v14 = 0;\n  v15 = \"/etc/mactab\";\n  if ( (sub_80ABEAC(a2, \"sc:\", &v15) & 1) != 0 )\n  {\n    openlog(ident, 0, 128);\n    byte_80DB561 |= 2u;\n  }\n  v2 = a2 + 4 * optind;\n  if ( *(_DWORD *)v2 )\n  {\n    do\n    {\n      if ( !*(_DWORD *)(v2 + 4) )\n        sub_804CDC2();\n      sub_805EEBC((int *)&v14, *(const char **)v2);\n      v2 += 8;\n    }\n    while ( *(_DWORD *)v2 );\n  }\n  else\n  {\n    sub_80B052C();\n    while ( sub_80B0560(\"# \\t\") )\n      sub_805EEBC((int *)&v14, v16);\n    sub_80B0536();\n  }\n  v3 = sub_804DF99(0, 2, 2);\n  v5 = sub_80B0511(v4, sub_80B3D45);\nLABEL_13:\n  while ( v14 && sub_80B0560((char *)&byte_80CD033) )\n  {\n    if ( *(int *)(v5 + 24) > 2 )\n    {\n      memset(s1, 0, 0x20u);\n      sub_804D67E(s1, v16);\n      ioctl(v3, 0x8927u, s1);\n      v6 = v14;\n      v7 = &s1[18];\n      while ( v6 )\n      {\n        v8 = (const void *)v6[3];\n        if ( !v8 || (srca = v7, v9 = memcmp(v8, v7, 6u), v7 = srca, !v9) )\n        {\n          src = (char *)v6[2];\n          if ( strcmp(s1, src) )\n          {\n            strcpy(&s1[16], src);\n            sub_804E029(v3, 0x8923u, (int)s1, \"can't change ifname %s to %s\", s1, (const char *)v6[2]);\n          }\n          v10 = (_DWORD *)v6[1];\n          if ( v10 )\n            *v10 = *v6;\n          else\n            v14 = (_DWORD *)*v6;\n          if ( *v6 )\n            *(_DWORD *)(*v6 + 4) = v10;\n          goto LABEL_13;\n        }\n        v6 = (_DWORD *)*v6;\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134607124": [
            "sub_805F114",
            "0x805f114",
            "int __usercall sub_805F114@<eax>(const char *a1@<eax>)\n{\n  int v1; // eax\n  int v2; // edx\n  char v3; // al\n  bool v4; // zf\n  const char *v5; // ebp\n  int v6; // edi\n  const char *v7; // ebx\n  const char *v8; // ebx\n  const char *v10; // [esp+0h] [ebp-58h]\n  int v12; // [esp+8h] [ebp-50h]\n  int v13; // [esp+Ch] [ebp-4Ch] BYREF\n  int v14; // [esp+10h] [ebp-48h] BYREF\n  int v15; // [esp+14h] [ebp-44h] BYREF\n  int v16; // [esp+18h] [ebp-40h] BYREF\n  int v17; // [esp+1Ch] [ebp-3Ch] BYREF\n  int v18; // [esp+20h] [ebp-38h] BYREF\n  int v19; // [esp+24h] [ebp-34h] BYREF\n  char dest[48]; // [esp+28h] [ebp-30h] BYREF\n\n  if ( !*a1 )\n    return 0;\n  v19 = 0;\n  v1 = sscanf(a1, \"%*p: %lX %lX %lX %X %X %lu %n\", &v13, &v14, &v15, &v17, &v18, &v16, &v19);\n  v2 = 1;\n  if ( v1 > 5 )\n  {\n    v3 = *(_BYTE *)dword_80DBB80;\n    if ( (*(_BYTE *)dword_80DBB80 & 3) == 3\n      || (v18 != 1 || (v15 & 0x10000) == 0 ? (v4 = (v3 & 1) == 0) : (v4 = (v3 & 2) == 0), !v4) )\n    {\n      v10 = \"unix\";\n      if ( v14 )\n        v10 = \"??\";\n      v5 = \"UNKNOWN\";\n      if ( (unsigned int)(v17 - 1) <= 4 )\n        v5 = off_80B78EC[v17 - 1];\n      v6 = v15;\n      v7 = \"UNKNOWN\";\n      switch ( v18 )\n      {\n        case 0:\n          v7 = \"FREE\";\n          break;\n        case 1:\n          v7 = \"LISTENING\";\n          if ( (v15 & 0x10000) == 0 )\n            v7 = &data;\n          break;\n        case 2:\n          v7 = \"DISCONNECTING\" + 3;\n          break;\n        case 3:\n          v7 = \"CONNECTED\";\n          break;\n        case 4:\n          v7 = \"DISCONNECTING\";\n          break;\n        default:\n          break;\n      }\n      v12 = v15 & 0x10000;\n      strcpy(dest, \"[ \");\n      if ( v12 )\n        strcat(dest, \"ACC \");\n      if ( (v6 & 0x20000) != 0 )\n        strcat(dest, \"W \");\n      if ( (v6 & 0x40000) != 0 )\n        strcat(dest, \"N \");\n      strcat(dest, \"]\");\n      printf(\"%-5s %-6lu %-11s %-10s %-13s %6lu \", v10, v13, dest, v5, v7, v16);\n      v8 = &a1[v19];\n      sub_80A9BE3();\n      while ( *v8 )\n      {\n        ++v8;\n        sub_80B0B92();\n      }\n      sub_804DD98(10);\n    }\n    return 0;\n  }\n  return v2;\n}\n"
        ],
        "134607559": [
            "sub_805F2C7",
            "0x805f2c7",
            "int __usercall sub_805F2C7@<eax>(const char *a1@<eax>, _WORD *a2@<edx>)\n{\n  int result; // eax\n  char v4[18]; // [esp+0h] [ebp-4Ch] BYREF\n  char buf[58]; // [esp+12h] [ebp-3Ah] BYREF\n\n  sscanf(a1, \"%08X%08X%08X%08X\", v4, &v4[4], &v4[8], &v4[12]);\n  inet_ntop(10, v4, buf, 0x2Eu);\n  result = inet_pton(10, buf, a2 + 4);\n  *a2 = 10;\n  return result;\n}\n"
        ],
        "134607638": [
            "sub_805F316",
            "0x805f316",
            "char *__usercall sub_805F316@<eax>(char *proto@<ecx>, unsigned __int16 a2@<dx>, int a3@<ebx>, int a4)\n{\n  char *v6; // ebx\n  unsigned __int16 v7; // dx\n  const char *s_name; // eax\n  struct servent *v9; // eax\n  char *v11; // [esp+0h] [ebp-14h]\n\n  if ( a4 || (v6 = (char *)sub_80B46A2(a3)) == 0 )\n    v6 = (char *)sub_80B46B6();\n  LOBYTE(v7) = HIBYTE(a2);\n  HIBYTE(v7) = a2;\n  s_name = \"   *\" + 3;\n  if ( v7 )\n  {\n    if ( a4 || (v9 = getservbyport(v7, proto)) == 0 )\n      s_name = sub_804D70F(a2);\n    else\n      s_name = v9->s_name;\n  }\n  v11 = sub_804DDBF((char *)\"%s:%s\", v6, s_name);\n  free(v6);\n  return v11;\n}\n"
        ],
        "134607761": [
            "sub_805F391",
            "0x805f391",
            "void __usercall sub_805F391(_DWORD *a1@<eax>, const char *a2@<edx>, char *a3@<ecx>, void *ptr)\n{\n  char v4; // bp\n  bool v5; // zf\n  char *v9; // ebp\n  char *v10; // [esp+0h] [ebp-14h]\n\n  v4 = *(_BYTE *)dword_80DBB80;\n  if ( ptr )\n    v5 = (v4 & 1) == 0;\n  else\n    v5 = (v4 & 2) == 0;\n  if ( !v5 )\n  {\n    v9 = sub_805F316(a3, *a1, (int)a1, v4 & 4);\n    v10 = sub_805F316(a3, a1[1], (int)a1, *(_BYTE *)dword_80DBB80 & 4);\n    printf(\"%s   %6lu %6lu %-23s %-23s %-12s\", a3, a1[18], a1[19], v9, v10, a2);\n    sub_804DD98(10);\n    free(v9);\n    free(v10);\n  }\n}\n"
        ],
        "134607924": [
            "sub_805F434",
            "0x805f434",
            "int __fastcall sub_805F434(int a1, int a2)\n{\n  int v3; // [esp+0h] [ebp-14h]\n\n  if ( sub_80B3D76(a2) )\n    sub_80AB345();\n  return v3;\n}\n"
        ],
        "134608019": [
            "sub_805F493",
            "0x805f493",
            "int __usercall sub_805F493@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  char s[33]; // [esp+2h] [ebp-4Eh] BYREF\n  char v5[45]; // [esp+23h] [ebp-2Dh] BYREF\n\n  if ( sscanf(\n         a2,\n         \"%*d: %32[0-9A-Fa-f]:%X %32[0-9A-Fa-f]:%X %X %lX:%lX %*X:%*X %*X %d %*d %lu \",\n         s,\n         a1,\n         v5,\n         a1 + 4,\n         a1 + 8,\n         a1 + 76,\n         a1 + 72,\n         a1 + 12,\n         a1 + 80) <= 8 )\n    return 1;\n  if ( strlen(s) <= 8 )\n  {\n    sscanf(s, \"%X\", a1 + 20);\n    *(_WORD *)(a1 + 16) = 2;\n    sscanf(v5, \"%X\", a1 + 48);\n    *(_WORD *)(a1 + 44) = 2;\n  }\n  else\n  {\n    sub_805F2C7(s, (_WORD *)(a1 + 16));\n    sub_805F2C7(v5, (_WORD *)(a1 + 44));\n  }\n  return 0;\n}\n"
        ],
        "134608176": [
            "sub_805F530",
            "0x805f530",
            "int __usercall sub_805F530@<eax>(const char *a1@<eax>)\n{\n  int v1; // ebx\n  bool v2; // zf\n  _BOOL4 v3; // ecx\n  const char *v4; // eax\n  void *ptr; // [esp+0h] [ebp-5Ch]\n  _DWORD v7[11]; // [esp+4h] [ebp-58h] BYREF\n  int v8; // [esp+30h] [ebp-2Ch]\n  int v9; // [esp+34h] [ebp-28h]\n  int v10; // [esp+38h] [ebp-24h]\n  int v11; // [esp+3Ch] [ebp-20h]\n  int v12; // [esp+40h] [ebp-1Ch]\n  int v13; // [esp+44h] [ebp-18h]\n\n  v1 = 1;\n  if ( !sub_805F493((int)v7, a1) )\n  {\n    v1 = 0;\n    if ( (_WORD)v8 == 10 )\n    {\n      v2 = (v13 | v12 | v11 | v10) == 0;\n    }\n    else\n    {\n      v3 = 0;\n      if ( (_WORD)v8 != 2 )\n      {\nLABEL_7:\n        ptr = (void *)v3;\n        v4 = sub_804D70F(v7[2]);\n        sub_805F391(v7, v4, \"raw\", ptr);\n        return v1;\n      }\n      v2 = v9 == 0;\n    }\n    v3 = !v2;\n    goto LABEL_7;\n  }\n  return v1;\n}\n"
        ],
        "134608503": [
            "sub_805F677",
            "0x805f677",
            "int __cdecl sub_805F677(int a1, int a2)\n{\n  _BYTE *v2; // ebx\n  __int16 v3; // ax\n  int v4; // ecx\n  int v5; // eax\n  int v6; // ecx\n  int v7; // ecx\n  int v8; // ecx\n  int v9; // ecx\n  int v11; // [esp-4h] [ebp-8h]\n\n  v2 = sub_804DB2E(1u);\n  dword_80DBB80 = (int)v2;\n  *v2 = -15;\n  v3 = sub_80ABEAC(a2, \"laentuwxr\");\n  v4 = v11;\n  if ( (v3 & 1) != 0 )\n    *v2 = *v2 & 0xFC | 2;\n  if ( (v3 & 2) != 0 )\n    *v2 |= 3u;\n  if ( (v3 & 8) != 0 )\n    *v2 |= 4u;\n  LOBYTE(v4) = *v2;\n  if ( (v3 & 0x100) != 0 )\n  {\n    sub_8061007();\n  }\n  else\n  {\n    v5 = v3 & 0xF0;\n    if ( v5 )\n    {\n      v4 &= 0xFu;\n      *v2 = v4 | v5;\n    }\n    if ( (*v2 & 0x70) != 0 )\n    {\n      printf(\"Active Internet connections \");\n      if ( (*v2 & 3) == 3 )\n      {\n        printf(\"(servers and established)\");\n      }\n      else if ( (*v2 & 2) != 0 )\n      {\n        printf(\"(only servers)\");\n      }\n      else\n      {\n        printf(\"(w/o servers)\");\n      }\n      printf(\"\\nProto Recv-Q Send-Q %-23s %-23s State       %s\\n\", \"Local Address\", \"Foreign Address\", &data);\n    }\n    if ( (*v2 & 0x10) != 0 )\n    {\n      sub_805F434(v4, (int)sub_805F62B);\n      sub_805F434(v6, (int)sub_805F62B);\n    }\n    if ( (*v2 & 0x20) != 0 )\n    {\n      sub_805F434(v4, (int)sub_805F5A1);\n      sub_805F434(v7, (int)sub_805F5A1);\n    }\n    if ( (*v2 & 0x40) != 0 )\n    {\n      sub_805F434(v4, (int)sub_805F530);\n      sub_805F434(v8, (int)sub_805F530);\n    }\n    if ( (char)*v2 < 0 )\n    {\n      printf(\"Active UNIX domain sockets \");\n      if ( (*v2 & 3) == 3 )\n      {\n        printf(\"(servers and established)\");\n      }\n      else if ( (*v2 & 2) != 0 )\n      {\n        printf(\"(only servers)\");\n      }\n      else\n      {\n        printf(\"(w/o servers)\");\n      }\n      printf(\"\\nProto RefCnt Flags       Type       State         I-Node %sPath\\n\", &data);\n      sub_805F434(v9, (int)sub_805F114);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134608908": [
            "sub_805F80C",
            "0x805f80c",
            "int __usercall sub_805F80C@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  size_t v4; // ebx\n  size_t v5; // ebx\n  int result; // eax\n\n  v4 = (*(&buf + 3))++;\n  *(&buf + 6) = sub_80B4733(v4, 133121);\n  v5 = *(&buf + 6) + 520 * v4;\n  *(_DWORD *)v5 = a2;\n  result = __res_mkquery(0, a2, 1, a1, 0, 0, 0, (u_char *)(v5 + 8), 512);\n  *(_DWORD *)(v5 + 4) = result;\n  return result;\n}\n"
        ],
        "134608997": [
            "sub_805F865",
            "0x805f865",
            "int __usercall sub_805F865@<eax>(int a1@<eax>)\n{\n  size_t v2; // ebx\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  int result; // eax\n\n  v2 = (*(&buf + 4))++;\n  *(&buf + 5) = sub_80B4733(v2, 4099);\n  v3 = (_DWORD *)(*(&buf + 5) + 16 * v2);\n  *v3 = a1;\n  result = sub_80B45BD(v4, buf);\n  v3[1] = result;\n  return result;\n}\n"
        ],
        "134609063": [
            "sub_805F8A7",
            "0x805f8a7",
            "int __usercall sub_805F8A7@<eax>(const char **a1@<eax>)\n{\n  size_t i; // ebx\n  size_t v3; // eax\n  int v4; // esi\n  const char *v5; // eax\n  const char *v6; // eax\n  char *v7; // ebx\n  size_t v8; // edi\n  u_char *v9; // edx\n  int v10; // eax\n  unsigned __int8 v11; // bl\n  int v12; // eax\n  ns_rr *v13; // ebx\n  ns_rr *v14; // eax\n  u_int v15; // edi\n  u_char v16; // dl\n  const u_char *rdata; // ebx\n  int v18; // edi\n  const u_char *v19; // ebx\n  int v20; // edi\n  const u_char *v21; // ebx\n  u_long v22; // eax\n  u_long v23; // eax\n  u_long v24; // eax\n  u_long v25; // eax\n  u_long v26; // eax\n  int v28; // [esp+0h] [ebp-ABCh]\n  u_char *v29; // [esp+0h] [ebp-ABCh]\n  const char *v30; // [esp+4h] [ebp-AB8h]\n  int v31; // [esp+8h] [ebp-AB4h]\n  int v32; // [esp+Ch] [ebp-AB0h]\n  int v33; // [esp+10h] [ebp-AACh]\n  int v34; // [esp+14h] [ebp-AA8h]\n  int v35; // [esp+18h] [ebp-AA4h]\n  size_t v36; // [esp+1Ch] [ebp-AA0h]\n  size_t v37; // [esp+20h] [ebp-A9Ch]\n  size_t v38; // [esp+24h] [ebp-A98h]\n  char *ptr; // [esp+28h] [ebp-A94h]\n  struct pollfd fd; // [esp+2Ch] [ebp-A90h] BYREF\n  char v41[46]; // [esp+36h] [ebp-A86h] BYREF\n  ns_msg v42; // [esp+64h] [ebp-A58h] BYREF\n  u_char buf[3]; // [esp+97h] [ebp-A25h] BYREF\n  char v44; // [esp+9Ah] [ebp-A22h]\n  char v45[1025]; // [esp+297h] [ebp-825h] BYREF\n  ns_rr v46; // [esp+698h] [ebp-424h] BYREF\n\n  v37 = 1000 * *(&::buf + 2);\n  fd.events = 1;\n  fd.fd = sub_80B45D3(2);\n  sub_804DFB3(*(_DWORD *)ptr, (struct sockaddr *)(ptr + 4), fd.fd);\n  free(ptr);\n  sub_80B42C3(*(_DWORD *)a1[1], (struct sockaddr *)(a1[1] + 4));\n  sub_804D61C(fd.fd);\n  v38 = v37 / *(&::buf + 1);\n  v34 = sub_804EC14();\n  v31 = v34;\n  v33 = 0;\nLABEL_2:\n  for ( i = 0; ; ++i )\n  {\n    if ( *(&::buf + 3) <= i )\n    {\n      v36 = 2 * *(&::buf + 3);\n      v28 = v31;\n      while ( 1 )\n      {\n        if ( poll(&fd, 1u, v38 + v31 - v28) > 0 )\n        {\n          v4 = read(fd.fd, buf, 0x200u);\n          if ( v4 >= 0 )\n          {\n            v5 = a1[3];\n            a1[3] = v5 + 1;\n            if ( !v5 )\n            {\n              printf(\"Server:\\t\\t%s\\n\", *a1);\n              sub_80B46AC();\n              v6 = (const char *)sub_80A9707();\n              printf(\"Address:\\t%s\\n\\n\", v6);\n            }\n            if ( v4 > 3 )\n            {\n              v7 = (char *)(*(&::buf + 6) + 8);\n              v8 = 0;\n              v9 = buf;\n              while ( 1 )\n              {\n                v35 = 520 * v8;\n                v29 = v9;\n                v10 = memcmp(v9, v7, 2u);\n                v9 = v29;\n                if ( !v10 )\n                  break;\n                ++v8;\n                v7 += 520;\n                if ( v8 >= *(&::buf + 3) )\n                  goto LABEL_12;\n              }\n              if ( *((_DWORD *)v7 - 1) )\n              {\n                v11 = v44 & 0xF;\n                if ( (v44 & 0xF) != 2 || (++a1[2], !v36) )\n                {\n                  *(_DWORD *)(*(&::buf + 6) + 520 * v8 + 4) = 0;\n                  v12 = sub_804EC14();\n                  v28 = v12;\n                  if ( (dword_80DBB9C & 1) != 0 )\n                    printf(\"Query #%d completed in %ums:\\n\", v8, v12 - v34);\n                  if ( v11 )\n                  {\n                    printf(\n                      \"** server can't find %s: %s\\n\",\n                      *(const char **)(*(&::buf + 6) + 520 * v8),\n                      off_80B5A00[v11]);\n                    goto LABEL_84;\n                  }\n                  if ( (buf[2] & 4) == 0 )\n                    printf(\"Non-authoritative answer:\\n\");\n                  v32 = __ns_initparse(buf, v4, &v42);\n                  if ( v32 )\n                  {\nLABEL_83:\n                    printf(\"*** Can't find %s: Parse error\\n\", *(const char **)(*(&::buf + 6) + v35));\nLABEL_84:\n                    sub_804DD98(10);\n                    if ( *(&::buf + 3) <= ++v33 )\n                      goto LABEL_88;\n                    goto LABEL_85;\n                  }\n                  v30 = 0;\n                  while ( 2 )\n                  {\n                    if ( v32 >= v42._counts[1] )\n                      goto LABEL_84;\n                    v13 = &v46;\n                    if ( __ns_parserr(&v42, ns_s_an, v32, &v46) )\n                      goto LABEL_83;\n                    if ( v46.type == 6 )\n                    {\n                      if ( v46.rdlength <= 0x13u )\n                        goto LABEL_83;\n                      if ( !v46.name[0] )\n                        v13 = (ns_rr *)\".\";\n                      printf(\"%s\\n\", v13->name);\n                      rdata = v46.rdata;\n                      v18 = __ns_name_uncompress(v42._msg, v42._eom, v46.rdata, v45, 0x401u);\n                      if ( v18 < 0 )\n                        goto LABEL_83;\n                      printf(\"\\torigin = %s\\n\", v45);\n                      v19 = &rdata[v18];\n                      v20 = __ns_name_uncompress(v42._msg, v42._eom, v19, v45, 0x401u);\n                      if ( v20 < 0 )\n                        goto LABEL_83;\n                      printf(\"\\tmail addr = %s\\n\", v45);\n                      v21 = &v19[v20];\n                      v22 = __ns_get32(v21);\n                      printf(\"\\tserial = %lu\\n\", v22);\n                      v23 = __ns_get32(v21 + 4);\n                      printf(\"\\trefresh = %lu\\n\", v23);\n                      v24 = __ns_get32(v21 + 8);\n                      printf(\"\\tretry = %lu\\n\", v24);\n                      v25 = __ns_get32(v21 + 12);\n                      printf(\"\\texpire = %lu\\n\", v25);\n                      v26 = __ns_get32(v21 + 16);\n                      printf(\"\\tminimum = %lu\\n\", v26);\n                      goto LABEL_82;\n                    }\n                    if ( v46.type > 6u )\n                    {\n                      if ( v46.type == 15 )\n                      {\n                        if ( v46.rdlength <= 1u )\n                        {\n                          printf(\"MX record too short\\n\");\n                          goto LABEL_83;\n                        }\n                        v15 = __ns_get16(v46.rdata);\n                        if ( __ns_name_uncompress(v42._msg, v42._eom, v46.rdata + 2, v45, 0x401u) < 0 )\n                          goto LABEL_83;\n                        if ( !v46.name[0] )\n                          v13 = (ns_rr *)\".\";\n                        printf(\"%s\\tmail exchanger = %d %s\\n\", v13->name, v15, v45);\n                        goto LABEL_82;\n                      }\n                      if ( v46.type > 0xFu )\n                      {\n                        if ( v46.type == 16 )\n                        {\n                          if ( !v46.rdlength )\n                            goto LABEL_83;\n                          v16 = *v46.rdata;\n                          if ( *v46.rdata )\n                          {\n                            memset(v45, 0, sizeof(v45));\n                            qmemcpy(v45, v46.rdata + 1, v16);\n                            if ( !v46.name[0] )\n                              v13 = (ns_rr *)\".\";\n                            printf(\"%s\\ttext = \\\"%s\\\"\\n\", v13, v45);\n                          }\n                          goto LABEL_82;\n                        }\n                        if ( v46.type != 28 )\n                        {\nLABEL_82:\n                          ++v32;\n                          continue;\n                        }\n                        if ( v46.rdlength != 16 )\n                          goto LABEL_83;\n                        inet_ntop(10, v46.rdata, v41, 0x2Eu);\nLABEL_51:\n                        if ( !v46.name[0] )\n                          v13 = (ns_rr *)\".\";\n                        printf(\"Name:\\t%s\\nAddress: %s\\n\", v13, v41);\n                        goto LABEL_82;\n                      }\n                      if ( v46.type != 12 )\n                        goto LABEL_82;\n                      if ( !v30 )\n                        v30 = \"%s\\tname = %s\\n\";\n                    }\n                    else\n                    {\n                      switch ( v46.type )\n                      {\n                        case 2u:\n                          if ( !v30 )\n                            v30 = \"%s\\tnameserver = %s\\n\";\n                          break;\n                        case 5u:\n                          if ( !v30 )\n                            v30 = \"%s\\tcanonical name = %s\\n\";\n                          break;\n                        case 1u:\n                          if ( v46.rdlength != 4 )\n                            goto LABEL_83;\n                          inet_ntop(2, v46.rdata, v41, 0x2Eu);\n                          goto LABEL_51;\n                        default:\n                          goto LABEL_82;\n                      }\n                    }\n                    break;\n                  }\n                  if ( __ns_name_uncompress(v42._msg, v42._eom, v46.rdata, v45, 0x401u) < 0 )\n                    goto LABEL_83;\n                  v14 = &v46;\n                  if ( !v46.name[0] )\n                    v14 = (ns_rr *)\".\";\n                  printf(v30, v14, v45);\n                  goto LABEL_82;\n                }\n                --v36;\n                write(fd.fd, (const void *)(*(&::buf + 6) + v35 + 8), *(_DWORD *)(*(&::buf + 6) + v35 + 4));\n              }\n            }\n          }\n          else\n          {\n            sub_804D3A5(135046626);\n          }\n        }\nLABEL_12:\n        v28 = sub_804EC14();\nLABEL_85:\n        if ( v28 - v34 >= v37 )\n          goto LABEL_88;\n        if ( v28 - v31 >= v38 )\n        {\n          v31 = v28;\n          goto LABEL_2;\n        }\n      }\n    }\n    v3 = *(&::buf + 6) + 520 * i;\n    if ( *(_DWORD *)(v3 + 4) )\n    {\n      if ( write(fd.fd, (const void *)(v3 + 8), *(_DWORD *)(v3 + 4)) < 0 )\n        break;\n    }\n  }\n  sub_804D3A5((int)\"write to '%s'\", *a1);\n  v33 = -1;\nLABEL_88:\n  close(fd.fd);\n  return v33;\n}\n"
        ],
        "134610720": [
            "sub_805FF20",
            "0x805ff20",
            "int __usercall sub_805FF20@<eax>(int a1@<edx>, int a2@<ecx>, __int16 a3, int a4)\n{\n  int v4; // ebx\n  int v5; // edi\n  const char *v6; // ebp\n  const char *v7; // ebp\n  const char *v8; // eax\n  const char *v9; // esi\n  int v10; // eax\n  int v11; // ebp\n  int v12; // eax\n  int v13; // ecx\n  char *v14; // eax\n  unsigned __int8 v15; // bp\n  char *v16; // eax\n  const char *v17; // edx\n  int v18; // eax\n  unsigned int i; // esi\n  const char *v20; // eax\n  FILE *v21; // ebx\n  char *v22; // eax\n  char *v23; // eax\n  char *v24; // eax\n  size_t v25; // ebx\n  int result; // eax\n  size_t j; // ebx\n  size_t v28; // edx\n  int v29; // [esp-6h] [ebp-A8h]\n  char v31[16]; // [esp+2h] [ebp-A0h] BYREF\n  char s[64]; // [esp+12h] [ebp-90h] BYREF\n  char dest[80]; // [esp+52h] [ebp-50h] BYREF\n\n  *(_QWORD *)&buf = 0x200000035LL;\n  *(&buf + 2) = 5;\n  v4 = a4 + 4;\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = *(const char **)v4;\n    if ( !*(_DWORD *)v4 )\n      goto LABEL_3;\n    if ( *v6 != 45 )\n      break;\n    v4 += 4;\n    v7 = v6 + 1;\n    v8 = (const char *)strchrnul(a2, a1, v7, 61);\n    v9 = v8;\n    if ( *v8 )\n    {\n      *v8 = 0;\n      v9 = v8 + 1;\n    }\n    v10 = sub_804D254(\"type\", v7);\n    if ( v10 < 0 )\n      goto LABEL_3;\n    if ( v10 > 1 )\n    {\n      switch ( v10 )\n      {\n        case 2:\n          buf = sub_80B40CC(0xFFFF, 1);\n          break;\n        case 3:\n          *(&buf + 1) = sub_80B40CC(0x7FFFFFFF, 1);\n          break;\n        case 4:\n          dword_80DBB9C |= 1u;\n          break;\n        default:\n          *(&buf + 2) = sub_80B40CC(2147483, 1);\n          break;\n      }\n    }\n    else\n    {\n      v11 = 0;\n      while ( 1 )\n      {\n        v12 = strcasecmp(&aSoa[8 * v11], v9);\n        a1 = v29;\n        if ( !v12 )\n          break;\n        if ( ++v11 == 9 )\n          sub_804D5E0(\"invalid query type \\\"%s\\\"\", v9);\n      }\n      a2 = v11;\n      v5 |= 1 << v11;\n    }\n  }\n  if ( !v5 )\n  {\n    if ( inet_pton(10, v6, v31) )\n    {\n      if ( !memcmp(v31, &unk_80B7900, 0xCu) )\n      {\n        v16 = sub_804DDBF(\n                \"%u.%u.%u.%u.in-addr.arpa\",\n                (unsigned __int8)v31[15],\n                (unsigned __int8)v31[14],\n                (unsigned __int8)v31[13],\n                (unsigned __int8)v31[12]);\n      }\n      else\n      {\n        v13 = 16;\n        v14 = s;\n        do\n        {\n          v15 = v31[v13 - 1];\n          *v14 = byte_80C7B1E[v15 & 0xF] | 0x20;\n          v14[1] = 46;\n          v14[2] = byte_80C7B1E[v15 >> 4] | 0x20;\n          v14 += 4;\n          *(v14 - 1) = 46;\n          --v13;\n        }\n        while ( v13 );\n        strcpy(dest, \"ip6.arpa\");\n        v16 = sub_804DB46(s);\n      }\n    }\n    else\n    {\n      if ( !inet_pton(2, v6, v31) )\n        goto LABEL_32;\n      v16 = sub_804DDBF(\n              \"%u.%u.%u.%u.in-addr.arpa\",\n              (unsigned __int8)v31[3],\n              (unsigned __int8)v31[2],\n              (unsigned __int8)v31[1],\n              (unsigned __int8)v31[0]);\n    }\n    if ( v16 )\n    {\n      v17 = v16;\n      v18 = 12;\nLABEL_33:\n      sub_805F80C(v18, v17);\n      goto LABEL_38;\n    }\nLABEL_32:\n    sub_805F80C(1, *(const char **)v4);\n    v17 = *(const char **)v4;\n    v18 = 28;\n    goto LABEL_33;\n  }\n  for ( i = 0; i != 9; ++i )\n  {\n    if ( _bittest(&v5, i) )\n      sub_805F80C((unsigned __int8)byte_80B5A40[8 * i], *(const char **)v4);\n  }\nLABEL_38:\n  v20 = *(const char **)(v4 + 4);\n  if ( v20 )\n  {\n    if ( *(_DWORD *)(v4 + 8) )\nLABEL_3:\n      sub_804CDC2();\n  }\n  else\n  {\n    v21 = (FILE *)fopen64(\"/etc/resolv.conf\", \"r\");\n    if ( v21 )\n    {\n      while ( fgets_unlocked(s, 128, v21) )\n      {\n        v22 = strtok(s, \" \\t\\n\");\n        if ( v22 )\n        {\n          if ( !strcmp(v22, \"nameserver\") )\n          {\n            v23 = strtok(0, \" \\t\\n\");\n            if ( v23 )\n            {\n              v24 = sub_804DB46(v23);\n              sub_805F865((int)v24);\n            }\n          }\n        }\n      }\n      fclose(v21);\n    }\n    if ( *(&buf + 4) )\n      goto LABEL_51;\n    v20 = \"127.0.0.1\";\n  }\n  sub_805F865((int)v20);\nLABEL_51:\n  v25 = 0;\n  while ( *(&buf + 4) > v25 && sub_805F8A7((const char **)(*(&buf + 5) + 16 * v25)) <= 0 )\n  {\n    if ( *(&buf + 4) <= ++v25 )\n    {\n      printf(\";; connection timed out; no servers could be reached\\n\\n\");\n      return 1;\n    }\n  }\n  result = 0;\n  for ( j = 0; *(&buf + 3) > j; ++j )\n  {\n    v28 = *(&buf + 6) + 520 * j;\n    if ( *(_DWORD *)(v28 + 4) )\n    {\n      printf(\"*** Can't find %s: No answer\\n\", *(const char **)v28);\n      result = 1;\n    }\n  }\n  if ( result )\n  {\n    sub_804DD98(10);\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134611583": [
            "sub_806027F",
            "0x806027f",
            "void __cdecl __noreturn sub_806027F(int a1)\n{\n  size_t v1; // ebx\n  size_t v2; // ecx\n  unsigned int v3; // esi\n  unsigned int v4; // edi\n  int v5; // eax\n\n  signal(2, (__sighandler_t)1);\n  v1 = *(&buf + 7);\n  printf(\n    \"\\n--- %s ping statistics ---\\n%lu packets transmitted, %lu packets received, \",\n    (const char *)preg.allocated,\n    *(&buf + 6),\n    *(&buf + 7));\n  if ( *(&buf + 8) )\n    printf(\"%lu duplicates, \", *(&buf + 8));\n  v2 = *(&buf + 6);\n  if ( *(&buf + 6) )\n    v2 = 100 * (*(&buf + 6) - v1) / *(&buf + 6);\n  printf(\"%lu%% packet loss\\n\", v2);\n  v3 = *(&buf + 10);\n  if ( *(&buf + 10) != -1 )\n  {\n    v4 = sub_80B4B88(*(&buf + 12), *(&buf + 13), v1 + *(&buf + 8), 0);\n    printf(\n      \"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\",\n      v3 / 0x3E8,\n      v3 % 0x3E8,\n      v4 / 0x3E8,\n      v4 % 0x3E8,\n      *(&buf + 11) / 0x3E8,\n      *(&buf + 11) % 0x3E8);\n  }\n  v5 = 1;\n  if ( v1 )\n  {\n    v5 = 0;\n    if ( dword_80DB7B4 )\n      v5 = *(&buf + 4) > v1;\n  }\n  exit(v5);\n}\n"
        ],
        "134611811": [
            "sub_8060363",
            "0x8060363",
            "void sub_8060363()\n{\n  unsigned __int8 *buffer; // ebx\n  __int16 v1; // ax\n  int v2; // eax\n  size_t v3; // ebx\n  size_t v4; // ebx\n  unsigned int secondsa; // [esp+Ch] [ebp+4h]\n\n  buffer = preg.buffer;\n  memset(preg.buffer, *((char *)&buf + 38), *(&buf + 3) + 12);\n  *buffer = 8;\n  *((_WORD *)buffer + 1) = 0;\n  LOBYTE(v1) = *((_BYTE *)&buf + 25);\n  HIBYTE(v1) = *((_BYTE *)&buf + 24);\n  *((_WORD *)buffer + 3) = v1;\n  *((_WORD *)buffer + 2) = *((_WORD *)&buf + 18);\n  *(&buf + 14) = sub_804EBDE();\n  *((_DWORD *)buffer + 2) = *(&buf + 14);\n  *((_WORD *)buffer + 1) = sub_80AD4D4();\n  v2 = *(&buf + 6);\n  *((_BYTE *)&preg + ((*((_WORD *)&buf + 12) >> 3) & 0x7F) + 28) &= ~(1 << (*(_BYTE *)(&buf + 6) & 7));\n  *(&buf + 6) = v2 + 1;\n  if ( dword_80DB7B4 && (int)(*(&buf + 14) - (_DWORD)dword_80DB7B4) >= 0 )\n    sub_806027F(0);\n  v3 = *(&buf + 3) + 8;\n  if ( v3 != sub_804DFCD(*(&buf + 3) + 8, preg.buffer, 0, (struct sockaddr *)&preg.syntax, 0x10u) )\n    sub_804D5E0(\"write error\");\n  if ( *(&buf + 4) && *(&buf + 4) <= *(&buf + 6) )\n  {\n    v4 = (size_t)seconds;\n    if ( *(&buf + 7) )\n    {\n      v4 = *(&buf + 11) >> 19;\n      if ( !(*(&buf + 11) >> 19) )\n        v4 = 1;\n    }\n    signal(14, (__sighandler_t)sub_806027F);\n    secondsa = v4;\n  }\n  else\n  {\n    signal(14, sub_8060363);\n    secondsa = 1;\n  }\n  alarm(secondsa);\n}\n"
        ],
        "134612104": [
            "sub_8060488",
            "0x8060488",
            "void __usercall __noreturn sub_8060488(size_t a1@<ebx>, int a2, int a3)\n{\n  __int16 v3; // si\n  void *v4; // esi\n  int v5; // eax\n  int v6; // edx\n  int v7; // eax\n  const void *v8; // esi\n  const char *v9; // eax\n  int v10; // eax\n  ssize_t v11; // eax\n  int v12; // ecx\n  int v13; // edx\n  unsigned __int8 *v14; // eax\n  unsigned int v15; // edx\n  unsigned __int16 v16; // si\n  _DWORD *v17; // edi\n  int v18; // ebp\n  int v19; // eax\n  int v20; // edx\n  unsigned __int8 v21; // cl\n  const char *v22; // esi\n  const char *v23; // eax\n  unsigned int v24; // [esp+0h] [ebp-38h]\n  int v25; // [esp+4h] [ebp-34h]\n  char *v26; // [esp+8h] [ebp-30h]\n  int v27; // [esp+Ch] [ebp-2Ch] BYREF\n  int v28; // [esp+10h] [ebp-28h] BYREF\n  socklen_t addr_len; // [esp+14h] [ebp-24h] BYREF\n  struct sockaddr addr; // [esp+18h] [ebp-20h] BYREF\n\n  *(&buf + 3) = 56;\n  seconds = (void *)10;\n  *(&buf + 10) = -1;\n  v3 = sub_80ABEAC(a3, \"^qvAc:+s:t:+w:+W:+I:np:4\", &buf + 4, &v27, &buf + 5, &dword_80DB7B4, &seconds, &buf + 1, &v28);\n  if ( (v3 & 0x10) != 0 )\n    *(&buf + 3) = (unsigned __int16)sub_80B4193();\n  if ( (v3 & 0x100) != 0 )\n  {\n    buf = if_nametoindex(*(&buf + 1));\n    if ( !buf )\n    {\n      *(&buf + 2) = sub_80B45C8();\n      *(&buf + 1) = 0;\n    }\n  }\n  if ( (v3 & 0x400) != 0 )\n    *((_BYTE *)&buf + 38) = sub_80B4093(255);\n  v4 = dword_80DB7B4;\n  if ( dword_80DB7B4 )\n  {\n    v5 = sub_804EBDE();\n    v6 = (int)v4;\n    if ( (unsigned int)v4 > 0x863 )\n      v6 = 2147;\n    dword_80DB7B4 = (void *)((1000000 * v6 + v5) | 1);\n  }\n  *((_WORD *)&buf + 18) = getpid();\n  preg.allocated = *(_DWORD *)(a3 + 4 * optind);\n  v7 = sub_80B45A6(2, 0);\n  if ( *(&buf + 2) && *(_WORD *)(*(&buf + 2) + 4) != (unsigned __int16)*(_DWORD *)(v7 + 4) )\n    *(&buf + 2) = 0;\n  v8 = (const void *)(v7 + 4);\n  preg.used = sub_80B46B6();\n  printf(\"PING %s (%s)\", (const char *)preg.allocated, (const char *)preg.used);\n  if ( *(&buf + 2) )\n  {\n    v9 = (const char *)sub_80B46B6();\n    printf(\" from %s\", v9);\n  }\n  printf(\": %d data bytes\\n\", *(&buf + 3));\n  v10 = socket(2, 3, 1);\n  if ( v10 < 0 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C == 1 )\n      sub_804D5E0(\"permission denied (are you root?)\");\n    sub_804D3C9((int)\"can't create raw socket\");\n  }\n  sub_804DC97(v10, 0);\n  if ( *(&buf + 1) )\n    sub_80B4280();\n  n = *(&buf + 3) + 136;\n  dword_80DB7C0 = sub_804DB2E(*(&buf + 3) + 136);\n  preg.buffer = (unsigned __int8 *)sub_804DB2E(*(&buf + 3) + 12);\n  qmemcpy(&preg.syntax, v8, 0x10u);\n  if ( *(&buf + 2) )\n  {\n    if ( setsockopt(0, 0, 32, (const void *)(*(&buf + 2) + 4), *(_DWORD *)*(&buf + 2)) )\n      sub_804D5E0(\"can't set multicast source interface\");\n    sub_804DFB3(*(_DWORD *)*(&buf + 2), (struct sockaddr *)(*(&buf + 2) + 4), 0);\n  }\n  sub_80B426C();\n  sub_80B424A(2 * *((_BYTE *)&buf + 12), 8);\n  if ( *(&buf + 5) )\n  {\n    sub_80B422B(2, 0, *((char *)&buf + 20));\n    sub_80B422B(33, 0, *((char *)&buf + 20));\n  }\n  signal(2, (__sighandler_t)sub_806027F);\n  while ( 1 )\n  {\n    sub_8060363();\n    do\n    {\n      while ( 1 )\n      {\n        addr_len = 16;\n        v11 = recvfrom(0, dword_80DB7C0, n, 0, &addr, &addr_len);\n        if ( v11 >= 0 )\n          break;\n        if ( *(_DWORD *)dword_80DBB7C != 4 )\n          sub_804D3A5((int)\"recvfrom\");\n      }\n      v12 = 0;\n      if ( *(&buf + 3) + 8 <= v11 )\n      {\n        v13 = 4 * (*(_BYTE *)dword_80DB7C0 & 0xF);\n        v24 = v11 - v13;\n        v14 = (unsigned __int8 *)dword_80DB7C0 + v13;\n        if ( *(_WORD *)((char *)dword_80DB7C0 + v13 + 4) == *((_WORD *)&buf + 18) )\n        {\n          v15 = *v14;\n          if ( (_BYTE)v15 )\n          {\n            if ( (_BYTE)v15 != 8 )\n            {\n              v23 = (const char *)&unk_80CD6CB;\n              if ( v15 <= 0x12 )\n                v23 = (&off_80B5AA0)[v15];\n              sub_804D5F4(\"warning: got ICMP %d (%s)\", v15, v23);\n              v12 = 0;\n            }\n          }\n          else\n          {\n            v16 = __ROL2__(*((_WORD *)v14 + 3), 8);\n            v17 = 0;\n            if ( v24 > 0xB )\n              v17 = v14 + 8;\n            v18 = *((unsigned __int8 *)dword_80DB7C0 + 8);\n            v25 = v16;\n            v26 = inet_ntoa(*(struct in_addr *)&addr.sa_data[2]);\n            if ( v17 )\n            {\n              a1 = sub_804EBDE() - *v17;\n              *((_QWORD *)&buf + 6) += a1;\n              if ( a1 < *(&buf + 10) )\n                *(&buf + 10) = a1;\n              if ( a1 > *(&buf + 11) )\n                *(&buf + 11) = a1;\n            }\n            v19 = ((v16 >> 3) & 0x7F) + 104;\n            v20 = 1 << (v16 & 7);\n            v21 = *((_BYTE *)&buf + v19);\n            if ( ((unsigned __int8)v20 & v21) != 0 )\n            {\n              ++*(&buf + 8);\n              v22 = \" (DUP!)\";\n            }\n            else\n            {\n              *((_BYTE *)&buf + v19) = v20 | v21;\n              ++*(&buf + 7);\n              v22 = \" (DUP!)\" + 7;\n            }\n            v12 = 1;\n            if ( (dword_80DBB9C & 1) == 0 )\n            {\n              printf(\"%d bytes from %s: seq=%u ttl=%d\", v24, v26, v25, v18);\n              if ( v17 )\n                printf(\" time=%u.%03u ms\", a1 / 0x3E8, a1 % 0x3E8);\n              puts(v22);\n              sub_804DD8F();\n              v12 = 1;\n            }\n          }\n        }\n      }\n      if ( *(&buf + 4) && *(&buf + 4) <= *(&buf + 7) )\n        sub_806027F(0);\n    }\n    while ( !v12 || (dword_80DBB9C & 4) == 0 );\n  }\n}\n"
        ],
        "134613264": [
            "sub_8060910",
            "0x8060910",
            "char *__usercall sub_8060910@<eax>(char *result@<eax>, int a2@<edx>)\n{\n  int i; // ecx\n  char v3; // bl\n\n  for ( i = 0; ; ++i )\n  {\n    v3 = byte_80CDACC[i];\n    *result = v3;\n    if ( !v3 )\n      break;\n    result += (a2 & dword_80B5B00[i]) != 0;\n  }\n  return result;\n}\n"
        ],
        "134613298": [
            "sub_8060932",
            "0x8060932",
            "int __usercall sub_8060932@<eax>(const char *a1@<eax>, const char ***a2@<edx>)\n{\n  const char **v2; // esi\n  const char *v3; // edi\n\n  v2 = *a2;\n  v3 = **a2;\n  if ( !v3 )\n    return 0;\n  while ( strcmp(a1 + 2, v3) )\n  {\n    a1 += *(unsigned __int8 *)a1;\n    if ( !*a1 )\n      return 0;\n  }\n  *a2 = v2 + 1;\n  if ( (a1[1] & 0x10) != 0 )\n  {\n    if ( !v2[1] )\n      sub_804CDC2();\n    *a2 = v2 + 2;\n  }\n  return *((unsigned __int8 *)a1 + 1);\n}\n"
        ],
        "134613382": [
            "sub_8060986",
            "0x8060986",
            "int sub_8060986()\n{\n  FILE *v0; // esi\n  int v1; // eax\n  char *v2; // ebp\n  int i; // ecx\n  int v5; // ebx\n  char v6; // al\n  char *v7; // ebx\n  char *ptr; // [esp+4h] [ebp-138h]\n  int v9; // [esp+8h] [ebp-134h] BYREF\n  int v10; // [esp+Ch] [ebp-130h] BYREF\n  int v11; // [esp+10h] [ebp-12Ch] BYREF\n  int v12; // [esp+14h] [ebp-128h] BYREF\n  int v13; // [esp+18h] [ebp-124h] BYREF\n  char v14; // [esp+1Ch] [ebp-120h] BYREF\n  char v15[16]; // [esp+20h] [ebp-11Ch] BYREF\n  char v16[16]; // [esp+30h] [ebp-10Ch] BYREF\n  __int16 v17; // [esp+40h] [ebp-FCh]\n  char buf[20]; // [esp+48h] [ebp-F4h] BYREF\n  char cp[15]; // [esp+5Ch] [ebp-E0h] BYREF\n  char v20[25]; // [esp+6Bh] [ebp-D1h] BYREF\n  char v21[40]; // [esp+84h] [ebp-B8h] BYREF\n  char s[144]; // [esp+ACh] [ebp-90h] BYREF\n\n  v0 = (FILE *)sub_80B3D45();\n  printf(\"Kernel IPv6 routing table\\n%-44s%-40sFlags Metric Ref    Use Iface\\n\", \"Destination\", \"Next Hop\");\nLABEL_2:\n  v1 = fscanf(v0, \"%32s%x%*s%x%32s%x%x%x%x%s\\n\", &cp[14], &v13, &v14, &v21[7], &v10, &v11, &v12, &v9, v15);\n  if ( v1 == 9 )\n  {\n    v2 = v20;\n    for ( i = 0; ; i = v5 )\n    {\n      v6 = *(v2 - 1);\n      if ( v6 )\n      {\n        v5 = i + 1;\n        cp[i] = v6;\n        if ( !((i + 2) % 5) )\n        {\n          cp[v5] = 58;\n          v5 = i + 2;\n        }\n        if ( v5 > 74 )\n        {\n          sub_8060910(v16, v9 & 0x1250207);\n          inet_pton(10, cp, buf);\n          v17 = 10;\n          ptr = (char *)sub_80AD6B6();\n          snprintf(s, 0x80u, \"%s/%d\", ptr, v13);\n          free(ptr);\n          inet_pton(10, v21, buf);\n          v17 = 10;\n          v7 = (char *)sub_80AD6B6();\n          printf(\"%-43s %-39s %-5s %-6d %-2d %7d %-8s\\n\", s, v7, v16, v10, v11, v12, v15);\n          free(v7);\n          goto LABEL_2;\n        }\n      }\n      else\n      {\n        if ( i != 40 )\n          goto LABEL_5;\n        v20[24] = 0;\n        v5 = 40;\n      }\n      ++v2;\n    }\n  }\n  if ( v1 >= 0 || (v0->_flags & 4) == 0 )\nLABEL_5:\n    sub_804D3C9((int)\"read error\");\n  return fclose(v0);\n}\n"
        ],
        "134613799": [
            "sub_8060B27",
            "0x8060b27",
            "int __usercall sub_8060B27@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  const char *v2; // esi\n  int v3; // ebx\n  char *v4; // eax\n  int v5; // ecx\n  const char *v6; // ebx\n  int v7; // eax\n  const char **v8; // edx\n  int v9; // esi\n  int v11; // [esp+4h] [ebp-A0h]\n  const char **v13; // [esp+Ch] [ebp-98h] BYREF\n  char v14[28]; // [esp+10h] [ebp-94h] BYREF\n  char v15[16]; // [esp+2Ch] [ebp-78h] BYREF\n  int v16; // [esp+3Ch] [ebp-68h]\n  _DWORD v17[22]; // [esp+4Ch] [ebp-58h] BYREF\n\n  v13 = a2 + 1;\n  v2 = *a2;\n  if ( !strcmp(*a2, \"default\") )\n  {\n    v3 = 0;\n    memset(v14, 0, sizeof(v14));\n  }\n  else\n  {\n    v4 = strchr(v2, 47);\n    v5 = v11;\n    v3 = 128;\n    if ( v4 )\n    {\n      *v4 = 0;\n      v3 = sub_80B40CC(128, 0);\n    }\n    if ( sub_80AD640(v5, v14) < 0 )\nLABEL_7:\n      sub_804D5E0(\"resolving %s\", v2);\n  }\n  memset(&v17[4], 0, 0x38u);\n  qmemcpy(v17, &v14[8], 0x10u);\n  LOWORD(v17[13]) = v3;\n  v17[16] = 4 * (v3 == 128) + 1;\n  v17[14] = 1;\n  v6 = 0;\n  while ( *v13 )\n  {\n    v7 = sub_8060932(asc_80CDAD8, &v13);\n    v8 = v13;\n    v2 = *(v13 - 1);\n    if ( (unsigned int)(v7 - 33) > 1 )\n    {\n      if ( v7 == 16 )\n      {\n        v17[14] = sub_80B40EC();\n      }\n      else if ( v7 == 18 )\n      {\n        if ( (v17[16] & 2) != 0 )\n          goto LABEL_16;\n        if ( sub_80AD640(v7 - 33, v14) < 0 )\n          goto LABEL_7;\n        qmemcpy(&v17[8], &v14[8], 0x10u);\n        v17[16] |= 2u;\n      }\n      else\n      {\n        if ( v6 || v7 != 22 && (v7 || (++v13, v8[1])) )\nLABEL_16:\n          sub_804CDC2();\n        v6 = *(v13 - 1);\n      }\n    }\n    else\n    {\n      v17[16] |= (unsigned __int16)word_80B790C[v7 & 3];\n    }\n  }\n  v9 = sub_804DF99(0, 2, 10);\n  v17[17] = 0;\n  if ( v6 )\n  {\n    sub_804D67E(v15, v6);\n    sub_804E0BE(v9, 0x8933u, (int)v15, \"SIOCGIFINDEX\");\n    v17[17] = v16;\n  }\n  if ( a1 == 1 )\n    return sub_804E0BE(v9, 0x890Bu, (int)v17, \"SIOCADDRT\");\n  else\n    return sub_804E0BE(v9, 0x890Cu, (int)v17, \"SIOCDELRT\");\n}\n"
        ],
        "134614289": [
            "sub_8060D11",
            "0x8060d11",
            "int __usercall sub_8060D11@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  int v2; // eax\n  const char **v3; // edx\n  int v4; // ebp\n  const char *v5; // edi\n  char *v6; // ebx\n  const char *v7; // esi\n  int v8; // eax\n  __int16 v9; // dx\n  int v10; // eax\n  const char **v11; // edx\n  const char *v12; // ebx\n  int v13; // eax\n  unsigned __int32 v14; // edx\n  int v15; // ebx\n  int v16; // eax\n  const char *v18; // [esp+4h] [ebp-80h]\n  const char **v20; // [esp+Ch] [ebp-78h] BYREF\n  char v21[16]; // [esp+10h] [ebp-74h] BYREF\n  int v22[25]; // [esp+20h] [ebp-64h] BYREF\n\n  v20 = a2;\n  v2 = sub_8060932(asc_80CDB40, &v20);\n  v3 = v20;\n  if ( !*v20 )\nLABEL_2:\n    sub_804CDC2();\n  v4 = v2;\n  memset(v22, 0, 0x54u);\n  ++v20;\n  v5 = *v3;\n  v6 = strchr(*v3, 47);\n  v7 = \"default\";\n  if ( v6 )\n  {\n    v22[10] = _byteswap_ulong(~(0xFFFFFFFF >> sub_80B40CC(32, 0)));\n    *v6 = 0;\n    LOWORD(v22[9]) = 2;\n    v7 = 0;\n  }\n  v8 = sub_80AD506(v4 & 2, &v22[1]);\n  if ( v8 < 0 )\n  {\n    v18 = v5;\n    goto LABEL_18;\n  }\n  if ( v6 )\n    *v6 = 47;\n  if ( v4 )\n    v8 = v4 & 1;\n  v9 = 1;\n  if ( !v8 )\n    v9 = 5;\n  LOWORD(v22[13]) = v9;\n  while ( *v20 )\n  {\n    v10 = sub_8060932(asc_80CDAD8, &v20);\n    v11 = v20;\n    v12 = *(v20 - 1);\n    if ( (v10 & 0x20) != 0 )\n    {\n      LOWORD(v22[13]) |= word_80B790C[v10 & 3];\n    }\n    else\n    {\n      switch ( v10 )\n      {\n        case 16:\n          LOWORD(v22[16]) = sub_80B40EC() + 1;\n          break;\n        case 17:\n          if ( v22[10] )\n            goto LABEL_2;\n          if ( sub_80AD506(0, v21) < 0 )\n            goto LABEL_17;\n          qmemcpy(&v22[9], v21, 0x10u);\n          v7 = v12;\n          break;\n        case 18:\n          if ( (v22[13] & 2) != 0 )\n            goto LABEL_2;\n          v13 = sub_80AD506(1, &v22[5]);\n          LOWORD(v22[13]) |= 2u;\n          if ( v13 )\n          {\n            if ( v13 >= 0 )\n              sub_804D5E0(\"gateway %s is a NETWORK\", v12);\nLABEL_17:\n            v18 = v12;\nLABEL_18:\n            sub_804D5E0(\"resolving %s\", v18);\n          }\n          break;\n        case 19:\n          LOWORD(v22[13]) |= 0x40u;\n          v22[18] = sub_80B40CC(0x8000, 64);\n          break;\n        case 20:\n          LOWORD(v22[13]) |= 0x80u;\n          v22[19] = sub_80B40CC(0x7FFFFFFF, 128);\n          break;\n        case 21:\n          LOWORD(v22[13]) |= 0x100u;\n          LOWORD(v22[20]) = sub_80B40EC();\n          LOWORD(v22[20]) *= (unsigned __int16)(sub_80B2F58() / 0x64u);\n          break;\n        default:\n          if ( v22[17] )\n            goto LABEL_2;\n          if ( v10 != 22 )\n          {\n            if ( v10 )\n              goto LABEL_2;\n            ++v20;\n            if ( v11[1] )\n              goto LABEL_2;\n          }\n          v22[17] = (int)*(v20 - 1);\n          break;\n      }\n    }\n  }\n  if ( (v22[13] & 0x200) != 0 && !v22[17] )\n    v22[17] = (int)\"lo\";\n  if ( v22[10] )\n  {\n    v14 = _byteswap_ulong(v22[10]);\n    v15 = ~v14;\n    if ( (v22[13] & 4) != 0 && v15 != -1 )\n      sub_804D5E0(\"netmask %.8x and host route conflict\", ~v14);\n    if ( (v15 & -v14) != 0 )\n      sub_804D5E0(\"bogus netmask %s\", v7);\n    if ( (~v22[10] & v22[2]) != 0 )\n      sub_804D5E0(\"netmask and route address conflict\");\n  }\n  if ( a1 == 1 && (v22[13] & 4) != 0 )\n    v22[10] = -1;\n  v16 = sub_804DF99(0, 2, 2);\n  if ( a1 == 1 )\n    return sub_804E0BE(v16, 0x890Bu, (int)v22, \"SIOCADDRT\");\n  else\n    return sub_804E0BE(v16, 0x890Cu, (int)v22, \"SIOCDELRT\");\n}\n"
        ],
        "134615047": [
            "sub_8061007",
            "0x8061007",
            "int __usercall sub_8061007@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  FILE *v3; // ebx\n  const char *v4; // eax\n  int v5; // eax\n  int v6; // edx\n  char *v7; // ebp\n  int v8; // edx\n  char *v9; // edi\n  char *v10; // eax\n  int v13; // [esp+4h] [ebp-98h] BYREF\n  int v14; // [esp+8h] [ebp-94h] BYREF\n  struct in_addr in; // [esp+Ch] [ebp-90h] BYREF\n  char v16; // [esp+10h] [ebp-8Ch] BYREF\n  char v17; // [esp+11h] [ebp-8Bh]\n  int v18; // [esp+14h] [ebp-88h] BYREF\n  int v19; // [esp+18h] [ebp-84h] BYREF\n  int v20; // [esp+1Ch] [ebp-80h] BYREF\n  int v21; // [esp+20h] [ebp-7Ch] BYREF\n  int v22; // [esp+24h] [ebp-78h] BYREF\n  int v23; // [esp+28h] [ebp-74h] BYREF\n  __int16 v24; // [esp+2Ch] [ebp-70h]\n  _WORD v25[7]; // [esp+2Eh] [ebp-6Eh] BYREF\n  char v26[16]; // [esp+3Ch] [ebp-60h] BYREF\n  char v27[80]; // [esp+4Ch] [ebp-50h] BYREF\n\n  v3 = (FILE *)sub_80B3D45();\n  v4 = \"Metric Ref    Use\";\n  if ( a2 )\n    v4 = \"  MSS Window  irtt\";\n  printf(\"Kernel IP routing table\\nDestination     Gateway         Genmask         Flags %s Iface\\n\", v4);\n  if ( fscanf(v3, \"%*[^\\n]\\n\") >= 0 )\n  {\n    while ( 1 )\n    {\n      v5 = fscanf(v3, \"%63s%lx%lx%X%d%d%d%lx%d%d%d\\n\", v27, &v13, &v14, &v16, &v18, &v19, &v20, &in, &v21, &v22, &v23);\n      if ( v5 != 11 )\n        break;\n      if ( (v16 & 1) != 0 )\n      {\n        sub_8060910(v26, v16 & 0x3F);\n        if ( (v17 & 2) != 0 )\n          v26[0] = 33;\n        memset(v25, 0, sizeof(v25));\n        v24 = 2;\n        *(_DWORD *)&v25[1] = v13;\n        v6 = a1;\n        BYTE1(v6) = BYTE1(a1) | 0x80;\n        v7 = (char *)sub_80AD56A(in.s_addr, v6);\n        *(_DWORD *)&v25[1] = v14;\n        v8 = a1;\n        BYTE1(v8) = BYTE1(a1) | 0x40;\n        v9 = (char *)sub_80AD56A(in.s_addr, v8);\n        v10 = inet_ntoa(in);\n        printf(\"%-15.15s %-15.15s %-16s%-6s\", v7, v9, v10, v26);\n        free(v7);\n        free(v9);\n        if ( a2 )\n          printf(\"%5d %-5d %6d %s\\n\", v21, v22, v23, v27);\n        else\n          printf(\"%-6d %-2d %7d %s\\n\", v20, v18, v19, v27);\n      }\n    }\n    if ( v5 >= 0 )\n      goto LABEL_9;\n  }\n  if ( (v3->_flags & 4) == 0 )\nLABEL_9:\n    sub_804D3C9((int)\"read error\");\n  return fclose(v3);\n}\n"
        ],
        "134615447": [
            "sub_8061197",
            "0x8061197",
            "int __usercall sub_8061197@<eax>(char *a1@<ebx>, int a2, const char **a3)\n{\n  char **v3; // esi\n  char *v4; // ebx\n  int v5; // ebx\n  char *v6; // esi\n  int v7; // eax\n  char *s1; // [esp+0h] [ebp-Ch] BYREF\n\n  s1 = a1;\n  v3 = (char **)a3;\n  while ( 1 )\n  {\n    v4 = *++v3;\n    if ( !*v3 )\n      break;\n    if ( !strcmp(v4, \"-net\") || !strcmp(v4, \"-host\") )\n      *v4 = 35;\n  }\n  v5 = sub_80ABEAC(a3, \"A:ne\", &s1);\n  if ( (v5 & 1) != 0 )\n  {\n    v6 = s1;\n    if ( strcmp(s1, \"inet\") )\n    {\n      v5 |= 8u;\n      if ( strcmp(v6, \"inet6\") )\n        goto LABEL_9;\n    }\n  }\n  a3 += optind;\n  if ( !*a3 )\n  {\n    if ( (v5 & 8) != 0 )\n      sub_8060986();\n    else\n      sub_8061007((v5 << 30 >> 31) & 0xFFF, v5 & 4);\n    sub_80AB247(s1);\n  }\n  v7 = sub_8060932(byte_80CDAB7, &a3);\n  if ( !v7 || !*a3 )\nLABEL_9:\n    sub_804CDC2();\n  if ( (v5 & 8) != 0 )\n    sub_8060B27(v7, a3);\n  else\n    sub_8060D11(v7, a3);\n  return 0;\n}\n"
        ],
        "134615685": [
            "sub_8061285",
            "0x8061285",
            "int sub_8061285()\n{\n  return 0;\n}\n"
        ],
        "134615688": [
            "sub_8061288",
            "0x8061288",
            "char *__usercall sub_8061288@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v2; // edx\n\n  if ( !a1 )\n    return sub_804DDBF(\"none\");\n  if ( (a1 & 0xFFFF0000) == 0 )\n    return sub_804DDBF((char *)\":%x\", a1);\n  v2 = HIWORD(a1);\n  if ( (_WORD)a1 )\n    return sub_804DDBF(\"%x:%x\", v2, (unsigned __int16)a1);\n  else\n    return sub_804DDBF(\"%x:\", v2);\n}\n"
        ],
        "134615761": [
            "sub_80612D1",
            "0x80612d1",
            "int __usercall sub_80612D1@<eax>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<ebp>, int a4@<esi>, char a5)\n{\n  unsigned __int16 *v5; // edi\n  unsigned __int16 *v6; // ebx\n  unsigned __int16 *v7; // esi\n  unsigned int v8; // eax\n  long double v9; // fst7\n  char v10; // al\n  unsigned __int16 *v12; // [esp+1Ch] [ebp-78h]\n  unsigned __int16 *v13; // [esp+20h] [ebp-74h]\n  unsigned __int16 *v14; // [esp+24h] [ebp-70h]\n  unsigned __int16 *v15; // [esp+28h] [ebp-6Ch]\n  unsigned __int16 *v16; // [esp+2Ch] [ebp-68h]\n  char v17[68]; // [esp+38h] [ebp-5Ch] BYREF\n  int v18; // [esp+7Ch] [ebp-18h]\n  int v19; // [esp+80h] [ebp-14h]\n  char *v20; // [esp+84h] [ebp-10h]\n  int v21; // [esp+88h] [ebp-Ch]\n  int v22; // [esp+8Ch] [ebp-8h]\n  int retaddr; // [esp+94h] [ebp+0h]\n\n  if ( !a1 )\n    return 0;\n  v22 = retaddr;\n  v21 = a3;\n  v20 = &a5;\n  v19 = a4;\n  v18 = a2;\n  sub_806901E(*a1 - 4);\n  v5 = 0;\n  if ( v16 )\n  {\n    v5 = v16 + 2;\n    if ( (unsigned int)*v16 - 4 <= 0xB )\n    {\n      sub_804D5F4(\"CBQ: too short %s opt\", \"rate\");\n      v5 = 0;\n    }\n  }\n  v6 = 0;\n  if ( v12 )\n  {\n    v6 = v12 + 2;\n    if ( (unsigned int)*v12 - 4 <= 0x13 )\n    {\n      sub_804D5F4(\"CBQ: too short %s opt\", \"lss\");\n      v6 = 0;\n    }\n  }\n  v7 = 0;\n  if ( v13 )\n  {\n    v7 = v13 + 2;\n    if ( (unsigned int)*v13 - 4 <= 0xB )\n    {\n      sub_804D5F4(\"CBQ: too short %s opt\", \"wrr\");\n      v7 = 0;\n    }\n  }\n  if ( v14 && (unsigned int)*v14 - 4 <= 0xB )\n    sub_804D5F4(\"CBQ: too short %s opt\", \"fopt\");\n  if ( v15 )\n  {\n    v8 = *v15 - 4;\n    if ( v8 <= 7 )\n      sub_804D5F4(\"CBQ: too short overlimit strategy %u/%u\", v8, 8);\n  }\n  if ( v5 )\n  {\n    v9 = (long double)*((unsigned int *)v5 + 2) * 8.0;\n    if ( v9 < 1000000000.0 )\n    {\n      if ( v9 < 1000000.0 )\n        snprintf(v17, 0x40u, \"%.0fbit\", (double)v9);\n      else\n        snprintf(v17, 0x40u, \"%.0fKbit\", (double)(v9 / 1000.0));\n    }\n    else\n    {\n      snprintf(v17, 0x40u, \"%.0fMbit\", (double)(v9 / 1000000.0));\n    }\n    printf(\"rate %s \", v17);\n  }\n  if ( v6 && *((_BYTE *)v6 + 1) )\n  {\n    sub_804DD98(40);\n    v10 = 0;\n    if ( (*((_BYTE *)v6 + 1) & 1) != 0 )\n    {\n      printf(\"bounded\");\n      v10 = 1;\n    }\n    if ( (*((_BYTE *)v6 + 1) & 2) != 0 )\n    {\n      if ( v10 )\n        sub_804DD98(44);\n      printf(\"isolated\");\n    }\n    printf(\") \");\n  }\n  if ( v7 )\n  {\n    if ( *((_BYTE *)v7 + 1) == 8 )\n      printf(\"prio no-transmit\");\n    else\n      printf(\"prio %u\", *((unsigned __int8 *)v7 + 1));\n  }\n  return 0;\n}\n"
        ],
        "134616272": [
            "sub_80614D0",
            "0x80614d0",
            "int __fastcall sub_80614D0(int a1, int a2)\n{\n  int result; // eax\n  int v3; // esi\n  int *v5; // ebp\n  const char *v6; // esi\n  const char *v7; // eax\n  unsigned int v8; // eax\n  char *v9; // eax\n  int v10; // eax\n  int v11; // ebx\n  int v12; // eax\n  _DWORD *v13; // esi\n  const char *v14; // eax\n  int *v15; // [esp-4h] [ebp-58h]\n  int v16[2]; // [esp+0h] [ebp-54h] BYREF\n  int v17[19]; // [esp+8h] [ebp-4Ch] BYREF\n\n  result = 0;\n  if ( (unsigned __int16)(*(_WORD *)(a2 + 4) - 36) <= 1u )\n  {\n    v3 = *(_DWORD *)a2 - 36;\n    if ( v3 < 0 )\n      return -1;\n    if ( !buf || buf == *(_DWORD *)(a2 + 20) )\n    {\n      v5 = v17;\n      memset(v17, 0, 0x3Cu);\n      sub_806901E(v3);\n      if ( !v17[1] )\n        return -1;\n      if ( *(_WORD *)(a2 + 4) == 37 )\n        printf(\"deleted \");\n      v6 = (const char *)(v17[1] + 4);\n      printf(\"qdisc %s %x: \", (const char *)(v17[1] + 4), *(unsigned __int16 *)(a2 + 26));\n      if ( !buf )\n      {\n        v7 = (const char *)sub_80692E5();\n        printf(\"dev %s \", v7);\n      }\n      v8 = *(_DWORD *)(a2 + 28);\n      if ( v8 == -1 )\n      {\n        printf(\"root \");\n        v5 = v15;\n      }\n      else if ( v8 )\n      {\n        v9 = sub_8061288(v8);\n        printf(\"parent %s \", v9);\n      }\n      if ( *(_DWORD *)(a2 + 32) != 1 )\n        printf(\"refcnt %d \", *(_DWORD *)(a2 + 32));\n      if ( v17[2] )\n      {\n        v10 = sub_804D222(\"pfifo_fast\", v6);\n        v11 = v10;\n        if ( v10 )\n        {\n          if ( v10 == 1 )\n            sub_80612D1((unsigned __int16 *)v17[2], 0, (int)v5, (int)v6, v16[0]);\n          else\n            sub_804D5F4(\"unknown %s\", v6);\n        }\n        else if ( v17[2] )\n        {\n          v12 = *(unsigned __int16 *)v17[2];\n          v13 = 0;\n          if ( (unsigned int)(v12 - 4) > 0x13 )\n            v13 = (_DWORD *)(v17[2] + 4);\n          if ( (unsigned __int16)(v12 - 4) <= 0x17u )\n            memset(v16, 0, sizeof(v16));\n          else\n            sub_806901E(*(unsigned __int16 *)(v17[2] + 24) - 4);\n          printf(\"bands %u priomap \", *v13);\n          do\n            printf(\" %d\", *((unsigned __int8 *)v13 + v11++ + 4));\n          while ( v11 != 16 );\n          if ( v16[1] )\n          {\n            v14 = \"n\";\n            if ( !*(_BYTE *)(v16[1] + 4) )\n              v14 = \"ff\";\n            printf(\" multiqueue: o%s \", v14);\n          }\n        }\n      }\n      sub_804DD98(10);\n      return 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134616741": [
            "sub_80616A5",
            "0x80616a5",
            "int __fastcall sub_80616A5(int a1, int a2)\n{\n  int result; // eax\n  int v3; // esi\n  int v4; // ebx\n  int *v5; // ebp\n  const char *v6; // esi\n  char *v7; // eax\n  unsigned int v8; // eax\n  const char *v9; // eax\n  unsigned int v10; // eax\n  char *v11; // eax\n  unsigned int v12; // eax\n  int v13; // eax\n  int *v14; // [esp-4h] [ebp-50h]\n  int v15; // [esp-4h] [ebp-50h]\n  int v16[19]; // [esp+0h] [ebp-4Ch] BYREF\n\n  result = 0;\n  if ( (unsigned __int16)(*(_WORD *)(a2 + 4) - 40) <= 1u )\n  {\n    v3 = *(_DWORD *)a2 - 36;\n    if ( v3 < 0 )\n      return -1;\n    if ( !*(&buf + 1) || ((*(_DWORD *)(a2 + 24) ^ *(&buf + 1)) & 0xFFFF0000) == 0 )\n    {\n      v4 = a2;\n      v5 = v16;\n      memset(v16, 0, 0x3Cu);\n      sub_806901E(v3);\n      if ( !v16[1] )\n        return -1;\n      if ( *(_WORD *)(v4 + 4) == 41 )\n        printf(\"deleted \");\n      v6 = (const char *)(v16[1] + 4);\n      v7 = 0;\n      if ( *(_DWORD *)(v4 + 24) )\n      {\n        v8 = *(_DWORD *)(v4 + 28);\n        if ( *(&buf + 1) )\n          v8 = (unsigned __int16)v8;\n        v7 = sub_8061288(v8);\n      }\n      printf(\"class %s %s\", v6, v7);\n      if ( !buf )\n      {\n        v9 = (const char *)sub_80692E5();\n        printf(\"dev %s \", v9);\n      }\n      v10 = *(_DWORD *)(v4 + 28);\n      if ( v10 == -1 )\n      {\n        printf(\"root \");\n      }\n      else if ( v10 )\n      {\n        if ( *(&buf + 1) )\n          v10 = (unsigned __int16)v10;\n        v11 = sub_8061288(v10);\n        printf(\"parent %s \", v11);\n        v5 = v14;\n      }\n      v12 = *(_DWORD *)(v4 + 32);\n      if ( v12 )\n      {\n        printf(\"leaf %x \", HIWORD(v12));\n        v4 = v15;\n      }\n      if ( v16[2] )\n      {\n        v13 = sub_804D222(\"pfifo_fast\", v6);\n        if ( v13 )\n        {\n          if ( v13 == 1 )\n            sub_80612D1((unsigned __int16 *)v16[2], v4, (int)v5, (int)v6, v16[0]);\n          else\n            sub_804D5F4(\"unknown %s\", v6);\n        }\n      }\n      sub_804DD98(10);\n      return 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134617090": [
            "sub_8061802",
            "0x8061802",
            "int __cdecl sub_8061802(int a1, const char **a2)\n{\n  const char **v2; // ebx\n  int v3; // esi\n  const char *v4; // edx\n  int v5; // eax\n  int v6; // edi\n  const char *v7; // ebp\n  unsigned int v8; // eax\n  int *v9; // eax\n  char *v10; // eax\n  size_t v11; // eax\n  const char **v12; // eax\n  const char *v13; // ebp\n  size_t v14; // eax\n  size_t v15; // edi\n  unsigned int v16; // eax\n  void *v17; // edx\n  int v19; // [esp+0h] [ebp-54h]\n  int v20; // [esp+4h] [ebp-50h]\n  char *endptr[6]; // [esp+8h] [ebp-4Ch] BYREF\n\n  if ( !a2[1] || (sub_8068A5B(), v2 = a2 + 2, v3 = sub_804D254(\"qdisc\", a2[1]), v3 < 0) )\n    sub_804CDC2();\n  v4 = a2[2];\n  if ( v4 )\n  {\n    v19 = sub_804D254(\"add\", v4);\n    if ( v19 < 0 )\nLABEL_18:\n      sub_8069C50();\n    v2 = a2 + 3;\n  }\n  else\n  {\n    v19 = 5;\n  }\n  memset(&endptr[1], 0, 0x14u);\n  sub_8069345();\n  v20 = 0;\n  while ( *v2 )\n  {\n    v5 = sub_804D254(\"dev\", *v2);\n    v6 = v5;\n    if ( v5 )\n    {\n      if ( v5 == 3 )\n      {\n        if ( v3 != 1 || v19 <= 4 )\n        {\n          if ( !v3 )\n            goto LABEL_18;\nLABEL_34:\n          if ( v3 != 2 || v5 <= 5 )\n            goto LABEL_18;\n          goto LABEL_37;\n        }\n        goto LABEL_16;\n      }\n      if ( v5 == 4 )\n      {\n        if ( !v3 )\n        {\n          if ( v19 != 2 )\n            goto LABEL_18;\nLABEL_16:\n          v7 = *(const char **)sub_8069C3A();\n          if ( !strcmp(v7, \"none\") )\n          {\n            v11 = 0;\n          }\n          else\n          {\n            v8 = strtoul(v7, endptr, 16);\n            if ( v7 == endptr[0] )\n              goto LABEL_18;\n            v11 = v8 << 16;\n            if ( *endptr[0] != 58 )\n            {\n              if ( *endptr[0] )\n                goto LABEL_18;\n            }\n          }\n          *(&buf + 1) = v11;\n          goto LABEL_37;\n        }\n      }\n      else if ( !v3 )\n      {\n        goto LABEL_18;\n      }\n      if ( (unsigned int)(v5 - 1) > 1 )\n        goto LABEL_34;\n    }\n    else\n    {\n      v9 = (int *)sub_8069C3A();\n      if ( v20 )\n        sub_8069CE0();\n      v20 = *v9;\n      v10 = (char *)sub_806932A();\n      endptr[2] = v10;\n      if ( v19 > 4 )\n        buf = (size_t)v10;\n    }\nLABEL_37:\n    v12 = (const char **)sub_8069C3A();\n    v2 = v12;\n    if ( v6 == 1 )\n    {\n      if ( endptr[4] )\n        goto LABEL_69;\n      endptr[4] = (char *)-1;\n      if ( v3 == 2 )\n        *(&buf + 2) = -1;\n    }\n    else\n    {\n      v13 = *v12;\n      if ( v6 == 2 )\n      {\n        if ( endptr[4] )\n          goto LABEL_69;\n        if ( !strcmp(v13, \"root\") )\n        {\n          v14 = -1;\n        }\n        else if ( !strcmp(v13, \"none\") )\n        {\n          v14 = 0;\n        }\n        else\n        {\n          v14 = strtoul(v13, endptr, 16);\n          if ( endptr[0] == v13 )\n          {\n            if ( *endptr[0] != 58 )\n              goto LABEL_18;\n            v14 = 0;\n          }\n          if ( *endptr[0] == 58 )\n          {\n            if ( v14 > 0xFFFF )\n              goto LABEL_18;\n            v15 = v14 << 16;\n            v16 = strtoul(endptr[0] + 1, endptr, 16);\n            if ( *endptr[0] || v16 > 0xFFFF )\n              goto LABEL_18;\n            v14 = v15 | v16;\n          }\n          else if ( *endptr[0] )\n          {\n            goto LABEL_18;\n          }\n        }\n        endptr[4] = (char *)v14;\n        if ( v3 == 2 )\n          *(&buf + 2) = v14;\n      }\n      else if ( v6 == 4 )\n      {\n        if ( endptr[3] )\n          goto LABEL_69;\n        endptr[3] = (char *)sub_8069C92();\n      }\n      else if ( v3 != 1 || v19 != 2 || v6 != 5 )\n      {\n        if ( (unsigned int)(v6 - 6) > 1 )\n        {\n          if ( v6 == 8 )\n          {\n            if ( *(&buf + 4) )\nLABEL_69:\n              sub_8069CD4();\n            if ( sub_8069366() )\n              goto LABEL_18;\n            *(&buf + 4) = LOWORD(endptr[0]);\n          }\n        }\n        else\n        {\n          if ( *(&buf + 3) )\n            goto LABEL_69;\n          *(&buf + 3) = sub_8069C92();\n        }\n      }\n    }\n  }\n  if ( v19 > 4 )\n  {\n    if ( v3 == 2 )\n      endptr[5] = (char *)(*((unsigned __int16 *)&buf + 8) | (*(&buf + 3) << 16));\n    if ( (int)sub_8068B22(20) < 0 )\n      sub_804D3FF(\"can't send dump request\");\n    v17 = sub_80614D0;\n    if ( v3 )\n    {\n      v17 = sub_8061285;\n      if ( v3 == 1 )\n        v17 = sub_80616A5;\n    }\n    sub_8068BB1(0, v17);\n  }\n  return 0;\n}\n"
        ],
        "134618059": [
            "sub_8061BCB",
            "0x8061bcb",
            "char __usercall sub_8061BCB@<al>(char result@<al>)\n{\n  size_t v1; // edx\n\n  v1 = buf++;\n  byte_80DB814[v1] = result;\n  return result;\n}\n"
        ],
        "134618081": [
            "sub_8061BE1",
            "0x8061be1",
            "int sub_8061BE1()\n{\n  int result; // eax\n\n  result = sub_804E586(buf, byte_80DB814);\n  buf = 0;\n  return result;\n}\n"
        ],
        "134618113": [
            "sub_8061C01",
            "0x8061c01",
            "char __usercall sub_8061C01@<al>(__int16 a1@<ax>)\n{\n  if ( (int)buf > 125 )\n    sub_8061BE1();\n  sub_8061BCB(255);\n  sub_8061BCB(SHIBYTE(a1));\n  return sub_8061BCB(a1);\n}\n"
        ],
        "134618159": [
            "sub_8061C2F",
            "0x8061c2f",
            "int sub_8061C2F()\n{\n  int result; // eax\n\n  if ( *((_BYTE *)&buf + 8) )\n    return tcsetattr(0, 1, &termios_p);\n  return result;\n}\n"
        ],
        "134618186": [
            "sub_8061C4A",
            "0x8061c4a",
            "int sub_8061C4A()\n{\n  int result; // eax\n\n  if ( *((_BYTE *)&buf + 8) )\n    return tcsetattr(0, 1, &stru_80DB894);\n  return result;\n}\n"
        ],
        "134618213": [
            "sub_8061C65",
            "0x8061c65",
            "char sub_8061C65()\n{\n  char result; // al\n\n  result = *((_BYTE *)&buf + 6);\n  if ( (*((_BYTE *)&buf + 7) & 1) != 0 )\n  {\n    if ( !*((_BYTE *)&buf + 6) )\n    {\n      *((_BYTE *)&buf + 6) = 1;\n      printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"character\", 93);\n      return sub_8061C2F();\n    }\n  }\n  else if ( *((_BYTE *)&buf + 6) != 2 )\n  {\n    *((_BYTE *)&buf + 6) = 2;\n    printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"line\", 67);\n    return sub_8061C4A();\n  }\n  return result;\n}\n"
        ],
        "134618300": [
            "sub_8061CBC",
            "0x8061cbc",
            "void __spoils<edx,ecx> sub_8061CBC()\n{\n  __int16 v0; // ax\n  unsigned __int8 buf; // [esp+1h] [ebp-1h] BYREF\n\n  if ( byte_80DBBA4 )\n    sub_8061C2F();\n  sub_804D846(\n    \"\\r\\n\"\n    \"Console escape. Commands are:\\r\\n\"\n    \"\\n\"\n    \" l\\tgo to line mode\\r\\n\"\n    \" c\\tgo to character mode\\r\\n\"\n    \" z\\tsuspend telnet\\r\\n\"\n    \" e\\texit telnet\\r\\n\");\n  if ( read(0, &buf, 1u) <= 0 )\n  {\n    sub_8061C4A();\n    exit(1);\n  }\n  if ( buf == 101 )\n  {\n    sub_8061C4A();\n    exit(0);\n  }\n  if ( buf > 0x65u )\n  {\n    if ( buf == 108 )\n    {\n      if ( !byte_80DBBA4 )\n      {\n        *((_WORD *)&::buf + 3) &= 0xFC00u;\n        sub_8061C65();\n        sub_8061C01(65025);\n        v0 = -509;\nLABEL_16:\n        sub_8061C01(v0);\n        sub_8061BE1();\n        goto LABEL_20;\n      }\n    }\n    else if ( buf == 122 )\n    {\n      sub_8061C4A();\n      kill(0, 20);\n      sub_8061C2F();\n    }\n  }\n  else if ( buf == 99 && byte_80DBBA4 )\n  {\n    *((_BYTE *)&::buf + 6) = 0;\n    *((_BYTE *)&::buf + 7) |= 3u;\n    sub_8061C65();\n    sub_8061C01(64769);\n    v0 = -765;\n    goto LABEL_16;\n  }\n  sub_804D846(\"continuing...\\r\\n\");\n  if ( byte_80DBBA4 )\n    sub_8061C4A();\nLABEL_20:\n  byte_80DBBA4 = 0;\n}\n"
        ],
        "134618561": [
            "sub_8061DC1",
            "0x8061dc1",
            "unsigned int __usercall sub_8061DC1@<eax>(int a1@<eax>)\n{\n  unsigned int result; // eax\n  size_t *v2; // esi\n  char *v3; // ecx\n  char v4; // bl\n  char *v5; // edi\n  char v6[268]; // [esp+0h] [ebp-10Ch] BYREF\n\n  result = a1 + 135116692;\n  v2 = &buf + 7;\n  v3 = v6;\n  while ( (unsigned int)v2 < result )\n  {\n    v2 = (size_t *)((char *)v2 + 1);\n    v4 = *((_BYTE *)v2 - 1);\n    if ( v4 == 29 )\n    {\n      sub_8061CBC();\n      return result;\n    }\n    *v3 = v4;\n    v5 = v3 + 1;\n    if ( v4 == -1 )\n    {\n      v3[1] = -1;\n    }\n    else if ( v4 == 10 || v4 == 13 )\n    {\n      *(_WORD *)v3 = 2573;\n    }\n    else\n    {\n      v5 = v3;\n    }\n    v3 = v5 + 1;\n  }\n  if ( v6 != v3 )\n    return sub_804E586(v3 - v6, v6);\n  return result;\n}\n"
        ],
        "134618670": [
            "sub_8061E2E",
            "0x8061e2e",
            "void __cdecl __noreturn sub_8061E2E(int a1, int a2)\n{\n  _DWORD *v2; // ecx\n  _DWORD *v3; // esi\n  int v4; // eax\n  int v5; // eax\n  ssize_t v6; // esi\n  size_t v7; // ebx\n  size_t v8; // eax\n  unsigned __int8 v9; // dl\n  __int16 v10; // ax\n  __int16 v12; // ax\n  char v13; // al\n  bool v14; // zf\n  __int16 v15; // di\n  __int16 v16; // bp\n  char *v17; // edi\n  size_t v18; // eax\n  char v19; // al\n  size_t v20; // eax\n  char *i; // edi\n  char v22; // al\n  char *j; // edi\n  char v24; // al\n  size_t v25; // [esp+0h] [ebp-24h]\n  struct pollfd fds; // [esp+4h] [ebp-20h] BYREF\n  int v27; // [esp+Ch] [ebp-18h]\n  __int16 v28; // [esp+10h] [ebp-14h]\n  __int16 v29; // [esp+12h] [ebp-12h]\n\n  *(&buf + 3) = (size_t)getenv(\"TERM\");\n  if ( tcgetattr(0, &stru_80DB894) >= 0 )\n  {\n    *((_BYTE *)&buf + 8) = 1;\n    qmemcpy(&termios_p, &stru_80DB894, sizeof(termios_p));\n    cfmakeraw(&termios_p);\n  }\n  if ( sub_80ABEAC(a2, \"al:\", &buf + 4) == 1 )\n    *(&buf + 4) = (size_t)getenv(\"USER\");\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v2 )\n    goto LABEL_6;\n  v3 = v2 + 1;\n  if ( v2[1] )\n  {\n    v3 = v2 + 2;\n    sub_80B42FF(23, 135057932);\n  }\n  if ( *v3 )\nLABEL_6:\n    sub_804CDC2();\n  v4 = sub_80B4645();\n  sub_804DC97(v4, 3);\n  sub_80B4276();\n  sub_804D878(0, (int *)&buf + 5, (int *)&buf + 6);\n  signal(2, (__sighandler_t)sub_804E68E);\n  fds.fd = 0;\n  fds.events = 1;\n  v27 = 3;\n  v28 = 1;\n  while ( 1 )\n  {\n    do\n    {\n      while ( poll(&fds, 2u, -1) < 0 )\n      {\n        if ( byte_80DBBA4 )\n          sub_8061CBC();\n        else\n          sleep(1u);\n      }\n      if ( fds.revents )\n      {\n        v5 = sub_804E5BC(0x80u, &buf + 7, 0);\n        if ( v5 <= 0 )\n        {\n          sub_8061C4A();\n          exit(0);\n        }\n        sub_8061DC1(v5);\n      }\n    }\n    while ( !v29 );\n    v6 = sub_804E5BC(0x80u, &buf + 7, 3);\n    if ( v6 <= 0 )\n    {\n      sub_804D846(\"Connection closed by foreign host\\r\\n\");\n      sub_8061C4A();\n      exit(1);\n    }\n    v7 = 0;\n    v8 = 0;\n    do\n    {\n      v9 = *((_BYTE *)&buf + v8 + 28);\n      v25 = v8 + 1;\n      if ( *((_BYTE *)&buf + 4) )\n      {\n        switch ( *((_BYTE *)&buf + 4) )\n        {\n          case 1:\n            goto LABEL_30;\n          case 2:\n            if ( v9 == 0xFF )\n            {\n              *((_BYTE *)&buf + v7 + 28) = -1;\n              *((_BYTE *)&buf + 4) = 1;\n              ++v7;\n              goto LABEL_101;\n            }\n            if ( v9 == 0xFA )\n              goto LABEL_100;\n            if ( v9 < 0xFAu )\n              goto LABEL_99;\n            *((_BYTE *)&buf + 5) = *((_BYTE *)&buf + v8 + 28);\n            *((_BYTE *)&buf + 4) = 3;\n            goto LABEL_101;\n          case 3:\n            if ( v9 == 24 )\n            {\n              v10 = -1256;\n              if ( !*(&buf + 3) )\n                v10 = -1000;\n              goto LABEL_76;\n            }\n            if ( v9 > 0x18u )\n            {\n              if ( v9 == 31 )\n              {\n                sub_8061C01(64287);\n                v15 = *((_WORD *)&buf + 12);\n                v16 = *((_WORD *)&buf + 10);\n                if ( (int)buf > 119 )\n                  sub_8061BE1();\n                sub_8061BCB(255);\n                sub_8061BCB(250);\n                sub_8061BCB(31);\n                sub_8061BCB(SHIBYTE(v16));\n                sub_8061BCB(v16);\n                sub_8061BCB(SHIBYTE(v15));\n                sub_8061BCB(v15);\n                sub_8061BCB(255);\n                sub_8061BCB(240);\n                goto LABEL_99;\n              }\n              if ( v9 == 39 )\n              {\n                v10 = -1241;\n                if ( !*(&buf + 4) )\n                  v10 = -985;\n                goto LABEL_76;\n              }\n            }\n            else\n            {\n              if ( v9 == 1 )\n              {\n                v10 = -1023;\n                if ( *((_BYTE *)&buf + 5) != 0xFD )\n                {\n                  if ( *((_BYTE *)&buf + 5) != 0xFE\n                    && !((*((_BYTE *)&buf + 7) & 1) != 0 ? *((_BYTE *)&buf + 5) == 0xFB : *((_BYTE *)&buf + 5) == 0xFC) )\n                  {\n                    if ( *((_BYTE *)&buf + 6) != 2 )\n                      *((_BYTE *)&buf + 7) ^= 1u;\n                    v12 = -767;\n                    if ( (*((_BYTE *)&buf + 7) & 1) == 0 )\n                      v12 = -511;\n                    sub_8061C01(v12);\n                    sub_8061C65();\n                    sub_804D846((char *)\"\\r\\n\");\n                  }\n                  goto LABEL_99;\n                }\n                goto LABEL_76;\n              }\n              if ( v9 == 3 )\n              {\n                v13 = *((_BYTE *)&buf + 7);\n                if ( (*((_BYTE *)&buf + 7) & 2) != 0 )\n                  v14 = *((_BYTE *)&buf + 5) == 0xFB;\n                else\n                  v14 = *((_BYTE *)&buf + 5) == 0xFC;\n                if ( v14 )\n                  goto LABEL_99;\n                *((_BYTE *)&buf + 7) ^= 2u;\n                if ( (v13 & 2) != 0 )\n                  v10 = -509;\n                else\n                  v10 = -765;\n                goto LABEL_76;\n              }\n            }\n            if ( *((_BYTE *)&buf + 5) == 0xFB )\n            {\n              v10 = v9 - 512;\n            }\n            else\n            {\n              if ( *((_BYTE *)&buf + 5) != 0xFD )\n              {\nLABEL_99:\n                *((_BYTE *)&buf + 4) = 1;\n                goto LABEL_101;\n              }\n              v10 = v9 - 1024;\n            }\nLABEL_76:\n            sub_8061C01(v10);\n            goto LABEL_99;\n          case 4:\n          case 5:\n            if ( *((_BYTE *)&buf + 4) == 5 )\n            {\n              if ( v9 == 0xF0 )\n                goto LABEL_99;\nLABEL_100:\n              *((_BYTE *)&buf + 4) = 4;\n            }\n            else\n            {\n              if ( v9 == 0xFF )\n              {\n                *((_BYTE *)&buf + 4) = 5;\n                goto LABEL_101;\n              }\n              if ( v9 == 24 )\n              {\n                v17 = (char *)*(&buf + 3);\n                if ( !*(&buf + 3) )\n                  goto LABEL_101;\n                v18 = strlen((const char *)*(&buf + 3));\n                if ( !(((int)(v18 + buf - 122) < 0) ^ __OFADD__(-128, v18 + buf + 6) | (v18 + buf == 122)) )\n                  sub_8061BE1();\n                sub_8061BCB(255);\n                sub_8061BCB(250);\n                sub_8061BCB(24);\n                v19 = 0;\n                while ( 1 )\n                {\n                  sub_8061BCB(v19);\n                  v19 = *v17;\n                  if ( !*v17 )\n                    break;\n                  ++v17;\n                }\n                goto LABEL_97;\n              }\n              if ( v9 == 39 && *(&buf + 4) )\n              {\n                v20 = strlen((const char *)*(&buf + 4));\n                if ( !(((int)(v20 + buf - 122) < 0) ^ __OFADD__(-128, v20 + buf + 6) | (v20 + buf == 122)) )\n                  sub_8061BE1();\n                sub_8061BCB(255);\n                sub_8061BCB(250);\n                sub_8061BCB(39);\n                sub_8061BCB(0);\n                sub_8061BCB(0);\n                for ( i = \"USER\"; ; ++i )\n                {\n                  v22 = *i;\n                  if ( !*i )\n                    break;\n                  sub_8061BCB(v22);\n                }\n                sub_8061BCB(1);\n                for ( j = (char *)*(&buf + 4); ; ++j )\n                {\n                  v24 = *j;\n                  if ( !*j )\n                    break;\n                  sub_8061BCB(v24);\n                }\nLABEL_97:\n                sub_8061BCB(255);\n                sub_8061BCB(240);\n                goto LABEL_101;\n              }\n            }\n            goto LABEL_101;\n          case 6:\n            *((_BYTE *)&buf + 4) = 1;\n            if ( v9 )\n            {\nLABEL_30:\n              if ( v9 == 0xFF )\n              {\n                *((_BYTE *)&buf + 4) = 2;\n              }\n              else\n              {\n                *((_BYTE *)&buf + v7++ + 28) = v9;\n                if ( v9 == 13 )\n                  *((_BYTE *)&buf + 4) = 6;\n              }\n            }\n            goto LABEL_101;\n          default:\n            goto LABEL_101;\n        }\n      }\n      if ( v9 == 0xFF )\n      {\n        *((_BYTE *)&buf + 4) = 2;\n        v7 = v8;\n      }\n      else if ( v9 == 13 )\n      {\n        *((_BYTE *)&buf + 4) = 6;\n        v7 = v8 + 1;\n      }\nLABEL_101:\n      v8 = v25;\n    }\n    while ( v6 != v25 );\n    if ( !*((_BYTE *)&buf + 4) )\n    {\n      v7 = v6;\n      goto LABEL_110;\n    }\n    if ( buf )\n      sub_8061BE1();\n    if ( *((_BYTE *)&buf + 4) == 1 )\n      *((_BYTE *)&buf + 4) = 0;\n    if ( v7 )\nLABEL_110:\n      sub_804E586(v7, (char *)&buf + 28);\n  }\n}\n"
        ],
        "134620140": [
            "sub_80623EC",
            "0x80623ec",
            "unsigned int __usercall sub_80623EC@<eax>(const char *a1@<eax>, unsigned int a2@<edx>)\n{\n  unsigned int result; // eax\n\n  result = sub_804ED6C(10, a1, 0, (int)a1);\n  if ( *(_DWORD *)dword_80DBB7C || result <= 0x17 || a2 < result )\n  {\n    sub_804D5F4(\"bad blocksize '%s'\", a1);\n    return -1;\n  }\n  return result;\n}\n"
        ],
        "134620197": [
            "sub_8062425",
            "0x8062425",
            "int __cdecl sub_8062425(int a1, int a2)\n{\n  _DWORD *v2; // esi\n  int v3; // ebx\n  char *v4; // ebx\n  char *v5; // eax\n  int v6; // eax\n  int v7; // ecx\n  char *v8; // edi\n  char *v9; // esi\n  char *v10; // ebp\n  char *v11; // ebx\n  __int16 v12; // si\n  size_t v13; // eax\n  char *v14; // ebx\n  char *v15; // edi\n  int v16; // ebx\n  __int16 v17; // ax\n  int v18; // edi\n  ssize_t v19; // ebx\n  unsigned __int16 v20; // dx\n  int v21; // eax\n  bool v22; // zf\n  int v23; // ebx\n  const char *v24; // eax\n  int v25; // ebx\n  const char *v26; // edi\n  int v27; // edx\n  int v28; // ecx\n  int v29; // esi\n  int v30; // eax\n  int v31; // esi\n  __int16 v32; // ax\n  ssize_t v33; // eax\n  size_t v34; // ebx\n  size_t v35; // eax\n  signed int nbytes; // [esp+0h] [ebp-BCh]\n  unsigned int n; // [esp+4h] [ebp-B8h]\n  char *buf; // [esp+8h] [ebp-B4h]\n  socklen_t *addr_len; // [esp+Ch] [ebp-B0h]\n  size_t v41; // [esp+10h] [ebp-ACh]\n  __int16 v42; // [esp+10h] [ebp-ACh]\n  char v43; // [esp+17h] [ebp-A5h]\n  int v44; // [esp+18h] [ebp-A4h]\n  struct sockaddr *addr; // [esp+1Ch] [ebp-A0h]\n  char v46; // [esp+20h] [ebp-9Ch]\n  unsigned __int16 v47; // [esp+20h] [ebp-9Ch]\n  int v48; // [esp+24h] [ebp-98h]\n  int v49; // [esp+28h] [ebp-94h]\n  char v50; // [esp+2Ch] [ebp-90h]\n  int v51; // [esp+30h] [ebp-8Ch]\n  size_t v52; // [esp+34h] [ebp-88h]\n  char *name; // [esp+38h] [ebp-84h] BYREF\n  char *s; // [esp+3Ch] [ebp-80h] BYREF\n  const char *v55; // [esp+40h] [ebp-7Ch] BYREF\n  int fd; // [esp+44h] [ebp-78h]\n  __int16 v57; // [esp+48h] [ebp-74h]\n  char v58[44]; // [esp+4Ch] [ebp-70h] BYREF\n  __int64 v59; // [esp+78h] [ebp-44h]\n\n  name = 0;\n  s = 0;\n  v55 = \"512\";\n  v50 = sub_80ABEAC(a2, \"^gpl:r:b:\", &name, &s, &v55);\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  nbytes = sub_80623EC(v55, 0x1001Cu);\n  if ( nbytes < 0 )\n    return 1;\n  v4 = s;\n  if ( s )\n  {\n    if ( !name )\n    {\n      v5 = strrchr(s, 47);\n      if ( v5 )\n        v4 = v5 + 1;\n      name = v4;\n    }\n  }\n  else\n  {\n    s = name;\n  }\n  if ( !s || !*v2 )\n    sub_804CDC2();\n  v6 = sub_80B42FF(69, 135057961);\n  addr_len = (socklen_t *)sub_80B45BD(v7, v6);\n  v8 = s;\n  v9 = name;\n  n = nbytes + 4;\n  buf = (char *)sub_804DAFA(nbytes + 4);\n  v10 = (char *)sub_804DAFA(nbytes + 4);\n  fd = sub_804DF99(0, 2, *((unsigned __int16 *)addr_len + 2));\n  sub_80B4262();\n  v11 = buf + 2;\n  v44 = dword_80DBB9C & 1;\n  if ( *v9 != 45 || v9[1] )\n    v44 = sub_804DBE1(v9);\n  v12 = 1;\n  if ( (dword_80DBB9C & 1) == 0 )\n    v12 = 2;\n  v13 = strlen(v8);\n  v41 = v13 + 1;\n  if ( n <= v13 + 9\n    || (strcpy(v11, v8),\n        v14 = &v11[v41],\n        strcpy(v14, \"octet\"),\n        v15 = v14 + 6,\n        (unsigned int)(&buf[n - 1] - (v14 + 6)) <= 0x2C) )\n  {\n    sub_804D5F4(\"remote filename is too long\");\n    goto LABEL_92;\n  }\n  if ( nbytes != 512 )\n  {\n    strcpy(v14 + 6, \"blksize\");\n    v15 = &v14[snprintf(v14 + 14, 6u, \"%d\", nbytes) + 15];\n  }\n  strcpy(v15, \"tsize\");\n  v59 = 0LL;\n  fstat64(v44, v58);\n  v16 = (int)&v15[sprintf(v15 + 6, \"%llu\", v59) + 7];\n  v42 = 1;\n  v43 = 0;\n  v46 = 1;\n  v49 = 0;\n  while ( 2 )\n  {\n    LOBYTE(v17) = HIBYTE(v12);\n    HIBYTE(v17) = v12;\n    *(_WORD *)buf = v17;\n    v52 = v16 - (_DWORD)buf;\n    v51 = 12;\n    v18 = 100;\nLABEL_24:\n    addr = (struct sockaddr *)(addr_len + 1);\n    sub_804DFCD(v52, buf, fd, (struct sockaddr *)(addr_len + 1), *addr_len);\n    if ( v12 == 4 && (v43 & 1) != 0 )\n      return 0;\n    while ( 1 )\n    {\n      do\n      {\n        v57 = 1;\n        v21 = sub_80B2C0A(v18, 1u);\n        if ( !v21 )\n        {\n          if ( !--v51 )\n          {\n            sub_804D5F4(\"timeout\");\n            goto LABEL_86;\n          }\n          v18 += v18 >> 1;\n          if ( v18 > 2000 )\n            v18 = 2000;\n          goto LABEL_24;\n        }\n        if ( v21 != 1 )\n          goto LABEL_86;\n        if ( v49 )\n        {\n          v19 = sub_804E5BC(n, v10, fd);\n          if ( v19 < 0 )\n            goto LABEL_88;\n        }\n        else\n        {\n          v19 = recvfrom(fd, v10, n, 0, addr, addr_len);\n          if ( v19 < 0 )\n            goto LABEL_88;\n          sub_80B42C3(*addr_len, addr);\n          v49 = -1;\n        }\n      }\n      while ( v19 <= 3 );\n      v12 = __ROL2__(*(_WORD *)v10, 8);\n      HIBYTE(v20) = *((_WORD *)v10 + 1);\n      LOBYTE(v20) = HIBYTE(*((_WORD *)v10 + 1));\n      if ( v12 == 5 )\n      {\n        v22 = v19 == 4;\n        v23 = v20;\n        if ( v22 || !v10[4] )\n        {\n          v24 = &data;\n          if ( v20 <= 8u )\n            v24 = sub_804D2B4(byte_80CDE9D, v20);\n        }\n        else\n        {\n          v24 = v10 + 4;\n          v10[n - 1] = 0;\n        }\n        sub_804D5F4(\"server error: (%u) %s\", v23, v24);\nLABEL_86:\n        if ( v43 != 1 )\n          goto LABEL_92;\n        return 0;\n      }\n      if ( v46 )\n      {\n        if ( v12 != 6 )\n        {\n          n = 516;\n          if ( nbytes != 512 )\n          {\n            v47 = v20;\n            sub_804D5F4(\"falling back to blocksize 512\");\n            nbytes = 512;\n            v20 = v47;\n          }\n          goto LABEL_34;\n        }\n        v25 = v19 - 2;\n        v26 = v10 + 2;\n        v27 = 0;\n        v28 = 0;\n        while ( 2 )\n        {\n          v29 = 0;\n          while ( v26[v29] )\n          {\n            if ( ++v29 >= v25 )\n              goto LABEL_68;\n          }\n          if ( !v28 )\n          {\n            v48 = v27;\n            v30 = strcasecmp(v26, \"blksize\");\n            v28 = 0;\n            v27 = v48;\n            if ( !v30 )\n              v27 = 1;\n            goto LABEL_63;\n          }\n          if ( v27 )\n          {\n            nbytes = sub_80623EC(v26, nbytes);\n            if ( nbytes < 0 )\n            {\n              HIBYTE(::buf) = 8;\n              goto LABEL_89;\n            }\n            n = nbytes + 4;\n          }\n          else\n          {\nLABEL_63:\n            v31 = v29 + 1;\n            v26 += v31;\n            v25 -= v31;\n            v28 ^= 1u;\n            if ( v25 > 0 )\n              continue;\n          }\n          break;\n        }\nLABEL_68:\n        if ( (dword_80DBB9C & 1) != 0 )\n          v42 = 0;\n        goto LABEL_72;\n      }\nLABEL_34:\n      if ( ((unsigned __int8)dword_80DBB9C & (v12 == 3)) != 0 && v20 == v42 )\n        break;\n      if ( (dword_80DBB9C & 2) != 0 && v12 == 4 )\n      {\n        if ( v20 == v42 - 1 )\n        {\n          if ( (v43 & 1) == 0 )\n          {\n            v43 = 0;\n            goto LABEL_72;\n          }\n          return 0;\n        }\n        v12 = 4;\n      }\n      v46 = 0;\n    }\n    v34 = v19 - 4;\n    if ( v34 != sub_804E586(v34, v10 + 4) )\n    {\n      strcpy((char *)&::buf + 4, \"write error\");\n      HIBYTE(::buf) = 3;\n      goto LABEL_89;\n    }\n    if ( v34 != nbytes )\n      v43 = 1;\nLABEL_72:\n    LOBYTE(v32) = HIBYTE(v42);\n    HIBYTE(v32) = v42;\n    *((_WORD *)buf + 1) = v32;\n    v16 = (int)(buf + 4);\n    ++v42;\n    if ( (dword_80DBB9C & 2) == 0 )\n    {\n      v12 = 4;\nLABEL_78:\n      v46 = 0;\n      continue;\n    }\n    break;\n  }\n  v33 = sub_804E5E3(nbytes, buf + 4, v44);\n  if ( v33 >= 0 )\n  {\n    if ( nbytes != v33 )\n      v43 = 1;\n    v16 += v33;\n    v12 = 3;\n    goto LABEL_78;\n  }\nLABEL_88:\n  strcpy((char *)&::buf + 4, \"read error\");\nLABEL_89:\n  if ( *((_BYTE *)&::buf + 4) )\n    sub_804D5F4(\"%s\", (const char *)&::buf + 4);\n  BYTE1(::buf) = 5;\n  v35 = strlen((const char *)&::buf + 4);\n  sub_804DFCD(v35 + 5, &::buf, fd, addr, *addr_len);\nLABEL_92:\n  if ( *name != 45 || name[1] )\n  {\n    v3 = v50 & 1;\n    if ( (v50 & 1) != 0 )\n    {\n      unlink(name);\n      return v3;\n    }\n  }\n  return 1;\n}\n"
        ],
        "134621773": [
            "sub_8062A4D",
            "0x8062a4d",
            "int __cdecl sub_8062A4D(int a1, int a2)\n{\n  unsigned __int16 *v2; // ebp\n  int v3; // ecx\n  int v4; // ebx\n  int v5; // esi\n  int v6; // eax\n  int v7; // eax\n  int v8; // esi\n  __gid_t v9; // eax\n  __uid_t v10; // eax\n  const char *v11; // eax\n  int v12; // ebx\n  int v13; // esi\n  size_t v14; // edi\n  ssize_t v15; // eax\n  int i; // edi\n  int v17; // edx\n  int v18; // edx\n  char v19; // cl\n  bool v20; // zf\n  int v21; // edi\n  int v22; // eax\n  int v23; // edx\n  char v24; // t1\n  const char *v25; // eax\n  char *v26; // ebx\n  char *v27; // esi\n  int v29; // [esp+0h] [ebp-90h]\n  int v30; // [esp+4h] [ebp-8Ch]\n  _DWORD *v31; // [esp+8h] [ebp-88h]\n  int optval; // [esp+Ch] [ebp-84h]\n  int v33; // [esp+10h] [ebp-80h]\n  _BYTE *s2; // [esp+14h] [ebp-7Ch]\n  void *s2a; // [esp+14h] [ebp-7Ch]\n  int v36; // [esp+18h] [ebp-78h]\n  int v37; // [esp+1Ch] [ebp-74h]\n  int v38; // [esp+20h] [ebp-70h]\n  int v39; // [esp+24h] [ebp-6Ch]\n  int v40; // [esp+28h] [ebp-68h]\n  unsigned __int8 v41; // [esp+2Ch] [ebp-64h]\n  int v42; // [esp+30h] [ebp-60h]\n  int timeout; // [esp+34h] [ebp-5Ch]\n  int timeouta; // [esp+34h] [ebp-5Ch]\n  void *s1; // [esp+38h] [ebp-58h]\n  int v46; // [esp+3Ch] [ebp-54h]\n  void *v47; // [esp+40h] [ebp-50h]\n  int v48; // [esp+4Ch] [ebp-44h]\n  int v49; // [esp+4Ch] [ebp-44h]\n  const char *v50; // [esp+54h] [ebp-3Ch] BYREF\n  int v51; // [esp+58h] [ebp-38h] BYREF\n  int v52; // [esp+5Ch] [ebp-34h] BYREF\n  int v53; // [esp+60h] [ebp-30h] BYREF\n  int v54; // [esp+64h] [ebp-2Ch] BYREF\n  int v55; // [esp+68h] [ebp-28h] BYREF\n  int v56; // [esp+6Ch] [ebp-24h] BYREF\n  int v57; // [esp+70h] [ebp-20h] BYREF\n  int v58[2]; // [esp+74h] [ebp-1Ch] BYREF\n  __int16 v59; // [esp+7Ch] [ebp-14h]\n\n  v2 = (unsigned __int16 *)sub_804DB2E(0x220u);\n  dword_80DBB80 = (int)v2;\n  v2[12] = -32102;\n  *((_DWORD *)v2 + 7) = 5;\n  v30 = sub_80ABEAC(a2, \"^FIlnrdvxt:i:m:p:q:s:w:z:f:4\", &v52, &v51, &v53, &v54, &v55, &v50, &v56, &v57, v58);\n  v4 = a2 + 4 * optind;\n  if ( (v30 & 0x100) != 0 )\n    v5 = sub_80B40CC(255, 0);\n  else\n    v5 = 0;\n  v36 = 30;\n  if ( (v30 & 0x400) != 0 )\n    v36 = sub_80B40CC(255, 1);\n  if ( (v30 & 0x800) != 0 )\n    v2[12] = sub_80B4193();\n  v39 = 3;\n  if ( (v30 & 0x1000) != 0 )\n    v39 = sub_80B40CC(0x7FFFFFFF, 1);\n  if ( (v30 & 0x2000) != 0 && getuid() )\n    sub_804D5E0(\"you must be root\");\n  if ( (v30 & 0x4000) != 0 )\n    *((_DWORD *)v2 + 7) = sub_80B40CC(86400, 1);\n  v38 = 0;\n  if ( (v30 & 0x8000) != 0 )\n    v38 = sub_80B40CC(3600000, 0);\n  optval = 1;\n  if ( (v30 & 0x10000) != 0 )\n    optval = sub_80B40CC(v36, 1);\n  *((_DWORD *)v2 + 2) = sub_80B45BD(v3, v2[12]);\n  *((_DWORD *)v2 + 3) = 38;\n  if ( *(_DWORD *)(v4 + 4) )\n    *((_DWORD *)v2 + 3) = sub_80B40CC(0x8000, 38);\n  sub_80B3CDB();\n  v6 = sub_804DF99(1, 3, 2);\n  sub_804DC97(v6, 3);\n  if ( (v30 & 0x10) != 0 )\n    sub_80B4258();\n  v7 = sub_804DF99(0, 2, 2);\n  sub_804DC97(v7, 4);\n  if ( sub_80B424A(*((_DWORD *)v2 + 3), 7) )\n    sub_804D3C9((int)\"setsockopt(%s)\", \"SO_SNDBUF\");\n  if ( (v30 & 0x100) != 0 && sub_80B422B(1, 0, v5) )\n    sub_804D3C9((int)\"setsockopt(%s) %d\", \"TOS\", v5);\n  if ( (v30 & 0x10) != 0 )\n    sub_80B4258();\n  *(_DWORD *)v2 = sub_804DB2E(*((_DWORD *)v2 + 3));\n  *((_DWORD *)v2 + 5) = getpid();\n  *((_DWORD *)v2 + 1) = *(_DWORD *)v2 + 28;\n  if ( (v30 & 0x200) != 0 )\n    sub_80B4280();\n  if ( (v30 & 0x2000) != 0 )\n  {\n    v8 = sub_80B45C8();\n    if ( setsockopt(4, 0, 32, (const void *)(v8 + 4), *(_DWORD *)v8) )\n      sub_804D5E0(\"can't set multicast source interface\");\n    sub_804DFB3(*(_DWORD *)v8, (struct sockaddr *)(v8 + 4), 4);\n    free((void *)v8);\n  }\n  v9 = getgid();\n  sub_804DE5E(v9);\n  v10 = getuid();\n  sub_804DE74(v10);\n  v11 = (const char *)sub_80B46B6();\n  printf(\"traceroute to %s (%s)\", *(const char **)v4, v11);\n  if ( (v30 & 0x2000) != 0 )\n    printf(\" from %s\", v50);\n  printf(\", %d hops max, %d byte packets\\n\", v36, *((_DWORD *)v2 + 3));\n  v31 = sub_804DB8D(*((const void **)v2 + 2), **((_DWORD **)v2 + 2) + 4);\n  s1 = sub_804DB2E(**((_DWORD **)v2 + 2));\n  v47 = sub_804DB2E(**((_DWORD **)v2 + 2));\n  v40 = 0;\nLABEL_42:\n  if ( v36 >= optval )\n  {\n    printf(\"%2d\", optval);\n    v37 = 0;\n    v12 = 0;\n    v29 = 0;\n    v33 = v40;\n    while ( 1 )\n    {\nLABEL_44:\n      if ( v33 - v40 >= v39 )\n      {\n        sub_804DD98(10);\n        if ( !v37 && (!v29 || v29 < v39 - 1) )\n        {\n          ++optval;\n          v40 = v33;\n          goto LABEL_42;\n        }\n        return 0;\n      }\n      sub_804DD8F();\n      if ( v38 && v33 != v40 )\n        usleep(1000 * v38);\n      ++v33;\n      v13 = dword_80DBB80;\n      s2 = *(_BYTE **)(dword_80DBB80 + 4);\n      *s2 = v33;\n      s2[1] = optval;\n      if ( sub_80B422B(2, 0, optval) )\n        sub_804D3C9((int)\"setsockopt(%s) %d\", \"TTL\", optval);\n      sub_80B435E();\n      v14 = *(_DWORD *)v13 + *(_DWORD *)(v13 + 12) - (_DWORD)s2;\n      v15 = sub_804DFCD(v14, s2, 4, (struct sockaddr *)(*(_DWORD *)(v13 + 8) + 4), **(_DWORD **)(v13 + 8));\n      if ( v14 != v15 )\n        sub_804D5F4(\"sent %d octets, ret=%d\", v14, v15);\n      v46 = sub_804EBDE();\n      timeout = 1000 * *((_DWORD *)v2 + 7);\n      for ( i = v46; ; i = v42 )\n      {\n        v58[1] = 3;\n        v59 = 1;\n        if ( timeout < 0\n          || sub_80B2C0A(timeout, 1u) <= 0\n          || (s2a = v31 + 1,\n              v48 = sub_80B32E8(512, v13 + 32, 64, v31 + 1, v47, *v31),\n              v42 = sub_804EBDE(),\n              timeout -= (v42 - i) / 0x3E8u,\n              !v48) )\n        {\n          printf(\"  *\");\n          goto LABEL_44;\n        }\n        if ( v48 >= 0 )\n        {\n          v17 = 4 * (*(_BYTE *)(v13 + 32) & 0xF);\n          if ( v17 + 7 < v48 )\n            break;\n        }\nLABEL_103:\n        ;\n      }\n      v49 = v48 - v17;\n      v18 = v13 + 32 + v17;\n      v19 = *(_BYTE *)v18;\n      v41 = *(_BYTE *)(v18 + 1);\n      *(_DWORD *)(v13 + 16) = 0;\n      if ( v41 == 4 )\n      {\n        *(_DWORD *)(v13 + 16) = (unsigned __int16)__ROL2__(*(_WORD *)(v18 + 6), 8);\n        if ( v19 == 11 )\n          goto LABEL_103;\n      }\n      else if ( v19 == 11 )\n      {\n        v20 = v41 == 0;\n        goto LABEL_65;\n      }\n      if ( v19 == 3 )\n        goto LABEL_66;\n      v20 = v19 == 0;\nLABEL_65:\n      if ( !v20 )\n        goto LABEL_103;\nLABEL_66:\n      v21 = 4 * (*(_DWORD *)(v18 + 8) & 0xF);\n      v22 = v18 + v21 + 8;\n      if ( v49 <= v21 + 11 )\n        goto LABEL_103;\n      if ( *(_BYTE *)(v18 + 17) != 17 )\n        goto LABEL_103;\n      LOWORD(v18) = v33;\n      v23 = *(_DWORD *)(v13 + 24) + v18;\n      v24 = BYTE1(v23);\n      BYTE1(v23) = v23;\n      LOBYTE(v23) = v24;\n      if ( *(_WORD *)(v22 + 2) != (_WORD)v23 )\n        goto LABEL_103;\n      timeouta = -1;\n      if ( v19 != 11 )\n        timeouta = v41 + 1;\n      if ( !v12 || memcmp(s1, s2a, *v31) )\n      {\n        v25 = (const char *)sub_80B46B6();\n        v26 = (char *)v25;\n        if ( (dword_80DBB9C & 8) != 0 )\n        {\n          printf(\"  %s\", v25);\n        }\n        else\n        {\n          if ( *((_WORD *)v31 + 2) == 2 && !v31[2] )\n          {\n            v27 = 0;\n          }\n          else\n          {\n            v25 = (const char *)sub_80B46A2(v29);\n            v27 = (char *)v25;\n            if ( !v25 )\n              v25 = v26;\n          }\n          printf(\"  %s (%s)\", v25, v26);\n          free(v27);\n        }\n        free(v26);\n        qmemcpy(s1, s2a, *v31);\n      }\n      printf(\"  %u.%03u ms\", (v42 - v46) / 0x3E8u, (v42 - v46) % 0x3E8u);\n      if ( *((_WORD *)v31 + 2) == 2 && (v30 & 4) != 0 )\n        printf(\" (%d)\", *((unsigned __int8 *)v2 + 40));\n      v12 = 1;\n      if ( timeouta != -1 )\n      {\n        v12 = timeouta - 1;\n        switch ( timeouta )\n        {\n          case 1:\n            printf(\" !N\");\n            goto LABEL_100;\n          case 2:\n            printf(\" !H\");\n            ++v29;\n            continue;\n          case 3:\n            printf(\" !P\");\n            goto LABEL_104;\n          case 4:\n            if ( *((_BYTE *)v2 + 40) <= 1u )\n              printf(\" !\");\nLABEL_104:\n            v37 = 1;\n            break;\n          case 5:\n            printf(\" !F-%d\", *((_DWORD *)v2 + 4));\n            goto LABEL_102;\n          case 6:\n            printf(\" !S\");\n            goto LABEL_100;\n          case 7:\n          case 8:\n            printf(\" !U\");\n            goto LABEL_100;\n          case 9:\n            printf(\" !I\");\n            goto LABEL_100;\n          case 10:\n          case 14:\n            printf(\" !A\");\n            goto LABEL_100;\n          case 11:\n          case 16:\n            printf(\" !C\");\n            goto LABEL_100;\n          case 12:\n          case 13:\n            printf(\" !T\");\n            goto LABEL_100;\n          case 15:\n            printf(\" !V\");\nLABEL_100:\n            ++v29;\n            break;\n          default:\n            printf(\" !<%d>\", timeouta - 1);\nLABEL_102:\n            ++v29;\n            break;\n        }\n        v12 = 1;\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134623804": [
            "sub_806323C",
            "0x806323c",
            "unsigned __int8 *__usercall sub_806323C@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // eax\n\n  while ( strcasecmp(a2, a1 + 1) )\n  {\n    v4 = *(unsigned __int8 *)a1;\n    if ( !(_BYTE)v4 )\n      sub_804CDC2();\n    a1 += v4;\n  }\n  return (unsigned __int8 *)(a1 - 1);\n}\n"
        ],
        "134623848": [
            "sub_8063268",
            "0x8063268",
            "int __cdecl sub_8063268(int a1, int a2)\n{\n  const char *v2; // edx\n  unsigned __int8 *v3; // eax\n  int v4; // ecx\n  const char *v5; // edx\n  int v6; // eax\n  int v7; // eax\n  int v8; // eax\n  int v10[17]; // [esp+0h] [ebp-44h] BYREF\n\n  memset(v10, 0, 0x38u);\n  v2 = *(const char **)(a2 + 4);\n  if ( !v2 || (v3 = sub_806323C(\"\\aadd\", v2), v4 = *v3, v10[0] = v4, *(v3 - 1) != a1) )\n    sub_804CDC2();\n  v5 = *(const char **)(a2 + 8);\n  if ( v4 != 6 )\n  {\n    sub_804D67E((char *)&v10[1], v5);\n    switch ( v10[0] )\n    {\n      case 7:\n        v7 = sub_80B40CC(1, 0);\n        break;\n      case 0:\n        v6 = sub_80B40CC(4095, 0);\n        goto LABEL_10;\n      case 1:\n        goto LABEL_14;\n      default:\n        v7 = sub_80B40EC();\n        break;\n    }\n    v10[7] = v7;\n    LOWORD(v10[13]) = sub_80B40CC(7, 0);\n    goto LABEL_14;\n  }\n  v6 = *sub_806323C(byte_80CE019, v5);\nLABEL_10:\n  v10[7] = v6;\nLABEL_14:\n  v8 = sub_804DF99(0, 1, 2);\n  sub_804E029(v8, 0x8983u, (int)v10, \"ioctl error for %s\", *(const char **)(a2 + 4));\n  return 0;\n}\n"
        ],
        "134624064": [
            "sub_8063340",
            "0x8063340",
            "void sub_8063340()\n{\n  if ( *(_BYTE *)(dword_80DBB80 + 80) )\n    sub_804D5E0(\"download timed out\");\n}\n"
        ],
        "134624086": [
            "sub_8063356",
            "0x8063356",
            "int sub_8063356()\n{\n  int v0; // ebx\n  int result; // eax\n  int v2; // [esp-4h] [ebp-8h]\n\n  v0 = dword_80DBB80;\n  result = *(_DWORD *)(dword_80DBB80 + 76);\n  if ( result )\n  {\n    alarm(*(_DWORD *)(dword_80DBB80 + 76));\n    *(_BYTE *)(v0 + 80) = 1;\n    return v2;\n  }\n  return result;\n}\n"
        ],
        "134624113": [
            "sub_8063371",
            "0x8063371",
            "FILE *sub_8063371()\n{\n  int v0; // eax\n  FILE *result; // eax\n  int v2; // [esp-8h] [ebp-Ch]\n  int v3; // [esp-4h] [ebp-8h]\n\n  sub_8063356();\n  v0 = sub_80B467D();\n  *(_BYTE *)(dword_80DBB80 + 80) = 0;\n  result = fdopen(v0, \"r+\");\n  if ( !result )\n    sub_804DAC9(v3, v2);\n  return result;\n}\n"
        ],
        "134624164": [
            "sub_80633A4",
            "0x80633a4",
            "int __usercall sub_80633A4@<eax>(const char *a1@<eax>)\n{\n  int v1; // ebx\n\n  strlen(a1);\n  v1 = dword_80DBB80 + 104;\n  sub_80B3958(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\");\n  return v1;\n}\n"
        ],
        "134624217": [
            "sub_80633D9",
            "0x80633d9",
            "int __usercall sub_80633D9@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  int v4; // esi\n  int v5; // ebx\n  int v6; // edx\n  int v7; // ecx\n  int v8; // esi\n  unsigned __int8 *i; // eax\n  unsigned __int8 v10; // cl\n\n  sub_8063356();\n  v4 = dword_80DBB80;\n  v5 = dword_80DBB80 + 104;\n  if ( !fgets_unlocked(dword_80DBB80 + 104, 4096, a1) )\n    sub_804D3C9((int)\"error getting response\");\n  *(_BYTE *)(v4 + 80) = 0;\n  v8 = *(unsigned __int8 *)strchrnul(v7, v6, v5, 10);\n  for ( i = (unsigned __int8 *)v5; ; ++i )\n  {\n    v10 = *i;\n    if ( !*i )\n      break;\n    if ( v10 <= 0x1Fu )\n    {\n      if ( v10 != 9 )\n        break;\n      *i = 32;\n    }\n  }\n  *i = 0;\n  if ( a2 && (dword_80DBB9C & 4) != 0 )\n    fprintf(stderr, a2, v5);\n  return v8;\n}\n"
        ],
        "134624350": [
            "sub_806345E",
            "0x806345e",
            "int sub_806345E()\n{\n  int v0; // eax\n  int v2; // [esp-4h] [ebp-4h]\n\n  sub_804D5F4(\"restart failed\");\n  v0 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 8) = 0;\n  *(_DWORD *)(v0 + 12) = 0;\n  sub_804DD09(*(_DWORD *)(v0 + 84), 0, 0, 0);\n  return v2;\n}\n"
        ],
        "134624395": [
            "sub_806348B",
            "0x806348b",
            "const char *__usercall sub_806348B@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  char *v3; // esi\n  char *v4; // eax\n  char *v5; // edi\n  const char *v6; // edi\n  char *v7; // ebp\n  char *v8; // eax\n  char *v9; // esi\n  char *v10; // eax\n  char *v11; // eax\n  char *v12; // esi\n  const char *v13; // eax\n\n  free(*(void **)a2);\n  v3 = sub_804DB46(a1);\n  *(_DWORD *)a2 = v3;\n  *(_DWORD *)(a2 + 12) = \"ftp\";\n  v4 = strstr(v3, \"://\");\n  if ( !v4 )\n  {\n    *(_DWORD *)(a2 + 16) = v3;\nLABEL_5:\n    *(_DWORD *)(a2 + 20) = 80;\n    *(_DWORD *)(a2 + 12) = \"http\";\n    goto LABEL_8;\n  }\n  v5 = v4;\n  *v4 = 0;\n  *(_DWORD *)(a2 + 16) = v4 + 3;\n  if ( strcmp(v3, \"ftp\") )\n  {\n    if ( strcmp(v3, \"http\") )\n    {\n      *v5 = 58;\n      sub_804D5E0(\"not an http or ftp url: %s\", v3);\n    }\n    goto LABEL_5;\n  }\n  *(_DWORD *)(a2 + 20) = 21;\nLABEL_8:\n  v6 = *(const char **)(a2 + 16);\n  v7 = strchr(v6, 47);\n  v8 = strchr(v6, 63);\n  v9 = v8;\n  if ( v7 && (!v8 || v7 <= v8) )\n    v9 = v7;\n  v10 = strchr(v6, 35);\n  if ( v9 )\n  {\n    if ( !v10 || v9 <= v10 )\n      goto LABEL_19;\n  }\n  else if ( !v10 )\n  {\n    *(_DWORD *)(a2 + 4) = &data;\n    goto LABEL_20;\n  }\n  v9 = v10;\nLABEL_19:\n  *v9 = 0;\n  *(_DWORD *)(a2 + 4) = v9 + 1;\nLABEL_20:\n  v11 = strrchr(*(const char **)(a2 + 16), 64);\n  v12 = v11;\n  if ( v11 )\n  {\n    *v11 = 0;\n    free(*(void **)(a2 + 8));\n    v13 = (const char *)sub_80B0948();\n    *(_DWORD *)(a2 + 8) = sub_804DB46(v13);\n    *(_DWORD *)(a2 + 16) = v12 + 1;\n  }\n  return a1;\n}\n"
        ],
        "134624684": [
            "sub_80635AC",
            "0x80635ac",
            "int __usercall sub_80635AC@<eax>(int a1@<eax>)\n{\n  char v2; // al\n  int v3; // edx\n  char v4; // si\n  const char *v5; // edi\n  char v6; // bp\n  int v7; // ecx\n  int v8; // edi\n  bool j; // zf\n  unsigned __int8 *v10; // eax\n  int v11; // eax\n  _BYTE *i; // [esp+0h] [ebp-14h]\n\n  v2 = sub_80633D9(a1, \"  %s\\n\");\n  v3 = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 + 104) )\n    return 0;\n  v4 = v2;\n  v5 = (const char *)(dword_80DBB80 + 104);\n  for ( i = (_BYTE *)(dword_80DBB80 + 104); ; ++i )\n  {\n    LOBYTE(v3) = *i;\n    v6 = *i | 0x20;\n    if ( (unsigned __int8)(*i - 48) > 9u )\n    {\n      v7 = v3 - 45;\n      LOBYTE(v7) = (unsigned __int8)(v3 - 45) <= 1u;\n      if ( !((unsigned __int8)v7 | ((unsigned __int8)(v6 - 97) <= 0x19u)) && (_BYTE)v3 != 95 )\n        break;\n    }\n    *i = v6;\n  }\n  if ( (_BYTE)v3 != 58 )\n    sub_804D5E0(\"bad header line: %s\", v5);\n  *i = 0;\n  v8 = sub_80B2E8C(v7, v3);\n  for ( j = v4 == 10; !j; j = v11 == 10 )\n  {\n    v10 = *(unsigned __int8 **)(a1 + 16);\n    if ( (unsigned int)v10 >= *(_DWORD *)(a1 + 24) )\n    {\n      v11 = __fgetc_unlocked(a1);\n      if ( v11 == -1 )\n        return v8;\n    }\n    else\n    {\n      *(_DWORD *)(a1 + 16) = v10 + 1;\n      v11 = *v10;\n    }\n  }\n  return v8;\n}\n"
        ],
        "134624866": [
            "sub_8063662",
            "0x8063662",
            "ssize_t __usercall sub_8063662@<eax>(ssize_t result@<eax>, int a2@<ecx>)\n{\n  ssize_t v2; // ebp\n  int v3; // ebx\n  int v4; // esi\n  int v5; // edi\n  int v6; // edx\n  __int64 v7; // [esp+0h] [ebp-1Ch]\n\n  if ( (dword_80DBB9C & 2) == 0 )\n  {\n    v2 = result;\n    v3 = dword_80DBB80;\n    if ( result == -1 )\n      sub_80B123C(a2, *(_DWORD *)(dword_80DBB80 + 24));\n    v7 = *(_QWORD *)(v3 + 16);\n    v4 = 0;\n    v5 = 0;\n    if ( !*(_BYTE *)(v3 + 92) && *(_BYTE *)(v3 + 93) )\n    {\n      v5 = (unsigned __int64)(*(_QWORD *)v3 + *(_QWORD *)(v3 + 8) + v7) >> 32;\n      v4 = *(_DWORD *)v3 + *(_DWORD *)(v3 + 8) + v7;\n    }\n    result = sub_80B1258(v7, HIDWORD(v7), v4, v5);\n    if ( !v2 )\n    {\n      *(_DWORD *)(v3 + 44) = 0;\n      result = sub_804D830(10, v6);\n      *(_DWORD *)(v3 + 16) = 0;\n      *(_DWORD *)(v3 + 20) = 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134625028": [
            "sub_8063704",
            "0x8063704",
            "ssize_t __usercall sub_8063704@<eax>(FILE *a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // ecx\n  int v4; // ebx\n  signed int v5; // eax\n  int v6; // ecx\n  int v7; // edi\n  int v8; // ecx\n  __int64 v9; // kr00_8\n  int v10; // ebx\n  const char *v11; // edi\n  signed __int64 v12; // rax\n  int v13; // ebx\n  int v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  int v18; // [esp+0h] [ebp-20h]\n  void *v19; // [esp+4h] [ebp-1Ch]\n  int v20; // [esp+8h] [ebp-18h]\n\n  v2 = dword_80DBB80;\n  v18 = *(_DWORD *)(dword_80DBB80 + 76);\n  v20 = fileno_unlocked(a1);\n  sub_8063662(-1, v3);\n  if ( *(_BYTE *)(v2 + 92) )\n  {\nLABEL_23:\n    sub_80633D9((int)a1, 0);\n    *(_DWORD *)dword_80DBB7C = 0;\n    v10 = dword_80DBB80;\n    v11 = (const char *)(dword_80DBB80 + 104);\n    v12 = strtoull((const char *)(dword_80DBB80 + 104), 0, 16);\n    *(_QWORD *)v10 = v12;\n    if ( v12 < 0 || *(_DWORD *)dword_80DBB7C )\n      sub_804D5E0(\"bad chunk length '%s'\", v11);\n    if ( !v12 )\n      goto LABEL_28;\n    *(_BYTE *)(v10 + 93) = 1;\n  }\n  sub_804D61C(v20);\n  while ( 1 )\n  {\n    clearerr(a1);\n    *(_DWORD *)dword_80DBB7C = 0;\n    v4 = dword_80DBB80;\n    if ( *(_BYTE *)(dword_80DBB80 + 93) && (v5 = *(_DWORD *)dword_80DBB80, *(__int64 *)dword_80DBB80 <= 4095) )\n    {\n      if ( v5 <= 0 )\n        goto LABEL_21;\n    }\n    else\n    {\n      v5 = 4096;\n    }\n    v19 = (void *)(dword_80DBB80 + 104);\n    v7 = fread((void *)(dword_80DBB80 + 104), 1u, v5, a1);\n    if ( v7 <= 0 )\n      break;\n    sub_804DCAD(v7, v19);\n    *(_QWORD *)(v4 + 16) += v7;\n    if ( *(_BYTE *)(v4 + 93) )\n    {\n      v9 = *(_QWORD *)v4 - v7;\n      *(_QWORD *)v4 = v9;\n      v8 = v9 | HIDWORD(v9);\n      if ( !v9 )\n        goto LABEL_21;\n    }\n    v18 = *(_DWORD *)(v4 + 76);\nLABEL_20:\n    sub_8063662(1, v8);\n  }\n  if ( *(_DWORD *)dword_80DBB7C == 11 )\n  {\n    if ( !sub_80B2C0A(1000, 1u) )\n    {\n      if ( v18 )\n      {\n        if ( !--v18 )\n        {\n          sub_8063662(0, v8);\n          sub_804D5E0(\"download timed out\");\n        }\n      }\n    }\n    goto LABEL_20;\n  }\n  if ( (a1->_flags & 8) != 0 )\n  {\n    sub_8063662(0, v6);\n    sub_804D3C9((int)\"read error\");\n  }\nLABEL_21:\n  clearerr(a1);\n  sub_804D646(v20);\n  if ( *(_BYTE *)(v4 + 92) )\n  {\n    sub_80633D9((int)a1, 0);\n    goto LABEL_23;\n  }\nLABEL_28:\n  v13 = dword_80DBB80;\n  v14 = lseek64(*(_DWORD *)(dword_80DBB80 + 84), 0, 0, 1);\n  if ( v15 != -1 || v14 != -1 )\n    ftruncate64(*(_DWORD *)(v13 + 84), v14, v15);\n  *(_WORD *)(v13 + 92) = 256;\n  return sub_8063662(0, v16);\n}\n"
        ],
        "134625522": [
            "sub_80638F2",
            "0x80638f2",
            "int __usercall sub_80638F2@<eax>(FILE *stream@<ecx>, const char *a2@<eax>, const char *a3@<edx>)\n{\n  const char *v5; // ebx\n  int v6; // ebx\n  int result; // eax\n\n  if ( a2 )\n  {\n    v5 = a3;\n    if ( !a3 )\n      v5 = &data;\n    fprintf(stream, \"%s%s\\r\\n\", a2, v5);\n    if ( (dword_80DBB9C & 4) != 0 )\n      fprintf(stderr, \"--> %s%s\\n\\n\", a2, v5);\n    fflush(stream);\n  }\n  v6 = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + 107) = 0;\n  do\n  {\n    do\n      sub_80633D9((int)stream, \"%s\\n\");\n    while ( (unsigned __int8)(*(_BYTE *)(v6 + 104) - 48) > 9u );\n  }\n  while ( *(_BYTE *)(v6 + 107) != 32 );\n  *(_BYTE *)(v6 + 107) = 0;\n  result = sub_80B4187();\n  *(_BYTE *)(v6 + 107) = 32;\n  return result;\n}\n"
        ],
        "134625655": [
            "sub_8063977",
            "0x8063977",
            "int __cdecl sub_8063977(int a1, int a2)\n{\n  _DWORD *v2; // ebp\n  int v3; // esi\n  _BYTE *v4; // eax\n  int v5; // ebx\n  char *v6; // ebx\n  const char *v7; // eax\n  const char *v8; // esi\n  FILE *v9; // edi\n  const char *v10; // eax\n  int v11; // ebx\n  const char *v12; // eax\n  char *v13; // eax\n  char *v14; // edi\n  char *v15; // eax\n  char v16; // dl\n  char *v17; // eax\n  int v18; // ecx\n  char v19; // al\n  int v20; // eax\n  char *v21; // eax\n  int v22; // ecx\n  int v23; // eax\n  int v24; // edx\n  char *v25; // esi\n  FILE *v26; // eax\n  FILE *v27; // esi\n  const char *v28; // eax\n  const char *v29; // eax\n  const char *v30; // eax\n  int v31; // eax\n  const char *v32; // edi\n  size_t v33; // eax\n  int v34; // edx\n  int v35; // ecx\n  const char *v36; // eax\n  int v37; // eax\n  int v38; // eax\n  int v39; // edx\n  int v40; // ecx\n  const char *v41; // edi\n  _BYTE *i; // eax\n  int v43; // eax\n  __int64 v44; // rax\n  const char *v45; // eax\n  const char *v46; // ebx\n  char *v47; // eax\n  char *v48; // edx\n  int v49; // eax\n  int v50; // eax\n  int v51; // ebx\n  __int64 v52; // rax\n  int v53; // ebx\n  int v54; // eax\n  int v56; // [esp+4h] [ebp-68h]\n  char ptr; // [esp+8h] [ebp-64h]\n  void *ptra; // [esp+8h] [ebp-64h]\n  int v59; // [esp+Ch] [ebp-60h]\n  int v60; // [esp+Ch] [ebp-60h]\n  char *v61; // [esp+Ch] [ebp-60h]\n  char *v62; // [esp+10h] [ebp-5Ch]\n  char v63; // [esp+17h] [ebp-55h]\n  char *v64; // [esp+18h] [ebp-54h]\n  const char **v65; // [esp+1Ch] [ebp-50h]\n  const char *v66; // [esp+20h] [ebp-4Ch]\n  int v67; // [esp+24h] [ebp-48h]\n  int v68; // [esp+28h] [ebp-44h] BYREF\n  void *v69; // [esp+2Ch] [ebp-40h] BYREF\n  void *v70; // [esp+34h] [ebp-38h]\n  const char *v71; // [esp+38h] [ebp-34h]\n  const char *v72; // [esp+3Ch] [ebp-30h]\n  int v73; // [esp+40h] [ebp-2Ch]\n  void *v74; // [esp+44h] [ebp-28h] BYREF\n  char *v75; // [esp+48h] [ebp-24h]\n  char *v76; // [esp+4Ch] [ebp-20h]\n  const char *v77; // [esp+50h] [ebp-1Ch]\n  char *s; // [esp+54h] [ebp-18h]\n  int v79; // [esp+58h] [ebp-14h]\n\n  v68 = 0;\n  v2 = sub_804DB2E(0x1068u);\n  dword_80DBB80 = (int)v2;\n  v2[19] = 900;\n  signal(14, (__sighandler_t)sub_8063340);\n  v2[17] = \"on\";\n  v2[18] = \"Wget\";\n  sub_80ABEC2(a2, \"^cqSO:P:Y:U:T:+t:n::\", \"continue\", v2 + 16, v2 + 12, v2 + 17, v2 + 18, v2 + 19, 0, 0, &v68, v2 + 13);\n  v65 = (const char **)(a2 + 4 * optind);\n  v3 = v68;\n  if ( v68 )\n  {\n    v5 = 0;\n    do\n    {\n      v5 += strlen(*(const char **)(v3 + 4)) + 2;\n      v3 = *(_DWORD *)v3;\n    }\n    while ( v3 );\n    v6 = (char *)sub_804DAFA(v5 + 1);\n    v2[14] = v6;\n    while ( v68 )\n    {\n      v7 = (const char *)sub_80AFB01();\n      v59 = sprintf(v6, \"%s\\r\\n\", v7);\n      v8 = \"Host:\";\n      ptr = 1;\n      while ( *v8 )\n      {\n        if ( strstr(v6, v8) == v6 )\n        {\n          *((_BYTE *)v2 + 60) |= ptr;\n          break;\n        }\n        ptr *= 2;\n        v8 += strlen(v8) + 1;\n      }\n      v6 += v59;\n    }\n  }\n  v2[21] = -1;\n  v2[22] = 705;\n  v4 = (_BYTE *)v2[16];\n  if ( v4 )\n  {\n    if ( *v4 == 45 && !v4[1] )\n    {\n      v2[21] = 1;\n      dword_80DBB9C &= ~1u;\n    }\n    v2[22] = 577;\n  }\n  while ( 1 )\n  {\n    v10 = *v65;\n    if ( !*v65 )\n      break;\n    ++v65;\n    v69 = 0;\n    v74 = 0;\n    v70 = 0;\n    v76 = 0;\n    sub_806348B(v10, (int)&v74);\n    v11 = dword_80DBB80;\n    if ( !strcmp(*(const char **)(dword_80DBB80 + 68), \"off\") )\n      goto LABEL_29;\n    v12 = \"http_proxy\";\n    if ( *v77 == 102 )\n      v12 = \"ftp_proxy\";\n    v13 = getenv(v12);\n    if ( v13 && *v13 )\n    {\n      sub_806348B(v13, (int)&v69);\n      v63 = 1;\n    }\n    else\n    {\nLABEL_29:\n      v71 = v77;\n      v73 = v79;\n      v69 = sub_804DB46(s);\n      v72 = (const char *)v69;\n      v63 = 0;\n    }\n    v14 = s;\n    if ( *s == 91 )\n    {\n      if ( strchr(s, 37) )\n      {\n        v15 = strchr(v14, 93);\n        if ( v15 )\n        {\n          v16 = v15[1];\n          if ( !v16 || v16 == 58 )\n            sub_80B2C69(v56, v15);\n        }\n      }\n    }\n    v62 = 0;\n    if ( (dword_80DBB9C & 8) == 0 )\n    {\n      v17 = sub_804D32D(v75);\n      *(_DWORD *)(v11 + 64) = v17;\n      v19 = *v17;\n      if ( !v19 || v19 == 47 )\n        *(_DWORD *)(v11 + 64) = \"index.html\";\n      v20 = *(_DWORD *)(v11 + 48);\n      if ( v20 )\n        v21 = (char *)sub_804D2D1(v20, *(_BYTE **)(v11 + 64), v18);\n      else\n        v21 = sub_804DB46(*(const char **)(v11 + 64));\n      v62 = v21;\n      *(_DWORD *)(v11 + 64) = v21;\n    }\n    *(_DWORD *)(v11 + 24) = sub_804D32D(*(const char **)(v11 + 64));\n    *(_DWORD *)(v11 + 8) = 0;\n    *(_DWORD *)(v11 + 12) = 0;\n    if ( (dword_80DBB9C & 1) != 0 )\n    {\n      v23 = open64(*(_DWORD *)(v11 + 64));\n      *(_DWORD *)(v11 + 84) = v23;\n      if ( v23 >= 0 )\n      {\n        *(_DWORD *)(v11 + 8) = sub_804DD09(v23, 0, 0, 2);\n        *(_DWORD *)(v11 + 12) = v24;\n      }\n    }\n    v64 = 0;\n    v67 = 5;\n    while ( 1 )\n    {\n      ptra = (void *)sub_80B45BD(v22, v73);\n      if ( (dword_80DBB9C & 2) == 0 )\n      {\n        v25 = (char *)sub_80B46AC();\n        fprintf(stderr, \"Connecting to %s (%s)\\n\", v72, v25);\n        free(v25);\n      }\nLABEL_50:\n      *(_WORD *)(v11 + 92) = 0;\n      if ( !v63 && *v77 == 102 )\n        break;\n      v26 = sub_8063371();\n      v27 = v26;\n      if ( v63 )\n      {\n        fprintf(v26, \"GET %s://%s/%s HTTP/1.1\\r\\n\", v77, s, v75);\n      }\n      else\n      {\n        v28 = \"BLKRAGET\" + 5;\n        if ( (dword_80DBB9C & 0x800) != 0 )\n          v28 = \"POST\";\n        fprintf(v27, \"%s /%s HTTP/1.1\\r\\n\", v28, v75);\n      }\n      if ( (*(_BYTE *)(v11 + 60) & 1) == 0 )\n        fprintf(v27, \"Host: %s\\r\\n\", s);\n      if ( (*(_BYTE *)(v11 + 60) & 2) == 0 )\n        fprintf(v27, \"User-Agent: %s\\r\\n\", *(const char **)(v11 + 72));\n      fputs(\"Connection: close\\r\\n\", v27);\n      if ( v76 && (*(_BYTE *)(v11 + 60) & 8) == 0 )\n      {\n        v29 = (const char *)sub_80633A4(v76);\n        fprintf(v27, \"Authorization: Basic %s\\r\\n\", v29);\n      }\n      if ( v63 && v70 && (*(_BYTE *)(v11 + 60) & 0x10) == 0 )\n      {\n        v30 = (const char *)sub_80633A4((const char *)v70);\n        fprintf(v27, \"Proxy-Authorization: Basic %s\\r\\n\", v30);\n      }\n      if ( *(_QWORD *)(v11 + 8) && (*(_BYTE *)(v11 + 60) & 4) == 0 )\n        fprintf(v27, \"Range: bytes=%llu-\\r\\n\", *(_QWORD *)(v11 + 8));\n      v31 = *(_DWORD *)(v11 + 56);\n      if ( v31 )\n        fputs_unlocked(v31, v27);\n      if ( (dword_80DBB9C & 0x800) != 0 )\n      {\n        v32 = *(const char **)(v11 + 52);\n        v33 = strlen(v32);\n        fprintf(v27, \"Content-Type: application/x-www-form-urlencoded\\r\\nContent-Length: %u\\r\\n\\r\\n%s\", v33, v32);\n      }\n      else\n      {\n        fputs(\"\\r\\n\", v27);\n      }\n      fflush(v27);\n      while ( 1 )\n      {\n        sub_80633D9((int)v27, \"  %s\\n\");\n        v66 = (const char *)(v11 + 104);\n        sub_80B2E9F();\n        v36 = (const char *)sub_80B2E8C(v35, v34);\n        v37 = atoi(v36);\n        v60 = v37;\n        if ( v37 > 204 )\n        {\n          if ( v37 == 206 )\n          {\n            if ( *(_QWORD *)(v11 + 8) )\n              goto LABEL_94;\n          }\n          else if ( v37 >= 206 && (unsigned int)(v37 - 300) <= 3 )\n          {\n            goto LABEL_94;\n          }\nLABEL_91:\n          sub_804D5E0(\"server returned error: %s\", v66);\n        }\n        if ( v37 >= 200 )\n          break;\n        if ( v37 && v37 != 100 )\n          goto LABEL_91;\n        while ( sub_80635AC((int)v27) )\n          ;\n      }\n      if ( *(_QWORD *)(v11 + 8) )\n        sub_806345E();\n      do\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\nLABEL_94:\n            v38 = sub_80635AC((int)v27);\n            v41 = (const char *)v38;\n            if ( !v38 )\n            {\n              v9 = v27;\n              goto LABEL_19;\n            }\n            for ( i = (_BYTE *)strchrnul(v40, v39, v38, 0); v41 <= --i && (*i == 9 || *i == 32); *i = 0 )\n              ;\n            v43 = sub_804D222(\"content-length\", v66) + 1;\n            if ( (_BYTE)v43 != 1 )\n              break;\n            v44 = sub_804EC9E(v41, 0, 10);\n            *(_QWORD *)v11 = v44;\n            if ( v44 < 0 || *(_DWORD *)dword_80DBB7C )\n              sub_804D5E0(\"content-length %s is garbage\", v41);\n            *(_BYTE *)(v11 + 93) = 1;\n          }\n          if ( (_BYTE)v43 != 2 )\n            break;\n          v45 = (const char *)sub_80B2F23();\n          if ( strcmp(v45, \"chunked\") )\n            sub_804D5E0(\"transfer encoding '%s' is not supported\", v41);\n          *(_BYTE *)(v11 + 92) = 1;\n        }\n      }\n      while ( (_BYTE)v43 != 3 || v60 <= 299 );\n      if ( !--v67 )\n        sub_804D5E0(\"too many redirections\");\n      fclose(v27);\n      if ( *v41 == 47 )\n      {\n        free(v64);\n        v64 = sub_804DB46(v41 + 1);\n        v75 = v64;\n        goto LABEL_50;\n      }\n      sub_806348B(v41, (int)&v74);\n      if ( v63 )\n        goto LABEL_50;\n      free(v69);\n      v69 = 0;\n      v71 = v77;\n      v72 = s;\n      v73 = v79;\n      free(ptra);\n    }\n    v27 = sub_8063371();\n    if ( sub_80638F2(v27, 0, 0) != 220 )\n      sub_804D5E0(\"%s\", dword_80DBB80 + 104);\n    v46 = \"busybox\";\n    if ( v76 )\n    {\n      v47 = strchr(v76, 58);\n      v46 = v47;\n      if ( v47 )\n      {\n        *v47 = 0;\n        v46 = v47 + 1;\n      }\n    }\n    v48 = v76;\n    if ( !v76 )\n      v48 = \"anonymous\";\n    v49 = sub_80638F2(v27, \"USER \", v48);\n    if ( v49 != 230 && (v49 != 331 || sub_80638F2(v27, \"PASS \", v46) != 230) )\n      sub_804D5E0(\"ftp login: %s\", dword_80DBB80 + 104);\n    sub_80638F2(v27, \"TYPE I\", 0);\n    v50 = sub_80638F2(v27, \"SIZE \", v75);\n    v51 = dword_80DBB80;\n    if ( v50 == 213 )\n    {\n      v52 = sub_804EC9E((const char *)(dword_80DBB80 + 108), 0, 10);\n      *(_QWORD *)v51 = v52;\n      if ( v52 < 0 || *(_DWORD *)dword_80DBB7C )\n        sub_804D5E0(\"bad SIZE value '%s'\", v51 + 108);\n      *(_BYTE *)(v51 + 93) = 1;\n    }\n    if ( sub_80638F2(v27, \"EPSV\", 0) != 229 && sub_80638F2(v27, \"PASV\", 0) != 227\n      || (v61 = (char *)(v51 + 104), sub_806427C() < 0) )\n    {\n      sub_804D5E0(\"bad response to %s: %s\", \"PASV\", (const char *)(v51 + 104));\n    }\n    sub_80B435E();\n    v9 = sub_8063371();\n    if ( *(_QWORD *)(v51 + 8) )\n    {\n      sprintf(v61, \"REST %llu\", *(_QWORD *)(v51 + 8));\n      if ( sub_80638F2(v27, (const char *)(v51 + 104), 0) == 350 )\n        *(_QWORD *)v51 -= *(_QWORD *)(v51 + 8);\n      else\n        sub_806345E();\n    }\n    if ( sub_80638F2(v27, \"RETR \", v75) > 150 )\n      sub_804D5E0(\"bad response to %s: %s\", \"RETR\", v61);\nLABEL_19:\n    free(ptra);\n    if ( (dword_80DBB9C & 0x1000) == 0 )\n    {\n      v53 = dword_80DBB80;\n      if ( *(int *)(dword_80DBB80 + 84) < 0 )\n        *(_DWORD *)(v53 + 84) = sub_804DBE1(*(const char **)(dword_80DBB80 + 64));\n      sub_8063704(v9);\n      if ( (dword_80DBB9C & 8) == 0 )\n      {\n        sub_804DCF3(*(_DWORD *)(v53 + 84));\n        *(_DWORD *)(v53 + 84) = -1;\n      }\n    }\n    if ( v27 != v9 )\n    {\n      fclose(v9);\n      if ( sub_80638F2(v27, 0, 0) != 226 )\n        sub_804D5E0(\"ftp error: %s\", dword_80DBB80 + 104);\n    }\n    fclose(v27);\n    free(v69);\n    free(v74);\n    free(v70);\n    free(v76);\n    free(v62);\n    free(v64);\n  }\n  v54 = v2[21];\n  if ( v54 >= 0 )\n    sub_804DCF3(v54);\n  return 0;\n}\n"
        ],
        "134627964": [
            "sub_806427C",
            "0x806427c",
            "int __usercall sub_806427C@<eax>(int a1@<eax>)\n{\n  char *v2; // eax\n  char *v3; // eax\n  int v5; // esi\n  char *v6; // eax\n  char *v7; // eax\n  char *v8; // eax\n\n  if ( *(_BYTE *)(a1 + 2) == 55 )\n  {\n    v2 = strrchr((const char *)a1, 41);\n    if ( v2 )\n      *v2 = 0;\n    v3 = strrchr((const char *)a1, 44);\n    if ( v3 )\n    {\n      *v3 = 0;\n      v5 = sub_80B40CC(255, 0);\n      v6 = strrchr((const char *)a1, 44);\n      if ( v6 )\n      {\n        *v6 = 0;\n        return v5 + (sub_80B40CC(255, 0) << 8);\n      }\n    }\n    return -1;\n  }\n  v7 = strrchr((const char *)a1, 124);\n  if ( !v7 )\n    return -1;\n  *v7 = 0;\n  v8 = strrchr((const char *)a1, 124);\n  if ( !v8 )\n    return -1;\n  *v8 = 0;\n  return sub_80B40CC(0xFFFF, 0);\n}\n"
        ],
        "134628117": [
            "sub_8064315",
            "0x8064315",
            "int __usercall sub_8064315@<eax>(int a1@<eax>)\n{\n  _BYTE *v2; // eax\n  const char *v3; // edx\n  int v4; // esi\n  int v5; // eax\n  const char *v6; // edx\n  int v7; // eax\n\n  while ( 1 )\n  {\n    v2 = *(_BYTE **)a1;\n    if ( !*(_DWORD *)a1 || *v2 != 45 )\n      break;\n    v3 = v2 + 1;\n    v4 = a1 + 4;\n    if ( v2[1] == 45 )\n    {\n      v3 = v2 + 2;\n      if ( !v2[2] )\n      {\n        a1 += 4;\n        break;\n      }\n    }\n    v5 = sub_804D254(\"oneline\", v3);\n    if ( v5 < 0 )\n      goto LABEL_7;\n    v6 = *(const char **)(a1 + 4);\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        if ( !v6 )\nLABEL_7:\n          sub_804CDC2();\n        v7 = sub_804D222(\"inet\", v6);\n        if ( v7 < 0 )\n          sub_8069C50();\n      }\n      else\n      {\n        v7 = v5 - 2;\n        v4 = a1;\n      }\n      byte_80DB764 = byte_80CE4F7[v7];\n      v4 += 4;\n    }\n    else\n    {\n      byte_80DBBA6 = 1;\n    }\n    a1 = v4;\n  }\n  byte_80DBBA5 = byte_80DBBA6 == 0 ? 10 : 92;\n  return a1;\n}\n"
        ],
        "134628274": [
            "sub_80643B2",
            "0x80643b2",
            "int __fastcall sub_80643B2(_DWORD *a1, _DWORD *a2)\n{\n  char *v3; // ebx\n\n  v3 = (char *)sub_804DB2E(*a2 + 4);\n  qmemcpy(v3 + 4, a2, *a2);\n  while ( *a1 )\n    a1 = (_DWORD *)*a1;\n  *a1 = v3;\n  sub_80691EB(0);\n  return 0;\n}\n"
        ],
        "134628351": [
            "sub_80643FF",
            "0x80643ff",
            "int sub_80643FF()\n{\n  if ( sub_8068AAE(*(&buf + 7)) >= 0 )\n  {\n    *(&buf + 7) = 0;\n    return 0;\n  }\n  else\n  {\n    sub_804D3A5((int)\"can't send flush request\");\n    return -1;\n  }\n}\n"
        ],
        "134628405": [
            "sub_8064435",
            "0x8064435",
            "int __fastcall sub_8064435(int a1, int a2)\n{\n  int v2; // ecx\n  size_t v3; // ebp\n  int v5; // eax\n  const char *v6; // eax\n  _DWORD *v7; // eax\n  int v8; // edx\n  const char *v9; // eax\n  char v10; // al\n  int v11; // ecx\n  FILE *v12; // esi\n  int v13; // eax\n  int v14; // edi\n  const char *v15; // eax\n  const char *v16; // eax\n  const char *v17; // eax\n  const char *v18; // eax\n  char v19; // al\n  char v20; // al\n  char v21; // al\n  char v22; // al\n  int v23; // esi\n  char *v24; // eax\n  int v26; // [esp-8h] [ebp-BCh]\n  int v27; // [esp-4h] [ebp-B8h]\n  unsigned __int16 *v28; // [esp+4h] [ebp-B0h]\n  unsigned __int16 *v29; // [esp+8h] [ebp-ACh]\n  int v30; // [esp+Ch] [ebp-A8h]\n  int v31; // [esp+10h] [ebp-A4h]\n  int v32; // [esp+14h] [ebp-A0h]\n  int v33; // [esp+18h] [ebp-9Ch]\n  char dest[144]; // [esp+24h] [ebp-90h] BYREF\n\n  v2 = *(_DWORD *)(a2 + 4);\n  if ( (unsigned __int16)(v2 - 20) > 1u )\n    return 0;\n  v5 = *(_DWORD *)a2 - 24;\n  if ( v5 < 0 )\n  {\n    sub_804D5F4(\"wrong nlmsg len %d\", v5);\n    return -1;\n  }\n  if ( *(&buf + 1) && (_WORD)v2 != 20 )\n    return 0;\n  sub_806901E(v5);\n  if ( !v29 )\n    v29 = v28;\n  if ( !v28 )\n    v28 = v29;\n  if ( *(&buf + 9) && *(&buf + 9) != *(_DWORD *)(a2 + 20) )\n    return 0;\n  if ( ((*(&buf + 3) ^ *(unsigned __int8 *)(a2 + 19)) & *(&buf + 4)) != 0 )\n    return 0;\n  v3 = *(&buf + 6) & (*(&buf + 5) ^ *(unsigned __int8 *)(a2 + 18));\n  if ( v3 )\n    return 0;\n  if ( buf )\n  {\n    v6 = (const char *)(v30 ? v30 + 4 : sub_80692E5());\n    if ( fnmatch((const char *)buf, v6, 0) )\n      return 0;\n  }\n  if ( !*((_BYTE *)&buf + 48)\n    || !v29\n    || (memset(dest, 0, 0x14u),\n        dest[0] = *(_BYTE *)(a2 + 16),\n        qmemcpy(&dest[4], v29 + 2, *v29 - 4),\n        !sub_8069CEC(*((__int16 *)&buf + 25), &buf + 12)) )\n  {\n    if ( *(&buf + 1) )\n    {\n      if ( *(_DWORD *)a2 + ((*(&buf + 7) + 3) & 0xFFFFFFFC) <= *(&buf + 8) || !sub_80643FF() )\n      {\n        v7 = (_DWORD *)(*(&buf + 1) + ((*(&buf + 7) + 3) & 0xFFFFFFFC));\n        qmemcpy(v7, (const void *)a2, *(_DWORD *)a2);\n        v7[1] = 65557;\n        v8 = *(_DWORD *)(*(&buf + 2) + 28) + 1;\n        *(_DWORD *)(*(&buf + 2) + 28) = v8;\n        v7[2] = v8;\n        *(&buf + 7) = (size_t)v7 + *(_DWORD *)a2 - *(&buf + 1);\n        *((_BYTE *)&buf + 44) = 1;\n        return v3;\n      }\n      return -1;\n    }\n    if ( *(_WORD *)(a2 + 4) == 21 )\n      printf(\"Deleted \");\n    if ( *((_BYTE *)&buf + 42) )\n    {\n      v9 = (const char *)sub_80692E5();\n      printf(\"%u: %s\", *(_DWORD *)(a2 + 20), v9);\n    }\n    v10 = *(_BYTE *)(a2 + 16);\n    if ( v10 == 2 )\n    {\n      printf(\"    inet \");\n    }\n    else\n    {\n      if ( v10 != 10 )\n      {\n        printf(\"    family %d \", *(unsigned __int8 *)(a2 + 16));\n        goto LABEL_40;\n      }\n      printf(\"    inet6 \");\n    }\n    v11 = v27;\nLABEL_40:\n    if ( v29 )\n    {\n      v12 = stdout;\n      v13 = ((int (*)(void))sub_8069D47)();\n      fputs_unlocked(v13, v12);\n      v14 = *(unsigned __int8 *)(a2 + 17);\n      if ( v28 && memcmp(v28 + 2, v29 + 2, 4u) )\n      {\n        v15 = (const char *)((int (*)(void))sub_8069D47)();\n        printf(\" peer %s/%d \", v15, v14);\n      }\n      else\n      {\n        printf(\"/%d \", v14);\n        v11 = v26;\n      }\n    }\n    if ( v31 )\n    {\n      v16 = (const char *)sub_8069D47(v11, v31 + 4);\n      printf(\"brd %s \", v16);\n    }\n    if ( v32 )\n    {\n      v17 = (const char *)sub_8069D47(v11, v32 + 4);\n      printf(\"any %s \", v17);\n    }\n    v18 = (const char *)sub_8069664();\n    printf(\"scope %s \", v18);\n    v19 = *(_BYTE *)(a2 + 18);\n    if ( (v19 & 1) != 0 )\n    {\n      *(_BYTE *)(a2 + 18) = v19 & 0xFE;\n      printf(\"secondary \");\n    }\n    v20 = *(_BYTE *)(a2 + 18);\n    if ( (v20 & 0x40) != 0 )\n    {\n      *(_BYTE *)(a2 + 18) = v20 & 0xBF;\n      printf(\"tentative \");\n    }\n    v21 = *(_BYTE *)(a2 + 18);\n    if ( (v21 & 0x20) != 0 )\n    {\n      *(_BYTE *)(a2 + 18) = v21 & 0xDF;\n      printf(\"deprecated \");\n    }\n    v22 = *(_BYTE *)(a2 + 18);\n    if ( v22 < 0 )\n      *(_BYTE *)(a2 + 18) = v22 & 0x7F;\n    else\n      printf(\"dynamic \");\n    if ( *(_BYTE *)(a2 + 18) )\n      printf(\"flags %02x \", *(unsigned __int8 *)(a2 + 18));\n    if ( v30 )\n      fputs_unlocked(v30 + 4, stdout);\n    if ( v33 )\n    {\n      sub_804DD98((unsigned __int8)byte_80DBBA5);\n      if ( *(_DWORD *)(v33 + 8) == -1 )\n        strcpy(dest, \"valid_lft forever\");\n      else\n        sprintf(dest, \"valid_lft %dsec\", *(_DWORD *)(v33 + 8));\n      v23 = *(_DWORD *)(v33 + 4);\n      v24 = &dest[strlen(dest)];\n      if ( v23 == -1 )\n        strcpy(v24, \" preferred_lft forever\");\n      else\n        sprintf(v24, \" preferred_lft %dsec\", v23);\n      printf(\"       %s\", dest);\n    }\n    sub_804DD98(10);\n  }\n  return v3;\n}\n"
        ],
        "134629433": [
            "sub_8064839",
            "0x8064839",
            "int __usercall sub_8064839@<eax>(int *a1@<eax>)\n{\n  int v2; // edx\n  int result; // eax\n  int v4; // edx\n  int v5; // esi\n  const char *v6; // eax\n  int v7; // edi\n  int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  const char *v11; // eax\n  int v12; // esi\n  const char *v13; // eax\n  FILE *v14; // edi\n  int v15; // eax\n  FILE *v16; // edi\n  int v17; // eax\n  int v18; // [esp-8h] [ebp-124h]\n  int v19; // [esp-4h] [ebp-120h]\n  int v20; // [esp-4h] [ebp-120h]\n  int v21[16]; // [esp+4h] [ebp-118h] BYREF\n  unsigned __int16 *v22; // [esp+48h] [ebp-D4h]\n  unsigned __int16 *v23; // [esp+4Ch] [ebp-D0h]\n  int v24; // [esp+50h] [ebp-CCh]\n  int v25; // [esp+54h] [ebp-C8h]\n  int v26; // [esp+58h] [ebp-C4h]\n  int v27; // [esp+5Ch] [ebp-C0h]\n  int v28; // [esp+6Ch] [ebp-B0h]\n\n  v2 = *a1;\n  if ( (unsigned __int16)(*((_WORD *)a1 + 2) - 16) <= 1u )\n  {\n    result = -1;\n    v4 = v2 - 32;\n    if ( v4 < 0 )\n      return result;\n    if ( (!*(&buf + 9) || *(&buf + 9) == a1[5]) && (!*((_BYTE *)&buf + 43) || (a1[6] & 1) != 0) )\n    {\n      sub_806901E(v4);\n      if ( !v24 )\n      {\n        sub_804D5F4(\"nil ifname\");\n        return -1;\n      }\n      if ( !buf\n        || *((_BYTE *)&buf + 40) && *((_BYTE *)&buf + 40) != 17\n        || !fnmatch((const char *)buf, (const char *)(v24 + 4), 0) )\n      {\n        if ( *((_WORD *)a1 + 2) == 17 )\n          printf(\"Deleted \");\n        printf(\"%d: %s\", a1[5], (const char *)(v24 + 4));\n        if ( v26 )\n        {\n          v5 = *(_DWORD *)(v26 + 4);\n          if ( v5 )\n          {\n            v6 = (const char *)((int (*)(void))sub_80692E5)();\n            printf(\"@%s: \", v6);\n            v5 = (sub_8069313() & 1) == 0;\n          }\n          else\n          {\n            printf(\"@NONE: \");\n          }\n        }\n        else\n        {\n          printf(\": \");\n          v5 = 0;\n        }\n        v7 = a1[6];\n        sub_804DD98(60);\n        if ( (v7 & 0x41) == 1 )\n          printf(\"NO-CARRIER,\");\n        v8 = sub_80B0AB7(v7 & 0xFFFFFFBF, \"LOOPBACK\", 135036660);\n        if ( v8 )\n          printf(\"%x\", v8);\n        if ( v5 )\n          printf(\",M-DOWN\");\n        printf(\"> \");\n        if ( v25 )\n        {\n          printf(\"mtu %u \", *(_DWORD *)(v25 + 4));\n          v10 = v18;\n        }\n        if ( v27 )\n        {\n          printf(\"qdisc %s \", (const char *)(v27 + 4));\n          v9 = v19;\n        }\n        if ( v28 )\n        {\n          v11 = (const char *)sub_80692E5(v10, v9);\n          printf(\"master %s \", v11);\n        }\n        if ( *((_BYTE *)&buf + 41) )\n        {\n          v12 = socket(2, 1, 0);\n          if ( v12 >= 0 )\n          {\n            memset(v21, 0, 0x20u);\n            sub_804D67E((char *)v21, (const char *)(v24 + 4));\n            if ( sub_804E09D(v12, 0x8942u, (int)v21, \"SIOCGIFTXQLEN\") >= 0 )\n            {\n              close(v12);\n              v10 = v20;\n              if ( v21[4] )\n                printf(\"qlen %d\", v21[4]);\n            }\n            else\n            {\n              close(v12);\n            }\n          }\n        }\n        if ( !*((_BYTE *)&buf + 40) || *((_BYTE *)&buf + 40) == 17 )\n        {\n          v13 = (const char *)sub_80693D1(v10, v21);\n          printf(\"%c    link/%s \", (unsigned __int8)byte_80DBBA5, v13);\n          if ( v22 )\n          {\n            v14 = stdout;\n            v15 = sub_806907E(*((unsigned __int16 *)a1 + 9), *v22 - 4, v21, 64);\n            fputs_unlocked(v15, v14);\n          }\n          if ( v23 )\n          {\n            if ( (a1[6] & 0x10) != 0 )\n              printf(\" peer \");\n            else\n              printf(\" brd \");\n            v16 = stdout;\n            v17 = sub_806907E(*((unsigned __int16 *)a1 + 9), *v23 - 4, v21, 64);\n            fputs_unlocked(v17, v16);\n          }\n        }\n        sub_804DD98(10);\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134630220": [
            "sub_8064B4C",
            "0x8064b4c",
            "unsigned int __usercall sub_8064B4C@<eax>(int a1@<eax>, __int16 a2@<dx>, const char **a3@<ecx>)\n{\n  int v4; // esi\n  char *v5; // ebp\n  int v6; // eax\n  unsigned int v7; // edx\n  const char *v8; // edi\n  size_t v9; // eax\n  int v10; // edx\n  char v11; // al\n  int i; // esi\n  unsigned __int32 v13; // eax\n  char v14; // al\n  int v16; // [esp+4h] [ebp-190h]\n  char *v17; // [esp+8h] [ebp-18Ch]\n  int v18; // [esp+Ch] [ebp-188h]\n  int v20; // [esp+14h] [ebp-180h]\n  char v21; // [esp+1Bh] [ebp-179h]\n  int v22; // [esp+1Ch] [ebp-178h]\n  __int16 v23[10]; // [esp+20h] [ebp-174h] BYREF\n  __int16 v24[10]; // [esp+34h] [ebp-160h] BYREF\n  int v25[9]; // [esp+48h] [ebp-14Ch] BYREF\n  int v26[74]; // [esp+6Ch] [ebp-128h] BYREF\n\n  memset(v26, 0, 0x118u);\n  v26[0] = 24;\n  HIWORD(v26[1]) = a2 | 1;\n  LOWORD(v26[1]) = a1;\n  LOBYTE(v26[4]) = byte_80DB764;\n  v21 = 0;\n  v20 = 0;\n  v16 = 0;\n  v4 = 0;\n  v18 = 0;\n  v5 = 0;\n  v17 = 0;\n  while ( *a3 )\n  {\n    v6 = sub_804D222(\"peer\", *a3);\n    v7 = v6;\n    if ( v6 >= 0 )\n    {\n      v22 = v6;\n      a3 = (const char **)sub_8069C3A();\n      v7 = v22;\n    }\n    v8 = *a3;\n    if ( v7 > 1 )\n    {\n      if ( v7 <= 3 )\n      {\n        if ( v16 )\n          goto LABEL_12;\n        if ( *v8 == 43 )\n        {\n          v16 = -1;\nLABEL_17:\n          if ( !v8[1] )\n            goto LABEL_39;\n        }\n        else if ( *v8 == 45 )\n        {\n          v16 = -2;\n          goto LABEL_17;\n        }\n        sub_8069A87(LOBYTE(v26[4]), v8);\n        if ( !LOBYTE(v26[4]) )\n          LOBYTE(v26[4]) = v25[0];\n        sub_8068F90(&v25[1], BYTE1(v25[0]));\n        v16 = BYTE1(v25[0]);\n        goto LABEL_39;\n      }\n      switch ( v7 )\n      {\n        case 4u:\n          if ( v20 )\nLABEL_12:\n            sub_8069CD4();\n          sub_8069A87(LOBYTE(v26[4]), v8);\n          if ( !LOBYTE(v26[4]) )\n            LOBYTE(v26[4]) = v25[0];\n          sub_8068F90(&v25[1], BYTE1(v25[0]));\n          v20 = BYTE1(v25[0]);\n          break;\n        case 5u:\n          v25[0] = 0;\n          if ( sub_806968A() )\n            sub_8069C50();\n          HIBYTE(v26[4]) = v25[0];\n          v21 = 1;\n          break;\n        case 6u:\n          v17 = (char *)*a3;\n          break;\n        case 7u:\n          v9 = strlen(*a3);\n          sub_8068F90(v8, v9 + 1);\n          v5 = (char *)v8;\n          break;\n        default:\n          if ( v18 )\n            sub_8069CE0();\n          sub_8069AC1(LOBYTE(v26[4]), v8);\n          if ( !LOBYTE(v26[4]) )\n            LOBYTE(v26[4]) = v23[0];\n          sub_8068F90(&v23[2], HIBYTE(v23[0]));\n          v18 = HIBYTE(v23[0]);\n          break;\n      }\n    }\n    else\n    {\n      if ( v4 )\n        goto LABEL_12;\n      sub_8069AC1(LOBYTE(v26[4]), *a3);\n      v4 = HIBYTE(v24[0]);\n      if ( !LOBYTE(v26[4]) )\n        LOBYTE(v26[4]) = v24[0];\n      sub_8068F90(&v24[2], HIBYTE(v24[0]));\n      BYTE1(v26[4]) = v24[1];\n    }\nLABEL_39:\n    ++a3;\n  }\n  if ( !v17 )\n    sub_804D5E0(\"need \\\"dev IFACE\\\"\");\n  if ( v5 && !sub_804D210(v5, v17) )\n    sub_804D5E0(\"\\\"dev\\\" (%s) must match \\\"label\\\" (%s)\", v17, v5);\n  if ( v4 == 0 && v18 != 0 && a1 != 21 )\n  {\n    qmemcpy(v24, v23, sizeof(v24));\n    sub_8068F90(&v23[2], HIBYTE(v23[0]));\n  }\n  if ( !BYTE1(v26[4]) )\n    BYTE1(v26[4]) = v23[1];\n  if ( v16 >= 0 )\n  {\nLABEL_64:\n    if ( !v21 && a1 != 21 )\n    {\n      v14 = 0;\n      if ( LOBYTE(v23[0]) == 2 && HIBYTE(v23[0]) )\n        v14 = LOBYTE(v23[2]) != 127 ? 0 : 0xFE;\n      HIBYTE(v26[4]) = v14;\n    }\n  }\n  else if ( a1 != 21 )\n  {\n    if ( LOBYTE(v26[4]) != 2 )\n      sub_804D5E0(\"broadcast can be set only for IPv4 addresses\");\n    qmemcpy(v25, v24, 0x14u);\n    if ( SHIWORD(v25[0]) <= 30 )\n    {\n      v10 = v25[1];\n      v11 = 0;\n      for ( i = 31; SHIWORD(v25[0]) <= i; --i )\n      {\n        v13 = _byteswap_ulong(1 << (31 - i));\n        if ( v16 == -1 )\n          v10 |= v13;\n        else\n          v10 &= ~v13;\n        v11 = 1;\n      }\n      if ( v11 )\n        v25[1] = v10;\n      sub_8068F90(&v25[1], BYTE1(v25[0]));\n    }\n    goto LABEL_64;\n  }\n  sub_8068A5B();\n  sub_8069345();\n  v26[5] = sub_806932A();\n  return 2 * ((unsigned int)sub_8068D41(0, v26) >> 31);\n}\n"
        ],
        "134631317": [
            "sub_8064F95",
            "0x8064f95",
            "int __usercall sub_8064F95@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char **v2; // ebx\n  const char *v3; // eax\n  const char *v4; // esi\n  char v5; // al\n  int *v6; // ebp\n  int j; // ebx\n  int v8; // edx\n  int v9; // ecx\n  const char *v10; // eax\n  _DWORD *k; // ebp\n  int v12; // ebx\n  int v13; // esi\n  int v15; // [esp-4h] [ebp-E60h]\n  int v16; // [esp+0h] [ebp-E5Ch]\n  int *i; // [esp+4h] [ebp-E58h]\n  _BOOL4 v18; // [esp+8h] [ebp-E54h]\n  _DWORD *v19; // [esp+Ch] [ebp-E50h] BYREF\n  int v20[6]; // [esp+10h] [ebp-E4Ch] BYREF\n  char v21; // [esp+28h] [ebp-E34h] BYREF\n  int v22[2]; // [esp+4Ch] [ebp-E10h] BYREF\n  unsigned __int16 *v23; // [esp+54h] [ebp-E08h]\n  int v24; // [esp+58h] [ebp-E04h]\n\n  v2 = a1;\n  v16 = a2;\n  v19 = 0;\n  v20[0] = 0;\n  memset(&buf, 0, 0x44u);\n  *((_BYTE *)&buf + 42) = byte_80DBBA6;\n  *((_BYTE *)&buf + 41) = 1;\n  *((_BYTE *)&buf + 40) = byte_80DB764;\n  v3 = *a1;\n  if ( a2 )\n  {\n    if ( !v3 )\n      sub_804D5E0(\"%s requires an argument\", \"flush\");\n    if ( *((_BYTE *)&buf + 40) == 17 )\n      sub_804D5E0(\"can't flush link addresses\");\n  }\n  v4 = 0;\n  while ( *v2 )\n  {\n    v5 = sub_804D222(\"to\", *v2);\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        v22[0] = 0;\n        v2 = (const char **)sub_8069C3A();\n        *(&buf + 4) = -1;\n        if ( sub_806968A() )\n        {\n          if ( strcmp(*v2, \"all\") )\n            sub_8069C50(v15, \"scope\");\n          v22[0] = 255;\n          *(&buf + 4) = 0;\n        }\n        *(&buf + 3) = v22[0];\n      }\n      else if ( v5 == 2 )\n      {\n        *((_BYTE *)&buf + 43) = 1;\n      }\n      else if ( v5 == 3 )\n      {\n        v2 = (const char **)sub_8069C3A();\n        buf = (size_t)*v2;\n      }\n      else\n      {\n        if ( v5 == 4 )\n          v2 = (const char **)sub_8069C3A();\n        if ( v4 )\n          sub_8069CE0();\n        v4 = *v2;\n      }\n    }\n    else\n    {\n      v2 = (const char **)sub_8069C3A();\n      sub_8069AC1(*((char *)&buf + 40), *v2);\n      if ( !*((_BYTE *)&buf + 40) )\n        *((_BYTE *)&buf + 40) = *((_BYTE *)&buf + 48);\n    }\n    ++v2;\n  }\n  sub_8068A5B();\n  sub_8068AE2(18, byte_80DB764);\n  sub_8068BB1(&v19, sub_80643B2);\n  if ( v4 )\n    *(&buf + 9) = sub_806932A();\n  if ( v16 )\n  {\n    *(&buf + 1) = (size_t)v22;\n    *(_QWORD *)(&buf + 7) = 0xE0000000000LL;\n    *(&buf + 2) = (size_t)&v21;\n    while ( 1 )\n    {\n      sub_8068AE2(22, *((char *)&buf + 40));\n      *((_BYTE *)&buf + 44) = 0;\n      sub_8068BB1(0, sub_8064435);\n      if ( !*((_BYTE *)&buf + 44) )\n        break;\n      if ( sub_80643FF() < 0 )\n        return 1;\n    }\n    return 0;\n  }\n  else\n  {\n    if ( *((_BYTE *)&buf + 40) != 17 )\n    {\n      sub_8068AE2(22, *((char *)&buf + 40));\n      sub_8068BB1(v20, sub_80643B2);\n    }\n    if ( *((_BYTE *)&buf + 40) == 17 || !*((_BYTE *)&buf + 40) )\n    {\n      v18 = 0;\n    }\n    else\n    {\n      v18 = *((_BYTE *)&buf + 42) != 0;\nLABEL_40:\n      for ( i = (int *)&v19; ; *i = *v6 )\n      {\n        v6 = (int *)*i;\n        if ( !*i )\n          break;\n        for ( j = v20[0]; j; j = *(_DWORD *)j )\n        {\n          if ( *(_DWORD *)(j + 24) == v6[6]\n            && (!*((_BYTE *)&buf + 40) || *((char *)&buf + 40) == *(unsigned __int8 *)(j + 20))\n            && ((*(&buf + 3) ^ *(unsigned __int8 *)(j + 23)) & *(&buf + 4)) == 0\n            && ((*(&buf + 5) ^ *(unsigned __int8 *)(j + 22)) & *(&buf + 6)) == 0 )\n          {\n            if ( !*((_BYTE *)&buf + 48) && !buf )\n              goto LABEL_60;\n            sub_806901E(*(_DWORD *)(j + 4) - 24);\n            if ( !v23 )\n              v23 = (unsigned __int16 *)v22[1];\n            if ( !*((_BYTE *)&buf + 48)\n              || !v23\n              || (memset(&v20[1], 0, 0x14u),\n                  LOBYTE(v20[1]) = *(_BYTE *)(j + 20),\n                  qmemcpy(&v20[2], v23 + 2, *v23 - 4),\n                  !sub_8069CEC(*((__int16 *)&buf + 25), &buf + 12)) )\n            {\n              if ( !buf\n                || (!v24 ? (v10 = (const char *)sub_80692E5(v9, v8)) : (v10 = (const char *)(v24 + 4)),\n                    !fnmatch((const char *)buf, v10, 0)) )\n              {\nLABEL_60:\n                i = v6;\n                goto LABEL_40;\n              }\n            }\n          }\n        }\n      }\n    }\n    for ( k = v19; k; k = (_DWORD *)*k )\n    {\n      if ( (v18 || byte_80DBBA6 || !sub_8064839(k + 1)) && *((_BYTE *)&buf + 40) != 17 )\n      {\n        v12 = v20[0];\n        v13 = k[6];\n        while ( v12 )\n        {\n          if ( *(_WORD *)(v12 + 8) == 20 )\n          {\n            if ( *(_DWORD *)(v12 + 4) <= 0x13u )\n              break;\n            if ( *(_DWORD *)(v12 + 24) == v13\n              && (!*((_BYTE *)&buf + 40) || *((char *)&buf + 40) == *(unsigned __int8 *)(v12 + 20)) )\n            {\n              sub_8064435(0, v12 + 4);\n            }\n          }\n          v12 = *(_DWORD *)v12;\n        }\n      }\n    }\n  }\n  return v16;\n}\n"
        ],
        "134632433": [
            "sub_80653F1",
            "0x80653f1",
            "int __usercall sub_80653F1@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  __int16 v4; // dx\n  int v5; // eax\n\n  v1 = a1;\n  if ( *a1 )\n  {\n    v2 = sub_804D254(\"add\", *a1);\n    if ( v2 < 0 )\n      sub_8069C50(v3, ident);\n    ++v1;\n    if ( v2 <= 4 )\n    {\n      if ( v2 )\n      {\n        if ( (unsigned int)(v2 - 1) <= 1 )\n        {\n          v4 = 256;\n        }\n        else\n        {\n          v4 = 0;\n          if ( v2 == 3 )\n          {\n            v4 = 1280;\nLABEL_15:\n            v5 = 20;\n            return sub_8064B4C(v5, v4, v1);\n          }\n        }\n        v5 = (v2 == 4) + 20;\n        return sub_8064B4C(v5, v4, v1);\n      }\n      v4 = 1536;\n      goto LABEL_15;\n    }\n  }\n  else\n  {\n    v2 = 2;\n  }\n  return sub_8064F95(v1, v2 == 8);\n}\n"
        ],
        "134632563": [
            "sub_8065473",
            "0x8065473",
            "int sub_8065473()\n{\n  int result; // eax\n\n  result = socket(2, 2, 0);\n  if ( result < 0 )\n  {\n    result = socket(17, 2, 0);\n    if ( result < 0 )\n      return sub_804DF99(0, 2, 10);\n  }\n  return result;\n}\n"
        ],
        "134632617": [
            "sub_80654A9",
            "0x80654a9",
            "int __fastcall sub_80654A9(int a1, int a2)\n{\n  int result; // eax\n  int v3; // [esp+0h] [ebp-454h] BYREF\n  int v4[267]; // [esp+28h] [ebp-42Ch] BYREF\n\n  memset(v4, 0, 0x420u);\n  v4[0] = 32;\n  v4[1] = 65552;\n  LOBYTE(v4[4]) = byte_80DB764;\n  sub_8068A5B(a2);\n  v4[5] = sub_806932A();\n  sub_8068F90(&v3, 4);\n  result = sub_8068D41(0, v4);\n  if ( result < 0 )\n    sub_804D604();\n  return result;\n}\n"
        ],
        "134632747": [
            "sub_806552B",
            "0x806552b",
            "unsigned int __usercall sub_806552B@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // esi\n  const char *v4; // ebp\n  const char *v5; // edi\n  char v6; // al\n  const char **v7; // eax\n  size_t v8; // eax\n  int v9; // ecx\n  int v10; // edi\n  const char *v11; // edx\n  const char **v12; // eax\n  const char **v13; // ebx\n  const char *v14; // edx\n  int v15; // eax\n  int v16; // eax\n  int v17; // edx\n  int v18; // edx\n  unsigned int v19; // edx\n  int v20; // eax\n  int v21; // eax\n  size_t v23; // eax\n  int v24; // [esp-4h] [ebp-49Ch]\n  const char *v25; // [esp+0h] [ebp-498h]\n  const char *v26; // [esp+4h] [ebp-494h]\n  int v27; // [esp+4h] [ebp-494h]\n  char *s; // [esp+8h] [ebp-490h]\n  unsigned int v30; // [esp+10h] [ebp-488h]\n  unsigned int v31; // [esp+14h] [ebp-484h]\n  __int16 v32; // [esp+20h] [ebp-478h] BYREF\n  __int16 v33; // [esp+22h] [ebp-476h] BYREF\n  int v34; // [esp+24h] [ebp-474h] BYREF\n  int v35; // [esp+28h] [ebp-470h]\n  int v36[268]; // [esp+68h] [ebp-430h] BYREF\n\n  memset(v36, 0, 0x420u);\n  v36[0] = 32;\n  HIWORD(v36[1]) = 1;\n  LOWORD(v36[1]) = a2;\n  LOBYTE(v36[4]) = byte_80DB764;\n  if ( a2 == 16 )\n    HIWORD(v36[1]) = 1537;\n  s = 0;\n  v3 = 0;\n  v26 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = *a1;\n    if ( !*a1 )\n      break;\n    v6 = sub_804D254(\"link\", *a1);\n    if ( v6 == 2 )\n    {\n      v7 = (const char **)sub_8069C3A(v26);\n      a1 = v7 + 1;\n      v5 = *v7;\n      break;\n    }\n    if ( v6 )\n    {\n      if ( v6 == 1 )\n      {\n        a1 = (const char **)sub_8069C3A(v26);\n        v4 = *a1;\n      }\n      else if ( v6 == 4 )\n      {\n        a1 = (const char **)sub_8069C3A(v26);\n        s = (char *)*a1;\n      }\n      else\n      {\n        if ( v6 == 3 )\n        {\n          if ( v3 )\n            sub_8069CD4();\n          a1 = (const char **)sub_8069C3A(v26);\n        }\n        v3 = *a1;\n      }\n    }\n    else\n    {\n      a1 = (const char **)sub_8069C3A(v26);\n      v26 = *a1;\n    }\n    ++a1;\n  }\n  sub_8068A5B(v26);\n  sub_8069345();\n  if ( !v5 )\n    goto LABEL_60;\n  v30 = (v36[0] + 3) & 0xFFFFFFFC;\n  sub_8068F90(0, 0);\n  v8 = strlen(v5);\n  sub_8068F90(v5, v8);\n  if ( !*a1 )\n    goto LABEL_59;\n  v31 = (v36[0] + 3) & 0xFFFFFFFC;\n  sub_8068F90(0, 0);\n  if ( strcmp(v5, \"vlan\") )\n  {\n    if ( strcmp(v5, \"vrf\") )\n      goto LABEL_58;\n    v20 = strcmp(*a1, \"table\");\n    v9 = v24;\n    if ( !v20 )\n    {\n      sub_8069C3A(v27);\n      v34 = sub_8069C92();\n      sub_8068F90(&v34, 4);\n      goto LABEL_58;\n    }\n    v11 = \"type vrf\";\nLABEL_56:\n    sub_8069C50(v9, v11);\n  }\n  v34 = 0;\n  v35 = 0;\n  while ( *a1 )\n  {\n    v10 = sub_804D254(\"id\", *a1);\n    if ( v10 < 0 )\n    {\n      v11 = (const char *)&unk_80CE7E8;\n      goto LABEL_56;\n    }\n    v12 = (const char **)sub_8069C3A(v27);\n    v13 = v12;\n    if ( !v10 )\n    {\n      v32 = sub_8069C97();\n      sub_8068F90(&v32, 2);\n      goto LABEL_50;\n    }\n    v14 = *v12;\n    if ( v10 == 5 )\n    {\n      v15 = sub_804D254(\"802.1q\", v14);\n      if ( v15 )\n      {\n        if ( v15 != 1 )\n          sub_804D5E0(\"unknown VLAN encapsulation protocol '%s'\", *v13);\n        v33 = -30552;\n      }\n      else\n      {\n        v33 = -32512;\n      }\n      sub_8068F90(&v33, 2);\n    }\n    else\n    {\n      v16 = sub_804D222(\"on\", v14);\n      if ( v16 < 0 )\n      {\n        v25 = sub_804D2B4(\"id\", v10);\n        sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", v25);\n      }\n      v17 = v34;\n      switch ( v10 )\n      {\n        case 1:\n          v35 |= 1u;\n          v34 &= ~1u;\n          v18 = v17 & 0xFFFFFFFE | 1;\n          if ( !v16 )\n            goto LABEL_49;\n          break;\n        case 2:\n          v35 |= 2u;\n          v34 &= ~2u;\n          v18 = v17 & 0xFFFFFFFD | 2;\n          if ( !v16 )\n            goto LABEL_49;\n          break;\n        case 3:\n          v35 |= 8u;\n          v34 &= ~8u;\n          v18 = v17 & 0xFFFFFFF7 | 8;\n          if ( !v16 )\n            goto LABEL_49;\n          break;\n        default:\n          v35 |= 4u;\n          v19 = v34 & 0xFFFFFFFB;\n          v34 &= ~4u;\n          if ( v16 )\n            break;\n          v18 = v19 | 4;\nLABEL_49:\n          v34 = v18;\n          break;\n      }\n    }\nLABEL_50:\n    a1 = v13 + 1;\n  }\n  if ( v35 )\n    sub_8068F90(&v34, 8);\nLABEL_58:\n  *(_WORD *)((char *)v36 + v31) = ((LOWORD(v36[0]) + 3) & 0xFFFC) - v31;\nLABEL_59:\n  *(_WORD *)((char *)v36 + v30) = ((LOWORD(v36[0]) + 3) & 0xFFFC) - v30;\nLABEL_60:\n  if ( a2 == 16 )\n  {\n    if ( v4 )\n      v3 = v4;\n    if ( v27 )\n    {\n      v34 = sub_806932A();\n      sub_8068F90(&v34, 4);\n    }\n    if ( s )\n    {\n      v21 = sub_8069111(s);\n      if ( v21 < 0 )\n        return -1;\n      sub_8068F90(&v34, v21);\n    }\nLABEL_71:\n    if ( v3 )\n    {\n      v23 = strlen(v3);\n      if ( v23 - 1 > 0xE )\n      {\n        v11 = \"name\";\n        goto LABEL_56;\n      }\n      sub_8068F90(v3, v23 + 1);\n    }\n    return 2 * ((unsigned int)sub_8068D41(0, v36) >> 31);\n  }\n  if ( v3 )\n  {\n    v36[5] = sub_806932A();\n    v3 = v4;\n    goto LABEL_71;\n  }\n  return 1;\n}\n"
        ],
        "134633890": [
            "sub_80659A2",
            "0x80659a2",
            "int __usercall sub_80659A2@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  int v5; // ebp\n  int v6; // eax\n  int v7; // eax\n  int v8; // esi\n  int v9; // esi\n  int v10; // eax\n  int v11; // esi\n  int v12; // ebx\n  int v13; // esi\n  int v14; // esi\n  int v15; // ebx\n  int v16; // [esp-4h] [ebp-78h]\n  char *s1; // [esp+0h] [ebp-74h]\n  int v18; // [esp+4h] [ebp-70h]\n  char *s2; // [esp+8h] [ebp-6Ch]\n  int v20; // [esp+Ch] [ebp-68h]\n  int v21; // [esp+10h] [ebp-64h]\n  int v22; // [esp+14h] [ebp-60h]\n  int v23; // [esp+18h] [ebp-5Ch]\n  char *s; // [esp+1Ch] [ebp-58h]\n  sa_family_t v25; // [esp+22h] [ebp-52h]\n  struct sockaddr addr[2]; // [esp+24h] [ebp-50h] BYREF\n  int v27[12]; // [esp+44h] [ebp-30h] BYREF\n\n  v1 = a1;\n  byte_80DB560 = 2;\n  if ( !*a1 )\n    goto LABEL_75;\n  v2 = sub_804D254(\"add\", *a1);\n  if ( v2 < 0 )\n    sub_8069C50(v3, ident);\n  ++v1;\n  if ( v2 <= 1 )\n    return sub_806552B(v1, 17 - (v2 == 0));\n  if ( v2 == 2 )\n  {\n    s2 = 0;\n    s = 0;\n    v23 = -1;\n    v21 = -1;\n    v22 = -1;\n    v5 = 0;\n    v18 = 0;\n    s1 = 0;\n    while ( *v1 )\n    {\n      v6 = sub_804D254(\"up\", *v1);\n      if ( (_BYTE)v6 )\n      {\n        switch ( (_BYTE)v6 )\n        {\n          case 1:\n            v18 |= 1u;\n            v5 &= ~1u;\n            break;\n          case 2:\n            v1 = (const char **)sub_8069C3A(s1);\n            s2 = (char *)*v1;\n            break;\n          case 3:\n            v1 = (const char **)sub_8069C3A(s1);\n            if ( v21 != -1 )\n              goto LABEL_20;\n            v21 = sub_8069C5C();\n            break;\n          case 4:\n            v1 = (const char **)sub_8069C3A(s1);\n            if ( v22 != -1 )\nLABEL_20:\n              sub_8069CD4();\n            v22 = sub_8069C5C();\n            break;\n          case 8:\n            v1 = (const char **)sub_8069C3A(s1);\n            s = (char *)*v1;\n            break;\n          case 9:\n            v1 = (const char **)sub_8069C3A(s1);\n            v23 = sub_806932A();\n            break;\n          case 0xA:\n            v23 = 0;\n            break;\n          default:\n            if ( (unsigned __int8)v6 <= 0xAu )\n            {\n              v20 = v6;\n              v1 = (const char **)sub_8069C3A(s1);\n              v7 = sub_804D222(\"on\", *v1);\n              v3 = v20;\n              switch ( (_BYTE)v20 )\n              {\n                case 5:\n                  if ( v7 < 0 )\n                    sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", \"multicast\");\n                  v18 |= 0x1000u;\n                  if ( v7 )\n                    v5 &= ~0x1000u;\n                  else\n                    v5 |= 0x1000u;\n                  break;\n                case 6:\n                  if ( v7 < 0 )\n                    sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", 135051898);\n                  v18 |= 0x80u;\n                  if ( v7 )\n                    v5 |= 0x80u;\n                  else\n                    v5 &= ~0x80u;\n                  break;\n                case 7:\n                  if ( v7 < 0 )\n                    sub_804D5E0(\"argument of \\\"%s\\\" must be \\\"on\\\" or \\\"off\\\"\", \"promisc\");\n                  v18 |= 0x100u;\n                  if ( v7 )\n                    v5 &= ~0x100u;\n                  else\n                    v5 |= 0x100u;\n                  break;\n              }\n            }\n            else\n            {\n              if ( (_BYTE)v6 == 11 )\n                v1 = (const char **)sub_8069C3A(s1);\n              if ( s1 )\n                sub_8069CE0();\n              s1 = (char *)*v1;\n            }\n            break;\n        }\n      }\n      else\n      {\n        v18 |= 1u;\n        v5 |= 1u;\n      }\n      ++v1;\n    }\n    if ( !s1 )\n      sub_804D5E0(\"%s requires an argument\", \"\\\"dev\\\"\");\n    if ( s )\n    {\n      v8 = sub_804DF99(0, 2, 17);\n      sub_804D67E((char *)v27, s1);\n      sub_804E0BE(v8, 0x8933u, (int)v27, \"SIOCGIFINDEX\");\n      memset(&addr[0].sa_data[6], 0, 0xCu);\n      *(_DWORD *)&addr[0].sa_data[2] = v27[4];\n      *(_DWORD *)&addr[0].sa_family = 1610612753;\n      sub_804DFB3(0x14u, addr, v8);\n      sub_80A998A(20, addr);\n      close(v8);\n      v25 = *(_WORD *)&addr[0].sa_data[6];\n      v9 = (unsigned __int8)addr[0].sa_data[9];\n      memset(addr, 0, sizeof(addr));\n      sub_804D67E((char *)addr, s1);\n      addr[1].sa_family = v25;\n      v10 = sub_8069111(s);\n      if ( v10 < 0 )\n        exit(1);\n      if ( v10 != v9 )\n        sub_804D5E0(\"wrong address (%s) length: expected %d bytes\", s, v9);\n      v11 = sub_8065473();\n      sub_804E0BE(v11, 0x8924u, (int)addr, \"SIOCSIFHWADDR\");\n      close(v11);\n    }\n    if ( s2 && strcmp(s1, s2) )\n    {\n      sub_804D67E((char *)v27, s1);\n      sub_804D67E((char *)&v27[4], s2);\n      v12 = sub_8065473();\n      sub_804E0BE(v12, 0x8923u, (int)v27, \"SIOCSIFNAME\");\n      close(v12);\n      s1 = s2;\n    }\n    if ( v22 != -1 )\n    {\n      v13 = sub_8065473();\n      memset(v27, 0, 0x20u);\n      sub_804D67E((char *)v27, s1);\n      v27[4] = v22;\n      sub_804E0BE(v13, 0x8943u, (int)v27, \"SIOCSIFTXQLEN\");\n      close(v13);\n      v3 = v16;\n    }\n    if ( v21 != -1 )\n    {\n      v14 = sub_8065473();\n      memset(v27, 0, 0x20u);\n      sub_804D67E((char *)v27, s1);\n      v27[4] = v21;\n      sub_804E0BE(v14, 0x8922u, (int)v27, \"SIOCSIFMTU\");\n      close(v14);\n    }\n    if ( v23 != -1 )\n      sub_80654A9(v3, v23);\n    if ( v18 )\n    {\n      sub_804D67E((char *)v27, s1);\n      v15 = sub_8065473();\n      sub_804E0BE(v15, 0x8913u, (int)v27, \"SIOCGIFFLAGS\");\n      if ( ((v5 ^ SLOWORD(v27[4])) & v18) != 0 )\n      {\n        LOWORD(v27[4]) ^= (unsigned __int16)v18 & (LOWORD(v27[4]) ^ v5);\n        sub_804E0BE(v15, 0x8914u, (int)v27, \"SIOCSIFFLAGS\");\n      }\n      close(v15);\n    }\n    return 0;\n  }\n  else\n  {\nLABEL_75:\n    byte_80DB764 = 17;\n    return sub_8064F95(v1, 0);\n  }\n}\n"
        ],
        "134635188": [
            "sub_8065EB4",
            "0x8065eb4",
            "int sub_8065EB4()\n{\n  if ( sub_8068AAE(*(&buf + 11)) >= 0 )\n  {\n    *(&buf + 11) = 0;\n    return 0;\n  }\n  else\n  {\n    sub_804D3A5((int)\"can't send flush request\");\n    return -1;\n  }\n}\n"
        ],
        "134635242": [
            "sub_8065EEA",
            "0x8065eea",
            "int __usercall sub_8065EEA@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char **v2; // ebx\n  int v4; // ebp\n  const char *v5; // edi\n  int v6; // eax\n  const char **v7; // eax\n  const char *v8; // ebp\n  unsigned int v9; // eax\n  int v10; // eax\n  int v11; // esi\n  _DWORD v13[3]; // [esp+0h] [ebp-E40h] BYREF\n  char v14; // [esp+Ch] [ebp-E34h] BYREF\n  char v15; // [esp+30h] [ebp-E10h] BYREF\n\n  v2 = a1;\n  memset(v13, 0, sizeof(v13));\n  memset(&buf, 0, 0x38u);\n  *(&buf + 2) = -1;\n  if ( a2 && !*a1 )\n    sub_804D5E0(\"%s requires an argument\", \"\\\"ip neigh flush\\\"\");\n  if ( !buf )\n    buf = byte_80DB764;\n  *(&buf + 2) = a2 == 0 ? 191 : -193;\n  v4 = 0;\n  v5 = 0;\n  while ( *v2 )\n  {\n    v6 = sub_804D254(\"to\", *v2);\n    if ( v6 == 1 )\n    {\n      v2 = (const char **)sub_8069C3A(v13[0]);\n      v5 = *v2;\n    }\n    else if ( v6 == 2 )\n    {\n      v7 = (const char **)sub_8069C3A(v13[0]);\n      v2 = v7;\n      if ( !v4 )\n        *(&buf + 2) = 0;\n      v8 = *v7;\n      if ( !strcmp(*v7, \"all\") )\n      {\n        v9 = a2 == 0 ? -1 : 0xFFFFFFBF;\n      }\n      else\n      {\n        v10 = sub_804D254(\"permanent\", v8);\n        if ( v10 < 0 )\n          sub_804D5E0(\"invalid argument '%s' to '%s'\", v8, \"nud state\");\n        v9 = (unsigned __int8)byte_80CEB30[v10];\n        if ( !v9 )\n          v9 = 256;\n      }\n      *(&buf + 2) |= v9;\n      v4 = 1;\n    }\n    else\n    {\n      if ( !v6 )\n        v2 = (const char **)sub_8069C3A(v13[0]);\n      sub_8069AC1(buf, *v2);\n      if ( !buf )\n        buf = *((unsigned __int8 *)&buf + 16);\n    }\n    ++v2;\n  }\n  sub_8068A5B(v13[0]);\n  sub_8069345();\n  if ( v5 )\n  {\n    *(&buf + 1) = sub_806932A();\n    if ( !*(&buf + 1) )\n      sub_804D5E0(\"can't find device '%s'\", v5);\n  }\n  if ( a2 )\n  {\n    *((_QWORD *)&buf + 5) = (unsigned int)&v15;\n    *(&buf + 12) = 3584;\n    *(&buf + 2) &= ~0x20u;\n    *(&buf + 13) = (size_t)&v14;\n    v11 = 0;\n    while ( 1 )\n    {\n      if ( sub_8068AE2(30, buf) < 0 )\n        goto LABEL_31;\n      *(&buf + 9) = 0;\n      if ( sub_8068BB1(0, sub_8066192) < 0 )\n        sub_804D3C9((int)\"flush terminated\");\n      if ( !*(&buf + 9) )\n        break;\n      ++v11;\n      if ( sub_8065EB4() < 0 )\n        sub_804D604();\n      printf(\"\\n*** Round %d, deleting %d entries ***\\n\", v11, *(&buf + 9));\n      if ( v11 == 10 )\n        sub_804D5E0(\"*** Flush not complete bailing out after %d rounds\", 10);\n    }\n    if ( v11 )\n      printf(\"*** Flush is complete after %d round(s) ***\\n\", v11);\n    else\n      puts(\"Nothing to flush\");\n  }\n  else\n  {\n    LOBYTE(v13[0]) = buf;\n    if ( (int)sub_8068B22(12) < 0 )\nLABEL_31:\n      sub_804D3C9((int)\"can't send dump request\");\n    if ( sub_8068BB1(0, sub_8066192) < 0 )\n      sub_804D5E0(\"dump terminated\");\n  }\n  return 0;\n}\n"
        ],
        "134635922": [
            "sub_8066192",
            "0x8066192",
            "int __fastcall sub_8066192(int a1, int *a2)\n{\n  int v3; // edx\n  int v4; // eax\n  int v5; // edx\n  int v6; // esi\n  int v7; // ecx\n  _DWORD *v8; // eax\n  int v9; // edi\n  int v10; // eax\n  int v11; // edx\n  unsigned __int16 *v12; // edx\n  const char *v13; // eax\n  const char *v14; // eax\n  const char *v15; // eax\n  unsigned int v16; // esi\n  int v17; // ebx\n  int v18; // eax\n  int v20; // [esp-8h] [ebp-88h]\n  unsigned __int16 *v21; // [esp+4h] [ebp-7Ch]\n  unsigned __int16 *v22; // [esp+8h] [ebp-78h]\n  _DWORD *v23; // [esp+Ch] [ebp-74h]\n  int v24; // [esp+10h] [ebp-70h]\n  char v25[80]; // [esp+30h] [ebp-50h] BYREF\n\n  v3 = *a2;\n  v4 = *((unsigned __int16 *)a2 + 2);\n  if ( (unsigned __int16)(v4 - 28) > 1u )\n    sub_804D5E0(\"not RTM_NEWNEIGH: %08x %08x %08x\", v3, v4, *((unsigned __int16 *)a2 + 3));\n  v5 = v3 - 28;\n  if ( v5 < 0 )\n    sub_804D5E0(\"BUG: wrong nlmsg len %d\", v5);\n  if ( *(&buf + 10) && (_WORD)v4 != 28 )\n    return 0;\n  if ( buf && buf != *((unsigned __int8 *)a2 + 16) )\n    return 0;\n  if ( *(&buf + 1) && *(&buf + 1) != a2[5] )\n    return 0;\n  v6 = *((unsigned __int16 *)a2 + 12);\n  if ( (*(&buf + 2) & v6) == 0\n    && (*((_BYTE *)a2 + 26) & 8) == 0\n    && ((_WORD)v6 || (*(_WORD *)(&buf + 2) & 0x100) == 0)\n    && *((_BYTE *)a2 + 16) != 12 )\n  {\n    return 0;\n  }\n  sub_806901E(v5);\n  if ( v21 )\n  {\n    if ( *((_BYTE *)&buf + 16) )\n    {\n      memset(v25, 0, 0x14u);\n      v25[0] = *((_BYTE *)a2 + 16);\n      qmemcpy(&v25[4], v21 + 2, *v21 - 4);\n      if ( sub_8069CEC(*((__int16 *)&buf + 9), &buf + 4) )\n        return 0;\n    }\n  }\n  if ( *(&buf + 3) && v23 && v23[4] )\n    return 0;\n  if ( !*(&buf + 10) )\n  {\nLABEL_27:\n    v12 = v21;\n    if ( v21 )\n    {\n      v13 = (const char *)sub_8069D47(v7, v21 + 2);\n      printf(\"%s \", v13);\n      v7 = v20;\n    }\n    if ( !*(&buf + 1) && a2[5] )\n    {\n      v14 = (const char *)sub_80692E5(v7, v12);\n      printf(\"dev %s \", v14);\n    }\n    if ( v22 )\n    {\n      v15 = (const char *)sub_806907E(1, *v22 - 4, v25, 64);\n      printf(\"lladdr %s\", v15);\n    }\n    if ( *((char *)a2 + 26) < 0 )\n      printf(\" router\");\n    if ( (*((_BYTE *)a2 + 26) & 8) != 0 )\n      printf(\" proxy\");\n    if ( v23 )\n    {\n      v16 = sub_806990F();\n      if ( v23[4] )\n        printf(\" ref %d\", v23[4]);\n      printf(\" used %d/%d/%d\", v23[2] / v16, v23[1] / v16, v23[3] / v16);\n    }\n    if ( v24 )\n      printf(\" probes %u\", *(_DWORD *)(v24 + 4));\n    v17 = a2[6];\n    v18 = 32;\n    if ( (v17 & 1) != 0 )\n    {\n      printf(\"%cINCOMPLETE\", 32);\n      v18 = 44;\n    }\n    if ( (v17 & 2) != 0 )\n    {\n      printf(\"%cREACHABLE\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 4) != 0 )\n    {\n      printf(\"%cSTALE\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 8) != 0 )\n    {\n      printf(\"%cDELAY\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x10) != 0 )\n    {\n      printf(\"%cPROBE\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x20) != 0 )\n    {\n      printf(\"%cFAILED\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x40) != 0 )\n    {\n      printf(\"%cNOARP\", v18);\n      v18 = 44;\n    }\n    if ( (v17 & 0x80) != 0 )\n      printf(\"%cPERMANENT\", v18);\n    sub_804DD98(10);\n    return 0;\n  }\n  if ( *a2 + ((*(&buf + 11) + 3) & 0xFFFFFFFC) <= *(&buf + 12) || (v10 = sub_8065EB4(), v11 = -1, !v10) )\n  {\n    v8 = (_DWORD *)(*(&buf + 10) + ((*(&buf + 11) + 3) & 0xFFFFFFFC));\n    qmemcpy(v8, a2, *a2);\n    v8[1] = 65565;\n    v7 = *(&buf + 13);\n    v9 = *(_DWORD *)(*(&buf + 13) + 28);\n    *(_DWORD *)(*(&buf + 13) + 28) = v9 + 1;\n    v8[2] = v9 + 1;\n    *(&buf + 11) = (size_t)v8 + *a2 - *(&buf + 10);\n    ++*(&buf + 9);\n    goto LABEL_27;\n  }\n  return v11;\n}\n"
        ],
        "134636777": [
            "sub_80664E9",
            "0x80664e9",
            "int __usercall sub_80664E9@<eax>(const char **a1@<eax>)\n{\n  int v1; // edx\n  const char **v2; // ebx\n  int v3; // eax\n  int v4; // ecx\n\n  v1 = (int)*a1;\n  if ( *a1 )\n  {\n    v2 = a1;\n    v3 = sub_804D254(\"show\", (const char *)v1);\n    if ( v3 )\n    {\n      if ( v3 != 1 )\n        sub_8069C50(v4, ident);\n      a1 = v2 + 1;\n      v1 = 1;\n    }\n    else\n    {\n      a1 = v2 + 1;\n      v1 = 0;\n    }\n  }\n  return sub_8065EEA(a1, v1);\n}\n"
        ],
        "134636837": [
            "sub_8066525",
            "0x8066525",
            "int sub_8066525()\n{\n  int result; // eax\n\n  result = 0;\n  memset(&buf, 0, 0x8Cu);\n  HIWORD(preg.allocated) = -1;\n  HIWORD(dword_80DB7F0) = -1;\n  return result;\n}\n"
        ],
        "134636874": [
            "sub_806654A",
            "0x806654a",
            "int sub_806654A()\n{\n  if ( sub_8068AAE(*(&buf + 3)) >= 0 )\n  {\n    *(&buf + 3) = 0;\n    return 0;\n  }\n  else\n  {\n    sub_804D3A5((int)\"can't send flush request\");\n    return -1;\n  }\n}\n"
        ],
        "134636928": [
            "sub_8066580",
            "0x8066580",
            "int __fastcall sub_8066580(int a1, int *a2)\n{\n  int v3; // eax\n  int v4; // edx\n  int v5; // eax\n  int v6; // eax\n  int v7; // ebp\n  int v8; // ecx\n  _DWORD *v9; // eax\n  int v10; // edx\n  const char *v11; // eax\n  unsigned __int8 v12; // al\n  int v13; // esi\n  int v14; // edx\n  const char *v15; // eax\n  int v16; // ecx\n  unsigned __int8 v17; // al\n  int v18; // esi\n  int v19; // edx\n  const char *v20; // eax\n  int v21; // edx\n  const char *v22; // eax\n  const char *v23; // eax\n  const char *v24; // eax\n  const char *v25; // eax\n  int v26; // edx\n  const char *v27; // eax\n  int v28; // esi\n  unsigned int v29; // ebx\n  unsigned int v30; // eax\n  const char *v31; // eax\n  int v32; // edx\n  bool v33; // zf\n  int v35; // [esp-8h] [ebp-B4h]\n  int v36; // [esp-8h] [ebp-B4h]\n  int v37; // [esp-8h] [ebp-B4h]\n  int v38; // [esp-4h] [ebp-B0h]\n  int v39; // [esp-4h] [ebp-B0h]\n  int v40; // [esp-4h] [ebp-B0h]\n  int v41; // [esp-4h] [ebp-B0h]\n  int v42; // [esp-4h] [ebp-B0h]\n  int v43; // [esp-4h] [ebp-B0h]\n  int v44; // [esp-4h] [ebp-B0h]\n  int v45; // [esp+0h] [ebp-ACh]\n  char v46; // [esp+6h] [ebp-A6h]\n  char v47; // [esp+7h] [ebp-A5h]\n  __int16 v48[20]; // [esp+8h] [ebp-A4h] BYREF\n  int v49; // [esp+34h] [ebp-78h]\n  int v50; // [esp+38h] [ebp-74h]\n  int v51; // [esp+3Ch] [ebp-70h]\n  int v52; // [esp+40h] [ebp-6Ch]\n  int v53; // [esp+44h] [ebp-68h]\n  int v54; // [esp+48h] [ebp-64h]\n  int v55; // [esp+4Ch] [ebp-60h]\n  int v56; // [esp+60h] [ebp-4Ch]\n  int v57; // [esp+6Ch] [ebp-40h]\n\n  v3 = *a2;\n  v4 = *((unsigned __int16 *)a2 + 2);\n  if ( (unsigned __int16)(v4 - 24) > 1u )\n  {\n    fprintf(stderr, \"Not a route: %08x %08x %08x\\n\", v3, v4, *((unsigned __int16 *)a2 + 3));\n    return 0;\n  }\n  if ( *(&buf + 2) && (_WORD)v4 != 24 )\n    return 0;\n  v5 = v3 - 28;\n  if ( v5 < 0 )\n    sub_804D5E0(\"wrong nlmsg len %d\", v5);\n  sub_806901E(v5);\n  if ( v57 )\n    v6 = *(_DWORD *)(v57 + 4);\n  else\n    v6 = *((unsigned __int8 *)a2 + 20);\n  v45 = v6;\n  v46 = *((_BYTE *)a2 + 16);\n  if ( v46 == 10 )\n  {\n    if ( buf )\n    {\n      v32 = a2[6] & 0x200;\n      if ( (buf & 0x80000000) == 0 )\n      {\n        if ( v32 )\n          return 0;\n        if ( buf == 255 )\n        {\n          if ( *((_BYTE *)a2 + 23) != 2 )\n            return 0;\n          goto LABEL_128;\n        }\n        if ( buf != 254 )\n          return 0;\n        v33 = *((_BYTE *)a2 + 23) == 2;\n      }\n      else\n      {\n        v33 = v32 == 0;\n      }\n      if ( v33 )\n        return 0;\n    }\nLABEL_128:\n    v7 = 128;\n    goto LABEL_13;\n  }\n  v7 = v46 == 2 ? 0x20 : -1;\n  if ( (int)buf > 0 && buf != v6 )\n    return 0;\nLABEL_13:\n  if ( ((*(&buf + 6) ^ *((unsigned __int8 *)a2 + 22)) & *(&buf + 7)) == 0 )\n  {\n    v47 = (char)dword_80DB7B4;\n    if ( (!(_BYTE)dword_80DB7B4\n       || v46 == (_BYTE)dword_80DB7B4 && SHIWORD(dword_80DB7B4) <= (int)*((unsigned __int8 *)a2 + 17))\n      && (!LOBYTE(preg.allocated)\n       || v46 == LOBYTE(preg.allocated)\n       && ((preg.allocated & 0x80000000) != 0 || SHIWORD(preg.allocated) >= (int)*((unsigned __int8 *)a2 + 17)))\n      && (!LOBYTE(preg.re_nsub)\n       || v46 == LOBYTE(preg.re_nsub) && SHIWORD(preg.re_nsub) <= (int)*((unsigned __int8 *)a2 + 18))\n      && (!(_BYTE)dword_80DB7F0\n       || v46 == (_BYTE)dword_80DB7F0\n       && (dword_80DB7F0 < 0 || SHIWORD(dword_80DB7F0) >= (int)*((unsigned __int8 *)a2 + 18))) )\n    {\n      memset(v48, 0, sizeof(v48));\n      v8 = 0;\n      if ( v50 )\n      {\n        v48[11] = *((unsigned __int8 *)a2 + 18);\n        HIBYTE(v48[10]) = v46 == 10 ? 16 : 4;\n        qmemcpy(&v48[12], (const void *)(v50 + 4), HIBYTE(v48[10]));\n        v8 = 0;\n      }\n      if ( v49 )\n      {\n        v48[1] = *((unsigned __int8 *)a2 + 17);\n        HIBYTE(v48[0]) = v46 == 10 ? 16 : 4;\n        qmemcpy(&v48[2], (const void *)(v49 + 4), HIBYTE(v48[0]));\n        v8 = 0;\n      }\n      if ( (!v47 || !sub_8069CEC(SHIWORD(dword_80DB7B4), &dword_80DB7B4))\n        && (!LOBYTE(preg.allocated)\n         || (preg.allocated & 0x80000000) != 0\n         || !sub_8069CEC(*((unsigned __int8 *)a2 + 17), &preg.allocated))\n        && (!LOBYTE(preg.re_nsub) || !sub_8069CEC(SHIWORD(preg.re_nsub), &preg.re_nsub))\n        && (!(_BYTE)dword_80DB7F0 || dword_80DB7F0 < 0 || !sub_8069CEC(*((unsigned __int8 *)a2 + 18), &dword_80DB7F0))\n        && (!*(&buf + 9) || v52 && *(&buf + 9) == *(_DWORD *)(v52 + 4)) )\n      {\n        if ( *(&buf + 2) )\n        {\n          if ( *((_WORD *)a2 + 8) != 10 || *((_BYTE *)a2 + 23) != 7 || !v54 || *(_DWORD *)(v54 + 4) != -1 )\n          {\n            if ( *a2 + ((*(&buf + 3) + 3) & 0xFFFFFFFC) > *(&buf + 4) && sub_806654A() )\n              sub_804D604();\n            v9 = (_DWORD *)(*(&buf + 2) + ((*(&buf + 3) + 3) & 0xFFFFFFFC));\n            qmemcpy(v9, a2, *a2);\n            v9[1] = 65561;\n            v10 = *(_DWORD *)(*(&buf + 5) + 28) + 1;\n            *(_DWORD *)(*(&buf + 5) + 28) = v10;\n            v9[2] = v10;\n            *(&buf + 3) = (size_t)v9 + *a2 - *(&buf + 2);\n            *((_BYTE *)&buf + 4) = 1;\n          }\n          return 0;\n        }\n        if ( *((_WORD *)a2 + 2) == 25 )\n        {\n          printf(\"Deleted \");\n          v8 = v38;\n        }\n        if ( *((_BYTE *)a2 + 23) != 1 )\n        {\n          v11 = (const char *)sub_8069778();\n          printf(\"%s \", v11);\n        }\n        v12 = *((_BYTE *)a2 + 17);\n        if ( v49 )\n        {\n          v13 = v12;\n          v14 = v49 + 4;\n          if ( v12 == v7 )\n          {\n            v39 = sub_8069D47(v8, v14);\n            printf(\"%s \", v39);\n          }\n          else\n          {\n            v15 = (const char *)sub_8069D47(v8, v14);\n            printf(\"%s/%u \", v15, v13);\n          }\n        }\n        else if ( v12 )\n        {\n          printf(\"0/%d \", *((unsigned __int8 *)a2 + 17));\n        }\n        else\n        {\n          printf(\"default \");\n          v16 = v40;\n        }\n        v17 = *((_BYTE *)a2 + 18);\n        if ( v50 )\n        {\n          v18 = v17;\n          v19 = v50 + 4;\n          if ( v17 == v7 )\n          {\n            v41 = sub_8069D47(v16, v19);\n            printf(\"from %s \", v41);\n          }\n          else\n          {\n            v20 = (const char *)sub_8069D47(v16, v19);\n            printf(\"from %s/%u \", v20, v18);\n          }\n        }\n        else if ( v17 )\n        {\n          printf(\"from 0/%u \", *((unsigned __int8 *)a2 + 18));\n        }\n        v21 = v53;\n        if ( v53 && *((__int16 *)&buf + 21) != v7 )\n        {\n          v22 = (const char *)sub_8069D47(v16, v53 + 4);\n          printf(\"via %s \", v22);\n        }\n        if ( v52 )\n        {\n          v23 = (const char *)sub_80692E5(v16, v21);\n          printf(\"dev %s \", v23);\n          v16 = v35;\n        }\n        if ( v45 != 254 && v45 && !buf )\n        {\n          v24 = (const char *)sub_8069733();\n          printf(\"table %s \", v24);\n        }\n        if ( (*((_BYTE *)a2 + 25) & 2) == 0 && *((_BYTE *)a2 + 22) && *(&buf + 7) != -1 )\n        {\n          v25 = (const char *)sub_8069664();\n          printf(\"scope %s \", v25);\n        }\n        v26 = v55;\n        if ( v55 )\n        {\n          v27 = (const char *)sub_8069D47(v16, v55 + 4);\n          printf(\" src %s \", v27);\n          v16 = v36;\n        }\n        if ( v54 )\n        {\n          printf(\" metric %d \", *(_DWORD *)(v54 + 4));\n          v26 = v42;\n        }\n        if ( (a2[6] & 1) != 0 )\n          printf(\"dead \");\n        if ( (a2[6] & 4) != 0 )\n          printf(\"onlink \");\n        if ( (a2[6] & 2) != 0 )\n          printf(\"pervasive \");\n        if ( (*((_BYTE *)a2 + 25) & 1) != 0 )\n        {\n          printf(\"notify \");\n          v16 = v43;\n        }\n        if ( *((_BYTE *)a2 + 16) != 10 )\n          goto LABEL_114;\n        v28 = 0;\n        if ( v56 )\n          v28 = v56 + 4;\n        if ( (*((_BYTE *)a2 + 25) & 2) != 0 )\n        {\n          printf(\"%c    cache \", (unsigned __int8)byte_80DBBA5);\n          v26 = v44;\n        }\n        else\n        {\n          if ( !v28 )\n          {\nLABEL_114:\n            if ( v51 && !*(&buf + 8) )\n            {\n              v31 = (const char *)sub_80692E5(v16, v26);\n              printf(\" iif %s\", v31);\n            }\n            sub_804DD98(10);\n            return 0;\n          }\n          if ( !*(_DWORD *)(v28 + 8) )\n          {\nLABEL_112:\n            if ( *(_DWORD *)(v28 + 12) )\n            {\n              printf(\" error %d\", *(_DWORD *)(v28 + 12));\n              v16 = v37;\n            }\n            goto LABEL_114;\n          }\n        }\n        v29 = *(_DWORD *)(v28 + 8);\n        if ( v29 )\n        {\n          v30 = sub_806990F();\n          printf(\" expires %dsec\", v29 / v30);\n        }\n        goto LABEL_112;\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134638522": [
            "sub_8066BBA",
            "0x8066bba",
            "int __usercall sub_8066BBA@<eax>(const char **a1@<eax>)\n{\n  char v2; // bp\n  const char *v3; // esi\n  const char *v4; // edi\n  int v5; // eax\n  int v6; // eax\n  int v7; // ebx\n  int v8; // ebx\n  _WORD *v9; // eax\n  int v11; // [esp+0h] [ebp-4C0h]\n  char v12; // [esp+3h] [ebp-4BDh]\n  char v13; // [esp+28h] [ebp-498h]\n  unsigned __int8 v14; // [esp+29h] [ebp-497h]\n  char v15; // [esp+2Ah] [ebp-496h]\n  char v16[4]; // [esp+2Ch] [ebp-494h] BYREF\n  int v17; // [esp+30h] [ebp-490h]\n  int v18; // [esp+34h] [ebp-48Ch]\n  int v19; // [esp+38h] [ebp-488h]\n  int v20; // [esp+3Ch] [ebp-484h]\n  _WORD *v21; // [esp+44h] [ebp-47Ch]\n  int v22[267]; // [esp+94h] [ebp-42Ch] BYREF\n\n  memset(v22, 0, 0x41Cu);\n  sub_8066525();\n  v22[0] = 28;\n  v22[1] = 65562;\n  LOBYTE(v22[4]) = byte_80DB764;\n  HIBYTE(v11) = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  while ( *a1 )\n  {\n    switch ( sub_804D222(\"from\", *a1) )\n    {\n      case 0:\n        a1 = (const char **)sub_8069C3A(v11);\n        sub_8069AC1(LOBYTE(v22[4]), *a1);\n        if ( !LOBYTE(v22[4]) )\n          LOBYTE(v22[4]) = v13;\n        if ( v14 )\n          sub_8068F90(v16, v14);\n        BYTE2(v22[4]) = v15;\n        HIBYTE(v11) = 1;\n        break;\n      case 1:\n        a1 = (const char **)sub_8069C3A(v11);\n        v4 = *a1;\n        break;\n      case 2:\n      case 3:\n        a1 = (const char **)sub_8069C3A(v11);\n        v3 = *a1;\n        break;\n      case 4:\n        v22[6] |= 0x100u;\n        break;\n      case 5:\n        v2 = 1;\n        break;\n      case 6:\n        a1 = (const char **)sub_8069C3A(v11);\n        goto LABEL_13;\n      default:\nLABEL_13:\n        sub_8069AC1(LOBYTE(v22[4]), *a1);\n        if ( !LOBYTE(v22[4]) )\n          LOBYTE(v22[4]) = v13;\n        if ( v14 )\n          sub_8068F90(v16, v14);\n        BYTE1(v22[4]) = v15;\n        break;\n    }\n    ++a1;\n  }\n  if ( !BYTE1(v22[4]) )\n    sub_804D5E0(\"need at least destination address\");\n  sub_8068A5B(v11);\n  sub_8069345();\n  if ( v4 )\n  {\n    v6 = sub_806932A();\n    sub_8068F53(v6);\n  }\n  if ( v3 )\n  {\n    v5 = sub_806932A();\n    sub_8068F53(v5);\n  }\n  if ( !LOBYTE(v22[4]) )\n    LOBYTE(v22[4]) = 2;\n  if ( sub_8068D41(v22, v22) < 0 )\n    return 2;\n  if ( v2 && !v12 )\n  {\n    v7 = v22[0];\n    sub_8066580(0, v22);\n    if ( LOWORD(v22[1]) != 24 )\n      sub_804D5E0(\"not a route?\");\n    v8 = v7 - 28;\n    if ( v8 < 0 )\n      sub_804D5E0(\"wrong len %d\", v8);\n    sub_806901E(v8);\n    v9 = v21;\n    if ( v21 )\n    {\n      v21[1] = 2;\n      BYTE2(v22[4]) = 8 * *v9 - 32;\n    }\n    else if ( !v17 )\n    {\n      sub_804D5E0(\"can't connect the route\");\n    }\n    if ( !v3 && v19 )\n      *(_WORD *)(v19 + 2) = 0;\n    if ( v20 )\n      *(_WORD *)(v20 + 2) = 0;\n    if ( !v4 && v18 )\n      *(_WORD *)(v18 + 2) = 0;\n    v22[1] = 65562;\n    if ( sub_8068D41(v22, v22) < 0 )\n      return 2;\n  }\n  sub_8066580(0, v22);\n  return 0;\n}\n"
        ],
        "134639324": [
            "sub_8066EDC",
            "0x8066edc",
            "int __usercall sub_8066EDC@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  size_t v3; // ebp\n  int v4; // eax\n  int v5; // ecx\n  const char *v6; // edx\n  int v7; // eax\n  int v8; // eax\n  int v9; // eax\n  size_t *p_re_nsub; // eax\n  unsigned int *p_allocated; // esi\n  int v12; // eax\n  int v13; // esi\n  int v15; // [esp-4h] [ebp-E50h]\n  const char *v16; // [esp+0h] [ebp-E4Ch]\n  int v17; // [esp+0h] [ebp-E4Ch]\n  const char *v19; // [esp+8h] [ebp-E44h]\n  struct sockaddr addr; // [esp+Ch] [ebp-E40h] BYREF\n  int v21; // [esp+34h] [ebp-E18h]\n  int v22; // [esp+38h] [ebp-E14h]\n  int buf[900]; // [esp+3Ch] [ebp-E10h] BYREF\n\n  v3 = byte_80DB764;\n  sub_8066525();\n  ::buf = 254;\n  if ( a2 && !*a1 )\n    sub_804D5E0(\"%s requires an argument\", \"\\\"ip route flush\\\"\");\n  v16 = 0;\n  v19 = 0;\n  while ( *a1 )\n  {\n    v4 = sub_804D254(\"protocol\", *a1);\n    if ( v4 )\n    {\n      if ( (unsigned int)(v4 - 1) <= 1 )\n      {\n        a1 = (const char **)sub_8069C3A(v16);\n        v16 = *a1;\n        goto LABEL_49;\n      }\n      if ( v4 == 3 )\n      {\n        a1 = (const char **)sub_8069C3A(v16);\n        v19 = *a1;\n        goto LABEL_49;\n      }\n      if ( v4 == 4 )\n      {\nLABEL_44:\n        a1 = (const char **)sub_8069C3A(v16);\n        sub_8069AC1(v3, *a1);\n        goto LABEL_49;\n      }\n      if ( v4 == 5 )\n      {\n        a1 = (const char **)sub_8069C3A(v16);\n        v7 = sub_804D254(\"protocol\", *a1);\n        if ( v7 == 6 )\n          goto LABEL_26;\n        if ( v7 == 10 )\n        {\n          ::buf = 0;\n        }\n        else if ( v7 != 14 )\n        {\n          if ( sub_8069759() )\n          {\n            v6 = \"table\";\n            goto LABEL_23;\n          }\n          ::buf = buf[0];\n        }\n      }\n      else\n      {\n        if ( v4 == 6 )\n        {\nLABEL_26:\n          ::buf = -1;\n          goto LABEL_49;\n        }\n        if ( v4 == 9 )\n        {\n          a1 = (const char **)sub_8069C3A(v16);\n          *(&::buf + 7) = -1;\n          if ( sub_806968A() )\n          {\n            v8 = strcmp(*a1, \"all\");\n            v5 = v15;\n            if ( v8 )\n            {\n              v6 = \"scope\";\nLABEL_23:\n              sub_8069C50(v5, v6);\n            }\n            buf[0] = 255;\n            *(&::buf + 7) = 0;\n          }\n          *(&::buf + 6) = buf[0];\n        }\n        else\n        {\n          if ( v4 == 7 )\n          {\n            a1 = (const char **)sub_8069C3A(v16);\n            v9 = sub_804D254(\"protocol\", *a1);\n            if ( v9 == 11 || v9 == 12 )\n              goto LABEL_44;\n            if ( v9 == 13 )\n              a1 = (const char **)sub_8069C3A(v16);\n            sub_8069AC1(v3, *a1);\n            p_re_nsub = &preg.re_nsub;\n            p_allocated = (unsigned int *)&dword_80DB7F0;\n          }\n          else\n          {\n            if ( v4 == 8 )\n            {\n              a1 = (const char **)sub_8069C3A(v16);\n              v4 = sub_804D254(\"protocol\", *a1);\n            }\n            if ( v4 == 11 || v4 == 12 )\n              goto LABEL_44;\n            if ( v4 == 13 )\n              a1 = (const char **)sub_8069C3A(v16);\n            sub_8069AC1(v3, *a1);\n            p_re_nsub = (size_t *)&dword_80DB7B4;\n            p_allocated = &preg.allocated;\n          }\n          qmemcpy(p_re_nsub, p_allocated, 0x14u);\n        }\n      }\n    }\n    else\n    {\n      buf[0] = 0;\n      a1 = (const char **)sub_8069C3A(v16);\n      if ( sub_8069613() && sub_804D222(\"protocol\", *a1) != 10 )\n      {\n        v6 = \"protocol\";\n        goto LABEL_23;\n      }\n    }\nLABEL_49:\n    ++a1;\n  }\n  if ( !v3 )\n  {\n    v3 = ::buf;\n    if ( ::buf )\n      v3 = 2;\n  }\n  sub_8068A5B(v16);\n  sub_8069345();\n  if ( v19 )\n    *(&::buf + 8) = sub_806932A();\n  if ( v17 )\n    *(&::buf + 9) = sub_806932A();\n  if ( a2 )\n  {\n    if ( ::buf != -1 || v3 == 10 )\n      goto LABEL_60;\n    v12 = sub_804DC14(\"/proc/sys/net/ipv4/route/flush\");\n    v13 = v12;\n    if ( v12 >= 0 )\n    {\n      if ( write(v12, \"-1\", 2u) > 1 )\n        close(v13);\n      else\n        sub_804D3A5((int)\"can't flush routing cache\");\n    }\n    if ( v3 != 2 )\n    {\nLABEL_60:\n      *((_QWORD *)&::buf + 1) = (unsigned int)buf;\n      *(&::buf + 4) = 3584;\n      *(&::buf + 5) = (size_t)&addr.sa_data[10];\n      while ( 1 )\n      {\n        sub_8068AE2(26, v3);\n        *((_BYTE *)&::buf + 4) = 0;\n        sub_8068BB1(0, sub_8066580);\n        if ( !*((_BYTE *)&::buf + 4) )\n          break;\n        if ( sub_806654A() )\n          return a2;\n      }\n    }\n    return 0;\n  }\n  else\n  {\n    if ( ::buf == -1 )\n    {\n      memset(addr.sa_data, 0, 0xAu);\n      memset(&buf[3], 0, 0xCu);\n      addr.sa_family = 16;\n      buf[0] = 28;\n      buf[1] = 16842778;\n      v22 = ++v21;\n      buf[2] = v21;\n      LOBYTE(buf[4]) = v3;\n      buf[6] = 512;\n      if ( sub_804DFCD(0x1Cu, buf, *(int *)&addr.sa_data[10], &addr, 0xCu) < 0 )\n        sub_804D3C9((int)\"can't send dump request\");\n    }\n    else\n    {\n      sub_8068AE2(26, v3);\n    }\n    sub_8068BB1(0, sub_8066580);\n  }\n  return a2;\n}\n"
        ],
        "134640501": [
            "sub_8067375",
            "0x8067375",
            "unsigned int __usercall sub_8067375@<eax>(int a1@<eax>, __int16 a2@<dx>, const char **a3@<ecx>)\n{\n  int v4; // esi\n  const char *v5; // ebp\n  int v6; // edi\n  int v7; // eax\n  int v8; // eax\n  int v9; // ecx\n  int v10; // eax\n  int v11; // ecx\n  int v12; // ecx\n  const char *v13; // edx\n  int v14; // eax\n  int v16; // [esp-4h] [ebp-560h]\n  int v17; // [esp-4h] [ebp-560h]\n  int v18; // [esp-4h] [ebp-560h]\n  int v19; // [esp-4h] [ebp-560h]\n  int v20; // [esp-4h] [ebp-560h]\n  int v21; // [esp+0h] [ebp-55Ch]\n  int v22; // [esp+0h] [ebp-55Ch]\n  char v23; // [esp+7h] [ebp-555h]\n  char v24; // [esp+8h] [ebp-554h]\n  unsigned int v25; // [esp+Ch] [ebp-550h]\n  char v26[32]; // [esp+10h] [ebp-54Ch] BYREF\n  int v27; // [esp+30h] [ebp-52Ch]\n  char v28[252]; // [esp+34h] [ebp-528h] BYREF\n  int v29[267]; // [esp+130h] [ebp-42Ch] BYREF\n\n  v21 = a1;\n  memset(v29, 0, 0x41Cu);\n  v29[0] = 28;\n  HIWORD(v29[1]) = a2 | 1;\n  LOWORD(v29[1]) = a1;\n  LOBYTE(v29[4]) = byte_80DB764;\n  LOBYTE(v29[5]) = -2;\n  BYTE2(v29[5]) = -1;\n  if ( a1 != 25 )\n  {\n    *(_WORD *)((char *)&v29[5] + 1) = 3;\n    HIBYTE(v29[5]) = 1;\n  }\n  v27 = 524292;\n  v23 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  while ( *a3 )\n  {\n    v7 = sub_804D254(\"src\", *a3);\n    switch ( v7 )\n    {\n      case 0:\n        a3 = (const char **)sub_8069C3A(v21);\n        sub_8069A87(LOBYTE(v29[4]), *a3);\n        if ( !LOBYTE(v29[4]) )\n          LOBYTE(v29[4]) = v25;\nLABEL_52:\n        sub_8068F90(v26, BYTE1(v25));\n        break;\n      case 1:\n        v4 |= 1u;\n        a3 = (const char **)sub_8069C3A(v21);\n        sub_8069A87(LOBYTE(v29[4]), *a3);\n        if ( !LOBYTE(v29[4]) )\n          LOBYTE(v29[4]) = v25;\n        goto LABEL_52;\n      case 2:\n        a3 = (const char **)sub_8069C3A(v21);\n        v8 = strcmp(*a3, \"lock\");\n        v9 = v16;\n        if ( !v8 )\n        {\n          v6 |= 4u;\n          a3 = (const char **)sub_8069C3A(v21);\n        }\n        v17 = sub_8069C5C(v9, \"mtu\");\n        sub_8068FDE(v17);\n        break;\n      case 3:\n        a3 = (const char **)sub_8069C3A(v21);\n        v10 = strcmp(*a3, \"lock\");\n        v11 = v18;\n        if ( !v10 )\n        {\n          v6 |= 0x100u;\n          a3 = (const char **)sub_8069C3A(v21);\n        }\n        v19 = sub_8069C5C(v11, \"advmss\");\n        sub_8068FDE(v19);\n        break;\n      case 4:\n        a3 = (const char **)sub_8069C3A(v21);\n        if ( sub_806968A() )\n        {\n          v13 = \"scope\";\n          goto LABEL_28;\n        }\n        BYTE2(v29[5]) = v25;\n        v23 = 1;\n        break;\n      case 5:\n        a3 = (const char **)sub_8069C3A(v21);\n        if ( sub_8069613() )\n        {\n          v13 = \"protocol\";\n          goto LABEL_28;\n        }\n        BYTE1(v29[5]) = v25;\n        v4 |= 4u;\n        break;\n      case 6:\n        a3 = (const char **)sub_8069C3A(v21);\n        if ( sub_8069759() )\n        {\n          v13 = \"table\";\nLABEL_28:\n          sub_8069C50(v12, v13);\n        }\n        if ( v25 <= 0xFF )\n        {\n          LOBYTE(v29[5]) = v25;\n        }\n        else\n        {\n          LOBYTE(v29[5]) = 0;\n          sub_8068F53(v25);\n        }\n        break;\n      default:\n        if ( (unsigned int)(v7 - 7) <= 1 )\n        {\n          a3 = (const char **)sub_8069C3A(v21);\n          v5 = *a3;\n          break;\n        }\n        switch ( v7 )\n        {\n          case 10:\n            a3 = (const char **)sub_8069C3A(v21);\n            v20 = sub_8069C92();\n            sub_8068F53(v20);\n            goto LABEL_53;\n          case 11:\n            v29[6] |= 4u;\n            goto LABEL_53;\n          case 9:\n            a3 = (const char **)sub_8069C3A(v21);\n            break;\n        }\n        if ( (unsigned __int8)(**a3 - 48) > 9u && !sub_80697D1() )\n        {\n          a3 = (const char **)sub_8069C3A(v21);\n          HIBYTE(v29[5]) = v24;\n          v4 |= 8u;\n        }\n        if ( (v4 & 2) != 0 )\n          sub_8069CE0();\n        sub_8069AC1(LOBYTE(v29[4]), *a3);\n        if ( !LOBYTE(v29[4]) )\n          LOBYTE(v29[4]) = v25;\n        BYTE1(v29[4]) = BYTE2(v25);\n        v4 |= 2u;\n        if ( BYTE1(v25) )\n          goto LABEL_52;\n        break;\n    }\nLABEL_53:\n    ++a3;\n  }\n  sub_8068A5B(v21);\n  if ( v5 )\n  {\n    sub_8069345();\n    v14 = sub_806932A();\n    sub_8068F53(v14);\n  }\n  if ( (unsigned __int16)v27 > 4u )\n  {\n    if ( v6 )\n      sub_8068FDE(v6);\n    sub_8068F90(v28, (unsigned __int16)v27 - 4);\n  }\n  if ( !v23 )\n  {\n    if ( (HIBYTE(v29[5]) & 0xF7) == 2 )\n    {\n      BYTE2(v29[5]) = -2;\n      goto LABEL_69;\n    }\n    if ( (unsigned __int8)(HIBYTE(v29[5]) - 3) > 2u )\n    {\n      if ( HIBYTE(v29[5]) <= 1u )\n      {\n        if ( v22 == 25 )\n        {\n          BYTE2(v29[5]) = -1;\n        }\n        else if ( (v4 & 1) == 0 )\n        {\n          goto LABEL_64;\n        }\n      }\n    }\n    else\n    {\nLABEL_64:\n      BYTE2(v29[5]) = -3;\n    }\n  }\nLABEL_69:\n  if ( !LOBYTE(v29[4]) )\n    LOBYTE(v29[4]) = 2;\n  return 2 * ((unsigned int)sub_8068D41(0, v29) >> 31);\n}\n"
        ],
        "134641674": [
            "sub_806780A",
            "0x806780a",
            "int __usercall sub_806780A@<eax>(const char **a1@<eax>)\n{\n  int v1; // edx\n  const char **v2; // ebx\n  int v3; // ecx\n  int v4; // kr00_4\n  int v5; // ebx\n  __int16 v6; // dx\n\n  v1 = (int)*a1;\n  if ( *a1 )\n  {\n    v2 = a1;\n    v4 = sub_804D254(\"a\", (const char *)v1);\n    a1 = v2 + 1;\n    switch ( v4 )\n    {\n      case 0:\n      case 1:\n        v5 = 24;\n        v6 = 1536;\n        return sub_8067375(v5, v6, a1);\n      case 2:\n        v5 = 24;\n        v6 = 3072;\n        return sub_8067375(v5, v6, a1);\n      case 3:\n      case 4:\n        v5 = 24;\n        v6 = 256;\n        return sub_8067375(v5, v6, a1);\n      case 5:\n        v5 = 25;\n        v6 = 0;\n        return sub_8067375(v5, v6, a1);\n      case 6:\n        return sub_8066BBA(a1);\n      case 7:\n      case 8:\n        v1 = 0;\n        return sub_8066EDC(a1, v1);\n      case 9:\n        v5 = 24;\n        v6 = 1024;\n        return sub_8067375(v5, v6, a1);\n      case 10:\n        v5 = 24;\n        v6 = 1280;\n        return sub_8067375(v5, v6, a1);\n      case 11:\n        v5 = 24;\n        v6 = 512;\n        return sub_8067375(v5, v6, a1);\n      case 12:\n        v1 = 1;\n        return sub_8066EDC(a1, v1);\n      default:\n        sub_8069C50(v3, ident);\n    }\n  }\n  return sub_8066EDC(a1, v1);\n}\n"
        ],
        "134641833": [
            "sub_80678A9",
            "0x80678a9",
            "unsigned int __usercall sub_80678A9@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  char v4; // di\n  char v5; // al\n  int v6; // ecx\n  const char *v7; // edx\n  int v8; // eax\n  int v10; // [esp+0h] [ebp-458h]\n  size_t v11; // [esp+0h] [ebp-458h]\n  const char *v12; // [esp+4h] [ebp-454h]\n  unsigned int v13; // [esp+8h] [ebp-450h]\n  char v14[32]; // [esp+Ch] [ebp-44Ch] BYREF\n  int v15[267]; // [esp+2Ch] [ebp-42Ch] BYREF\n\n  memset(v15, 0, 0x41Cu);\n  LOWORD(v15[1]) = a1;\n  v15[0] = 28;\n  HIWORD(v15[1]) = 1;\n  LOBYTE(v15[4]) = byte_80DB764;\n  BYTE1(v15[5]) = 3;\n  if ( a1 == 32 )\n  {\n    HIWORD(v15[1]) = 1537;\n    HIBYTE(v15[5]) = 1;\n  }\n  v4 = 0;\n  while ( *a2 )\n  {\n    v5 = sub_804D254(\"from\", *a2);\n    switch ( v5 )\n    {\n      case -1:\n        v7 = ident;\n        goto LABEL_16;\n      case 0:\n        a2 = (const char **)sub_8069C3A(v12);\n        sub_8069AC1(LOBYTE(v15[4]), *a2);\n        BYTE2(v15[4]) = BYTE2(v13);\n        sub_8068F90(v14, BYTE1(v13));\n        goto LABEL_44;\n      case 1:\n        a2 = (const char **)sub_8069C3A(v12);\n        sub_8069AC1(LOBYTE(v15[4]), *a2);\n        BYTE1(v15[4]) = BYTE2(v13);\n        sub_8068F90(v14, BYTE1(v13));\n        goto LABEL_44;\n    }\n    if ( (unsigned __int8)(v5 - 2) <= 2u )\n    {\nLABEL_19:\n      a2 = (const char **)sub_8069C3A(v12);\n      v10 = sub_8069C92();\n      sub_8068F53(v10);\n      goto LABEL_44;\n    }\n    switch ( v5 )\n    {\n      case 5:\n        a2 = (const char **)sub_8069C3A(v12);\n        if ( sub_8069714() )\n        {\n          v7 = \"TOS\";\n          goto LABEL_16;\n        }\n        HIBYTE(v15[4]) = v13;\n        break;\n      case 6:\n        goto LABEL_19;\n      case 7:\n        a2 = (const char **)sub_8069C3A(v12);\n        if ( sub_80698A2() )\n        {\n          v7 = \"realms\";\n          goto LABEL_16;\n        }\n        sub_8068F53(v13);\n        break;\n      default:\n        if ( (unsigned __int8)(v5 - 8) > 1u )\n        {\n          if ( v5 == 10 || v5 == 11 )\n            goto LABEL_19;\n          if ( (unsigned __int8)(v5 - 12) > 1u )\n          {\n            if ( (unsigned __int8)(v5 - 14) > 1u )\n            {\n              if ( v5 == 16 )\n              {\n                a2 = (const char **)sub_8069C3A(v12);\n              }\n              else if ( v5 == 17 )\n              {\n                sub_804CDC2();\n              }\n              if ( sub_80697D1() )\n              {\n                v7 = \"type\";\nLABEL_16:\n                sub_8069C50(v6, v7);\n              }\n              HIBYTE(v15[5]) = v13;\n            }\n            else\n            {\n              a2 = (const char **)sub_8069C3A(v12);\n              v8 = sub_8069C04();\n              sub_8068F53(v8);\n              HIBYTE(v15[5]) = 10;\n            }\n          }\n          else\n          {\n            a2 = (const char **)sub_8069C3A(v12);\n            v12 = *a2;\n            v11 = strlen(*a2) + 1;\n            sub_8068F90(v12, v11);\n          }\n        }\n        else\n        {\n          a2 = (const char **)sub_8069C3A(v12);\n          if ( sub_8069759() )\n          {\n            v7 = \"table ID\";\n            goto LABEL_16;\n          }\n          if ( v13 <= 0xFF )\n          {\n            LOBYTE(v15[5]) = v13;\n          }\n          else\n          {\n            LOBYTE(v15[5]) = 0;\n            sub_8068F53(v13);\n          }\n          v4 = 1;\n        }\n        break;\n    }\nLABEL_44:\n    ++a2;\n  }\n  if ( !LOBYTE(v15[4]) )\n    LOBYTE(v15[4]) = 2;\n  if ( !v4 && a1 == 32 )\n    LOBYTE(v15[5]) = -2;\n  sub_8068A5B(v12);\n  return 2 * ((unsigned int)sub_8068D41(0, v15) >> 31);\n}\n"
        ],
        "134642663": [
            "sub_8067BE7",
            "0x8067be7",
            "int __fastcall sub_8067BE7(int a1, int *a2)\n{\n  int v2; // ecx\n  int result; // eax\n  char v5; // al\n  int v6; // esi\n  int v7; // eax\n  int v8; // ecx\n  int v9; // edi\n  int v10; // edx\n  const char *v11; // eax\n  FILE *v12; // edi\n  int v13; // eax\n  int v14; // ecx\n  int v15; // edx\n  int v16; // edi\n  int v17; // edx\n  const char *v18; // eax\n  const char *v19; // eax\n  const char *v20; // eax\n  int v21; // eax\n  int v22; // eax\n  const char *v23; // eax\n  const char *v24; // eax\n  char v25; // al\n  const char *v26; // eax\n  FILE *v27; // ebx\n  int v28; // eax\n  int v29; // [esp-8h] [ebp-80h]\n  int v30; // [esp-8h] [ebp-80h]\n  int v31; // [esp-4h] [ebp-7Ch]\n  int v32; // [esp-4h] [ebp-7Ch]\n  int v33; // [esp+4h] [ebp-74h]\n  int v34; // [esp+8h] [ebp-70h]\n  int v35; // [esp+Ch] [ebp-6Ch]\n  int v36; // [esp+14h] [ebp-64h]\n  int v37; // [esp+18h] [ebp-60h]\n  int v38; // [esp+28h] [ebp-50h]\n  int v39; // [esp+2Ch] [ebp-4Ch]\n  int v40; // [esp+34h] [ebp-44h]\n  int v41; // [esp+38h] [ebp-40h]\n  int v42; // [esp+3Ch] [ebp-3Ch]\n\n  v2 = *a2;\n  result = 0;\n  if ( *((_WORD *)a2 + 2) == 32 )\n  {\n    result = -1;\n    if ( v2 - 28 >= 0 )\n    {\n      sub_806901E(v2 - 28);\n      v5 = *((_BYTE *)a2 + 16);\n      v6 = 32;\n      if ( v5 != 2 )\n        v6 = v5 == 10 ? 0x80 : -1;\n      v7 = 0;\n      if ( v37 )\n        v7 = *(_DWORD *)(v37 + 4);\n      printf(\"%u:\\t\", v7);\n      printf(\"from \");\n      if ( v34 )\n      {\n        v9 = *((unsigned __int8 *)a2 + 18);\n        v10 = v34 + 4;\n        if ( v9 == v6 )\n        {\n          v12 = stdout;\n          v13 = sub_8069D47(v8, v10);\n          fputs_unlocked(v13, v12);\n        }\n        else\n        {\n          v11 = (const char *)sub_8069D47(v8, v10);\n          printf(\"%s/%u\", v11, v9);\n        }\n      }\n      else if ( *((_BYTE *)a2 + 18) )\n      {\n        printf(\"0/%d\", *((unsigned __int8 *)a2 + 18));\n      }\n      else\n      {\n        printf(\"all\");\n      }\n      sub_804DD98(32);\n      v15 = v33;\n      if ( v33 )\n      {\n        v16 = *((unsigned __int8 *)a2 + 17);\n        v17 = v33 + 4;\n        if ( v16 == v6 )\n        {\n          sub_8069D47(v14, v17);\n          printf(\"to %s \");\n        }\n        else\n        {\n          v18 = (const char *)sub_8069D47(v14, v17);\n          printf(\"to %s/%u \", v18, v16);\n        }\n      }\n      else if ( *((_BYTE *)a2 + 17) )\n      {\n        printf(\"to 0/%d \");\n      }\n      if ( *((_BYTE *)a2 + 19) )\n      {\n        v19 = (const char *)sub_80696EE();\n        printf(\"tos %s \", v19);\n        v14 = v29;\n      }\n      if ( v38 )\n      {\n        printf(\"fwmark %#x \", *(_DWORD *)(v38 + 4));\n        v15 = v31;\n      }\n      if ( v35 )\n        printf(\"iif %s \", (const char *)(v35 + 4));\n      if ( v42 || *((_BYTE *)a2 + 20) )\n      {\n        v20 = (const char *)sub_8069733(v14, v15);\n        printf(\"lookup %s \", v20);\n        v14 = v30;\n      }\n      if ( v41 )\n      {\n        v21 = *(_DWORD *)(v41 + 4);\n        if ( v21 != -1 )\n          printf(\"%s %d \", \"suppress_prefixlength\", v21);\n      }\n      if ( v40 )\n      {\n        v22 = *(_DWORD *)(v40 + 4);\n        if ( v22 != -1 )\n          printf(\"%s %d \", \"suppress_ifgroup\", v22);\n      }\n      if ( v39 )\n      {\n        if ( HIWORD(*(_DWORD *)(v39 + 4)) )\n        {\n          v23 = (const char *)sub_80696C8(v14, v15);\n          printf(\"realms %s/\", v23);\n          v15 = v32;\n        }\n        v24 = (const char *)sub_80696C8(v14, v15);\n        printf(\"%s \", v24);\n      }\n      v25 = *((_BYTE *)a2 + 23);\n      if ( v25 == 10 )\n      {\n        if ( v36 )\n        {\n          v26 = (const char *)sub_8069D47(v14, v36 + 4);\n          printf(\"map-to %s \", v26);\n        }\n        else\n        {\n          printf(\"masquerade\");\n        }\n      }\n      else if ( v25 != 1 )\n      {\n        v27 = stdout;\n        v28 = sub_8069778(v14, v15);\n        fputs_unlocked(v28, v27);\n      }\n      sub_804DD98(10);\n      return 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134643309": [
            "sub_8067E6D",
            "0x8067e6d",
            "unsigned int __usercall sub_8067E6D@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  int v5; // esi\n\n  v1 = a1;\n  if ( *a1 )\n  {\n    v2 = sub_804D254(\"add\", *a1);\n    if ( v2 < 0 )\n      sub_8069C50(v3, ident);\n    ++v1;\n    if ( v2 <= 1 )\n      return sub_80678A9(33 - (v2 == 0), v1);\n  }\n  v5 = byte_80DB764;\n  if ( !byte_80DB764 )\n    v5 = 2;\n  if ( *v1 )\n  {\n    sub_80B3CE5();\n    return -1;\n  }\n  else\n  {\n    sub_8068A5B();\n    sub_8068AE2(34, v5);\n    sub_8068BB1(0, sub_8067BE7);\n    return 0;\n  }\n}\n"
        ],
        "134643446": [
            "sub_8067EF6",
            "0x8067ef6",
            "int __usercall sub_8067EF6@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebx\n  int v4; // esi\n  char v6[16]; // [esp+0h] [ebp-28h] BYREF\n  int v7; // [esp+10h] [ebp-18h]\n\n  sub_804D67E(v6, a1);\n  v7 = a2;\n  v3 = sub_804DF99(0, 2, 2);\n  v4 = sub_804E09D(v3, 0x89F0u, (int)v6, \"SIOCGETTUNNEL\");\n  close(v3);\n  return v4;\n}\n"
        ],
        "134643520": [
            "sub_8067F40",
            "0x8067f40",
            "int __usercall sub_8067F40@<eax>(int a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  int v5; // eax\n  int v6; // ebx\n  char v8[16]; // [esp+0h] [ebp-28h] BYREF\n  const char *v9; // [esp+10h] [ebp-18h]\n\n  if ( a1 == 35315 && *a3 )\n    a2 = a3;\n  sub_804D67E(v8, a2);\n  v9 = a3;\n  v5 = sub_804DF99(0, 2, 2);\n  v6 = v5;\n  if ( a1 == 35315 )\n    sub_804E0BE(v5, 0x89F3u, (int)v8, \"SIOCCHGTUNNEL\");\n  else\n    sub_804E0BE(v5, 0x89F1u, (int)v8, \"SIOCADDTUNNEL\");\n  close(v6);\n  return 0;\n}\n"
        ],
        "134643632": [
            "sub_8067FB0",
            "0x8067fb0",
            "int __usercall sub_8067FB0@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int v2; // ebx\n  int v3; // ebx\n  char v5[16]; // [esp+0h] [ebp-24h] BYREF\n  int v6; // [esp+10h] [ebp-14h]\n\n  v2 = (int)a2;\n  if ( !*a2 )\n    a2 = a1;\n  sub_804D67E(v5, a2);\n  v6 = v2;\n  v3 = sub_804DF99(0, 2, 2);\n  sub_804E0BE(v3, 0x89F2u, (int)v5, \"SIOCDELTUNNEL\");\n  close(v3);\n  return 0;\n}\n"
        ],
        "134643707": [
            "sub_8067FFB",
            "0x8067ffb",
            "unsigned __int32 __usercall sub_8067FFB@<eax>(int *s1@<ecx>, const char **a2@<eax>, int a3@<edx>)\n{\n  int v5; // eax\n  int v6; // eax\n  char v7; // al\n  char v8; // al\n  int v9; // edx\n  int v10; // eax\n  char *v11; // eax\n  int v12; // ecx\n  int v13; // edx\n  char *v14; // eax\n  int v15; // eax\n  int v16; // ecx\n  unsigned int v17; // eax\n  int v18; // ecx\n  const char *v19; // edx\n  char v20; // al\n  int v21; // esi\n  unsigned int v22; // edx\n  unsigned __int32 result; // eax\n  int v24; // [esp-8h] [ebp-64h]\n  int v25; // [esp-8h] [ebp-64h]\n  int v26; // [esp-4h] [ebp-60h]\n  int v27; // [esp-4h] [ebp-60h]\n  int v28; // [esp+0h] [ebp-5Ch]\n  char v30[16]; // [esp+8h] [ebp-54h] BYREF\n  int v31[17]; // [esp+18h] [ebp-44h] BYREF\n\n  memset(s1, 0, 0x34u);\n  v30[0] = 0;\n  *((_BYTE *)s1 + 32) = 69;\n  *((_WORD *)s1 + 19) = 64;\n  v28 = 0;\n  while ( *a2 )\n  {\n    v5 = sub_804D222(\"mode\", *a2);\n    if ( v5 )\n    {\n      switch ( v5 )\n      {\n        case 7:\n          a2 = (const char **)sub_8069C3A(v28);\n          *((_WORD *)s1 + 10) |= 0x20u;\n          *((_WORD *)s1 + 11) |= 0x20u;\n          if ( strchr(*a2, 46) )\n            v10 = sub_8069C04(v24, v9);\n          else\n            v10 = _byteswap_ulong(sub_8069C5C(v24, \"key\"));\n          s1[7] = v10;\n          goto LABEL_22;\n        case 8:\n          a2 = (const char **)sub_8069C3A(v28);\n          *((_WORD *)s1 + 10) |= 0x20u;\n          v11 = strchr(*a2, 46);\n          v13 = v26;\n          if ( !v11 )\n          {\n            v10 = _byteswap_ulong(sub_8069C5C(v12, \"ikey\"));\nLABEL_22:\n            s1[6] = v10;\n            break;\n          }\nLABEL_28:\n          v15 = sub_8069C04(v12, v13);\n          goto LABEL_30;\n        case 9:\n          a2 = (const char **)sub_8069C3A(v28);\n          *((_WORD *)s1 + 11) |= 0x20u;\n          v14 = strchr(*a2, 46);\n          v13 = v25;\n          v12 = v27;\n          if ( v14 )\n            goto LABEL_28;\n          v15 = _byteswap_ulong(sub_8069C5C(v27, \"okey\"));\nLABEL_30:\n          s1[7] = v15;\n          break;\n        case 10:\n          *((_WORD *)s1 + 10) |= 0x10u;\nLABEL_36:\n          *((_WORD *)s1 + 11) |= 0x10u;\n          break;\n        case 11:\n          *((_WORD *)s1 + 10) |= 0x10u;\n          break;\n        case 12:\n          goto LABEL_36;\n        case 13:\n          *((_WORD *)s1 + 10) |= 0x80u;\nLABEL_42:\n          *((_WORD *)s1 + 11) |= 0x80u;\n          break;\n        case 14:\n          *((_WORD *)s1 + 10) |= 0x80u;\n          break;\n        case 15:\n          goto LABEL_42;\n        case 16:\n          *((_WORD *)s1 + 19) = 0;\n          break;\n        case 17:\n          *((_WORD *)s1 + 19) = 64;\n          break;\n        case 18:\n          a2 = (const char **)sub_8069C3A(v28);\n          if ( sub_804D222(\"mode\", *a2) != 19 )\n            s1[12] = ((int (*)(void))sub_8069C04)();\n          break;\n        case 20:\n          a2 = (const char **)sub_8069C3A(v28);\n          if ( sub_804D222(\"mode\", *a2) != 19 )\n            s1[11] = ((int (*)(void))sub_8069C04)();\n          break;\n        case 21:\n          a2 = (const char **)sub_8069C3A(v28);\n          sub_804D67E(v30, *a2);\n          break;\n        case 22:\n          a2 = (const char **)sub_8069C3A(v28);\n          if ( sub_804D222(\"mode\", *a2) != 23 )\n          {\n            v17 = sub_8069C5C(v16, \"TTL\");\n            if ( v17 > 0xFF )\n            {\n              v19 = \"TTL\";\n              goto LABEL_64;\n            }\n            *((_BYTE *)s1 + 40) = v17;\n          }\n          break;\n        default:\n          if ( (unsigned int)(v5 - 24) > 1 )\n          {\n            if ( v5 == 26 )\n              a2 = (const char **)sub_8069C3A(v28);\n            if ( *(_BYTE *)s1 )\n              sub_8069CE0();\n            sub_804D67E((char *)s1, *a2);\n            if ( a3 == 35315 && !v28 )\n            {\n              memset(v31, 0, 0x34u);\n              if ( sub_8067EF6(*a2, (int)v31) )\n                exit(1);\n              qmemcpy(s1, v31, 0x34u);\n            }\n          }\n          else\n          {\n            a2 = (const char **)sub_8069C3A(v28);\n            if ( sub_804D222(\"mode\", *a2) == 23 )\n            {\n              *((_BYTE *)s1 + 33) = 1;\n            }\n            else\n            {\n              if ( sub_8069714() )\n              {\n                v19 = \"TOS\";\nLABEL_64:\n                sub_8069C50(v18, v19);\n              }\n              *((_BYTE *)s1 + 33) = v31[0];\n            }\n          }\n          break;\n      }\n    }\n    else\n    {\n      a2 = (const char **)sub_8069C3A(v28);\n      v6 = sub_804D222(\"mode\", *a2);\n      if ( (unsigned int)(v6 - 1) > 1 )\n      {\n        if ( (unsigned int)(v6 - 3) > 1 )\n        {\n          if ( (unsigned int)(v6 - 5) > 1 )\n            sub_804D5E0(\"%s tunnel mode\", \"can't guess\");\n          v8 = *((_BYTE *)s1 + 41);\n          if ( v8 && v8 != 41 )\nLABEL_6:\n            sub_804D5E0(\"%s tunnel mode\", \"you managed to ask for more than one\");\n          *((_BYTE *)s1 + 41) = 41;\n        }\n        else\n        {\n          v7 = *((_BYTE *)s1 + 41);\n          if ( v7 && v7 != 47 )\n            goto LABEL_6;\n          *((_BYTE *)s1 + 41) = 47;\n        }\n      }\n      else\n      {\n        if ( (*((_BYTE *)s1 + 41) & 0xFB) != 0 )\n          goto LABEL_6;\n        *((_BYTE *)s1 + 41) = 4;\n      }\n    }\n    ++v28;\n    ++a2;\n  }\n  if ( !*((_BYTE *)s1 + 41) )\n  {\n    if ( !memcmp(s1, \"gre\", 3u) )\n    {\n      *((_BYTE *)s1 + 41) = 47;\n    }\n    else if ( !memcmp(s1, \"ipip\", 4u) )\n    {\n      *((_BYTE *)s1 + 41) = 4;\n    }\n    else if ( !memcmp(s1, \"sit\", 3u) )\n    {\n      *((_BYTE *)s1 + 41) = 41;\n    }\n  }\n  v20 = *((_BYTE *)s1 + 41);\n  if ( (v20 == 4 || v20 == 41) && ((s1[5] & 0x20) != 0 || (*((_BYTE *)s1 + 22) & 0x20) != 0) )\n    sub_804D5E0(\"keys are not allowed with ipip and sit\");\n  if ( v30[0] )\n  {\n    sub_804D67E((char *)v31, v30);\n    v21 = sub_804DF99(0, 2, 2);\n    sub_804E0BE(v21, 0x8933u, (int)v31, \"SIOCGIFINDEX\");\n    close(v21);\n    s1[4] = v31[4];\n  }\n  v22 = s1[12];\n  result = _byteswap_ulong(v22) & 0xF0000000;\n  if ( !s1[6] && result == -536870912 )\n  {\n    s1[6] = v22;\n    *((_WORD *)s1 + 10) |= 0x20u;\n  }\n  if ( s1[7] )\n  {\n    if ( result == -536870912 )\n      goto LABEL_98;\n  }\n  else if ( result == -536870912 )\n  {\n    s1[7] = v22;\n    *((_WORD *)s1 + 11) |= 0x20u;\nLABEL_98:\n    if ( !s1[11] )\n      sub_804D5E0(\"broadcast tunnel requires a source address\");\n  }\n  return result;\n}\n"
        ],
        "134644877": [
            "sub_806848D",
            "0x806848d",
            "int __usercall sub_806848D@<eax>(int a1@<eax>, const char **a2@<edx>)\n{\n  const char *v3; // edx\n  int v5[9]; // [esp+0h] [ebp-38h] BYREF\n  __int16 v6; // [esp+26h] [ebp-12h]\n  char v7; // [esp+28h] [ebp-10h]\n  char v8; // [esp+29h] [ebp-Fh]\n\n  sub_8067FFB(v5, a2, a1);\n  if ( v7 && !v6 )\n    sub_804D5E0(\"ttl != 0 and noptmudisc are incompatible\");\n  switch ( v8 )\n  {\n    case 41:\n      v3 = \"sit0\";\n      break;\n    case 47:\n      v3 = \"gre0\";\n      break;\n    case 4:\n      v3 = \"tunl0\";\n      break;\n    default:\n      sub_804D5E0(\"can't determine tunnel mode (ipip, gre or sit)\");\n  }\n  return sub_8067F40(a1, v3, (const char *)v5);\n}\n"
        ],
        "134644979": [
            "sub_80684F3",
            "0x80684f3",
            "const char *__usercall sub_80684F3@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // esi\n  const char *v4; // eax\n  char v5; // cl\n  const char *v6; // edx\n  int v7; // edi\n  int v8; // ebp\n  const char *v9; // eax\n  char *v10; // edi\n  const char *v11; // eax\n  const char *result; // eax\n  const char *v13; // [esp-8h] [ebp-48h]\n  int v14; // [esp-8h] [ebp-48h]\n  char buf[16]; // [esp+0h] [ebp-40h] BYREF\n  char v16[16]; // [esp+10h] [ebp-30h] BYREF\n  int v17; // [esp+20h] [ebp-20h]\n\n  v3 = \"any\";\n  if ( *(_DWORD *)(a1 + 44) )\n    v3 = (const char *)sub_8069D47(a2, a1 + 44);\n  v4 = \"any\";\n  if ( *(_DWORD *)(a1 + 48) )\n    v4 = (const char *)sub_8069D47(a2, a1 + 48);\n  v5 = *(_BYTE *)(a1 + 41);\n  v6 = \"ip\";\n  if ( v5 != 4 )\n  {\n    v6 = \"gre\";\n    if ( v5 != 47 )\n    {\n      v6 = \"ipv6\";\n      if ( v5 != 41 )\n        v6 = \"unknown\";\n    }\n  }\n  printf(\"%s: %s/ip  remote %s  local %s \", (const char *)a1, v6, v4, v3);\n  if ( *(_DWORD *)(a1 + 16) )\n  {\n    v17 = *(_DWORD *)(a1 + 16);\n    v7 = sub_804DF99(0, 2, 2);\n    v8 = sub_804E09D(v7, 0x8910u, (int)v16, \"SIOCGIFNAME\");\n    close(v7);\n    if ( !v8 )\n    {\n      v9 = sub_804DB5D(v16, 16);\n      v10 = (char *)v9;\n      if ( v9 )\n      {\n        printf(\" dev %s \", v9);\n        free(v10);\n      }\n    }\n  }\n  if ( *(_BYTE *)(a1 + 40) )\n    printf(\" ttl %d \", *(unsigned __int8 *)(a1 + 40));\n  else\n    printf(\" ttl inherit \");\n  if ( *(_BYTE *)(a1 + 33) )\n  {\n    printf(\" tos\");\n    if ( (*(_BYTE *)(a1 + 33) & 1) != 0 )\n      printf(\" inherit\");\n    if ( (*(_BYTE *)(a1 + 33) & 0xFE) != 0 )\n    {\n      v11 = (const char *)sub_80696EE();\n      printf(\"%c%s \", (*(_BYTE *)(a1 + 33) & 1) == 0 ? 32 : 47, v11);\n    }\n  }\n  if ( (*(_BYTE *)(a1 + 38) & 0x40) == 0 )\n    printf(\" nopmtudisc\");\n  inet_ntop(2, (const void *)(a1 + 24), buf, 0x10u);\n  result = inet_ntop(2, (const void *)(a1 + 28), v16, 0x10u);\n  if ( (*(_BYTE *)(a1 + 20) & 0x20) != 0 )\n  {\n    if ( (*(_BYTE *)(a1 + 22) & 0x20) != 0 && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a1 + 24) )\n    {\n      result = (const char *)printf(\" key %s\");\n      goto LABEL_30;\n    }\n    result = (const char *)printf(\" ikey %s \", buf);\n  }\n  if ( (*(_BYTE *)(a1 + 22) & 0x20) != 0 )\n    result = (const char *)printf(\" okey %s \");\nLABEL_30:\n  if ( (*(_BYTE *)(a1 + 20) & 0x10) != 0 )\n  {\n    printf(\"%c  Drop packets out of sequence.\\n\", (unsigned __int8)byte_80DBBA5);\n    result = v13;\n  }\n  if ( *(char *)(a1 + 20) < 0 )\n    result = (const char *)printf(\"%c  Checksum in received packet is required.\", (unsigned __int8)byte_80DBBA5);\n  if ( (*(_BYTE *)(a1 + 22) & 0x10) != 0 )\n    result = (const char *)printf(\"%c  Sequence packets on output.\", (unsigned __int8)byte_80DBBA5);\n  if ( *(char *)(a1 + 22) < 0 )\n  {\n    printf(\"%c  Checksum output packets.\", (unsigned __int8)byte_80DBBA5);\n    return (const char *)v14;\n  }\n  return result;\n}\n"
        ],
        "134645533": [
            "sub_806871D",
            "0x806871d",
            "char *__usercall sub_806871D@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  char *result; // eax\n  char *v4; // ebp\n  char *v5; // eax\n  int v6; // edi\n  int v7; // ecx\n  int v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  int v12; // eax\n  int v13; // [esp-4h] [ebp-2B4h]\n  char *v14; // [esp+0h] [ebp-2B0h]\n  char *v15; // [esp+0h] [ebp-2B0h]\n  char v16; // [esp+4h] [ebp-2ACh] BYREF\n  char v17; // [esp+8h] [ebp-2A8h] BYREF\n  char v18; // [esp+Ch] [ebp-2A4h] BYREF\n  char v19; // [esp+10h] [ebp-2A0h] BYREF\n  char v20; // [esp+14h] [ebp-29Ch] BYREF\n  char v21; // [esp+18h] [ebp-298h] BYREF\n  char v22; // [esp+1Ch] [ebp-294h] BYREF\n  char v23; // [esp+20h] [ebp-290h] BYREF\n  char v24; // [esp+24h] [ebp-28Ch] BYREF\n  char v25; // [esp+28h] [ebp-288h] BYREF\n  char v26; // [esp+2Ch] [ebp-284h] BYREF\n  char v27; // [esp+30h] [ebp-280h] BYREF\n  char v28; // [esp+34h] [ebp-27Ch] BYREF\n  char v29; // [esp+38h] [ebp-278h] BYREF\n  char s2[16]; // [esp+3Ch] [ebp-274h] BYREF\n  char v31[16]; // [esp+4Ch] [ebp-264h] BYREF\n  int v32; // [esp+5Ch] [ebp-254h]\n  char s1[52]; // [esp+6Ch] [ebp-244h] BYREF\n  char s[528]; // [esp+A0h] [ebp-210h] BYREF\n\n  result = (char *)sub_80B3D18(a2, \"r\");\n  if ( result )\n  {\n    v4 = result;\n    fgets_unlocked(s, 512, result);\n    fgets_unlocked(s, 512, v4);\n    while ( 1 )\n    {\n      result = (char *)fgets_unlocked(s, 512, v4);\n      if ( !result )\n        break;\n      v5 = strchr(s, 58);\n      if ( !v5 )\n        return sub_804D5F4(\"wrong format of /proc/net/dev\");\n      v14 = v5 + 1;\n      *v5 = 0;\n      if ( sscanf(s, \"%s\", s2) != 1 )\n        return sub_804D5F4(\"wrong format of /proc/net/dev\");\n      if ( sscanf(\n             v14,\n             \"%lu%lu%lu%lu%lu%lu%lu%*d%lu%lu%lu%lu%lu%lu%lu\",\n             &v16,\n             &v17,\n             &v18,\n             &v19,\n             &v20,\n             &v21,\n             &v29,\n             &v22,\n             &v23,\n             &v24,\n             &v25,\n             &v26,\n             &v27,\n             &v28) == 14\n        && (!*(_BYTE *)a1 || !strcmp((const char *)a1, s2)) )\n      {\n        sub_804D67E(v31, s2);\n        v6 = sub_804DF99(0, 2, 2);\n        v15 = (char *)sub_804E09D(v6, 0x8927u, (int)v31, \"SIOCGIFHWADDR\");\n        close(v6);\n        if ( v15 )\n        {\n          sub_804D5F4(\"can't get type of [%s]\", s2);\n        }\n        else if ( (v32 & 0xFFF7) == 768 || (_WORD)v32 == 778 )\n        {\n          memset(s1, 0, sizeof(s1));\n          if ( !sub_8067EF6(s2, (int)s1) )\n          {\n            v8 = *(_DWORD *)(a1 + 16);\n            if ( !v8 || v8 == *(_DWORD *)&s1[16] )\n            {\n              if ( !*(_BYTE *)a1 || (v9 = strcmp(s1, (const char *)a1), v7 = v13, !v9) )\n              {\n                v10 = *(_DWORD *)(a1 + 48);\n                if ( !v10 || v10 == *(_DWORD *)&s1[48] )\n                {\n                  v11 = *(_DWORD *)(a1 + 44);\n                  if ( !v11 || v11 == *(_DWORD *)&s1[44] )\n                  {\n                    v12 = *(_DWORD *)(a1 + 24);\n                    if ( !v12 || v12 == *(_DWORD *)&s1[24] )\n                    {\n                      sub_80684F3((int)s1, v7);\n                      sub_804DD98(10);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"
        ],
        "134646089": [
            "sub_8068949",
            "0x8068949",
            "int __usercall sub_8068949@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebx\n  int v2; // eax\n  int v3; // ecx\n  const char **v4; // edx\n  int v5; // eax\n  int v7; // ebx\n  const char *v8; // eax\n  int v9; // ecx\n  const char *v10; // eax\n  int v11; // ecx\n  int v13[10]; // [esp+0h] [ebp-38h] BYREF\n  char v14; // [esp+29h] [ebp-Fh]\n\n  v1 = a1;\n  if ( *a1 )\n  {\n    v2 = sub_804D254(\"add\", *a1);\n    if ( v2 < 0 )\n      sub_8069C50(v3, ident);\n    ++v1;\n    switch ( v2 )\n    {\n      case 0:\n        v4 = v1;\n        v5 = 35313;\n        return sub_806848D(v5, v4);\n      case 1:\n        v4 = v1;\n        v5 = 35315;\n        return sub_806848D(v5, v4);\n      case 2:\n        sub_8067FFB(v13, v1, 35314);\n        switch ( v14 )\n        {\n          case 41:\n            v8 = \"sit0\";\n            break;\n          case 47:\n            v8 = \"gre0\";\n            break;\n          case 4:\n            v8 = \"tunl0\";\n            break;\n          default:\n            v8 = (const char *)v13;\n            break;\n        }\n        return sub_8067FB0(v8, (const char *)v13);\n    }\n  }\n  sub_8067FFB(v13, v1, 35312);\n  if ( v14 == 41 )\n  {\n    v10 = (const char *)v13;\n    if ( !LOBYTE(v13[0]) )\n      v10 = \"sit0\";\n  }\n  else if ( v14 == 47 )\n  {\n    v10 = (const char *)v13;\n    if ( !LOBYTE(v13[0]) )\n      v10 = \"gre0\";\n  }\n  else\n  {\n    v10 = (const char *)v13;\n    if ( v14 != 4 )\n    {\n      sub_806871D((int)v13, v9);\n      return 0;\n    }\n    if ( !LOBYTE(v13[0]) )\n      v10 = \"tunl0\";\n  }\n  v7 = sub_8067EF6(v10, (int)v13);\n  if ( v7 )\n    return -1;\n  sub_80684F3((int)v13, v11);\n  sub_804DD98(10);\n  return v7;\n}\n"
        ],
        "134646363": [
            "sub_8068A5B",
            "0x8068a5b",
            "int __usercall sub_8068A5B@<eax>(int *a1@<eax>)\n{\n  int v2; // eax\n  int v4; // [esp-4h] [ebp-10h]\n\n  memset(a1, 0, 0x24u);\n  v2 = sub_804DF99(0, 3, 16);\n  *a1 = v2;\n  *((_WORD *)a1 + 2) = 16;\n  sub_804DFB3(0xCu, (struct sockaddr *)(a1 + 1), v2);\n  sub_80A998A(12, a1 + 1);\n  a1[7] = time(0);\n  return v4;\n}\n"
        ],
        "134646446": [
            "sub_8068AAE",
            "0x8068aae",
            "ssize_t __usercall sub_8068AAE@<eax>(size_t n@<ecx>, int *a2@<eax>, void *a3@<edx>)\n{\n  struct sockaddr v4; // [esp+0h] [ebp-1Ch] BYREF\n\n  memset(v4.sa_data, 0, 0xAu);\n  v4.sa_family = 16;\n  return sub_804DFCD(n, a3, *a2, &v4, 0xCu);\n}\n"
        ],
        "134646498": [
            "sub_8068AE2",
            "0x8068ae2",
            "ssize_t __usercall sub_8068AE2@<eax>(int *a1@<eax>, char a2@<dl>, __int16 a3@<cx>)\n{\n  int v3; // ecx\n  int v5; // [esp+0h] [ebp-14h] BYREF\n  __int16 v6; // [esp+4h] [ebp-10h]\n  __int16 v7; // [esp+6h] [ebp-Eh]\n  int v8; // [esp+8h] [ebp-Ch]\n  int v9; // [esp+Ch] [ebp-8h]\n  char v10; // [esp+10h] [ebp-4h]\n\n  v5 = 20;\n  v6 = a3;\n  v7 = 769;\n  v9 = 0;\n  v3 = a1[7] + 1;\n  a1[7] = v3;\n  a1[8] = v3;\n  v8 = v3;\n  v10 = a2;\n  return sub_8068AAE(0x14u, a1, &v5);\n}\n"
        ],
        "134646562": [
            "sub_8068B22",
            "0x8068b22",
            "ssize_t __userpurge sub_8068B22@<eax>(int *a1@<eax>, __int16 a2@<dx>, int a3@<ecx>, int a4)\n{\n  int v5; // eax\n  _DWORD v7[4]; // [esp+0h] [ebp-1Ch] BYREF\n  int v8; // [esp+10h] [ebp-Ch] BYREF\n  __int16 v9; // [esp+14h] [ebp-8h]\n  __int16 v10; // [esp+16h] [ebp-6h]\n  int v11; // [esp+18h] [ebp-4h]\n  _DWORD v12[14]; // [esp+1Ch] [ebp+0h] BYREF\n\n  v7[0] = &v8;\n  v7[1] = 16;\n  v7[2] = a3;\n  v7[3] = a4;\n  memset(v12, 0, 0x2Cu);\n  v12[1] = &v12[8];\n  v12[2] = 12;\n  v12[3] = v7;\n  v12[4] = 2;\n  LOWORD(v12[8]) = 16;\n  v8 = a4 + 16;\n  v9 = a2;\n  v10 = 769;\n  v5 = a1[7] + 1;\n  a1[7] = v5;\n  a1[8] = v5;\n  v11 = v5;\n  return sendmsg(*a1, (const struct msghdr *)&v12[1], 0);\n}\n"
        ],
        "134646705": [
            "sub_8068BB1",
            "0x8068bb1",
            "int __usercall sub_8068BB1@<eax>(int *a1@<eax>, int (__fastcall *a2)(int, unsigned int *)@<edx>, int a3@<ecx>)\n{\n  ssize_t v5; // eax\n  int v6; // esi\n  int v7; // eax\n  unsigned int v8; // eax\n  unsigned int *i; // ebx\n  unsigned int v10; // eax\n  unsigned int v11; // edx\n  unsigned int *ptr; // [esp+8h] [ebp-48h]\n  int v15; // [esp+Ch] [ebp-44h]\n  int v16[2]; // [esp+10h] [ebp-40h] BYREF\n  char v17; // [esp+18h] [ebp-38h] BYREF\n  int v18; // [esp+1Ch] [ebp-34h]\n  struct msghdr message; // [esp+24h] [ebp-2Ch] BYREF\n\n  ptr = (unsigned int *)sub_804DAFA(0x2000u);\n  v16[0] = (int)ptr;\n  v16[1] = 0x2000;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      message.msg_name = &v17;\n      message.msg_namelen = 12;\n      message.msg_iov = (struct iovec *)v16;\n      message.msg_iovlen = 1;\n      memset(&message.msg_control, 0, 12);\n      v5 = recvmsg(*a1, &message, 0);\n      v6 = v5;\n      if ( v5 >= 0 )\n        break;\n      if ( *(_DWORD *)dword_80DBB7C != 4 )\n        sub_804D3A5((int)\"OVERRUN\");\n    }\n    if ( !v5 )\n      break;\n    if ( message.msg_namelen != 12 )\n      sub_804D5E0(\"sender address length == %d\", message.msg_namelen);\n    for ( i = ptr; v6 > 15; i = (unsigned int *)((char *)i + v8) )\n    {\n      v10 = *i;\n      if ( *i <= 0xF || v6 < v10 )\n        break;\n      if ( !v18 && i[3] == a1[2] && i[2] == a1[8] )\n      {\n        v11 = i[1];\n        if ( (_WORD)v11 == 3 )\n        {\n          v7 = 0;\n          goto LABEL_29;\n        }\n        if ( (_WORD)v11 == 2 )\n        {\n          if ( v10 > 0x23 )\n          {\n            *(_DWORD *)dword_80DBB7C = -i[4];\n            sub_804D3A5((int)\"RTNETLINK answers\");\n          }\n          else\n          {\n            sub_804D5F4(\"ERROR truncated\");\n          }\n          goto LABEL_22;\n        }\n        v7 = a2(a3, i);\n        if ( v7 < 0 )\n          goto LABEL_29;\n      }\n      v8 = (*i + 3) & 0xFFFFFFFC;\n      v6 -= v8;\n    }\n    if ( (message.msg_flags & 0x20) != 0 )\n    {\n      sub_804D5F4(\"message truncated\");\n    }\n    else if ( v6 )\n    {\n      sub_804D5E0(\"remnant of size %d!\", v6);\n    }\n  }\n  sub_804D5F4(\"EOF on netlink\");\nLABEL_22:\n  v7 = -1;\nLABEL_29:\n  v15 = v7;\n  free(ptr);\n  if ( v15 )\n    sub_804D5E0(\"dump terminated\");\n  return 0;\n}\n"
        ],
        "134647105": [
            "sub_8068D41",
            "0x8068d41",
            "int __usercall sub_8068D41@<eax>(int *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)\n{\n  int v6; // edi\n  ssize_t v7; // eax\n  int v8; // ebp\n  unsigned int *i; // esi\n  unsigned int v10; // ecx\n  unsigned int v11; // ecx\n  _DWORD *ptr; // [esp+0h] [ebp-4Ch]\n  unsigned int v14; // [esp+4h] [ebp-48h]\n  ssize_t v15; // [esp+8h] [ebp-44h]\n  _DWORD *v16; // [esp+Ch] [ebp-40h] BYREF\n  int v17; // [esp+10h] [ebp-3Ch]\n  _DWORD v18[3]; // [esp+14h] [ebp-38h] BYREF\n  struct msghdr message; // [esp+20h] [ebp-2Ch] BYREF\n\n  v16 = (_DWORD *)a2;\n  v17 = *(_DWORD *)a2;\n  ptr = sub_804DAFA(0x2000u);\n  message.msg_name = v18;\n  message.msg_namelen = 12;\n  message.msg_iov = (struct iovec *)&v16;\n  message.msg_iovlen = 1;\n  memset(&message.msg_control, 0, 12);\n  memset((char *)v18 + 2, 0, 0xAu);\n  LOWORD(v18[0]) = 16;\n  v6 = a1[7] + 1;\n  a1[7] = v6;\n  *(_DWORD *)(a2 + 8) = v6;\n  if ( !a3 )\n    *(_WORD *)(a2 + 6) |= 4u;\n  if ( sendmsg(*a1, &message, 0) < 0 )\n  {\n    sub_804D3A5((int)\"can't talk to rtnetlink\");\nLABEL_11:\n    v8 = -1;\n    goto LABEL_38;\n  }\n  v16 = ptr;\nLABEL_6:\n  while ( 1 )\n  {\n    v17 = 0x2000;\n    v7 = recvmsg(*a1, &message, 0);\n    if ( v7 >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 4 )\n      sub_804D3A5((int)\"OVERRUN\");\n  }\n  if ( !v7 )\n  {\n    sub_804D5F4(\"EOF on netlink\");\n    goto LABEL_11;\n  }\n  if ( message.msg_namelen != 12 )\n    sub_804D5E0(\"sender address length == %d\", message.msg_namelen);\n  for ( i = ptr; ; i = (unsigned int *)((char *)i + v11) )\n  {\n    do\n    {\n      if ( v7 <= 15 )\n      {\n        if ( (message.msg_flags & 0x20) != 0 )\n        {\n          sub_804D5F4(\"message truncated\");\n        }\n        else if ( v7 )\n        {\n          sub_804D5E0(\"remnant of size %d!\", v7);\n        }\n        goto LABEL_6;\n      }\n      v10 = *i;\n      if ( v7 < (int)*i || (int)(*i - 16) < 0 )\n      {\n        if ( (message.msg_flags & 0x20) == 0 )\n          sub_804D5E0(\"malformed message: len=%d!\", v10);\n        sub_804D5F4(\"truncated message\");\n        goto LABEL_11;\n      }\n    }\n    while ( v18[1] || i[3] != a1[2] || v6 != i[2] );\n    if ( *((_WORD *)i + 2) == 2 )\n      break;\n    if ( a3 )\n    {\n      qmemcpy(a3, i, v10);\n      v8 = 0;\n      goto LABEL_38;\n    }\n    v15 = v7;\n    v14 = *i;\n    sub_804D5F4(\"unexpected reply!\");\n    v11 = (v14 + 3) & 0xFFFFFFFC;\n    v7 = v15 - v11;\n  }\n  if ( (int)(*i - 16) <= 19 )\n  {\n    sub_804D5F4(\"ERROR truncated\");\n    goto LABEL_11;\n  }\n  v8 = i[4];\n  *(_DWORD *)dword_80DBB7C = -v8;\n  if ( v8 )\n  {\n    sub_804D3A5((int)\"RTNETLINK answers\");\n    goto LABEL_11;\n  }\n  if ( a3 )\n    qmemcpy(a3, i, *i);\nLABEL_38:\n  free(ptr);\n  return v8;\n}\n"
        ],
        "134647635": [
            "sub_8068F53",
            "0x8068f53",
            "int __userpurge sub_8068F53@<eax>(unsigned int *a1@<eax>, signed int a2@<edx>, __int16 a3@<cx>, int a4)\n{\n  char *v4; // edx\n\n  if ( (int)((*a1 + 11) & 0xFFFFFFFC) > a2 )\n    return -1;\n  v4 = (char *)a1 + ((*a1 + 3) & 0xFFFFFFFC);\n  *((_WORD *)v4 + 1) = a3;\n  *(_WORD *)v4 = 8;\n  *((_DWORD *)v4 + 1) = a4;\n  *a1 = (*a1 + 11) & 0xFFFFFFFC;\n  return 0;\n}\n"
        ],
        "134647696": [
            "sub_8068F90",
            "0x8068f90",
            "int __userpurge sub_8068F90@<eax>(\n        unsigned int *a1@<eax>,\n        signed int a2@<edx>,\n        __int16 a3@<cx>,\n        const void *a4,\n        unsigned int a5)\n{\n  unsigned int v5; // ebx\n  int v6; // edi\n  _WORD *v7; // edi\n\n  v5 = a5 + 4;\n  v6 = *a1 + 3;\n  if ( (int)((a5 + 4 + v6) & 0xFFFFFFFC) > a2 )\n    return -1;\n  v7 = (_WORD *)((char *)a1 + (v6 & 0xFFFFFFFC));\n  v7[1] = a3;\n  *v7 = v5;\n  qmemcpy(v7 + 2, a4, a5);\n  *a1 = (v5 + *a1 + 3) & 0xFFFFFFFC;\n  return 0;\n}\n"
        ],
        "134647774": [
            "sub_8068FDE",
            "0x8068fde",
            "int __userpurge sub_8068FDE@<eax>(_WORD *a1@<eax>, unsigned int a2@<edx>, __int16 a3@<cx>, int a4)\n{\n  int v4; // ebx\n  char *v5; // edx\n\n  v4 = (unsigned __int16)*a1;\n  if ( ((v4 + 11) & 0xFFFFFFFC) > a2 )\n    return -1;\n  v5 = (char *)a1 + ((v4 + 3) & 0xFFFFFFFC);\n  *((_WORD *)v5 + 1) = a3;\n  *(_WORD *)v5 = 8;\n  *((_DWORD *)v5 + 1) = a4;\n  *a1 = (*a1 + 11) & 0xFFFC;\n  return 0;\n}\n"
        ],
        "134647838": [
            "sub_806901E",
            "0x806901e",
            "char *__userpurge sub_806901E@<eax>(void *a1@<eax>, int a2@<edx>, unsigned __int16 *a3@<ecx>, int a4)\n{\n  char *result; // eax\n  int v8; // eax\n  int v9; // ecx\n\n  result = 0;\n  memset(a1, 0, 4 * a2 + 4);\n  while ( a4 > 3 )\n  {\n    v8 = *a3;\n    if ( (unsigned __int16)v8 <= 3u || v8 > a4 )\n      return sub_804D5F4(\"deficit %d, rta_len=%d!\", a4, *a3);\n    v9 = a3[1];\n    if ( v9 <= a2 )\n      *((_DWORD *)a1 + v9) = a3;\n    result = (char *)((v8 + 3) & 0xFFFFFFFC);\n    a4 -= (int)result;\n    a3 = (unsigned __int16 *)((char *)a3 + (_DWORD)result);\n  }\n  if ( !a4 )\n    return result;\n  return sub_804D5F4(\"deficit %d, rta_len=%d!\", a4, *a3);\n}\n"
        ],
        "134647934": [
            "sub_806907E",
            "0x806907e",
            "const char *__userpurge sub_806907E@<eax>(\n        unsigned __int8 *a1@<eax>,\n        int a2@<edx>,\n        int a3@<ecx>,\n        char *buf,\n        socklen_t len)\n{\n  size_t v6; // ebx\n  int v7; // edi\n  int i; // esi\n\n  v6 = len;\n  if ( a2 == 4 && ((a3 & 0xFFFFFFF7) == 768 || a3 == 778) )\n    return inet_ntop(2, a1, buf, len);\n  v7 = 0;\n  for ( i = 0; i < a2; ++i )\n  {\n    if ( i )\n    {\n      snprintf(&buf[v7], v6, \":%02x\", a1[i]);\n      v6 -= 3;\n      v7 += 3;\n    }\n    else\n    {\n      snprintf(&buf[v7], v6, \"%02x\", *a1);\n      v6 -= 2;\n      v7 += 2;\n    }\n  }\n  return buf;\n}\n"
        ],
        "134648081": [
            "sub_8069111",
            "0x8069111",
            "int __usercall sub_8069111@<eax>(char *s@<ecx>, _DWORD *a2@<eax>, int a3@<edx>)\n{\n  const char *v5; // ebp\n  int result; // eax\n  int i; // ebx\n  char *v8; // eax\n  char *v9; // edx\n  char *sa; // [esp+0h] [ebp-28h]\n  unsigned int v11; // [esp+4h] [ebp-24h] BYREF\n  int v12; // [esp+8h] [ebp-20h]\n\n  v5 = s;\n  if ( strchr(s, 46) )\n  {\n    if ( sub_8069980(2, v5) )\n    {\nLABEL_12:\n      sub_804D5F4(\"\\\"%s\\\" is invalid lladdr\", v5);\n      return -1;\n    }\n    else\n    {\n      result = -1;\n      if ( a3 > 3 )\n      {\n        *a2 = v12;\n        return 4;\n      }\n    }\n  }\n  else\n  {\n    for ( i = 0; i < a3; ++i )\n    {\n      v8 = strchr(v5, 58);\n      v9 = v8;\n      if ( v8 )\n      {\n        *v8 = 0;\n        v9 = v8 + 1;\n      }\n      sa = v9;\n      if ( sscanf(v5, \"%x\", &v11) != 1 || v11 > 0xFF )\n        goto LABEL_12;\n      *((_BYTE *)a2 + i) = v11;\n      if ( !sa )\n        break;\n      v5 = sa;\n    }\n    return i + 1;\n  }\n  return result;\n}\n"
        ],
        "134648263": [
            "sub_80691C7",
            "0x80691c7",
            "_DWORD *__usercall sub_80691C7@<eax>(int a1@<eax>)\n{\n  _DWORD *i; // edx\n\n  if ( !dword_80DB65C )\n    return 0;\n  for ( i = *(_DWORD **)(dword_80DB65C + 4 * (a1 & 0xF)); i && i[1] != a1; i = (_DWORD *)*i )\n    ;\n  return i;\n}\n"
        ],
        "134648299": [
            "sub_80691EB",
            "0x80691eb",
            "int __fastcall sub_80691EB(int a1, int a2)\n{\n  int result; // eax\n  _DWORD *i; // edi\n  _DWORD *v5; // ebx\n  unsigned __int16 *v6; // eax\n  unsigned __int16 *v7; // edx\n  signed int v8; // ecx\n  char v9[4]; // [esp+0h] [ebp-D4h] BYREF\n  unsigned __int16 *v10; // [esp+4h] [ebp-D0h]\n  int v11; // [esp+Ch] [ebp-C8h]\n\n  if ( *(_WORD *)(a2 + 4) != 16 )\n    return 0;\n  result = -1;\n  if ( *(_DWORD *)a2 > 0x13u )\n  {\n    sub_806901E(v9, 49, (unsigned __int16 *)(a2 + 32), *(_DWORD *)a2 - 32);\n    if ( v11 )\n    {\n      if ( !dword_80DB65C )\n        dword_80DB65C = (int)sub_804DB2E(0x40u);\n      for ( i = (_DWORD *)(dword_80DB65C + 4 * (*(_DWORD *)(a2 + 20) & 0xF)); ; i = (_DWORD *)*i )\n      {\n        v5 = (_DWORD *)*i;\n        if ( !*i )\n          break;\n        if ( *(_DWORD *)(a2 + 20) == v5[1] )\n          goto LABEL_11;\n      }\n      v5 = sub_804DAFA(0x2Cu);\n      *v5 = *i;\n      v5[1] = *(_DWORD *)(a2 + 20);\n      *i = v5;\nLABEL_11:\n      v5[2] = *(unsigned __int16 *)(a2 + 18);\n      v5[4] = *(_DWORD *)(a2 + 24);\n      v6 = v10;\n      v7 = (unsigned __int16 *)(v5 + 5);\n      if ( v10 )\n      {\n        v8 = *v10 - 4;\n        v5[3] = v8;\n        if ( v8 > 8 )\n          v8 = 8;\n        qmemcpy(v7, v6 + 2, v8);\n      }\n      else\n      {\n        v5[3] = 0;\n        memset(v7, 0, 8u);\n      }\n      strcpy((char *)v5 + 28, (const char *)(v11 + 4));\n    }\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134648549": [
            "sub_80692E5",
            "0x80692e5",
            "int __usercall sub_80692E5@<eax>(int a1@<eax>)\n{\n  _DWORD *v2; // eax\n  int v4; // [esp-Ch] [ebp-Ch]\n  int v5; // [esp-8h] [ebp-8h]\n\n  if ( !a1 )\n    return 135039284;\n  v2 = sub_80691C7(a1);\n  if ( v2 )\n    return (int)(v2 + 7);\n  sub_804DDBF(\"if%d\", a1);\n  return sub_80A9707(v5, v4);\n}\n"
        ],
        "134648595": [
            "sub_8069313",
            "0x8069313",
            "int __usercall sub_8069313@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  _DWORD *v2; // eax\n\n  v1 = 0;\n  if ( a1 )\n  {\n    v2 = sub_80691C7(a1);\n    v1 = 0;\n    if ( v2 )\n      return v2[4];\n  }\n  return v1;\n}\n"
        ],
        "134648618": [
            "sub_806932A",
            "0x806932a",
            "int __usercall sub_806932A@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n\n  result = if_nametoindex(a1);\n  if ( result <= 0 )\n    sub_804D5E0(\"can't find device '%s'\", a1);\n  return result;\n}\n"
        ],
        "134648645": [
            "sub_8069345",
            "0x8069345",
            "int __usercall sub_8069345@<eax>(int *a1@<eax>)\n{\n  sub_8068AE2(a1, 0, 18);\n  sub_8068BB1(a1, (int (__fastcall *)(int, unsigned int *))sub_80691EB, 0);\n  return 0;\n}\n"
        ],
        "134648678": [
            "sub_8069366",
            "0x8069366",
            "int __usercall sub_8069366@<eax>(_WORD *a1@<eax>, const char *a2@<edx>)\n{\n  const char *v4; // edi\n  int i; // ebx\n  unsigned int v6; // eax\n  _DWORD *v7; // ebx\n  __int16 v8; // ax\n  char v9; // t0\n\n  v4 = \"loop\";\n  for ( i = 0; i != 43; ++i )\n  {\n    if ( !strcasecmp(v4, a2) )\n    {\n      LOWORD(v6) = word_80B5B40[i];\nLABEL_7:\n      v9 = BYTE1(v6);\n      HIBYTE(v8) = v6;\n      LOBYTE(v8) = v9;\n      *a1 = v8;\n      return 0;\n    }\n    v4 += strlen(v4) + 1;\n  }\n  v7 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v6 = sub_804ED6C(0, a2, 0, (int)v7);\n  if ( !*v7 && v6 <= 0xFFFF )\n    goto LABEL_7;\n  return -1;\n}\n"
        ],
        "134648785": [
            "sub_80693D1",
            "0x80693d1",
            "char *__usercall sub_80693D1@<eax>(int a1@<eax>, char *a2@<edx>)\n{\n  const char *v4; // ebx\n  int v5; // esi\n\n  v4 = \"generic\";\n  v5 = 0;\n  while ( (unsigned __int16)word_80B8538[v5] != a1 )\n  {\n    v4 += strlen(v4) + 1;\n    if ( ++v5 == 19 )\n    {\n      sprintf(a2, \"[%d]\", a1);\n      return a2;\n    }\n  }\n  return (char *)v4;\n}\n"
        ],
        "134648853": [
            "sub_8069415",
            "0x8069415",
            "int __usercall sub_8069415@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v4; // ecx\n  int v5; // ebx\n  unsigned int v6; // eax\n  const char *v8; // [esp+0h] [ebp-3Ch]\n  const char *v9; // [esp+4h] [ebp-38h]\n  char s[49]; // [esp+Bh] [ebp-31h] BYREF\n\n  sprintf(s, \"/etc/iproute2/rt_%s\", a1);\n  v5 = sub_80B0511(v4, sub_80B3D37);\n  while ( sub_80B0560(\"# \\t\") )\n  {\n    v6 = sub_804ED6C(0, v8, 0, v5);\n    if ( v6 > 0x3FF )\n    {\n      sub_804D5F4(\"database %s is corrupted at line %d\", a1, *(_DWORD *)(v5 + 24));\n      return sub_80B0536();\n    }\n    *(_DWORD *)(a2 + 4 * v6) = sub_804DB46(v9);\n  }\n  return sub_80B0536();\n}\n"
        ],
        "134648992": [
            "sub_80694A0",
            "0x80694a0",
            "void sub_80694A0()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB66C )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB66C = (int)v0;\n    v0[2] = \"global\";\n    v0[257] = \"nowhere\";\n    v0[256] = \"host\";\n    v0[255] = 135036335;\n    v0[202] = \"site\";\n    sub_8069415(\"scopes\", (int)(v0 + 2));\n  }\n}\n"
        ],
        "134649077": [
            "sub_80694F5",
            "0x80694f5",
            "void sub_80694F5()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB668 )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB668 = (int)v0;\n    v0[2] = \"unknown\";\n    sub_8069415(\"realms\", (int)(v0 + 2));\n  }\n}\n"
        ],
        "134649122": [
            "sub_8069522",
            "0x8069522",
            "void sub_8069522()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB664 )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB664 = (int)v0;\n    v0[2] = 135052877;\n    sub_8069415(\"dsfield\", (int)(v0 + 2));\n  }\n}\n"
        ],
        "134649167": [
            "sub_806954F",
            "0x806954f",
            "void sub_806954F()\n{\n  _DWORD *v0; // eax\n\n  if ( !dword_80DB660 )\n  {\n    v0 = sub_804DB2E(0x1008u);\n    dword_80DB660 = (int)v0;\n    v0[2] = \"unspec\";\n    v0[257] = \"local\";\n    v0[256] = \"main\";\n    v0[255] = \"default\";\n    sub_8069415(\"tables\", (int)(v0 + 2));\n  }\n}\n"
        ],
        "134649242": [
            "sub_806959A",
            "0x806959a",
            "int __usercall sub_806959A@<eax>(char *s2@<ecx>, int a2@<eax>, unsigned int *a3@<edx>, int base)\n{\n  const char *v7; // eax\n  int result; // eax\n  unsigned int i; // ebx\n  const char *v10; // edx\n  unsigned int v11; // edx\n  int v12; // [esp+0h] [ebp-14h]\n\n  v7 = *(const char **)a2;\n  if ( !v7 || (result = strcmp(v7, s2)) != 0 )\n  {\n    for ( i = 0; i != 1024; ++i )\n    {\n      v10 = *(const char **)(a2 + 4 * i + 8);\n      if ( v10 )\n      {\n        v12 = *(_DWORD *)(a2 + 4 * i + 8);\n        result = strcmp(v10, s2);\n        if ( !result )\n        {\n          *(_DWORD *)a2 = v12;\n          *(_DWORD *)(a2 + 4) = i;\n          *a3 = i;\n          return result;\n        }\n      }\n    }\n    v11 = sub_804ED6C(base, s2, 0, 1024);\n    result = -1;\n    if ( v11 <= 0x3FF )\n    {\n      *a3 = v11;\n      return 0;\n    }\n  }\n  else\n  {\n    *a3 = *(_DWORD *)(a2 + 4);\n  }\n  return result;\n}\n"
        ],
        "134649363": [
            "sub_8069613",
            "0x8069613",
            "int __usercall sub_8069613@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  int v4; // edx\n\n  if ( !dword_80DB670 )\n  {\n    dword_80DB670 = (int)sub_804DB2E(0x1008u);\n    v4 = dword_80DB670 + 8;\n    qmemcpy((void *)(dword_80DB670 + 8), off_80B5BA0, 0x34u);\n    sub_8069415(\"protos\", v4);\n  }\n  return sub_806959A(a2, dword_80DB670, a1, 0);\n}\n"
        ],
        "134649444": [
            "sub_8069664",
            "0x8069664",
            "_BYTE *__usercall sub_8069664@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_80694A0();\n    result = *(_BYTE **)(dword_80DB66C + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
        ],
        "134649482": [
            "sub_806968A",
            "0x806968a",
            "int __usercall sub_806968A@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_80694A0();\n  return sub_806959A(a2, dword_80DB66C, a1, 0);\n}\n"
        ],
        "134649513": [
            "sub_80696A9",
            "0x80696a9",
            "int __usercall sub_80696A9@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_80694F5();\n  return sub_806959A(a2, dword_80DB668, a1, 0);\n}\n"
        ],
        "134649544": [
            "sub_80696C8",
            "0x80696c8",
            "_BYTE *__usercall sub_80696C8@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_80694F5();\n    result = *(_BYTE **)(dword_80DB668 + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
        ],
        "134649582": [
            "sub_80696EE",
            "0x80696ee",
            "_BYTE *__usercall sub_80696EE@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_8069522();\n    result = *(_BYTE **)(dword_80DB664 + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
        ],
        "134649620": [
            "sub_8069714",
            "0x8069714",
            "int __usercall sub_8069714@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_8069522();\n  return sub_806959A(a2, dword_80DB664, a1, 16);\n}\n"
        ],
        "134649651": [
            "sub_8069733",
            "0x8069733",
            "_BYTE *__usercall sub_8069733@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // ebx\n  _BYTE *result; // eax\n\n  if ( a1 <= 0x3FF )\n  {\n    v1 = a1;\n    sub_806954F();\n    result = *(_BYTE **)(dword_80DB660 + 4 * v1 + 8);\n    if ( result )\n      return result;\n    a1 = v1;\n  }\n  return sub_804D70F(a1);\n}\n"
        ],
        "134649689": [
            "sub_8069759",
            "0x8069759",
            "int __usercall sub_8069759@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  sub_806954F();\n  return sub_806959A(a2, dword_80DB660, a1, 0);\n}\n"
        ],
        "134649720": [
            "sub_8069778",
            "0x8069778",
            "const char *__usercall sub_8069778@<eax>(signed int a1@<eax>)\n{\n  const char *result; // eax\n\n  switch ( a1 )\n  {\n    case 0:\n      result = \"none\";\n      break;\n    case 1:\n      result = \"unicast\";\n      break;\n    case 2:\n      result = \"local\";\n      break;\n    case 3:\n      result = \"broadcast\";\n      break;\n    case 4:\n      result = \"anycast\";\n      break;\n    case 5:\n      result = \"multicast\";\n      break;\n    case 6:\n      result = \"blackhole\";\n      break;\n    case 7:\n      result = \"unreachable\";\n      break;\n    case 8:\n      result = \"prohibit\";\n      break;\n    case 9:\n      result = \"throw\";\n      break;\n    case 10:\n      result = \"nat\";\n      break;\n    case 11:\n      result = \"xresolve\";\n      break;\n    default:\n      result = sub_804D70F(a1);\n      break;\n  }\n  return result;\n}\n"
        ],
        "134649809": [
            "sub_80697D1",
            "0x80697d1",
            "int __usercall sub_80697D1@<eax>(unsigned int *a1@<eax>, const char *a2@<edx>, char *a3@<ecx>)\n{\n  char v5; // al\n  unsigned int v6; // edx\n  int result; // eax\n  char *endptr; // [esp+0h] [ebp-Ch] BYREF\n\n  endptr = a3;\n  v5 = sub_804D254(\"local\", a2);\n  if ( !v5 )\n  {\n    v6 = 2;\nLABEL_27:\n    *a1 = v6;\n    return 0;\n  }\n  if ( v5 == 1 )\n  {\n    v6 = 10;\n    goto LABEL_27;\n  }\n  if ( (unsigned __int8)(v5 - 2) <= 1u )\n  {\n    v6 = 3;\n    goto LABEL_27;\n  }\n  switch ( v5 )\n  {\n    case 4:\n      v6 = 4;\n      goto LABEL_27;\n    case 5:\n      v6 = 5;\n      goto LABEL_27;\n    case 6:\n      v6 = 8;\n      goto LABEL_27;\n    case 7:\n      v6 = 7;\n      goto LABEL_27;\n    case 8:\n      v6 = 6;\n      goto LABEL_27;\n    case 9:\n      v6 = 11;\n      goto LABEL_27;\n    case 10:\n      v6 = 1;\n      goto LABEL_27;\n    case 11:\n      v6 = 9;\n      goto LABEL_27;\n  }\n  v6 = strtoul(a2, &endptr, 0);\n  result = -1;\n  if ( endptr == a2 )\n    return result;\n  if ( !*endptr && v6 <= 0xFF )\n    goto LABEL_27;\n  return -1;\n}\n"
        ],
        "134650018": [
            "sub_80698A2",
            "0x80698a2",
            "int __usercall sub_80698A2@<eax>(unsigned int *a1@<eax>, char *a2@<edx>)\n{\n  char *v3; // eax\n  char *v4; // edx\n  char *v5; // esi\n  unsigned int v8[3]; // [esp+4h] [ebp-Ch] BYREF\n\n  v8[0] = 0;\n  v3 = strchr(a2, 47);\n  *a1 = 0;\n  v4 = a2;\n  if ( v3 )\n  {\n    v5 = v3;\n    *v3 = 0;\n    if ( sub_80696A9(a1, a2) )\n    {\n      *v5 = 47;\n      return -1;\n    }\n    *a1 <<= 16;\n    *v5 = 47;\n    v4 = v5 + 1;\n  }\n  if ( !*v4 || !sub_80696A9(v8, v4) )\n  {\n    *a1 |= v8[0];\n    return 0;\n  }\n  return -1;\n}\n"
        ],
        "134650127": [
            "sub_806990F",
            "0x806990f",
            "int sub_806990F()\n{\n  int result; // eax\n  FILE *v1; // ebx\n  int v2; // [esp+0h] [ebp-Ch] BYREF\n  int v3; // [esp+4h] [ebp-8h] BYREF\n\n  result = dword_80DB674;\n  if ( !dword_80DB674 )\n  {\n    v1 = (FILE *)sub_80B3D37();\n    if ( v1 )\n    {\n      if ( fscanf(v1, \"%*08x%*08x%08x%08x\", &v2, &v3) == 2 && v2 == 1000000 )\n        dword_80DB674 = v3;\n      fclose(v1);\n    }\n    if ( !dword_80DB674 )\n      dword_80DB674 = sub_80B2F58();\n    return dword_80DB674;\n  }\n  return result;\n}\n"
        ],
        "134650240": [
            "sub_8069980",
            "0x8069980",
            "unsigned int __usercall sub_8069980@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  unsigned int result; // eax\n  const char *v7; // esi\n  unsigned int v8; // edx\n  char v9; // di\n  int v10; // [esp+0h] [ebp-14h]\n\n  memset(a1, 0, 0x14u);\n  if ( !strcmp(a2, \"default\") || !strcmp(a2, \"all\") || !strcmp(a2, \"any\") )\n  {\n    *a1 = a3;\n    a1[1] = a3 == 10 ? 16 : 4;\nLABEL_11:\n    *((_WORD *)a1 + 1) = -1;\n    return 0;\n  }\n  if ( strchr(a2, 58) )\n  {\n    *a1 = 10;\n    if ( (a3 == 10 || !a3) && inet_pton(10, a2, a1 + 4) > 0 )\n    {\n      a1[1] = 16;\n      goto LABEL_11;\n    }\n    return -1;\n  }\n  result = a3 & 0xFFFFFFFD;\n  if ( (a3 & 0xFFFFFFFD) != 0 )\n    return -1;\n  *a1 = 2;\n  v7 = a2 - 1;\n  v8 = 0;\n  v10 = 0;\n  while ( 1 )\n  {\n    v9 = *++v7;\n    if ( !*v7 )\n      break;\n    if ( (unsigned __int8)(v9 - 48) > 9u )\n    {\n      if ( v9 != 46 )\n        return -1;\n      if ( (unsigned int)++v10 > 3 )\n        return -1;\n      v8 = 0;\n    }\n    else\n    {\n      v8 = (unsigned __int8)(v9 - 48) + 10 * v8;\n      if ( v8 > 0xFF )\n        return -1;\n      a1[v10 + 4] = v8;\n    }\n  }\n  a1[1] = 4;\n  *((_WORD *)a1 + 1) = -1;\n  return result;\n}\n"
        ],
        "134650503": [
            "sub_8069A87",
            "0x8069a87",
            "int __usercall sub_8069A87@<eax>(_BYTE *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  if ( a3 == 17 )\n    sub_804D5E0(\"\\\"%s\\\" may be inet %s, but it is not allowed in this context\", a2, \"address\");\n  if ( sub_8069980(a1, a2, a3) )\n    sub_804D5E0(\"an %s %s is expected rather than \\\"%s\\\"\", \"inet\", \"address\", a2);\n  return 0;\n}\n"
        ],
        "134650561": [
            "sub_8069AC1",
            "0x8069ac1",
            "char __usercall sub_8069AC1@<al>(_WORD *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  unsigned int v5; // eax\n  char *v6; // eax\n  char *v7; // edi\n  unsigned int v8; // ebp\n  unsigned __int32 v9; // eax\n  char v12[4]; // [esp+8h] [ebp-24h] BYREF\n  unsigned int v13; // [esp+Ch] [ebp-20h]\n\n  if ( a3 == 17 )\n    sub_804D5E0(\"\\\"%s\\\" may be inet %s, but it is not allowed in this context\", a2, \"prefix\");\n  memset(a1, 0, 0x14u);\n  if ( !strcmp(a2, \"default\") || !strcmp(a2, \"all\") || !strcmp(a2, \"any\") )\n  {\n    LOBYTE(v5) = a3;\n    *(_BYTE *)a1 = a3;\n    return v5;\n  }\n  v6 = strchr(a2, 47);\n  v7 = v6;\n  if ( v6 )\n    *v6 = 0;\n  v5 = sub_8069980(a1, a2, a3);\n  if ( v5 )\n  {\n    if ( !v7 )\n      return v5;\nLABEL_26:\n    *v7 = 47;\n    return v5;\n  }\n  LOWORD(v5) = 128;\n  if ( *(_BYTE *)a1 != 10 )\n    LOWORD(v5) = 32;\n  a1[1] = v5;\n  if ( v7 )\n  {\n    v12[0] = 0;\n    v8 = sub_804ED6C(0, v7 + 1, 0, (int)a1);\n    if ( *(_DWORD *)dword_80DBB7C || (v5 = (__int16)a1[1], v8 > v5) )\n    {\n      v5 = sub_8069980(v12, v7 + 1, a3);\n      if ( v5 )\n        goto LABEL_24;\n    }\n    if ( v12[0] == 2 )\n    {\n      v9 = _byteswap_ulong(v13);\n      v8 = 0;\n      if ( (-v9 & ~v9) != 0 )\n        goto LABEL_24;\n      while ( v9 )\n      {\n        ++v8;\n        v9 *= 2;\n      }\n      v5 = (__int16)a1[1];\n      if ( v8 > v5 )\nLABEL_24:\n        sub_804D5E0(\"an %s %s is expected rather than \\\"%s\\\"\", \"inet\", \"prefix\", a2);\n    }\n    a1[1] = v8;\n    goto LABEL_26;\n  }\n  return v5;\n}\n"
        ],
        "134650884": [
            "sub_8069C04",
            "0x8069c04",
            "int __usercall sub_8069C04@<eax>(const char *a1@<eax>)\n{\n  char v3[4]; // [esp+0h] [ebp-18h] BYREF\n  int v4; // [esp+4h] [ebp-14h]\n\n  if ( sub_8069980(v3, a1, 2) )\n    sub_804D5E0(\"an %s %s is expected rather than \\\"%s\\\"\", \"IP\", \"address\", a1);\n  return v4;\n}\n"
        ],
        "134650938": [
            "sub_8069C3A",
            "0x8069c3a",
            "int __usercall sub_8069C3A@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = a1 + 4;\n  if ( !*(_DWORD *)(a1 + 4) )\n    sub_804D5E0(\"command line is not complete, try \\\"help\\\"\");\n  return result;\n}\n"
        ],
        "134650960": [
            "sub_8069C50",
            "0x8069c50",
            "void __usercall __noreturn sub_8069C50(const char *a1@<eax>, const char *a2@<edx>)\n{\n  sub_804D5E0(\"invalid argument '%s' to '%s'\", a1, a2);\n}\n"
        ],
        "134650972": [
            "sub_8069C5C",
            "0x8069c5c",
            "unsigned int __usercall sub_8069C5C@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  unsigned int result; // eax\n  const char *v4; // [esp+0h] [ebp-Ch]\n  char *endptr; // [esp+4h] [ebp-8h] BYREF\n\n  if ( !*a1 || (v4 = a2, result = strtoul(a1, &endptr, 0), a2 = v4, *endptr) )\n    sub_8069C50(a1, a2);\n  return result;\n}\n"
        ],
        "134651026": [
            "sub_8069C92",
            "0x8069c92",
            "// attributes: thunk\nunsigned int __usercall sub_8069C92@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  return sub_8069C5C(a1, a2);\n}\n"
        ],
        "134651031": [
            "sub_8069C97",
            "0x8069c97",
            "unsigned int __usercall sub_8069C97@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  unsigned int result; // eax\n  const char *v4; // [esp+0h] [ebp-Ch]\n  char *endptr; // [esp+4h] [ebp-8h] BYREF\n\n  if ( !*a1 || (v4 = a2, result = strtoul(a1, &endptr, 0), a2 = v4, *endptr) || result > 0xFFFF )\n    sub_8069C50(a1, a2);\n  return result;\n}\n"
        ],
        "134651092": [
            "sub_8069CD4",
            "0x8069cd4",
            "void __usercall __noreturn sub_8069CD4(const char *a1@<eax>, const char *a2@<edx>)\n{\n  sub_804D5E0(\"duplicate \\\"%s\\\": \\\"%s\\\" is the second value\", a1, a2);\n}\n"
        ],
        "134651104": [
            "sub_8069CE0",
            "0x8069ce0",
            "void __usercall __noreturn sub_8069CE0(const char *a1@<eax>, const char *a2@<edx>)\n{\n  sub_804D5E0(\"either \\\"%s\\\" is duplicate, or \\\"%s\\\" is garbage\", a1, a2);\n}\n"
        ],
        "134651116": [
            "sub_8069CEC",
            "0x8069cec",
            "int __usercall sub_8069CEC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  const void *v3; // ebp\n  const void *v4; // edi\n  int v5; // esi\n  int v6; // ebx\n\n  v3 = (const void *)(a1 + 4);\n  v4 = (const void *)(a2 + 4);\n  v5 = a3 & 0x1F;\n  v6 = a3 >> 5;\n  if ( a3 >> 5 && memcmp(v3, v4, 4 * v6) )\n    return -1;\n  if ( v5 )\n    return (_byteswap_ulong(-1 << (32 - v5)) & (*((_DWORD *)v4 + v6) ^ *((_DWORD *)v3 + v6))) != 0;\n  return v5;\n}\n"
        ],
        "134651207": [
            "sub_8069D47",
            "0x8069d47",
            "const char *__usercall sub_8069D47@<eax>(int a1@<eax>, const void *a2@<edx>)\n{\n  int v4; // edx\n  int v5; // ecx\n  char *v6; // eax\n\n  if ( a1 != 2 && a1 != 10 )\n    return \"???\";\n  sub_804DB2E(0x2Eu);\n  v6 = (char *)sub_80A9707(v5, v4);\n  return inet_ntop(a1, a2, v6, 0x2Eu);\n}\n"
        ],
        "134651260": [
            "sub_8069D7C",
            "0x8069d7c",
            "_BYTE *__usercall sub_8069D7C@<eax>(char a1@<al>, const void *a2@<edx>, int a3@<ecx>)\n{\n  unsigned int v6; // ebx\n  _BYTE *result; // eax\n\n  v6 = strnlen(a2);\n  result = sub_804DB2E(v6 + a3 + 2);\n  *result = a1;\n  result[1] = v6 + a3;\n  qmemcpy(&result[a3 + 2], a2, v6);\n  return result;\n}\n"
        ],
        "134651319": [
            "sub_8069DB7",
            "0x8069db7",
            "__int16 __usercall sub_8069DB7@<ax>(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>)\n{\n  __int16 v4; // ax\n  __int16 v5; // ax\n  char v6; // t0\n  __int16 result; // ax\n\n  sub_806B251(a3, a2);\n  *(_DWORD *)(a1 + 4) = rand();\n  v4 = sub_804EC4A();\n  word_80DB9C6 = v4;\n  if ( !word_80DB9C4 )\n    word_80DB9C4 = v4;\n  v5 = v4 - word_80DB9C4;\n  v6 = HIBYTE(v5);\n  HIBYTE(v5) = v5;\n  LOBYTE(v5) = v6;\n  *(_WORD *)(a1 + 8) = v5;\n  *(_DWORD *)(a1 + 28) = dword_80DB978;\n  result = word_80DB97C;\n  *(_WORD *)(a1 + 32) = word_80DB97C;\n  if ( dword_80DB9B4 )\n    return sub_806BA8F();\n  return result;\n}\n"
        ],
        "134651416": [
            "sub_8069E18",
            "0x8069e18",
            "int __usercall sub_8069E18@<eax>(int a1@<eax>)\n{\n  int result; // eax\n  int v3; // edx\n  int i; // ecx\n  int v5; // edi\n  int j; // esi\n\n  sub_806BADE(16386, 57);\n  result = sub_806BA72();\n  v3 = 0;\n  for ( i = 1; i != 255; ++i )\n  {\n    v5 = (unsigned __int8)byte_80DB984[i >> 3];\n    if ( _bittest(&v5, i & 7) )\n      *(_BYTE *)(result + a1 + v3++ + 242) = i;\n  }\n  if ( v3 )\n  {\n    *(_BYTE *)(a1 + result + 240) = 55;\n    *(_BYTE *)(a1 + result + 241) = v3;\n    *(_BYTE *)(result + a1 + v3 + 242) = -1;\n  }\n  if ( dword_80DB9B8 )\n    result = sub_806BA8F();\n  if ( dword_80DB9BC )\n    result = sub_806BA8F();\n  if ( dword_80DB9C0 )\n    result = sub_806BA8F();\n  if ( (dword_80DBB9C & 0x100000) != 0 && !*(_DWORD *)(a1 + 12) )\n    *(_WORD *)(a1 + 10) |= 0x80u;\n  for ( j = dword_80DB9B0; j; j = *(_DWORD *)(j + 4) )\n    result = sub_806BA8F();\n  return result;\n}\n"
        ],
        "134651625": [
            "sub_8069EE9",
            "0x8069ee9",
            "int sub_8069EE9()\n{\n  return sub_806B2E9(-1, 67, &unk_80B855E, dword_80DB980);\n}\n"
        ],
        "134651651": [
            "sub_8069F03",
            "0x8069f03",
            "int __usercall sub_8069F03@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char v6[4]; // [esp+0h] [ebp-27Ch] BYREF\n  int v7; // [esp+4h] [ebp-278h]\n\n  sub_8069DB7((int)v6, 1u, a3);\n  v7 = a1;\n  if ( a2 )\n    sub_806BADE(a2, 50);\n  sub_8069E18((int)v6);\n  sub_804D5F4(\"sending %s\", \"discover\");\n  return sub_8069EE9();\n}\n"
        ],
        "134651739": [
            "sub_8069F5B",
            "0x8069f5b",
            "int __usercall sub_8069F5B@<eax>(struct in_addr in@<ecx>, int a2@<eax>, int a3@<edx>)\n{\n  char *v6; // eax\n  char v8[4]; // [esp+0h] [ebp-280h] BYREF\n  int v9; // [esp+4h] [ebp-27Ch]\n\n  sub_8069DB7((int)v8, 3u, in.s_addr);\n  v9 = a2;\n  sub_806BADE(in.s_addr, 50);\n  sub_806BADE(a3, 54);\n  sub_8069E18((int)v8);\n  v6 = inet_ntoa(in);\n  sub_804D5F4(\"sending select for %s\", v6);\n  return sub_8069EE9();\n}\n"
        ],
        "134651843": [
            "sub_8069FC3",
            "0x8069fc3",
            "int __usercall sub_8069FC3@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char v6[636]; // [esp+0h] [ebp-27Ch] BYREF\n\n  sub_8069DB7((int)v6, 4u, a3);\n  sub_806BADE(a2, 50);\n  sub_806BADE(a1, 54);\n  sub_804D5F4(\"sending %s\", \"decline\");\n  return sub_8069EE9();\n}\n"
        ],
        "134651930": [
            "sub_806A01A",
            "0x806a01a",
            "int __usercall sub_806A01A@<eax>(int a1@<eax>, struct in_addr a2@<edx>, int a3@<ecx>)\n{\n  char *v6; // eax\n  char v8[4]; // [esp+0h] [ebp-280h] BYREF\n  int v9; // [esp+4h] [ebp-27Ch]\n  int v10; // [esp+Ch] [ebp-274h]\n\n  sub_8069DB7((int)v8, 3u, a3);\n  v9 = a1;\n  v10 = a3;\n  sub_8069E18((int)v8);\n  v6 = inet_ntoa(a2);\n  sub_804D5F4(\"sending renew to %s\", v6);\n  if ( a2.s_addr )\n    return sub_806B47D(68, a3, a2.s_addr, 67);\n  else\n    return sub_8069EE9();\n}\n"
        ],
        "134652036": [
            "sub_806A084",
            "0x806a084",
            "ssize_t __usercall sub_806A084@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  ssize_t result; // eax\n  unsigned __int16 v4; // dx\n  int v5; // esi\n  __int16 v6; // ax\n  __int16 v7; // bp\n  __int16 v8; // bp\n  struct cmsghdr *i; // eax\n  int v11[2]; // [esp+4h] [ebp-2E4h] BYREF\n  struct msghdr message; // [esp+Ch] [ebp-2DCh] BYREF\n  char v13; // [esp+28h] [ebp-2C0h] BYREF\n  _BYTE v14[9]; // [esp+48h] [ebp-2A0h] BYREF\n  char v15; // [esp+51h] [ebp-297h]\n  __int16 v16; // [esp+52h] [ebp-296h]\n  __int16 v17; // [esp+5Eh] [ebp-28Ah]\n  __int16 v18; // [esp+60h] [ebp-288h]\n  __int16 v19; // [esp+62h] [ebp-286h]\n  char v20[236]; // [esp+64h] [ebp-284h] BYREF\n  int v21; // [esp+150h] [ebp-198h]\n\n  v11[0] = (int)v14;\n  v11[1] = 656;\n  memset(&message, 0, sizeof(message));\n  message.msg_iov = (struct iovec *)v11;\n  message.msg_iovlen = 1;\n  message.msg_control = &v13;\n  message.msg_controllen = 32;\n  while ( 1 )\n  {\n    result = recvmsg(a2, &message, 0);\n    if ( result >= 0 )\n      break;\n    if ( *(_DWORD *)dword_80DBB7C != 4 )\n      return result;\n  }\n  if ( result <= 27 )\n    return -2;\n  LOBYTE(v4) = v14[3];\n  HIBYTE(v4) = v14[2];\n  v5 = v4;\n  if ( v4 > result )\n    return -2;\n  if ( v15 != 17 )\n    return -2;\n  if ( v14[0] != 69 )\n    return -2;\n  if ( v17 != 17408 )\n    return -2;\n  LOBYTE(v6) = HIBYTE(v18);\n  HIBYTE(v6) = v18;\n  if ( v4 - 20 != v6 )\n    return -2;\n  v7 = v16;\n  v16 = 0;\n  if ( (unsigned __int16)sub_80AD4D4() != v7 )\n    return -2;\n  if ( message.msg_controllen > 0xB )\n  {\n    for ( i = (struct cmsghdr *)message.msg_control; i; i = __cmsg_nxthdr(&message, i) )\n    {\n      if ( i->cmsg_level == 263 && i->cmsg_type == 8 && (i[1].cmsg_len & 8) != 0 )\n        goto LABEL_21;\n    }\n  }\n  memset(v14, 0, sizeof(v14));\n  v8 = v19;\n  *(_WORD *)&v14[2] = v18;\n  v19 = 0;\n  if ( v8 )\n  {\n    if ( (unsigned __int16)sub_80AD4D4() != v8 )\n      return -2;\n  }\nLABEL_21:\n  if ( v21 != 1666417251 )\n  {\n    sub_804D5F4(\"packet with bad magic, ignoring\");\n    return -2;\n  }\n  result = v5 - 28;\n  qmemcpy(a1, v20, v5 - 28);\n  return result;\n}\n"
        ],
        "134652421": [
            "sub_806A205",
            "0x806a205",
            "int sub_806A205()\n{\n  sub_80B3C0D();\n  byte_80DB561 &= ~1u;\n  return sub_80B0A2C();\n}\n"
        ],
        "134652445": [
            "sub_806A21D",
            "0x806a21d",
            "int __usercall sub_806A21D@<eax>(char *a1@<eax>, const char *a2@<edx>, unsigned __int8 *a3@<ecx>)\n{\n  return sprintf(a1, \"%s%u.%u.%u.%u\", a2, *a3, a3[1], a3[2], a3[3]);\n}\n"
        ],
        "134652482": [
            "sub_806A242",
            "0x806a242",
            "int __usercall sub_806A242@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int result; // eax\n  int v4; // esi\n  int v5; // ebx\n  int v6; // [esp-4h] [ebp-24h]\n  struct sockaddr v7[2]; // [esp+0h] [ebp-20h] BYREF\n\n  byte_80DB766 = a1;\n  result = fd;\n  if ( fd >= 0 )\n  {\n    close(fd);\n    fd = -1;\n    result = v6;\n  }\n  if ( a1 == 1 )\n  {\n    result = sub_806B745(a2, *(_DWORD *)dword_80DB9A4);\n    fd = result;\n  }\n  else if ( a1 )\n  {\n    v4 = dword_80DB980;\n    v5 = sub_804DF99(8, 2, 17);\n    memset(&v7[0].sa_data[6], 0, 0xCu);\n    *(_DWORD *)&v7[0].sa_family = 524305;\n    *(_DWORD *)&v7[0].sa_data[2] = v4;\n    sub_804DFB3(0x14u, v7, v5);\n    result = sub_80B4242();\n    fd = v5;\n  }\n  return result;\n}\n"
        ],
        "134652651": [
            "sub_806A2EB",
            "0x806a2eb",
            "char *__usercall sub_806A2EB@<eax>(char *s@<ecx>, unsigned __int8 *a2@<eax>, char a3@<dl>)\n{\n  unsigned __int8 *v3; // esi\n  signed int v5; // ebp\n  int v6; // ecx\n  signed int v7; // edi\n  size_t v8; // eax\n  char *v9; // ebx\n  int v10; // eax\n  int v11; // eax\n  char *v12; // eax\n  char *k; // edx\n  char v14; // al\n  unsigned int v15; // edi\n  int v16; // ebp\n  unsigned int v17; // eax\n  int j; // ecx\n  unsigned __int8 *v19; // esi\n  int v20; // ebp\n  char *v21; // ebx\n  char *v22; // ebx\n  int v23; // eax\n  int v24; // edx\n  char *v25; // ebx\n  char *v26; // ebx\n  char *v27; // ebx\n  int v28; // ebp\n  int v29; // esi\n  char v31; // [esp+0h] [ebp-28h]\n  const char *i; // [esp+0h] [ebp-28h]\n  char *sb; // [esp+4h] [ebp-24h]\n  char *sa; // [esp+4h] [ebp-24h]\n  const char *v35; // [esp+8h] [ebp-20h]\n  int v36[5]; // [esp+14h] [ebp-14h] BYREF\n\n  v3 = a2;\n  v5 = *(a2 - 1);\n  v31 = a3 & 0xF;\n  v6 = a3 & 0xF;\n  v7 = (unsigned __int8)byte_80CFCF3[v6];\n  sb = (char *)((v5 + v7) / (unsigned int)v7 * (unsigned __int8)byte_80CFAA6[v6]);\n  v8 = strlen(s);\n  sa = (char *)sub_804DAFA((size_t)&sb[v8 + 2]);\n  v9 = &sa[sprintf(sa, \"%s=\", s)];\n  v35 = \"wakeup dt=%ld\" + 10;\n  if ( v31 == 7 )\n    v35 = \"%lu\";\n  while ( 2 )\n  {\n    if ( v7 <= v5 )\n    {\n      switch ( v31 )\n      {\n        case 1:\n        case 2:\n          v9 += sub_806A21D(v9, &data, v3);\n          if ( v31 != 1 )\n            v9 += sub_806A21D(v9, \"/\", v3 + 4);\n          goto LABEL_37;\n        case 3:\n        case 4:\n          qmemcpy(v9, v3, v5);\n          v9[v5] = 0;\n          if ( v31 != 4 )\n            return sa;\n          v12 = v9;\n          break;\n        case 5:\n          v10 = *v3;\n          goto LABEL_9;\n        case 6:\n          BYTE1(v10) = *(_WORD *)v3;\n          LOBYTE(v10) = HIBYTE(*(_WORD *)v3);\n          v10 = (unsigned __int16)v10;\nLABEL_9:\n          v11 = sprintf(v9, \"%u\", v10);\n          goto LABEL_10;\n        case 7:\n        case 8:\n          v11 = sprintf(v9, v35, _byteswap_ulong(*(_DWORD *)v3));\nLABEL_10:\n          v9 += v11;\n          goto LABEL_37;\n        case 10:\n          for ( i = &data; v5 > 4; i = \"     \" + 4 )\n          {\n            v15 = *v3;\n            if ( v15 > 0x20 )\n              break;\n            v16 = v5 - 1;\n            v36[0] = 0;\n            v17 = (v15 + 7) >> 3;\n            for ( j = 0; v17 != j; ++j )\n              *((_BYTE *)v36 + j) = v3[j + 1];\n            v19 = &v3[v17 + 1];\n            v20 = v16 - v17;\n            if ( v20 <= 3 )\n              break;\n            v21 = &v9[sub_806A21D(v9, i, (unsigned __int8 *)v36)];\n            v22 = &v21[sprintf(v21, \"/%u \", v15)];\n            v9 = &v22[sub_806A21D(v22, &data, v19)];\n            v3 = v19 + 4;\n            v5 = v20 - 4;\n          }\n          return sa;\n        case 11:\n          if ( v5 > 21 )\n          {\n            v23 = *v3;\n            if ( (unsigned __int8)v23 <= 0x20u )\n            {\n              v24 = v3[1] + 32 - v23;\n              if ( (v24 - 128 < 0) ^ __OFADD__(-128, v24) | (v24 == 128) )\n              {\n                v25 = &v9[sprintf(v9, \"%u \", *v3)];\n                v26 = &v25[sprintf(v25, \"%u \", v3[1])];\n                v27 = &v26[sub_806BEF4()];\n                v28 = v5 - 22;\n                v29 = (int)&v3[v28 + 18];\n                do\n                {\n                  v27 += sub_806A21D(v27, \" \", (unsigned __int8 *)(v29 - v28));\n                  v28 -= 4;\n                }\n                while ( v28 >= 0 );\n              }\n            }\n          }\n          return sa;\n        default:\nLABEL_37:\n          v3 += v7;\n          v5 -= v7;\n          if ( v7 > v5 )\n            return sa;\n          *(_WORD *)v9++ = 32;\n          continue;\n      }\n      while ( 1 )\n      {\n        for ( k = v12; ; ++k )\n        {\n          v14 = *k;\n          if ( (unsigned __int8)((*k | 0x20) - 97) <= 0x19u || (unsigned __int8)(v14 - 48) <= 9u )\n            continue;\n          if ( !v14 || v14 == 46 )\n            break;\n          if ( v14 != 45 && v14 != 95 )\n          {\n            sub_80B2C4E(v5);\n            return sa;\n          }\n        }\n        if ( v14 )\n        {\n          v12 = k + 1;\n          if ( k[1] )\n            continue;\n        }\n        return sa;\n      }\n    }\n    return sa;\n  }\n}\n"
        ],
        "134653311": [
            "sub_806A57F",
            "0x806a57f",
            "void __usercall sub_806A57F(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebx\n  char v4; // di\n  unsigned int i; // ebp\n  _BYTE *v6; // eax\n  char *v7; // eax\n  char *v8; // ebp\n  char **v9; // ebx\n  char *v10; // ebp\n  char *v11; // eax\n  char *v12; // eax\n  char *v13; // edi\n  char *v14; // ebp\n  int v15; // edx\n  int v16; // eax\n  int v17; // ecx\n  char *v18; // eax\n  unsigned __int32 v19; // eax\n  int v20; // edx\n  char *v21; // eax\n  signed int v22; // edi\n  int v23; // eax\n  char *v24; // ebp\n  int v25; // eax\n  char **j; // ebx\n  _DWORD *ptr; // [esp+0h] [ebp-44h]\n  char **ptra; // [esp+0h] [ebp-44h]\n  int v29; // [esp+4h] [ebp-40h]\n  unsigned __int8 *v30; // [esp+8h] [ebp-3Ch]\n  _DWORD *v31; // [esp+Ch] [ebp-38h]\n  int v33[12]; // [esp+14h] [ebp-30h] BYREF\n\n  memset(v33, 0, 0x20u);\n  if ( a1 )\n  {\n    v3 = 6;\n    v4 = 0;\n    for ( i = 1; i != 255; ++i )\n    {\n      v6 = (_BYTE *)sub_806B9D0();\n      if ( v6 )\n      {\n        if ( i == 52 )\n        {\n          v4 |= *v6;\n        }\n        else if ( i == 1 )\n        {\n          ++v3;\n        }\n        ++v3;\n        v33[i >> 5] |= 1 << i;\n      }\n    }\n  }\n  else\n  {\n    v4 = 0;\n    v3 = 6;\n  }\n  ptr = sub_804DB2E(4 * v3);\n  v7 = sub_804DDBF(\"interface=%s\", *(const char **)dword_80DB9A4);\n  *ptr = v7;\n  putenv(v7);\n  if ( a1 )\n  {\n    v8 = (char *)sub_804DAFA(0x13u);\n    ptr[1] = v8;\n    sub_806A21D(v8, \"ip=\", (unsigned __int8 *)(a1 + 16));\n    v9 = (char **)(ptr + 2);\n    putenv(v8);\n    if ( *(_DWORD *)(a1 + 20) )\n    {\n      v10 = (char *)sub_804DAFA(0x17u);\n      ptr[2] = v10;\n      sub_806A21D(v10, \"siaddr=\", (unsigned __int8 *)(a1 + 20));\n      v9 = (char **)(ptr + 3);\n      putenv(v10);\n    }\n    if ( (v4 & 1) == 0 && *(_BYTE *)(a1 + 108) )\n    {\n      v11 = sub_804DDBF(\"boot_file=%.128s\", (const char *)(a1 + 108));\n      *v9++ = v11;\n      putenv(v11);\n    }\n    if ( (v4 & 2) == 0 && *(_BYTE *)(a1 + 44) )\n    {\n      v12 = sub_804DDBF(\"sname=%.64s\", (const char *)(a1 + 44));\n      *v9++ = v12;\n      putenv(v12);\n    }\n    v13 = (char *)&unk_80B5BE0;\n    v14 = \"subnet\";\n    while ( *v14 )\n    {\n      LOBYTE(v29) = v13[1];\n      v15 = (unsigned __int8)v29 >> 5;\n      v16 = 1 << (v29 & 0x1F);\n      v17 = v33[v15];\n      if ( (v17 & v16) != 0 )\n      {\n        v33[v15] = v17 & ~v16;\n        v30 = (unsigned __int8 *)sub_806B9D0();\n        v18 = sub_806A2EB(v14, v30, *v13);\n        *v9 = v18;\n        v31 = v9 + 1;\n        putenv(v18);\n        if ( (_BYTE)v29 == 1 )\n        {\n          v19 = _byteswap_ulong(*(_DWORD *)v30);\n          v20 = 0;\n          while ( v19 )\n          {\n            ++v20;\n            v19 *= 2;\n          }\n          v21 = sub_804DDBF(\"mask=%u\", v20);\n          v9[1] = v21;\n          v9 += 2;\n          putenv(v21);\n        }\n        else\n        {\n          ++v9;\n        }\n      }\n      v14 += strlen(v14) + 1;\n      v13 += 2;\n    }\n    v22 = 0;\n    do\n    {\n      v23 = v33[(unsigned int)v22 >> 5];\n      if ( v23 )\n      {\n        if ( _bittest(&v23, v22) )\n        {\n          v30 = (unsigned __int8 *)sub_806B9D0();\n          v29 = *(v30 - 1);\n          v24 = (char *)sub_804DAFA(2 * v29 + 9);\n          *v9 = v24;\n          v25 = sprintf(v24, \"opt%u=\", v22);\n          *(_BYTE *)sub_804D727((int)&v24[v25], (int)v30, v29) = 0;\n          ++v9;\n          putenv(v24);\n        }\n        ++v22;\n      }\n      else\n      {\n        v22 += 32;\n      }\n    }\n    while ( v22 <= 255 );\n  }\n  v33[1] = a2;\n  v33[2] = 0;\n  sub_80B3C03(ptr, v29, v30, v31, a2, dword_80DB9AC);\n  for ( j = ptra; *j; ++j )\n    sub_804DE4D(*j);\n  free(ptra);\n}\n"
        ],
        "134654021": [
            "sub_806A845",
            "0x806a845",
            "int __usercall sub_806A845@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  char v6[12]; // [esp+0h] [ebp-27Ch] BYREF\n  int v7; // [esp+Ch] [ebp-270h]\n\n  sub_8069DB7((int)v6, 7u, a3);\n  v7 = a2;\n  sub_806BADE(a1, 54);\n  sub_804D5F4(\"sending %s\", \"release\");\n  if ( a1 )\n    return sub_806B47D(68, a2, a1, 67);\n  else\n    return sub_8069EE9();\n}\n"
        ],
        "134654123": [
            "sub_806A8AB",
            "0x806a8ab",
            "int __usercall sub_806A8AB@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  char *v4; // eax\n  char *v5; // eax\n  int v6; // ecx\n  int v7; // ecx\n  int result; // eax\n  char dest[28]; // [esp+0h] [ebp-1Ch] BYREF\n\n  if ( (unsigned __int8)(byte_80DB765 - 2) <= 3u )\n  {\n    v4 = inet_ntoa((struct in_addr)a1);\n    strcpy(dest, v4);\n    v5 = inet_ntoa((struct in_addr)a2);\n    sub_804D5F4(\"unicasting a release of %s to %s\", v5, dest);\n    sub_806A845(a1, a2, v6);\n  }\n  sub_804D5F4(\"entering released state\");\n  sub_806A57F(0, (int)\"deconfig\");\n  result = sub_806A242(0, v7);\n  byte_80DB765 = 6;\n  return result;\n}\n"
        ],
        "134654235": [
            "sub_806A91B",
            "0x806a91b",
            "int __cdecl sub_806A91B(int a1, int a2)\n{\n  unsigned int v2; // esi\n  const char *v3; // ebx\n  unsigned int v4; // eax\n  _BYTE *i; // edx\n  const char *v6; // eax\n  char *v7; // ebx\n  int v8; // ecx\n  unsigned int v9; // eax\n  int v10; // ecx\n  int v11; // edi\n  int v12; // ebp\n  unsigned int v13; // ebx\n  int v14; // ecx\n  int v15; // eax\n  int v16; // eax\n  int v17; // eax\n  ssize_t v18; // eax\n  int v19; // ecx\n  char *v20; // eax\n  int *v21; // eax\n  char v22; // al\n  unsigned int *v23; // eax\n  unsigned __int32 v24; // edi\n  int v25; // ecx\n  int v26; // ecx\n  unsigned int v27; // eax\n  char *v28; // eax\n  int v29; // ebx\n  const char *v30; // edx\n  int v31; // ecx\n  unsigned int v32; // edi\n  int v33; // ecx\n  _DWORD *v34; // eax\n  int v36; // [esp-8h] [ebp-2E4h]\n  int s_addr; // [esp+0h] [ebp-2DCh]\n  int v38; // [esp+4h] [ebp-2D8h]\n  int v39; // [esp+8h] [ebp-2D4h]\n  int v40; // [esp+Ch] [ebp-2D0h]\n  int v41; // [esp+10h] [ebp-2CCh]\n  int v42; // [esp+10h] [ebp-2CCh]\n  int v43; // [esp+14h] [ebp-2C8h]\n  int v44; // [esp+18h] [ebp-2C4h]\n  int v45; // [esp+1Ch] [ebp-2C0h]\n  const char *v46; // [esp+20h] [ebp-2BCh] BYREF\n  const void *v47; // [esp+24h] [ebp-2B8h] BYREF\n  const void *v48; // [esp+28h] [ebp-2B4h] BYREF\n  char *cp; // [esp+2Ch] [ebp-2B0h] BYREF\n  const char *v50; // [esp+30h] [ebp-2ACh] BYREF\n  int v51; // [esp+34h] [ebp-2A8h] BYREF\n  int v52; // [esp+38h] [ebp-2A4h] BYREF\n  int v53; // [esp+3Ch] [ebp-2A0h] BYREF\n  unsigned int seconds; // [esp+40h] [ebp-29Ch] BYREF\n  int v55; // [esp+44h] [ebp-298h] BYREF\n  struct pollfd fds; // [esp+48h] [ebp-294h] BYREF\n  __int16 v57; // [esp+56h] [ebp-286h]\n  char v58[4]; // [esp+58h] [ebp-284h] BYREF\n  int v59; // [esp+5Ch] [ebp-280h]\n  struct in_addr in; // [esp+68h] [ebp-274h]\n  char s1[616]; // [esp+74h] [ebp-268h] BYREF\n\n  v50 = \"2000\";\n  v51 = 0;\n  v52 = 0;\n  v53 = 20;\n  seconds = 3;\n  v55 = 3;\n  *(_DWORD *)dword_80DB9A4 = \"eth0\";\n  dword_80DB9AC = (int)&unk_80CF884;\n  v46 = \"udhcp 1.29.2\";\n  v2 = sub_80ABEC2(\n         a2,\n         \"^CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fBba::v\",\n         \"clientid-none\",\n         &v46,\n         &v47,\n         &v47,\n         &v48,\n         dword_80DB9A4,\n         &dword_80DB9A8,\n         &cp,\n         &dword_80DB9AC,\n         &seconds,\n         &v55,\n         &v53,\n         &v51,\n         &v52,\n         &v50);\n  if ( (v2 & 0xC) != 0 )\n  {\n    sub_804D5F4(\"option -h NAME is deprecated, use -x hostname:NAME\");\n    dword_80DB9BC = (int)sub_8069D7C(12, v47, 0);\n  }\n  if ( (v2 & 0x10) != 0 )\n  {\n    dword_80DB9C0 = (int)sub_8069D7C(81, v48, 3);\n    *(_BYTE *)(dword_80DB9C0 + 2) = 1;\n  }\n  s_addr = 0;\n  if ( (v2 & 0x400) != 0 )\n    s_addr = inet_addr(cp);\n  v45 = sub_80B40EC();\n  while ( v51 )\n  {\n    v3 = (const char *)sub_80AFB01(s_addr);\n    v4 = sub_804ED6C(0, v3, 0, (int)v3);\n    if ( *(_DWORD *)dword_80DBB7C || v4 > 0xFE )\n      v4 = (unsigned __int8)byte_80B5BE1[2 * sub_806B974()];\n    byte_80DB984[v4 >> 3] |= 1 << (v4 & 7);\n  }\n  if ( (v2 & 0x20000) == 0 )\n  {\n    for ( i = &unk_80B5BE0; i[1]; i += 2 )\n    {\n      if ( (*i & 0x10) != 0 )\n        byte_80DB984[(unsigned __int8)i[1] >> 3] |= 1 << (i[1] & 7);\n    }\n  }\n  while ( v52 )\n  {\n    v6 = (const char *)sub_80AFB01(s_addr);\n    v7 = sub_804DB46(v6);\n    sub_806BCAF(&unk_80B5BE0, &dword_80DB9B0, \"subnet\");\n    free(v7);\n  }\n  v43 = sub_806B66A(&dword_80DB978);\n  if ( v43 )\n    return 1;\n  if ( (v2 & 1) != 0 || sub_806BB3E(s_addr) )\n  {\n    v39 = 0;\n  }\n  else\n  {\n    dword_80DB9B4 = (int)sub_8069D7C(61, &data, 7);\n    *(_BYTE *)(dword_80DB9B4 + 2) = 1;\n    v8 = dword_80DB9B4 + 3;\n    v39 = dword_80DB9B4 + 3;\n    *(_DWORD *)(dword_80DB9B4 + 3) = dword_80DB978;\n    *(_WORD *)(v8 + 4) = word_80DB97C;\n  }\n  if ( *v46 )\n    dword_80DB9B8 = (int)sub_8069D7C(60, v46, 0);\n  if ( (v2 & 0x4000) != 0 )\n  {\n    openlog(ident, 1, 24);\n    byte_80DB561 |= 2u;\n  }\n  sub_80B3CDB();\n  sub_80B0A2C();\n  sub_804D5F4(\"started, v1.29.2\");\n  sub_806B5CE();\n  v9 = sub_804EBDE();\n  srand(v9);\n  byte_80DB765 = 0;\n  sub_806A57F(0, (int)\"deconfig\");\n  sub_806A242(2, v10);\nLABEL_31:\n  v11 = 0;\nLABEL_32:\n  v12 = 0;\nLABEL_33:\n  v13 = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        sub_806B60F();\n        if ( (int)(v11 - v13) <= 0 )\n        {\nLABEL_35:\n          if ( sub_806B66A(&dword_80DB978) )\n            goto LABEL_135;\n          if ( v39 )\n          {\n            v14 = v39;\n            *(_DWORD *)v39 = dword_80DB978;\n            *(_WORD *)(v39 + 4) = word_80DB97C;\n          }\n          switch ( byte_80DB765 )\n          {\n            case 0:\n              if ( v55 && v55 <= v12 )\n                goto LABEL_54;\n              if ( !v12 )\n                v40 = rand();\n              sub_8069F03(v40, s_addr, v14);\n              goto LABEL_61;\n            case 1:\n              if ( v12 <= 2 )\n              {\n                sub_8069F5B((struct in_addr)s_addr, v40, v38);\nLABEL_61:\n                v11 = seconds;\n                ++v12;\n                goto LABEL_33;\n              }\n              sub_806A242(2, v14);\n              byte_80DB765 = 0;\nLABEL_54:\n              sub_806A57F(0, (int)\"leasefail\");\n              if ( (v2 & 0x200000) != 0 )\n              {\n                sub_804D5F4(\"no lease, forking to background\");\n                sub_806A205();\n                v2 = v2 & 0xFFD7FFFF | 0x80000;\n              }\n              else if ( (v2 & 0x40) != 0 )\n              {\n                sub_804D5F4(\"no lease, failing\");\n                v43 = 1;\n                goto LABEL_137;\n              }\n              v11 = v53;\n              goto LABEL_32;\n            case 2:\n              byte_80DB765 = 3;\n              word_80DB9C4 = 0;\n              sub_806A242(1, v14);\n              goto LABEL_63;\n            case 3:\n            case 5:\n              goto LABEL_63;\n            case 4:\n              goto LABEL_66;\n            default:\n              v13 = 0;\n              goto LABEL_134;\n          }\n        }\n        v44 = sub_804EC4A();\n        v15 = 0x7FFFFFFF;\n        if ( (int)(v11 - v13) <= 2147482 )\n          v15 = 1000 * (v11 - v13);\n        v16 = poll(&fds, 2u, v15);\n        if ( v16 >= 0 )\n          break;\n        if ( *(_DWORD *)dword_80DBB7C != 4 )\n          sub_804D3C9((int)\"poll\");\n        v13 = sub_804EC4A() + v13 - v44;\n      }\n      if ( !v16 )\n        goto LABEL_35;\n      v17 = sub_806B646();\n      if ( v17 != 12 )\n        break;\n      sub_806A8AB(v38, s_addr);\nLABEL_134:\n      v11 = 0x7FFFFFFF;\n    }\n    if ( v17 == 15 )\n      break;\n    if ( v17 == 10 )\n    {\n      word_80DB9C4 = 0;\n      sub_804D5F4(\"performing DHCP renew\");\n      switch ( byte_80DB765 )\n      {\n        case 1:\n        case 6:\n          goto LABEL_77;\n        case 2:\n          sub_806A242(1, v14);\n          goto LABEL_75;\n        case 3:\n        case 4:\nLABEL_75:\n          byte_80DB765 = 5;\n          break;\n        case 5:\n          sub_806A57F(0, (int)\"deconfig\");\nLABEL_77:\n          sub_806A242(2, v14);\n          byte_80DB765 = 0;\n          break;\n        default:\n          break;\n      }\n      if ( byte_80DB765 != 5 )\n        goto LABEL_31;\n      if ( v11 > v53 )\n        v11 = v53;\nLABEL_63:\n      if ( v11 <= 60 || sub_806A01A(v40, (struct in_addr)v38, s_addr) < 0 )\n      {\n        byte_80DB765 = 4;\nLABEL_66:\n        sub_806A242(2, v14);\n        if ( v11 > 0 )\n        {\n          sub_806A01A(v40, 0, s_addr);\n          goto LABEL_68;\n        }\n        sub_804D5F4(\"lease lost, entering init state\");\n        sub_806A57F(0, (int)\"deconfig\");\n        byte_80DB765 = 0;\n        word_80DB9C4 = 0;\n        goto LABEL_32;\n      }\nLABEL_68:\n      v11 >>= 1;\n      goto LABEL_33;\n    }\n    if ( v57 )\n    {\n      if ( byte_80DB766 == 1 )\n        v18 = sub_806B29E();\n      else\n        v18 = sub_806A084(v58, fd);\n      v41 = v18;\n      if ( v18 == -1 )\n      {\n        sub_804D5F4(\"read error: %m, reopening socket\");\n        sleep(seconds);\n        sub_806A242(byte_80DB766, v19);\n      }\n      v13 = sub_804EC4A() + v13 - v44;\n      if ( v41 >= 0 && v59 == v40 && v58[2] == 6 )\n      {\n        v42 = memcmp(s1, &dword_80DB978, 6u);\n        if ( !v42 )\n        {\n          v20 = (char *)sub_806B9D0();\n          if ( v20 )\n          {\n            if ( byte_80DB765 == 1 )\n            {\nLABEL_106:\n              v22 = *v20;\n              if ( v22 == 5 )\n              {\n                v23 = (unsigned int *)sub_806B9D0();\n                if ( v23 )\n                {\n                  v24 = _byteswap_ulong(*v23);\n                  if ( v24 < 0x10 )\n                    v24 = 16;\n                }\n                else\n                {\n                  sub_804D5F4(\"no lease time with ACK, using 1 hour lease\");\n                  v24 = 3600;\n                }\n                if ( (v2 & 0x400000) == 0 || sub_806B7E1(0, 0, &dword_80DB978, *(_DWORD *)dword_80DB9A4, v45) )\n                {\n                  v28 = inet_ntoa(in);\n                  sub_804D5F4(\"lease of %s obtained, lease time %u\", v28, v24);\n                  s_addr = in.s_addr;\n                  v29 = sub_804EC4A();\n                  v30 = \"performing DHCP renew\" + 16;\n                  if ( byte_80DB765 == 1 )\n                    v30 = \"bound\";\n                  sub_806A57F((int)v58, (int)v30);\n                  v13 = sub_804EC4A() - v29;\n                  v32 = v24 >> 1;\n                  if ( v32 < v13 )\n                    v13 = 0;\n                  else\n                    v42 = v32;\n                  byte_80DB765 = 2;\n                  sub_806A242(0, v31);\n                  if ( (v2 & 0x100) != 0 )\n                    goto LABEL_135;\n                  v27 = v2 & 0xFFFFFFBF;\n                  if ( (v2 & 0x80000) == 0 )\n                  {\n                    sub_806A205();\n                    v27 = v2 & 0xFFD7FFBF | 0x80000;\n                  }\n                }\n                else\n                {\n                  sub_804D5F4(\"offered address is in use (got ARP reply), declining\");\n                  sub_8069FC3(v38, in.s_addr, v25);\n                  if ( byte_80DB765 != 1 )\n                    sub_806A57F(0, (int)\"deconfig\");\n                  sub_806A242(2, v26);\n                  byte_80DB765 = 0;\n                  word_80DB9C4 = 0;\n                  v42 = v53;\n                  v27 = v2;\n                  v12 = 0;\n                  v13 = 0;\n                  s_addr = 0;\n                }\n                v2 = v27;\n                v11 = v42;\n              }\n              else if ( v22 == 6 && (!v38 || (v34 = (_DWORD *)sub_806B9D0()) != 0 && v38 == *v34) )\n              {\n                sub_804D5F4(\"received %s\", \"DHCP NAK\");\n                sub_806A57F((int)v58, (int)\"nak\");\n                v33 = v36;\n                if ( byte_80DB765 != 1 )\n                  sub_806A57F(0, (int)\"deconfig\");\n                sub_806A242(2, v33);\n                sleep(3u);\n                byte_80DB765 = 0;\n                word_80DB9C4 = 0;\n                v11 = 0;\n                v12 = 0;\n                v13 = 0;\n                s_addr = 0;\n              }\n            }\n            else if ( byte_80DB765 > 1 )\n            {\n              if ( (unsigned __int8)(byte_80DB765 - 3) <= 2u )\n                goto LABEL_106;\n            }\n            else if ( !byte_80DB765 && *v20 == 2 )\n            {\n              v21 = (int *)sub_806B9D0();\n              if ( v21 )\n              {\n                v38 = *v21;\n              }\n              else\n              {\n                sub_804D5F4(\"no server ID, using 0.0.0.0\");\n                v38 = 0;\n              }\n              s_addr = in.s_addr;\n              byte_80DB765 = 1;\n              goto LABEL_31;\n            }\n          }\n          else\n          {\n            sub_804D5F4(\"no message type option, ignoring packet\");\n          }\n        }\n      }\n    }\n  }\n  sub_804D5F4(\"received %s\", \"SIGTERM\");\nLABEL_135:\n  if ( (v2 & 0x200) != 0 )\n    sub_806A8AB(v38, s_addr);\nLABEL_137:\n  if ( byte_80DBBA7 )\n    unlink(dword_80DB9A8);\n  return v43;\n}\n"
        ],
        "134656593": [
            "sub_806B251",
            "0x806b251",
            "int __usercall sub_806B251@<eax>(_BYTE *a1@<eax>, unsigned __int8 a2@<dl>)\n{\n  memset(a1, 0, 0x274u);\n  *a1 = 1;\n  if ( a2 <= 6u && ((1 << a2) & 0x64) != 0 )\n    *a1 = 2;\n  *(_WORD *)(a1 + 1) = 1537;\n  *((_DWORD *)a1 + 59) = 1666417251;\n  a1[240] = -1;\n  return sub_806BADE(a2, 53);\n}\n"
        ],
        "134656670": [
            "sub_806B29E",
            "0x806b29e",
            "ssize_t __usercall sub_806B29E@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  ssize_t result; // eax\n\n  memset(a1, 0, 0x274u);\n  result = sub_804E5BC(0x274u, a1, a2);\n  if ( result >= 0 && (result <= 239 || a1[59] != 1666417251) )\n  {\n    sub_804D5F4(\"packet with bad magic, ignoring\");\n    return -2;\n  }\n  return result;\n}\n"
        ],
        "134656745": [
            "sub_806B2E9",
            "0x806b2e9",
            "ssize_t __userpurge sub_806B2E9@<eax>(\n        const void *a1@<eax>,\n        int a2@<edx>,\n        __int16 a3@<cx>,\n        int a4,\n        __int16 a5,\n        int a6,\n        int a7)\n{\n  int v8; // eax\n  int v9; // ebx\n  unsigned int v10; // esi\n  __int16 v11; // ax\n  __int16 v12; // ax\n  ssize_t v13; // esi\n  const char *v14; // edi\n  _DWORD addr[5]; // [esp+8h] [ebp-2B4h] BYREF\n  int buf[7]; // [esp+1Ch] [ebp-2A0h] BYREF\n  char v20[628]; // [esp+38h] [ebp-284h] BYREF\n\n  v8 = socket(17, 2, 8);\n  if ( v8 < 0 )\n  {\n    v14 = \"socket(%s)\";\n    v13 = -1;\nLABEL_10:\n    sub_804D3A5((int)v14, \"PACKET\");\n    return v13;\n  }\n  v9 = v8;\n  memset(&addr[2], 0, 0xCu);\n  memset(buf, 0, sizeof(buf));\n  qmemcpy(v20, a1, sizeof(v20));\n  addr[0] = 524305;\n  addr[1] = a7;\n  HIBYTE(addr[2]) = 6;\n  addr[3] = *(_DWORD *)a6;\n  LOWORD(addr[4]) = *(_WORD *)(a6 + 4);\n  if ( bind(v8, (const struct sockaddr *)addr, 0x14u) < 0 )\n  {\n    v14 = \"bind(%s)\";\n    v13 = -1;\n  }\n  else\n  {\n    v10 = 307 - sub_806BA72();\n    if ( v10 > 0xF8 )\n      v10 = 248;\n    BYTE1(buf[2]) = 17;\n    buf[3] = a2;\n    buf[4] = a4;\n    LOBYTE(v11) = HIBYTE(a3);\n    HIBYTE(v11) = a3;\n    LOWORD(buf[5]) = v11;\n    LOBYTE(v11) = HIBYTE(a5);\n    HIBYTE(v11) = a5;\n    HIWORD(buf[5]) = v11;\n    HIBYTE(v11) = 44 - v10;\n    LOBYTE(v11) = (unsigned __int16)(556 - v10) >> 8;\n    LOWORD(buf[6]) = v11;\n    HIWORD(buf[0]) = v11;\n    HIWORD(buf[6]) = sub_80AD4D4();\n    HIBYTE(v12) = 64 - v10;\n    LOBYTE(v12) = (unsigned __int16)(576 - v10) >> 8;\n    HIWORD(buf[0]) = v12;\n    LOBYTE(buf[0]) = 69;\n    LOBYTE(buf[2]) = 64;\n    HIWORD(buf[2]) = sub_80AD4D4();\n    v13 = sendto(v9, buf, 576 - v10, 0, (const struct sockaddr *)addr, 0x14u);\n    v14 = \"sendto\";\n  }\n  close(v9);\n  if ( v13 < 0 )\n    goto LABEL_10;\n  return v13;\n}\n"
        ],
        "134657149": [
            "sub_806B47D",
            "0x806b47d",
            "int __userpurge sub_806B47D@<eax>(void *a1@<eax>, int a2@<edx>, __int16 a3@<cx>, int a4, __int16 a5)\n{\n  int v7; // eax\n  int v8; // ebx\n  __int16 v9; // ax\n  int v10; // ebp\n  const char *v11; // edi\n  __int16 v12; // ax\n  unsigned int v13; // eax\n  struct sockaddr addr; // [esp+4h] [ebp-20h] BYREF\n\n  v7 = socket(2, 2, 17);\n  if ( v7 < 0 )\n  {\n    v11 = \"socket(%s)\";\n    v10 = -1;\nLABEL_10:\n    sub_804D3A5((int)v11, \"UDP\");\n    return v10;\n  }\n  v8 = v7;\n  sub_80B4262();\n  memset(&addr.sa_data[6], 0, 8u);\n  addr.sa_family = 2;\n  LOBYTE(v9) = HIBYTE(a3);\n  HIBYTE(v9) = a3;\n  *(_WORD *)addr.sa_data = v9;\n  *(_DWORD *)&addr.sa_data[2] = a2;\n  v10 = bind(v8, &addr, 0x10u);\n  v11 = \"bind(%s)\";\n  if ( v10 != -1 )\n  {\n    memset(&addr.sa_data[6], 0, 8u);\n    addr.sa_family = 2;\n    LOBYTE(v12) = HIBYTE(a5);\n    HIBYTE(v12) = a5;\n    *(_WORD *)addr.sa_data = v12;\n    *(_DWORD *)&addr.sa_data[2] = a4;\n    v10 = connect(v8, &addr, 0x10u);\n    v11 = \"connect\";\n    if ( v10 != -1 )\n    {\n      v13 = 307 - sub_806BA72();\n      if ( v13 > 0xF8 )\n        v13 = 248;\n      v10 = sub_804E65D(548 - v13, a1, v8);\n      v11 = \"SMBus quick write\" + 12;\n    }\n  }\n  close(v8);\n  if ( v10 < 0 )\n    goto LABEL_10;\n  return v10;\n}\n"
        ],
        "134657426": [
            "sub_806B592",
            "0x806b592",
            "int __cdecl sub_806B592(char a1)\n{\n  _DWORD *v1; // ebx\n  int v2; // esi\n  int v4; // [esp+0h] [ebp-Ch] BYREF\n\n  v1 = (_DWORD *)dword_80DBB7C;\n  v2 = *(_DWORD *)dword_80DBB7C;\n  HIBYTE(v4) = a1;\n  if ( write(dword_80DB67C, (char *)&v4 + 3, 1u) != 1 )\n    sub_804D3A5((int)\"can't send signal\");\n  *v1 = v2;\n  return v4;\n}\n"
        ],
        "134657486": [
            "sub_806B5CE",
            "0x806b5ce",
            "int sub_806B5CE()\n{\n  sub_804DC65(&dword_80DB678);\n  sub_804D670(dword_80DB678);\n  sub_804D670(dword_80DB67C);\n  sub_804D61C(dword_80DB678);\n  sub_804D61C(dword_80DB67C);\n  return sub_804E6C8(37888, (void (*)(int))sub_806B592);\n}\n"
        ],
        "134657551": [
            "sub_806B60F",
            "0x806b60f",
            "int __usercall sub_806B60F@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = dword_80DB678;\n  *(_DWORD *)a1 = dword_80DB678;\n  *(_WORD *)(a1 + 4) = 1;\n  *(_DWORD *)(a1 + 8) = -1;\n  if ( a2 >= 0 )\n  {\n    result = sub_804D670(a2);\n    *(_DWORD *)(a1 + 8) = a2;\n    *(_WORD *)(a1 + 12) = 1;\n  }\n  *(_WORD *)(a1 + 14) = 0;\n  return result;\n}\n"
        ],
        "134657606": [
            "sub_806B646",
            "0x806b646",
            "int __fastcall sub_806B646(int a1)\n{\n  unsigned __int8 buf; // [esp+1h] [ebp-1h] BYREF\n\n  buf = HIBYTE(a1);\n  if ( sub_804E5BC(1u, &buf, dword_80DB678) == 1 )\n    return buf;\n  else\n    return 0;\n}\n"
        ],
        "134657642": [
            "sub_806B66A",
            "0x806b66a",
            "int __userpurge sub_806B66A@<eax>(const char *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, int a4)\n{\n  int v6; // edi\n  int v9[12]; // [esp+4h] [ebp-30h] BYREF\n\n  memset(v9, 0, 0x20u);\n  v6 = sub_804DF99(255, 3, 2);\n  LOWORD(v9[4]) = 2;\n  sub_804D67E((char *)v9, a1);\n  if ( a3 )\n  {\n    if ( sub_804E062(v6, 0x8915u, (int)v9, \"is interface %s up and configured?\", a1) )\n      goto LABEL_9;\n    *a3 = v9[5];\n  }\n  if ( !a2 )\n    goto LABEL_7;\n  if ( sub_804E09D(v6, 0x8933u, (int)v9, \"SIOCGIFINDEX\") )\n  {\nLABEL_9:\n    close(v6);\n    return -1;\n  }\n  *a2 = v9[4];\nLABEL_7:\n  if ( a4 )\n  {\n    if ( sub_804E09D(v6, 0x8927u, (int)v9, \"SIOCGIFHWADDR\") )\n      goto LABEL_9;\n    *(_DWORD *)a4 = *(int *)((char *)&v9[4] + 2);\n    *(_WORD *)(a4 + 4) = HIWORD(v9[5]);\n  }\n  close(v6);\n  return 0;\n}\n"
        ],
        "134657861": [
            "sub_806B745",
            "0x806b745",
            "int __usercall sub_806B745@<eax>(__int16 a1@<ax>, const char *a2@<edx>)\n{\n  int v4; // ebx\n  char *v5; // eax\n  char *v6; // esi\n  int v8; // [esp-4h] [ebp-24h]\n  struct sockaddr v9[2]; // [esp+0h] [ebp-20h] BYREF\n\n  v4 = sub_804DF99(17, 2, 2);\n  sub_80B4262();\n  if ( sub_80B426C() == -1 )\n    sub_804D3C9((int)\"SO_BROADCAST\");\n  v5 = strrchr(a2, 58);\n  v6 = v5;\n  if ( v5 )\n    *v5 = 0;\n  if ( sub_80B4280(v8, a2) )\n    sub_804D604();\n  if ( v6 )\n    *v6 = 58;\n  memset(&v9[0].sa_data[2], 0, 0xCu);\n  v9[0].sa_family = 2;\n  *(_WORD *)v9[0].sa_data = __ROL2__(a1, 8);\n  sub_804DFB3(0x10u, v9, v4);\n  return v4;\n}\n"
        ],
        "134658017": [
            "sub_806B7E1",
            "0x806b7e1",
            "int __userpurge sub_806B7E1@<eax>(\n        int a1@<eax>,\n        const void *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        int a5,\n        unsigned int timeout)\n{\n  int v6; // edi\n  unsigned int v9; // ebp\n  int v10; // edi\n  int v11; // eax\n  ssize_t v12; // eax\n  int fd; // [esp+4h] [ebp-64h]\n  struct sockaddr addr; // [esp+Ch] [ebp-5Ch] BYREF\n  int buf; // [esp+1Ch] [ebp-4Ch] BYREF\n  __int16 v18; // [esp+20h] [ebp-48h]\n  int v19; // [esp+22h] [ebp-46h]\n  __int16 v20; // [esp+26h] [ebp-42h]\n  int v21; // [esp+28h] [ebp-40h]\n  int v22; // [esp+2Ch] [ebp-3Ch]\n  __int16 v23; // [esp+30h] [ebp-38h]\n  int s2; // [esp+32h] [ebp-36h] BYREF\n  __int16 v25; // [esp+36h] [ebp-32h]\n  int v26; // [esp+38h] [ebp-30h]\n  _WORD v27[14]; // [esp+3Ch] [ebp-2Ch] BYREF\n\n  v6 = 1;\n  if ( timeout )\n  {\n    v6 = socket(17, 10, 1544);\n    fd = v6;\n    if ( v6 == -1 )\n    {\n      sub_804D3A5((int)\"can't create raw socket\");\n    }\n    else\n    {\n      if ( sub_80B426C() == -1 )\n      {\n        sub_804D3A5((int)\"can't enable bcast on raw socket\");\n      }\n      else\n      {\n        memset(v27, 0, sizeof(v27));\n        buf = -1;\n        v18 = -1;\n        v19 = *(_DWORD *)a4;\n        v20 = *(_WORD *)(a4 + 4);\n        v21 = 16778760;\n        v22 = 67502088;\n        v23 = 256;\n        s2 = v19;\n        v25 = v20;\n        v26 = a3;\n        *(_DWORD *)&v27[3] = a1;\n        memset(&addr, 0, sizeof(addr));\n        sub_80B2C4E(14);\n        if ( sendto(v6, &buf, 0x3Cu, 0, &addr, 0x10u) >= 0 )\n        {\n          v9 = timeout;\n          do\n          {\n            v10 = sub_804EC14();\n            v11 = sub_80B2C0A(v9, 1u);\n            if ( v11 < 0 )\n              break;\n            if ( v11 )\n            {\n              v12 = sub_804E5BC(0x3Cu, &buf, fd);\n              if ( v12 < 0 )\n                break;\n              if ( v12 > 41 && v23 == 512 && v26 == a1 )\n              {\n                v6 = 0;\n                if ( !a2 || memcmp(a2, &s2, 6u) )\n                  goto LABEL_19;\n                break;\n              }\n            }\n            v9 = v9 + v10 - 1 - sub_804EC14();\n          }\n          while ( v9 <= timeout );\n        }\n      }\n      v6 = 1;\nLABEL_19:\n      close(fd);\n    }\n  }\n  return v6;\n}\n"
        ],
        "134658420": [
            "sub_806B974",
            "0x806b974",
            "int __usercall sub_806B974@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n  const char *i; // ebx\n  const char *v6; // eax\n  int j; // edx\n  char v8; // cl\n\n  result = sub_804D222(a2, a1);\n  if ( result < 0 )\n  {\n    for ( i = a2; *i; i += strlen(i) + 1 )\n      ;\n    v6 = (const char *)sub_804DB2E(i - a2);\n    for ( j = 0; ; ++j )\n    {\n      v8 = a2[j];\n      if ( !v8 )\n      {\n        if ( !a2[j + 1] )\n          sub_804D5E0(\"unknown option '%s', known options: %s\", a1, v6);\n        v8 = 32;\n      }\n      v6[j] = v8;\n    }\n  }\n  return result;\n}\n"
        ],
        "134658512": [
            "sub_806B9D0",
            "0x806b9d0",
            "unsigned __int8 *__usercall sub_806B9D0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  unsigned __int8 *v3; // ecx\n  int v4; // esi\n  int v5; // ebx\n  unsigned __int8 v6; // al\n  int v7; // ebp\n\n  v3 = a1 + 240;\n  v4 = 0;\n  v5 = 388;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v6 = *v3;\n      if ( *v3 )\n        break;\n      --v5;\n      ++v3;\nLABEL_4:\n      if ( !v5 )\n        goto LABEL_5;\n    }\n    if ( v6 != 0xFF )\n      break;\n    if ( (v4 & 0x101) == 1 )\n    {\n      v4 |= 0x101u;\n      v3 = a1 + 108;\n      v5 = 128;\n    }\n    else\n    {\n      if ( (v4 & 0x202) != 2 )\n        return 0;\n      v4 |= 0x202u;\n      v3 = a1 + 44;\n      v5 = 64;\n    }\n  }\n  if ( v5 != 1 )\n  {\n    v7 = v3[1] + 2;\n    v5 -= v7;\n    if ( v5 >= 0 )\n    {\n      if ( v6 == a2 )\n        return v3 + 2;\n      if ( v3[1] )\n      {\n        if ( v6 == 52 )\n          v4 |= v3[2];\n      }\n      v3 += v7;\n      goto LABEL_4;\n    }\n  }\nLABEL_5:\n  sub_804D5F4(\"bad packet, malformed option field\");\n  return 0;\n}\n"
        ],
        "134658674": [
            "sub_806BA72",
            "0x806ba72",
            "int __usercall sub_806BA72@<eax>(int a1@<eax>)\n{\n  int i; // edx\n  char v2; // cl\n\n  for ( i = 0; ; ++i )\n  {\n    v2 = *(_BYTE *)(a1 + i);\n    if ( v2 == -1 )\n      break;\n    if ( v2 )\n      i += *(unsigned __int8 *)(a1 + i + 1) + 1;\n  }\n  return i;\n}\n"
        ],
        "134658703": [
            "sub_806BA8F",
            "0x806ba8f",
            "unsigned __int8 *__usercall sub_806BA8F@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>)\n{\n  int v4; // edi\n  int v5; // eax\n  unsigned int v6; // ecx\n  unsigned int v7; // ebp\n  unsigned __int8 *result; // eax\n  int v9; // [esp-8h] [ebp-18h]\n\n  v4 = a1 + 240;\n  v5 = sub_806BA72(a1 + 240);\n  v6 = a2[1] + 2;\n  v7 = v5 + v6;\n  if ( v5 + v6 + 1 <= 0x133 )\n  {\n    result = (unsigned __int8 *)(v4 + v5);\n    qmemcpy(result, a2, v6);\n    *(_BYTE *)(a1 + v7 + 240) = -1;\n  }\n  else\n  {\n    sub_804D5F4(\"option 0x%02x did not fit into the packet\", *a2);\n    return (unsigned __int8 *)v9;\n  }\n  return result;\n}\n"
        ],
        "134658782": [
            "sub_806BADE",
            "0x806bade",
            "unsigned __int8 *__usercall sub_806BADE@<eax>(int a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>)\n{\n  _BYTE *i; // ebx\n  char v5; // cl\n  unsigned __int8 v7[2]; // [esp+2h] [ebp-16h] BYREF\n  int v8; // [esp+4h] [ebp-14h]\n\n  for ( i = &unk_80B5BE0; ; i += 2 )\n  {\n    v5 = i[1];\n    if ( !v5 )\n      break;\n    if ( v5 == a2 )\n    {\n      v7[0] = a2;\n      v7[1] = byte_80CFCF3[*i & 0xF];\n      v8 = a3;\n      return sub_806BA8F(a1, v7);\n    }\n  }\n  return (unsigned __int8 *)sub_804D5F4(\"can't add option 0x%02x\", a2);\n}\n"
        ],
        "134658878": [
            "sub_806BB3E",
            "0x806bb3e",
            "unsigned __int8 **__usercall sub_806BB3E@<eax>(unsigned __int8 **result@<eax>, unsigned __int8 a2@<dl>)\n{\n  unsigned __int8 v2; // cl\n\n  while ( result )\n  {\n    v2 = **result;\n    if ( v2 >= a2 )\n    {\n      if ( v2 != a2 )\n        return 0;\n      return result;\n    }\n    result = (unsigned __int8 **)result[1];\n  }\n  return result;\n}\n"
        ],
        "134658906": [
            "sub_806BB5A",
            "0x806bb5a",
            "void __usercall sub_806BB5A(unsigned __int8 ***a1@<eax>, _BYTE *a2@<edx>, const char *a3@<ecx>, void *ptr)\n{\n  _BYTE *v6; // esi\n  _BYTE *v7; // eax\n  unsigned __int8 **v8; // eax\n  unsigned __int8 **v9; // ebp\n  unsigned __int8 **v10; // ebp\n  unsigned __int8 *v11; // eax\n  unsigned __int8 v12; // dl\n  unsigned __int8 **v13; // eax\n  unsigned __int8 *v14; // eax\n  int v15; // ebx\n  unsigned __int8 *v16; // eax\n  char *v17; // [esp+0h] [ebp-18h]\n\n  v6 = a3;\n  if ( (*a2 & 0xF) == 9 )\n  {\n    v17 = sub_804DB46(a3);\n    v7 = sub_804D76F(v17, v6, 255);\n    if ( *(_DWORD *)dword_80DBB7C )\n      sub_804D5E0(\"malformed hex string '%s'\", v6);\n    ptr = (void *)(v7 - v17);\n  }\n  else\n  {\n    v17 = 0;\n  }\n  v8 = sub_806BB3E(*a1, a2[1]);\n  v9 = v8;\n  if ( v8 )\n  {\n    if ( (*a2 & 0x20) != 0 )\n    {\n      v14 = *v8;\n      v15 = v14[1];\n      if ( (unsigned int)ptr + v15 <= 0xFE )\n      {\n        v16 = (unsigned __int8 *)sub_804DB13(v14, (size_t)ptr + v15 + 3);\n        *v9 = v16;\n        if ( (*a2 & 0xFu) - 3 <= 1 )\n          v16[v15++ + 2] = 32;\n        if ( v17 )\n          v6 = v17;\n        qmemcpy(&(*v9)[v15 + 2], v6, (unsigned int)ptr);\n        (*v9)[1] = (_BYTE)ptr + v15;\n      }\n    }\n  }\n  else\n  {\n    v10 = (unsigned __int8 **)sub_804DAFA(8u);\n    v11 = (unsigned __int8 *)sub_804DAFA((size_t)ptr + 2);\n    *v10 = v11;\n    v12 = a2[1];\n    *v11 = v12;\n    v11[1] = (unsigned __int8)ptr;\n    if ( v17 )\n      v6 = v17;\n    qmemcpy(v11 + 2, v6, (unsigned int)ptr);\n    while ( 1 )\n    {\n      v13 = *a1;\n      if ( !*a1 || v12 <= **v13 )\n        break;\n      a1 = (unsigned __int8 ***)(v13 + 1);\n    }\n    v10[1] = (unsigned __int8 *)v13;\n    *a1 = v10;\n  }\n  free(v17);\n}\n"
        ],
        "134659205": [
            "sub_806BC85",
            "0x806bc85",
            "int __fastcall sub_806BC85(int a1, _DWORD *a2)\n{\n  _DWORD *v3; // eax\n\n  v3 = (_DWORD *)sub_80B459A(2, 0);\n  if ( !v3 )\n    return 0;\n  *a2 = v3[2];\n  free(v3);\n  return 1;\n}\n"
        ],
        "134659247": [
            "sub_806BCAF",
            "0x806bcaf",
            "int __userpurge sub_806BCAF@<eax>(char *a1@<eax>, unsigned __int8 ***a2@<edx>, int a3@<ecx>, const char *a4)\n{\n  char *v5; // eax\n  const char *v6; // ebx\n  unsigned int v7; // eax\n  char *v8; // edi\n  int v9; // esi\n  char *v10; // ebx\n  int v11; // ecx\n  unsigned __int8 v12; // al\n  int v13; // ebp\n  unsigned __int32 *v14; // edx\n  int v15; // ebx\n  int v16; // edx\n  const char *v17; // eax\n  __int16 v18; // ax\n  char v19; // t0\n  int v20; // eax\n  int v21; // eax\n  char *v22; // eax\n  int v23; // ecx\n  char *v24; // ebp\n  int v25; // esi\n  unsigned int v26; // ebx\n  char *v27; // eax\n  unsigned int v28; // ebx\n  int v30; // [esp-8h] [ebp-2Ch]\n  int v31; // [esp-4h] [ebp-28h]\n  char v33[2]; // [esp+6h] [ebp-1Eh] BYREF\n  unsigned __int32 v34; // [esp+8h] [ebp-1Ch] BYREF\n  char v35; // [esp+Ch] [ebp-18h] BYREF\n\n  v5 = strtok(a1, \" \\t=:\");\n  if ( !v5 )\n    return 0;\n  v6 = v5;\n  v7 = sub_804ED6C(0, v5, 0, (int)v5);\n  if ( *(_DWORD *)dword_80DBB7C || v7 > 0xFE )\n  {\n    v8 = (char *)(2 * sub_806B974(v6, a4) + a3);\n  }\n  else\n  {\n    v33[0] = 9;\n    v33[1] = v7;\n    v8 = v33;\n  }\n  v9 = 0;\n  while ( 2 )\n  {\n    if ( *v8 == 9 )\n    {\n      v10 = strtok(0, &data);\n      sub_80B2F61();\n    }\n    else\n    {\n      v10 = strtok(0, \", \\t\");\n    }\n    v11 = v30;\n    if ( v10 )\n    {\n      v12 = *v8 & 0xF;\n      v13 = (unsigned __int8)byte_80CFCF3[v12];\n      switch ( v12 )\n      {\n        case 1u:\n          v14 = &v34;\n          goto LABEL_35;\n        case 2u:\n          v15 = sub_806BC85(v30, &v34);\n          if ( !strtok(0, \", \\t/-\") || !v15 )\n            return 0;\n          v14 = (unsigned __int32 *)&v35;\n          goto LABEL_35;\n        case 3u:\n        case 4u:\n          goto LABEL_19;\n        case 5u:\n          LOBYTE(v34) = sub_804ED6C(0, v10, 0, (int)v10);\n          goto LABEL_26;\n        case 6u:\n          v18 = sub_804ED6C(0, v10, 0, (int)v10);\n          v19 = HIBYTE(v18);\n          HIBYTE(v18) = v18;\n          LOBYTE(v18) = v19;\n          LOWORD(v34) = v18;\n          goto LABEL_26;\n        case 7u:\n          v20 = sub_804ED6C(0, v10, 0, (int)v10);\n          goto LABEL_25;\n        case 8u:\n          v20 = sub_804EDC5(0, v10, 0, (int)v10);\nLABEL_25:\n          v34 = _byteswap_ulong(v20);\nLABEL_26:\n          v21 = *(_DWORD *)dword_80DBB7C == 0;\n          goto LABEL_27;\n        case 9u:\n          v16 = (unsigned __int8)*v10;\n          if ( (_BYTE)v16 == 34 || (_BYTE)v16 == 39 )\n          {\n            v17 = sub_804D378(v10 + 1, v16);\n            if ( v17 )\n            {\n              *v17 = 0;\n              v33[0] = 3;\n              ++v10;\nLABEL_19:\n              v13 = strnlen(v10);\n              if ( v13 <= 0 )\n                return 0;\n            }\n          }\n          v9 = 1;\n          goto LABEL_38;\n        case 0xAu:\n          v22 = strchr(v10, 47);\n          v24 = v22;\n          if ( !v22 )\n            return 0;\n          *v22 = 0;\n          v25 = sub_806BC85(v23, (unsigned __int32 *)((char *)&v34 + 1));\n          v26 = sub_804ED6C(10, v24 + 1, 0, (int)v10);\n          LOBYTE(v34) = v26;\n          v27 = strtok(0, \", \\t/-\");\n          v11 = v31;\n          if ( v26 > 0x20 || !v27 || *(_DWORD *)dword_80DBB7C || !v25 )\n            return 0;\n          v28 = (v26 + 7) >> 3;\n          v13 = v28 + 5;\n          v14 = (unsigned __int32 *)((char *)&v34 + v28 + 1);\nLABEL_35:\n          v21 = sub_806BC85(v11, v14);\nLABEL_27:\n          v9 = v21;\n          if ( !v21 )\n            return 0;\n          v10 = (char *)&v34;\nLABEL_38:\n          sub_806BB5A(a2, v8, v10, (void *)v13);\n          if ( (*v8 & 0x20) == 0 )\n            return v9;\n          continue;\n        default:\n          return 0;\n      }\n    }\n    return v9;\n  }\n}\n"
        ],
        "134659828": [
            "sub_806BEF4",
            "0x806bef4",
            "int __usercall sub_806BEF4@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char v4[4]; // [esp+0h] [ebp-28h] BYREF\n  char v5[4]; // [esp+4h] [ebp-24h] BYREF\n  char v6[4]; // [esp+8h] [ebp-20h] BYREF\n  char v7[4]; // [esp+Ch] [ebp-1Ch] BYREF\n  char v8[4]; // [esp+10h] [ebp-18h] BYREF\n  char v9[4]; // [esp+14h] [ebp-14h] BYREF\n  char v10[4]; // [esp+18h] [ebp-10h] BYREF\n  char v11[12]; // [esp+1Ch] [ebp-Ch] BYREF\n\n  sub_804D727((int)v4, a2, 16);\n  return sprintf(a1, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v4, v5, v6, v7, v8, v9, v10, v11);\n}\n"
        ],
        "134659902": [
            "sub_806BF3E",
            "0x806bf3e",
            "int sub_806BF3E()\n{\n  FILE *v0; // ebx\n  int v2; // [esp+0h] [ebp-48h] BYREF\n  char s[68]; // [esp+4h] [ebp-44h] BYREF\n\n  v2 = 0;\n  v0 = (FILE *)sub_80B3D45();\n  while ( fgets_unlocked(s, 60, v0) && sscanf(s, \"Cached: %lu %*s\\n\", &v2) != 1 )\n    ;\n  fclose(v0);\n  return v2;\n}\n"
        ],
        "134659980": [
            "sub_806BF8C",
            "0x806bf8c",
            "int __cdecl sub_806BF8C(int a1, int a2)\n{\n  _BYTE *v2; // eax\n  unsigned __int8 v3; // al\n  char v4; // cl\n  unsigned int mem_unit; // ebx\n  int v6; // eax\n  char v8; // [esp+0h] [ebp-5Ch]\n  unsigned int v9; // [esp+0h] [ebp-5Ch]\n  char v10; // [esp+Bh] [ebp-51h]\n  struct sysinfo v11; // [esp+Ch] [ebp-50h] BYREF\n\n  v2 = *(_BYTE **)(a2 + 4);\n  if ( !v2 || *v2 != 45 )\n    goto LABEL_12;\n  v3 = v2[1];\n  if ( v3 == 103 )\n  {\n    v4 = 30;\n    goto LABEL_13;\n  }\n  if ( v3 <= 0x67u )\n  {\n    if ( v3 == 98 )\n    {\n      v4 = 0;\n      goto LABEL_13;\n    }\nLABEL_11:\n    sub_804CDC2();\n  }\n  if ( v3 != 107 )\n  {\n    if ( v3 != 109 )\n      goto LABEL_11;\n    v4 = 20;\n  }\n  else\n  {\nLABEL_12:\n    v4 = 10;\n  }\nLABEL_13:\n  v8 = v4;\n  printf(\"       %11s%11s%11s%11s%11s%11s\\nMem:   \", \"total\", \"used\", \"free\", \"shared\", \"buffers\", \"cached\");\n  sysinfo(&v11);\n  mem_unit = v11.mem_unit;\n  if ( !v11.mem_unit )\n    mem_unit = 1;\n  v10 = v8;\n  v6 = sub_806BF3E();\n  v9 = sub_80B4B88(v6 << 10, (unsigned __int64)(unsigned int)v6 >> 22, mem_unit, 0);\n  printf(\n    \"%11llu%11llu%11llu%11llu%11llu%11llu\\n\",\n    (v11.totalram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)(v11.totalram - v11.freeram)) >> (v10 & 0x1F),\n    (v11.freeram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (v11.sharedram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (v11.bufferram * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)v9) >> (v10 & 0x1F));\n  printf(\"-/+ buffers/cache:\");\n  printf(\n    \"%11llu%11llu\\n\",\n    (mem_unit * (unsigned __int64)(v11.totalram - (v9 + v11.bufferram + v11.freeram))) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)(v9 + v11.bufferram + v11.freeram)) >> (v10 & 0x1F));\n  printf(\"Swap:  \");\n  printf(\n    \"%11llu%11llu%11llu\\n\",\n    (v11.totalswap * (unsigned __int64)mem_unit) >> (v10 & 0x1F),\n    (mem_unit * (unsigned __int64)(v11.totalswap - v11.freeswap)) >> (v10 & 0x1F),\n    (v11.freeswap * (unsigned __int64)mem_unit) >> (v10 & 0x1F));\n  return 0;\n}\n"
        ],
        "134660505": [
            "sub_806C199",
            "0x806c199",
            "char __usercall sub_806C199@<al>(_DWORD *a1@<eax>)\n{\n  _DWORD *v1; // edx\n\n  v1 = (_DWORD *)*(&buf + 2);\n  if ( !*(&buf + 2) )\n    return 0;\n  while ( v1[4] != a1[1] || v1[3] != *a1 || (dword_80DBB9C & 1) == 0 && (v1[2] != a1[23] || v1[1] != a1[22]) )\n  {\n    v1 = (_DWORD *)*v1;\n    if ( !v1 )\n      return 0;\n  }\n  return 1;\n}\n"
        ],
        "134660579": [
            "sub_806C1E3",
            "0x806c1e3",
            "_DWORD *__usercall sub_806C1E3@<eax>(_DWORD *result@<eax>)\n{\n  size_t *v1; // edx\n  size_t *v2; // esi\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  int v5; // ecx\n  int v6; // ebx\n\n  v1 = (size_t *)*(&buf + 2);\n  v2 = &buf + 2;\n  while ( v1 )\n  {\n    if ( v1[4] == result[1] && v1[3] == *result && v1[2] == result[23] && v1[1] == result[22] )\n      return result;\n    v2 = v1;\n    v1 = (size_t *)*v1;\n  }\n  v3 = result;\n  result = sub_804DB2E(0x14u);\n  *v2 = (size_t)result;\n  v4 = v3[1];\n  result[3] = *v3;\n  result[4] = v4;\n  v5 = v3[22];\n  v6 = v3[23];\n  result[1] = v5;\n  result[2] = v6;\n  return result;\n}\n"
        ],
        "134660673": [
            "sub_806C241",
            "0x806c241",
            "int __fastcall sub_806C241(int a1, int a2)\n{\n  int v2; // ebp\n  int v3; // ebx\n  int *v4; // esi\n  char *v5; // ebx\n  const char *v6; // edi\n  signed int v7; // eax\n  bool v8; // zf\n  int v9; // eax\n  FILE *stream; // [esp+0h] [ebp-1D0h]\n  int v13; // [esp+8h] [ebp-1C8h] BYREF\n  int v14; // [esp+Ch] [ebp-1C4h] BYREF\n  int v15; // [esp+10h] [ebp-1C0h] BYREF\n  __int64 v16; // [esp+14h] [ebp-1BCh] BYREF\n  char v17[68]; // [esp+1Ch] [ebp-1B4h] BYREF\n  __int64 v18[12]; // [esp+60h] [ebp-170h] BYREF\n  char s[272]; // [esp+C0h] [ebp-110h] BYREF\n\n  stream = (FILE *)sub_80B3D37();\n  v2 = 0;\n  if ( !stream )\n    return v2;\n  if ( buf )\n  {\n    v4 = &v14;\n    v5 = (char *)&v13;\n    v6 = \"%*s %*s %*s %x:%x %llu\";\n  }\n  else\n  {\n    v18[0] = 0LL;\n    v3 = socket(2, 2, 0);\n    if ( v3 >= 0 )\n    {\n      fstat64(v3, v18);\n      close(v3);\n    }\n    v4 = &v15;\n    v5 = v17;\n    v6 = \"%*d: %64[0-9A-Fa-f]:%x %*x:%*x %*x %*x:%*x %*x:%*x %*x %*d %*d %llu\";\n  }\n  while ( fgets_unlocked(s, 255, stream) )\n  {\n    if ( sscanf(s, v6, v5, v4, &v16) == 3 )\n    {\n      v18[11] = v16;\n      if ( buf )\n      {\n        if ( v13 )\n        {\n          if ( v16 )\n          {\n            if ( v14 )\n            {\n              v18[0] = sub_80B0220();\n              LOBYTE(v9) = sub_806C199(v18);\n              v2 = v9;\n              if ( (_BYTE)v9 )\n                goto LABEL_22;\n            }\n          }\n        }\n      }\n      else\n      {\n        v7 = strlen(v17);\n        if ( v7 == 8 )\n        {\n          v8 = (dword_80DBB9C & 8) == 0;\nLABEL_15:\n          if ( v8 )\n            goto LABEL_16;\n        }\n        else\n        {\n          if ( v7 > 8 )\n          {\n            v8 = (dword_80DBB9C & 0x10) == 0;\n            goto LABEL_15;\n          }\nLABEL_16:\n          if ( v15 == a2 )\n            sub_806C1E3(v18);\n        }\n      }\n    }\n  }\n  v2 = 0;\nLABEL_22:\n  fclose(stream);\n  return v2;\n}\n"
        ],
        "134661034": [
            "sub_806C3AA",
            "0x806c3aa",
            "int __usercall sub_806C3AA@<eax>(const char *a1@<eax>)\n{\n  DIR *v1; // eax\n  int v2; // edx\n  int v3; // ecx\n  int v4; // esi\n  DIR *v5; // ebp\n  int v6; // eax\n  const char *v7; // ebx\n  void *v8; // edi\n  int v9; // edx\n  int v10; // eax\n  int v11; // edx\n  int v12; // ecx\n  int v13; // edx\n  int v15; // [esp-4h] [ebp-7Ch]\n  __pid_t pid; // [esp+4h] [ebp-74h]\n  char pida; // [esp+4h] [ebp-74h]\n  _DWORD v18[28]; // [esp+8h] [ebp-70h] BYREF\n\n  v1 = opendir(a1);\n  v4 = 0;\n  if ( v1 )\n  {\n    v5 = v1;\n    ++buf;\n    v4 = 0;\n    while ( 1 )\n    {\n      do\n      {\n        v6 = readdir64(v3, v2, v5);\n        if ( !v6 )\n        {\nLABEL_26:\n          closedir(v5);\n          --buf;\n          return v4;\n        }\n        v7 = (const char *)(v6 + 19);\n        v8 = (void *)sub_80A9BF5();\n      }\n      while ( !v8 );\n      switch ( buf )\n      {\n        case 2u:\n          v11 = sub_804D254(\"cwd\", v7);\n          LOBYTE(v10) = 0;\n          switch ( v11 )\n          {\n            case 0:\n            case 1:\n            case 2:\n              goto LABEL_19;\n            case 3:\n            case 4:\n            case 5:\n              v10 = sub_806C3AA();\n              goto LABEL_21;\n            case 6:\n              v10 = sub_806C241(v12, 0);\n              goto LABEL_21;\n            default:\n              goto LABEL_25;\n          }\n          goto LABEL_25;\n        case 3u:\nLABEL_19:\n          v13 = stat64(v8, v18);\n          LOBYTE(v10) = 0;\n          if ( v13 >= 0 )\n          {\n            LOBYTE(v10) = sub_806C199(v18);\nLABEL_21:\n            if ( (_BYTE)v10 )\n              v4 = v10;\n          }\n          goto LABEL_25;\n        case 1u:\n          v9 = sub_804ED6C(10, v7, 0, (int)v7);\n          LOBYTE(v10) = 0;\n          if ( *(_DWORD *)dword_80DBB7C )\n            goto LABEL_25;\n          if ( *(&buf + 1) == v9 )\n            goto LABEL_25;\n          pid = v9;\n          LOBYTE(v10) = sub_806C3AA();\n          if ( !(_BYTE)v10 )\n            goto LABEL_25;\n          if ( (dword_80DBB9C & 2) != 0 && kill(pid, *(&buf + 4)) )\n          {\n            sub_804D3A5((int)\"kill pid %s\", v7);\n            *((_BYTE *)&buf + 12) = 1;\n          }\n          if ( (dword_80DBB9C & 4) == 0 )\n            printf(\"%s \", v7);\n          v4 = 1;\n          break;\n      }\n      LOBYTE(v10) = 0;\nLABEL_25:\n      pida = v10;\n      free(v8);\n      v3 = v15;\n      if ( pida )\n        goto LABEL_26;\n    }\n  }\n  return v4;\n}\n"
        ],
        "134661413": [
            "sub_806C525",
            "0x806c525",
            "int __cdecl sub_806C525(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  char v4; // dl\n  const char **i; // ebx\n  int v6; // eax\n  int v7; // eax\n  const char *v8; // edi\n  char v9; // al\n  int v10; // edx\n  int v12; // [esp-4h] [ebp-84h]\n  int v13; // [esp+0h] [ebp-80h] BYREF\n  char dest[15]; // [esp+5h] [ebp-7Bh] BYREF\n  _DWORD v15[27]; // [esp+14h] [ebp-6Ch] BYREF\n\n  *(&buf + 1) = getpid();\n  *(&buf + 4) = 9;\n  v2 = a2;\n  while ( 1 )\n  {\n    v2 += 4;\n    v3 = *(_BYTE **)v2;\n    if ( !*(_DWORD *)v2 )\n      break;\n    if ( *v3 == 45 )\n    {\n      v4 = v3[1];\n      if ( v4 == 45 )\n      {\n        if ( !v3[2] )\n          break;\n        goto LABEL_9;\n      }\n      if ( (v4 & 0xFD) != 52 || v3[2] )\n      {\nLABEL_9:\n        v6 = sub_80B2FB5();\n        if ( v6 >= 0 )\n        {\n          *(&buf + 4) = v6;\n          do\n          {\n            v7 = *(_DWORD *)(v2 + 4);\n            *(_DWORD *)v2 = v7;\n            v2 += 4;\n          }\n          while ( v7 );\n          break;\n        }\n      }\n    }\n  }\n  sub_80ABEAC(a2, \"^mks64\");\n  for ( i = (const char **)(a2 + 4 * optind); ; ++i )\n  {\n    v8 = *i;\n    if ( !*i )\n      break;\n    strcpy(dest, \"/proc/net/\");\n    if ( sscanf(v8, \"%u/%4s\", &v13, &dest[10]) != 2 || access(dest, 4) )\n    {\n      sub_804DFF3(*i, (int)v15);\n      sub_806C1E3(v15);\n    }\n    else\n    {\n      sub_806C241(v12, v13);\n    }\n  }\n  v9 = sub_806C3AA(\"/proc\");\n  v10 = 1;\n  if ( v9 )\n  {\n    if ( (dword_80DBB9C & 4) == 0 )\n      sub_804DD98(10);\n    return *((char *)&buf + 12);\n  }\n  return v10;\n}\n"
        ],
        "134661697": [
            "sub_806C641",
            "0x806c641",
            "int __cdecl sub_806C641(int a1, int a2)\n{\n  const char *v2; // ebx\n  char v3; // bl\n  char **v4; // ebp\n  char *v5; // esi\n  char v6; // al\n  int *v7; // esi\n  int v8; // ebx\n  const char *v9; // eax\n  int v10; // eax\n  int v11; // edi\n  char *v12; // ecx\n  char v13; // al\n  char *v14; // edx\n  __pid_t v15; // eax\n  int v16; // eax\n  int v17; // edi\n  int v18; // eax\n  int v19; // eax\n  char **v20; // edx\n  char *v21; // eax\n  char *v22; // esi\n  int v23; // eax\n  bool v24; // zf\n  __pid_t *i; // esi\n  __pid_t v26; // eax\n  int v27; // edi\n  int sig; // [esp+0h] [ebp-28h]\n  char *v30; // [esp+4h] [ebp-24h]\n  __pid_t v31; // [esp+4h] [ebp-24h]\n  __pid_t *ptr; // [esp+8h] [ebp-20h]\n  char **v33; // [esp+Ch] [ebp-1Ch]\n  int v34; // [esp+10h] [ebp-18h]\n  char *v35; // [esp+14h] [ebp-14h] BYREF\n\n  v2 = *(const char **)a2;\n  v3 = v2[strlen(*(const char **)a2) - 3];\n  v4 = (char **)(a2 + 4);\n  v5 = *(char **)(a2 + 4);\n  if ( v5 && *v5 == 45 )\n  {\n    v6 = v5[1];\n    if ( v6 == 108 && !v5[2] )\n    {\n      v7 = (int *)(a2 + 8);\n      v8 = *(_DWORD *)(a2 + 8);\n      if ( v8 )\n      {\n        while ( 1 )\n        {\n          if ( (unsigned __int8)(*(_BYTE *)v8 - 48) <= 9u )\n          {\n            sub_804ED6C(10, (const char *)v8, 0, v8);\n            if ( *(_DWORD *)dword_80DBB7C )\n              goto LABEL_12;\n            v9 = (const char *)sub_80B30D9();\n            puts(v9);\n          }\n          else\n          {\n            v10 = sub_80B2FB5();\n            if ( v10 < 0 )\n            {\nLABEL_12:\n              sub_804D5F4(\"unknown signal '%s'\", v8);\n              return 1;\n            }\n            printf(\"%d\\n\", v10);\n          }\n          v8 = *++v7;\n          if ( !*v7 )\n            return v8;\n        }\n      }\n      sub_80B30F8();\n      return v8;\n    }\n    if ( v3 == 97 && v6 == 113 && !v5[2] )\n    {\n      v4 = (char **)(a2 + 8);\n      v5 = *(char **)(a2 + 8);\n      if ( !v5 )\n        sub_804CDC2();\n      v11 = 1;\n      if ( *v5 != 45 )\n        goto LABEL_37;\n    }\n    else\n    {\n      v11 = 0;\n    }\n    v12 = v5 + 1;\n    v13 = v5[1];\n    if ( v3 != 108 )\n    {\n      if ( v13 == 45 && !v5[2] )\n      {\n        sig = 15;\nLABEL_34:\n        v5 = v4[1];\n        ++v4;\n        goto LABEL_38;\n      }\nLABEL_27:\n      v14 = v4[1];\n      if ( v14 && v13 == 115 && !v5[2] )\n      {\n        ++v4;\n        v12 = v14;\n      }\n      v30 = v12;\n      sig = sub_80B2FB5();\n      if ( sig < 0 )\n      {\n        sub_804D5F4(\"bad signal name '%s'\", v30);\n        return 1;\n      }\n      goto LABEL_34;\n    }\n    if ( v13 != 111 )\n      goto LABEL_27;\n    ++v5;\n  }\n  else\n  {\n    v11 = 0;\n  }\nLABEL_37:\n  sig = 15;\nLABEL_38:\n  v15 = getpid();\n  v31 = v15;\n  if ( v3 != 108 )\n  {\n    if ( !v5 )\n    {\n      sub_804D5F4(\"you need to specify whom to kill\");\n      return 1;\n    }\n    v24 = v3 == 97;\n    v8 = 0;\n    if ( v24 )\n    {\n      do\n      {\n        ptr = (__pid_t *)sub_80AB493();\n        if ( *ptr )\n        {\n          for ( i = ptr; ; ++i )\n          {\n            v26 = *i;\n            if ( !*i )\n              break;\n            if ( v26 != v31 )\n            {\n              if ( kill(v26, sig) )\n              {\n                ++v8;\n                if ( !v11 )\n                  sub_804D3A5((int)\"can't kill pid %d\", *i);\n              }\n            }\n          }\n        }\n        else\n        {\n          ++v8;\n          if ( !v11 )\n            sub_804D5F4(\"%s: no process killed\", v5);\n        }\n        free(ptr);\n        v5 = *++v4;\n      }\n      while ( *v4 );\n      return v8;\n    }\n    while ( 1 )\n    {\n      if ( !*v5 )\n        goto LABEL_89;\n      if ( *v5 == 32 )\n        ++v5;\n      v27 = sub_804EDC5(10, v5, &v35, v8);\n      if ( !*(_DWORD *)dword_80DBB7C || *(_DWORD *)dword_80DBB7C == 22 && *v35 == 32 )\n      {\n        if ( kill(v27, sig) )\n        {\n          sub_804D3A5((int)\"can't kill pid %d\", v27);\n          ++v8;\n        }\n        v5 = v35;\n      }\n      else\n      {\n        sub_804D5F4(\"invalid number '%s'\", v5);\n        ++v8;\nLABEL_89:\n        v5 = *++v4;\n        if ( !*v4 )\n          return v8;\n      }\n    }\n  }\n  v34 = getsid(v15);\n  if ( (unsigned int)(sig - 18) > 1 )\n    kill(-1, 19);\n  v8 = 2;\nLABEL_42:\n  while ( 1 )\n  {\n    v16 = sub_80B0EC0();\n    v17 = v16;\n    if ( !v16 )\n      break;\n    v18 = *(_DWORD *)(v16 + 48);\n    if ( v18 )\n    {\n      if ( v34 != v18 )\n      {\n        v19 = *(_DWORD *)(v17 + 36);\n        if ( v31 != v19 )\n        {\n          v20 = v4;\n          if ( v19 != 1 )\n          {\n            while ( 1 )\n            {\n              v21 = *v20;\n              if ( !*v20 )\n                break;\n              v33 = v20 + 1;\n              if ( *v21 != 45 || v21[1] != 111 )\n              {\n                sub_804D5F4(\"bad option '%s'\");\nLABEL_56:\n                v8 = 1;\n                goto LABEL_60;\n              }\n              v22 = v21 + 2;\n              if ( !v21[2] && v20[1] )\n              {\n                v33 = v20 + 2;\n                v22 = v20[1];\n              }\n              v23 = sub_804EDC5(10, v22, 0, v8);\n              if ( *(_DWORD *)dword_80DBB7C )\n              {\n                sub_804D5F4(\"invalid number '%s'\");\n                goto LABEL_56;\n              }\n              if ( *(_DWORD *)(v17 + 36) == v23 )\n                goto LABEL_42;\n              v20 = v33;\n            }\n            kill(*(_DWORD *)(v17 + 36), sig);\n            v8 = 0;\n          }\n        }\n      }\n    }\n  }\nLABEL_60:\n  if ( (unsigned int)(sig - 18) > 1 )\n    kill(-1, 18);\n  return v8;\n}\n"
        ],
        "134662590": [
            "sub_806C9BE",
            "0x806c9be",
            "int __fastcall sub_806C9BE(int a1)\n{\n  int v1; // ebx\n  int v2; // edx\n  DIR *v3; // esi\n  int v4; // eax\n  const char *v5; // eax\n  char *v6; // ebp\n  int v8; // [esp-4h] [ebp-38h]\n  char s[51]; // [esp+1h] [ebp-33h] BYREF\n\n  while ( 1 )\n  {\n    v1 = sub_80B0EC0(a1, 257);\n    if ( !v1 )\n      break;\n    if ( getpid() != *(_DWORD *)(v1 + 36) )\n    {\n      sprintf(s, \"/proc/%u/fd/\", *(_DWORD *)(v1 + 36));\n      v3 = opendir(s);\n      if ( v3 )\n      {\n        while ( 1 )\n        {\n          v4 = readdir64(a1, v2, v3);\n          v2 = v8;\n          if ( !v4 )\n            break;\n          if ( *(_BYTE *)(v4 + 19) != 46 )\n          {\n            sub_80B2C4E(10);\n            v5 = (const char *)sub_804E190(s);\n            v6 = (char *)v5;\n            if ( v5 )\n            {\n              printf(\"%d\\t%s\\t%s\\n\", *(_DWORD *)(v1 + 36), *(const char **)(v1 + 12), v5);\n              free(v6);\n            }\n          }\n        }\n        closedir(v3);\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134662767": [
            "sub_806CA6F",
            "0x806ca6f",
            "int __cdecl sub_806CA6F(int a1, int a2)\n{\n  int v2; // ebx\n  unsigned int v3; // eax\n  _DWORD *v4; // esi\n  int v5; // ebx\n  _DWORD *v6; // ebp\n  _DWORD *i; // edi\n  int j; // ecx\n  char v10; // [esp+0h] [ebp-1Ch]\n  int *v11; // [esp+4h] [ebp-18h]\n  int v12[5]; // [esp+8h] [ebp-14h] BYREF\n\n  v12[0] = 0;\n  v10 = sub_80ABEAC(a2, \"so:*\", v12);\n  while ( 1 )\n  {\n    v2 = sub_80AFB6A();\n    if ( !v2 )\n      break;\n    v3 = getppid();\n    *(_DWORD *)(v2 + 4) = sub_804D6F7(v3);\n  }\n  v4 = (_DWORD *)(a2 + 4 * optind);\n  v5 = 1;\n  while ( *v4 )\n  {\n    sub_80AB493();\n    v6 = (_DWORD *)sub_80AB572();\n    for ( i = v6; *i; ++i )\n    {\n      if ( (v10 & 2) != 0 )\n      {\n        for ( j = v12[0]; j; j = *v11 )\n        {\n          v11 = (int *)j;\n          if ( sub_80B40EC() == *i )\n            goto LABEL_15;\n        }\n      }\n      printf((const char *)(v5 + 135085724), *i);\n      v5 = v10 & 1;\n      if ( (v10 & 1) != 0 )\n      {\n        v5 = 0;\n        break;\n      }\nLABEL_15:\n      ;\n    }\n    free(v6);\n    ++v4;\n  }\n  if ( !v5 )\n    sub_804DD98(10);\n  return v5;\n}\n"
        ],
        "134662991": [
            "sub_806CB4F",
            "0x806cb4f",
            "size_t sub_806CB4F()\n{\n  size_t v0; // edx\n\n  buf = sub_80B4733(*(&buf + 1), 5122);\n  v0 = (*(&buf + 1))++;\n  return 20 * v0 + buf;\n}\n"
        ],
        "134663154": [
            "sub_806CBF2",
            "0x806cbf2",
            "char *__usercall sub_806CBF2@<eax>(const char *a1@<eax>)\n{\n  int v2; // ebx\n  char *v3; // esi\n  char s[101]; // [esp+7h] [ebp-65h] BYREF\n\n  v2 = 0;\n  v3 = s;\n  while ( strncmp(a1, &aUser_2[v2], 6u) )\n  {\n    v3 += sprintf(v3, \"%.6s,\", &aUser_2[v2]);\n    v2 += 20;\n    if ( v2 == 240 )\n    {\n      *(v3 - 1) = 0;\n      sub_804D5E0(\"bad -o argument '%s', supported arguments: %s\", a1, s);\n    }\n  }\n  return (char *)&unk_80B5C40 + v2;\n}\n"
        ],
        "134663258": [
            "sub_806CC5A",
            "0x806cc5a",
            "char *__usercall sub_806CC5A@<eax>(const char *a1@<eax>)\n{\n  char *v2; // ebp\n  char *v3; // eax\n  char *v4; // ebx\n  char *v5; // esi\n  _DWORD *v6; // ebp\n  char *result; // eax\n\n  while ( 1 )\n  {\n    v2 = strchr(a1, 44);\n    v3 = strchr(a1, 61);\n    v4 = v3;\n    if ( !v2 || v2 >= v3 && v3 )\n      break;\n    *v2 = 0;\n    v5 = sub_806CBF2(a1);\n    qmemcpy((void *)sub_806CB4F(), v5, 0x14u);\n    *v2 = 44;\n    a1 = v2 + 1;\n  }\n  v6 = (_DWORD *)sub_806CB4F();\n  if ( v4 )\n    *v4 = 0;\n  result = sub_806CBF2(a1);\n  qmemcpy(v6, result, 0x14u);\n  if ( v4 )\n  {\n    *v4 = 61;\n    result = v4 + 1;\n    v6[2] = v4 + 1;\n    if ( !v4[1] )\n      return result;\n    result = (char *)strlen(v4 + 1);\n    *(_WORD *)v6 = (_WORD)result;\n  }\n  *(&buf + 2) = 1;\n  return result;\n}\n"
        ],
        "134663659": [
            "sub_806CDEB",
            "0x806cdeb",
            "int __cdecl sub_806CDEB(int a1, int a2)\n{\n  sub_80B0E79();\n  return sub_80B2C4E(a2 + 1);\n}\n"
        ],
        "134663695": [
            "sub_806CE0F",
            "0x806ce0f",
            "int __cdecl sub_806CE0F(int a1, int a2)\n{\n  const char *v2; // eax\n  int v3; // edx\n  int v4; // eax\n  signed int v5; // edx\n  unsigned __int16 *v6; // ecx\n  int v7; // ecx\n  char *v8; // ebx\n  int v9; // esi\n  const char **v10; // eax\n  int v11; // esi\n  char *v12; // ebx\n  int v13; // edi\n  size_t v14; // eax\n  char *v15; // ebx\n  int v16; // eax\n  int v18; // [esp+0h] [ebp-24h] BYREF\n  char dest[30]; // [esp+6h] [ebp-1Eh] BYREF\n\n  v18 = 0;\n  sub_80ABEAC(a2, \"Zo:*aAdefl\", &v18);\n  if ( v18 )\n  {\n    do\n    {\n      v2 = (const char *)sub_80AFB01(v18);\n      sub_806CC5A(v2);\n    }\n    while ( v18 );\n  }\n  else\n  {\n    strcpy(dest, \"pid,user,args\");\n    sub_806CC5A(dest);\n  }\n  *(&buf + 5) = 2048;\n  if ( isatty(1) )\n  {\n    *(&buf + 5) = sub_804D986(0, v3) - 1;\n    if ( *(&buf + 5) > 0x800 )\n      *(&buf + 5) = 2048;\n  }\n  v4 = 0;\n  v5 = 0;\n  while ( v5 < (int)*(&buf + 1) )\n  {\n    v6 = (unsigned __int16 *)(buf + 20 * v5);\n    *(&buf + 3) |= *((_DWORD *)v6 + 4);\n    if ( **((_BYTE **)v6 + 2) )\n      *(&buf + 2) = 1;\n    v4 += *v6 + 1;\n    ++v5;\n    if ( (int)(v4 - *(&buf + 5)) > 0 )\n    {\n      *(&buf + 1) = v5;\n      break;\n    }\n  }\n  v8 = (char *)sub_804DAFA(v4 + 1);\n  *(&buf + 4) = (size_t)v8;\n  if ( !*(&buf + 2) )\n    goto LABEL_21;\n  if ( *(&buf + 1) )\n  {\n    v9 = 0;\n    while ( 1 )\n    {\n      v10 = (const char **)(buf + 20 * v9++);\n      if ( v9 == *(&buf + 1) )\n        break;\n      v8 += sprintf(v8, \"%-*s \", *(unsigned __int16 *)v10, v10[2]);\n    }\n    strcpy(v8, v10[2]);\n  }\n  while ( 1 )\n  {\n    printf(\"%.*s\\n\", *(&buf + 5), (const char *)*(&buf + 4));\nLABEL_21:\n    v11 = sub_80B0EC0(v7, *(&buf + 3));\n    if ( !v11 )\n      break;\n    v12 = (char *)*(&buf + 4);\n    if ( *(&buf + 1) )\n    {\n      v13 = 0;\n      while ( 1 )\n      {\n        (*(void (__cdecl **)(char *, _DWORD, int))(20 * v13 + buf + 12))(\n          v12,\n          *(unsigned __int16 *)(20 * v13 + buf),\n          v11);\n        if ( !*v12 )\n          *(_WORD *)v12 = 45;\n        v14 = strlen(v12);\n        v15 = &v12[v14];\n        v16 = *(unsigned __int16 *)(buf + 20 * v13++) - v14 + 1;\n        if ( v13 == *(&buf + 1) )\n          break;\n        v12 = &v15[sprintf(v15, \"%*s\", v16, &data)];\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134664193": [
            "sub_806D001",
            "0x806d001",
            "int __usercall sub_806D001@<eax>(const char *a1@<eax>, int a2@<ebx>)\n{\n  int v3; // edi\n  char *v4; // eax\n  char *v5; // ebx\n  char *v6; // eax\n  int v7; // esi\n  char v8; // dl\n  char *v9; // edi\n  int v10; // ecx\n  int v11; // esi\n  int v12; // esi\n  const char *v13; // eax\n  unsigned __int8 *v14; // edi\n  unsigned __int8 *v15; // esi\n  unsigned __int8 v16; // dl\n  char *IO_write_base; // ecx\n  unsigned __int8 v20; // [esp+1h] [ebp-11h]\n  unsigned __int8 v21; // [esp+1h] [ebp-11h]\n\n  v3 = dword_80DBB9C & 0x20;\n  v4 = sub_804DB46(a1);\n  v5 = v4;\n  while ( *v4 )\n  {\n    if ( *v4 == 47 )\n      *v4 = 46;\n    ++v4;\n  }\n  v6 = strchr(a1, 61);\n  if ( !v6 )\n  {\n    if ( !v3 )\n    {\n      v7 = open64(a1);\n      v8 = 0;\n      if ( v7 >= 0 )\n      {\n        v14 = (unsigned __int8 *)sub_80B2402(a2);\n        close(v7);\n        if ( v14 )\n        {\n          v15 = v14;\n          while ( 1 )\n          {\n            v16 = *v15;\n            if ( !*v15 )\n              break;\n            if ( (dword_80DBB9C & 1) != 0 )\n            {\n              v20 = *v15;\n              printf(\"%s = \", v5);\n              v16 = v20;\n            }\n            do\n            {\n              IO_write_base = stdout->_IO_write_base;\n              if ( IO_write_base >= stdout->_IO_buf_base )\n              {\n                v21 = v16;\n                __fputc_unlocked(v16, stdout);\n                v16 = v21;\n              }\n              else\n              {\n                stdout->_IO_write_base = IO_write_base + 1;\n                *IO_write_base = v16;\n              }\n              ++v15;\n              if ( v16 == 10 )\n                break;\n              v16 = *v15;\n            }\n            while ( *v15 );\n          }\n          free(v14);\n        }\n        else\n        {\n          sub_804D3A5((int)\"error reading key '%s'\", v5);\n        }\nLABEL_35:\n        v12 = 0;\n        goto LABEL_43;\n      }\n      goto LABEL_14;\n    }\n    sub_804D5F4(\"error: '%s' must be of the form name=value\", v5);\nLABEL_37:\n    v12 = 1;\n    goto LABEL_43;\n  }\n  v9 = v6 + 1;\n  if ( a1 == v6 || !v6[1] )\n  {\n    sub_804D5F4(\"error: malformed setting '%s'\", v5);\n    goto LABEL_37;\n  }\n  *v6 = 0;\n  v5[v6 - a1] = 0;\n  v11 = open64(a1);\n  if ( v11 >= 0 )\n  {\n    sub_804DCD4(v10, v9);\n    close(v11);\n    v12 = 0;\n    if ( (dword_80DBB9C & 0x40) != 0 )\n      goto LABEL_43;\n    if ( (dword_80DBB9C & 1) != 0 )\n      printf(\"%s = \", v5);\n    puts(v9);\n    goto LABEL_35;\n  }\n  v8 = 1;\nLABEL_14:\n  if ( *(_DWORD *)dword_80DBB7C == 2 )\n  {\n    v12 = 1;\n    if ( (dword_80DBB9C & 2) != 0 )\n      sub_804D5F4(\"error: '%s' is an unknown key\", v5);\n  }\n  else\n  {\n    v12 = 0;\n    if ( *(_DWORD *)dword_80DBB7C != 13 )\n    {\n      v13 = \"I2C block read\" + 10;\n      if ( v8 )\n        v13 = \"sett\";\n      sub_804D3A5((int)\"error %sing key '%s'\", v13, v5);\n      goto LABEL_37;\n    }\n  }\nLABEL_43:\n  free(v5);\n  return v12;\n}\n"
        ],
        "134664671": [
            "sub_806D1DF",
            "0x806d1df",
            "size_t __usercall sub_806D1DF@<eax>(const char *a1@<eax>)\n{\n  size_t result; // eax\n  const char *v3; // esi\n  const char *v4; // ebp\n  char *i; // ebx\n\n  result = strlen(a1);\n  v3 = &a1[result];\n  v4 = a1 - 1;\n  a1[result] = 46;\nLABEL_2:\n  for ( i = (char *)v3; i > v4; --i )\n  {\n    if ( *i == 46 )\n    {\n      *i = 0;\n      result = access(a1, 0);\n      if ( !result )\n      {\n        *i = 47;\n        v4 = i;\n        goto LABEL_2;\n      }\n      *i = 46;\n    }\n  }\n  *v3 = 0;\n  return result;\n}\n"
        ],
        "134664742": [
            "sub_806D226",
            "0x806d226",
            "int __usercall sub_806D226@<eax>(const char *a1@<eax>)\n{\n  int v2; // edx\n  int v3; // ecx\n  DIR *v4; // ebp\n  int v5; // esi\n  int v6; // eax\n  void *v7; // ebx\n  char *v8; // ebx\n  int v10; // [esp-4h] [ebp-74h]\n  _WORD v11[56]; // [esp+0h] [ebp-70h] BYREF\n\n  stat64(a1, v11);\n  if ( (v11[8] & 0xF000) != 0x4000 || (dword_80DBB9C & 0x20) != 0 )\n  {\n    v8 = sub_804DB46(a1);\n    v5 = sub_806D001(v8, (int)v8);\n    free(v8);\n  }\n  else\n  {\n    v4 = opendir(a1);\n    v5 = -1;\n    if ( v4 )\n    {\n      v5 = 0;\n      while ( readdir64(v3, v2, v4) )\n      {\n        v6 = sub_80A9BF5();\n        v7 = (void *)v6;\n        if ( v6 )\n        {\n          v5 |= sub_806D226();\n          free(v7);\n          v3 = v10;\n        }\n      }\n      closedir(v4);\n    }\n  }\n  return v5;\n}\n"
        ],
        "134664901": [
            "sub_806D2C5",
            "0x806d2c5",
            "int __cdecl sub_806D2C5(int a1, int a2)\n{\n  int v2; // eax\n  const char **v3; // esi\n  int v4; // eax\n  char v5; // bl\n  int v6; // edi\n  int v7; // ebx\n  _BYTE *v8; // ebx\n  int v9; // ecx\n  const char *v11; // [esp+0h] [ebp-18h]\n\n  v2 = sub_80ABEAC(a2, \"+neAapwq\");\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = v2 ^ 3;\n  v5 = v4;\n  dword_80DBB9C = v4;\n  if ( (v4 & 0x10) != 0 )\n  {\n    dword_80DBB9C = v4 | 0x20;\n    if ( !*v3 )\n      *--v3 = \"/etc/sysctl.conf\";\n    v6 = sub_804DBE1(\".\");\n    do\n    {\n      sub_80B052C();\n      sub_804DF04(\"/proc/sys\");\n      while ( 1 )\n      {\n        v7 = sub_80B0560(\";#=\");\n        if ( !v7 )\n          break;\n        sub_80B2F61();\n        v8 = (_BYTE *)sub_80B2F61();\n        sub_806D1DF(v11);\n        *v8 = 61;\n        sub_80B2C69(v9);\n        sub_806D001(v11, (int)v8);\n      }\n      sub_804DF1F(v6);\n      ++v3;\n    }\n    while ( *v3 );\n  }\n  else\n  {\n    sub_804DF04(\"/proc/sys\");\n    v7 = v5 & 0xC;\n    if ( v7 )\n    {\n      return sub_806D226(\".\");\n    }\n    else\n    {\n      while ( *v3 )\n      {\n        sub_806D1DF(*v3);\n        v7 |= sub_806D226(*v3++);\n      }\n    }\n  }\n  return v7;\n}\n"
        ],
        "134665172": [
            "sub_806D3D4",
            "0x806d3d4",
            "int __cdecl sub_806D3D4(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12);\n}\n"
        ],
        "134665187": [
            "sub_806D3E3",
            "0x806d3e3",
            "int __cdecl sub_806D3E3(_DWORD *a1, _DWORD *a2)\n{\n  int result; // eax\n\n  result = -1;\n  if ( *a2 >= *a1 )\n    return *a2 != *a1;\n  return result;\n}\n"
        ],
        "134665211": [
            "sub_806D3FB",
            "0x806d3fb",
            "int __cdecl sub_806D3FB(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 8);\n}\n"
        ],
        "134665226": [
            "sub_806D40A",
            "0x806d40a",
            "int __cdecl sub_806D40A(int a1, int a2)\n{\n  int result; // eax\n  unsigned int v3; // edx\n\n  result = -1;\n  v3 = *(_DWORD *)(a1 + 4);\n  if ( *(_DWORD *)(a2 + 4) >= v3 )\n    return *(_DWORD *)(a2 + 4) != v3;\n  return result;\n}\n"
        ],
        "134665252": [
            "compar",
            "0x806d424",
            "int __cdecl compar(const void *a1, const void *a2)\n{\n  int i; // esi\n  int v3; // ebx\n  int result; // eax\n\n  for ( i = 0; i != 3; ++i )\n  {\n    v3 = dword_80DBB80;\n    result = (*(int (__cdecl **)(const void *, const void *))(dword_80DBB80 + 4 * i + 80))(a1, a2);\n    if ( result )\n      break;\n  }\n  if ( *(_BYTE *)(v3 + 8) )\n    return -result;\n  return result;\n}\n"
        ],
        "134665297": [
            "sub_806D451",
            "0x806d451",
            "int __usercall sub_806D451@<eax>(int a1@<eax>, _QWORD *a2@<edx>)\n{\n  int v3; // edi\n  const char *v4; // ebx\n  bool v5; // zf\n  int result; // eax\n  __int64 v7; // rcx\n\n  v3 = dword_80DBB80;\n  v4 = (const char *)(dword_80DBB80 + 280);\n  v5 = fgets_unlocked(dword_80DBB80 + 280, 448, a1) == 0;\n  result = 0;\n  if ( !v5 && *(_BYTE *)(v3 + 280) == 99 )\n  {\n    result = sscanf(\n               v4,\n               \"cpu %llu %llu %llu %llu %llu %llu %llu %llu\",\n               a2,\n               a2 + 1,\n               a2 + 2,\n               a2 + 3,\n               a2 + 4,\n               a2 + 5,\n               a2 + 6,\n               a2 + 7);\n    if ( result > 3 )\n    {\n      v7 = a2[7] + a2[6] + a2[5] + a2[4] + a2[3] + a2[2] + *a2 + a2[1];\n      a2[8] = v7;\n      a2[9] = v7 - a2[3] - a2[4];\n    }\n  }\n  return result;\n}\n"
        ],
        "134665474": [
            "sub_806D502",
            "0x806d502",
            "int sub_806D502()\n{\n  FILE *v0; // ebp\n  int v1; // ebx\n  _DWORD *v2; // edi\n  int i; // ecx\n  _DWORD *v4; // esi\n  int v5; // ebp\n  unsigned int v6; // edx\n  char *v7; // eax\n  int v8; // ebp\n  int result; // eax\n  unsigned int v10; // [esp+0h] [ebp-24h]\n  int v11; // [esp+4h] [ebp-20h]\n  unsigned int v12; // [esp+8h] [ebp-1Ch]\n  char *ptr; // [esp+Ch] [ebp-18h]\n  int v14; // [esp+10h] [ebp-14h]\n\n  v0 = (FILE *)sub_80B3D45();\n  v1 = dword_80DBB80;\n  qmemcpy((void *)(dword_80DBB80 + 180), (const void *)(dword_80DBB80 + 100), 0x50u);\n  if ( sub_806D451((int)v0, (_QWORD *)(v1 + 100)) <= 3 )\n    sub_804D5E0(\"can't read '%s'\", \"/proc/stat\");\n  fclose(v0);\n  *(_DWORD *)(v1 + 260) = 0;\n  v2 = sub_804DAFA(8 * *(_DWORD *)(v1 + 4));\n  v14 = *(_DWORD *)(v1 + 4);\n  ptr = *(char **)(v1 + 92);\n  v10 = 0;\n  for ( i = 0; v14 > i; ++i )\n  {\n    v4 = (_DWORD *)(*(_DWORD *)v1 + 44 * i);\n    v5 = v4[3];\n    v11 = v4[1];\n    v2[2 * i] = v11;\n    v2[2 * i + 1] = v5;\n    v4[2] = 0;\n    v12 = *(_DWORD *)(v1 + 96);\n    if ( v12 )\n    {\n      v6 = v10;\n      while ( 1 )\n      {\n        v7 = &ptr[8 * v6];\n        if ( *((_DWORD *)v7 + 1) == v5 )\n          break;\n        v6 = (v6 + 1) % v12;\n        if ( v10 == v6 )\n          goto LABEL_10;\n      }\n      v8 = v11 - *(_DWORD *)v7;\n      v4[2] = v8;\n      *(_DWORD *)(v1 + 260) += v8;\n      v10 = v6;\n    }\nLABEL_10:\n    ;\n  }\n  free(ptr);\n  *(_DWORD *)(v1 + 92) = v2;\n  result = *(_DWORD *)(v1 + 4);\n  *(_DWORD *)(v1 + 96) = result;\n  return result;\n}\n"
        ],
        "134665720": [
            "sub_806D5F8",
            "0x806d5f8",
            "int __usercall sub_806D5F8@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  FILE *v3; // esi\n  char *v4; // eax\n  char *v5; // ebx\n  int v6; // edi\n  size_t v7; // edi\n  const char *v8; // eax\n  int v9; // ebx\n  unsigned int v10; // ecx\n  int v11; // edx\n  int v12; // ecx\n  const char *v13; // eax\n  int v14; // esi\n  unsigned int v15; // eax\n  int v16; // eax\n  unsigned int v17; // edi\n  unsigned int v18; // ecx\n  int v19; // eax\n  const char *i; // esi\n  const char *v21; // eax\n  unsigned int v23; // [esp+0h] [ebp-D0h]\n  char v24; // [esp+0h] [ebp-D0h]\n  char *v25; // [esp+4h] [ebp-CCh]\n  int v27; // [esp+8h] [ebp-C8h]\n  char v28; // [esp+Ch] [ebp-C4h]\n  unsigned int v29; // [esp+10h] [ebp-C0h]\n  unsigned int v30; // [esp+20h] [ebp-B0h]\n  unsigned int v31; // [esp+24h] [ebp-ACh]\n  int v32[13]; // [esp+28h] [ebp-A8h] BYREF\n  char s[116]; // [esp+5Ch] [ebp-74h] BYREF\n\n  memset(v32, 0, sizeof(v32));\n  v3 = (FILE *)sub_80B3D45();\n  while ( fgets_unlocked(s, 60, v3) )\n  {\n    v4 = strchr(s, 58);\n    v5 = v4;\n    if ( v4 )\n    {\n      *v4 = 0;\n      v6 = sub_804D222(\"MemTotal\", s);\n      if ( v6 >= 0 )\n        v32[v6] = strtoul(v5 + 1, 0, 10);\n    }\n  }\n  fclose(v3);\n  v7 = a2;\n  if ( a2 > 100 )\n    v7 = 100;\n  v23 = v32[0];\n  snprintf(\n    s,\n    v7,\n    \"Mem: %luK used, %luK free, %luK shrd, %luK buff, %luK cached\",\n    v32[0] - v32[1],\n    v32[1],\n    v32[2] + v32[3],\n    v32[4],\n    v32[5]);\n  v8 = \"%s\\n\";\n  if ( (dword_80DBB9C & 4) == 0 )\n    v8 = \"\\x1B[H\\x1B[J%s\\n\";\n  printf(v8, s);\n  v9 = dword_80DBB80;\n  v10 = *(_DWORD *)(dword_80DBB80 + 164) - *(_DWORD *)(dword_80DBB80 + 244);\n  if ( !v10 )\n    v10 = 1;\n  snprintf(\n    s,\n    v7,\n    \"CPU:%4u%% usr%4u%% sys%4u%% nic%4u%% idle%4u%% io%4u%% irq%4u%% sirq\",\n    100 * (*(_DWORD *)(dword_80DBB80 + 100) - *(_DWORD *)(dword_80DBB80 + 180)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 116) - *(_DWORD *)(dword_80DBB80 + 196)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 108) - *(_DWORD *)(dword_80DBB80 + 188)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 124) - *(_DWORD *)(dword_80DBB80 + 204)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 132) - *(_DWORD *)(dword_80DBB80 + 212)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 140) - *(_DWORD *)(dword_80DBB80 + 220)) / v10,\n    100 * (*(_DWORD *)(dword_80DBB80 + 148) - *(_DWORD *)(dword_80DBB80 + 228)) / v10);\n  puts(s);\n  v25 = (char *)stpcpy(s, \"Load average: \");\n  sub_804E632((int)\"loadavg\", v25, 0x55u);\n  *((_BYTE *)&v32[12] + v7 + 3) = 0;\n  *(_BYTE *)strchrnul(v12, v11, v25, 10) = 0;\n  puts(s);\n  v13 = \"%.*s\";\n  if ( (dword_80DBB9C & 4) == 0 )\n    v13 = \"\\x1B[7m%.*s\\x1B[m\";\n  printf(v13, a2, \"  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND\");\n  v14 = a1 - 4;\n  v29 = 0xC800000 / v23;\n  v28 = 21;\n  while ( v29 > 0x1FF )\n  {\n    v29 >>= 2;\n    v28 -= 2;\n  }\n  v15 = *(_DWORD *)(v9 + 172) - *(_DWORD *)(v9 + 252);\n  if ( *(_DWORD *)(v9 + 260) < v15 )\n    *(_DWORD *)(v9 + 260) = v15;\n  v16 = 6400 * (unsigned __int16)v15;\n  if ( !v16 )\n    v16 = 1;\n  v17 = v16;\n  v24 = 6;\n  do\n  {\n    v17 *= 4;\n    v24 += 2;\n  }\n  while ( v17 <= 0x3FFFFFFF );\n  v18 = *(_DWORD *)(v9 + 260) * (unsigned __int16)(*(_WORD *)(v9 + 164) - *(_WORD *)(v9 + 244));\n  if ( v18 )\n    v17 /= v18;\n  while ( v17 > 0x3FF )\n  {\n    v17 >>= 2;\n    v24 -= 2;\n  }\n  v19 = *(_DWORD *)(v9 + 76);\n  v27 = *(_DWORD *)(v9 + 4) - v19;\n  if ( v27 > v14 )\n    v27 = v14;\n  for ( i = (const char *)(*(_DWORD *)v9 + 44 * v19 + 24); --v27 >= 0; i += 44 )\n  {\n    v30 = (((unsigned int)(1 << v28) >> 1) + *((_DWORD *)i - 6) * v29) >> v28;\n    v31 = (((unsigned int)(1 << v24) >> 1) + v17 * *((_DWORD *)i - 4)) >> v24;\n    sub_80AD152(\" mgtpezy\");\n    v21 = (const char *)sub_80B0E79();\n    if ( a2\n       + 2\n       - snprintf(\n           (char *)(v9 + 280),\n           a2 + 2,\n           \"\\n%5u%6u %-8.8s %s  %.5s%4u%%%4u%% \",\n           *((_DWORD *)i - 3),\n           *((_DWORD *)i - 2),\n           v21,\n           i,\n           s,\n           v30,\n           v31) > 1 )\n      sub_80B1146(*((_DWORD *)i - 3), i + 4);\n    fputs_unlocked(v9 + 280, stdout);\n  }\n  sub_804DD98((dword_80DBB9C & 4) == 0 ? 13 : 10);\n  return sub_804DD8F();\n}\n"
        ],
        "134666678": [
            "sub_806D9B6",
            "0x806d9b6",
            "int __usercall sub_806D9B6@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v3; // eax\n  int v4; // ebx\n  int v5; // eax\n  int v6; // eax\n  int v8; // [esp+0h] [ebp-8h]\n  int v9; // [esp+4h] [ebp-4h]\n\n  if ( (dword_80DBB9C & 0x10) != 0 )\n  {\n    sleep(a2);\n    return a1;\n  }\n  while ( 1 )\n  {\n    v4 = dword_80DBB80;\n    v5 = sub_80B20CC(1000 * a2, dword_80DBB80 + 264, v8, v9);\n    if ( v5 == -1 && *(_DWORD *)dword_80DBB7C != 11 )\n    {\n      dword_80DBB9C |= 0x10u;\n      return a1;\n    }\n    if ( *(unsigned __int8 *)(v4 + 33) == v5 || *(unsigned __int8 *)(v4 + 37) == v5 )\n      return 0;\n    switch ( v5 )\n    {\n      case -2:\n        --*(_DWORD *)(v4 + 76);\n        goto LABEL_24;\n      case -3:\n        ++*(_DWORD *)(v4 + 76);\n        goto LABEL_24;\n      case -6:\n        *(_DWORD *)(v4 + 76) = 0;\n        goto LABEL_24;\n      case -7:\n        *(_DWORD *)(v4 + 76) = *(_DWORD *)(v4 + 4) - (*(_DWORD *)(v4 + 12) >> 1);\n        goto LABEL_24;\n      case -10:\n        *(_DWORD *)(v4 + 76) -= *(_DWORD *)(v4 + 12) >> 1;\n        goto LABEL_24;\n    }\n    if ( v5 == -11 )\n      break;\n    v3 = v5 | 0x20;\n    switch ( v3 )\n    {\n      case 'q':\n        return 0;\n      case 'n':\n        *(_DWORD *)(v4 + 80) = sub_806D3D4;\n        break;\n      case 'm':\n        *(_DWORD *)(v4 + 80) = sub_806D3E3;\n        *(_DWORD *)(v4 + 84) = sub_806D3FB;\nLABEL_32:\n        *(_DWORD *)(v4 + 88) = sub_806D40A;\n        break;\n      case 'p':\n        *(_DWORD *)(v4 + 80) = sub_806D3FB;\n        *(_DWORD *)(v4 + 84) = sub_806D3E3;\n        goto LABEL_32;\n      case 't':\n        *(_DWORD *)(v4 + 80) = sub_806D40A;\n        *(_DWORD *)(v4 + 84) = sub_806D3E3;\n        *(_DWORD *)(v4 + 88) = sub_806D3FB;\n        break;\n      case 'r':\n        *(_BYTE *)(v4 + 8) ^= 1u;\n        break;\n      default:\n        return a1;\n    }\n    a2 = 0;\n  }\n  *(_DWORD *)(v4 + 76) += *(_DWORD *)(v4 + 12) >> 1;\nLABEL_24:\n  v6 = *(_DWORD *)(v4 + 4);\n  if ( *(_DWORD *)(v4 + 76) >= v6 )\n    *(_DWORD *)(v4 + 76) = v6 - 1;\n  a1 = -1;\n  if ( *(int *)(v4 + 76) < 0 )\n    *(_DWORD *)(v4 + 76) = 0;\n  return a1;\n}\n"
        ],
        "134667030": [
            "sub_806DB16",
            "0x806db16",
            "int sub_806DB16()\n{\n  _DWORD *v0; // ebx\n  int v2; // [esp-4h] [ebp-8h]\n\n  sub_80B0E38();\n  v0 = (_DWORD *)dword_80DBB80;\n  free(*(void **)dword_80DBB80);\n  *v0 = 0;\n  return v2;\n}\n"
        ],
        "134667058": [
            "sub_806DB32",
            "0x806db32",
            "int sub_806DB32()\n{\n  int result; // eax\n\n  if ( (dword_80DBB9C & 4) == 0 )\n    return sub_804D995((const struct termios *)(dword_80DBB80 + 16));\n  return result;\n}\n"
        ],
        "134667081": [
            "sub_806DB49",
            "0x806db49",
            "void __cdecl __noreturn sub_806DB49(int a1)\n{\n  sub_806DB32();\n  sub_804E761(a1);\n}\n"
        ],
        "134667095": [
            "sub_806DB57",
            "0x806db57",
            "int __cdecl sub_806DB57(int a1, int a2)\n{\n  int v2; // ebp\n  int v3; // edx\n  int v4; // ecx\n  int v5; // ebx\n  int v6; // esi\n  int v7; // edi\n  int v8; // eax\n  int v9; // eax\n  int v10; // esi\n  int v12; // [esp+0h] [ebp-24h]\n  unsigned int seconds; // [esp+4h] [ebp-20h]\n  unsigned int v14; // [esp+8h] [ebp-1Ch] BYREF\n  _BYTE *v15; // [esp+Ch] [ebp-18h] BYREF\n  int v16[5]; // [esp+10h] [ebp-14h] BYREF\n\n  dword_80DBB80 = (int)sub_804DB2E(0x2D8u);\n  sub_80ABEDA();\n  v14 = sub_80ABEAC(a2, \"d:n:b\", &v15, v16);\n  seconds = 5;\n  if ( (v14 & 1) != 0 )\n  {\n    if ( *v15 == 45 )\n      ++v15;\n    seconds = (unsigned __int16)sub_80B4193();\n  }\n  v2 = 0;\n  if ( (v14 & 2) != 0 )\n  {\n    if ( *(_BYTE *)v16[0] == 45 )\n      ++v16[0];\n    v2 = sub_80B40EC();\n  }\n  sub_804DF04(\"/proc\");\n  v3 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 80) = sub_806D3FB;\n  *(_DWORD *)(v3 + 84) = sub_806D3E3;\n  *(_DWORD *)(v3 + 88) = sub_806D40A;\n  if ( (dword_80DBB9C & 4) != 0 )\n  {\n    dword_80DBB9C |= 0x10u;\n  }\n  else\n  {\n    sub_804DA14(1, (struct termios *)(v3 + 16), 0);\n    dword_80DBB84 = sub_806DB32;\n  }\n  sub_804E6C8(117503054, (void (*)(int))sub_806DB49);\n  v12 = sub_806D9B6(13875, 0);\nLABEL_13:\n  while ( v12 )\n  {\n    v5 = dword_80DBB80;\n    if ( (dword_80DBB9C & 4) != 0 )\n    {\n      *(_DWORD *)(dword_80DBB80 + 12) = 0x7FFFFFFF;\nLABEL_20:\n      v14 = 446;\n      goto LABEL_21;\n    }\n    *(_DWORD *)(dword_80DBB80 + 12) = 24;\n    v14 = 79;\n    sub_804D878(1, (int *)&v14, (int *)(v5 + 12));\n    if ( *(_DWORD *)(v5 + 12) > 4u && v14 > 9 )\n    {\n      if ( v14 > 0x1BE )\n        goto LABEL_20;\nLABEL_21:\n      *(_DWORD *)(v5 + 4) = 0;\n      while ( 1 )\n      {\n        v6 = sub_80B0EC0(v4, v12);\n        if ( !v6 )\n          break;\n        v7 = *(_DWORD *)(v5 + 4);\n        *(_DWORD *)(v5 + 4) = v7 + 1;\n        v8 = sub_80B4733(v7, 11270);\n        *(_DWORD *)v5 = v8;\n        v7 *= 44;\n        v9 = v7 + v8;\n        *(_DWORD *)(v9 + 12) = *(_DWORD *)(v6 + 36);\n        *(_DWORD *)(v9 + 16) = *(_DWORD *)(v6 + 40);\n        *(_DWORD *)v9 = *(_DWORD *)(v6 + 16);\n        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v6 + 24) + *(_DWORD *)(v6 + 28);\n        *(_DWORD *)(v9 + 20) = *(_DWORD *)(v6 + 52);\n        strcpy((char *)(v9 + 24), (const char *)(v6 + 68));\n        strcpy((char *)(*(_DWORD *)v5 + v7 + 28), (const char *)(v6 + 72));\n      }\n      if ( !*(_DWORD *)(v5 + 4) )\n      {\n        sub_804D5F4(\"no process info in /proc\");\n        break;\n      }\n      if ( *(_DWORD *)(v5 + 96) )\n      {\n        sub_806D502();\n        qsort(*(void **)v5, *(_DWORD *)(v5 + 4), 0x2Cu, compar);\n        while ( 1 )\n        {\n          sub_806D5F8(*(_DWORD *)(v5 + 12), v14);\n          if ( v2 >= 0 && !--v2 )\n            goto LABEL_33;\n          v10 = sub_806D9B6(v12, seconds);\n          if ( v10 != -1 )\n          {\n            sub_806DB16();\n            v12 = v10;\n            goto LABEL_13;\n          }\n        }\n      }\n      sub_806D502();\n      usleep(0x186A0u);\n      sub_806DB16();\n    }\n    else\n    {\n      sleep(seconds);\n    }\n  }\nLABEL_33:\n  sub_804DD98(10);\n  sub_806DB32();\n  return 0;\n}\n"
        ],
        "134667725": [
            "sub_806DDCD",
            "0x806ddcd",
            "int sub_806DDCD()\n{\n  struct tm *v0; // ebx\n  const char *v1; // edx\n  time_t v3; // [esp+0h] [ebp-4Ch] BYREF\n  struct sysinfo v4; // [esp+4h] [ebp-48h] BYREF\n\n  time(&v3);\n  v0 = localtime(&v3);\n  sysinfo(&v4);\n  printf(\" %02u:%02u:%02u up \", v0->tm_hour, v0->tm_min, v0->tm_sec);\n  if ( v4.uptime / 0x15180u )\n  {\n    v1 = \"\\r\\n%s\" + 3;\n    if ( v4.uptime / 0x15180u == 1 )\n      v1 = &data;\n    printf(\"%u day%s, \", v4.uptime / 0x15180u, v1);\n  }\n  if ( v4.uptime / 0xE10u % 0x18 )\n    printf(\"%2u:%02u\", v4.uptime / 0xE10u % 0x18, v4.uptime / 0x3Cu % 0x3C);\n  else\n    printf(\"%u min\", v4.uptime / 0x3Cu % 0x3C);\n  printf(\n    \",  load average: %u.%02u, %u.%02u, %u.%02u\\n\",\n    HIWORD(v4.loads[0]),\n    (100 * (unsigned int)LOWORD(v4.loads[0])) >> 16,\n    HIWORD(v4.loads[1]),\n    (100 * (unsigned int)LOWORD(v4.loads[1])) >> 16,\n    HIWORD(v4.loads[2]),\n    (100 * (unsigned int)LOWORD(v4.loads[2])) >> 16);\n  return 0;\n}\n"
        ],
        "134667977": [
            "sub_806DEC9",
            "0x806dec9",
            "void __cdecl __noreturn sub_806DEC9(int a1, int a2)\n{\n  const char **v2; // esi\n  char *i; // edi\n  char *v4; // ebx\n  int v5; // ebp\n  int v6; // edx\n  unsigned int v7; // esi\n  char v8; // [esp+0h] [ebp-18h]\n  unsigned int seconds[5]; // [esp+4h] [ebp-14h] BYREF\n\n  seconds[0] = 2;\n  v8 = sub_80ABEAC(a2, \"^+dtn:+\", seconds);\n  v2 = (const char **)(a2 + 4 * optind);\n  for ( i = (char *)*v2; ; i = sub_804DDBF((char *)\"%s %s\", i, *v2) )\n  {\n    v4 = (char *)*++v2;\n    if ( !*v2 )\n      break;\n  }\n  v5 = -1;\n  while ( 1 )\n  {\n    printf(\"\\x1B[H\\x1B[J\");\n    if ( (v8 & 2) == 0 )\n    {\n      v7 = sub_804D986(2, v6);\n      if ( v5 != v7 )\n      {\n        free(v4);\n        v4 = sub_804DDBF(\"Every %us: %-*s\", seconds[0], v7, i);\n      }\n      if ( v7 > 0x14 )\n        sub_804EBAF(0, 0x14u, &v4[v7 - 20], (time_t)v4);\n      printf(\"%s\\n\\n\", v4);\n      v5 = v7;\n    }\n    sub_804DD8F();\n    system(i);\n    sleep(seconds[0]);\n  }\n}\n"
        ],
        "134668177": [
            "sub_806DF91",
            "0x806df91",
            "int __usercall sub_806DF91@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  const char *v2; // ecx\n\n  v2 = \"/log\";\n  if ( !*((_BYTE *)&buf + 48) )\n    v2 = &data;\n  printf(\"%s%s%s: %s\", a1, *(const char **)*(&buf + 1), v2, a2);\n  if ( *(_DWORD *)dword_80DBB7C )\n    printf(\": %m\");\n  return sub_804DD98(10);\n}\n"
        ],
        "134668251": [
            "sub_806DFDB",
            "0x806dfdb",
            "int __usercall sub_806DFDB@<eax>(const char *a1@<eax>)\n{\n  ++*(&buf + 2);\n  return sub_806DF91(\"warning: \", a1);\n}\n"
        ],
        "134668269": [
            "sub_806DFED",
            "0x806dfed",
            "int __usercall sub_806DFED@<eax>(const char *a1@<eax>)\n{\n  ++*(&buf + 2);\n  return sub_806DF91(\"fail: \", a1);\n}\n"
        ],
        "134668287": [
            "sub_806DFFF",
            "0x806dfff",
            "int __usercall sub_806DFFF@<eax>(const char *a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // ebx\n  int v4; // esi\n  int v5; // edi\n  size_t v6; // eax\n  int v8; // [esp-8h] [ebp-78h]\n  int v9; // [esp+0h] [ebp-70h] BYREF\n\n  if ( stat64(\"down\", &v9) == -1 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C != 2 )\n    {\n      sub_804D3A5((int)\"warning: can't stat %s/down\", *(const char **)*(&buf + 1));\n      return 0;\n    }\n    v3 = 1;\n  }\n  else\n  {\n    v3 = 0;\n  }\n  v4 = *(&buf + 10);\n  v5 = sub_80A9893(v8, *(&buf + 8));\n  if ( *((_BYTE *)&buf + 47) == 1 )\n  {\n    printf(\"run: \");\n  }\n  else if ( *((_BYTE *)&buf + 47) )\n  {\n    if ( *((_BYTE *)&buf + 47) == 2 )\n      printf(\"finish: \");\n  }\n  else\n  {\n    printf(\"down: \");\n  }\n  printf(\"%s: \", a1);\n  if ( *((_BYTE *)&buf + 47) )\n    printf(\"(pid %d) \", v4);\n  v6 = *(&buf + 5) - v5;\n  if ( (int)(*(&buf + 5) - v5) < 0 )\n    v6 = 0;\n  printf(\"%us\", v6);\n  if ( v4 )\n  {\n    if ( !v3 )\n      printf(\", normally down\");\n    if ( *((_BYTE *)&buf + 44) )\n      printf(\", paused\");\n    if ( *((_BYTE *)&buf + 45) == 100 )\n      printf(\", want down\");\n    v2 = 1;\n    if ( *((_BYTE *)&buf + 46) )\n      printf(\", got TERM\");\n  }\n  else\n  {\n    if ( v3 )\n      printf(\", normally up\");\n    v2 = 2;\n    if ( *((_BYTE *)&buf + 45) == 117 )\n      printf(\", want up\");\n  }\n  return v2;\n}\n"
        ],
        "134668610": [
            "sub_806E142",
            "0x806e142",
            "_BOOL4 sub_806E142()\n{\n  _BOOL4 result; // eax\n  __pid_t v1; // eax\n  int v2; // [esp-8h] [ebp-74h]\n  int v3; // [esp-4h] [ebp-70h]\n  int v4[3]; // [esp+0h] [ebp-6Ch] BYREF\n  char v5[96]; // [esp+Ch] [ebp-60h] BYREF\n\n  if ( stat64(\"check\", v5) == -1 )\n  {\n    result = 1;\n    if ( *(_DWORD *)dword_80DBB7C == 2 )\n      return result;\n    sub_804D3A5((int)\"warning: can't stat %s/check\", *(const char **)*(&buf + 1));\n    return 0;\n  }\n  v4[1] = (int)&unk_80D0442;\n  v4[2] = 0;\n  v1 = sub_80B3BA2(v2, v3);\n  if ( v1 <= 0 )\n  {\n    sub_804D3A5((int)\"warning: can't %s child %s/check\", \"run\", *(const char **)*(&buf + 1));\n    return 0;\n  }\n  if ( sub_804DA34(0, v4, v1) == -1 )\n  {\n    sub_804D3A5((int)\"warning: can't %s child %s/check\", \"wait for\", *(const char **)*(&buf + 1));\n    return 0;\n  }\n  return BYTE1(v4[0]) == 0;\n}\n"
        ],
        "134668768": [
            "sub_806E1E0",
            "0x806e1e0",
            "void __usercall __noreturn sub_806E1E0(const char *a1@<eax>)\n{\n  sub_804D3A5((int)\"fatal: can't %s\", a1);\n  _exit(151);\n}\n"
        ],
        "134668789": [
            "sub_806E1F5",
            "0x806e1f5",
            "int sub_806E1F5()\n{\n  int v0; // ebx\n  bool v1; // zf\n  const char *v2; // eax\n  int v3; // eax\n  ssize_t v4; // esi\n  const char *v5; // eax\n\n  v0 = open64(\"supervise/ok\");\n  if ( v0 != -1 )\n  {\n    close(v0);\n    v3 = open64(\"supervise/status\");\n    v0 = v3;\n    if ( v3 != -1 )\n    {\n      v4 = read(v3, &buf + 7, 0x14u);\n      close(v0);\n      if ( v4 == -1 )\n      {\n        v5 = (const char *)&unk_80D04CF;\n      }\n      else\n      {\n        v0 = 1;\n        if ( v4 == 20 )\n          return v0;\n        *(_DWORD *)dword_80DBB7C = 0;\n        v5 = \"can't read supervise/status: bad format\";\n      }\n      sub_806DFDB(v5);\n      return -1;\n    }\n    v2 = \"can't open supervise/status\";\n    goto LABEL_10;\n  }\n  if ( *(_DWORD *)dword_80DBB7C != 19 )\n  {\n    v2 = (const char *)&unk_80D049B;\nLABEL_10:\n    sub_806DFDB(v2);\n    return v0;\n  }\n  v1 = *(_BYTE *)buf == 120;\n  *(_DWORD *)dword_80DBB7C = 0;\n  if ( v1 )\n    sub_806DF91(\"ok: \", \"runsv not running\");\n  else\n    sub_806DFED(\"runsv not running\");\n  return 0;\n}\n"
        ],
        "134668996": [
            "sub_806E2C4",
            "0x806e2c4",
            "int sub_806E2C4()\n{\n  int v0; // ebx\n\n  v0 = 0;\n  if ( sub_806E1F5() > 0 )\n  {\n    v0 = sub_806DFFF(*(const char **)*(&buf + 1));\n    *((_BYTE *)&buf + 48) = 1;\n    if ( chdir(\"log\") == -1 )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 2 )\n      {\n        printf(\"; \");\n        sub_806DFDB(\"can't change directory\");\nLABEL_8:\n        *((_BYTE *)&buf + 48) = 0;\n        return v0;\n      }\n    }\n    else\n    {\n      printf(\"; \");\n      if ( !sub_806E1F5() )\n        goto LABEL_8;\n      v0 = sub_806DFFF(\"log\");\n    }\n    sub_804DD98(10);\n    goto LABEL_8;\n  }\n  return v0;\n}\n"
        ],
        "134669129": [
            "sub_806E349",
            "0x806e349",
            "int __cdecl sub_806E349(unsigned __int8 *a1)\n{\n  int v2; // ecx\n  int v3; // edi\n  int v4; // ebx\n  unsigned __int8 v5; // dl\n  int result; // eax\n  bool v7; // zf\n  bool v8; // zf\n  bool v9; // zf\n  unsigned __int64 v10; // rax\n  unsigned __int64 v11; // rax\n\n  v3 = sub_806E1F5();\n  if ( v3 != -1 )\n  {\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( !*a1 )\n      {\n        printf(\"ok: \");\n        sub_806DFFF(*(const char **)*(&buf + 1));\n        sub_804DD98(10);\n        return 1;\n      }\n      if ( !v3 )\n      {\n        result = 1;\n        if ( v5 == 120 )\n          return result;\n        return -1;\n      }\n      v4 = *(&buf + 10);\n      if ( v5 == 111 )\n      {\n        LODWORD(v11) = sub_80A9893(v2, *(&buf + 8));\n        if ( !v4 )\n        {\n          if ( *(_QWORD *)(&buf + 3) > v11 )\n            return 0;\n          goto LABEL_8;\n        }\n        v9 = *((_BYTE *)&buf + 45) == 100;\n      }\n      else\n      {\n        if ( v5 > 0x6Fu )\n        {\n          if ( v5 == 116 )\n            goto LABEL_28;\n          if ( v5 > 0x74u )\n          {\n            if ( v5 == 117 )\n            {\n              if ( !*(&buf + 10) )\n                return 0;\n              v8 = *((_BYTE *)&buf + 47) == 1;\n              goto LABEL_33;\n            }\n            v7 = v5 == 120;\n          }\n          else\n          {\n            if ( v5 != 112 || !*(&buf + 10) )\n              goto LABEL_8;\n            v7 = *((_BYTE *)&buf + 44) == 0;\n          }\n          goto LABEL_41;\n        }\n        if ( v5 == 99 )\n        {\n          if ( !*(&buf + 10) )\n            goto LABEL_8;\n          v9 = *((_BYTE *)&buf + 44) == 0;\n        }\n        else\n        {\n          if ( v5 <= 0x63u )\n          {\n            if ( v5 != 67 || !*(&buf + 10) )\n              goto LABEL_8;\n            goto LABEL_34;\n          }\n          if ( v5 != 100 )\n          {\n            if ( v5 != 107 )\n              goto LABEL_8;\nLABEL_28:\n            if ( !*(&buf + 10) && *((_BYTE *)&buf + 45) == 100 )\n              goto LABEL_8;\n            LODWORD(v10) = sub_80A9893(v2, *(&buf + 8));\n            if ( *(_QWORD *)(&buf + 3) > v10 || !v4 )\n              return 0;\n            v8 = *((_BYTE *)&buf + 46) == 0;\nLABEL_33:\n            if ( !v8 )\n              return 0;\nLABEL_34:\n            v7 = !sub_806E142();\nLABEL_41:\n            if ( v7 )\n              return 0;\n            goto LABEL_8;\n          }\n          if ( *(&buf + 10) )\n            return 0;\n          v9 = *((_BYTE *)&buf + 47) == 0;\n        }\n      }\n      if ( !v9 )\n        return 0;\nLABEL_8:\n      ++a1;\n    }\n  }\n  return -1;\n}\n"
        ],
        "134669541": [
            "sub_806E4E5",
            "0x806e4e5",
            "int __cdecl sub_806E4E5(char *s)\n{\n  int v1; // ebx\n  bool v2; // zf\n  size_t n; // edi\n  ssize_t v4; // esi\n\n  v1 = -1;\n  if ( sub_806E1F5() > 0 )\n  {\n    if ( *((_BYTE *)&buf + 45) != *s || (v1 = 0, *((_BYTE *)&buf + 45) == 100) && *((_BYTE *)&buf + 46) != 1 )\n    {\n      v1 = open64(\"supervise/control\");\n      if ( v1 == -1 )\n      {\n        if ( *(_DWORD *)dword_80DBB7C == 19 )\n        {\n          v2 = *s == 120;\n          *(_DWORD *)dword_80DBB7C = 0;\n          if ( v2 )\n            sub_806DF91(\"ok: \", \"runsv not running\");\n          else\n            sub_806DFED(\"runsv not running\");\n        }\n        else\n        {\n          sub_806DFDB(\"can't open supervise/control\");\n        }\n      }\n      else\n      {\n        n = strlen(s);\n        v4 = write(v1, s, n);\n        close(v1);\n        v1 = 1;\n        if ( n != v4 )\n        {\n          sub_806DFDB(\"can't write to supervise/control\");\n          return -1;\n        }\n      }\n    }\n  }\n  return v1;\n}\n"
        ],
        "134669739": [
            "sub_806E5AB",
            "0x806e5ab",
            "int __cdecl sub_806E5AB(int a1, int a2)\n{\n  _DWORD *v2; // eax\n  size_t *v4; // eax\n  size_t v5; // ebx\n  const char *v6; // eax\n  char v7; // al\n  bool v8; // zf\n  bool v9; // zf\n  int (__cdecl *v10)(unsigned __int8 *); // ebx\n  int (*v11)(); // edi\n  char v12; // si\n  const char *v13; // ebp\n  int v14; // edi\n  const char *v15; // ebp\n  int v16; // eax\n  int v17; // edx\n  int v18; // eax\n  int v19; // edx\n  _DWORD *v20; // [esp+0h] [ebp-40h]\n  const char *path; // [esp+4h] [ebp-3Ch]\n  unsigned int v22; // [esp+8h] [ebp-38h]\n  int fd; // [esp+Ch] [ebp-34h]\n  char *v24; // [esp+10h] [ebp-30h]\n  size_t v25; // [esp+14h] [ebp-2Ch]\n  char *format; // [esp+18h] [ebp-28h]\n  size_t v27; // [esp+1Ch] [ebp-24h]\n  int v28; // [esp+20h] [ebp-20h]\n  char v29[2]; // [esp+26h] [ebp-1Ah] BYREF\n  unsigned int v30; // [esp+28h] [ebp-18h] BYREF\n  int v31[5]; // [esp+2Ch] [ebp-14h] BYREF\n\n  v22 = sub_80ABEAC(a2, \"udopchaitkx\");\n  v2 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v2 || !v22 )\nLABEL_74:\n    sub_804CDC2();\n  v20 = v2 - 2;\n  if ( optind > 2 )\n  {\n    v20 = v2 - 3;\n    *(v2 - 1) = \"--\";\n  }\n  *v20 = 135052030;\n  v20[1] = v29;\n  v29[1] = 0;\n  v24 = \"udopchaitkx\";\n  while ( 2 )\n  {\n    if ( (v22 & 1) == 0 )\n      goto LABEL_7;\n    v29[0] = *v24;\n    optind = 0;\n    v30 = 7;\n    v31[0] = 0;\n    memset(&buf, 0, 0x34u);\n    byte_80DB560 = 100;\n    path = getenv(\"SVDIR\");\n    if ( !path )\n      path = &data;\n    if ( getenv(\"SVWAIT\") )\n      v30 = sub_80B40EC();\n    sub_80ABEAC(v20, \"^w:+v\", &v30, v31);\n    v4 = &v20[optind];\n    v25 = (size_t)(v4 + 1);\n    v5 = *v4;\n    if ( !*v4 || !v4[1] )\n      goto LABEL_74;\n    *(_QWORD *)(&buf + 5) = time(0) + 0x400000000000000ALL;\n    *(_QWORD *)(&buf + 3) = *(_QWORD *)(&buf + 5);\n    fd = open64(\".\");\n    if ( fd == -1 )\n    {\n      v6 = \"open current directory\";\n      goto LABEL_87;\n    }\n    buf = 135062127;\n    v7 = *(_BYTE *)v5;\n    if ( *(_BYTE *)v5 != 102 )\n    {\n      if ( *(_BYTE *)v5 > 0x66u )\n      {\n        if ( (unsigned __int8)v7 <= 0x71u )\n        {\n          if ( (unsigned __int8)v7 >= 0x6Fu )\n            goto LABEL_54;\n          if ( (unsigned __int8)v7 < 0x68u )\n            goto LABEL_74;\n          if ( (unsigned __int8)v7 <= 0x69u )\n            goto LABEL_54;\n          v8 = v7 == 107;\nLABEL_38:\n          if ( !v8 )\n            goto LABEL_74;\n          goto LABEL_54;\n        }\n        if ( v7 != 116 )\n        {\n          if ( (unsigned __int8)v7 <= 0x74u )\n          {\n            if ( v7 == 114 )\n            {\n              if ( !strcmp((const char *)v5, \"restart\") )\n              {\n                buf = (size_t)\"tcu\";\n              }\n              else\n              {\n                if ( strcmp((const char *)v5, \"reload\") )\n                  goto LABEL_74;\n                buf = (size_t)\"h\";\n              }\n            }\n            else if ( !strcmp((const char *)v5, \"shutdown\") )\n            {\n              buf = (size_t)\"x\";\n            }\n            else if ( !strcmp((const char *)v5, \"start\") )\n            {\n              buf = (size_t)\"u\";\n            }\n            else\n            {\n              if ( strcmp((const char *)v5, \"stop\") )\n              {\n                v10 = 0;\n                v11 = sub_806E2C4;\n                goto LABEL_78;\n              }\n              buf = 135061336;\n            }\n            goto LABEL_75;\n          }\n          if ( v7 == 117 )\n            goto LABEL_54;\n          v9 = v7 == 120;\n          goto LABEL_46;\n        }\n        if ( !strcmp((const char *)v5, \"try-restart\") )\n        {\n          buf = (size_t)\"tc\";\n          goto LABEL_75;\n        }\nLABEL_52:\n        if ( !strcmp((const char *)v5, \"check\") )\n        {\n          buf = 135061484;\n          v10 = sub_806E349;\n          v11 = 0;\nLABEL_78:\n          v12 = 0;\n          goto LABEL_79;\n        }\n        goto LABEL_54;\n      }\n      if ( v7 != 84 )\n      {\n        if ( (unsigned __int8)v7 <= 0x54u )\n        {\n          if ( v7 != 68 )\n          {\n            if ( (unsigned __int8)v7 <= 0x44u )\n            {\n              if ( (unsigned __int8)(v7 - 49) > 1u )\n                goto LABEL_74;\n              goto LABEL_54;\n            }\n            if ( v7 != 69 )\n              goto LABEL_74;\n            goto LABEL_70;\n          }\nLABEL_72:\n          buf = 135061336;\n          goto LABEL_73;\n        }\n        if ( v7 != 99 )\n        {\n          if ( (unsigned __int8)v7 <= 0x63u )\n          {\n            if ( v7 != 88 )\n            {\n              v8 = v7 == 97;\n              goto LABEL_38;\n            }\nLABEL_70:\n            buf = (size_t)\"x\";\n            goto LABEL_73;\n          }\n          if ( v7 == 100 )\n          {\nLABEL_54:\n            *(_BYTE *)(v5 + 1) = 0;\n            buf = v5;\n            goto LABEL_48;\n          }\n          v9 = v7 == 101;\nLABEL_46:\n          if ( !v9 )\n            goto LABEL_74;\n          buf = (size_t)\"x\";\nLABEL_48:\n          v10 = 0;\n          if ( !v31[0] )\n          {\nLABEL_76:\n            v11 = (int (*)())sub_806E4E5;\n            goto LABEL_78;\n          }\nLABEL_75:\n          v10 = sub_806E349;\n          goto LABEL_76;\n        }\n        goto LABEL_52;\n      }\n      goto LABEL_66;\n    }\n    if ( !strcmp((const char *)v5, \"force-reload\") )\n    {\nLABEL_66:\n      buf = (size_t)\"tc\";\n      goto LABEL_73;\n    }\n    if ( strcmp((const char *)v5, \"force-restart\") )\n    {\n      if ( strcmp((const char *)v5, \"force-shutdown\") )\n      {\n        if ( strcmp((const char *)v5, \"force-stop\") )\n          goto LABEL_74;\n        goto LABEL_72;\n      }\n      goto LABEL_70;\n    }\n    buf = (size_t)\"tcu\";\nLABEL_73:\n    v10 = sub_806E349;\n    v11 = (int (*)())sub_806E4E5;\n    v12 = 1;\nLABEL_79:\n    for ( *(&buf + 1) = v25; ; *(&buf + 1) += 4 )\n    {\n      v13 = *(const char **)*(&buf + 1);\n      if ( !*(_DWORD *)*(&buf + 1) )\n        break;\n      if ( (unsigned __int8)(*v13 - 46) > 1u && !sub_804D378(*(const char **)*(&buf + 1), 47) && chdir(path) == -1\n        || chdir(v13) == -1 )\n      {\n        sub_806DFED(\"can't change to service directory\");\nLABEL_92:\n        *(_DWORD *)*(&buf + 1) = -1;\n        goto LABEL_85;\n      }\n      if ( v11 && ((int (__cdecl *)(char *))v11)((char *)buf) == -1 )\n        goto LABEL_92;\nLABEL_85:\n      if ( fchdir(fd) == -1 )\n      {\nLABEL_86:\n        v6 = \"change to original directory\";\nLABEL_87:\n        sub_806E1E0(v6);\n      }\n    }\n    if ( !v10 )\n      goto LABEL_117;\n    format = \"timeout: \";\n    if ( v12 )\n      format = \"kill: \";\n    while ( 2 )\n    {\n      v27 = *(&buf + 5) - *(&buf + 3);\n      *(&buf + 1) = v25;\n      v14 = 1;\n      while ( 2 )\n      {\n        v15 = *(const char **)*(&buf + 1);\n        if ( *(_DWORD *)*(&buf + 1) )\n        {\n          if ( v15 == (const char *)-1 )\n          {\n            v19 = v14;\n          }\n          else\n          {\n            if ( (unsigned __int8)(*v15 - 46) > 1u && chdir(path) == -1 || chdir(v15) == -1 )\n            {\n              sub_806DFED(\"can't change to service directory\");\n              goto LABEL_110;\n            }\n            v16 = v10((unsigned __int8 *)buf);\n            v17 = v16;\n            if ( v16 )\n            {\nLABEL_110:\n              *(_DWORD *)*(&buf + 1) = -1;\n              v17 = v14;\n            }\n            else if ( v27 >= v30 )\n            {\n              printf(format);\n              if ( sub_806E1F5() > 0 )\n              {\n                sub_806DFFF(v15);\n                ++*(&buf + 2);\n              }\n              sub_804DD98(10);\n              v14 = 0;\n              if ( v12 )\n                sub_806E4E5(\"k\");\n              goto LABEL_110;\n            }\n            v28 = v17;\n            v18 = fchdir(fd);\n            v19 = v28;\n            if ( v18 == -1 )\n              goto LABEL_86;\n          }\n          *(&buf + 1) += 4;\n          v14 = v19;\n          continue;\n        }\n        break;\n      }\n      if ( !v14 )\n      {\n        usleep(0x668A0u);\n        *(_QWORD *)(&buf + 5) = time(0) + 0x400000000000000ALL;\n        continue;\n      }\n      break;\n    }\nLABEL_117:\n    if ( !*(&buf + 2) )\n    {\nLABEL_7:\n      ++v24;\n      v22 >>= 1;\n      if ( !v22 )\n        return 0;\n      continue;\n    }\n    return 1;\n  }\n}\n"
        ],
        "134671243": [
            "sub_806EB8B",
            "0x806eb8b",
            "int __cdecl sub_806EB8B(int a1, int a2)\n{\n  const char *v2; // ebx\n\n  v2 = *(const char **)(a2 + 4);\n  if ( !v2 )\n    sub_804CDC2();\n  byte_80DB560 = 111;\n  if ( (unsigned __int8)(*v2 - 46) > 1u && !sub_804D378(v2, 47) )\n    sub_804DF04(&data);\n  sub_804DF04(v2);\n  if ( open64(\"supervise/ok\") >= 0 )\n    return 0;\n  if ( (*(_DWORD *)dword_80DBB7C & 0xFFFFFFFB) != 2 )\n    sub_804D3C9((int)\"can't open '%s'\", \"supervise/ok\");\n  return 100;\n}\n"
        ],
        "134671368": [
            "sub_806EC08",
            "0x806ec08",
            "_BOOL4 __usercall sub_806EC08@<eax>(char *a1@<eax>)\n{\n  int v1; // edx\n  char v2; // cl\n\n  v1 = 0;\n  v2 = *a1;\n  do\n  {\n    ++v1;\n    if ( (unsigned __int8)(v2 - 48) > 9u )\n      break;\n    v2 = a1[v1];\n  }\n  while ( v1 != 9 );\n  return v2 == 0;\n}\n"
        ],
        "134671413": [
            "sub_806EC35",
            "0x806ec35",
            "int __usercall sub_806EC35@<eax>(int result@<eax>)\n{\n  int v1; // edx\n\n  v1 = dword_80DBB88;\n  *(_DWORD *)(dword_80DBB88 + 12) += *(_DWORD *)(dword_80DBB88 + 4) - result;\n  *(_DWORD *)(v1 + 4) = result;\n  return result;\n}\n"
        ],
        "134671431": [
            "sub_806EC47",
            "0x806ec47",
            "_BYTE *__cdecl sub_806EC47(_BYTE *a1, char *a2)\n{\n  _BYTE *result; // eax\n  char v4; // cl\n\n  result = a1;\n  while ( 1 )\n  {\n    v4 = *a2;\n    if ( !*a2 )\n      break;\n    ++a2;\n    if ( *result++ != v4 )\n      return 0;\n  }\n  return result;\n}\n"
        ],
        "134671456": [
            "sub_806EC60",
            "0x806ec60",
            "int __usercall sub_806EC60@<eax>(_BYTE *a1@<eax>)\n{\n  while ( (unsigned __int8)(*a1 - 48) <= 9u )\n  {\n    if ( !*++a1 )\n      return 1;\n  }\n  return 0;\n}\n"
        ],
        "134671481": [
            "sub_806EC79",
            "0x806ec79",
            "int __usercall sub_806EC79@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int i; // esi\n  int v3; // ecx\n  int v4; // ebx\n\n  for ( i = 0; ; ++i )\n  {\n    v3 = *(unsigned __int8 *)(a1 + i);\n    v4 = *(unsigned __int8 *)(a2 + i);\n    if ( v3 != v4 )\n      break;\n    if ( !*(_BYTE *)(a1 + i) )\n      goto LABEL_9;\n    if ( v3 == 61 )\n    {\n      v4 = 61;\n      return v3 - v4;\n    }\n  }\n  if ( v3 == 61 )\n    v3 = 0;\n  if ( v4 == 61 )\nLABEL_9:\n    v4 = 0;\n  return v3 - v4;\n}\n"
        ],
        "134671532": [
            "sub_806ECAC",
            "0x806ecac",
            "unsigned int __usercall sub_806ECAC@<eax>(unsigned __int8 *a1@<eax>)\n{\n  unsigned int i; // edx\n  int v2; // ecx\n\n  for ( i = 16 * *a1; ; i += v2 )\n  {\n    v2 = *a1;\n    if ( (_BYTE)v2 == 61 || !(_BYTE)v2 )\n      break;\n    ++a1;\n  }\n  return dword_80DBB90 + 4 * (i % 0x27) + 28;\n}\n"
        ],
        "134671576": [
            "sub_806ECD8",
            "0x806ecd8",
            "int __cdecl sub_806ECD8(int *a1, int *a2)\n{\n  return sub_806EC79(*a1, *a2);\n}\n"
        ],
        "134671593": [
            "sub_806ECE9",
            "0x806ece9",
            "_DWORD *__usercall sub_806ECE9@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *v4; // esi\n\n  while ( 1 )\n  {\n    v4 = (_DWORD *)*a1;\n    if ( !*a1 || !sub_806EC79(v4[2], a2) )\n      break;\n    a1 = v4;\n  }\n  return a1;\n}\n"
        ],
        "134671630": [
            "sub_806ED0E",
            "0x806ed0e",
            "int __usercall sub_806ED0E@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // ecx\n  int *v3; // ebx\n  int v4; // eax\n  int *v5; // edx\n\n  v2 = dword_80DB6E0;\n  v3 = &dword_80DB6E0;\n  while ( v2 != result )\n  {\n    v3 = (int *)(v2 + 28);\n    v2 = *(_DWORD *)(v2 + 28);\n  }\n  *v3 = *(_DWORD *)(v2 + 28);\n  if ( a2 )\n  {\n    if ( a2 != 1 )\n      return result;\n    v4 = dword_80DB6E0;\n    v5 = &dword_80DB6E0;\n    while ( v4 && *(_BYTE *)(v4 + 24) == 1 )\n    {\n      v5 = (int *)(v4 + 28);\n      v4 = *(_DWORD *)(v4 + 28);\n    }\n  }\n  else\n  {\n    v5 = &dword_80DB6E0;\n  }\n  result = *v5;\n  *(_DWORD *)(v2 + 28) = *v5;\n  *v5 = v2;\n  return result;\n}\n"
        ],
        "134671709": [
            "sub_806ED5D",
            "0x806ed5d",
            "int __usercall sub_806ED5D@<eax>(int a1@<eax>)\n{\n  unsigned int v2; // eax\n  unsigned int v3; // ecx\n  int v4; // edx\n  int result; // eax\n  int v6; // ecx\n\n  v2 = *(_DWORD *)(a1 + 12);\n  v3 = v2 + 12 * *(_DWORD *)(a1 + 20) - 12;\n  v4 = *(_DWORD *)(v3 + 4);\n  if ( *(_BYTE *)(dword_80DBB8C + 59) )\n  {\n    while ( !v4 )\n    {\n      v3 -= 12;\n      if ( v2 > v3 )\n        break;\n      v4 = *(_DWORD *)(v3 + 4);\n    }\n  }\n  result = BYTE1(v4);\n  v6 = v4 & 0x7F;\n  if ( (v4 & 0x7F) != 0 )\n  {\n    if ( (_BYTE)v4 == 127 )\n    {\n      v6 = BYTE1(v4);\n    }\n    else if ( v6 == 2 )\n    {\n      *(_BYTE *)(a1 + 25) |= 1u;\n    }\n    return v6 + 128;\n  }\n  return result;\n}\n"
        ],
        "134671792": [
            "sub_806EDB0",
            "0x806edb0",
            "int sub_806EDB0()\n{\n  int result; // eax\n\n  result = byte_80DB76C;\n  if ( (unsigned __int8)(byte_80DB76C - 1) <= 1u )\n  {\n    if ( --dword_80DB6A0 > 0 )\n      return 1;\n    else\n      byte_80DB76C = 0;\n  }\n  return result;\n}\n"
        ],
        "134671840": [
            "sub_806EDE0",
            "0x806ede0",
            "int sub_806EDE0()\n{\n  return 1;\n}\n"
        ],
        "134671846": [
            "sub_806EDE6",
            "0x806ede6",
            "int sub_806EDE6()\n{\n  return 0;\n}\n"
        ],
        "134671849": [
            "sub_806EDE9",
            "0x806ede9",
            "int sub_806EDE9()\n{\n  return *(unsigned __int8 *)(dword_80DBB8C + 1);\n}\n"
        ],
        "134671859": [
            "sub_806EDF3",
            "0x806edf3",
            "char sub_806EDF3()\n{\n  char result; // al\n\n  ++*((_DWORD *)off_80DB55C + 1);\n  result = byte_80DB76F;\n  byte_80DB76E = byte_80DB76F;\n  return result;\n}\n"
        ],
        "134671878": [
            "sub_806EE06",
            "0x806ee06",
            "void *sub_806EE06()\n{\n  void *result; // eax\n\n  result = off_80DB55C;\n  ++*((_DWORD *)off_80DB55C + 18);\n  return result;\n}\n"
        ],
        "134671887": [
            "sub_806EE0F",
            "0x806ee0f",
            "_DWORD *sub_806EE0F()\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x4Cu);\n  *result = off_80DB55C;\n  result[2] = -1;\n  off_80DB55C = result;\n  return result;\n}\n"
        ],
        "134671918": [
            "sub_806EE2E",
            "0x806ee2e",
            "int __usercall sub_806EE2E@<eax>(int a1@<eax>)\n{\n  int v1; // esi\n  int result; // eax\n  int v3; // ebx\n  int v4; // edx\n  _DWORD *v5; // eax\n  _DWORD *v6; // edx\n\n  v1 = dword_80DBB90;\n  if ( !a1 )\n    return *(_DWORD *)(dword_80DBB90 + 20);\n  v3 = 0;\n  do\n  {\n    v4 = v3 + 1;\n    v3 += 2;\n    if ( *(_BYTE *)a1 != 17 )\n      v3 = v4;\n    a1 = *(_DWORD *)(a1 + 4);\n  }\n  while ( a1 );\n  v5 = sub_804DB2E(8 * v3 + 8);\n  v6 = v5;\n  v5[1] = v3;\n  while ( --v3 != -1 )\n  {\n    v5[2 * v3 + 3] = -2;\n    v5[2 * v3 + 2] = -2;\n  }\n  result = *(_DWORD *)(v1 + 20);\n  *v6 = result;\n  *(_DWORD *)(v1 + 20) = v6;\n  return result;\n}\n"
        ],
        "134672009": [
            "sub_806EE89",
            "0x806ee89",
            "void *__usercall sub_806EE89@<eax>(void *result@<eax>)\n{\n  int v1; // edx\n  void **v2; // ebx\n  void *v3; // [esp+0h] [ebp-8h]\n\n  v1 = *((_DWORD *)result + 3);\n  if ( (v1 & 1) != 0 )\n  {\n    *((_DWORD *)result + 3) = v1 | 2;\n  }\n  else\n  {\n    v2 = (void **)result;\n    v3 = *(void **)result;\n    free(*((void **)result + 1));\n    free(v2[2]);\n    free(v2);\n    return v3;\n  }\n  return result;\n}\n"
        ],
        "134672064": [
            "sub_806EEC0",
            "0x806eec0",
            "int __usercall sub_806EEC0@<eax>(int result@<eax>)\n{\n  void **v1; // esi\n  void **i; // ebx\n  void *v3; // eax\n  int v4; // [esp-Ch] [ebp-Ch]\n\n  if ( *(_BYTE *)(result + 12) )\n  {\n    v1 = *(void ***)(result + 16);\n    for ( i = v1; ; ++i )\n    {\n      v3 = *i;\n      if ( !*i )\n        break;\n      free(v3);\n    }\n    free(v1);\n    return v4;\n  }\n  return result;\n}\n"
        ],
        "134672107": [
            "sub_806EEEB",
            "0x806eeeb",
            "_DWORD *__usercall sub_806EEEB@<eax>(_DWORD *result@<eax>)\n{\n  int v2; // [esp-4h] [ebp-4h]\n\n  if ( result )\n  {\n    if ( --*result < 0 )\n    {\n      free(result);\n      return (_DWORD *)v2;\n    }\n  }\n  return result;\n}\n"
        ],
        "134672123": [
            "sub_806EEFB",
            "0x806eefb",
            "int __usercall sub_806EEFB@<eax>(int a1@<eax>, char a2@<dl>, int a3@<ecx>)\n{\n  int v3; // ebx\n  _BYTE *v5; // eax\n  int v6; // eax\n\n  v3 = 11;\n  if ( a1 != 256 )\n  {\n    if ( a1 == 257 )\n    {\n      v6 = 0;\n      return ((int)(unsigned __int16)word_80B8564[v6] >> (4 * a2)) & 0xF;\n    }\n    v3 = 12;\n    if ( (unsigned __int8)(a1 + 127) > 7u )\n    {\n      v5 = (_BYTE *)strchrnul(a3, a1 + 127, \"\\t\\n !\\\"$&'()*-:;<=>?[\\\\]`|}~\", a1);\n      v3 = 0;\n      if ( *v5 )\n      {\n        v6 = (unsigned __int8)byte_80D0D31[v5 - \"\\t\\n !\\\"$&'()*-:;<=>?[\\\\]`|}~\"];\n        return ((int)(unsigned __int16)word_80B8564[v6] >> (4 * a2)) & 0xF;\n      }\n    }\n  }\n  return v3;\n}\n"
        ],
        "134672220": [
            "sub_806EF5C",
            "0x806ef5c",
            "char *__usercall sub_806EF5C@<eax>(const char *a1@<eax>)\n{\n  dword_80DB6A4 -= (strlen(a1) + 8) & 0xFFFFFFF8;\n  return strcpy((char *)dword_80DB6A4, a1);\n}\n"
        ],
        "134672262": [
            "sub_806EF86",
            "0x806ef86",
            "int __usercall sub_806EF86@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *v1; // ebx\n  int v2; // esi\n  char v3; // al\n  char *v4; // eax\n  char *v5; // eax\n  char *v6; // eax\n  int v7; // eax\n  int v8; // eax\n\n  v1 = a1;\n  if ( a1 )\n  {\n    v2 = dword_80DB6A8;\n    v3 = *a1;\n    dword_80DB6A8 += (unsigned __int8)byte_80D0F76[v3];\n    switch ( v3 )\n    {\n      case 0:\n        v4 = (char *)sub_806EF86();\n        goto LABEL_8;\n      case 1:\n        *(_DWORD *)(v2 + 4) = sub_806F087();\n        *(_BYTE *)(v2 + 1) = v1[1];\n        break;\n      case 2:\n      case 3:\n      case 4:\n      case 12:\n        goto LABEL_9;\n      case 5:\n      case 6:\n      case 7:\n      case 9:\n      case 10:\n        goto LABEL_6;\n      case 8:\n      case 13:\n        *(_DWORD *)(v2 + 12) = sub_806EF86();\nLABEL_6:\n        v5 = (char *)sub_806EF86();\n        goto LABEL_18;\n      case 11:\n        v4 = sub_806EF5C(*((const char **)v1 + 4));\nLABEL_8:\n        *(_DWORD *)(v2 + 16) = v4;\nLABEL_9:\n        *(_DWORD *)(v2 + 12) = sub_806EF86();\n        v6 = (char *)sub_806EF86();\n        goto LABEL_11;\n      case 14:\n        *(_DWORD *)(v2 + 12) = sub_806EF86();\n        v6 = sub_806EF5C(*((const char **)v1 + 2));\nLABEL_11:\n        *(_DWORD *)(v2 + 8) = v6;\n        v7 = *((_DWORD *)v1 + 1);\n        goto LABEL_20;\n      case 15:\n        *(_DWORD *)(v2 + 12) = sub_806F087();\n        v5 = sub_806EF5C(*((const char **)v1 + 2));\n        goto LABEL_18;\n      case 16:\n      case 17:\n      case 18:\n      case 19:\n      case 20:\n      case 21:\n        *(_DWORD *)(v2 + 16) = sub_806EF86();\n        goto LABEL_17;\n      case 22:\n      case 23:\n        *(_DWORD *)(v2 + 16) = sub_806EF86();\n        v8 = *((_DWORD *)v1 + 3);\n        goto LABEL_16;\n      case 24:\n      case 25:\n        v8 = sub_806EF86();\nLABEL_16:\n        *(_DWORD *)(v2 + 12) = v8;\nLABEL_17:\n        v5 = (char *)*((_DWORD *)v1 + 2);\nLABEL_18:\n        *(_DWORD *)(v2 + 8) = v5;\n        goto LABEL_19;\n      case 26:\nLABEL_19:\n        v7 = sub_806EF86();\nLABEL_20:\n        *(_DWORD *)(v2 + 4) = v7;\n        break;\n      default:\n        break;\n    }\n    *(_BYTE *)v2 = *v1;\n    return v2;\n  }\n  return (int)v1;\n}\n"
        ],
        "134672519": [
            "sub_806F087",
            "0x806f087",
            "int __usercall sub_806F087@<eax>(int **a1@<eax>, int a2@<ecx>)\n{\n  int *v3; // ebx\n  int v4; // edi\n  int v6; // [esp+0h] [ebp-10h] BYREF\n\n  v6 = a2;\n  v3 = &v6;\n  while ( a1 )\n  {\n    v4 = dword_80DB6A8;\n    *v3 = dword_80DB6A8;\n    dword_80DB6A8 = v4 + 8;\n    *(_DWORD *)(v4 + 4) = sub_806EF86(a1[1]);\n    a1 = (int **)*a1;\n    v3 = (int *)*v3;\n  }\n  *v3 = 0;\n  return v6;\n}\n"
        ],
        "134672578": [
            "sub_806F0C2",
            "0x806f0c2",
            "int *__usercall sub_806F0C2@<eax>(const char *a1@<eax>)\n{\n  int v2; // edx\n  unsigned int v3; // eax\n  const char *v4; // ecx\n  int *i; // ebx\n  int v6; // edi\n\n  v2 = *(unsigned __int8 *)a1;\n  v3 = 16 * v2;\n  v4 = a1;\n  while ( v2 )\n  {\n    v3 += v2;\n    v2 = *(unsigned __int8 *)++v4;\n  }\n  for ( i = (int *)(dword_80DB6F0 + 4 * (v3 % 0x27)); ; i = (int *)v6 )\n  {\n    v6 = *i;\n    if ( !*i || !strcmp(a1, *(const char **)(v6 + 4)) )\n      break;\n  }\n  return i;\n}\n"
        ],
        "134672653": [
            "sub_806F10D",
            "0x806f10d",
            "int __cdecl sub_806F10D(const char *a1, char *s2)\n{\n  return strcmp(a1, (const char *)(*(_DWORD *)s2 + 1));\n}\n"
        ],
        "134672669": [
            "sub_806F11D",
            "0x806f11d",
            "const char *__usercall sub_806F11D@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  __int16 v4; // ax\n  const char *i; // ecx\n  __int16 v6; // dx\n  const char **v7; // ebp\n  const char *j; // ebx\n  size_t v9; // eax\n\n  v4 = 16 * *(unsigned __int8 *)a1;\n  for ( i = a1; ; ++i )\n  {\n    v6 = *(unsigned __int8 *)i;\n    if ( !(_BYTE)v6 )\n      break;\n    v4 += v6;\n  }\n  v7 = (const char **)(dword_80DB6B0 + 4 * ((v4 & 0x7FFFu) % 0x1F));\n  for ( j = *v7; j; j = *(const char **)j )\n  {\n    if ( !strcmp(j + 10, a1) )\n      goto LABEL_10;\n    v7 = (const char **)j;\n  }\n  if ( a2 )\n  {\n    v9 = strlen(a1);\n    j = (const char *)sub_804DB2E(v9 + 12);\n    *v7 = j;\n    *((_BYTE *)j + 8) = -1;\n    strcpy((char *)j + 10, a1);\n  }\nLABEL_10:\n  dword_80DB6AC = (int)v7;\n  return j;\n}\n"
        ],
        "134672801": [
            "sub_806F1A1",
            "0x806f1a1",
            "int __cdecl sub_806F1A1(const char *a1, char *s2)\n{\n  return strcmp(a1, *(const char **)s2);\n}\n"
        ],
        "134672816": [
            "sub_806F1B0",
            "0x806f1b0",
            "int __usercall sub_806F1B0@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // ebp\n  int v3; // ecx\n  _DWORD *v4; // edi\n  _DWORD *v5; // ebx\n  int v7; // ebx\n  int v8; // ecx\n  int v9; // esi\n  int *v10; // edi\n  int v11; // eax\n  int v12; // [esp+0h] [ebp-14h] BYREF\n\n  v12 = result;\n  if ( a2 <= 1 )\n    return result;\n  v2 = a2 >> 1;\n  v3 = a2 >> 1;\n  v4 = (_DWORD *)result;\n  v5 = 0;\n  while ( --v3 != -1 )\n  {\n    v5 = v4;\n    v4 = (_DWORD *)*v4;\n  }\n  *v5 = 0;\n  v7 = sub_806F1B0(-1, a2 >> 1);\n  v9 = sub_806F1B0(v8, a2 - v2);\n  v10 = &v12;\n  while ( strcmp(*(const char **)(v9 + 4), *(const char **)(v7 + 4)) < 0 )\n  {\n    *v10 = v9;\n    v10 = (int *)v9;\n    if ( !*(_DWORD *)v9 )\n    {\n      *(_DWORD *)v9 = v7;\n      return v12;\n    }\n    v11 = v7;\n    v9 = *(_DWORD *)v9;\nLABEL_9:\n    v7 = v11;\n  }\n  *v10 = v7;\n  v10 = (int *)v7;\n  v11 = *(_DWORD *)v7;\n  if ( *(_DWORD *)v7 )\n    goto LABEL_9;\n  *(_DWORD *)v7 = v9;\n  return v12;\n}\n"
        ],
        "134672943": [
            "sub_806F22F",
            "0x806f22f",
            "void __usercall __noreturn sub_806F22F(char a1@<al>)\n{\n  int v1; // edx\n\n  v1 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  *(_BYTE *)(v1 + 43) = a1;\n  longjmp(*(struct __jmp_buf_tag **)(v1 + 32), 1);\n}\n"
        ],
        "134672969": [
            "sub_806F249",
            "0x806f249",
            "int __usercall sub_806F249@<eax>(const char **a1@<eax>)\n{\n  const char **v1; // ebp\n  int i; // esi\n  _DWORD *v3; // edi\n  _DWORD *j; // ebx\n  const char *v5; // eax\n  int v6; // ebx\n  int result; // eax\n\n  v1 = a1;\n  for ( i = 0; a1[i]; ++i )\n    ;\n  v3 = sub_804DAFA(4 * (i + 1));\n  for ( j = v3; ; *(j - 1) = sub_804DB46(v5) )\n  {\n    v5 = *v1;\n    if ( !*v1 )\n      break;\n    ++v1;\n    ++j;\n  }\n  *j = 0;\n  v6 = dword_80DBB90;\n  result = sub_806EEC0(dword_80DBB90);\n  *(_BYTE *)(v6 + 12) = 1;\n  *(_DWORD *)v6 = i;\n  *(_DWORD *)(v6 + 16) = v3;\n  *(_DWORD *)(v6 + 4) = 1;\n  *(_DWORD *)(v6 + 8) = -1;\n  return result;\n}\n"
        ],
        "134673073": [
            "sub_806F2B1",
            "0x806f2b1",
            "char __usercall sub_806F2B1@<al>(int a1@<eax>)\n{\n  int v2; // esi\n  _BYTE *v3; // eax\n  char v4; // bl\n  int v5; // ebp\n  int v6; // eax\n  int v8[9]; // [esp+0h] [ebp-24h] BYREF\n\n  v2 = dword_80DBB8C;\n  v3 = *(_BYTE **)(dword_80DBB8C + 4 * a1 + 192);\n  v4 = 1;\n  if ( v3 )\n    v4 = (*v3 == 0) + 2;\n  if ( *(_DWORD *)(dword_80DBB8C + 8) || v4 != 1 )\n    goto LABEL_19;\n  if ( a1 == 15 )\n  {\n    v4 = *(_BYTE *)(dword_80DBB8C + 48) == 0 ? 1 : 3;\n    goto LABEL_21;\n  }\n  if ( a1 > 15 )\n  {\n    if ( a1 == 20 || a1 == 22 )\n    {\n      v4 = *(_BYTE *)(dword_80DBB8C + 49) == 0 ? 1 : 3;\n      goto LABEL_19;\n    }\nLABEL_18:\n    v4 = 1;\nLABEL_19:\n    if ( a1 == 17 )\n      v4 = 2;\n    goto LABEL_21;\n  }\n  if ( a1 != 2 )\n  {\n    v4 = 3;\n    if ( a1 == 3 )\n      goto LABEL_21;\n    goto LABEL_18;\n  }\n  v4 = 2;\n  if ( !*(_BYTE *)(dword_80DBB8C + 48) && !*(_DWORD *)(dword_80DBB8C + 16) )\n    v4 = 2 - (*(_BYTE *)(dword_80DBB8C + 51) != 0);\nLABEL_21:\n  v5 = a1 - 1;\n  LOBYTE(v6) = *(_BYTE *)(dword_80DBB8C + a1 - 1 + 60);\n  if ( (_BYTE)v6 )\n  {\n    if ( (_BYTE)v6 == 4 )\n      return v6;\nLABEL_28:\n    if ( v4 == (_BYTE)v6 )\n      return v6;\n    goto LABEL_29;\n  }\n  v6 = sigaction(a1, 0, (struct sigaction *)v8);\n  if ( v6 )\n    return v6;\n  LOBYTE(v6) = v8[0];\n  if ( v8[0] == 1 )\n  {\n    if ( !*(_BYTE *)(v2 + 49) )\n      return v6;\n    LOBYTE(v6) = a1 - 20;\n    if ( (unsigned int)(a1 - 20) > 2 )\n      return v6;\n    LOBYTE(v6) = 3;\n    goto LABEL_28;\n  }\n  if ( !v8[0] && v4 == 1 )\n  {\n    *(_BYTE *)(v2 + v5 + 60) = 1;\n    return v6;\n  }\nLABEL_29:\n  *(_BYTE *)(v2 + v5 + 60) = v4;\n  v8[0] = 0;\n  if ( v4 == 2 )\n  {\n    v8[0] = (int)sub_806F444;\n  }\n  else if ( v4 == 3 )\n  {\n    v8[0] = 1;\n  }\n  v8[1] = 0;\n  v8[3] = -1;\n  v8[4] = -1;\n  LOBYTE(v6) = sub_804E698(a1, (const struct sigaction *)v8);\n  return v6;\n}\n"
        ],
        "134673373": [
            "sub_806F3DD",
            "0x806f3dd",
            "int __usercall sub_806F3DD@<eax>(int result@<eax>)\n{\n  int v1; // esi\n  int v2; // ebx\n  int v3; // [esp-8h] [ebp-10h]\n\n  v1 = dword_80DBB8C;\n  v2 = result - 1;\n  if ( (unsigned __int8)(*(_BYTE *)(dword_80DBB8C + result - 1 + 60) - 3) > 1u )\n  {\n    signal(result, (__sighandler_t)1);\n    result = v3;\n  }\n  *(_BYTE *)(v1 + v2 + 60) = 4;\n  return result;\n}\n"
        ],
        "134673414": [
            "sub_806F406",
            "0x806f406",
            "void __noreturn sub_806F406()\n{\n  int v0; // ebx\n\n  v0 = dword_80DBB8C;\n  *(_BYTE *)(dword_80DBB8C + 40) = 0;\n  sub_804E6A5(1);\n  if ( *(_DWORD *)(v0 + 8) || !*(_BYTE *)(v0 + 48) )\n  {\n    signal(2, 0);\n    raise(2);\n  }\n  *(_BYTE *)v0 = -126;\n  sub_806F22F(0);\n}\n"
        ],
        "134673476": [
            "sub_806F444",
            "0x806f444",
            "int __cdecl sub_806F444(int a1)\n{\n  int result; // eax\n\n  result = dword_80DBB8C;\n  if ( a1 != 17 || (*(_BYTE *)(dword_80DBB8C + 41) = 1, *(_DWORD *)(result + 260)) )\n  {\n    *(_BYTE *)(result + a1 + 123) = 1;\n    *(_BYTE *)(result + 42) = a1;\n    if ( a1 == 2 && !*(_DWORD *)(result + 200) )\n    {\n      if ( !*(_DWORD *)(result + 36) )\n      {\n        *(_BYTE *)(result + 42) = 0;\n        sub_806F406();\n      }\n      *(_BYTE *)(result + 40) = 1;\n    }\n  }\n  return result;\n}\n"
        ],
        "134673548": [
            "sub_806F48C",
            "0x806f48c",
            "char sub_806F48C()\n{\n  int v0; // eax\n  char result; // al\n\n  v0 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 36) = 0;\n  result = *(_BYTE *)(v0 + 40);\n  if ( result )\n    sub_806F406();\n  return result;\n}\n"
        ],
        "134673573": [
            "sub_806F4A5",
            "0x806f4a5",
            "char sub_806F4A5()\n{\n  int v0; // edx\n  char result; // al\n\n  v0 = dword_80DBB8C;\n  if ( (*(_DWORD *)(dword_80DBB8C + 36))-- == 1 )\n  {\n    result = *(_BYTE *)(v0 + 40);\n    if ( result )\n      sub_806F406();\n  }\n  return result;\n}\n"
        ],
        "134673597": [
            "sub_806F4BD",
            "0x806f4bd",
            "char sub_806F4BD()\n{\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  sub_804DD8F();\n  return sub_806F4A5();\n}\n"
        ],
        "134673620": [
            "sub_806F4D4",
            "0x806f4d4",
            "char __usercall sub_806F4D4@<al>(int a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // esi\n  void **v4; // edi\n  _BYTE *v5; // edx\n  char v6; // cl\n  bool v7; // cc\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v2 = dword_80DB6B0;\n  v3 = dword_80DB6B0 + 124;\nLABEL_2:\n  if ( v2 != v3 )\n  {\n    v4 = (void **)v2;\n    while ( 1 )\n    {\n      v5 = *v4;\n      if ( !*v4 )\n      {\n        v2 += 4;\n        goto LABEL_2;\n      }\n      v6 = v5[8];\n      if ( v6 )\n      {\n        if ( v6 != 2 )\n          goto LABEL_11;\n        v7 = dword_80DB554 < a1;\n      }\n      else\n      {\n        v7 = *((_DWORD *)v5 + 1) < a1;\n      }\n      if ( v7 )\n      {\nLABEL_11:\n        v4 = (void **)*v4;\n      }\n      else\n      {\n        *v4 = *(void **)v5;\n        free(v5);\n      }\n    }\n  }\n  return sub_806F4A5();\n}\n"
        ],
        "134673882": [
            "sub_806F5DA",
            "0x806f5da",
            "char sub_806F5DA()\n{\n  _DWORD *v0; // eax\n  _DWORD *v1; // ebx\n\n  v0 = ptr;\n  if ( ptr )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    do\n    {\n      v1 = (_DWORD *)*v0;\n      free(v0);\n      v0 = v1;\n    }\n    while ( v1 );\n    ptr = 0;\n    LOBYTE(v0) = sub_806F4A5();\n    dword_80DB6BC = 0;\n  }\n  else\n  {\n    dword_80DB6BC = 0;\n  }\n  return (char)v0;\n}\n"
        ],
        "134673958": [
            "sub_806F626",
            "0x806f626",
            "int __usercall sub_806F626@<eax>(const char *a1@<eax>)\n{\n  void **v1; // eax\n\n  v1 = (void **)sub_806F0C2(a1);\n  if ( !*v1 )\n    return 1;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  *v1 = sub_806EE89(*v1);\n  sub_806F4A5();\n  return 0;\n}\n"
        ],
        "134674009": [
            "sub_806F659",
            "0x806f659",
            "char sub_806F659()\n{\n  _DWORD *v0; // ebx\n  int v1; // edx\n  char v2; // al\n  int v3; // eax\n  int v4; // edx\n  _DWORD *v5; // ecx\n  int v6; // edx\n\n  v0 = (_DWORD *)*((_DWORD *)off_80DB55C + 7);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v1 = v0[3];\n  if ( v1 )\n  {\n    v2 = *(_BYTE *)(*((_DWORD *)off_80DB55C + 5) - 1);\n    if ( v2 == 32 || v2 == 9 )\n      byte_80DB76B |= 1u;\n    if ( v0[4] != *(_DWORD *)(v1 + 8) )\n      free((void *)v0[4]);\n    v3 = v0[3];\n    v4 = *(_DWORD *)(v3 + 12);\n    *(_DWORD *)(v3 + 12) = v4 & 0xFFFFFFFE;\n    if ( (v4 & 2) != 0 )\n      sub_806F626(*(const char **)(v3 + 4));\n  }\n  v5 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 5) = v0[1];\n  v5[3] = v0[2];\n  v5[18] = v0[7];\n  v6 = v0[6];\n  v5[16] = v0[5];\n  v5[17] = v6;\n  v5[7] = *v0;\n  if ( v0 != v5 + 8 )\n    free(v0);\n  return sub_806F4A5();\n}\n"
        ],
        "134674167": [
            "sub_806F6F7",
            "0x806f6f7",
            "char sub_806F6F7()\n{\n  void *v0; // ebx\n  char result; // al\n\n  v0 = off_80DB55C;\n  if ( off_80DB55C != &unk_80DB5E0 )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    if ( *((int *)v0 + 2) >= 0 )\n      close(*((_DWORD *)v0 + 2));\n    free(*((void **)v0 + 6));\n    while ( *((_DWORD *)v0 + 7) )\n      sub_806F659();\n    off_80DB55C = *(void **)v0;\n    free(v0);\n    return sub_806F4A5();\n  }\n  return result;\n}\n"
        ],
        "134674253": [
            "sub_806F74D",
            "0x806f74d",
            "char __usercall sub_806F74D@<al>(const char *a1@<eax>)\n{\n  _DWORD *v2; // ebx\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  sub_806EE0F();\n  v2 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 5) = a1;\n  v2[3] = strlen(a1);\n  v2[6] = 0;\n  v2[1] = 1;\n  return sub_806F4A5();\n}\n"
        ],
        "134674314": [
            "sub_806F78A",
            "0x806f78a",
            "char __usercall sub_806F78A@<al>(const char *a1@<eax>, int a2@<edx>)\n{\n  size_t v4; // edi\n  _DWORD *v5; // eax\n  _DWORD *v6; // edx\n  int v7; // ebx\n\n  v4 = strlen(a1);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v5 = (char *)off_80DB55C + 32;\n  if ( *((_DWORD *)off_80DB55C + 7) )\n  {\n    v5 = sub_804DB2E(0x20u);\n    *v5 = *((_DWORD *)off_80DB55C + 7);\n  }\n  v6 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 7) = v5;\n  v5[1] = v6[5];\n  v5[2] = v6[3];\n  v5[7] = v6[18];\n  v7 = v6[17];\n  v5[5] = v6[16];\n  v5[6] = v7;\n  v5[3] = a2;\n  if ( a2 )\n  {\n    *(_DWORD *)(a2 + 12) |= 1u;\n    v5[4] = a1;\n  }\n  v6[5] = a1;\n  v6[3] = v4;\n  v6[18] = 0;\n  return sub_806F4A5();\n}\n"
        ],
        "134674455": [
            "sub_806F817",
            "0x806f817",
            "char sub_806F817()\n{\n  int v0; // ebx\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v0 = *(_DWORD *)dword_80DB6AC;\n  *(_DWORD *)dword_80DB6AC = **(_DWORD **)dword_80DB6AC;\n  if ( *(_BYTE *)(v0 + 8) == 1 )\n    sub_806EEEB(*(_DWORD **)(v0 + 4));\n  free((void *)v0);\n  return sub_806F4A5();\n}\n"
        ],
        "134674507": [
            "sub_806F84B",
            "0x806f84b",
            "int sub_806F84B()\n{\n  void *v0; // ebx\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v0 = sub_804DB2E(8u);\n  *(_DWORD *)v0 = dword_80DB694;\n  dword_80DB694 = v0;\n  sub_806F4A5();\n  return *(_DWORD *)v0;\n}\n"
        ],
        "134674555": [
            "sub_806F87B",
            "0x806f87b",
            "char __usercall sub_806F87B@<al>(void *a1@<eax>, void *a2@<edx>, void *a3@<ecx>)\n{\n  void *v3; // esi\n  void **v6; // ebx\n\n  v3 = a1;\n  v6 = &ptr;\n  if ( dword_80DB6BC )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v6 = (void **)sub_804DB2E(0x10u);\n    *(_DWORD *)dword_80DB6BC = v6;\n    LOBYTE(a1) = sub_806F4A5();\n  }\n  dword_80DB6BC = (int)v6;\n  v6[1] = v3;\n  v6[2] = a2;\n  v6[3] = a3;\n  return (char)a1;\n}\n"
        ],
        "134674636": [
            "sub_806F8CC",
            "0x806f8cc",
            "char __usercall sub_806F8CC@<al>(int a1@<eax>)\n{\n  int v1; // ebx\n  void *v2; // esi\n  char v3; // dl\n  void **i; // eax\n  _DWORD *v5; // esi\n  int v6; // edi\n\n  if ( dword_80DB6BC )\n  {\n    v1 = a1;\n    if ( dword_80DB6C8 <= a1 )\n    {\n      dword_80DB6BC = (int)&ptr;\n      v3 = 0;\n      for ( i = &ptr; *i; i = (void **)*i )\n      {\n        if ( *((_DWORD *)*i + 1) >= v1 )\n        {\n          if ( v3 )\n            dword_80DB6BC = (int)i;\n          while ( 1 )\n          {\n            a1 = dword_80DB6BC;\n            if ( !*(_DWORD *)dword_80DB6BC )\n              break;\n            ++*(_DWORD *)(dword_80DBB8C + 36);\n            v5 = (_DWORD *)dword_80DB6BC;\n            v6 = **(_DWORD **)dword_80DB6BC;\n            free(*(void **)dword_80DB6BC);\n            *v5 = v6;\n            sub_806F4A5();\n          }\n          goto LABEL_19;\n        }\n        v3 = 1;\n      }\n      if ( v3 )\n        dword_80DB6BC = (int)i;\n      a1 = dword_80DB6BC;\nLABEL_19:\n      if ( *(_DWORD *)(a1 + 8) > v1 )\n        *(_DWORD *)(a1 + 8) = v1;\n    }\n    else\n    {\n      while ( ptr )\n      {\n        ++*(_DWORD *)(dword_80DBB8C + 36);\n        v2 = *(void **)ptr;\n        free(ptr);\n        ptr = v2;\n        LOBYTE(a1) = sub_806F4A5();\n      }\n      if ( dword_80DB6C4 <= v1 )\n      {\n        dword_80DB6BC = (int)&ptr;\n        dword_80DB6C8 = v1;\n      }\n      else\n      {\n        dword_80DB6BC = 0;\n      }\n    }\n  }\n  return a1;\n}\n"
        ],
        "134674871": [
            "sub_806F9B7",
            "0x806f9b7",
            "char __usercall sub_806F9B7@<al>(int a1@<eax>)\n{\n  int v2; // edi\n  int v3; // esi\n  int i; // ebp\n  void *v5; // eax\n\n  v2 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v3 = *(_DWORD *)(a1 + 20);\n  for ( i = *(_DWORD *)(a1 + 12); --v3 >= 0; i += 12 )\n  {\n    v5 = *(void **)(i + 8);\n    if ( v5 != (void *)(v2 + 44) )\n      free(v5);\n  }\n  if ( *(_DWORD *)(a1 + 12) != a1 )\n    free(*(void **)(a1 + 12));\n  *(_BYTE *)(a1 + 25) &= ~8u;\n  sub_806ED0E(a1, 2);\n  return sub_806F4A5();\n}\n"
        ],
        "134674960": [
            "sub_806FA10",
            "0x806fa10",
            "char __usercall sub_806FA10@<al>(_DWORD *a1@<eax>)\n{\n  _DWORD *v1; // ebx\n  int v2; // eax\n  _DWORD *v3; // edx\n  int v4; // edx\n  int v5; // ecx\n\n  if ( *a1 )\n  {\n    v1 = a1;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    while ( 1 )\n    {\n      v2 = dword_80DBB88;\n      v3 = *(_DWORD **)dword_80DBB88;\n      if ( *(_DWORD *)dword_80DBB88 == *v1 )\n        break;\n      *(_DWORD *)dword_80DBB88 = *v3;\n      free(v3);\n    }\n    v4 = v1[1];\n    *(_DWORD *)(dword_80DBB88 + 4) = v4;\n    v5 = v1[2];\n    *(_DWORD *)(v2 + 12) = v5;\n    *(_DWORD *)(v2 + 8) = v5 + v4;\n    LOBYTE(a1) = sub_806F4A5();\n  }\n  return (char)a1;\n}\n"
        ],
        "134675029": [
            "sub_806FA55",
            "0x806fa55",
            "int __usercall sub_806FA55@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  do\n    result = fcntl64(a1, 1030);\n  while ( result < 0 && (*(_DWORD *)dword_80DBB7C == 4 || *(_DWORD *)dword_80DBB7C == 16) );\n  return result;\n}\n"
        ],
        "134675078": [
            "sub_806FA86",
            "0x806fa86",
            "char __usercall sub_806FA86@<al>(FILE *a1@<eax>)\n{\n  char *IO_write_base; // eax\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  IO_write_base = a1->_IO_write_base;\n  if ( IO_write_base >= a1->_IO_buf_base )\n  {\n    __fputc_unlocked(10, a1);\n  }\n  else\n  {\n    a1->_IO_write_base = IO_write_base + 1;\n    *IO_write_base = 10;\n  }\n  fflush(a1);\n  return sub_806F4A5();\n}\n"
        ],
        "134675136": [
            "sub_806FAC0",
            "0x806fac0",
            "char __usercall sub_806FAC0@<al>(const char *a1@<eax>, void *a2@<edx>)\n{\n  int v4; // ebx\n  const char *v5; // esi\n\n  v4 = dword_80DBB8C;\n  fprintf(stderr, \"%s: \", *(const char **)(dword_80DBB8C + 28));\n  v5 = dword_80DB70C;\n  if ( dword_80DB70C )\n  {\n    if ( strcmp(*(const char **)(v4 + 28), dword_80DB70C) )\n      fprintf(stderr, \"%s: \", v5);\n    if ( !*(_BYTE *)(v4 + 48) || *((int *)off_80DB55C + 2) > 0 )\n      fprintf(stderr, \"line %d: \", *(_DWORD *)(v4 + 12));\n  }\n  vfprintf(stderr, a1, a2);\n  return sub_806FA86(stderr);\n}\n"
        ],
        "134675287": [
            "sub_806FB57",
            "0x806fb57",
            "void __noreturn sub_806FB57(const char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  *(_BYTE *)dword_80DBB8C = 2;\n  sub_806FAC0(a1, va);\n  sub_806F4BD();\n  sub_806F22F(1);\n}\n"
        ],
        "134675323": [
            "sub_806FB7B",
            "0x806fb7b",
            "_DWORD *__usercall sub_806FB7B@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // edi\n  _DWORD *v4; // eax\n  int v5; // ebx\n  int v6; // edx\n  _DWORD *v7; // ecx\n  _DWORD *v8; // ebp\n  const char *v9; // ebx\n  int v10; // eax\n  void (*v11)(void); // esi\n  char *v12; // edx\n  char v13; // al\n  unsigned int v14; // esi\n  _DWORD *v16; // [esp+0h] [ebp-14h]\n  _DWORD *v17; // [esp+0h] [ebp-14h]\n  _DWORD *v18; // [esp+0h] [ebp-14h]\n\n  v2 = (char *)a1;\n  v4 = (_DWORD *)sub_806ECAC(a1);\n  v5 = a2 | *(_BYTE *)(dword_80DBB8C + 55) & 1;\n  v7 = sub_806ECE9(v4, (int)v2);\n  v8 = (_DWORD *)*v7;\n  if ( !*v7 )\n  {\n    v14 = v5;\n    if ( (v5 & 0x80u) != 0 )\n      return v8;\n    if ( (v5 & 0x27) == 32 )\n      goto LABEL_17;\n    v18 = v7;\n    v8 = sub_804DB2E(0x10u);\n    *v8 = *v18;\n    *v18 = v8;\nLABEL_23:\n    if ( (v14 & 0x118) == 0 )\n      v2 = sub_804DB46(v2);\n    v8[2] = v2;\n    v8[1] = v14;\n    return v8;\n  }\n  if ( (v8[1] & 0x202) == 2 )\n  {\n    if ( (v5 & 0x100) != 0 )\n      free(v2);\n    v9 = (const char *)v8[2];\n    *(_BYTE *)dword_80DBB8C = 1;\n    v10 = strchrnul(v7, v6, v9, 61);\n    sub_806FB57(\"%.*s: is read only\", v10 - (_DWORD)v9, v9);\n  }\n  if ( (v5 & 0x80u) == 0 )\n  {\n    v11 = (void (*)(void))v8[3];\n    if ( v11 && (v5 & 0x40) == 0 )\n    {\n      v12 = v2;\n      do\n      {\n        v13 = *v12;\n        if ( !*v12 )\n          break;\n        ++v12;\n      }\n      while ( v13 != 61 );\n      v16 = v7;\n      v11();\n      v7 = v16;\n    }\n    if ( (v8[1] & 0x18) == 0 )\n    {\n      v17 = v7;\n      free((void *)v8[2]);\n      v7 = v17;\n    }\n    if ( (v8[1] & 4 | v5 & 0x27) == 32 )\n    {\n      *v7 = *v8;\n      free(v8);\nLABEL_17:\n      if ( (v5 & 0x118) == 256 )\n        free(v2);\n      return v8;\n    }\n    v14 = v5 | v8[1] & 0xFFFFFEC7;\n    goto LABEL_23;\n  }\n  return v8;\n}\n"
        ],
        "134675635": [
            "sub_806FCB3",
            "0x806fcb3",
            "char __usercall sub_806FCB3@<al>(int **a1@<eax>, int a2@<edx>)\n{\n  int **v2; // ebx\n\n  if ( a1 )\n  {\n    v2 = a1;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    do\n    {\n      sub_806FB7B((unsigned __int8 *)v2[1], a2);\n      v2 = (int **)*v2;\n    }\n    while ( v2 );\n    LOBYTE(a1) = sub_806F4A5();\n  }\n  return (char)a1;\n}\n"
        ],
        "134675682": [
            "sub_806FCE2",
            "0x806fce2",
            "_DWORD *__usercall sub_806FCE2@<eax>(int a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  __int64 v5; // rax\n  int v6; // edi\n  int v7; // ecx\n  int v8; // eax\n  int v9; // ebp\n  size_t v10; // ecx\n  unsigned __int8 *v11; // edi\n  _BYTE *v12; // eax\n  int v13; // edx\n  _DWORD *v16; // [esp+0h] [ebp-18h]\n  size_t v17; // [esp+4h] [ebp-14h]\n\n  v5 = sub_80AB128();\n  v6 = v5;\n  v8 = strchrnul(v7, HIDWORD(v5), v5, 61);\n  v9 = v8 - a1;\n  if ( v8 == a1 || v6 != v8 )\n    sub_806FB57(\"%.*s: bad variable name\", v8 - a1, a1);\n  if ( a2 )\n  {\n    v10 = strlen(a2);\n  }\n  else\n  {\n    a3 |= 0x20u;\n    v10 = 0;\n  }\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v17 = v10;\n  v11 = (unsigned __int8 *)sub_804DAFA(v10 + v9 + 2);\n  v12 = (_BYTE *)mempcpy(v11, a1, v9);\n  if ( a2 )\n  {\n    *v12 = 61;\n    v12 = (_BYTE *)mempcpy(v12 + 1, a2, v17);\n  }\n  *v12 = 0;\n  v13 = a3;\n  BYTE1(v13) = BYTE1(a3) | 1;\n  v16 = sub_806FB7B(v11, v13);\n  sub_806F4A5();\n  return v16;\n}\n"
        ],
        "134675965": [
            "sub_806FDFD",
            "0x806fdfd",
            "_DWORD *__usercall sub_806FDFD@<eax>(int a1@<eax>)\n{\n  return sub_806FCE2(a1, 0, 0);\n}\n"
        ],
        "134675974": [
            "sub_806FE06",
            "0x806fe06",
            "_DWORD *__usercall sub_806FE06@<eax>(int a1@<eax>, const char *a2@<edx>)\n{\n  return sub_806FCE2(a1, a2, 0);\n}\n"
        ],
        "134675981": [
            "sub_806FE0D",
            "0x806fe0d",
            "int __usercall sub_806FE0D@<eax>(char *a1@<eax>)\n{\n  if ( !sub_806EC60(a1) )\n    sub_806FB57(\"Illegal number: %s\", a1);\n  return atoi(a1);\n}\n"
        ],
        "134676068": [
            "sub_806FE64",
            "0x806fe64",
            "int __fastcall sub_806FE64(int a1, int a2)\n{\n  char *v2; // eax\n  int v3; // ebx\n  int v4; // esi\n  int result; // eax\n  void **v6; // eax\n  void **v7; // ebp\n  int v8; // edi\n  void **v9; // ebx\n  int v10; // ecx\n  int v11; // eax\n  void *v12; // edx\n  void **v13; // [esp+0h] [ebp-14h]\n\n  v2 = *(char **)(a2 + 4);\n  v3 = 1;\n  if ( v2 )\n    v3 = sub_806FE0D(v2);\n  v4 = dword_80DBB90;\n  result = 1;\n  if ( *(_DWORD *)dword_80DBB90 >= v3 )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    *(_DWORD *)v4 -= v3;\n    v6 = *(void ***)(v4 + 16);\n    v7 = v6;\n    v8 = v3;\n    while ( --v8 >= 0 )\n    {\n      if ( *(_BYTE *)(v4 + 12) )\n      {\n        v13 = v6;\n        free(*v7);\n        v6 = v13;\n      }\n      ++v7;\n    }\n    if ( v3 < 0 )\n      v3 = 0;\n    v9 = &v6[v3];\n    v10 = *(_DWORD *)(v4 + 16);\n    v11 = 0;\n    do\n    {\n      v12 = v9[v11];\n      *(_DWORD *)(v10 + v11 * 4) = v12;\n      ++v11;\n    }\n    while ( v12 );\n    *(_DWORD *)(v4 + 4) = 1;\n    *(_DWORD *)(v4 + 8) = -1;\n    sub_806F4A5();\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134676212": [
            "sub_806FEF4",
            "0x806fef4",
            "int __fastcall sub_806FEF4(int a1, int a2)\n{\n  char *v2; // eax\n\n  byte_80DB76C = 4;\n  v2 = *(char **)(a2 + 4);\n  if ( v2 )\n    return sub_806FE0D(v2);\n  else\n    return *(unsigned __int8 *)dword_80DBB8C;\n}\n"
        ],
        "134676240": [
            "sub_806FF10",
            "0x806ff10",
            "int __usercall sub_806FF10@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  result = a2;\n  if ( a1 != a2 )\n    result = dup2(a1, a2);\n  if ( result < 0 )\n    sub_806FB57(\"%d: %m\", a1);\n  return result;\n}\n"
        ],
        "134676275": [
            "sub_806FF33",
            "0x806ff33",
            "char __usercall sub_806FF33@<al>(int a1@<eax>, char a2@<dl>)\n{\n  int v2; // ebp\n  _DWORD *v4; // ebx\n  int i; // esi\n  int v6; // ecx\n  int v8; // [esp+0h] [ebp-14h]\n\n  v2 = dword_80DBB90;\n  if ( !*(_DWORD *)(dword_80DBB90 + 20) )\n    return a2;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v4 = *(_DWORD **)(v2 + 20);\n  for ( i = 0; v4[1] > i; ++i )\n  {\n    v6 = v4[2 * i + 3];\n    if ( v6 == -1 )\n    {\n      if ( !a1 )\n        close(v4[2 * i + 2]);\n    }\n    else if ( v6 != -2 )\n    {\n      if ( !a1 )\n      {\n        v8 = v4[2 * i + 3];\n        sub_806FF10(v8, v4[2 * i + 2]);\n        v6 = v8;\n      }\n      close(v6);\n    }\n  }\n  *(_DWORD *)(v2 + 20) = *v4;\n  free(v4);\n  return sub_806F4A5();\n}\n"
        ],
        "134676398": [
            "sub_806FFAE",
            "0x806ffae",
            "int __usercall sub_806FFAE@<eax>(int a1@<eax>, __pid_t a2@<edx>)\n{\n  int result; // eax\n\n  result = tcsetpgrp(a1, a2);\n  if ( result )\n    sub_806FB57(\"can't set tty process group: %m\");\n  return result;\n}\n"
        ],
        "134676422": [
            "sub_806FFC6",
            "0x806ffc6",
            "int __usercall sub_806FFC6@<eax>(int a1@<eax>)\n{\n  unsigned int v1; // esi\n  _DWORD *v2; // ebx\n  unsigned int v3; // edi\n  _DWORD *v4; // eax\n  int result; // eax\n\n  v1 = (a1 + 7) & 0xFFFFFFF8;\n  v2 = (_DWORD *)dword_80DBB88;\n  if ( *(_DWORD *)(dword_80DBB88 + 12) < v1 )\n  {\n    v3 = (a1 + 7) & 0xFFFFFFF8;\n    if ( v1 < 0x1F8 )\n      v3 = 504;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v4 = sub_804DAFA(v3 + 4);\n    *v4 = *v2;\n    v2[1] = v4 + 1;\n    v2[3] = v3;\n    v2[2] = (char *)v4 + v3 + 4;\n    *v2 = v4;\n    sub_806F4A5();\n  }\n  result = v2[1];\n  v2[1] = result + v1;\n  v2[3] -= v1;\n  return result;\n}\n"
        ],
        "134676535": [
            "sub_8070037",
            "0x8070037",
            "int __usercall sub_8070037@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  int v2; // ecx\n\n  v2 = dword_80DBB88;\n  *a1 = *(_DWORD *)dword_80DBB88;\n  a1[1] = *(_DWORD *)(v2 + 4);\n  a1[2] = *(_DWORD *)(v2 + 12);\n  return sub_806FFC6(a2);\n}\n"
        ],
        "134676566": [
            "sub_8070056",
            "0x8070056",
            "int __usercall sub_8070056@<eax>(_DWORD *a1@<eax>)\n{\n  int v1; // edx\n\n  v1 = 0;\n  if ( *(_DWORD *)(dword_80DBB88 + 4) == *(_DWORD *)dword_80DBB88 + 4 )\n    v1 = *(_DWORD *)dword_80DBB88 != dword_80DBB88 + 16;\n  return sub_8070037(a1, v1);\n}\n"
        ],
        "134676603": [
            "sub_807007B",
            "0x807007b",
            "char *__usercall sub_807007B@<eax>(const char *a1@<eax>)\n{\n  size_t v2; // ebx\n  char *result; // eax\n\n  v2 = strlen(a1) + 1;\n  result = (char *)sub_806FFC6(v2);\n  qmemcpy(result, a1, v2);\n  return result;\n}\n"
        ],
        "134676635": [
            "sub_807009B",
            "0x807009b",
            "int __usercall sub_807009B@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  _BYTE *v4; // esi\n  int v5; // eax\n  int v6; // ebx\n  int v7; // esi\n  _DWORD *v8; // ebx\n  _DWORD *v9; // eax\n\n  v4 = (_BYTE *)dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v5 = open64(a1);\n  v6 = v5;\n  if ( v5 < 0 )\n  {\n    if ( (a2 & 2) == 0 )\n    {\n      *v4 = 127;\n      sub_806FB57(\"can't open '%s': %m\", a1);\n    }\n    goto LABEL_16;\n  }\n  if ( v5 > 9 )\n  {\n    v7 = v5;\n    goto LABEL_11;\n  }\n  v7 = fcntl64(v5, 1030);\n  if ( v7 >= 0 )\n    goto LABEL_9;\n  if ( *(_DWORD *)dword_80DBB7C != 9 )\n  {\n    if ( *(_DWORD *)dword_80DBB7C )\n      sub_806FB57(\"%d: %m\", v6);\nLABEL_9:\n    close(v6);\n  }\nLABEL_11:\n  if ( (a2 & 1) != 0 )\n  {\n    sub_806EE0F();\n    *((_DWORD *)off_80DB55C + 6) = 0;\n  }\n  v8 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 2) = v7;\n  if ( !v8[6] )\n    v8[6] = sub_804DAFA(0x400u);\n  v9 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 4) = 0;\n  v9[3] = 0;\n  v9[1] = 1;\n  v6 = v7;\nLABEL_16:\n  sub_806F4A5();\n  return v6;\n}\n"
        ],
        "134676850": [
            "sub_8070172",
            "0x8070172",
            "void __usercall __noreturn sub_8070172(const char *a1@<eax>)\n{\n  *(_DWORD *)(dword_80DBB8C + 12) = *((_DWORD *)off_80DB55C + 1);\n  sub_806FB57(\"syntax error: %s\", a1);\n}\n"
        ],
        "134677054": [
            "sub_807023E",
            "0x807023e",
            "void __noreturn sub_807023E()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134677130": [
            "sub_807028A",
            "0x807028a",
            "void __noreturn sub_807028A()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134677282": [
            "sub_8070322",
            "0x8070322",
            "void __noreturn sub_8070322()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134677321": [
            "sub_8070349",
            "0x8070349",
            "int __usercall sub_8070349@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  char *v4; // edi\n  int v5; // eax\n  char v6; // bl\n  const char *v7; // ebx\n  unsigned int v8; // eax\n  void *v9; // edx\n  int v10; // ecx\n  _BYTE *v11; // eax\n  void *v14; // [esp+4h] [ebp-18h]\n  int v15; // [esp+8h] [ebp-14h]\n\n  v3 = dword_80DB6E0;\n  if ( !a1 )\n    goto LABEL_10;\n  if ( *a1 != 37 )\n    goto LABEL_28;\n  v4 = a1 + 1;\n  v5 = (unsigned __int8)a1[1];\n  v6 = v5;\n  if ( !v5 )\n    goto LABEL_10;\n  if ( a1[2] )\n    goto LABEL_11;\n  if ( v5 == 37 || v5 == 43 )\n  {\nLABEL_10:\n    v7 = \"No current job\";\n    goto LABEL_24;\n  }\n  if ( v5 == 45 )\n  {\n    if ( !dword_80DB6E0 )\n    {\n      v7 = \"No previous job\";\n      goto LABEL_30;\n    }\n    v3 = *(_DWORD *)(dword_80DB6E0 + 28);\n    v7 = \"No previous job\";\nLABEL_24:\n    if ( v3 )\n      goto LABEL_25;\nLABEL_30:\n    sub_806FB57(v7, a1);\n  }\nLABEL_11:\n  if ( !sub_806EC60(v4) || (v8 = atoi(v4)) == 0 || dword_80DB6E4 < v8 )\n  {\n    v9 = sub_806EC47;\n    if ( v6 == 63 )\n    {\n      v4 = a1 + 2;\n      v9 = strstr;\n    }\n    v10 = v3;\n    v7 = \"%s: no such job\";\n    v3 = 0;\n    while ( v10 )\n    {\n      v15 = v10;\n      v14 = v9;\n      v11 = ((_BYTE *(__cdecl *)(_BYTE *, char *))v9)(*(_BYTE **)(*(_DWORD *)(v10 + 12) + 8), v4);\n      v9 = v14;\n      if ( v11 )\n      {\n        if ( v3 )\n          goto LABEL_30;\n        v3 = v15;\n        v7 = \"%s: ambiguous\";\n      }\n      v10 = *(_DWORD *)(v15 + 28);\n    }\n    goto LABEL_24;\n  }\n  v3 = dword_80DB6E8 + 32 * (v8 + 0x7FFFFFF);\n  if ( (*(_BYTE *)(v3 + 25) & 8) == 0 )\nLABEL_28:\n    sub_806FB57(\"%s: no such job\", a1);\nLABEL_25:\n  if ( a2 && (*(_BYTE *)(v3 + 25) & 2) == 0 )\n    sub_806FB57(\"job %s not created under job control\", a1);\n  return v3;\n}\n"
        ],
        "134677601": [
            "sub_8070461",
            "0x8070461",
            "int __usercall sub_8070461@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // eax\n\n  do\n  {\n    v2 = fcntl64(a1, 1030);\n    if ( v2 >= 0 )\n    {\n      close(a1);\n      return v2;\n    }\n    v3 = *(_DWORD *)dword_80DBB7C;\n  }\n  while ( *(_DWORD *)dword_80DBB7C == 4 || v3 == 16 );\n  if ( v3 != 9 )\n    sub_806FB57(\"%d: %m\", v2);\n  return a1;\n}\n"
        ],
        "134677680": [
            "sub_80704B0",
            "0x80704b0",
            "int __fastcall sub_80704B0(int a1, _BYTE **a2)\n{\n  const char *v3; // ebx\n  int v4; // eax\n  int v5; // ecx\n\n  v3 = a2[1];\n  if ( v3 )\n  {\n    v4 = sub_806FE0D(a2[1]);\n    if ( v4 <= 0 )\n      sub_806FB57(\"Illegal number: %s\", v3);\n  }\n  else\n  {\n    v4 = 1;\n  }\n  v5 = dword_80DB69C;\n  if ( v4 <= dword_80DB69C )\n  {\n    v5 = v4;\nLABEL_9:\n    byte_80DB76C = (**a2 == 99) + 1;\n    dword_80DB6A0 = v5;\n    return 0;\n  }\n  if ( dword_80DB69C > 0 )\n    goto LABEL_9;\n  return 0;\n}\n"
        ],
        "134677761": [
            "sub_8070501",
            "0x8070501",
            "char sub_8070501(const char *a1, ...)\n{\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  return sub_806FAC0(a1, va);\n}\n"
        ],
        "134677775": [
            "sub_807050F",
            "0x807050f",
            "__pid_t __usercall sub_807050F@<eax>(__pid_t result@<eax>, __pid_t a2@<esi>)\n{\n  __pid_t v2; // edi\n  char v3; // si\n  int v4; // ebp\n  int v5; // ebx\n  int v6; // ebx\n  __pid_t v7; // edx\n  __pid_t v8; // eax\n  __pid_t v9; // esi\n\n  if ( byte_80DB76D != result )\n  {\n    v2 = *(_DWORD *)(dword_80DBB8C + 8);\n    if ( !v2 )\n    {\n      v3 = result;\n      if ( result )\n      {\n        v4 = open64(\"/dev/tty\");\n        v5 = v4;\n        if ( v4 < 0 )\n        {\n          v5 = 2;\n          while ( !isatty(v5) )\n          {\n            if ( --v5 == -1 )\n            {\n              v6 = -1;\n              goto LABEL_13;\n            }\n          }\n        }\n        v6 = fcntl64(v5, 1030);\n        if ( v4 >= 0 )\n          close(v4);\n        if ( v6 >= 0 )\n        {\n          while ( 1 )\n          {\n            v7 = tcgetpgrp(v6);\n            if ( v7 < 0 )\n              break;\n            a2 = v7;\n            v8 = getpgrp();\n            if ( v8 == a2 )\n            {\n              pgid = v8;\n              sub_806F2B1(20);\n              sub_806F2B1(22);\n              sub_806F2B1(21);\n              v2 = *(_DWORD *)(dword_80DBB8C + 4);\n              setpgid(0, v2);\n              sub_806FFAE(v6, v2);\n              LOBYTE(v2) = v3;\n              goto LABEL_21;\n            }\n            killpg(0, 21);\n          }\n        }\nLABEL_13:\n        sub_8070501(\"can't access tty; job control turned off\");\n        *(_BYTE *)(dword_80DBB8C + 49) = 0;\n      }\n      else\n      {\n        v6 = dword_80DB558;\n        v9 = pgid;\n        tcsetpgrp(dword_80DB558, pgid);\n        setpgid(0, v9);\n        sub_806F2B1(20);\n        sub_806F2B1(22);\n        sub_806F2B1(21);\n      }\n      if ( v6 >= 0 )\n        close(v6);\n      v6 = -1;\nLABEL_21:\n      dword_80DB558 = v6;\n      byte_80DB76D = v2;\n    }\n    return a2;\n  }\n  return result;\n}\n"
        ],
        "134678130": [
            "sub_8070672",
            "0x8070672",
            "int __usercall sub_8070672@<eax>(__pid_t a1@<esi>)\n{\n  int v1; // ebx\n  int result; // eax\n\n  v1 = dword_80DBB8C;\n  if ( *(unsigned __int8 *)(dword_80DBB8C + 48) + 1 != byte_80DB767 )\n  {\n    byte_80DB767 = *(_BYTE *)(dword_80DBB8C + 48) + 1;\n    sub_806F2B1(2);\n    sub_806F2B1(3);\n    sub_806F2B1(15);\n  }\n  sub_807050F(*(unsigned __int8 *)(v1 + 49), a1);\n  result = dword_80DB6F8;\n  if ( *(_BYTE *)(v1 + 58) )\n    *(_DWORD *)dword_80DB6F8 |= 8u;\n  else\n    *(_DWORD *)dword_80DB6F8 &= ~8u;\n  return result;\n}\n"
        ],
        "134678218": [
            "sub_80706CA",
            "0x80706ca",
            "char __usercall sub_80706CA@<al>(int a1@<eax>)\n{\n  char *v2; // edi\n  int v3; // esi\n  _DWORD *i; // ebp\n  int v5; // eax\n  _DWORD *v6; // ebp\n  void *v7; // eax\n  _DWORD *v8; // esi\n  _DWORD *v9; // eax\n  _DWORD *v10; // eax\n  int v11; // eax\n  _DWORD *v12; // eax\n\n  v2 = strchr((const char *)a1, 61);\n  v3 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  for ( i = (_DWORD *)*((_DWORD *)dword_80DB694 + 1); i; i = (_DWORD *)*i )\n  {\n    v5 = i[1];\n    if ( v5 && !sub_806EC79(*(_DWORD *)(v5 + 8), a1) )\n    {\n      if ( v2 )\n        sub_806FB7B((unsigned __int8 *)a1, 0);\n      return sub_806F4A5();\n    }\n  }\n  v6 = sub_804DB2E(0x10u);\n  if ( *(_BYTE *)a1 != 45 || *(_BYTE *)(a1 + 1) )\n  {\n    v9 = (_DWORD *)sub_806ECAC((unsigned __int8 *)a1);\n    v8 = (_DWORD *)*sub_806ECE9(v9, a1);\n    if ( v8 )\n    {\n      v6[3] = v8[2];\n      v11 = v8[1];\n      v6[2] = v11;\n      v8[1] = v11 | 0xC;\n      if ( v2 )\n        sub_806FB7B((unsigned __int8 *)a1, 0);\n      else\n        sub_806FE06(a1, 0);\n    }\n    else\n    {\n      if ( v2 )\n        v10 = sub_806FB7B((unsigned __int8 *)a1, 4);\n      else\n        v10 = sub_806FCE2(a1, 0, 4);\n      v8 = v10;\n      v6[2] = 32;\n    }\n  }\n  else\n  {\n    v7 = sub_804DAFA(0xFu);\n    qmemcpy(v7, (const void *)(v3 + 45), 0xFu);\n    v6[3] = v7;\n    v8 = 0;\n  }\n  v6[1] = v8;\n  v12 = dword_80DB694;\n  *v6 = *((_DWORD *)dword_80DB694 + 1);\n  v12[1] = v6;\n  return sub_806F4A5();\n}\n"
        ],
        "134678488": [
            "sub_80707D8",
            "0x80707d8",
            "int sub_80707D8()\n{\n  int v0; // ebx\n  int result; // eax\n\n  if ( !dword_80DB694 )\n    sub_806FB57(\"not in a function\");\n  v0 = dword_80DB708;\n  while ( 1 )\n  {\n    v0 += 4;\n    result = *(_DWORD *)(v0 - 4);\n    if ( !result )\n      break;\n    sub_80706CA(result);\n  }\n  return result;\n}\n"
        ],
        "134678533": [
            "sub_8070805",
            "0x8070805",
            "_DWORD *__usercall sub_8070805@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  char *v4; // ebx\n  char *v5; // eax\n  char *v6; // edi\n  char *v7; // eax\n  char *v9; // [esp+0h] [ebp-14h]\n\n  v3 = dword_80DBB8C;\n  v4 = *(char **)(dword_80DBB8C + 20);\n  if ( a2 )\n    sub_806FCE2((int)\"OLDPWD\", *(const char **)(dword_80DBB8C + 20), 1);\n  ++*(_DWORD *)(v3 + 36);\n  v5 = *(char **)(v3 + 24);\n  v6 = (char *)(v3 + 44);\n  if ( v5 != (char *)(v3 + 44) )\n  {\n    if ( v5 != v4 )\n      free(*(void **)(v3 + 24));\n    *(_DWORD *)(v3 + 24) = v6;\n  }\n  if ( a1 && v4 != a1 )\n  {\n    v7 = sub_804DB46(a1);\nLABEL_14:\n    if ( v7 != v4 )\n    {\n      if ( v6 != v4 )\n      {\n        v9 = v7;\n        free(v4);\n        v7 = v9;\n      }\n      v4 = v7;\n    }\n    goto LABEL_18;\n  }\n  v7 = getcwd(0, 0);\n  if ( !v7 )\n    v7 = (char *)(v3 + 44);\n  *(_DWORD *)(v3 + 24) = v7;\n  if ( !a1 )\n    goto LABEL_14;\nLABEL_18:\n  *(_DWORD *)(v3 + 20) = v4;\n  sub_806F4A5();\n  return sub_806FCE2(135071659, v4, 1);\n}\n"
        ],
        "134678695": [
            "sub_80708A7",
            "0x80708a7",
            "int sub_80708A7(char *format, ...)\n{\n  int v2; // [esp+0h] [ebp-4h]\n  va_list __varargs; // [esp+Ch] [ebp+8h] BYREF\n\n  va_start(__varargs, format);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v2 = vprintf(format, __varargs);\n  sub_806F4A5();\n  return v2;\n}\n"
        ],
        "134678740": [
            "sub_80708D4",
            "0x80708d4",
            "int __usercall sub_80708D4@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v2; // ebx\n  const char *v4; // edi\n  int v5; // eax\n  int v6; // ecx\n  _BYTE *v7; // edx\n  char v8; // al\n  char v9; // al\n  int v10; // esi\n  const char *v11; // edx\n  int v12; // ecx\n  int v13; // eax\n  char v14; // dl\n  char *v15; // ecx\n  int v16; // edx\n  const char *v18; // [esp+0h] [ebp-18h]\n  int i; // [esp+0h] [ebp-18h]\n  int v20; // [esp+4h] [ebp-14h]\n  char *v21; // [esp+4h] [ebp-14h]\n\n  v2 = a1;\n  if ( a1 )\n    *(_DWORD *)(dword_80DBB8C + 16) = 0;\nLABEL_13:\n  v6 = dword_80DB708;\n  v7 = *(_BYTE **)dword_80DB708;\n  if ( !*(_DWORD *)dword_80DB708 )\n    return 0;\n  v4 = v7 + 1;\n  v8 = *v7;\n  if ( ((*v7 - 43) & 0xFD) != 0 )\n    return 0;\n  dword_80DB708 += 4;\n  if ( v8 != 45 )\n  {\n    v10 = 0;\n    goto LABEL_5;\n  }\n  v9 = v7[1];\n  if ( !v9 )\n  {\n    if ( !v2 )\n    {\n      *(_WORD *)(dword_80DBB8C + 52) = 0;\n      return v2;\n    }\n    return 0;\n  }\n  if ( v9 != 45 || v7[2] )\n  {\n    v10 = 1;\n    while ( 1 )\n    {\nLABEL_5:\n      v5 = *(unsigned __int8 *)v4++;\n      if ( !*(v4 - 1) )\n        goto LABEL_13;\n      if ( v5 == 99 )\n      {\n        if ( !v2 )\n          goto LABEL_42;\n        *(_DWORD *)(dword_80DBB8C + 16) = v4;\n      }\n      else if ( v5 == 111 )\n      {\n        v11 = *(const char **)dword_80DB708;\n        if ( *(_DWORD *)dword_80DB708 )\n        {\n          v12 = 0;\n          do\n          {\n            v20 = v12;\n            v18 = v11;\n            v13 = strcmp(v11, off_80B5FE0[v12] + 1);\n            v11 = v18;\n            if ( !v13 )\n            {\n              *(_BYTE *)(dword_80DBB8C + v20 + 45) = v10;\n              goto LABEL_36;\n            }\n            v12 = v20 + 1;\n          }\n          while ( v20 != 14 );\n          sub_8070501(\"illegal option %co %s\", v10 == 0 ? 43 : 45, v18);\n          return 1;\n        }\n        for ( i = 0; i != 15; ++i )\n        {\n          v21 = off_80B5FE0[i];\n          v14 = *(_BYTE *)(dword_80DBB8C + i + 45);\n          if ( v10 )\n          {\n            v15 = \"can't access tty; job control turned off\" + 37;\n            if ( v14 )\n              v15 = \"on\";\n            sub_80708A7(\"%-16s%s\\n\", v21 + 1, v15);\n          }\n          else\n          {\n            sub_80708A7(\"set %co %s\\n\", v14 == 0 ? 43 : 45, v21 + 1);\n          }\n        }\nLABEL_36:\n        if ( *(_DWORD *)dword_80DB708 )\n          dword_80DB708 += 4;\n      }\n      else\n      {\n        if ( !v2 )\n          goto LABEL_42;\n        if ( v5 == 108 )\n        {\n          if ( a2 )\n            *a2 = 1;\n        }\n        else\n        {\n          if ( v5 == 45 && v10 )\n          {\n            if ( !strcmp(v4, \"login\") && a2 )\n              *a2 = 1;\n            goto LABEL_13;\n          }\nLABEL_42:\n          v16 = 0;\n          while ( v5 != (unsigned __int8)*off_80B5FE0[v16] )\n          {\n            if ( ++v16 == 15 )\n              sub_806FB57(\"illegal option %c%c\", v10 == 0 ? 43 : 45, *((unsigned __int8 *)v4 - 1));\n          }\n          *(_BYTE *)(dword_80DBB8C + v16 + 45) = v10;\n        }\n      }\n    }\n  }\n  if ( !v2 && !*(_DWORD *)(v6 + 4) )\n  {\n    sub_806F249((const char **)(v6 + 4));\n    return v2;\n  }\n  return 0;\n}\n"
        ],
        "134679343": [
            "sub_8070B2F",
            "0x8070b2f",
            "void __noreturn sub_8070B2F()\n{\n  sub_8070322();\n}\n"
        ],
        "134679401": [
            "sub_8070B69",
            "0x8070b69",
            "int sub_8070B69()\n{\n  int v0; // esi\n  unsigned int v1; // ebx\n\n  sub_80708A7(\"Built-in commands:\\n------------------\\n\");\n  v0 = 0;\n  v1 = 0;\n  do\n  {\n    v1 += sub_80708A7((char *)\"%c%s\", v1 == 0 ? 9 : 32, (&off_80B5D80)[2 * v0] + 1);\n    if ( v1 > 0x3C )\n    {\n      sub_80708A7((char *)\"\\n\");\n      v1 = 0;\n    }\n    ++v0;\n  }\n  while ( v0 != 44 );\n  sub_806FA86(stdout);\n  return 0;\n}\n"
        ],
        "134679495": [
            "sub_8070BC7",
            "0x8070bc7",
            "char __usercall sub_8070BC7@<al>(int a1@<eax>)\n{\n  FILE *v1; // ebx\n\n  v1 = stderr;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  fputs_unlocked(a1, v1);\n  sub_806F4A5();\n  return sub_806F4BD();\n}\n"
        ],
        "134679535": [
            "sub_8070BEF",
            "0x8070bef",
            "int sub_8070BEF()\n{\n  int v0; // ebx\n  int result; // eax\n\n  v0 = dword_80DBB8C;\n  result = 0;\n  if ( !*(_BYTE *)(dword_80DBB8C + 2) && dword_80DB6E0 && *(_BYTE *)(dword_80DB6E0 + 24) == 1 )\n  {\n    sub_8070BC7((int)\"You have stopped jobs.\\n\");\n    *(_BYTE *)(v0 + 2) = 2;\n    return 1;\n  }\n  return result;\n}\n"
        ],
        "134679587": [
            "sub_8070C23",
            "0x8070c23",
            "int __fastcall sub_8070C23(int a1, int a2)\n{\n  char *v3; // eax\n\n  if ( !sub_8070BEF() )\n  {\n    v3 = *(char **)(a2 + 4);\n    if ( v3 )\n      *(_BYTE *)dword_80DBB8C = sub_806FE0D(v3);\n    sub_806F22F(4);\n  }\n  return 0;\n}\n"
        ],
        "134679633": [
            "sub_8070C51",
            "0x8070c51",
            "void *__usercall sub_8070C51@<eax>(unsigned int a1@<eax>)\n{\n  void *v2; // edx\n\n  v2 = (void *)sub_806FFC6(a1);\n  memset(v2, 0, a1);\n  return v2;\n}\n"
        ],
        "134679657": [
            "sub_8070C69",
            "0x8070c69",
            "_DWORD *sub_8070C69()\n{\n  _DWORD *result; // eax\n\n  result = sub_8070C51(0x10u);\n  *(_BYTE *)result = 15;\n  result[2] = dword_80DB68C;\n  result[3] = dword_80DB688;\n  return result;\n}\n"
        ],
        "134679689": [
            "sub_8070C89",
            "0x8070c89",
            "int __usercall sub_8070C89@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v2; // ebx\n  int result; // eax\n\n  v2 = sub_8070C51(8u);\n  v2[1] = sub_807007B(a1);\n  result = dword_80DB6B8;\n  *(_DWORD *)dword_80DB6B8 = v2;\n  dword_80DB6B8 = (int)v2;\n  return result;\n}\n"
        ],
        "134679731": [
            "sub_8070CB3",
            "0x8070cb3",
            "void *__usercall sub_8070CB3@<eax>(const void *a1@<eax>)\n{\n  return bsearch(a1, &off_80B5D80, 0x2Cu, 8u, (__compar_fn_t)sub_806F10D);\n}\n"
        ],
        "134679755": [
            "sub_8070CCB",
            "0x8070ccb",
            "void *__usercall sub_8070CCB@<eax>(const void *a1@<eax>)\n{\n  return bsearch(a1, &off_80B5F14, 0x11u, 4u, (__compar_fn_t)sub_806F1A1);\n}\n"
        ],
        "134679779": [
            "sub_8070CE3",
            "0x8070ce3",
            "int sub_8070CE3(char *s, size_t maxlen, char *format, ...)\n{\n  int v4; // [esp+0h] [ebp-4h]\n  va_list __varargs; // [esp+14h] [ebp+10h] BYREF\n\n  va_start(__varargs, format);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v4 = vsnprintf(s, maxlen, format, __varargs);\n  sub_806F4A5();\n  return v4;\n}\n"
        ],
        "134679832": [
            "sub_8070D18",
            "0x8070d18",
            "int __usercall sub_8070D18@<eax>(char *a1@<eax>, __int16 a2@<dx>, int a3@<ecx>)\n{\n  int v4; // ebx\n  char *v5; // eax\n  int v6; // eax\n  int v7; // edx\n  char *v8; // eax\n  char v10; // [esp+0h] [ebp-Ch]\n\n  v4 = a2 & 0x7F;\n  if ( (a2 & 0x7F) != 0 )\n  {\n    if ( (_BYTE)a2 == 127 )\n    {\n      LOBYTE(v4) = HIBYTE(a2);\n      if ( !a3 )\n        goto LABEL_8;\n    }\n    else if ( !a3 || v4 != 13 && v4 != 2 )\n    {\nLABEL_8:\n      v10 = a2;\n      v5 = (char *)strsignal(v4 & 0x7F);\n      v6 = sub_8070CE3(a1, 0x20u, v5);\n      v4 = v6;\n      if ( v10 < 0 )\n      {\n        strcpy(&a1[v6], \" (core dumped)\");\n        v4 += 14;\n      }\n      return v4;\n    }\n    return 0;\n  }\n  if ( !a3 )\n  {\n    v7 = HIBYTE(a2);\n    v8 = \"Done\";\n    if ( v7 )\n      v8 = \"Done(%d)\";\n    return sub_8070CE3(a1, 0x10u, v8, v7);\n  }\n  return v4;\n}\n"
        ],
        "134679972": [
            "sub_8070DA4",
            "0x8070da4",
            "__pid_t __usercall sub_8070DA4@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // edi\n  __pid_t v3; // esi\n  int v4; // eax\n  int v5; // eax\n  int v6; // ebp\n  int v7; // edx\n  int v8; // ebx\n  int v9; // edi\n  int v10; // eax\n  _DWORD *v12; // [esp+0h] [ebp-54h]\n  _DWORD *v13; // [esp+4h] [ebp-50h]\n  int stat_loc; // [esp+Ch] [ebp-48h] BYREF\n  int v16[17]; // [esp+10h] [ebp-44h] BYREF\n\n  v2 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  if ( a1 == 2 )\n  {\n    while ( 1 )\n    {\n      *(_BYTE *)(v2 + 41) = 0;\n      v3 = waitpid(-1, &stat_loc, byte_80DB76D == 0 ? 1 : 3);\n      if ( v3 )\n        break;\n      v16[0] = -1;\n      v16[1] = -1;\n      sigprocmask(2, (const sigset_t *)v16, (sigset_t *)v16);\n      while ( !*(_BYTE *)(v2 + 41) && !*(_BYTE *)(v2 + 42) )\n        sigsuspend((const sigset_t *)v16);\n      sigprocmask(2, (const sigset_t *)v16, 0);\n      if ( !*(_BYTE *)(v2 + 41) )\n        goto LABEL_33;\n    }\n  }\n  else\n  {\n    v4 = a1 ^ 1;\n    if ( byte_80DB76D )\n      v4 |= 2u;\n    v3 = waitpid(-1, &stat_loc, v4);\n  }\n  if ( v3 > 0 )\n  {\n    v5 = dword_80DB6E0;\n    v6 = stat_loc;\n    while ( v5 )\n    {\n      if ( *(_BYTE *)(v5 + 24) != 2 )\n      {\n        v12 = *(_DWORD **)(v5 + 12);\n        v13 = &v12[3 * *(_DWORD *)(v5 + 20)];\n        v7 = 2;\n        v8 = 0;\n        do\n        {\n          if ( *v12 == v3 )\n          {\n            v12[1] = v6;\n            v8 = v5;\n          }\n          v9 = v12[1];\n          if ( v9 == -1 || !v7 )\n          {\n            v7 = 0;\n          }\n          else if ( (_BYTE)v9 == 127 )\n          {\n            *(_DWORD *)(v5 + 16) = v9;\n            v7 = 1;\n          }\n          v12 += 3;\n        }\n        while ( v13 > v12 );\n        if ( v8 )\n        {\n          if ( v7 )\n          {\n            *(_BYTE *)(v8 + 25) |= 0x10u;\n            if ( *(unsigned __int8 *)(v8 + 24) != v7 )\n            {\n              *(_BYTE *)(v8 + 24) = v7;\n              if ( v7 == 1 )\n                sub_806ED0E(v8, 0);\n            }\n          }\n          sub_806F4A5();\n          if ( v8 == a2 )\n          {\n            v10 = sub_8070D18((char *)v16, stat_loc, 1);\n            if ( v10 )\n            {\n              *((_BYTE *)v16 + v10) = 10;\n              *((_BYTE *)v16 + v10 + 1) = 0;\n              sub_8070BC7((int)v16);\n            }\n          }\n          return v3;\n        }\n      }\n      v5 = *(_DWORD *)(v5 + 28);\n    }\n    if ( (_BYTE)v6 != 127 )\n      --dword_80DB6DC;\n  }\nLABEL_33:\n  sub_806F4A5();\n  return v3;\n}\n"
        ],
        "134680391": [
            "sub_8070F47",
            "0x8070f47",
            "void __noreturn sub_8070F47()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134680596": [
            "sub_8071014",
            "0x8071014",
            "int __usercall sub_8071014@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // edi\n\n  v2 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  while ( !*(_BYTE *)(a1 + 24) )\n    sub_8070DA4(1, a1);\n  sub_806F4A5();\n  v3 = sub_806ED5D(a1);\n  if ( (*(_BYTE *)(a1 + 25) & 2) != 0 )\n  {\n    sub_806FFAE(dword_80DB558, *(_DWORD *)(v2 + 4));\n    if ( (*(_BYTE *)(a1 + 25) & 1) != 0 )\n      raise(2);\n  }\n  if ( *(_BYTE *)(a1 + 24) == 2 )\n    sub_806F9B7(a1);\n  return v3;\n}\n"
        ],
        "134680700": [
            "sub_807107C",
            "0x807107c",
            "char __usercall sub_807107C@<al>(int a1@<eax>, char *a2@<edx>)\n{\n  _DWORD *v3; // esi\n  char result; // al\n  int v5; // edi\n  char v6; // dl\n  char v7; // cl\n  int v8; // ecx\n  int v9; // edx\n  int v10; // eax\n  int v11; // eax\n  char *v12; // eax\n  const char *v13; // [esp-8h] [ebp-74h]\n  const char *v14; // [esp-4h] [ebp-70h]\n  int v15; // [esp+0h] [ebp-6Ch]\n  _DWORD *v16; // [esp+4h] [ebp-68h]\n  FILE *stream; // [esp+8h] [ebp-64h]\n  char *s; // [esp+Ch] [ebp-60h]\n  char dest[92]; // [esp+10h] [ebp-5Ch] BYREF\n\n  stream = stdout;\n  if ( ((unsigned __int8)a2 & 8) != 0 )\n    stream = stderr;\n  v3 = *(_DWORD **)(a1 + 12);\n  if ( ((unsigned __int8)a2 & 1) != 0 )\n    return fprintf(stream, \"%d\\n\", *v3);\n  s = a2;\n  v5 = sub_8070CE3(dest, 0x10u, \"[%d]   \", ((a1 - dword_80DB6E8) >> 5) + 1);\n  v6 = (char)s;\n  if ( dword_80DB6E0 == a1 )\n  {\n    dest[v5 - 3] = 43;\n  }\n  else if ( dword_80DB6E0 && *(_DWORD *)(dword_80DB6E0 + 28) == a1 )\n  {\n    dest[v5 - 3] = 45;\n  }\n  s = (char *)v5;\n  v15 = v6 & 2;\n  if ( (v6 & 2) != 0 )\n    s = (char *)(v5 + sub_8070CE3(&dest[v5], 0x10u, (char *)\"%d \", *v3));\n  v16 = &v3[3 * *(_DWORD *)(a1 + 20)];\n  v7 = *(_BYTE *)(a1 + 24);\n  if ( v7 )\n  {\n    v9 = *(v16 - 2);\n    if ( v7 == 1 )\n      v9 = *(_DWORD *)(a1 + 16);\n    v10 = sub_8070D18(&dest[(_DWORD)s], v9, 0);\n    v8 = (int)&s[v10];\n  }\n  else\n  {\n    strcpy(&dest[(_DWORD)s], \"Running\");\n    v8 = (int)(s + 7);\n  }\n  while ( 1 )\n  {\n    v12 = \"| \";\n    if ( *(_DWORD **)(a1 + 12) == v3 )\n      v12 = (char *)&data;\n    v14 = (const char *)v3[2];\n    v13 = v12;\n    v11 = 33 - v8;\n    if ( 33 - v8 < 0 )\n      v11 = 0;\n    s = dest;\n    fprintf(stream, \"%s%*c%s%s\", dest, v11, 32, v13, v14);\n    v3 += 3;\n    if ( v16 == v3 )\n      break;\n    dest[0] = 0;\n    v8 = 33;\n    if ( v15 )\n      v8 = sub_8070CE3(s, 0x30u, \"\\n%*c%d \", v5, 32, *v3) - 1;\n  }\n  result = sub_806FA86(stream);\n  *(_BYTE *)(a1 + 25) &= ~0x10u;\n  if ( *(_BYTE *)(a1 + 24) == 2 )\n    return sub_806F9B7(a1);\n  return result;\n}\n"
        ],
        "134681087": [
            "sub_80711FF",
            "0x80711ff",
            "char __usercall sub_80711FF@<al>(char *a1@<eax>)\n{\n  __pid_t v2; // eax\n  int i; // ebx\n\n  do\n    v2 = sub_8070DA4(0, 0);\n  while ( v2 > 0 );\n  for ( i = dword_80DB6E0; i; i = *(_DWORD *)(i + 28) )\n  {\n    if ( ((unsigned __int8)a1 & 4) == 0 || (*(_BYTE *)(i + 25) & 0x10) != 0 )\n      LOBYTE(v2) = sub_807107C(i, a1);\n  }\n  return v2;\n}\n"
        ],
        "134681145": [
            "sub_8071239",
            "0x8071239",
            "void __noreturn sub_8071239()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134681227": [
            "sub_807128B",
            "0x807128b",
            "void __noreturn sub_807128B()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134681479": [
            "sub_8071387",
            "0x8071387",
            "int sub_8071387()\n{\n  return sub_80795F7();\n}\n"
        ],
        "134681575": [
            "sub_80713E7",
            "0x80713e7",
            "char *__cdecl sub_80713E7(unsigned int a1, const char *a2, char *name, char *pattern, int a5, int a6)\n{\n  char *v7; // ebx\n  int v8; // ebp\n  char v9; // dl\n  const char *v10; // eax\n  int v11; // eax\n  char *v12; // ecx\n  char *v13; // edx\n  int v14; // eax\n  char v16; // [esp+1h] [ebp-11h]\n\n  v7 = pattern - 1;\n  v8 = 0;\n  while ( (unsigned int)v7 >= a1 )\n  {\n    v9 = *name;\n    v10 = name;\n    if ( a6 )\n    {\n      *name = 0;\n      v10 = a2;\n    }\n    v16 = v9;\n    v11 = fnmatch(pattern, v10, 0);\n    *name = v16;\n    if ( !v11 )\n      return v7;\n    v12 = v7 - 1;\n    if ( a5 )\n    {\n      if ( --v8 < 0 )\n      {\n        v13 = v7 - 1;\n        do\n        {\n          v14 = v12 - v13;\n          if ( a1 >= (unsigned int)v13 )\n            break;\n          --v13;\n        }\n        while ( *v13 == -127 );\n        v8 = v14;\n      }\n      if ( (v8 & 1) != 0 )\n      {\n        --v8;\n        v12 = v7 - 2;\n      }\n    }\n    --name;\n    v7 = v12;\n  }\n  return 0;\n}\n"
        ],
        "134681709": [
            "sub_807146D",
            "0x807146d",
            "__int64 sub_807146D()\n{\n  __int64 v0; // rax\n  __int64 v2; // [esp+0h] [ebp-20h]\n  const char *v3; // [esp+8h] [ebp-18h]\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  LODWORD(v0) = sub_8078F92();\n  if ( v3 )\n    sub_806FB57(v3);\n  v2 = v0;\n  sub_806F4A5();\n  return v2;\n}\n"
        ],
        "134681791": [
            "sub_80714BF",
            "0x80714bf",
            "int sub_80714BF()\n{\n  __int64 v0; // rax\n\n  v0 = sub_807146D();\n  if ( v0 < (__int64)0xFFFFFFFF80000000LL )\n    v0 = 0xFFFFFFFF80000000LL;\n  if ( v0 > 0x7FFFFFFF )\n    LODWORD(v0) = 0x7FFFFFFF;\n  return v0;\n}\n"
        ],
        "134681838": [
            "sub_80714EE",
            "0x80714ee",
            "_BOOL4 __fastcall sub_80714EE(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  __int64 v3; // rax\n\n  if ( !*(_DWORD *)(a2 + 4) )\n    sub_806FB57(\"expression expected\");\n  v2 = (_DWORD *)(a2 + 4);\n  do\n  {\n    v3 = sub_807146D();\n    ++v2;\n  }\n  while ( *v2 );\n  return v3 == 0;\n}\n"
        ],
        "134681883": [
            "sub_807151B",
            "0x807151b",
            "int __usercall sub_807151B@<eax>(int a1@<eax>)\n{\n  int v1; // eax\n  int v2; // ebx\n  int i; // ebp\n  int v4; // esi\n  char *v5; // eax\n  char *v6; // ebp\n  char *v7; // edi\n  char *v8; // edx\n  int v9; // ecx\n  int v10; // esi\n\n  v1 = dword_80DB6E4;\n  v2 = dword_80DB6E8;\n  for ( i = dword_80DB6E8; --v1 >= 0; i += 32 )\n  {\n    if ( (*(_BYTE *)(i + 25) & 8) == 0 )\n      goto LABEL_19;\n    if ( (*(_DWORD *)(i + 24) & 0x4FF) == 1026 && !byte_80DB76D )\n    {\n      sub_806F9B7(i);\n      goto LABEL_19;\n    }\n  }\n  v4 = 32 * dword_80DB6E4;\n  v5 = (char *)sub_804DB13((void *)dword_80DB6E8, 32 * dword_80DB6E4 + 128);\n  v6 = &v5[-v2];\n  v7 = &v5[v4];\n  if ( v5 != (char *)v2 )\n  {\n    v8 = &v5[v4];\n    v9 = v4;\n    while ( v9 )\n    {\n      v9 -= 32;\n      if ( *((_DWORD *)v8 - 5) == v2 + v9 )\n        *((_DWORD *)v8 - 5) = &v5[v9];\n      v10 = *((_DWORD *)v8 - 1);\n      if ( v10 )\n        *((_DWORD *)v8 - 1) = &v6[v10];\n      v8 -= 32;\n    }\n    if ( dword_80DB6E0 )\n      dword_80DB6E0 += (int)v6;\n  }\n  dword_80DB6E4 += 4;\n  dword_80DB6E8 = (int)v5;\n  i = (int)v7;\n  v7[121] &= ~8u;\n  v7[89] &= ~8u;\n  v7[57] &= ~8u;\n  v7[25] &= ~8u;\nLABEL_19:\n  memset((void *)i, 0, 0x20u);\n  if ( byte_80DB76D )\n    *(_BYTE *)(i + 25) |= 2u;\n  *(_DWORD *)(i + 28) = dword_80DB6E0;\n  dword_80DB6E0 = i;\n  *(_BYTE *)(i + 25) |= 8u;\n  *(_DWORD *)(i + 12) = i;\n  if ( a1 > 1 )\n    *(_DWORD *)(i + 12) = sub_804DAFA(12 * a1);\n  return i;\n}\n"
        ],
        "134682147": [
            "sub_8071623",
            "0x8071623",
            "char sub_8071623()\n{\n  int v0; // ebx\n  unsigned int v1; // ecx\n  unsigned int v2; // ebp\n  const void *v3; // esi\n  int v4; // esi\n  _DWORD *v5; // eax\n  void *v7; // eax\n  unsigned int v8; // [esp+0h] [ebp-14h]\n\n  v0 = dword_80DBB88;\n  v1 = *(_DWORD *)(dword_80DBB88 + 12);\n  v2 = 2 * v1;\n  if ( v1 > 2 * v1 )\n    sub_806FB57(\"out of memory\");\n  if ( v2 <= 0x7F )\n    v2 += 128;\n  v3 = *(const void **)(dword_80DBB88 + 4);\n  if ( v3 != (const void *)(*(_DWORD *)dword_80DBB88 + 4) || *(_DWORD *)dword_80DBB88 == dword_80DBB88 + 16 )\n  {\n    v8 = *(_DWORD *)(dword_80DBB88 + 12);\n    v7 = (void *)sub_806FFC6(v2);\n    qmemcpy(v7, v3, v8);\n    *(_DWORD *)(v0 + 4) = v7;\n    *(_DWORD *)(v0 + 12) += v2;\n    return v8;\n  }\n  else\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v4 = **(_DWORD **)v0;\n    v5 = sub_804DB13(*(void **)v0, v2 + 4);\n    *v5 = v4;\n    *(_DWORD *)v0 = v5++;\n    *(_DWORD *)(v0 + 4) = v5;\n    *(_DWORD *)(v0 + 12) = v2;\n    *(_DWORD *)(v0 + 8) = (char *)v5 + v2;\n    return sub_806F4A5();\n  }\n}\n"
        ],
        "134682287": [
            "sub_80716AF",
            "0x80716af",
            "int __usercall sub_80716AF@<eax>(unsigned int a1@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  int v4; // ebx\n\n  v3 = dword_80DBB88;\n  v4 = a2 - *(_DWORD *)(dword_80DBB88 + 4);\n  while ( *(_DWORD *)(v3 + 12) - v4 < a1 )\n    sub_8071623();\n  return v4 + *(_DWORD *)(v3 + 4);\n}\n"
        ],
        "134682328": [
            "sub_80716D8",
            "0x80716d8",
            "int __usercall sub_80716D8@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)\n{\n  _BYTE *v3; // edx\n  _BYTE *v4; // ebp\n  _BYTE *v5; // eax\n  _BYTE *v6; // eax\n  int i; // ebx\n  _BYTE *v8; // eax\n  _BYTE *v9; // eax\n  int v11; // [esp+0h] [ebp-14h]\n\n  v3 = *(_BYTE **)(dword_80DBB88 + 4);\n  do\n  {\n    v11 = (int)v3;\n    v4 = (_BYTE *)strchrnul(a2, v3, a1, 39);\n    v5 = (_BYTE *)sub_80716AF(v4 - a1 + 3, v11);\n    *v5 = 39;\n    v6 = (_BYTE *)mempcpy(v5 + 1, a1, v4 - a1);\n    v3 = v6 + 1;\n    *v6 = 39;\n    if ( *v4 != 39 )\n      break;\n    for ( i = 0; ; ++i )\n    {\n      a1 = &v4[i + 1];\n      if ( v4[i + 1] != 39 )\n        break;\n    }\n    v8 = (_BYTE *)sub_80716AF(i + 4, (int)v3);\n    *v8 = 34;\n    v9 = (_BYTE *)mempcpy(v8 + 1, &a1[~i], i + 1);\n    v3 = v9 + 1;\n    *v9 = 34;\n  }\n  while ( *a1 );\n  *v3 = 0;\n  return *(_DWORD *)(dword_80DBB88 + 4);\n}\n"
        ],
        "134682479": [
            "sub_807176F",
            "0x807176f",
            "int __usercall sub_807176F@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  const char *v3; // eax\n\n  v3 = (const char *)sub_80716D8(*(_BYTE **)(a1 + 8), a2);\n  return sub_80708A7(\"%s=%s\\n\", *(const char **)(a1 + 4), v3);\n}\n"
        ],
        "134682509": [
            "sub_807178D",
            "0x807178d",
            "int __fastcall sub_807178D(int a1, int a2)\n{\n  int i; // ebx\n  _DWORD *j; // esi\n  int v4; // edi\n  const char **v5; // esi\n  const char *v6; // ebx\n  char *v7; // eax\n  int v8; // eax\n  int v9; // ecx\n  int *v10; // ecx\n  int v11; // ebp\n  _DWORD *v12; // ebp\n  const char *v14; // [esp+0h] [ebp-18h]\n  int *v15; // [esp+4h] [ebp-14h]\n\n  if ( *(_DWORD *)(a2 + 4) )\n  {\n    v5 = (const char **)a2;\n    v4 = 0;\n    while ( 1 )\n    {\n      v6 = *++v5;\n      if ( !*v5 )\n        break;\n      v7 = strchr(v6 + 1, 61);\n      if ( v7 )\n      {\n        v14 = v7 + 1;\n        *v7 = 0;\n        v10 = sub_806F0C2(v6);\n        v11 = *v10;\n        ++*(_DWORD *)(dword_80DBB8C + 36);\n        if ( v11 )\n        {\n          if ( (*(_BYTE *)(v11 + 12) & 1) == 0 )\n            free(*(void **)(v11 + 8));\n          *(_DWORD *)(v11 + 8) = sub_804DB46(v14);\n          *(_DWORD *)(v11 + 12) &= ~2u;\n        }\n        else\n        {\n          v15 = v10;\n          v12 = sub_804DB2E(0x10u);\n          v12[1] = sub_804DB46(v6);\n          v12[2] = sub_804DB46(v14);\n          *v15 = (int)v12;\n        }\n        sub_806F4A5();\n      }\n      else\n      {\n        v8 = *sub_806F0C2(v6);\n        if ( v8 )\n        {\n          sub_807176F(v8, v9);\n        }\n        else\n        {\n          fprintf(stderr, \"%s: %s not found\\n\", \"alias\", v6);\n          v4 = 1;\n        }\n      }\n    }\n  }\n  else\n  {\n    for ( i = 0; i != 156; i += 4 )\n    {\n      for ( j = *(_DWORD **)(dword_80DB6F0 + i); j; j = (_DWORD *)*j )\n        sub_807176F((int)j, a1);\n    }\n    return 0;\n  }\n  return v4;\n}\n"
        ],
        "134682783": [
            "sub_807189F",
            "0x807189f",
            "_BYTE *__usercall sub_807189F@<eax>(_BYTE *result@<eax>, int a2@<edx>)\n{\n  _BYTE *i; // esi\n  int v3; // ecx\n\n  for ( i = result; ; ++i )\n  {\n    LOBYTE(a2) = *i;\n    if ( !*i )\n      break;\n    v3 = a2 - 43;\n    if ( (unsigned __int8)(a2 - 43) <= 0x4Fu )\n    {\n      v3 = a2 - 59;\n      LOBYTE(v3) = (_BYTE)a2 == 96;\n      if ( (_BYTE)a2 != 96 && (unsigned __int8)(a2 - 59) > 4u )\n      {\n        a2 -= 91;\n        if ( (unsigned __int8)a2 > 1u )\n          continue;\n      }\n    }\n    return (_BYTE *)sub_80716D8(result, v3);\n  }\n  return result;\n}\n"
        ],
        "134682841": [
            "sub_80718D9",
            "0x80718d9",
            "int __usercall sub_80718D9@<eax>(int result@<eax>, unsigned int a2@<edx>, int a3@<ecx>, char a4)\n{\n  _BYTE *v4; // ebx\n  unsigned int v7; // eax\n  int v8; // ecx\n  _BYTE *v9; // ebp\n  _BYTE *v10; // [esp+4h] [ebp-18h]\n  char v11; // [esp+Bh] [ebp-11h]\n\n  if ( a2 )\n  {\n    v4 = (_BYTE *)result;\n    v7 = a2;\n    if ( (a4 & 0x11) != 0 )\n      v7 = 2 * a2;\n    v9 = (_BYTE *)sub_80716AF(v7, dword_80DB6D4);\n    result = (int)&v4[a2];\n    v10 = &v4[a2];\n    while ( 1 )\n    {\n      LOBYTE(v8) = *v4++;\n      if ( (_BYTE)v8 )\n        break;\n      if ( (a4 & 2) != 0 )\n        goto LABEL_12;\nLABEL_13:\n      if ( v4 == v10 )\n      {\n        dword_80DB6D4 = (int)v9;\n        return result;\n      }\n    }\n    if ( (a4 & 0x11) != 0 )\n    {\n      v11 = *(v4 - 1);\n      result = sub_806EEFB((unsigned __int8)v8, a3, v8);\n      LOBYTE(v8) = v11;\n      if ( result == 12 || a3 | a4 & 1 && result == 2 )\n        *v9++ = -127;\n    }\nLABEL_12:\n    *v9++ = v8;\n    goto LABEL_13;\n  }\n  return result;\n}\n"
        ],
        "134682993": [
            "sub_8071971",
            "0x8071971",
            "int __usercall sub_8071971@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  unsigned int v3; // esi\n  int v4; // eax\n\n  v3 = strlen(a1);\n  v4 = sub_80716AF(v3, a2);\n  return mempcpy(v4, a1, v3);\n}\n"
        ],
        "134683032": [
            "sub_8071998",
            "0x8071998",
            "int __usercall sub_8071998@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>)\n{\n  int result; // eax\n\n  dword_80DB6D4 = sub_80716AF(0x18u, dword_80DB6D4);\n  result = sub_8070CE3((char *)dword_80DB6D4, 0x18u, \"%lld\", __PAIR64__(a2, a1));\n  dword_80DB6D4 += result;\n  return result;\n}\n"
        ],
        "134683086": [
            "sub_80719CE",
            "0x80719ce",
            "const char *__usercall sub_80719CE@<eax>(const char *a1@<eax>, char a2@<dl>, _DWORD *a3@<ecx>)\n{\n  const char *v5; // eax\n  char *v6; // eax\n  char *v7; // ebp\n  int v8; // edi\n  size_t v9; // eax\n  const char *v10; // ebp\n  const char *v11; // eax\n  int v12; // esi\n  int v13; // edi\n  char v14; // dl\n  int v15; // ecx\n  char v16; // cl\n  bool v17; // dl\n  unsigned __int8 v18; // cl\n  bool v19; // si\n  const char *v21; // [esp+0h] [ebp-24h]\n  char *v22; // [esp+4h] [ebp-20h]\n  _DWORD *v23; // [esp+8h] [ebp-1Ch]\n  int v24; // [esp+Ch] [ebp-18h]\n  int v25; // [esp+10h] [ebp-14h]\n\n  v23 = a3;\n  v5 = &byte_80D0D10;\n  if ( a3 )\n    v5 = (const char *)&unk_80D0D0F;\n  v6 = strpbrk(a1, v5);\n  v7 = v6;\n  if ( v6 )\n  {\n    v24 = a2 & 8;\n    if ( (a2 & 1) != 0 )\n    {\n      v8 = v6 - a1;\n      v9 = strlen(v6) + v6 - a1 + 1;\n      if ( (a2 & 8) != 0 )\n      {\n        v10 = &a1[-*(_DWORD *)(dword_80DBB88 + 4)];\n        a1 = (const char *)sub_80716AF(v9, dword_80DB6D4);\n        v21 = &v10[*(_DWORD *)(dword_80DBB88 + 4)];\n        v7 = (char *)&v21[v8];\n      }\n      else\n      {\n        if ( (a2 & 0x10) != 0 )\n          v11 = (const char *)sub_804DAFA(v9);\n        else\n          v11 = (const char *)sub_806FFC6(v9);\n        v21 = a1;\n        a1 = v11;\n      }\n      v6 = (char *)a1;\n      if ( v8 )\n        v6 = (char *)mempcpy(a1, v21, v8);\n    }\n    else\n    {\n      v21 = a1;\n    }\n    v12 = a2 & 2;\n    v13 = v12;\n    while ( 1 )\n    {\n      v14 = *v7;\n      if ( !*v7 )\n        break;\n      v22 = v7 + 1;\n      v25 = v13;\n      if ( v14 != -120 )\n      {\n        v15 = 0;\n        if ( v14 != 92 )\n        {\n          if ( v14 == -127 )\n          {\n            v16 = v7[1];\n            if ( !v12 )\n              goto LABEL_28;\n            v17 = (unsigned __int8)(v16 - 91) <= 3u;\n            v18 = v16 - 33;\n            v19 = 1;\n            if ( v18 <= 0x1Eu )\n              v19 = ((0x40001201u >> v18) & 1) == 0;\n            if ( !v19 || v17 )\n            {\n              *v6 = 92;\n              v15 = v13;\n              ++v6;\n            }\n            else\n            {\nLABEL_28:\n              v15 = v13;\n            }\n            ++v7;\n          }\n          else\n          {\n            v15 = v13;\n            if ( v23 && v7 == &v21[*v23] )\n            {\n              *v23 = v6 - a1;\n              v13 = 0;\n              v15 = 0;\n              v23 = 0;\n            }\n          }\n        }\n        v22 = v7 + 1;\n        *v6 = *v7;\n        v25 = v13;\n        v13 = v15;\n        ++v6;\n      }\n      v12 = v13;\n      v13 = v25;\n      v7 = v22;\n    }\n    *v6 = 0;\n    if ( v24 )\n      dword_80DB6D4 = (int)(v6 + 1);\n  }\n  return a1;\n}\n"
        ],
        "134683485": [
            "sub_8071B5D",
            "0x8071b5d",
            "int __usercall sub_8071B5D@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // esi\n  size_t v3; // eax\n  char *v4; // eax\n  int v5; // ebx\n  char v6; // di\n  char *v7; // ebp\n  char v8; // cl\n  bool v9; // zf\n  char *v10; // edx\n  char *i; // esi\n  char v12; // al\n  int v14; // [esp-2h] [ebp-14h] BYREF\n\n  v14 = a2;\n  v2 = (char *)a1;\n  HIBYTE(v14) = 0;\n  v3 = strlen(a1);\n  v4 = (char *)sub_80716AF(8 * v3 + 8, dword_80DB6D8);\n  v5 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    v7 = v2 + 1;\n    v8 = *v2;\n    if ( !*v2 )\n      break;\n    if ( v8 == -127 )\n    {\n      v7 = v2 + 2;\n      v8 = v2[1];\n      goto LABEL_35;\n    }\n    if ( (unsigned __int8)v8 > 0x81u )\n    {\n      if ( v8 == -124 )\n      {\n        v10 = \"$(...)\";\n      }\n      else if ( (unsigned __int8)v8 > 0x84u )\n      {\n        if ( v8 == -121 )\n        {\n          v10 = \"))\";\n        }\n        else\n        {\n          if ( v8 == -120 )\n          {\n            v5 ^= 1u;\n            v8 = 34;\n            goto LABEL_35;\n          }\n          v10 = \"$((\";\n          if ( v8 != -122 )\n            goto LABEL_35;\n        }\n      }\n      else if ( v8 == -126 )\n      {\n        v7 = v2 + 2;\n        v6 = v2[1];\n        v10 = \"${#\";\n        if ( (v6 & 0xF) != 10 )\n          v10 = \"${\";\n      }\n      else\n      {\n        v10 = \"}\";\n        if ( (v5 & 1) != 0 )\n          v10 = \"\\\"}\";\n        v5 >>= 1;\n        v6 = 0;\n      }\n    }\n    else\n    {\n      if ( v8 == 39 )\n        goto LABEL_34;\n      if ( (unsigned __int8)v8 <= 0x27u )\n      {\n        if ( v8 != 34 )\n        {\n          v9 = v8 == 36;\n          goto LABEL_11;\n        }\n        goto LABEL_34;\n      }\n      if ( v8 != 61 )\n      {\n        v9 = v8 == 92;\nLABEL_11:\n        if ( v9 )\n        {\nLABEL_34:\n          BYTE2(v14) = *v2;\n          v8 = 92;\n          v10 = (char *)&v14 + 2;\n        }\n        else\n        {\nLABEL_35:\n          v10 = 0;\n        }\nLABEL_36:\n        i = v4 + 1;\n        *v4++ = v8;\n        if ( !v10 )\n          goto LABEL_42;\n        goto LABEL_39;\n      }\n      if ( !v6 )\n        goto LABEL_35;\n      if ( (v6 & 0xF) != 1 )\n        v5 *= 2;\n      v10 = (char *)(3 * (v6 & 0xF) + 134962496);\n      if ( (v6 & 0x10) != 0 )\n      {\n        v8 = 58;\n        goto LABEL_36;\n      }\n    }\nLABEL_39:\n    for ( i = v4; ; *(i - 1) = v12 )\n    {\n      v12 = *v10++;\n      if ( !v12 )\n        break;\n      ++i;\n    }\nLABEL_42:\n    v4 = i;\n    v2 = v7;\n  }\n  if ( (v5 & 1) != 0 )\n    *v4++ = 34;\n  *v4 = 0;\n  dword_80DB6D8 = (int)v4;\n  return v14;\n}\n"
        ],
        "134683838": [
            "sub_8071CBE",
            "0x8071cbe",
            "int sub_8071CBE()\n{\n  int v0; // esi\n  int v1; // ebx\n\n  v0 = dword_80DBB88;\n  v1 = *(_DWORD *)(dword_80DBB88 + 12);\n  sub_8071623();\n  return v1 + *(_DWORD *)(v0 + 4);\n}\n"
        ],
        "134683862": [
            "sub_8071CD6",
            "0x8071cd6",
            "_BYTE *__usercall sub_8071CD6@<eax>(char a1@<al>, _BYTE *a2@<edx>)\n{\n  _BYTE *v3; // eax\n\n  v3 = a2;\n  if ( *(_BYTE **)(dword_80DBB88 + 8) == a2 )\n    v3 = (_BYTE *)sub_8071CBE();\n  *v3 = a1;\n  return v3 + 1;\n}\n"
        ],
        "134683888": [
            "sub_8071CF0",
            "0x8071cf0",
            "int __usercall sub_8071CF0@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3@<ecx>)\n{\n  _DWORD *v5; // eax\n  _DWORD *v6; // esi\n  _DWORD *i; // ebx\n  _DWORD *v8; // edx\n  int v10; // [esp+0h] [ebp-14h]\n\n  v5 = *(_DWORD **)(dword_80DBB88 + 4);\n  v6 = (_DWORD *)(dword_80DBB90 + 28);\n  v10 = a1 | a2;\n  do\n  {\n    for ( i = (_DWORD *)*v6; ; i = (_DWORD *)*i )\n    {\n      v8 = *(_DWORD **)(dword_80DBB88 + 8);\n      if ( !i )\n        break;\n      if ( (i[1] & v10) == a1 )\n      {\n        if ( v5 == v8 )\n          v5 = (_DWORD *)sub_8071CBE();\n        *v5++ = i[2];\n      }\n    }\n    ++v6;\n  }\n  while ( (unsigned int)v6 < dword_80DBB90 + 184 );\n  if ( v5 == v8 )\n    v5 = (_DWORD *)sub_8071CBE();\n  if ( a3 )\n    *a3 = v5;\n  *v5 = 0;\n  return sub_806FFC6((int)v5 - *(_DWORD *)(dword_80DBB88 + 4) + 4);\n}\n"
        ],
        "134684028": [
            "sub_8071D7C",
            "0x8071d7c",
            "int __usercall sub_8071D7C@<eax>(_DWORD *a1@<eax>, const char *a2@<edx>)\n{\n  _BYTE *v2; // esi\n  _BYTE *i; // ebx\n  char *v6; // edx\n  _BYTE *v7; // eax\n  unsigned int v9; // [esp+4h] [ebp-14h]\n\n  v2 = (_BYTE *)*a1;\n  if ( !*a1 )\n    return 0;\n  for ( i = (_BYTE *)*a1; *i != 58 && *i != 0 && *i != 37; ++i )\n    ;\n  v9 = i - v2 + strlen(a2) + 2;\n  while ( *(_DWORD *)(dword_80DBB88 + 12) < v9 )\n    sub_8071623();\n  v6 = *(char **)(dword_80DBB88 + 4);\n  if ( v2 != i )\n  {\n    v7 = (_BYTE *)mempcpy(v6, v2, i - v2);\n    v6 = v7 + 1;\n    *v7 = 47;\n  }\n  strcpy(v6, a2);\n  dword_80DB6FC = 0;\n  if ( *i == 37 )\n  {\n    dword_80DB6FC = (int)++i;\n    while ( *i != 58 && *i )\n      ++i;\n  }\n  if ( *i == 58 )\n    *a1 = i + 1;\n  else\n    *a1 = 0;\n  return sub_806FFC6(v9);\n}\n"
        ],
        "134684246": [
            "sub_8071E56",
            "0x8071e56",
            "char __usercall sub_8071E56@<al>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int v5; // ebx\n  int v6; // ebp\n  int v7; // edx\n  void **i; // edx\n  int v9; // eax\n  __pid_t v10; // edi\n  int v11; // ebx\n  int v14; // [esp+4h] [ebp-1Ch]\n  int v15; // [esp+4h] [ebp-1Ch]\n  void **ptr; // [esp+8h] [ebp-18h]\n  void **v17; // [esp+Ch] [ebp-14h]\n\n  v5 = dword_80DBB8C;\n  v6 = *(_DWORD *)(dword_80DBB8C + 8);\n  *(_DWORD *)(dword_80DBB8C + 8) = v6 + 1;\n  while ( off_80DB55C != &unk_80DB5E0 )\n    sub_806F6F7();\n  if ( dword_80DB5E8 > 0 )\n  {\n    close(dword_80DB5E8);\n    *((_DWORD *)off_80DB55C + 2) = 0;\n  }\n  if ( a3 == 2 )\n  {\n    if ( a2 )\n    {\n      if ( !*(_BYTE *)a2 )\n      {\n        v7 = *(_DWORD *)(a2 + 12);\n        if ( v7 )\n        {\n          v14 = *(_DWORD *)(a2 + 12);\n          if ( !strcmp(*(const char **)(v7 + 8), \"trap\") && !*(_DWORD *)(v14 + 4) )\n            *(_DWORD *)(v5 + 452) = sub_804DB8D((const void *)(v5 + 192), 0x104u);\n        }\n      }\n    }\n  }\n  ++*(_DWORD *)(v5 + 36);\n  v15 = dword_80DBB8C + 192;\n  for ( i = (void **)(dword_80DBB8C + 192); (unsigned int)i < dword_80DBB8C + 452; ++i )\n  {\n    if ( *i && *(_BYTE *)*i )\n    {\n      if ( v15 == *(_DWORD *)(dword_80DBB8C + 452) )\n      {\n        v17 = i;\n        free(*i);\n        i = v17;\n      }\n      *i = 0;\n      if ( i != (void **)v15 )\n      {\n        ptr = i;\n        sub_806F2B1(((int)i - v15) >> 2);\n        i = ptr;\n      }\n    }\n  }\n  *(_BYTE *)(dword_80DBB8C + 188) = 0;\n  LOBYTE(v9) = sub_806F4A5();\n  byte_80DB76D = 0;\n  if ( a3 == 2 )\n  {\nLABEL_35:\n    if ( v6 )\n      goto LABEL_39;\n    goto LABEL_36;\n  }\n  if ( (*(_BYTE *)(a1 + 25) & 2) == 0 )\n  {\n    if ( a3 != 1 )\n      goto LABEL_35;\n    goto LABEL_32;\n  }\n  if ( v6 )\n  {\n    if ( a3 != 1 )\n      goto LABEL_39;\nLABEL_32:\n    sub_806F3DD(2);\n    LOBYTE(v9) = sub_806F3DD(3);\n    if ( !*(_DWORD *)(a1 + 20) )\n    {\n      close(0);\n      v9 = open64(\"/dev/null\");\n      if ( v9 )\n        sub_806FB57(\"can't open '%s': %m\", \"/dev/null\");\n    }\n    goto LABEL_35;\n  }\n  if ( *(_DWORD *)(a1 + 20) )\n    v10 = **(_DWORD **)(a1 + 12);\n  else\n    v10 = getpid();\n  setpgid(0, v10);\n  if ( !a3 )\n    sub_806FFAE(dword_80DB558, v10);\n  sub_806F2B1(20);\n  sub_806F2B1(22);\nLABEL_36:\n  if ( *(_BYTE *)(v5 + 48) )\n  {\n    sub_806F2B1(2);\n    sub_806F2B1(15);\n  }\n  LOBYTE(v9) = sub_806F2B1(3);\nLABEL_39:\n  v11 = dword_80DB6E0;\n  if ( !a2 || *(_BYTE *)a2 || (v9 = *(_DWORD *)(a2 + 12)) == 0 || (v9 = strcmp(*(const char **)(v9 + 8), \"jobs\")) != 0 )\n  {\n    while ( v11 )\n    {\n      LOBYTE(v9) = sub_806F9B7(v11);\n      v11 = *(_DWORD *)(v11 + 28);\n    }\n    dword_80DB6DC = 0;\n  }\n  else\n  {\n    LOBYTE(v9) = sub_806F9B7(v11);\n  }\n  return v9;\n}\n"
        ],
        "134684858": [
            "sub_80720BA",
            "0x80720ba",
            "int __usercall sub_80720BA@<eax>(char **envp@<ecx>, const char **argv@<edx>, const char *a3@<eax>)\n{\n  int result; // eax\n\n  while ( 1 )\n  {\n    result = execve(a3, (char *const *)argv, envp);\n    if ( a3 == \"/proc/self/exe\" )\n      break;\n    result = dword_80DBB7C;\n    if ( *(_DWORD *)dword_80DBB7C != 8 )\n      break;\n    *argv-- = a3;\n    *argv = \"ash\";\n    a3 = \"/proc/self/exe\";\n  }\n  return result;\n}\n"
        ],
        "134684918": [
            "sub_80720F6",
            "0x80720f6",
            "char *__usercall sub_80720F6@<eax>(int a1@<eax>, char *a2@<edx>)\n{\n  char *result; // eax\n\n  result = a2;\n  if ( a1 != 2 && a1 != 20 )\n    return strerror(a1);\n  return result;\n}\n"
        ],
        "134684940": [
            "sub_807210C",
            "0x807210c",
            "void __noreturn sub_807210C()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134685226": [
            "sub_807222A",
            "0x807222a",
            "int sub_807222A()\n{\n  unsigned int v0; // ebx\n  unsigned __int8 *v1; // esi\n  unsigned int v2; // ecx\n  struct tms v4; // [esp+0h] [ebp-1Ch] BYREF\n\n  v0 = sub_80B2F58();\n  times(&v4);\n  v1 = \" \";\n  do\n  {\n    v2 = *(clock_t *)((char *)&v4.tms_utime + v1[1]) / v0;\n    sub_80708A7(\n      \"%um%u.%03us%c\",\n      v2 / 0x3C,\n      v2 % 0x3C,\n      1000 * (*(clock_t *)((char *)&v4.tms_utime + v1[1]) % v0) / v0,\n      *v1);\n    v1 += 2;\n  }\n  while ( *v1 );\n  return 0;\n}\n"
        ],
        "134685322": [
            "sub_807228A",
            "0x807228a",
            "int __usercall sub_807228A@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>, unsigned int a4@<ebx>)\n{\n  const char **v5; // ebx\n  const char *v6; // ebp\n  int v7; // ecx\n  _BYTE *v8; // esi\n  const char *v9; // eax\n  unsigned int v11[5]; // [esp+0h] [ebp-14h] BYREF\n\n  v11[0] = a4;\n  v5 = (const char **)sub_8071CF0(a2, a3, v11);\n  qsort(v5, (signed int)(v11[0] - (_DWORD)v5) >> 2, 4u, (__compar_fn_t)sub_806ECD8);\n  v6 = a1;\n  if ( *a1 )\n    v6 = \"     \" + 4;\n  while ( v11[0] > (unsigned int)v5 )\n  {\n    v8 = (_BYTE *)sub_80AB128();\n    v9 = (const char *)(dword_80DBB8C + 44);\n    if ( *v8 == 61 )\n      v9 = (const char *)sub_80716D8(++v8, v7);\n    sub_80708A7(\"%s%s%.*s%s\\n\", a1, v6, v8 - *v5, *v5, v9);\n    ++v5;\n  }\n  return 0;\n}\n"
        ],
        "134685450": [
            "sub_807230A",
            "0x807230a",
            "int __usercall sub_807230A@<eax>(int a1@<edx>, unsigned int a2@<ebx>, __pid_t a3@<esi>)\n{\n  int v4; // ebx\n\n  if ( !*(_DWORD *)(a1 + 4) )\n    return sub_807228A((const char *)(dword_80DBB8C + 44), 0, 32, a2);\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v4 = sub_80708D4(0, 0);\n  if ( !v4 )\n  {\n    sub_8070672(a3);\n    if ( *(_DWORD *)dword_80DB708 )\n      sub_806F249((const char **)dword_80DB708);\n  }\n  sub_806F4A5();\n  return v4;\n}\n"
        ],
        "134685528": [
            "sub_8072358",
            "0x8072358",
            "void __usercall __noreturn sub_8072358(int a1@<eax>)\n{\n  ((void (__cdecl __noreturn *)(int))loc_807018F)(a1);\n}\n"
        ],
        "134685692": [
            "sub_80723FC",
            "0x80723fc",
            "int __usercall sub_80723FC@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_80963DC(a1, a2);\n}\n"
        ],
        "134685702": [
            "sub_8072406",
            "0x8072406",
            "int __usercall sub_8072406@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  _BYTE **v4; // esi\n  int v5; // edx\n  void *v6; // esp\n  char *v7; // ebx\n  int *v8; // eax\n  int v9; // ecx\n  int v10; // ecx\n  const char *v11; // eax\n  int v13; // [esp+0h] [ebp-1Ch]\n  int v14; // [esp+4h] [ebp-18h] BYREF\n  int i; // [esp+8h] [ebp-14h]\n  int v16; // [esp+Ch] [ebp-10h]\n\n  v14 = a1;\n  v3 = *(const char **)(a2 + 4);\n  if ( v3 && strcmp(v3, \"-l\") )\n  {\n    v4 = (_BYTE **)(a2 + 4);\n    do\n    {\n      if ( **v4 == 37 )\n      {\n        v5 = sub_8070349(*v4, 0);\n        v16 = *(_DWORD *)(v5 + 20);\n        if ( (*(_BYTE *)(v5 + 25) & 2) != 0 )\n          v16 = 1;\n        v6 = alloca(16 * v16 + 16);\n        v7 = (char *)&v14;\n        *v4 = &v14;\n        for ( i = 0; i < v16; ++i )\n        {\n          v8 = (int *)(*(_DWORD *)(v5 + 12) + 12 * i);\n          v9 = v8[1];\n          if ( v9 == -1 || (_BYTE)v9 == 127 )\n          {\n            v10 = *v8;\n            v11 = \" -%u\";\n            if ( (*(_BYTE *)(v5 + 25) & 2) == 0 )\n              v11 = \" %u\";\n            v13 = v5;\n            v7 += sprintf(v7, v11, v10);\n            v5 = v13;\n          }\n        }\n        *v7 = 0;\n      }\n      ++v4;\n    }\n    while ( *v4 );\n  }\n  return sub_806C641(v14, a2);\n}\n"
        ],
        "134685919": [
            "sub_80724DF",
            "0x80724df",
            "int sub_80724DF()\n{\n  sub_80AED34();\n  return 0;\n}\n"
        ],
        "134685932": [
            "sub_80724EC",
            "0x80724ec",
            "int __usercall sub_80724EC@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_809191A(a1, a2);\n}\n"
        ],
        "134685942": [
            "sub_80724F6",
            "0x80724f6",
            "int __usercall sub_80724F6@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  return sub_8099228(a1, a2);\n}\n"
        ],
        "134685952": [
            "sub_8072500",
            "0x8072500",
            "char __usercall sub_8072500@<al>(_DWORD *a1@<eax>, char *a2@<edx>, int a3@<ecx>, int a4)\n{\n  char *v5; // ebp\n  char *v6; // ebx\n  int v7; // edx\n  DIR *v8; // eax\n  _BYTE *v9; // eax\n  _BYTE *v10; // esi\n  _BOOL4 v11; // eax\n  int v12; // esi\n  char *v13; // eax\n  char *v14; // eax\n  char *v15; // edx\n  const char *v16; // eax\n  int v17; // edx\n  int v18; // ecx\n  char *v19; // eax\n  int v20; // eax\n  const char *v21; // ebp\n  _BYTE *v22; // ebp\n  int v23; // ebp\n  int v24; // ecx\n  int v26; // [esp-4h] [ebp-90h]\n  int v27; // [esp-4h] [ebp-90h]\n  char *dest; // [esp+0h] [ebp-8Ch]\n  char *desta; // [esp+0h] [ebp-8Ch]\n  char *pattern; // [esp+4h] [ebp-88h]\n  int v31; // [esp+8h] [ebp-84h]\n  DIR *dirp; // [esp+Ch] [ebp-80h]\n  int v34; // [esp+10h] [ebp-7Ch]\n  char v35; // [esp+17h] [ebp-75h]\n  char *v36; // [esp+18h] [ebp-74h]\n  char v37[112]; // [esp+1Ch] [ebp-70h] BYREF\n\n  v5 = a2;\n  dest = (char *)(a4 + *a1);\n  pattern = a2;\n  v6 = a2;\n  v7 = 0;\n  while ( 1 )\n  {\n    LOBYTE(v8) = *v6;\n    if ( !*v6 )\n      break;\n    if ( (_BYTE)v8 == 42 || (_BYTE)v8 == 63 )\n    {\nLABEL_18:\n      v12 = 0;\n      v7 = 1;\n    }\n    else if ( (_BYTE)v8 == 91 )\n    {\n      v9 = v6 + 1;\n      if ( v6[1] == 33 )\n        v9 = v6 + 2;\n      while ( 1 )\n      {\n        v10 = v9;\n        if ( *v9 == 92 )\n          v10 = v9 + 1;\n        if ( !*v10 || *v10 == 47 )\n          break;\n        v9 = v10 + 1;\n        if ( v10[1] == 93 )\n          goto LABEL_18;\n      }\n      v12 = 0;\n    }\n    else\n    {\n      v11 = (_BYTE)v8 == 92;\n      v12 = v11;\n      if ( v6[v11] == 47 )\n      {\n        if ( v7 )\n          goto LABEL_28;\n        pattern = &v6[v11 + 1];\n      }\n    }\n    v6 += v12 + 1;\n  }\n  if ( v7 )\n  {\n    v12 = 0;\nLABEL_28:\n    if ( pattern > v5 )\n    {\n      v14 = v5;\n      do\n      {\n        v15 = v14 + 1;\n        if ( *v14 != 92 )\n          v15 = v14;\n        v14 = v15 + 1;\n        *dest++ = *v15;\n      }\n      while ( pattern > v15 + 1 );\n    }\n    *dest = 0;\n    v16 = (const char *)*a1;\n    v36 = &dest[-*a1];\n    if ( dest == (char *)*a1 )\n      v16 = \".\";\n    v8 = opendir(v16);\n    dirp = v8;\n    if ( v8 )\n    {\n      v31 = 1;\n      if ( *v6 )\n      {\n        *v6 = 0;\n        v6 += v12 + 1;\n        v31 = 0;\n      }\n      v18 = a3 - (v6 - v5);\n      v34 = v18;\n      v19 = pattern;\n      if ( *pattern == 92 )\n        v19 = pattern + 1;\n      v35 = *v19;\n      while ( !*(_BYTE *)(dword_80DBB8C + 40) )\n      {\n        v20 = readdir64(v18, v17, dirp);\n        v17 = v26;\n        if ( !v20 )\n          break;\n        if ( *(_BYTE *)(v20 + 19) != 46 || v35 == 46 )\n        {\n          v21 = (const char *)(v20 + 19);\n          if ( !fnmatch(pattern, (const char *)(v20 + 19), 0) )\n          {\n            if ( v31 )\n            {\n              strcpy(dest, v21);\n              sub_8070C89((const char *)*a1);\n              v17 = v27;\n            }\n            else\n            {\n              v22 = (_BYTE *)stpcpy(dest, v21);\n              *v22 = 47;\n              v23 = (int)&v22[-*a1 + 1];\n              v24 = v34 + v23;\n              if ( a1[1] < (unsigned int)(v34 + v23 + 255) )\n              {\n                desta = (char *)(v24 + 4351);\n                *a1 = sub_804DB13((void *)*a1, v24 + 4351);\n                a1[1] = desta;\n              }\n              sub_8072500(v23);\n              dest = &v36[*a1];\n            }\n          }\n        }\n      }\n      LOBYTE(v8) = closedir(dirp);\n      if ( !v31 )\n      {\n        v8 = (DIR *)(v12 == 0 ? 47 : 92);\n        v6[~v12] = (char)v8;\n      }\n    }\n    return (char)v8;\n  }\n  if ( a4 )\n  {\n    do\n    {\n      v13 = v5 + 1;\n      if ( *v5 != 92 )\n        v13 = v5;\n      *dest++ = *v13;\n      v5 = v13 + 1;\n    }\n    while ( *v13 );\n    v8 = (DIR *)lstat64(*a1, v37);\n    if ( !v8 )\n      LOBYTE(v8) = sub_8070C89((const char *)*a1);\n  }\n  return (char)v8;\n}\n"
        ],
        "134686556": [
            "sub_807275C",
            "0x807275c",
            "void __usercall __noreturn sub_807275C(int a1@<eax>)\n{\n  char *v2; // eax\n  int v3; // edi\n  char *v4; // eax\n  char s[16]; // [esp+0h] [ebp-5Ch] BYREF\n  char v6[76]; // [esp+10h] [ebp-4Ch] BYREF\n\n  v2 = (char *)*(&off_80B5EE0 + byte_80DB768);\n  if ( byte_80DB768 > 3 )\n  {\n    sprintf(s, \"\\\"%s\\\"\", (const char *)*(&off_80B5EE0 + byte_80DB768));\n    v2 = s;\n  }\n  v3 = sprintf(v6, \"unexpected %s\", v2);\n  if ( a1 != -1 )\n  {\n    v4 = (char *)*(&off_80B5EE0 + a1);\n    if ( a1 > 3 )\n    {\n      sprintf(s, \"\\\"%s\\\"\", (const char *)*(&off_80B5EE0 + a1));\n      v4 = s;\n    }\n    sprintf(&v6[v3], \" (expecting %s)\", v4);\n  }\n  sub_8070172(v6);\n}\n"
        ],
        "134686687": [
            "sub_80727DF",
            "0x80727df",
            "size_t __usercall sub_80727DF@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  _DWORD *i; // ebx\n  int v6; // edx\n  int v7; // edx\n  int v8; // esi\n  _DWORD *j; // edi\n\n  while ( 2 )\n  {\n    if ( a2 )\n    {\n      a1 += (unsigned __int8)byte_80D0F76[*a2];\n      switch ( *a2 )\n      {\n        case 0:\n          sub_80727DF(a3, *((_DWORD *)a2 + 4));\n          goto LABEL_9;\n        case 1:\n          for ( i = (_DWORD *)*((_DWORD *)a2 + 1); i; i = (_DWORD *)*i )\n            a1 = sub_80727DF(a3, i[1]);\n          return a1;\n        case 2:\n        case 3:\n        case 4:\n        case 12:\n          v7 = *((_DWORD *)a2 + 3);\n          goto LABEL_11;\n        case 5:\n        case 6:\n        case 7:\n        case 9:\n        case 10:\n          v6 = *((_DWORD *)a2 + 2);\n          goto LABEL_20;\n        case 8:\n        case 13:\n          sub_80727DF(a3, *((_DWORD *)a2 + 3));\n          v6 = *((_DWORD *)a2 + 2);\n          goto LABEL_20;\n        case 11:\n          strlen(*((const char **)a2 + 4));\nLABEL_9:\n          v7 = *((_DWORD *)a2 + 3);\nLABEL_11:\n          a1 = sub_80727DF(a3, v7);\n          a2 = (char *)*((_DWORD *)a2 + 2);\n          continue;\n        case 14:\n          v8 = sub_80727DF(a3, *((_DWORD *)a2 + 3));\n          return ((strlen(*((const char **)a2 + 2)) + 8) & 0xFFFFFFF8) + v8;\n        case 15:\n          for ( j = (_DWORD *)*((_DWORD *)a2 + 3); j; j = (_DWORD *)*j )\n            a1 = sub_80727DF(a3, j[1]);\n          a1 += (strlen(*((const char **)a2 + 2)) + 8) & 0xFFFFFFF8;\n          goto LABEL_21;\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        case 20:\n        case 21:\n        case 22:\n        case 23:\n          v6 = *((_DWORD *)a2 + 4);\n          goto LABEL_20;\n        case 24:\n        case 25:\n          v6 = *((_DWORD *)a2 + 3);\nLABEL_20:\n          a1 = sub_80727DF(a3, v6);\n          goto LABEL_21;\n        case 26:\nLABEL_21:\n          a2 = (char *)*((_DWORD *)a2 + 1);\n          continue;\n        default:\n          return a1;\n      }\n    }\n    return a1;\n  }\n}\n"
        ],
        "134686941": [
            "sub_80728DD",
            "0x80728dd",
            "int __usercall sub_80728DD@<eax>(int result@<eax>, int a2@<edx>)\n{\n  unsigned __int8 *v2; // ebx\n  const char *v3; // esi\n  const char *v4; // eax\n  const char *v5; // esi\n  _DWORD *v6; // ebx\n  int v7; // edx\n  int v8; // edx\n  int v9; // edx\n  int v10; // edx\n  const char *v11; // ebx\n  int v12; // edx\n  int v13; // edx\n  int v14; // edx\n  int k; // esi\n  int i; // esi\n  int j; // ebx\n  const char *v18; // eax\n  int v19; // edx\n  int v20; // edx\n  int m; // ebx\n  int v22; // edx\n  int v23; // edx\n  const char *v24; // eax\n  int v25; // edx\n  int v26; // edx\n  int v27; // eax\n  signed int v28; // eax\n\n  v2 = (unsigned __int8 *)result;\n  while ( 2 )\n  {\n    if ( !v2 )\n      return result;\n    result = *v2;\n    switch ( *v2 )\n    {\n      case 0u:\n        for ( i = *((_DWORD *)v2 + 3); i; i = *(_DWORD *)(i + 4) )\n        {\n          result = sub_80728DD();\n          if ( *(_DWORD *)(i + 4) )\n            result = sub_8071B5D(\" \", a2);\n        }\n        for ( j = *((_DWORD *)v2 + 4); j; j = *(_DWORD *)(j + 4) )\n        {\n          sub_8071B5D(\" \", a2);\n          result = sub_80728DD();\n        }\n        return result;\n      case 2u:\n      case 3u:\n        goto LABEL_13;\n      case 4u:\n        sub_8071B5D(\"(\", a2);\n        v11 = \" (DUP!)\" + 6;\n        goto LABEL_22;\n      case 5u:\n        v5 = \" && \";\n        goto LABEL_12;\n      case 6u:\n        v5 = \" || \";\n        goto LABEL_12;\n      case 7u:\n        v5 = \"; \";\nLABEL_12:\n        sub_80728DD();\n        result = sub_8071B5D(v5, v8);\nLABEL_13:\n        v2 = (unsigned __int8 *)*((_DWORD *)v2 + 2);\n        continue;\n      case 8u:\n        sub_8071B5D(\"if \", a2);\n        sub_80728DD();\n        sub_8071B5D(\"; then \", v9);\n        if ( *((_DWORD *)v2 + 3) )\n        {\n          sub_80728DD();\n          sub_8071B5D(\"; else \", v10);\n        }\n        v11 = \"; fi\";\n        goto LABEL_22;\n      case 9u:\n        v4 = \"while \";\n        goto LABEL_20;\n      case 0xAu:\n        v4 = \"until \";\nLABEL_20:\n        sub_8071B5D(v4, a2);\n        sub_80728DD();\n        goto LABEL_21;\n      case 0xBu:\n        sub_8071B5D(\"for \", a2);\n        sub_8071B5D(*((const char **)v2 + 4), v13);\n        sub_8071B5D(\" in \", v14);\n        for ( k = *((_DWORD *)v2 + 2); k; k = *(_DWORD *)(k + 4) )\n        {\n          sub_80728DD();\n          if ( *(_DWORD *)(k + 4) )\n            sub_8071B5D(\" \", v12);\n        }\nLABEL_21:\n        sub_8071B5D(\"; do \", v12);\n        v11 = \"; done\";\nLABEL_22:\n        sub_80728DD();\n        goto LABEL_40;\n      case 0xCu:\n        sub_8071B5D(\"case \", a2);\n        sub_8071B5D(*(const char **)(*((_DWORD *)v2 + 2) + 8), v19);\n        sub_8071B5D(\" in \", v20);\n        for ( m = *((_DWORD *)v2 + 3); m; m = *(_DWORD *)(m + 4) )\n        {\n          sub_80728DD();\n          sub_8071B5D(\") \", v22);\n          sub_80728DD();\n          sub_8071B5D(\";; \", v23);\n        }\n        v11 = \"esac\";\n        goto LABEL_40;\n      case 0xEu:\n        sub_8071B5D(*((const char **)v2 + 2), a2);\n        v11 = \"() { ... }\";\n        goto LABEL_40;\n      case 0xFu:\n        v11 = (const char *)*((_DWORD *)v2 + 2);\n        goto LABEL_40;\n      case 0x10u:\n        v3 = \">\";\n        goto LABEL_51;\n      case 0x11u:\n      case 0x16u:\n        v3 = \">&\";\n        goto LABEL_51;\n      case 0x12u:\n        v3 = \">|\";\n        goto LABEL_51;\n      case 0x13u:\n        v3 = \"<\";\n        goto LABEL_51;\n      case 0x14u:\n        v3 = \"<>\";\n        goto LABEL_51;\n      case 0x15u:\n        v3 = \">>\";\n        goto LABEL_51;\n      case 0x17u:\n        v3 = \"<&\";\nLABEL_51:\n        v24 = sub_804D6F7(*((_DWORD *)v2 + 2));\n        sub_8071B5D(v24, v25);\n        v27 = sub_8071B5D(v3, v26);\n        LOBYTE(v27) = *v2;\n        result = v27 - 22;\n        if ( (unsigned __int8)result > 1u )\n        {\n          v2 = (unsigned __int8 *)*((_DWORD *)v2 + 4);\n          continue;\n        }\n        v28 = *((_DWORD *)v2 + 3);\n        if ( v28 < 0 )\n          v18 = \"-\";\n        else\n          v18 = sub_804D6F7(v28);\n        return sub_8071B5D(v18, a2);\n      case 0x18u:\n      case 0x19u:\n        v11 = \"<<...\";\nLABEL_40:\n        v18 = v11;\n        return sub_8071B5D(v18, a2);\n      case 0x1Au:\n        result = sub_8071B5D(\"!\", a2);\n        v2 = (unsigned __int8 *)*((_DWORD *)v2 + 1);\n        continue;\n      default:\n        v6 = (_DWORD *)*((_DWORD *)v2 + 1);\n        while ( 1 )\n        {\n          result = sub_80728DD();\n          v6 = (_DWORD *)*v6;\n          if ( !v6 )\n            break;\n          sub_8071B5D(\" | \", v7);\n        }\n        return result;\n    }\n  }\n}\n"
        ],
        "134687572": [
            "sub_8072B54",
            "0x8072b54",
            "__pid_t __usercall sub_8072B54@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int v6; // eax\n  __pid_t v7; // esi\n  int v8; // edx\n  int v9; // eax\n  __pid_t *v10; // ebx\n  int v11; // edi\n\n  v6 = fork();\n  if ( v6 < 0 )\n  {\n    if ( a1 )\n      sub_806F9B7(a1);\n    sub_806FB57(\"can't fork: %m\");\n  }\n  v7 = v6;\n  if ( v6 )\n  {\n    if ( a1 )\n    {\n      if ( a3 != 2 )\n      {\n        if ( (*(_BYTE *)(a1 + 25) & 2) != 0 )\n        {\n          if ( *(_DWORD *)(a1 + 20) )\n            v6 = **(_DWORD **)(a1 + 12);\n          setpgid(v7, v6);\n        }\n        if ( a3 == 1 )\n        {\n          *(_DWORD *)(dword_80DBB8C + 472) = v7;\n          sub_806ED0E(a1, 1);\n        }\n      }\n      v8 = *(_DWORD *)(a1 + 12);\n      v9 = *(_DWORD *)(a1 + 20);\n      *(_DWORD *)(a1 + 20) = v9 + 1;\n      v10 = (__pid_t *)(v8 + 12 * v9);\n      *v10 = v7;\n      v10[1] = -1;\n      v10[2] = dword_80DBB8C + 44;\n      if ( byte_80DB76D && a2 )\n      {\n        v11 = dword_80DBB88;\n        dword_80DB6D8 = *(_DWORD *)(dword_80DBB88 + 4);\n        sub_80728DD(a2, v8);\n        v10[2] = (__pid_t)sub_804DB46(*(const char **)(v11 + 4));\n      }\n    }\n    else\n    {\n      while ( dword_80DB6DC && sub_8070DA4(0, 0) > 0 )\n        ;\n      ++dword_80DB6DC;\n    }\n  }\n  else\n  {\n    *(_DWORD *)(dword_80DBB8C + 456) = 0;\n    sub_8071E56(a1, a2, a3);\n  }\n  return v7;\n}\n"
        ],
        "134687831": [
            "sub_8072C57",
            "0x8072c57",
            "void __noreturn sub_8072C57(int a1, int a2, ...)\n{\n  va_list va; // [esp+Ch] [ebp+Ch] BYREF\n\n  va_start(va, a2);\n  sub_806FAC0(\"%s: %s\", va);\n  sub_806F4BD();\n  sub_806F22F(4);\n}\n"
        ],
        "134687860": [
            "sub_8072C74",
            "0x8072c74",
            "void __usercall __noreturn sub_8072C74(const char *a1@<eax>, const char **a2@<edx>, int a3@<ecx>, int a4)\n{\n  int v6; // ebx\n  const char *v7; // eax\n  int v8; // edi\n  char v9; // al\n  char *v10; // eax\n  char **envp; // [esp+0h] [ebp-18h]\n  int v12[5]; // [esp+4h] [ebp-14h] BYREF\n\n  v12[0] = a3;\n  envp = (char **)sub_8071CF0(1, 32, 0);\n  if ( strchr(a1, 47) )\n  {\n    sub_80720BA(envp, a2, a1);\n    v6 = *(_DWORD *)dword_80DBB7C;\n  }\n  else\n  {\n    v6 = 2;\n    while ( 1 )\n    {\n      v7 = (const char *)sub_8071D7C(v12, a1);\n      v8 = (int)v7;\n      if ( !v7 )\n        break;\n      if ( --a4 < 0 && !dword_80DB6FC )\n      {\n        sub_80720BA(envp, a2, v7);\n        if ( *(_DWORD *)dword_80DBB7C != 2 && *(_DWORD *)dword_80DBB7C != 20 )\n          v6 = *(_DWORD *)dword_80DBB7C;\n      }\n      sub_806EC35(v8);\n    }\n  }\n  v9 = 127;\n  if ( v6 != 2 )\n    v9 = v6 == 13 ? 126 : 2;\n  *(_BYTE *)dword_80DBB8C = v9;\n  v10 = sub_80720F6(v6, \"not found\");\n  sub_8072C57(4, (int)\"%s: %s\", a1, v10);\n}\n"
        ],
        "134688066": [
            "sub_8072D42",
            "0x8072d42",
            "void __noreturn sub_8072D42()\n{\n  dword_80DB704 = 0;\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134688176": [
            "sub_8072DB0",
            "0x8072db0",
            "char __usercall sub_8072DB0@<al>(int a1@<eax>)\n{\n  FILE *v1; // ebx\n\n  v1 = stdout;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  fputs_unlocked(a1, v1);\n  return sub_806F4A5();\n}\n"
        ],
        "134688211": [
            "sub_8072DD3",
            "0x8072dd3",
            "void __usercall __noreturn sub_8072DD3(int a1@<eax>)\n{\n  ((void (__cdecl __noreturn *)(int))loc_807018F)(a1);\n}\n"
        ],
        "134688493": [
            "sub_8072EED",
            "0x8072eed",
            "char *__usercall sub_8072EED@<eax>(unsigned __int8 *a1@<eax>)\n{\n  _DWORD *v2; // eax\n  int v3; // ebx\n  char *result; // eax\n  char v5; // dl\n\n  v2 = (_DWORD *)sub_806ECAC(a1);\n  v3 = *sub_806ECE9(v2, (int)a1);\n  if ( !v3 )\n    return 0;\n  if ( (*(_BYTE *)(v3 + 5) & 2) != 0 )\n    (*(void (**)(void))(v3 + 12))();\n  if ( (*(_BYTE *)(v3 + 4) & 0x20) != 0 )\n    return 0;\n  if ( v3 == dword_80DBB90 + 280 && *(_DWORD *)(dword_80DBB90 + 288) == dword_80DBB90 + 332 )\n    sub_8070CE3((char *)(dword_80DBB90 + 339), 0xDu, \"%d\", *(_DWORD *)(dword_80DBB90 + 328));\n  result = *(char **)(v3 + 8);\n  do\n  {\n    v5 = *result;\n    if ( !*result )\n      break;\n    ++result;\n  }\n  while ( v5 != 61 );\n  return result;\n}\n"
        ],
        "134688608": [
            "sub_8072F60",
            "0x8072f60",
            "_DWORD *sub_8072F60()\n{\n  int v0; // eax\n  unsigned int v1; // ebx\n  unsigned int v2; // esi\n  _DWORD *v3; // eax\n  unsigned __int8 **i; // ebx\n  unsigned __int8 *v5; // esi\n  unsigned int v6; // eax\n  const char *v7; // eax\n  char *v8; // eax\n  unsigned int v9; // edx\n  const char *v10; // eax\n  char *v11; // eax\n  const char *v12; // ebx\n  int v14[24]; // [esp+0h] [ebp-1F0h] BYREF\n  struct utsname name; // [esp+60h] [ebp-190h] BYREF\n\n  dword_80DB5F8 = (int)sub_804DAFA(0x400u);\n  dword_80DB5F4 = dword_80DB5F8;\n  dword_80DB5E4 = 1;\n  *(_BYTE *)(dword_80DBB8C + 76) = 1;\n  sub_806F2B1(17);\n  signal(1, 0);\n  v0 = dword_80DBB90;\n  *(_DWORD *)(dword_80DBB90 + 224) = \"PS1=\\\\w \\\\$ \";\n  v1 = v0 + 184;\n  v2 = v0 + 328;\n  do\n  {\n    v3 = (_DWORD *)sub_806ECAC(*(unsigned __int8 **)(v1 + 8));\n    *(_DWORD *)v1 = *v3;\n    *v3 = v1;\n    v1 += 16;\n  }\n  while ( v2 > v1 );\n  for ( i = (unsigned __int8 **)environ; i; ++i )\n  {\n    v5 = *i;\n    if ( !*i )\n      break;\n    if ( strchr((const char *)v5, 61) )\n      sub_806FB7B(v5, 9);\n  }\n  sub_806FB7B(\"OPTIND=1\", 8);\n  v6 = getppid();\n  v7 = sub_804D6F7(v6);\n  sub_806FE06(135069685, v7);\n  v8 = sub_8072EED(\"SHLVL\");\n  v9 = 1;\n  if ( v8 )\n    v9 = atoi(v8) + 1;\n  v10 = sub_804D6F7(v9);\n  sub_806FCE2((int)\"SHLVL\", v10, 1);\n  if ( !sub_8072EED(\"HOSTNAME\") )\n  {\n    uname(&name);\n    sub_806FE06((int)\"HOSTNAME\", name.nodename);\n  }\n  v11 = sub_8072EED((unsigned __int8 *)\"PWD\");\n  v12 = v11;\n  if ( v11\n    && (*v11 != 47\n     || stat64(v11, v14)\n     || stat64(135072092, &name)\n     || v14[1] != *(_DWORD *)&name.sysname[4]\n     || v14[0] != *(_DWORD *)name.sysname\n     || v14[23] != *(_DWORD *)&name.nodename[27]\n     || v14[22] != *(_DWORD *)&name.nodename[23]) )\n  {\n    v12 = 0;\n  }\n  return sub_8070805(v12, 0);\n}\n"
        ],
        "134689023": [
            "sub_80730FF",
            "0x80730ff",
            "int __usercall sub_80730FF@<eax>(unsigned __int8 *a1@<eax>, char a2@<dl>, __int16 a3@<cx>, int *a4)\n{\n  int v4; // ebx\n  int v5; // edx\n  char v6; // bp\n  int v7; // edi\n  unsigned __int8 v8; // dl\n  signed int v9; // eax\n  unsigned int v10; // ebx\n  _BYTE *v11; // eax\n  int v12; // edi\n  char v13; // bp\n  int i; // edx\n  char v15; // cl\n  int v16; // eax\n  _DWORD *v17; // esi\n  int v18; // eax\n  char *v19; // esi\n  int v21; // [esp+4h] [ebp-24h]\n  char *s; // [esp+8h] [ebp-20h]\n  int v23; // [esp+Ch] [ebp-1Ch]\n  unsigned int v24; // [esp+10h] [ebp-18h]\n  char v25[17]; // [esp+17h] [ebp-11h] BYREF\n\n  v4 = *a4;\n  v5 = a2 & 0xF;\n  if ( v5 == 3 || v5 == 10 )\n  {\n    v23 = 1;\n    v6 = 2;\n  }\n  else\n  {\n    v6 = a3 & 0x11 | 2;\n    v23 = 0;\n  }\n  v7 = (a3 << 8) & 0x100;\n  v21 = v4 != 0;\n  v8 = *a1;\n  if ( *a1 == 45 )\n  {\n    v11 = (_BYTE *)sub_80716AF(0xFu, dword_80DB6D4);\n    dword_80DB6D4 = (int)v11;\n    v12 = dword_80DBB8C;\n    v13 = 0;\n    v10 = 0;\n    for ( i = 14; i != -1; --i )\n    {\n      if ( *(_BYTE *)(v12 + i + 45) )\n      {\n        v15 = *off_80B5FE0[i];\n        if ( v15 )\n        {\n          *v11 = v15;\n          ++v10;\n          ++v11;\n          v13 = 1;\n        }\n      }\n    }\n    if ( v13 )\n      dword_80DB6D4 = (int)v11;\n    goto LABEL_55;\n  }\n  if ( *a1 <= 0x2Du )\n  {\n    if ( v8 == 35 )\n    {\n      v9 = *(_DWORD *)dword_80DBB90;\n      goto LABEL_24;\n    }\n    if ( v8 <= 0x23u )\n    {\n      if ( v8 != 33 )\n        goto LABEL_52;\n      v9 = *(_DWORD *)(dword_80DBB8C + 472);\n      if ( v9 )\n      {\nLABEL_24:\n        v10 = sub_8071998(v9, v9 >> 31);\n        goto LABEL_55;\n      }\n      return -1;\n    }\n    if ( v8 == 36 )\n    {\n      v9 = *(_DWORD *)(dword_80DBB8C + 4);\n      goto LABEL_24;\n    }\n    if ( v8 != 42 )\n      goto LABEL_52;\n    if ( v4 )\n      v7 = 0;\nLABEL_37:\n    v16 = 32;\n    if ( (*(_BYTE *)(dword_80DBB90 + 188) & 0x20) == 0 )\n      v16 = *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB90 + 192) + 4);\n    v7 |= v16;\nLABEL_40:\n    v25[0] = v7;\n    *a4 = (_BYTE)v7 == 0;\n    v17 = *(_DWORD **)(dword_80DBB90 + 16);\n    if ( v17 )\n    {\n      v10 = 0;\n      while ( 1 )\n      {\n        s = (char *)*v17++;\n        if ( !s )\n          break;\n        v24 = strlen(s);\n        sub_80718D9((int)s, v24, v21, v6);\n        v10 += v24;\n        if ( *v17 && v7 )\n        {\n          ++v10;\n          sub_80718D9((int)v25, 1u, v21, v6);\n        }\n      }\n      goto LABEL_55;\n    }\n    return -1;\n  }\n  if ( v8 == 63 )\n  {\n    v9 = *(unsigned __int8 *)dword_80DBB8C;\n    goto LABEL_24;\n  }\n  if ( v8 > 0x3Fu )\n  {\n    if ( v8 != 64 )\n      goto LABEL_52;\n    if ( v4 && ((a3 << 8) & 0x100) != 0 )\n      goto LABEL_40;\n    goto LABEL_37;\n  }\n  if ( (unsigned __int8)(v8 - 48) > 9u )\n  {\nLABEL_52:\n    v19 = sub_8072EED(a1);\n    goto LABEL_53;\n  }\n  v18 = atoi((const char *)a1);\n  if ( v18 < 0 || *(_DWORD *)dword_80DBB90 < v18 )\n    return -1;\n  if ( v18 )\n    v19 = *(char **)(*(_DWORD *)(dword_80DBB90 + 16) + 4 * v18 - 4);\n  else\n    v19 = *(char **)(dword_80DBB8C + 28);\nLABEL_53:\n  if ( !v19 )\n    return -1;\n  v10 = strlen(v19);\n  sub_80718D9((int)v19, v10, v21, v6);\nLABEL_55:\n  if ( v23 )\n    dword_80DB6D4 -= v10;\n  return v10;\n}\n"
        ],
        "134689626": [
            "sub_807335A",
            "0x807335a",
            "void __noreturn sub_807335A()\n{\n  void *retaddr; // [esp+1Ch] [ebp+0h]\n\n  retaddr = 0;\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134689856": [
            "sub_8073440",
            "0x8073440",
            "int __usercall sub_8073440@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ebp\n  unsigned int v4; // eax\n  _BYTE *v5; // edi\n  int v6; // eax\n  int v7; // ebx\n  const char *v8; // eax\n  const char *v9; // edx\n  char v10; // cl\n  int v11; // edi\n  int v12; // ebx\n  _BYTE *v13; // edx\n  char *v14; // eax\n  const char *v15; // edx\n  char *v16; // eax\n  signed int v17; // ebp\n  const char *v18; // eax\n  int v19; // eax\n  const char *v21; // [esp+0h] [ebp-20h]\n  const char *v22; // [esp+0h] [ebp-20h]\n  const char **v23; // [esp+4h] [ebp-1Ch]\n  int v24; // [esp+8h] [ebp-18h]\n  char v25[18]; // [esp+Eh] [ebp-12h] BYREF\n\n  if ( a1 <= 2 )\n    sub_806FB57(\"usage: getopts optstring var [arg]\");\n  v2 = dword_80DBB90;\n  if ( a1 == 3 )\n  {\n    v3 = *(_DWORD *)(dword_80DBB90 + 16);\n    v4 = *(_DWORD *)dword_80DBB90 + 1;\n  }\n  else\n  {\n    v3 = a2 + 12;\n    v4 = a1 - 2;\n  }\n  if ( v4 < *(_DWORD *)(dword_80DBB90 + 4) )\n  {\n    *(_DWORD *)(dword_80DBB90 + 4) = 1;\n    *(_DWORD *)(v2 + 8) = -1;\n  }\n  v24 = *(_DWORD *)(a2 + 8);\n  v5 = *(_BYTE **)(a2 + 4);\n  v6 = *(_DWORD *)(v2 + 4);\n  v7 = *(_DWORD *)(v2 + 8);\n  v25[1] = 0;\n  *(_DWORD *)(v2 + 4) = -1;\n  v23 = (const char **)(v3 + 4 * v6 - 4);\n  if ( v6 <= 1\n    || v7 < 0\n    || (v21 = *(const char **)(v3 + 4 * v6 - 8), v7 > (int)strlen(v21))\n    || (v8 = &v21[v7]) == 0\n    || !*v8 )\n  {\n    v9 = *v23;\n    if ( !*v23 || *v9 != 45 || (v8 = v9 + 1, (v10 = v9[1]) == 0) || (++v23, v10 == 45) && !v9[2] )\n    {\n      sub_806FDFD((int)\"OPTARG\");\n      v11 = 1;\n      LOBYTE(v12) = 63;\nLABEL_46:\n      v22 = 0;\n      goto LABEL_49;\n    }\n  }\n  v22 = v8 + 1;\n  v12 = *(unsigned __int8 *)v8;\n  v13 = v5;\n  while ( (_BYTE)v12 != *v13 )\n  {\n    if ( !*v13 )\n    {\n      v14 = sub_8072EED(\"OPTERR\");\n      if ( v14 && *v14 == 48 && !v14[1] || *v5 == 58 )\n      {\n        v25[0] = v12;\n        sub_806FE06((int)\"OPTARG\", v25);\n      }\n      else\n      {\n        fprintf(stderr, \"Illegal option -%c\\n\", v12);\n        sub_806FDFD((int)\"OPTARG\");\n      }\n      goto LABEL_28;\n    }\n    if ( v13[1] == 58 )\n      v13 += 2;\n    else\n      ++v13;\n  }\n  if ( v13[1] == 58 )\n  {\n    v15 = *v23;\n    if ( v8[1] )\n    {\n      if ( v15 != v22 )\n      {\nLABEL_45:\n        sub_806FE06((int)\"OPTARG\", v22);\n        v11 = 0;\n        goto LABEL_46;\n      }\n    }\n    else\n    {\n      if ( !v15 )\n      {\n        v16 = sub_8072EED(\"OPTERR\");\n        if ( (!v16 || *v16 != 48 || v16[1]) && *v5 != 58 )\n        {\n          fprintf(stderr, \"No arg for -%c option\\n\", v12);\n          sub_806FDFD((int)\"OPTARG\");\n          v22 = 0;\nLABEL_28:\n          v11 = 0;\n          LOBYTE(v12) = 63;\n          goto LABEL_49;\n        }\n        v25[0] = v12;\n        sub_806FE06((int)\"OPTARG\", v25);\n        LOBYTE(v12) = 58;\n        v22 = 0;\n        goto LABEL_48;\n      }\n      v22 = *v23;\n    }\n    ++v23;\n    goto LABEL_45;\n  }\n  sub_806FE06((int)\"OPTARG\", (const char *)(dword_80DBB8C + 44));\nLABEL_48:\n  v11 = 0;\nLABEL_49:\n  v17 = (((int)v23 - v3) >> 2) + 1;\n  v18 = sub_804D70F(v17);\n  sub_806FCE2((int)\"OPTIND\", v18, 64);\n  v25[0] = v12;\n  sub_806FE06(v24, v25);\n  v19 = -1;\n  if ( v22 )\n    v19 = v22 - *(v23 - 1);\n  *(_DWORD *)(v2 + 8) = v19;\n  *(_DWORD *)(v2 + 4) = v17;\n  return v11;\n}\n"
        ],
        "134690464": [
            "sub_80736A0",
            "0x80736a0",
            "void __noreturn sub_80736A0()\n{\n  sub_8070322();\n}\n"
        ],
        "134691154": [
            "sub_8073952",
            "0x8073952",
            "int sub_8073952()\n{\n  _DWORD *v0; // eax\n  int v1; // edx\n  int result; // eax\n  int v3; // edx\n  unsigned __int8 *v4; // edx\n  _DWORD *v5; // edx\n  int v6; // ecx\n  char v7; // dl\n  signed int v8; // ebx\n  _WORD *v9; // edi\n  int v10; // ebp\n  char *v11; // eax\n  int v12; // esi\n  int v13; // eax\n  int v14; // eax\n  _DWORD *v15; // edi\n  char *v16; // esi\n  int v17; // eax\n  char v18; // bl\n  unsigned __int8 *v19; // eax\n  _DWORD *v20; // edx\n  int v21; // [esp-14h] [ebp-14h]\n\n  v0 = off_80DB55C;\n  v1 = *((_DWORD *)off_80DB55C + 18);\n  if ( v1 )\n  {\n    *((_DWORD *)off_80DB55C + 18) = v1 - 1;\n    return v0[v1 + 15];\n  }\n  v3 = *((_DWORD *)off_80DB55C + 3) - 1;\n  *((_DWORD *)off_80DB55C + 3) = v3;\n  if ( v3 >= 0 )\n  {\n    v4 = (unsigned __int8 *)v0[5];\n    v0[5] = v4 + 1;\n    result = *v4;\n    v5 = off_80DB55C;\n    *((_DWORD *)off_80DB55C + 17) = *((_DWORD *)off_80DB55C + 16);\n    v5[16] = result;\n    return result;\n  }\n  v6 = v0[7];\n  if ( v6 )\n  {\n    if ( v3 != -1 || !*(_DWORD *)(v6 + 12) || (v7 = *(_BYTE *)(v0[5] - 1), v7 == 32) || (result = 257, v7 == 9) )\n    {\n      sub_806F659();\n      result = sub_8073952();\n    }\n  }\n  else\n  {\n    if ( v3 >= -90 && v0[6] )\n    {\n      v8 = v0[4];\n      if ( v8 > 0 )\n      {\nLABEL_33:\n        v15 = off_80DB55C;\n        v16 = (char *)*((_DWORD *)off_80DB55C + 5);\n        do\n        {\n          --v8;\n          if ( *v16 )\n          {\n            if ( *v16 == 10 )\n            {\n              v15[3] = &v16[-v15[5]];\n              ++v16;\n              goto LABEL_41;\n            }\n            ++v16;\n          }\n          else\n          {\n            memmove(v16, v16 + 1, v8);\n          }\n        }\n        while ( v8 );\n        v17 = (int)&v16[-v15[5] - 1];\n        v15[3] = v17;\n        if ( v17 < 0 )\n          goto LABEL_15;\nLABEL_41:\n        v15[4] = v8;\n        if ( *(_BYTE *)(dword_80DBB8C + 53) )\n        {\n          v18 = *v16;\n          *v16 = 0;\n          sub_8070BC7(v15[5]);\n          *v16 = v18;\n        }\n        v19 = (unsigned __int8 *)*((_DWORD *)off_80DB55C + 5);\n        *((_DWORD *)off_80DB55C + 5) = v19 + 1;\n        result = *v19;\n        goto LABEL_44;\n      }\n      sub_806F4BD();\nLABEL_15:\n      v9 = (_WORD *)*((_DWORD *)off_80DB55C + 6);\n      *((_DWORD *)off_80DB55C + 5) = v9;\n      while ( 1 )\n      {\n        v10 = dword_80DBB8C;\n        if ( !*(_BYTE *)(dword_80DBB8C + 48) || *((_DWORD *)off_80DB55C + 2) )\n        {\n          v8 = sub_80B2319(0x3FFu, v9);\n          if ( v8 > 0 )\n            goto LABEL_33;\n          goto LABEL_31;\n        }\n        v11 = sub_8072EED(\"TMOUT\");\n        v12 = -1;\n        if ( v11 )\n        {\n          v12 = 1000 * atoi(v11);\n          if ( v12 <= 0 )\n            v12 = -1;\n        }\n        v13 = dword_80DB6F8;\n        *(_DWORD *)(dword_80DB6F8 + 4) = v12;\n        *(_DWORD *)(v13 + 8) = *(_DWORD *)(dword_80DBB90 + 208) + 5;\n        v14 = sub_80AED5C(1024);\n        v8 = v14;\n        if ( v14 )\n          break;\n        write(1, \"^C\", 2u);\n        if ( *(_DWORD *)(v10 + 200) )\n        {\n          *v9 = 10;\n          raise(2);\n          v8 = 1;\n          goto LABEL_33;\n        }\n        *(_BYTE *)v10 = -126;\n        sub_804DD98(10);\n      }\n      if ( v14 >= 0 )\n        goto LABEL_33;\n      if ( *(_DWORD *)dword_80DBB7C == 11 && v12 > 0 )\n      {\n        puts(\"\\atimed out waiting for input: auto-logout\");\n        sub_80769A1(v21);\n      }\nLABEL_31:\n      v0 = off_80DB55C;\n      *((_DWORD *)off_80DB55C + 3) = -99;\n    }\n    ++v0[5];\n    result = 256;\n  }\nLABEL_44:\n  v20 = off_80DB55C;\n  *((_DWORD *)off_80DB55C + 17) = *((_DWORD *)off_80DB55C + 16);\n  v20[16] = result;\n  return result;\n}\n"
        ],
        "134691719": [
            "sub_8073B87",
            "0x8073b87",
            "int sub_8073B87()\n{\n  int result; // eax\n\n  do\n    result = sub_8073952();\n  while ( result == 257 );\n  return result;\n}\n"
        ],
        "134691732": [
            "sub_8073B94",
            "0x8073b94",
            "int __fastcall sub_8073B94(int a1)\n{\n  int result; // eax\n  int v2; // ebx\n  int v3; // eax\n  char *v4; // eax\n  int v5; // esi\n  int v6; // edx\n  int v7; // esi\n\n  if ( byte_80DB76A )\n  {\n    byte_80DB76A = 0;\n    return byte_80DB768;\n  }\n  sub_8074B7B(a1, 2);\n  while ( 1 )\n  {\n    do\n    {\n      do\n        v2 = sub_8074C1E();\n      while ( v2 == 32 || v2 == 9 );\n    }\n    while ( v2 == 257 );\n    if ( v2 != 35 )\n      break;\n    do\n      v3 = sub_8073952();\n    while ( v3 != 10 && v3 != 256 );\n    sub_806EE06();\n  }\n  if ( v2 != 92 )\n  {\n    if ( v2 == 256 )\n    {\n      v5 = 135073155;\n      goto LABEL_22;\n    }\n    if ( v2 == 10 )\n      sub_806EDF3();\n    v4 = strchr(\"\\n()&|;\", v2);\n    v5 = (int)v4;\n    if ( v4 )\n    {\n      if ( v4 - \"\\n()&|;\" <= 2 )\n      {\nLABEL_22:\n        v7 = v5 - (_DWORD)\"\\n()&|;\";\n        result = byte_80D0D73[v7];\n        byte_80DB768 = byte_80D0D73[v7];\n        return result;\n      }\n      if ( v2 == sub_8074C1E() )\n      {\n        v5 += 4;\n        goto LABEL_22;\n      }\n      sub_806EE06();\n      if ( v2 != 38 || v6 != 62 )\n        goto LABEL_22;\n    }\n  }\n  return sub_8073F3E(0);\n}\n"
        ],
        "134691962": [
            "sub_8073C7A",
            "0x8073c7a",
            "int __fastcall sub_8073C7A(int a1)\n{\n  char v1; // si\n  int v2; // ebx\n  int v3; // ecx\n  _BYTE *v4; // eax\n  int v5; // edx\n  const char *v6; // eax\n\n  v1 = byte_80DB76B;\n  while ( 1 )\n  {\n    v2 = sub_8073B94(a1);\n    if ( (v1 & 4) != 0 )\n    {\n      while ( v2 == 1 )\n      {\n        sub_8076C18();\n        v2 = sub_8073B94(v3);\n      }\n    }\n    if ( v2 != 3 || byte_80DB769 )\n      break;\n    if ( (v1 & 2) != 0 )\n    {\n      v4 = sub_8070CCB(dword_80DB68C);\n      if ( v4 )\n      {\n        v2 = (v4 - (_BYTE *)&off_80B5EE0) >> 2;\n        byte_80DB768 = v2;\n        break;\n      }\n    }\n    if ( (byte_80DB76B & 1) == 0 )\n      break;\n    v5 = *sub_806F0C2(dword_80DB68C);\n    if ( !v5 || (*(_BYTE *)(v5 + 12) & 1) != 0 )\n      break;\n    v6 = *(const char **)(v5 + 8);\n    if ( *v6 )\n      sub_806F78A(v6, v5);\n  }\n  byte_80DB76B = 0;\n  return v2;\n}\n"
        ],
        "134692119": [
            "sub_8073D17",
            "0x8073d17",
            "_DWORD *__fastcall sub_8073D17(int a1)\n{\n  int v1; // ebx\n  _DWORD *v2; // esi\n  _DWORD *result; // eax\n  char *v4; // esi\n\n  v1 = dword_80DB684;\n  if ( *(_BYTE *)dword_80DB684 == 24 )\n    byte_80DB76B = 8;\n  if ( sub_8073C7A(a1) != 3 )\n    sub_807275C(-1);\n  if ( *(_BYTE *)v1 == 24 )\n  {\n    v2 = (_DWORD *)dword_80DB680;\n    if ( !byte_80DB769 )\n      *(_BYTE *)v1 = 25;\n    sub_80719CE(dword_80DB68C, 0, 0);\n    v2[2] = dword_80DB68C;\n    *v2 = 0;\n    result = (_DWORD *)dword_80DB690;\n    if ( dword_80DB690 )\n    {\n      while ( *result )\n        result = (_DWORD *)*result;\n      *result = v2;\n    }\n    else\n    {\n      dword_80DB690 = (int)v2;\n    }\n  }\n  else\n  {\n    if ( (unsigned __int8)(*(_BYTE *)v1 - 22) > 1u )\n      goto LABEL_20;\n    v4 = dword_80DB68C;\n    *(_DWORD *)(v1 + 16) = 0;\n    result = (_DWORD *)sub_804ED6C(10, v4, 0, v1);\n    if ( !*(_DWORD *)dword_80DBB7C && (int)result >= 0 )\n    {\n      *(_DWORD *)(v1 + 12) = result;\n      return result;\n    }\n    if ( *v4 != 45 || v4[1] )\n    {\nLABEL_20:\n      result = sub_8070C69();\n      *(_DWORD *)(v1 + 16) = result;\n    }\n    else\n    {\n      *(_DWORD *)(v1 + 12) = -1;\n    }\n  }\n  return result;\n}\n"
        ],
        "134692325": [
            "sub_8073DE5",
            "0x8073de5",
            "_BYTE *__usercall sub_8073DE5@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int v3; // ebx\n  int v4; // eax\n  int v5; // ecx\n  _DWORD *i; // eax\n  int v7; // ecx\n  int v8; // eax\n  int v9; // edx\n  char v10; // si\n  _BYTE *v11; // ebp\n  int v12; // eax\n  int v13; // ecx\n  int v14; // esi\n  _DWORD *v15; // eax\n  _DWORD *v16; // eax\n  int v18; // [esp+4h] [ebp-14h]\n\n  v3 = 0;\n  while ( 2 )\n  {\n    v4 = sub_8073C7A(a2);\n    byte_80DB76A = 1;\n    if ( !v4 )\n    {\n      if ( !v3 )\n        v3 = -(a1 & 1);\nLABEL_8:\n      sub_8076C18();\n      return (_BYTE *)v3;\n    }\n    if ( v4 == 1 && (a1 & 1) != 0 )\n      goto LABEL_8;\n    byte_80DB76B = 7;\n    if ( a1 == 2 )\n    {\n      v8 = sub_8073C7A(v5);\n      byte_80DB76A = 1;\n      v9 = 572496897;\n      if ( _bittest(&v9, v8) )\n        return (_BYTE *)v3;\n    }\n    for ( i = (_DWORD *)sub_8077325(); ; i[2] = v18 )\n    {\n      v11 = i;\n      v12 = sub_8073C7A(v7);\n      if ( v12 == 6 )\n      {\n        v10 = 5;\n        goto LABEL_14;\n      }\n      if ( v12 != 7 )\n        break;\n      v10 = 6;\nLABEL_14:\n      byte_80DB76B = 7;\n      v18 = sub_8077325();\n      i = sub_8070C51(0xCu);\n      *(_BYTE *)i = v10;\n      i[1] = v11;\n      v7 = v18;\n    }\n    byte_80DB76A = 1;\n    v14 = sub_8073C7A(v13);\n    if ( v14 == 5 )\n    {\n      if ( *v11 == 1 )\n      {\n        v11[1] = 1;\n      }\n      else\n      {\n        if ( *v11 != 2 )\n        {\n          v15 = sub_8070C51(0x10u);\n          v15[2] = v11;\n          v11 = v15;\n        }\n        *v11 = 3;\n      }\n      if ( v3 )\n      {\nLABEL_26:\n        v16 = sub_8070C51(0xCu);\n        *(_BYTE *)v16 = 7;\n        v16[1] = v3;\n        v16[2] = v11;\n        v11 = v16;\n        goto LABEL_27;\n      }\n      goto LABEL_30;\n    }\n    if ( v3 )\n      goto LABEL_26;\nLABEL_27:\n    if ( v14 < 0 )\n      goto LABEL_32;\n    if ( v14 <= 1 )\n    {\n      byte_80DB76A = 1;\nLABEL_30:\n      v3 = (int)v11;\n      a1 |= 2u;\n      continue;\n    }\n    break;\n  }\n  if ( (unsigned int)(v14 - 4) <= 1 )\n    goto LABEL_30;\nLABEL_32:\n  if ( (a1 & 1) != 0 )\n    sub_807275C(-1);\n  byte_80DB76A = 1;\n  return v11;\n}\n"
        ],
        "134692670": [
            "sub_8073F3E",
            "0x8073f3e",
            "int __usercall sub_8073F3E@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4)\n{\n  _BYTE *v5; // ecx\n  _BYTE *v6; // edi\n  unsigned __int8 *i; // ebx\n  int v8; // eax\n  _BYTE *v9; // eax\n  int v10; // edi\n  _BOOL4 v11; // edx\n  int v12; // edi\n  void *v13; // esp\n  int v14; // ebx\n  int v15; // eax\n  int v16; // ecx\n  int v17; // esi\n  char v18; // al\n  int v19; // edi\n  char v20; // al\n  int v21; // eax\n  int v22; // edx\n  int v23; // eax\n  int v24; // eax\n  char v25; // dl\n  int v26; // eax\n  int v27; // eax\n  int v28; // ecx\n  int v29; // eax\n  int v30; // eax\n  const char *v31; // eax\n  char *v32; // edi\n  int v33; // ebx\n  int v35; // ebx\n  _DWORD *v36; // eax\n  int v37; // ecx\n  _DWORD *v38; // edi\n  int v39; // eax\n  int v40; // eax\n  int v41; // ecx\n  int v42; // eax\n  int v43; // ecx\n  int v44; // edi\n  int v45; // edx\n  int v46; // ecx\n  int v47; // esi\n  int v48; // ecx\n  int v49; // eax\n  int v50; // ecx\n  int v51; // ecx\n  int v52; // edx\n  int v53; // eax\n  char *v54; // eax\n  _BYTE *v55; // edx\n  int v56; // eax\n  int v57; // eax\n  unsigned int v58; // ebx\n  void *v59; // esp\n  int v60; // ecx\n  int v61; // eax\n  int v62; // esi\n  int v63; // eax\n  _BYTE *v64; // ecx\n  _BYTE *v65; // edx\n  const char *v66; // eax\n  int *v67; // eax\n  int *v68; // esi\n  int v69; // ecx\n  char v70; // dl\n  int v71; // ecx\n  _BYTE *v72; // edi\n  _BYTE *v73; // eax\n  _BYTE *v74; // edx\n  int v75; // eax\n  _BYTE v76[40]; // [esp-28h] [ebp-78h] BYREF\n  int v77; // [esp+0h] [ebp-50h]\n  int v78; // [esp+4h] [ebp-4Ch]\n  const void **v79; // [esp+8h] [ebp-48h] BYREF\n  char v80; // [esp+Eh] [ebp-42h]\n  char v81; // [esp+Fh] [ebp-41h]\n  _BYTE *v82; // [esp+10h] [ebp-40h]\n  unsigned int v83; // [esp+14h] [ebp-3Ch]\n  int v84; // [esp+18h] [ebp-38h]\n  char *v85; // [esp+1Ch] [ebp-34h]\n  int *v86; // [esp+20h] [ebp-30h] BYREF\n  char *v87; // [esp+24h] [ebp-2Ch]\n  char v88; // [esp+28h] [ebp-28h] BYREF\n  char v89; // [esp+29h] [ebp-27h] BYREF\n  char v90[36]; // [esp+2Ch] [ebp-24h] BYREF\n\n  v78 = a2;\n  v83 = a3;\n  memset(v90, 0, 0x18u);\n  v5 = 0;\n  if ( a2 == 4 )\n  {\n    v90[0] = 1;\nLABEL_4:\n    v90[1] |= 4u;\n    goto LABEL_5;\n  }\n  v90[0] = v78;\n  if ( v78 == 1 )\n    goto LABEL_4;\nLABEL_5:\n  v86 = 0;\n  v6 = *(_BYTE **)(dword_80DBB88 + 4);\n  v85 = v90;\n  v80 = 0;\n  v81 = 0;\n  while ( 2 )\n  {\n    if ( v83 > 1 )\n    {\n      if ( a1 == 257 )\n        a1 = sub_8073B87();\n      if ( a4 )\n      {\n        while ( a1 == 9 )\n          a1 = sub_8073B87();\n      }\n      v84 = (int)&v6[-*(_DWORD *)(dword_80DBB88 + 4)];\n      for ( i = (unsigned __int8 *)v83; ; ++i )\n      {\n        v6 = sub_8071CD6(a1, v6);\n        v8 = *i;\n        if ( !(_BYTE)v8 )\n          break;\n        if ( v8 != a1 )\n          goto LABEL_19;\n        a1 = sub_8073B87();\n      }\n      if ( a1 == 256 || a1 == 10 )\n      {\n        ++*((_DWORD *)off_80DB55C + 1);\n        byte_80DB76E = byte_80DB76F;\n        a1 = 256;\n        goto LABEL_22;\n      }\nLABEL_19:\n      v5 = (_BYTE *)v84;\n      v9 = (_BYTE *)(*(_DWORD *)(dword_80DBB88 + 4) + v84 + 1);\n      v10 = v6 - v9;\n      if ( v10 )\n      {\n        v11 = a1 > 255;\n        a1 = *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB88 + 4) + v84);\n        v12 = v10 - v11;\n        if ( v12 )\n        {\n          v13 = alloca(v12 + 16);\n          *(_BYTE *)mempcpy(&v79, v9, v12) = 0;\n          sub_806F78A((const char *)&v79, 0);\n        }\n      }\nLABEL_22:\n      v6 = (_BYTE *)(*(_DWORD *)(dword_80DBB88 + 4) + v84);\n    }\n    v14 = (int)v6;\nLABEL_24:\n    v84 = *(_DWORD *)(dword_80DBB88 + 8);\n    if ( (unsigned int)(v84 - v14) <= 3 )\n      v14 = sub_80716AF(4u, v14);\n    LOBYTE(v84) = *v85;\n    v15 = sub_806EEFB(a1, v84, (int)v5);\n    LOBYTE(v16) = v84;\n    switch ( v15 )\n    {\n      case 0:\n        goto LABEL_111;\n      case 1:\n        if ( !(_BYTE)v84 && !*((_DWORD *)v85 + 1) )\n          goto LABEL_114;\n        v6 = (_BYTE *)(v14 + 1);\n        *(_BYTE *)v14 = a1;\n        sub_8074C05(v16);\n        a1 = sub_8073952();\n        continue;\n      case 2:\n        v21 = sub_8073B87();\n        if ( v21 == 256 )\n        {\n          *(_WORD *)v14 = 23681;\n          sub_806EE06();\n          v14 = v22;\n          goto LABEL_113;\n        }\n        if ( v21 == 10 )\n        {\n          ((void (*)(void))sub_8074C05)();\n          goto LABEL_113;\n        }\n        if ( v78 == 4 && v21 == 36 )\n        {\n          *(_WORD *)v14 = 23681;\n          v14 += 2;\n        }\n        LOBYTE(v84) = v85[1];\n        if ( ((v21 != 36) & ((unsigned __int8)v84 >> 2)) == 0 || ((v21 - 92) & 0xFFFFFFFB) == 0 )\n          goto LABEL_75;\n        if ( v21 == 34 )\n        {\n          if ( !v83 )\n            goto LABEL_75;\n        }\n        else if ( v21 != 125 )\n        {\n          goto LABEL_74;\n        }\n        if ( *((_DWORD *)v85 + 1) )\n          goto LABEL_75;\nLABEL_74:\n        *(_WORD *)v14 = 23681;\n        v14 += 2;\nLABEL_75:\n        *(_BYTE *)v14 = -127;\n        *(_BYTE *)(v14 + 1) = v21;\n        v14 += 2;\n        goto LABEL_104;\n      case 3:\n        *v85 = 2;\n        goto LABEL_77;\n      case 4:\n        v23 = (int)v85;\n        *v85 = 1;\n        *(_BYTE *)(v23 + 1) |= 4u;\n        goto LABEL_80;\n      case 5:\n        if ( !v83 || *((_DWORD *)v85 + 1) )\n        {\n          v24 = (int)v85;\n          if ( !*((_DWORD *)v85 + 2) )\n          {\n            *v85 = 0;\n            *(_BYTE *)(v24 + 1) &= ~4u;\n          }\n          v80 = 0;\n          v81 = 1;\n          if ( a1 == 34 )\n          {\nLABEL_80:\n            if ( *((_DWORD *)v85 + 1) )\n              v85[1] = !(v85[1] & 1) | v85[1] & 0xFE;\n          }\nLABEL_77:\n          if ( !v83 )\n          {\n            *(_BYTE *)v14 = -120;\n            goto LABEL_112;\n          }\n        }\n        else\n        {\n          *(_BYTE *)v14++ = a1;\n          v80 = 0;\n        }\n        goto LABEL_113;\n      case 6:\n        if ( (byte_80DB76B & 8) == 0 )\n        {\n          LOBYTE(v82) = 1;\n          goto LABEL_233;\n        }\n        *(_BYTE *)v14++ = 96;\nLABEL_104:\n        v81 = 1;\n        goto LABEL_113;\n      case 7:\n        v42 = sub_8074C1E(v16);\n        v44 = v42;\n        if ( (byte_80DB76B & 8) != 0 || v42 > 255 )\n          goto LABEL_161;\n        if ( v42 != 40 )\n        {\n          if ( v42 != 123 && v42 != 95 && (unsigned __int8)((v42 | 0x20) - 97) > 0x19u )\n          {\n            if ( (unsigned int)(v42 - 33) > 0x1F || (v45 = -1040215539, !_bittest(&v45, v42 - 33)) )\n            {\nLABEL_161:\n              if ( *v85 != 1 && v42 == 39 )\n                v80 = 1;\n              else\n                *(_BYTE *)v14++ = 36;\n              sub_806EE06();\n              goto LABEL_113;\n            }\n          }\n          LOBYTE(v84) = *v85;\n          *(_BYTE *)v14 = -126;\n          v46 = dword_80DBB88;\n          v79 = (const void **)(v14 + 1 - *(_DWORD *)(dword_80DBB88 + 4));\n          v82 = (_BYTE *)(v14 + 2);\n          v47 = 1;\n          if ( v42 == 123 )\n          {\n            v44 = sub_8074C1E(dword_80DBB88);\n            v47 = 0;\n          }\n          while ( 1 )\n          {\n            if ( v44 == 95 || (unsigned __int8)((v44 | 0x20) - 97) <= 0x19u )\n              goto LABEL_174;\n            if ( (unsigned __int8)(v44 - 48) <= 9u )\n            {\n              do\n              {\n                v82 = sub_8071CD6(v44, v82);\n                v44 = sub_8074C1E(v51);\n              }\n              while ( (unsigned __int8)(v44 - 48) <= 9u );\n              goto LABEL_195;\n            }\n            v52 = sub_8074C1E(v46);\n            if ( (_BYTE)v47 || v44 != 35 )\n              goto LABEL_190;\n            if ( v52 == 95 )\n              break;\n            if ( (unsigned __int8)(v52 - 48) > 9u && (unsigned __int8)((v52 | 0x20) - 97) > 0x19u )\n            {\n              v77 = v52;\n              v53 = sub_8074C1E(v46);\n              if ( v77 != 125 && v53 == 125 )\n              {\n                v44 = v77;\n                v47 = 10;\n                v52 = 125;\n              }\n              else\n              {\n                sub_806EE06();\n                v52 = v77;\n              }\nLABEL_190:\n              if ( (unsigned int)(v44 - 33) <= 0x1F )\n              {\n                v50 = -1040215539;\n                if ( _bittest(&v50, v44 - 33) )\n                {\n                  v82 = (_BYTE *)(v14 + 3);\n                  *(_BYTE *)(v14 + 2) = v44;\n                  v44 = v52;\n                  goto LABEL_195;\n                }\n              }\n              if ( (_BYTE)v47 == 10 )\n                LOBYTE(v47) = 0;\nLABEL_218:\n              sub_806EE06();\nLABEL_219:\n              if ( (_BYTE)v84 == 3 )\n                LOBYTE(v84) = 1;\nLABEL_222:\n              if ( (*v85 != (_BYTE)v84 || (v85[1] & 1) != 0) && (_BYTE)v47 != 1 )\n              {\n                v55 = (_BYTE *)*((_DWORD *)v85 + 4);\n                if ( !v55 )\n                  v55 = v76;\n                memset(v55, 0, 0x14u);\n                *v55 = v84;\n                v56 = (int)v85;\n                *((_DWORD *)v55 + 5) = v85;\n                *(_DWORD *)(v56 + 16) = v55;\n                v55[1] = (4 * ((_BYTE)v84 != 0)) | v55[1] & 0xF9 | 2;\n                v85 = v55;\n              }\n              *((_BYTE *)v79 + *(_DWORD *)(dword_80DBB88 + 4)) = v47;\n              if ( (_BYTE)v47 != 1 )\n              {\n                v57 = (int)v85;\n                ++*((_DWORD *)v85 + 1);\n                if ( (*(_BYTE *)(v57 + 1) & 4) != 0 )\n                  ++*(_DWORD *)(v57 + 8);\n              }\n              v14 = (int)sub_8071CD6(61, v82);\n              goto LABEL_113;\n            }\n            v47 = 10;\n            v44 = v52;\n          }\n          LOBYTE(v44) = 95;\n          v47 = 10;\n          do\n          {\n            do\n            {\nLABEL_174:\n              v82 = sub_8071CD6(v44, v82);\n              v49 = sub_8074C1E(v48);\n              v44 = v49;\n            }\n            while ( v49 == 95 );\n          }\n          while ( (unsigned __int8)(v49 - 48) <= 9u || (unsigned __int8)((v49 | 0x20) - 97) <= 0x19u );\nLABEL_195:\n          if ( v44 != 125 && (_BYTE)v47 == 10 )\n          {\n            LOBYTE(v47) = 10;\n            goto LABEL_218;\n          }\n          if ( (_BYTE)v47 )\n            goto LABEL_218;\n          if ( v44 != 37 )\n          {\n            if ( v44 > 37 )\n            {\n              if ( v44 != 47 )\n              {\n                if ( v44 == 58 )\n                {\n                  v44 = sub_8074C1E(v50);\n                  if ( !strchr(\"}-+?=\", v44) )\n                  {\n                    sub_806EE06();\n                    LOBYTE(v47) = 12;\n                    goto LABEL_219;\n                  }\n                  v47 = 16;\n                }\n                goto LABEL_207;\n              }\n              if ( sub_8074C1E(v50) != 47 )\n              {\n                LOBYTE(v84) = 0;\n                LOBYTE(v47) = 13;\n                goto LABEL_218;\n              }\n              LOBYTE(v47) = 14;\n            }\n            else\n            {\n              if ( v44 != 35 )\n              {\nLABEL_207:\n                v54 = strchr(\"}-+?=\", v44);\n                if ( v54 )\n                  v47 |= v54 - \"}-+?=\" + 1;\n                goto LABEL_219;\n              }\n              LOBYTE(v47) = 8;\nLABEL_211:\n              if ( v44 == sub_8074C1E(v50) )\n                LOBYTE(v47) = v47 + 1;\n              else\n                sub_806EE06();\n            }\n            LOBYTE(v84) = 0;\n            goto LABEL_222;\n          }\n          LOBYTE(v47) = 6;\n          goto LABEL_211;\n        }\n        if ( sub_8074C1E(v43) == 40 )\n        {\n          v74 = (_BYTE *)*((_DWORD *)v85 + 4);\n          if ( !v74 )\n            v74 = v76;\n          memset(v74, 0, 0x14u);\n          *v74 = 3;\n          v75 = (int)v85;\n          *((_DWORD *)v74 + 5) = v85;\n          *(_DWORD *)(v75 + 16) = v74;\n          v74[1] |= 4u;\n          *(_BYTE *)v14 = -122;\n          v85 = v74;\n          goto LABEL_112;\n        }\n        sub_806EE06();\n        LOBYTE(v82) = 0;\nLABEL_233:\n        v84 = *(_DWORD *)(dword_80DBB88 + 4);\n        v79 = 0;\n        v58 = v14 - v84;\n        if ( v58 )\n        {\n          v59 = alloca(v58 + 15);\n          v79 = (const void **)&v79;\n          qmemcpy(&v79, (const void *)v84, v58);\n          v16 = 0;\n        }\n        if ( (_BYTE)v82 )\n        {\n          while ( 1 )\n          {\n            sub_8074B7B(v16, 2);\n            v61 = sub_8074C1E(v60);\n            LOBYTE(v62) = v61;\n            if ( v61 == 96 )\n              break;\n            if ( v61 > 96 )\n            {\n              if ( (unsigned int)(v61 - 256) <= 1 )\n                goto LABEL_250;\n            }\n            else if ( v61 == 10 )\n            {\n              sub_806EDF3();\n            }\n            else if ( v61 == 92 )\n            {\n              v63 = sub_8073952();\n              v62 = v63;\n              if ( v63 != 92 )\n              {\n                if ( v63 != 96 && v63 != 36 && ((v85[1] & 4) == 0 || v63 != 34) )\n                  v84 = (int)sub_8071CD6(92, (_BYTE *)v84);\n                if ( v62 > 255 )\n                {\nLABEL_250:\n                  v31 = \"EOF in backquote substitution\";\nLABEL_119:\n                  sub_8070172(v31);\n                }\n              }\n            }\n            v84 = (int)sub_8071CD6(v62, (_BYTE *)v84);\n          }\n          v64 = sub_8071CD6(0, (_BYTE *)v84);\n          v65 = *(_BYTE **)(dword_80DBB88 + 4);\n          if ( v64 != v65 )\n          {\n            v66 = (const char *)sub_806FFC6(v64 - v65);\n            sub_806F74D(v66);\n          }\n        }\n        v67 = v86;\n        v68 = (int *)&v86;\n        while ( v67 )\n        {\n          v68 = v67;\n          v67 = (int *)*v67;\n        }\n        *v68 = (int)sub_8070C51(8u);\n        v70 = 0;\n        if ( (_BYTE)v82 )\n        {\n          v70 = byte_80DB76F;\n          byte_80DB76F = 0;\n        }\n        LOBYTE(v84) = v70;\n        v72 = sub_8073DE5(2, v69);\n        if ( (_BYTE)v82 )\n        {\n          byte_80DB76F = v84;\n        }\n        else if ( sub_8073C7A(v71) != 10 )\n        {\n          sub_807275C(10);\n        }\n        *(_DWORD *)(*v68 + 4) = v72;\n        if ( (_BYTE)v82 )\n        {\n          sub_806F6F7();\n          byte_80DB76A = 0;\n        }\n        while ( *(_DWORD *)(dword_80DBB88 + 12) <= v58 )\n          sub_8071623();\n        v73 = *(_BYTE **)(dword_80DBB88 + 4);\n        if ( v79 )\n        {\n          qmemcpy(v73, v79, v58);\n          v73 += v58;\n        }\n        v14 = (int)(v73 + 1);\n        *v73 = -124;\n        goto LABEL_113;\n      case 8:\n        v25 = v85[1];\n        if ( (v25 & 1) == 0 )\n        {\n          v26 = *((_DWORD *)v85 + 1);\n          if ( v26 > 0 )\n          {\n            v27 = v26 - 1;\n            v28 = (int)v85;\n            *((_DWORD *)v85 + 1) = v27;\n            if ( v27 || (v25 & 2) == 0 )\n            {\n              v29 = *((_DWORD *)v85 + 2);\n              LOBYTE(a1) = -125;\n              if ( v29 > 0 )\n                *((_DWORD *)v85 + 2) = v29 - 1;\n            }\n            else\n            {\n              v85 = *(char **)(v28 + 20);\n              LOBYTE(a1) = -125;\n            }\n          }\n        }\n        goto LABEL_111;\n      case 9:\n        ++*((_DWORD *)v85 + 3);\n        goto LABEL_111;\n      case 10:\n        v30 = *((_DWORD *)v85 + 3);\n        if ( v30 <= 0 )\n        {\n          if ( sub_8074C1E(v16) == 41 )\n          {\n            v85 = (char *)*((_DWORD *)v85 + 5);\n            LOBYTE(a1) = -121;\n          }\n          else\n          {\n            sub_806EE06();\n          }\n        }\n        else\n        {\n          *((_DWORD *)v85 + 3) = v30 - 1;\n        }\n        goto LABEL_111;\n      case 11:\n        goto LABEL_114;\n      case 12:\n        if ( a1 != 92 || !v80 )\n          goto LABEL_56;\n        a1 = sub_8073952();\n        v87 = strchr(\"nrbtfavx\\\\01234567\", a1);\n        if ( !v87 )\n        {\n          if ( a1 != 39 && a1 != 34 )\nLABEL_51:\n            LOWORD(a1) = a1 | 0x100;\n          if ( (a1 & 0x100) != 0 )\n          {\n            if ( !v83 || (v85[1] & 4) != 0 )\n              *(_BYTE *)v14++ = -127;\n            *(_BYTE *)v14++ = 92;\n          }\n          goto LABEL_56;\n        }\n        v88 = a1;\n        v87 = &v88;\n        if ( (unsigned __int8)(a1 - 48) > 7u )\n        {\n          if ( a1 == 120 )\n          {\n            v84 = 3;\n            while ( 1 )\n            {\n              v19 = v84;\n              v20 = sub_8073952();\n              *++v87 = v20;\n              if ( (unsigned __int8)(v20 - 48) > 9u && (unsigned __int8)((v20 | 0x20) - 97) > 5u )\n                break;\n              if ( !--v84 )\n              {\n                v19 = 0;\n                break;\n              }\n            }\n            sub_806EE06();\n            if ( v19 == 3 )\n              goto LABEL_51;\n          }\n          else\n          {\n            v87 = &v89;\n          }\n        }\n        else\n        {\n          v17 = 3;\n          do\n          {\n            v18 = sub_8073952();\n            *++v87 = v18;\n            if ( (unsigned __int8)(v18 - 48) > 7u )\n              break;\n            --v17;\n          }\n          while ( v17 );\n          sub_806EE06();\n        }\n        *v87 = 0;\n        v87 = &v88;\n        LOBYTE(a1) = sub_80B0CB3();\n        if ( !(_BYTE)a1 )\n          goto LABEL_113;\nLABEL_56:\n        if ( !v83 || (v85[1] & 4) != 0 || *((_DWORD *)v85 + 1) )\n          *(_BYTE *)v14++ = -127;\n        goto LABEL_111;\n      case 14:\n        goto LABEL_113;\n      default:\n        if ( *((_DWORD *)v85 + 1) )\n        {\n          if ( a1 != 257 )\n          {\nLABEL_111:\n            *(_BYTE *)v14 = a1;\nLABEL_112:\n            ++v14;\n          }\nLABEL_113:\n          a1 = sub_8073952();\n          goto LABEL_24;\n        }\n        if ( a1 == 38 )\n        {\n          if ( sub_8073952() == 62 )\n            a1 = 318;\n          sub_806EE06();\n        }\nLABEL_114:\n        if ( *v85 == 3 )\n        {\n          v31 = \"missing '))'\";\n          goto LABEL_119;\n        }\n        if ( !v83 && *v85 )\n        {\n          v31 = \"unterminated quoted string\";\n          goto LABEL_119;\n        }\n        if ( *((_DWORD *)v85 + 1) )\n        {\n          v31 = \"missing '}'\";\n          goto LABEL_119;\n        }\n        *(_BYTE *)v14 = 0;\n        v32 = *(char **)(dword_80DBB88 + 4);\n        v33 = v14 + 1 - (_DWORD)v32;\n        if ( v83 )\n        {\nLABEL_128:\n          byte_80DB769 = v81;\n          dword_80DB688 = (int)v86;\n          sub_806FFC6(v33);\n          dword_80DB68C = v32;\n          byte_80DB768 = 3;\n          return 3;\n        }\n        else\n        {\n          if ( (a1 & 0xFFFFFFFD) != 60 && a1 != 318 || v81 || !sub_806EC08(v32) )\n          {\n            sub_806EE06();\n            goto LABEL_128;\n          }\n          v35 = -1;\n          if ( *v32 )\n            v35 = atoi(v32);\n          v36 = sub_8070C51(0x18u);\n          v38 = v36;\n          if ( a1 == 62 )\n          {\n            v36[2] = 1;\n            v39 = sub_8074C1E(v37);\n            switch ( v39 )\n            {\n              case '>':\n                *(_BYTE *)v38 = 21;\n                goto LABEL_150;\n              case '|':\n                *(_BYTE *)v38 = 18;\n                goto LABEL_150;\n              case '&':\n                *(_BYTE *)v38 = 22;\n                goto LABEL_150;\n            }\n            *(_BYTE *)v38 = 16;\nLABEL_149:\n            sub_806EE06();\n          }\n          else if ( a1 == 318 )\n          {\n            v36[2] = 1;\n            sub_8073952();\n            *(_BYTE *)v38 = 17;\n          }\n          else\n          {\n            v40 = sub_8074C1E(v37);\n            switch ( v40 )\n            {\n              case '<':\n                v38 = sub_8070C51(0x10u);\n                *(_BYTE *)v38 = 24;\n                dword_80DB680 = (int)sub_8070C51(0x10u);\n                *(_DWORD *)(dword_80DB680 + 4) = v38;\n                if ( sub_8074C1E(v41) != 45 )\n                  goto LABEL_149;\n                *(_BYTE *)(dword_80DB680 + 12) = 1;\n                break;\n              case '>':\n                *(_BYTE *)v38 = 20;\n                break;\n              case '&':\n                *(_BYTE *)v38 = 23;\n                break;\n              default:\n                *(_BYTE *)v38 = 19;\n                goto LABEL_149;\n            }\n          }\nLABEL_150:\n          if ( v35 >= 0 )\n            v38[2] = v35;\n          dword_80DB684 = (int)v38;\n          byte_80DB768 = 2;\n          return 2;\n        }\n    }\n  }\n}\n"
        ],
        "134695589": [
            "sub_8074AA5",
            "0x8074aa5",
            "int __usercall sub_8074AA5@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v2; // eax\n  int v3; // ebx\n  int v4; // eax\n  int v5; // eax\n  char v7; // [esp+0h] [ebp-50h]\n  int v9; // [esp+8h] [ebp-48h]\n  int v10; // [esp+Ch] [ebp-44h]\n  char v11[40]; // [esp+28h] [ebp-28h] BYREF\n\n  sub_806F74D(a1);\n  v7 = byte_80DB76F;\n  byte_80DB76F = 0;\n  v10 = *(_DWORD *)(dword_80DBB8C + 32);\n  v9 = *(_DWORD *)(dword_80DBB8C + 36);\n  v2 = _setjmp((struct __jmp_buf_tag *)v11);\n  v3 = dword_80DBB8C;\n  if ( !v2 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v11;\n    v5 = sub_8073952();\n    sub_8073F3E(v5, a2, 1u, 0);\n  }\n  *(_DWORD *)(v3 + 32) = v10;\n  v4 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 36) = v9;\n  if ( !*(_DWORD *)(v4 + 36) && *(_BYTE *)(v4 + 40) )\n    sub_806F406();\n  byte_80DB76F = v7;\n  sub_806F6F7();\n  sub_8075D0B();\n  return *(_DWORD *)(dword_80DBB88 + 4);\n}\n"
        ],
        "134695803": [
            "sub_8074B7B",
            "0x8074b7b",
            "char __usercall sub_8074B7B@<al>(char result@<al>, int a2@<edx>)\n{\n  int v2; // ebx\n  const char *v3; // ebx\n  const char *v4; // [esp+0h] [ebp-14h]\n  _DWORD v5[4]; // [esp+4h] [ebp-10h] BYREF\n\n  if ( result )\n  {\n    byte_80DB76E = 0;\n    if ( a2 == 1 )\n    {\n      v2 = *(_DWORD *)(dword_80DBB90 + 224);\n    }\n    else\n    {\n      if ( a2 != 2 )\n      {\n        v3 = (const char *)(dword_80DBB8C + 44);\n        goto LABEL_8;\n      }\n      v2 = *(_DWORD *)(dword_80DBB90 + 240);\n    }\n    v3 = (const char *)(v2 + 4);\nLABEL_8:\n    sub_8070037(v5, *(_DWORD *)(dword_80DBB88 + 12));\n    v4 = (const char *)sub_8074AA5(v3, 4);\n    free(dword_80DB6F4);\n    dword_80DB6F4 = sub_804DB46(v4);\n    return sub_806FA10(v5);\n  }\n  return result;\n}\n"
        ],
        "134695941": [
            "sub_8074C05",
            "0x8074c05",
            "char sub_8074C05()\n{\n  ++*((_DWORD *)off_80DB55C + 1);\n  return sub_8074B7B(byte_80DB76F, 2);\n}\n"
        ],
        "134695966": [
            "sub_8074C1E",
            "0x8074c1e",
            "int sub_8074C1E()\n{\n  int v0; // ebx\n\n  while ( 1 )\n  {\n    v0 = sub_8073952();\n    if ( v0 != 92 )\n      break;\n    if ( sub_8073952() != 10 )\n    {\n      sub_806EE06();\n      return v0;\n    }\n    sub_8074C05();\n  }\n  return v0;\n}\n"
        ],
        "134696007": [
            "sub_8074C47",
            "0x8074c47",
            "_BYTE *__usercall sub_8074C47@<eax>(int a1@<eax>)\n{\n  int v1; // ecx\n\n  byte_80DB76A = 0;\n  byte_80DB76B = 0;\n  dword_80DB690 = 0;\n  byte_80DB76F = a1;\n  sub_8074B7B(a1, a1);\n  byte_80DB76E = 0;\n  return sub_8073DE5(1, v1);\n}\n"
        ],
        "134696060": [
            "sub_8074C7C",
            "0x8074c7c",
            "int __usercall sub_8074C7C@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  _BYTE *v3; // esi\n  _BOOL4 v4; // eax\n  int v5; // eax\n  char *v7; // [esp+0h] [ebp-48h]\n  int v8; // [esp+4h] [ebp-44h]\n  struct __jmp_buf_tag *env; // [esp+Ch] [ebp-3Ch]\n  _DWORD v11[3]; // [esp+10h] [ebp-38h] BYREF\n  char v12[44]; // [esp+1Ch] [ebp-2Ch] BYREF\n\n  v7 = sub_807007B(a1);\n  sub_806F74D(v7);\n  sub_8070056(v11);\n  env = *(struct __jmp_buf_tag **)(dword_80DBB8C + 32);\n  v8 = 0;\n  v2 = _setjmp((struct __jmp_buf_tag *)v12);\n  if ( !v2 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v12;\n    do\n    {\n      v3 = sub_8074C47(0);\n      if ( v3 == (_BYTE *)-1 )\n        break;\n      v4 = 0;\n      if ( byte_80DB76A )\n        v4 = byte_80DB768 == 0;\n      v5 = sub_8074EF2(v3, a2 & (v4 ^ 0xFFFFFFFE));\n      if ( v3 )\n        v8 = v5;\n      sub_806FA10(v11);\n    }\n    while ( !byte_80DB76C );\n  }\n  sub_806FA10(v11);\n  sub_806F6F7();\n  sub_806EC35((int)v7);\n  *(_DWORD *)(dword_80DBB8C + 32) = env;\n  if ( v2 )\n    longjmp(env, v2);\n  return v8;\n}\n"
        ],
        "134696278": [
            "sub_8074D56",
            "0x8074d56",
            "int __usercall sub_8074D56@<eax>(int a1@<eax>, int a2@<ecx>, char a3)\n{\n  int v3; // ebx\n  const char *v4; // esi\n  char v5; // al\n  int v6; // ebp\n  int v7; // edi\n  _BYTE *i; // eax\n  _BYTE *v9; // edx\n  _BYTE *v10; // eax\n  char v14; // [esp+Ch] [ebp-40h]\n  char *v15; // [esp+10h] [ebp-3Ch]\n  int v16; // [esp+14h] [ebp-38h]\n  char v17[52]; // [esp+18h] [ebp-34h] BYREF\n\n  v15 = dword_80DB70C;\n  v16 = *(_DWORD *)(dword_80DBB8C + 32);\n  v3 = _setjmp((struct __jmp_buf_tag *)v17);\n  if ( !v3 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v17;\n    dword_80DB70C = *(char **)a2;\n    dword_80DB708 = a2 + 4;\n    dword_80DB700 = 0;\n    if ( (char **)a1 == &off_80B5DE0 )\n    {\n      v4 = *(const char **)(a2 + 4);\n      v5 = 0;\n      if ( v4 )\n      {\n        v6 = a2 + 8;\n        if ( *(_DWORD *)(a2 + 8) )\n        {\n          v7 = dword_80DBB88;\n          for ( i = *(_BYTE **)(dword_80DBB88 + 4); ; i = sub_8071CD6(32, v9) )\n          {\n            v9 = (_BYTE *)sub_8071971(v4, (int)i);\n            v6 += 4;\n            v4 = *(const char **)(v6 - 4);\n            if ( !v4 )\n              break;\n          }\n          v10 = sub_8071CD6(0, v9);\n          v4 = (const char *)sub_806FFC6((int)&v10[-*(_DWORD *)(v7 + 4)]);\n        }\n        v5 = sub_8074C7C(v4, a3 & 2);\n      }\n    }\n    else\n    {\n      v5 = (*(int (__fastcall **)(int, int))(a1 + 4))(a1, a2);\n    }\n    v14 = v5;\n    sub_806F4BD();\n    *(_BYTE *)dword_80DBB8C = stdout->_flags & 8 | v14;\n  }\n  clearerr(stdout);\n  dword_80DB70C = v15;\n  *(_DWORD *)(dword_80DBB8C + 32) = v16;\n  return v3;\n}\n"
        ],
        "134696585": [
            "sub_8074E89",
            "0x8074e89",
            "int __fastcall sub_8074E89(int a1, int a2)\n{\n  _BYTE *v2; // esi\n  char v3; // cl\n  _BYTE *v4; // edi\n  int v5; // ebx\n  const char *v6; // eax\n\n  v2 = (_BYTE *)dword_80DBB8C;\n  if ( !*(_BYTE *)(dword_80DBB8C + 42) )\n    return a2;\n  v3 = *(_BYTE *)dword_80DBB8C;\n  *(_BYTE *)(dword_80DBB8C + 42) = 0;\n  v4 = v2 + 124;\n  v5 = 1;\n  while ( !v4[v5 - 1] )\n  {\nLABEL_10:\n    if ( ++v5 == 65 )\n      goto LABEL_11;\n  }\n  if ( !byte_80DB76C )\n  {\n    v6 = *(const char **)&v2[4 * v5 + 192];\n    if ( v6 || v5 != 2 )\n    {\n      v4[v5 - 1] = 0;\n      if ( v6 )\n      {\n        HIBYTE(a2) = v3;\n        sub_8074C7C(v6, 0);\n        v3 = HIBYTE(a2);\n      }\n    }\n    goto LABEL_10;\n  }\n  v2[42] = v5;\nLABEL_11:\n  *v2 = v3;\n  return a2;\n}\n"
        ],
        "134696690": [
            "sub_8074EF2",
            "0x8074ef2",
            "int __usercall sub_8074EF2@<eax>(int a1@<edx>, int a2@<ecx>, char *a3, int a4)\n{\n  char *v4; // edi\n  unsigned __int8 *v5; // ebx\n  int v6; // ecx\n  int v7; // esi\n  int (__cdecl *v8)(int, int); // eax\n  int v9; // eax\n  int v10; // ebp\n  int v11; // esi\n  int v12; // eax\n  int v13; // esi\n  int v14; // eax\n  int v15; // eax\n  size_t v16; // esi\n  void *v17; // ebp\n  const char *v18; // eax\n  const char *v19; // esi\n  int v21; // [esp-8h] [ebp-1Ch]\n  int v22; // [esp-8h] [ebp-1Ch]\n  int v23; // [esp-8h] [ebp-1Ch]\n  int v24; // [esp-4h] [ebp-18h]\n  int v25; // [esp-4h] [ebp-18h]\n  int v26; // [esp+0h] [ebp-14h]\n\n  v4 = a3;\n  v5 = (unsigned __int8 *)dword_80DBB8C;\n  if ( a3 )\n  {\n    sub_8074E89(a2, a1);\n    v7 = *a3;\n    switch ( *a3 )\n    {\n      case 0:\n        v8 = sub_8077DB8;\n        goto LABEL_13;\n      case 1:\n        v8 = sub_8077B33;\n        goto LABEL_13;\n      case 2:\n        v11 = dword_80DBB90;\n        v12 = *((_DWORD *)a3 + 1);\n        *(_DWORD *)(dword_80DBB90 + 328) = v12;\n        *((_DWORD *)v5 + 3) = v12;\n        if ( dword_80DB698 )\n          *(_DWORD *)(v11 + 328) = v12 - (dword_80DB698 - 1);\n        sub_8076588();\n        sub_806EE2E(*((_DWORD *)a3 + 3));\n        v10 = sub_80764FE();\n        if ( !v10 )\n        {\n          v10 = sub_8074EF2(*((_DWORD *)a3 + 2), a4 & 2);\n          a1 = v24;\n        }\n        v13 = 0;\n        if ( *((_DWORD *)a3 + 3) )\n          sub_806FF33(0, a1);\n        goto LABEL_33;\n      case 3:\n      case 4:\n        v8 = sub_807665F;\nLABEL_13:\n        v10 = 0;\n        if ( v5[45] )\n          v10 = -((a4 & 2) == 0);\n        goto LABEL_24;\n      case 5:\n      case 6:\n      case 7:\n        v26 = v7 - 5;\n        v10 = sub_8074EF2(\n                *((_DWORD *)a3 + 1),\n                ((unsigned __int8)a4 | (unsigned __int8)(((unsigned int)(v7 - 5) >> 1) - 1)) & 2);\n        a2 = v22;\n        v13 = 0;\n        if ( (v10 == 0) == v26 || byte_80DB76C )\n          break;\n        v4 = (char *)*((_DWORD *)a3 + 2);\n        goto LABEL_22;\n      case 8:\n        v15 = sub_8074EF2(*((_DWORD *)a3 + 1), 2);\n        v10 = v15;\n        a2 = v23;\n        v13 = 0;\n        if ( byte_80DB76C )\n          break;\n        if ( v15 )\n        {\n          v4 = (char *)*((_DWORD *)a3 + 3);\n          v10 = 0;\n          if ( !v4 )\n            goto LABEL_33;\nLABEL_22:\n          v8 = sub_8074EF2;\nLABEL_23:\n          v10 = 0;\nLABEL_24:\n          v14 = v8((int)v4, a4);\n        }\n        else\n        {\n          v14 = sub_8074EF2(*((_DWORD *)a3 + 2), a4);\n        }\n        a1 = v25;\n        v13 = v10;\n        v10 = v14;\nLABEL_33:\n        *v5 = v10;\n        break;\n      case 9:\n      case 10:\n        v8 = sub_8076871;\n        goto LABEL_23;\n      case 11:\n        v8 = sub_80768DE;\n        goto LABEL_23;\n      case 12:\n        v8 = sub_807672E;\n        goto LABEL_23;\n      case 14:\n        ++*((_DWORD *)v5 + 9);\n        v16 = sub_80727DF(0, a3, v6) + 4;\n        v17 = sub_804DB2E(v16);\n        dword_80DB6A8 = (int)v17 + 4;\n        dword_80DB6A4 = (int)v17 + v16;\n        sub_806EF86(a3);\n        v18 = sub_806F11D(*((const char **)a3 + 2), 1);\n        v19 = v18;\n        if ( v18[8] == 1 )\n          sub_806EEEB(*((_DWORD **)v18 + 1));\n        *((_DWORD *)v19 + 1) = v17;\n        *((_WORD *)v19 + 4) = 1;\n        sub_806F4A5();\n        v10 = 0;\n        goto LABEL_32;\n      default:\n        v9 = sub_8074EF2(*((_DWORD *)a3 + 1), 2);\n        a2 = v21;\n        v10 = v9 == 0;\nLABEL_32:\n        v13 = 0;\n        goto LABEL_33;\n    }\n  }\n  else\n  {\n    v10 = 0;\n    v13 = 0;\n  }\n  sub_8074E89(a2, a1);\n  if ( (v10 & v13) != 0 || (a4 & 1) != 0 )\n    sub_806F22F(4);\n  return *v5;\n}\n"
        ],
        "134697230": [
            "sub_807510E",
            "0x807510e",
            "char __usercall sub_807510E@<al>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int i; // ebp\n  unsigned __int8 v4; // dl\n  bool v5; // zf\n  char *pw_dir; // ebx\n  char v7; // dl\n  struct passwd *v8; // eax\n  unsigned int v9; // eax\n  int v10; // ecx\n  unsigned int v11; // edx\n  int v12; // ebp\n  int v13; // ebx\n  size_t v14; // eax\n  int v15; // ecx\n  unsigned int v16; // edi\n  char v17; // bl\n  char result; // al\n  int v19; // eax\n  char *v20; // ebx\n  void *v21; // edi\n  int v22; // esi\n  int v23; // edx\n  int v24; // ecx\n  int v25; // ebx\n  signed int v26; // eax\n  unsigned int v27; // edx\n  unsigned int v28; // eax\n  void *v29; // edx\n  unsigned int v30; // ecx\n  int v31; // ebx\n  _BYTE *j; // ebx\n  _BYTE *v33; // eax\n  int v34; // edx\n  char *v35; // esi\n  const char *v36; // ebx\n  __int64 v37; // rax\n  int v38; // eax\n  int v39; // [esp-8h] [ebp-BCh]\n  void *v40; // [esp-4h] [ebp-B8h]\n  int v41; // [esp-4h] [ebp-B8h]\n  unsigned int v42; // [esp+0h] [ebp-B4h]\n  int v43; // [esp+4h] [ebp-B0h]\n  char *v44; // [esp+8h] [ebp-ACh]\n  char *reject; // [esp+Ch] [ebp-A8h]\n  char *v46; // [esp+10h] [ebp-A4h] BYREF\n  unsigned int v47; // [esp+14h] [ebp-A0h]\n  int v48; // [esp+18h] [ebp-9Ch] BYREF\n  int buf[2]; // [esp+1Ch] [ebp-98h] BYREF\n  int pipedes[2]; // [esp+24h] [ebp-90h] BYREF\n\n  v42 = a2;\n  v47 = a2 & 0xC0;\n  reject = (char *)&unk_80D0D15;\n  if ( (a2 & 4) != 0 )\n  {\n    reject = (char *)&unk_80D0D14;\n    if ( (a2 & 0x20) == 0 )\n      reject = (char *)&unk_80D0D13;\n  }\n  v43 = a2 & 2;\n  if ( (a2 & 2) == 0 )\n    goto LABEL_31;\n  v42 = a2 & 0xFFFFFFFD;\n  v43 = 0;\nLABEL_6:\n  if ( *(_BYTE *)a1 != 126 )\n    goto LABEL_31;\n  for ( i = a1; ; ++i )\n  {\n    v4 = *(_BYTE *)(i + 1);\n    if ( !v4 )\n      break;\n    if ( v4 == 0x81 )\n      goto LABEL_31;\n    if ( v4 > 0x81u )\n    {\n      if ( v4 == 0x83 )\n        break;\n      if ( v4 == 0x88 )\n        goto LABEL_31;\n    }\n    else if ( v4 == 47 || v4 == 58 && (v42 & 4) != 0 )\n    {\n      break;\n    }\n  }\n  *(_BYTE *)(i + 1) = 0;\n  v5 = *(_BYTE *)(a1 + 1) == 0;\n  LOBYTE(v46) = v4;\n  if ( v5 )\n  {\n    pw_dir = sub_8072EED(\"HOME\");\n    v7 = (char)v46;\n  }\n  else\n  {\n    v8 = getpwnam((const char *)(a1 + 1));\n    v7 = (char)v46;\n    if ( !v8 )\n    {\nLABEL_26:\n      *(_BYTE *)(i + 1) = v7;\n      goto LABEL_31;\n    }\n    pw_dir = v8->pw_dir;\n  }\n  if ( !pw_dir || !*pw_dir )\n    goto LABEL_26;\n  *(_BYTE *)(i + 1) = v7;\n  v9 = strlen(pw_dir);\n  sub_80718D9((int)pw_dir, v9, 2, v42 & 0x11);\n  a1 = i + 1;\nLABEL_31:\n  while ( 2 )\n  {\n    v46 = (char *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n    v13 = 0;\n    while ( 1 )\n    {\n      v14 = strcspn((const char *)(a1 + v13), reject);\n      v15 = v39;\n      v16 = v14 + v13;\n      v17 = *(_BYTE *)(a1 + v14 + v13);\n      if ( v17 && (v17 == -121 || v17 >= 0) )\n        ++v16;\n      result = (char)v46;\n      v44 = v46;\n      if ( v16 )\n      {\n        v19 = sub_80716AF(v16, dword_80DB6D4);\n        dword_80DB6D4 = mempcpy(v19, a1, v16);\n        v15 = dword_80DBB88;\n        v44 = (char *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n        result = v47 == 64;\n        if ( v47 == 64 && v43 == 0 )\n        {\n          v15 = dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4);\n          if ( (int)v46 < (int)v44 )\n            result = sub_806F87B(v46, v44, 0);\n        }\n      }\n      v12 = a1 + v16 + 1;\n      if ( v17 == 58 )\n        goto LABEL_49;\n      if ( v17 != 61 )\n        break;\n      if ( (v42 & 0x20) != 0 )\n      {\n        v12 = a1 + v16;\n        goto LABEL_46;\n      }\n      v42 |= 0x20u;\n      ++reject;\nLABEL_49:\n      a1 += v16;\n      if ( *(_BYTE *)(v12 - 1) == 126 )\n        goto LABEL_6;\n      v12 = a1;\nLABEL_46:\n      v13 = 0;\nLABEL_47:\n      v46 = v44;\n      a1 = v12;\n    }\n    if ( v17 )\n    {\n      switch ( v17 )\n      {\n        case -127:\n          ++v44;\n          v13 = 1;\n          goto LABEL_53;\n        case -126:\n          v12 = sub_8075AA1(v15, v43 | v42);\n          goto LABEL_30;\n        case -125:\n          return result;\n        case -124:\n          v20 = *(char **)(dword_80DB6D0 + 4);\n          v46 = (char *)(((int)(v43 | v42) >> 7) & 1);\n          ++*(_DWORD *)(dword_80DBB8C + 36);\n          v21 = (void *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n          sub_8070037(&v48, (int)v21);\n          if ( v20 )\n          {\n            if ( pipe(pipedes) < 0 )\n              sub_806FB57(\"can't create pipe: %m\");\n            v22 = sub_807151B(1);\n            if ( !sub_8072B54(v22, (int)v20, 2) )\n            {\n              sub_806F48C();\n              close(pipedes[0]);\n              v21 = v40;\n              if ( pipedes[1] != 1 )\n              {\n                sub_806FF10(pipedes[1], 1);\n                close(pipedes[1]);\n                v22 = v41;\n              }\n              *(_BYTE *)(dword_80DBB8C + 45) = 0;\n              sub_806F5DA();\n              sub_8074EF2(v23, v24, v20, 1);\n            }\n            close(buf[1]);\n            v25 = buf[0];\n          }\n          else\n          {\n            v22 = 0;\n            v25 = -1;\n          }\n          sub_806FA10(&v46);\n          while ( 2 )\n          {\n            if ( v25 >= 0 )\n            {\n              v26 = sub_80B2319(0x80u, buf);\n              if ( v26 > 0 )\n              {\n                sub_80718D9((int)buf, v26, v43 | v42, v42 & 0x11);\n                continue;\n              }\n              close(v25);\n              *(_BYTE *)(dword_80DBB8C + 1) = sub_8071014(v22);\n            }\n            break;\n          }\n          sub_806F4A5();\n          v27 = dword_80DB6D4;\n          v28 = *(_DWORD *)(dword_80DBB88 + 4);\n          while ( v27 > v28 && *(_BYTE *)(v27 - 1) == 10 )\n            --v27;\n          dword_80DB6D4 = v27;\n          v29 = (void *)(v27 - v28);\n          if ( (v42 & 0x80u) == 0 )\n            sub_806F87B(v21, v29, 0);\n          dword_80DB6D0 = *(_DWORD *)dword_80DB6D0;\n          goto LABEL_30;\n        case -121:\n          v12 = a1 + v16;\n          v30 = *(_DWORD *)(dword_80DBB88 + 4);\n          v31 = dword_80DB6D4;\n          *(_BYTE *)(dword_80DB6D4 - 1) = 0;\n          for ( j = (_BYTE *)(v31 - 2); ; j += ~v34 )\n          {\n            while ( *j != 0x86 )\n              --j;\n            v33 = j;\n            do\n            {\n              v34 = j - v33;\n              if ( v30 >= (unsigned int)v33 )\n                break;\n              --v33;\n            }\n            while ( *v33 == 0x81 );\n            if ( (v34 & 1) == 0 )\n              break;\n          }\n          v35 = &j[-v30];\n          sub_806F8CC((int)&j[-v30]);\n          dword_80DB6D4 = (int)j;\n          v36 = j + 1;\n          if ( (((unsigned __int8)v43 | (unsigned __int8)v42) & 0x11) != 0 )\n            sub_80719CE(v36, 0, 0);\n          v37 = sub_807146D();\n          v38 = sub_8071998(v37, HIDWORD(v37));\n          if ( (((unsigned __int8)v43 | (unsigned __int8)v42) & 0x80) == 0 )\n            sub_806F87B(v35, &v35[v38], 0);\n          goto LABEL_30;\n        case -120:\n          if ( v43 || memcmp((const void *)(a1 + v16 + 1), &unk_80D0F92, 5u) )\n          {\n            v43 ^= 0x80u;\n            v13 = 0;\nLABEL_53:\n            if ( (v42 & 0x11) != 0 )\n            {\n              v12 = a1 + v16;\n              ++v13;\n              ++v44;\n            }\n            goto LABEL_47;\n          }\n          v11 = v42;\n          LOBYTE(v11) = v42 | 0x80;\n          v12 = sub_8075AA1(v10, v11) + 1;\nLABEL_30:\n          a1 = v12;\n          break;\n        default:\n          goto LABEL_46;\n      }\n      continue;\n    }\n    return result;\n  }\n}\n"
        ],
        "134698395": [
            "sub_807559B",
            "0x807559b",
            "char *__usercall sub_807559B@<eax>(char *a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5, char a6, char a7)\n{\n  int v9; // ebp\n  char *i; // edi\n  char v11; // al\n  unsigned int v12; // edx\n  _BYTE *v13; // eax\n  int v14; // ebp\n  char *v15; // edi\n  const char *v16; // eax\n  const char *v17; // ebp\n  char *v18; // eax\n  char *v19; // ebx\n  int v20; // esi\n  unsigned int v21; // ebx\n  char *j; // eax\n  char *v23; // eax\n  bool k; // zf\n  char v25; // dl\n  int v26; // eax\n  unsigned int v27; // ebx\n  char *v28; // eax\n  int v29; // esi\n  char *v30; // ebx\n  int v31; // esi\n  char *v32; // ebp\n  int *v33; // ecx\n  int v34; // esi\n  char *v35; // eax\n  int v36; // edi\n  _BYTE *v37; // edx\n  int v38; // edi\n  char *m; // esi\n  char v40; // al\n  int v41; // ebp\n  int v42; // eax\n  int v43; // esi\n  char *(__cdecl *v44)(unsigned int, const char *, char *, char *, int, int); // edx\n  char *v45; // eax\n  int v46; // esi\n  int v48; // [esp+0h] [ebp-40h]\n  const char *v49; // [esp+4h] [ebp-3Ch]\n  int v50; // [esp+8h] [ebp-38h]\n  char *name; // [esp+14h] [ebp-2Ch]\n  char *v53; // [esp+18h] [ebp-28h]\n  int v54; // [esp+1Ch] [ebp-24h]\n  int v55; // [esp+20h] [ebp-20h]\n  _BYTE *v56; // [esp+24h] [ebp-1Ch]\n  int v57; // [esp+28h] [ebp-18h]\n  int v58; // [esp+2Ch] [ebp-14h] BYREF\n\n  v9 = dword_80DB6D0;\n  v48 = a7 & 0x11;\n  i = 0;\n  if ( (unsigned int)(a4 - 13) <= 1 )\n  {\n    for ( i = a1; ; ++i )\n    {\n      v11 = *i;\n      if ( !*i )\n        break;\n      if ( v11 == 47 )\n      {\n        *i = 0;\n        goto LABEL_11;\n      }\n      if ( v11 == -127 && i[1] )\n        ++i;\n    }\n    i = 0;\n  }\nLABEL_11:\n  if ( (unsigned int)(a4 - 4) <= 1 || (v12 = 18, a4 == 12) )\n    v12 = 2;\n  sub_807510E((int)a1, v12);\n  v58 = -1;\n  if ( i )\n  {\n    v58 = dword_80DB6D4 - (*(_DWORD *)(dword_80DBB88 + 4) + a3);\n    dword_80DB6D4 = (int)sub_8071CD6(47, (_BYTE *)dword_80DB6D4);\n    sub_807510E((int)(i + 1), 2u);\n    *i = 47;\n  }\n  v13 = sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n  dword_80DB6D4 = (int)v13;\n  dword_80DB6D0 = v9;\n  v14 = *(_DWORD *)(dword_80DBB88 + 4);\n  v15 = (char *)(v14 + a5);\n  if ( a4 != 5 )\n  {\n    if ( a4 == 12 )\n    {\n      v17 = (const char *)(a3 + v14);\n      v18 = strchr(v17, 58);\n      v19 = v18;\n      if ( v18 )\n        *v18 = 0;\n      v20 = sub_80714BF();\n      if ( v19 )\n        *v19 = 58;\n      v21 = a3 - a5 - 1;\n      if ( (a7 & 0x11) != 0 )\n      {\n        for ( j = v15; j < v17 - 1; ++j )\n        {\n          if ( *j == -127 )\n          {\n            --v21;\n            ++j;\n          }\n        }\n      }\n      v23 = (char *)(v17 + 1);\n      for ( k = *v17 == 58; ; k = v25 == 58 )\n      {\n        if ( k )\n        {\n          v26 = sub_80714BF();\n          goto LABEL_43;\n        }\n        v25 = *v23++;\n        if ( !v25 )\n          break;\n      }\n      v26 = v21;\nLABEL_43:\n      if ( v20 < 0 )\n        v20 += v21;\n      if ( v20 >= v21 )\n      {\n        v20 = 0;\n        v26 = 0;\n      }\n      else if ( v26 < 0 )\n      {\n        v26 += v21 - v20;\n      }\n      v27 = v21 - v20;\n      if ( v27 >= v26 )\n        v27 = v26;\n      v28 = v15;\n      while ( v20 )\n      {\n        if ( (a7 & 0x11) != 0 && *v28 == -127 )\n          ++v28;\n        ++v28;\n        --v20;\n      }\n      while ( v27 )\n      {\n        if ( (a7 & 0x11) != 0 && *v28 == -127 )\n        {\n          *v15 = -127;\n          ++v28;\n          ++v15;\n        }\n        *v15 = *v28;\n        --v27;\n        ++v28;\n        ++v15;\n      }\n      goto LABEL_111;\n    }\n    if ( a4 != 4 )\n    {\n      v56 = &v13[-v14];\n      v50 = 0;\n      while ( 1 )\n      {\nLABEL_63:\n        v29 = *(_DWORD *)(dword_80DBB88 + 4);\n        dword_80DB6D4 = (int)&v56[v29];\n        v30 = (char *)(v29 + a5);\n        v31 = a3 + v29;\n        v49 = v30;\n        if ( (a7 & 0x11) != 0 )\n        {\n          v49 = sub_80719CE(v30, 9, 0);\n          if ( v30 != v49 )\n          {\n            v31 = dword_80DB6D4;\n            v30 = (char *)(a5 + *(_DWORD *)(dword_80DBB88 + 4));\n          }\n        }\n        name = (char *)(v31 - 1);\n        v32 = (char *)(*(_DWORD *)(dword_80DBB88 + 4) + a3);\n        v33 = 0;\n        if ( !v50 )\n        {\n          v33 = 0;\n          if ( v58 >= 0 )\n            v33 = &v58;\n        }\n        sub_80719CE((const char *)(*(_DWORD *)(dword_80DBB88 + 4) + a3), 2, v33);\n        v54 = dword_80DB6D4;\n        v55 = *(_DWORD *)(dword_80DBB88 + 4);\n        if ( (unsigned int)(a4 - 13) > 1 )\n          break;\n        if ( !v50 )\n        {\n          v50 = dword_80DBB8C + 44;\n          if ( v58 >= 0 )\n          {\n            v50 = (int)&v32[v58 + 1];\n            v32[v58] = 0;\n          }\n        }\n        if ( !*v32 )\n          return 0;\n        v53 = v32 - 1;\n        v34 = 0;\n        while ( 1 )\n        {\n          if ( v30 >= v53 )\n            goto LABEL_105;\nLABEL_77:\n          v35 = sub_80713E7((unsigned int)v30, v49, name, v32, v48, 1);\n          if ( !v35 )\n            break;\n          if ( a4 == 14 )\n          {\n            while ( v30 < v35 )\n            {\n              if ( (a7 & 0x11) != 0 && *v30 == -127 )\n                ++v30;\n              ++v30;\n              ++v49;\n            }\n          }\n          else\n          {\n            v30 = v35;\n          }\n          v38 = v34;\n          for ( m = (char *)v50; *m; ++m )\n          {\n            v57 = *(_DWORD *)(dword_80DBB88 + 4);\n            if ( *m == 92 && (a7 & 0x11) != 0 )\n            {\n              dword_80DB6D4 = (int)sub_8071CD6(129, (_BYTE *)dword_80DB6D4);\n              ++v38;\n            }\n            dword_80DB6D4 = (int)sub_8071CD6(*m, (_BYTE *)dword_80DB6D4);\n            if ( *(_DWORD *)(dword_80DBB88 + 4) != v57 )\n              goto LABEL_63;\n            ++v38;\n          }\n          v34 = v38;\n          if ( a4 == 13 )\n          {\n            while ( 1 )\n            {\n              v40 = v30[v34 - v38];\n              if ( !v40 )\n                break;\n              v41 = *(_DWORD *)(dword_80DBB88 + 4);\n              dword_80DB6D4 = (int)sub_8071CD6(v40, (_BYTE *)dword_80DB6D4);\n              if ( *(_DWORD *)(dword_80DBB88 + 4) != v41 )\n                goto LABEL_63;\n              ++v34;\n            }\nLABEL_105:\n            sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n            v42 = *(_DWORD *)(dword_80DBB88 + 4);\n            v15 = (char *)(v42 + a5);\n            memmove((void *)(v42 + a5), (const void *)(v54 - v55 + v42), v34 + 1);\n            dword_80DB6D4 = (int)&v15[v34];\n            return v15;\n          }\n        }\n        v36 = *(_DWORD *)(dword_80DBB88 + 4);\n        while ( 1 )\n        {\n          v37 = sub_8071CD6(*v30, (_BYTE *)dword_80DB6D4);\n          dword_80DB6D4 = (int)v37;\n          if ( (a7 & 0x11) != 0 && *v30 == -127 )\n          {\n            ++v34;\n            dword_80DB6D4 = (int)sub_8071CD6(*++v30, v37);\n          }\n          if ( *(_DWORD *)(dword_80DBB88 + 4) != v36 )\n            break;\n          ++v30;\n          ++v34;\n          ++v49;\n          if ( v53 <= v30 )\n            goto LABEL_105;\n          if ( *v32 != 42 )\n            goto LABEL_77;\n        }\n      }\n      v43 = (a4 - 6) >> 1;\n      v44 = sub_80713E7;\n      if ( ((a4 - 6) & 1) != v43 )\n        v44 = (char *(__cdecl *)(unsigned int, const char *, char *, char *, int, int))sub_807138E;\n      v45 = v44((unsigned int)v30, v49, name, v32, v48, (a4 - 6) >> 1);\n      v15 = v45;\n      if ( !v45 )\n        return 0;\n      if ( v43 )\n      {\n        v46 = v32 - v45;\n        memmove(v30, v45, v32 - v45);\n        v15 = &v30[v46 - 1];\n      }\nLABEL_111:\n      *v15 = 0;\n      goto LABEL_112;\n    }\n    v16 = (const char *)(dword_80DBB8C + 44);\n    if ( v15 )\n    {\n      if ( *a1 != -125 )\n        goto LABEL_26;\n      if ( (a6 & 0x10) != 0 )\n        v16 = \" or null\";\n    }\n    v15 = \"parameter not set\";\nLABEL_26:\n    sub_806FB57(\"%.*s: %s%s\", &a1[-a2 - 1], a2, v15, v16);\n  }\n  sub_806FE06(a2, (const char *)(v14 + a5));\nLABEL_112:\n  dword_80DB6D4 = (int)v15;\n  return v15;\n}\n"
        ],
        "134699681": [
            "sub_8075AA1",
            "0x8075aa1",
            "char *__usercall sub_8075AA1@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // ebp\n  _BOOL4 v3; // edi\n  char *v4; // ebx\n  int v5; // esi\n  signed int v6; // eax\n  int v7; // ebp\n  _DWORD *v8; // edi\n  char *v9; // edx\n  char v10; // bp\n  int v11; // eax\n  char v12; // cl\n  void *v14; // [esp+0h] [ebp-28h]\n  unsigned __int8 v16; // [esp+Ah] [ebp-1Eh]\n  char v17; // [esp+Bh] [ebp-1Dh]\n  void *v18; // [esp+14h] [ebp-14h] BYREF\n\n  v17 = *a1;\n  v16 = *a1 & 0xF;\n  if ( !v16 )\n    sub_8070172(\"bad substitution\");\n  v2 = a1 + 1;\n  v18 = (void *)(a2 & 0x80);\n  v3 = 1;\n  if ( (a2 & 0x80) != 0 )\n  {\n    v3 = 0;\n    if ( a1[1] == 64 )\n      v3 = *(_DWORD *)dword_80DBB90 != 0;\n  }\n  v14 = (void *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4));\n  v4 = strchr(v2, 61) + 1;\n  while ( 1 )\n  {\n    v5 = sub_80730FF((unsigned __int8 *)v2, v17, a2, (int *)&v18) - ((v17 & 0x10) != 0);\n    if ( v16 == 3 )\n    {\n      v5 = ~v5;\nLABEL_10:\n      if ( v5 < 0 )\n      {\n        sub_807510E((int)v4, a2 | 0x42);\n        goto LABEL_30;\n      }\nLABEL_24:\n      if ( !v3 )\n        goto LABEL_30;\n      goto LABEL_25;\n    }\n    if ( v16 == 2 )\n      goto LABEL_10;\n    if ( (unsigned __int8)(v16 - 4) > 1u )\n      break;\n    if ( v5 >= 0 )\n      goto LABEL_24;\n    sub_807559B(v4, (int)v2, 0, v16, (int)v14, v17, a2 & 0xEE);\n    v17 &= ~0x10u;\n    sub_806F8CC((int)v14);\n  }\n  if ( v5 < 0 && *(_BYTE *)(dword_80DBB8C + 57) )\n    sub_806FB57(\"%.*s: %s%s\", v4 - v2 - 1, v2, \"parameter not set\", (const char *)(dword_80DBB8C + 44));\n  if ( v16 == 10 )\n  {\n    v6 = v5;\n    if ( v5 < 0 )\n      v6 = 0;\n    sub_8071998(v6, v6 >> 31);\n  }\n  else\n  {\n    if ( v16 == 1 )\n    {\n      if ( !v3 )\n        return v4;\n      goto LABEL_25;\n    }\n    if ( v5 < 0 )\n      goto LABEL_33;\n    dword_80DB6D4 = (int)sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n    v7 = dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4);\n    if ( !sub_807559B(v4, 0, v7, v16, (int)v14, v17, a2) )\n      dword_80DB6D4 = *(_DWORD *)(dword_80DBB88 + 4) + v7 - 1;\n    sub_806F8CC((int)v14);\n  }\n  if ( !v3 )\n    goto LABEL_33;\nLABEL_25:\n  sub_806F87B(v14, (void *)(dword_80DB6D4 - *(_DWORD *)(dword_80DBB88 + 4)), v18);\nLABEL_30:\n  if ( v16 == 1 )\n    return v4;\nLABEL_33:\n  v8 = (_DWORD *)dword_80DB6D0;\n  v9 = v4;\n  v10 = 0;\n  v11 = 1;\n  while ( 1 )\n  {\n    ++v4;\n    v12 = *v9;\n    if ( *v9 == -127 )\n    {\n      v4 = v9 + 2;\n      goto LABEL_36;\n    }\n    if ( v12 == -124 )\n    {\n      if ( v5 >= 0 )\n      {\n        v8 = (_DWORD *)*v8;\n        v10 = 1;\n      }\n      goto LABEL_36;\n    }\n    if ( v12 != -126 )\n      break;\n    v4 = v9 + 2;\n    if ( (v9[1] & 0xF) != 1 )\n      ++v11;\nLABEL_36:\n    v9 = v4;\n  }\n  if ( v12 != -125 )\n    goto LABEL_36;\n  if ( --v11 )\n    goto LABEL_36;\n  if ( v10 )\n    dword_80DB6D0 = (int)v8;\n  return v4;\n}\n"
        ],
        "134700299": [
            "sub_8075D0B",
            "0x8075d0b",
            "char __usercall sub_8075D0B@<al>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)\n{\n  char v3; // bl\n  int v4; // esi\n  _BYTE *v5; // eax\n  unsigned __int8 *v6; // ebx\n  void **v7; // edi\n  unsigned __int8 *v8; // edx\n  _BOOL4 v9; // ebp\n  unsigned __int8 *v10; // esi\n  char *v11; // eax\n  unsigned __int8 *v12; // esi\n  unsigned __int8 *v13; // edx\n  _DWORD *v14; // eax\n  _DWORD *v15; // eax\n  int i; // esi\n  int v17; // edi\n  const char *v18; // eax\n  char v19; // al\n  char *v20; // eax\n  char v21; // dl\n  char *v22; // eax\n  char *v23; // ebx\n  int *v24; // ebx\n  char *v25; // edi\n  int v26; // ebp\n  _DWORD *v27; // ecx\n  int v28; // edx\n  _DWORD *v29; // eax\n  _DWORD *v30; // eax\n  int v31; // eax\n  int v33; // [esp+0h] [ebp-3Ch]\n  unsigned int v34; // [esp+4h] [ebp-38h]\n  char *s; // [esp+8h] [ebp-34h]\n  unsigned int v37; // [esp+10h] [ebp-2Ch]\n  const char *v38; // [esp+14h] [ebp-28h]\n  int v39; // [esp+18h] [ebp-24h]\n  int c; // [esp+1Ch] [ebp-20h]\n  unsigned int ca; // [esp+1Ch] [ebp-20h]\n  int v42; // [esp+20h] [ebp-1Ch]\n  int v43; // [esp+20h] [ebp-1Ch]\n  void *ptr[6]; // [esp+24h] [ebp-18h] BYREF\n\n  v3 = a3;\n  dword_80DB6D0 = *(_DWORD *)(a1 + 12);\n  v4 = dword_80DBB88;\n  dword_80DB6D4 = *(_DWORD *)(dword_80DBB88 + 4);\n  sub_807510E(*(_DWORD *)(a1 + 8), a3);\n  v5 = sub_8071CD6(0, (_BYTE *)dword_80DB6D4);\n  dword_80DB6D4 = (int)(v5 - 1);\n  if ( !a2 )\n    return sub_806F5DA();\n  v33 = sub_806FFC6((int)&v5[-*(_DWORD *)(v4 + 4)]);\n  dword_80DB6B8 = (int)&dword_80DB6B4;\n  v39 = v3 & 1;\n  if ( (v3 & 1) != 0 )\n  {\n    if ( dword_80DB6BC )\n    {\n      v38 = \" \\t\\n\";\n      if ( (*(_BYTE *)(dword_80DBB90 + 188) & 0x20) == 0 )\n        v38 = (const char *)(*(_DWORD *)(dword_80DBB90 + 192) + 4);\n      v6 = (unsigned __int8 *)v33;\n      v37 = 0;\n      v7 = &::ptr;\n      do\n      {\n        v8 = (unsigned __int8 *)v7[1] + v33;\n        v34 = (unsigned int)v7[3];\n        s = (char *)v38;\n        if ( v34 )\n          s = (char *)(dword_80DBB8C + 44);\n        v9 = 0;\n        while ( v8 < (unsigned __int8 *)((char *)v7[2] + v33) )\n        {\n          v10 = v8 + 1;\n          if ( *v8 != 0x81 )\n            v10 = v8;\n          v42 = (int)v8;\n          c = *v10;\n          v11 = strchr(s, c);\n          v12 = v10 + 1;\n          v13 = (unsigned __int8 *)v42;\n          if ( v11 )\n          {\n            if ( !(v37 | v34) )\n            {\n              v9 = strchr(\" \\t\\n\", c) != 0;\n              v13 = (unsigned __int8 *)v42;\n            }\n            if ( v13 == v6 && v9 )\n            {\n              v9 = v39;\n              v6 = v12;\n            }\n            else\n            {\n              *v13 = 0;\n              v14 = sub_8070C51(8u);\n              v14[1] = v6;\n              *(_DWORD *)dword_80DB6B8 = v14;\n              dword_80DB6B8 = (int)v14;\n              v6 = v12;\n              if ( !v34 )\n              {\n                ca = (unsigned int)v7[2] + v33;\n                while ( 1 )\n                {\n                  v12 = v6;\n                  if ( ca <= (unsigned int)v6 )\n                    break;\n                  if ( *v6 == 0x81 )\n                    v12 = v6 + 1;\n                  v43 = *v12;\n                  if ( !strchr(s, v43) )\n                  {\nLABEL_29:\n                    v12 = v6;\n                    break;\n                  }\n                  if ( strchr(\" \\t\\n\", v43) )\n                  {\n                    v6 = v12 + 1;\n                  }\n                  else\n                  {\n                    if ( !v9 )\n                      goto LABEL_29;\n                    v6 = v12 + 1;\n                    v9 = 0;\n                  }\n                }\n              }\n            }\n          }\n          v8 = v12;\n        }\n        v7 = (void **)*v7;\n        v37 = v34;\n      }\n      while ( v7 );\n      if ( v34 )\n      {\nLABEL_36:\n        v15 = sub_8070C51(8u);\n        v15[1] = v6;\n        *(_DWORD *)dword_80DB6B8 = v15;\n        dword_80DB6B8 = (int)v15;\nLABEL_37:\n        *(_DWORD *)dword_80DB6B8 = 0;\n        dword_80DB6B8 = (int)&dword_80DB6B4;\n        for ( i = dword_80DB6B4; i; i = *(_DWORD *)i )\n        {\n          v17 = dword_80DBB8C;\n          v18 = *(const char **)(i + 4);\n          if ( !*(_BYTE *)(dword_80DBB8C + 46) )\n          {\n            while ( 1 )\n            {\n              v22 = strpbrk(v18, asc_80D0CF7);\n              v23 = v22;\n              if ( !v22 )\n                goto LABEL_40;\n              v19 = *v22;\n              if ( v19 == 92 )\n                break;\n              if ( (unsigned __int8)v19 <= 0x5Cu )\n              {\n                if ( v19 != 91 || strchr(v23 + 1, 93) )\n                {\nLABEL_59:\n                  v24 = (int *)dword_80DB6B8;\n                  ++*(_DWORD *)(v17 + 36);\n                  v25 = (char *)sub_80719CE(*(const char **)(i + 4), 19, 0);\n                  v26 = strlen(v25);\n                  ptr[1] = (void *)(v26 + 4096);\n                  ptr[0] = sub_804DAFA(v26 + 4096);\n                  sub_8072500(ptr, v25, v26, 0);\n                  free(ptr[0]);\n                  if ( *(char **)(i + 4) != v25 )\n                    free(v25);\n                  sub_806F4A5();\n                  if ( v24 != (int *)dword_80DB6B8 )\n                  {\n                    *(_DWORD *)dword_80DB6B8 = 0;\n                    v27 = (_DWORD *)*v24;\n                    v28 = 0;\n                    while ( v27 )\n                    {\n                      ++v28;\n                      v27 = (_DWORD *)*v27;\n                    }\n                    v29 = (_DWORD *)sub_806F1B0(*v24, v28);\n                    *v24 = (int)v29;\n                    while ( *v29 )\n                      v29 = (_DWORD *)*v29;\n                    dword_80DB6B8 = (int)v29;\n                    goto LABEL_69;\n                  }\n                  goto LABEL_40;\n                }\n                v20 = v23;\n              }\n              else\n              {\n                if ( v19 == -127 )\n                  break;\n                if ( v19 != -120 )\n                  goto LABEL_59;\n                while ( 1 )\n                {\n                  v20 = v23 + 1;\n                  v21 = v23[1];\n                  if ( v21 == -120 )\n                    break;\n                  v23 += 2;\n                  if ( v21 != -127 )\n                    v23 = v20;\n                  if ( !*v23 )\n                    goto LABEL_40;\n                }\n              }\nLABEL_46:\n              v18 = v20 + 1;\n            }\n            v20 = v23 + 1;\n            if ( !v23[1] )\n              goto LABEL_40;\n            goto LABEL_46;\n          }\nLABEL_40:\n          *(_DWORD *)dword_80DB6B8 = i;\n          sub_80719CE(*(const char **)(i + 4), 0, 0);\n          dword_80DB6B8 = i;\nLABEL_69:\n          ;\n        }\n        goto LABEL_71;\n      }\n    }\n    else\n    {\n      v6 = (unsigned __int8 *)v33;\n    }\n    if ( !*v6 )\n      goto LABEL_37;\n    goto LABEL_36;\n  }\n  v30 = sub_8070C51(8u);\n  v30[1] = v33;\n  *(_DWORD *)dword_80DB6B8 = v30;\n  dword_80DB6B8 = (int)v30;\nLABEL_71:\n  v31 = dword_80DB6B8;\n  *(_DWORD *)dword_80DB6B8 = 0;\n  if ( dword_80DB6B4 )\n  {\n    **(_DWORD **)(a2 + 4) = dword_80DB6B4;\n    *(_DWORD *)(a2 + 4) = v31;\n  }\n  return sub_806F5DA();\n}\n"
        ],
        "134701254": [
            "sub_80760C6",
            "0x80760c6",
            "char __usercall sub_80760C6@<al>(char *a1@<eax>, int a2@<edx>)\n{\n  char *v2; // esi\n  int v3; // edi\n  int v4; // ebx\n  char v5; // al\n  int v6; // ecx\n  size_t v7; // eax\n  size_t v8; // ebp\n  int v9; // eax\n  char *v10; // edx\n  size_t v11; // ecx\n  const char *v12; // ebp\n  char *v13; // eax\n  int v14; // ecx\n  int v15; // eax\n  char *v16; // eax\n  int v17; // eax\n  int v18; // edx\n  int v19; // eax\n  _DWORD *v20; // ebp\n  int v21; // eax\n  int v22; // eax\n  int v23; // eax\n  int v24; // eax\n  int v25; // edx\n  _DWORD *v26; // eax\n  int i; // eax\n  bool v28; // al\n  int fd; // [esp+0h] [ebp-78h]\n  char *fda; // [esp+0h] [ebp-78h]\n  int fdb; // [esp+0h] [ebp-78h]\n  int v33; // [esp+4h] [ebp-74h]\n  int v34; // [esp+4h] [ebp-74h]\n  int v35; // [esp+4h] [ebp-74h]\n  int pipedes[2]; // [esp+8h] [ebp-70h] BYREF\n  int v37; // [esp+18h] [ebp-60h]\n\n  if ( a1 )\n  {\n    v2 = a1;\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    v3 = 0;\n    if ( a2 )\n      v3 = *(_DWORD *)(dword_80DBB90 + 20);\n    while ( 1 )\n    {\n      v4 = *((_DWORD *)v2 + 2);\n      v5 = *v2;\n      if ( (unsigned __int8)(*v2 - 22) > 1u )\n        break;\n      v6 = *((_DWORD *)v2 + 3);\n      if ( v4 != v6 )\n      {\n        fd = -1;\n        goto LABEL_40;\n      }\nLABEL_79:\n      v2 = (char *)*((_DWORD *)v2 + 1);\n      if ( !v2 )\n      {\n        LOBYTE(a1) = sub_806F4A5();\n        return (char)a1;\n      }\n    }\n    if ( (unsigned __int8)(v5 - 24) > 1u )\n    {\n      v12 = (const char *)*((_DWORD *)v2 + 5);\n      switch ( v5 )\n      {\n        case 16:\n        case 17:\n          if ( !*(_BYTE *)(dword_80DBB8C + 54) || stat64(v12, pipedes) < 0 )\n            goto LABEL_31;\n          if ( (v37 & 0xF000) == 0x8000 )\n          {\n            *(_DWORD *)dword_80DBB7C = 17;\nLABEL_32:\n            v16 = sub_80720F6(*(_DWORD *)dword_80DBB7C, \"nonexistent directory\");\n            sub_806FB57(\"can't create %s: %s\", v12, v16);\n          }\n          v14 = open64(v12);\n          if ( v14 < 0 )\n            goto LABEL_32;\n          fdb = v14;\n          v15 = fstat64(v14, pipedes);\n          v6 = fdb;\n          if ( !v15 && (v37 & 0xF000) == 0x8000 )\n          {\n            close(fdb);\n            *(_DWORD *)dword_80DBB7C = 17;\n            goto LABEL_32;\n          }\n          break;\n        case 18:\n        case 20:\n        case 21:\nLABEL_31:\n          v6 = open64(v12);\n          if ( v6 < 0 )\n            goto LABEL_32;\n          goto LABEL_33;\n        default:\n          v6 = open64(v12);\n          if ( v6 < 0 )\n          {\n            v13 = sub_80720F6(*(_DWORD *)dword_80DBB7C, \"no such file\");\n            sub_806FB57(\"can't open %s: %s\", v12, v13);\n          }\n          goto LABEL_33;\n      }\n      goto LABEL_33;\n    }\n    if ( pipe(pipedes) < 0 )\n      sub_806FB57(\"can't create pipe: %m\");\n    if ( *v2 == 24 )\n    {\n      fda = *(char **)(*((_DWORD *)v2 + 3) + 8);\n      v7 = strlen(fda);\n      v8 = v7;\n      if ( v7 <= 0x1000 )\n      {\n        sub_804E586(v7, fda);\nLABEL_19:\n        close(pipedes[1]);\n        v6 = pipedes[0];\nLABEL_33:\n        if ( v4 == v6 )\n        {\n          v17 = 0;\n          if ( v3 )\n          {\n            while ( 1 )\n            {\n              v18 = *(_DWORD *)(v3 + 8 * v17 + 8);\n              if ( v18 == -2 )\n                break;\n              if ( v4 == v18 )\n                goto LABEL_79;\n              ++v17;\n            }\n            v19 = v3 + 8 * v17;\n            *(_DWORD *)(v19 + 8) = v4;\n            *(_DWORD *)(v19 + 12) = -1;\n          }\n        }\n        else\n        {\n          fd = v6;\n          while ( 1 )\n          {\nLABEL_40:\n            if ( v4 == dword_80DB558 )\n            {\n              v33 = v6;\n              dword_80DB558 = sub_8070461(v4);\nLABEL_49:\n              v21 = 1;\n              v6 = v33;\n            }\n            else\n            {\n              if ( v3 )\n              {\n                v20 = off_80DB55C;\n                if ( !v4 )\n                {\n                  v20 = 0;\n                  goto LABEL_50;\n                }\n                while ( v20 )\n                {\n                  if ( v4 == v20[2] )\n                  {\n                    v33 = v6;\n                    v20[2] = sub_8070461(v4);\n                    goto LABEL_49;\n                  }\n                  v20 = (_DWORD *)*v20;\n                }\nLABEL_50:\n                while ( 1 )\n                {\n                  v22 = *(_DWORD *)(v3 + 8 * (_DWORD)v20 + 8);\n                  if ( v22 == -2 )\n                    break;\n                  if ( v4 == *(_DWORD *)(v3 + 8 * (_DWORD)v20 + 12) )\n                  {\n                    v34 = v6;\n                    v23 = sub_806FA55(v4);\n                    *(_DWORD *)(v3 + 8 * (_DWORD)v20 + 12) = v23;\n                    v6 = v34;\n                    if ( v23 < 0 )\n                      goto LABEL_53;\n                    goto LABEL_60;\n                  }\n                  if ( v4 == v22 )\n                    goto LABEL_60;\n                  v20 = (_DWORD *)((char *)v20 + 1);\n                }\n                v35 = v6;\n                v24 = sub_806FA55(v4);\n                v6 = v35;\n                if ( v24 < 0 && *(_DWORD *)dword_80DBB7C != 9 )\nLABEL_53:\n                  sub_804D604();\n                v25 = v3 + 8 * (_DWORD)v20;\n                *(_DWORD *)(v25 + 12) = v24;\n                *(_DWORD *)(v25 + 8) = v4;\n                if ( v4 == *(_DWORD *)(dword_80DBB90 + 24) )\n                  *(_DWORD *)(dword_80DBB90 + 24) = v24;\n              }\nLABEL_60:\n              v21 = 0;\n            }\n            if ( v6 == -1 )\n              break;\n            if ( v6 == dword_80DB558 )\n            {\nLABEL_75:\n              *(_DWORD *)dword_80DBB7C = 9;\n              sub_806FB57(\"%d: %m\", v6);\n            }\n            v26 = off_80DB55C;\n            if ( v6 )\n            {\n              while ( v26 )\n              {\n                if ( v6 == v26[2] )\n                  goto LABEL_75;\n                v26 = (_DWORD *)*v26;\n              }\n            }\n            if ( v3 )\n            {\n              for ( i = 0; i < *(_DWORD *)(v3 + 4) && *(_DWORD *)(v3 + 8 * i + 8) != -2; ++i )\n              {\n                if ( v6 == *(_DWORD *)(v3 + 8 * i + 12) )\n                  goto LABEL_75;\n              }\n            }\n            sub_806FF10(v6, v4);\n            if ( fd >= 0 )\n              close(fd);\n            v28 = v4 == 1;\n            v4 = 2;\n            v6 = 1;\n            fd = -1;\n            if ( !v28 || *v2 != 17 )\n              goto LABEL_79;\n          }\n          if ( !v21 )\n            close(v4);\n        }\n        goto LABEL_79;\n      }\n    }\n    else\n    {\n      v8 = 0;\n    }\n    if ( !sub_8072B54(0, 0, 2) )\n    {\n      close(pipedes[0]);\n      sub_806F3DD(2);\n      sub_806F3DD(3);\n      sub_806F3DD(1);\n      sub_806F3DD(20);\n      signal(13, 0);\n      v9 = *((_DWORD *)v2 + 3);\n      if ( *v2 == 24 )\n      {\n        v10 = *(char **)(v9 + 8);\n        v11 = v8;\n      }\n      else\n      {\n        sub_8075D0B(v9, 0, 0x80u);\n        v10 = *(char **)(dword_80DBB88 + 4);\n        v11 = dword_80DB6D4 - (_DWORD)v10;\n      }\n      sub_804E586(v11, v10);\n      _exit(0);\n    }\n    goto LABEL_19;\n  }\n  return (char)a1;\n}\n"
        ],
        "134702334": [
            "sub_80764FE",
            "0x80764fe",
            "int __usercall sub_80764FE@<eax>(char *a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // esi\n  int v3; // eax\n  int v6; // [esp+4h] [ebp-34h]\n  struct __jmp_buf_tag *env; // [esp+8h] [ebp-30h]\n  char v8[44]; // [esp+Ch] [ebp-2Ch] BYREF\n\n  env = *(struct __jmp_buf_tag **)(dword_80DBB8C + 32);\n  v6 = *(_DWORD *)(dword_80DBB8C + 36);\n  v1 = _setjmp((struct __jmp_buf_tag *)v8);\n  v2 = dword_80DBB8C;\n  if ( !v1 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v8;\n    sub_80760C6(a1, 1);\n  }\n  *(_DWORD *)(v2 + 32) = env;\n  if ( v1 && *(_BYTE *)(v2 + 43) != 1 )\n    longjmp(env, 1);\n  v3 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 36) = v6;\n  if ( !*(_DWORD *)(v3 + 36) && *(_BYTE *)(v3 + 40) )\n    sub_806F406();\n  return v1;\n}\n"
        ],
        "134702472": [
            "sub_8076588",
            "0x8076588",
            "char __usercall sub_8076588@<al>(int a1@<eax>)\n{\n  int i; // ebx\n  char *v2; // esi\n  int v4[4]; // [esp+0h] [ebp-10h] BYREF\n\n  for ( i = a1; i; i = *(_DWORD *)(i + 4) )\n  {\n    v4[0] = 0;\n    v4[1] = (int)v4;\n    LOBYTE(a1) = *(_BYTE *)i;\n    if ( *(char *)i < 16 )\n      continue;\n    if ( (char)a1 <= 21 )\n    {\n      sub_8075D0B(*(_DWORD *)(i + 16), (int)v4, 0xAu);\nLABEL_8:\n      a1 = *(_DWORD *)(v4[0] + 4);\n      *(_DWORD *)(i + 20) = a1;\n      continue;\n    }\n    if ( (char)a1 <= 23 )\n    {\n      a1 = *(_DWORD *)(i + 16);\n      if ( a1 )\n      {\n        sub_8075D0B(a1, (int)v4, 3u);\n        if ( !v4[0] )\n          goto LABEL_11;\n        v2 = *(char **)(v4[0] + 4);\n        if ( !sub_806EC08(v2) )\n        {\n          if ( *(_DWORD *)(i + 8) != 1 )\nLABEL_11:\n            sub_806FB57(\"redir error\");\n          *(_BYTE *)i = 17;\n          goto LABEL_8;\n        }\n        a1 = sub_804ED6C(10, v2, 0, i);\n        if ( *(_DWORD *)dword_80DBB7C || a1 < 0 )\n        {\n          if ( *v2 != 45 || v2[1] )\n            sub_8070172(\"bad fd number\");\n          *(_DWORD *)(i + 12) = -1;\n        }\n        else\n        {\n          *(_DWORD *)(i + 12) = a1;\n        }\n      }\n    }\n  }\n  return a1;\n}\n"
        ],
        "134702687": [
            "sub_807665F",
            "0x807665f",
            "int __cdecl sub_807665F(int a1, int a2)\n{\n  int v2; // esi\n  char v3; // bl\n  int v4; // ecx\n  int v5; // eax\n  int v6; // ebp\n  int v7; // edx\n  int v8; // ecx\n  int v9; // eax\n  int v11; // [esp+0h] [ebp-1Ch]\n  int v12; // [esp+8h] [ebp-14h]\n\n  v2 = a2;\n  v3 = *(_BYTE *)a1;\n  v12 = *(_BYTE *)a1 == 3;\n  v4 = dword_80DBB90;\n  v5 = *(_DWORD *)(a1 + 4);\n  *(_DWORD *)(dword_80DBB90 + 328) = v5;\n  v6 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 12) = v5;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v4 + 328) = v5 - (dword_80DB698 - 1);\n  sub_8076588(*(_DWORD *)(a1 + 12));\n  if ( v3 == 3 || (a2 & 1) == 0 || *(_BYTE *)(v6 + 188) )\n  {\n    ++*(_DWORD *)(v6 + 36);\n    v6 = sub_807151B(1);\n    if ( sub_8072B54(v6, a1, v12) )\n      goto LABEL_11;\n    sub_806F4A5();\n    if ( v3 == 3 )\n      v2 = a2 & 0xFFFFFFFC | 1;\n    else\n      v2 = a2 | 1;\n  }\n  sub_80760C6(*(char **)(a1 + 12), 0);\n  sub_8074EF2(v7, v8, *(char **)(a1 + 8), v2);\nLABEL_11:\n  v9 = 0;\n  if ( v3 != 3 )\n    v9 = sub_8071014(v6);\n  v11 = v9;\n  sub_806F4A5();\n  return v11;\n}\n"
        ],
        "134702894": [
            "sub_807672E",
            "0x807672e",
            "int __cdecl sub_807672E(_DWORD *a1, int a2)\n{\n  int v2; // ecx\n  int v3; // eax\n  _DWORD *v4; // ebx\n  int v5; // ebx\n  _DWORD *i; // esi\n  const char *v7; // ebp\n  int v8; // edi\n  const char *v9; // eax\n  int v10; // edi\n  int v11; // edx\n  int v12; // ecx\n  char *v13; // eax\n  int v15[2]; // [esp+0h] [ebp-30h] BYREF\n  _DWORD v16[3]; // [esp+8h] [ebp-28h] BYREF\n  _DWORD v17[7]; // [esp+14h] [ebp-1Ch] BYREF\n\n  v2 = dword_80DBB90;\n  v3 = a1[1];\n  *(_DWORD *)(dword_80DBB90 + 328) = v3;\n  *(_DWORD *)(dword_80DBB8C + 12) = v3;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v2 + 328) = v3 - (dword_80DB698 - 1);\n  sub_8070056(v16);\n  v15[0] = 0;\n  v15[1] = (int)v15;\n  sub_8075D0B(a1[2], (int)v15, 2u);\n  v4 = (_DWORD *)a1[3];\nLABEL_4:\n  if ( v4 && !byte_80DB76C )\n  {\n    for ( i = (_DWORD *)v4[2]; ; i = (_DWORD *)i[1] )\n    {\n      if ( !i )\n      {\n        v4 = (_DWORD *)v4[1];\n        goto LABEL_4;\n      }\n      v7 = *(const char **)(v15[0] + 4);\n      sub_8070056(v17);\n      dword_80DB6D0 = i[3];\n      v8 = dword_80DBB88;\n      dword_80DB6D4 = *(_DWORD *)(dword_80DBB88 + 4);\n      sub_807510E(i[2], 0x12u);\n      if ( *(_DWORD *)(v8 + 8) == dword_80DB6D4 )\n        dword_80DB6D4 = sub_8071CBE();\n      *(_BYTE *)dword_80DB6D4 = 0;\n      sub_806F5DA();\n      v9 = sub_80719CE(*(const char **)(v8 + 4), 2, 0);\n      v10 = fnmatch(v9, v7, 0);\n      sub_806FA10(v17);\n      if ( !v10 )\n        break;\n    }\n    if ( !byte_80DB76C )\n    {\n      v13 = (char *)v4[3];\n      if ( v13 )\n      {\n        v5 = sub_8074EF2(v11, v12, v13, a2);\n        goto LABEL_17;\n      }\n    }\n  }\n  v5 = 0;\nLABEL_17:\n  sub_806FA10(v16);\n  return v5;\n}\n"
        ],
        "134703217": [
            "sub_8076871",
            "0x8076871",
            "int __usercall sub_8076871@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char a4)\n{\n  int v4; // ebx\n  int v5; // ebp\n  int v6; // eax\n  int v8; // [esp-8h] [ebp-18h]\n  int v9; // [esp-8h] [ebp-18h]\n  int v10; // [esp-4h] [ebp-14h]\n  int v11; // [esp-4h] [ebp-14h]\n\n  ++dword_80DB69C;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = sub_8074EF2(a1, a2, *(char **)(a3 + 4), 2);\n    v6 = sub_806EDB0();\n    a1 = v8;\n    a2 = v10;\n    if ( v6 == 4 )\n    {\n      v4 = v5;\n      goto LABEL_9;\n    }\n    if ( !v6 )\n      break;\nLABEL_9:\n    if ( (v6 & 0xFFFFFFFD) != 0 )\n      goto LABEL_10;\n  }\n  if ( *(_BYTE *)a3 != 9 )\n    v5 = v5 == 0;\n  if ( !v5 )\n  {\n    v4 = sub_8074EF2(v8, v10, *(char **)(a3 + 8), a4 & 2);\n    v6 = sub_806EDB0();\n    a1 = v9;\n    a2 = v11;\n    goto LABEL_9;\n  }\nLABEL_10:\n  --dword_80DB69C;\n  return v4;\n}\n"
        ],
        "134703326": [
            "sub_80768DE",
            "0x80768de",
            "int __cdecl sub_80768DE(int a1, char a2)\n{\n  int v2; // ecx\n  int v3; // eax\n  int i; // ebx\n  int v5; // ebx\n  int v6; // ebp\n  int v7; // edx\n  int v8; // ecx\n  int v10; // [esp+0h] [ebp-24h] BYREF\n  int *v11; // [esp+4h] [ebp-20h]\n  _DWORD v12[7]; // [esp+8h] [ebp-1Ch] BYREF\n\n  v2 = dword_80DBB90;\n  v3 = *(_DWORD *)(a1 + 4);\n  *(_DWORD *)(dword_80DBB90 + 328) = v3;\n  *(_DWORD *)(dword_80DBB8C + 12) = v3;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v2 + 328) = v3 - (dword_80DB698 - 1);\n  sub_8070056(v12);\n  v10 = 0;\n  v11 = &v10;\n  for ( i = *(_DWORD *)(a1 + 8); i; i = *(_DWORD *)(i + 4) )\n    sub_8075D0B(i, (int)&v10, 3u);\n  *v11 = 0;\n  ++dword_80DB69C;\n  v5 = v10;\n  v6 = 0;\n  while ( v5 )\n  {\n    sub_806FE06(*(_DWORD *)(a1 + 16), *(const char **)(v5 + 4));\n    v6 = sub_8074EF2(v7, v8, *(char **)(a1 + 12), a2 & 2);\n    if ( (sub_806EDB0() & 0xFFFFFFFD) != 0 )\n      break;\n    v5 = *(_DWORD *)v5;\n  }\n  --dword_80DB69C;\n  sub_806FA10(v12);\n  return v6;\n}\n"
        ],
        "134703521": [
            "sub_80769A1",
            "0x80769a1",
            "void __usercall __noreturn sub_80769A1(__pid_t a1@<esi>)\n{\n  bool v1; // zf\n  int v2; // eax\n  const char *v3; // eax\n  int status; // [esp+0h] [ebp-28h]\n  char v5[36]; // [esp+4h] [ebp-24h] BYREF\n\n  status = *(unsigned __int8 *)dword_80DBB8C;\n  v1 = _setjmp((struct __jmp_buf_tag *)v5) == 0;\n  v2 = dword_80DBB8C;\n  if ( v1 )\n  {\n    *(_DWORD *)(dword_80DBB8C + 32) = v5;\n    v3 = *(const char **)(v2 + 192);\n    if ( v3 )\n    {\n      *(_DWORD *)(dword_80DBB8C + 192) = 0;\n      byte_80DB76C = 0;\n      sub_8074C7C(v3, 0);\n    }\n  }\n  else if ( *(_BYTE *)(dword_80DBB8C + 43) == 4 )\n  {\n    status = *(unsigned __int8 *)dword_80DBB8C;\n  }\n  sub_807050F(0, a1);\n  sub_806F4BD();\n  _exit(status);\n}\n"
        ],
        "134703636": [
            "sub_8076A14",
            "0x8076a14",
            "int __usercall sub_8076A14@<eax>(unsigned __int8 a1@<al>)\n{\n  int v2; // esi\n  int v3; // edi\n  char *v4; // ebx\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // eax\n  char *v10; // [esp+0h] [ebp-20h]\n  _DWORD v11[7]; // [esp+4h] [ebp-1Ch] BYREF\n\n  v2 = 0;\n  v3 = 0;\n  do\n  {\n    sub_8070056(v11);\n    if ( byte_80DB76D )\n      sub_80711FF((char *)0xC);\n    v4 = (char *)dword_80DBB8C;\n    v5 = sub_8074C47(a1 & (*(_BYTE *)(dword_80DBB8C + 48) != 0));\n    if ( v5 == (char *)-1 )\n    {\n      if ( (a1 & 1) == 0 || v2 > 49 )\n        return v3;\n      if ( !sub_8070BEF() )\n      {\n        if ( !v4[47] )\n          return v3;\n        sub_8070BC7((int)\"\\nUse \\\"exit\\\" to leave shell.\\n\");\n      }\n      ++v2;\n    }\n    else if ( !v4[50] )\n    {\n      v4[2] >>= 1;\n      v10 = v5;\n      v8 = sub_8074EF2(v6, v7, v5, 0);\n      v2 = 0;\n      if ( v10 )\n        v3 = v8;\n    }\n    sub_806FA10(v11);\n  }\n  while ( !byte_80DB76C );\n  byte_80DB76C &= ~4u;\n  return v3;\n}\n"
        ],
        "134703819": [
            "sub_8076ACB",
            "0x8076acb",
            "void __noreturn sub_8076ACB()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134704115": [
            "sub_8076BF3",
            "0x8076bf3",
            "char __usercall sub_8076BF3@<al>(const char *a1@<eax>)\n{\n  int v1; // eax\n  int v2; // eax\n\n  v1 = sub_8074AA5(a1, 1);\n  v2 = sub_807009B(v1, 3);\n  if ( v2 >= 0 )\n  {\n    sub_8076A14(0);\n    LOBYTE(v2) = sub_806F6F7();\n  }\n  return v2;\n}\n"
        ],
        "134704152": [
            "sub_8076C18",
            "0x8076c18",
            "void sub_8076C18()\n{\n  int v0; // ebx\n  int v1; // edi\n  unsigned int v2; // esi\n  int v3; // eax\n  _DWORD *v4; // eax\n  int v5; // [esp+0h] [ebp-14h]\n\n  v0 = dword_80DB690;\n  dword_80DB690 = 0;\n  while ( v0 )\n  {\n    sub_8074B7B(byte_80DB76E, 2);\n    v1 = *(char *)(v0 + 12);\n    v2 = *(_DWORD *)(v0 + 8);\n    v5 = (**(_BYTE **)(v0 + 4) == 24) + 1;\n    v3 = sub_8073952();\n    sub_8073F3E(v3, v5, v2, v1);\n    v4 = sub_8070C51(0x10u);\n    *(_BYTE *)v4 = 15;\n    v4[2] = dword_80DB68C;\n    v4[3] = dword_80DB688;\n    *(_DWORD *)(*(_DWORD *)(v0 + 4) + 12) = v4;\n    v0 = *(_DWORD *)v0;\n  }\n}\n"
        ],
        "134704287": [
            "sub_8076C9F",
            "0x8076c9f",
            "_DWORD *__fastcall sub_8076C9F(int a1)\n{\n  int v1; // edi\n  int v2; // ecx\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  int v5; // ecx\n  int v6; // ecx\n  int v7; // eax\n  int v8; // ecx\n  _DWORD *v9; // ebp\n  int v10; // ecx\n  _DWORD *v11; // esi\n  int v12; // ecx\n  int v13; // ecx\n  int v14; // ecx\n  int v15; // esi\n  int v16; // ecx\n  int v17; // ecx\n  int v18; // ecx\n  int v19; // edx\n  int v20; // ecx\n  const char *v21; // eax\n  int v22; // ecx\n  int v23; // ecx\n  int *v24; // esi\n  int v25; // ecx\n  _DWORD *v26; // eax\n  _DWORD *v27; // eax\n  int v28; // ecx\n  int v29; // ecx\n  _DWORD *v30; // eax\n  int v31; // ecx\n  int v32; // ecx\n  _DWORD *v33; // ebp\n  _DWORD *v34; // esi\n  _DWORD *v35; // ebp\n  _DWORD *v36; // eax\n  int v37; // ecx\n  int v38; // ecx\n  int v39; // ecx\n  int v40; // eax\n  int v41; // ecx\n  int *v42; // ebp\n  int *v43; // edi\n  int v44; // eax\n  int v45; // edx\n  int v46; // eax\n  char *v47; // edx\n  const char *v48; // esi\n  int v49; // eax\n  int v50; // eax\n  int *v51; // edx\n  const char *v52; // eax\n  unsigned int v53; // eax\n  int v54; // eax\n  int v55; // eax\n  const void *v56; // esi\n  _BYTE **v57; // eax\n  int *v58; // esi\n  int v59; // ecx\n  int v60; // eax\n  int v61; // esi\n  _DWORD *v62; // eax\n  int v64; // [esp-8h] [ebp-44h]\n  int v65; // [esp-4h] [ebp-40h]\n  int v66; // [esp-4h] [ebp-40h]\n  int v67; // [esp-4h] [ebp-40h]\n  _DWORD *v68; // [esp+0h] [ebp-3Ch]\n  char v69; // [esp+0h] [ebp-3Ch]\n  int *v70; // [esp+4h] [ebp-38h]\n  int v71; // [esp+8h] [ebp-34h]\n  char v72; // [esp+Fh] [ebp-2Dh]\n  int v73; // [esp+10h] [ebp-2Ch]\n  _DWORD *v74; // [esp+18h] [ebp-24h] BYREF\n  int v75; // [esp+1Ch] [ebp-20h] BYREF\n  int v76; // [esp+20h] [ebp-1Ch] BYREF\n  int v77; // [esp+24h] [ebp-18h] BYREF\n  int v78; // [esp+28h] [ebp-14h] BYREF\n\n  v75 = 0;\n  v1 = *((_DWORD *)off_80DB55C + 1);\n  switch ( sub_8073C7A(a1) )\n  {\n    case 2:\n    case 3:\n    case 22:\n      byte_80DB76A = 1;\n      v76 = 0;\n      v77 = 0;\n      v78 = 0;\n      v73 = *((_DWORD *)off_80DB55C + 1);\n      v69 = 0;\n      v72 = 0;\n      v71 = 1;\n      v42 = &v78;\n      v70 = &v77;\n      v3 = 0;\n      v43 = &v76;\n      break;\n    case 9:\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 4;\n      v3[1] = v1;\n      v3[2] = sub_8073DE5(0, v41);\n      v15 = 10;\n      goto LABEL_96;\n    case 14:\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 12;\n      v3[1] = v1;\n      if ( sub_8073C7A(v29) != 3 )\n        goto LABEL_33;\n      v30 = sub_8070C51(0x10u);\n      v3[2] = v30;\n      *(_BYTE *)v30 = 15;\n      v30[2] = dword_80DB68C;\n      v30[3] = dword_80DB688;\n      byte_80DB76B = 7;\n      if ( sub_8073C7A(v31) != 24 )\n      {\n        v7 = 24;\n        goto LABEL_4;\n      }\n      v33 = v3 + 3;\n      while ( 1 )\n      {\n        byte_80DB76B = 6;\n        if ( sub_8073C7A(v32) == 19 )\n          break;\n        if ( byte_80DB768 == 9 )\n          sub_8073C7A(v32);\n        v34 = sub_8070C51(0x10u);\n        *v33 = v34;\n        *(_BYTE *)v34 = 13;\n        v35 = v34 + 2;\n        while ( 1 )\n        {\n          v36 = sub_8070C51(0x10u);\n          v74 = v36;\n          *v35 = v36;\n          *(_BYTE *)v36 = 15;\n          v36[2] = dword_80DB68C;\n          v36[3] = dword_80DB688;\n          v68 = v36;\n          if ( sub_8073C7A(v37) != 8 )\n            break;\n          v35 = v68 + 1;\n          sub_8073C7A(v38);\n        }\n        if ( byte_80DB768 != 10 )\n          goto LABEL_44;\n        v34[3] = sub_8073DE5(2, v38);\n        v33 = v34 + 1;\n        byte_80DB76B = 6;\n        v40 = sub_8073C7A(v39);\n        if ( v40 == 19 )\n          break;\n        if ( v40 != 11 )\n        {\n          v7 = 11;\n          goto LABEL_4;\n        }\n      }\n      *v33 = 0;\n      goto LABEL_98;\n    case 21:\n      if ( sub_8073C7A(v2) != 3 || byte_80DB769 || *(_BYTE *)sub_80AB128(v20, v19) )\n      {\n        v21 = \"bad for loop variable\";\n        goto LABEL_91;\n      }\n      v3 = sub_8070C51(0x14u);\n      *(_BYTE *)v3 = 11;\n      v3[1] = v1;\n      v3[4] = dword_80DB68C;\n      byte_80DB76B = 7;\n      if ( sub_8073C7A(v22) == 24 )\n      {\n        v24 = (int *)&v74;\n        while ( sub_8073C7A(v23) == 3 )\n        {\n          v26 = sub_8070C51(0x10u);\n          *(_BYTE *)v26 = 15;\n          v26[2] = dword_80DB68C;\n          v26[3] = dword_80DB688;\n          *v24 = (int)v26;\n          v24 = v26 + 1;\n        }\n        *v24 = 0;\n        v3[2] = v74;\n        if ( byte_80DB768 != 4 && byte_80DB768 != 1 )\n          goto LABEL_26;\n      }\n      else\n      {\n        v27 = sub_8070C51(0x10u);\n        *(_BYTE *)v27 = 15;\n        v27[2] = &unk_80D0F91;\n        v3[2] = v27;\n        if ( byte_80DB768 != 4 )\n          byte_80DB76A = 1;\n      }\n      byte_80DB76B = 7;\n      if ( sub_8073C7A(v25) != 15 )\n      {\nLABEL_14:\n        v7 = 15;\n        goto LABEL_4;\n      }\n      v3[3] = sub_8073DE5(0, v28);\nLABEL_31:\n      v15 = 16;\n      goto LABEL_96;\n    case 23:\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 8;\n      v3[1] = sub_8073DE5(0, v4);\n      if ( sub_8073C7A(v5) != 25 )\n        goto LABEL_3;\n      v3[2] = sub_8073DE5(0, v6);\n      v9 = v3;\n      while ( 2 )\n      {\n        if ( sub_8073C7A(v8) == 17 )\n        {\n          v11 = sub_8070C51(0x10u);\n          v9[3] = v11;\n          *(_BYTE *)v11 = 8;\n          v11[1] = sub_8073DE5(0, v12);\n          if ( sub_8073C7A(v13) == 25 )\n          {\n            v11[2] = sub_8073DE5(0, v14);\n            v9 = v11;\n            continue;\n          }\nLABEL_3:\n          v7 = 25;\n          goto LABEL_4;\n        }\n        break;\n      }\n      if ( byte_80DB768 == 18 )\n      {\n        v9[3] = sub_8073DE5(0, v10);\n      }\n      else\n      {\n        v9[3] = 0;\n        byte_80DB76A = 1;\n      }\n      v15 = 20;\nLABEL_96:\n      if ( sub_8073C7A(v10) != v15 )\n      {\n        v7 = v15;\n        goto LABEL_4;\n      }\nLABEL_98:\n      byte_80DB76B = 3;\n      v58 = &v75;\n      while ( sub_8073C7A(v32) == 2 )\n      {\n        v60 = dword_80DB684;\n        *v58 = dword_80DB684;\n        v58 = (int *)(v60 + 4);\n        sub_8073D17(v59);\n      }\n      byte_80DB76A = 1;\n      *v58 = 0;\n      v61 = v75;\n      if ( v75 )\n      {\n        if ( *(_BYTE *)v3 != 4 )\n        {\n          v62 = sub_8070C51(0x10u);\n          *(_BYTE *)v62 = 2;\n          v62[1] = v1;\n          v62[2] = v3;\n          v3 = v62;\n        }\n        v3[3] = v61;\n      }\n      return v3;\n    case 26:\n    case 27:\n      v3 = sub_8070C51(0xCu);\n      *(_BYTE *)v3 = (byte_80DB768 != 27) + 9;\n      v3[1] = sub_8073DE5(0, v16);\n      if ( sub_8073C7A(v17) != 15 )\n        goto LABEL_14;\n      v3[2] = sub_8073DE5(0, v18);\n      goto LABEL_31;\n    case 28:\n      v3 = sub_8073DE5(0, v2);\n      v15 = 29;\n      goto LABEL_96;\n    default:\n      goto LABEL_26;\n  }\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      byte_80DB76B = v71;\n      v44 = sub_8073C7A(v2);\n      if ( v44 > 7 )\n        break;\n      if ( v44 >= 6 )\n      {\n        if ( !v72 )\n          goto LABEL_95;\n        v47 = \"-o\";\n        if ( v44 == 6 )\n          v47 = (char *)\"-a\";\n        dword_80DB68C = v47;\n      }\n      else\n      {\n        if ( v44 == 2 )\n        {\n          v3 = (_DWORD *)dword_80DB684;\n          *v42 = dword_80DB684;\n          v42 = v3 + 1;\n          sub_8073D17(v2);\n          continue;\n        }\n        if ( v44 != 3 )\n          goto LABEL_95;\n      }\n      v3 = sub_8070C51(0x10u);\n      *(_BYTE *)v3 = 15;\n      v48 = dword_80DB68C;\n      v3[2] = dword_80DB68C;\n      v49 = strcmp(\"[[\", v48);\n      v2 = v65;\n      if ( v49 )\n      {\n        v50 = strcmp(\"]]\", v48);\n        v2 = v66;\n        if ( !v50 )\n          v72 = 0;\n      }\n      else\n      {\n        v72 = 1;\n      }\n      v3[3] = dword_80DB688;\n      v51 = v3 + 1;\n      if ( v71 && (v52 = (const char *)((int (*)(void))sub_80AB128)(), v51 = v3 + 1, v48 != v52) && *v52 == 61 )\n      {\n        *v70 = (int)v3;\n        v70 = v3 + 1;\n      }\n      else\n      {\n        *v43 = (int)v3;\n        v43 = v51;\n        v71 = 0;\n      }\n      if ( v69 )\n      {\n        byte_80DB76B = 6;\n        v53 = sub_8073C7A(v2);\n        v2 = v53;\n        byte_80DB76A = 1;\n        if ( v53 > 0x1C )\n          goto LABEL_26;\n        v54 = 1 << v53;\n        if ( ((1 << v2) & 0x1CA04000) == 0 )\n        {\n          if ( (v54 & 0x200) != 0 )\n          {\n            v69 = 0;\n            continue;\n          }\n          if ( (v54 & 8) == 0 || (v55 = strcmp(\"[[\", dword_80DB68C), v45 = v64, v2 = v67, v55) )\n          {\nLABEL_26:\n            v7 = -1;\n            goto LABEL_4;\n          }\n        }\nLABEL_83:\n        if ( v76 && v43 == (int *)(v76 + 4) && !v77 && !v78 )\n        {\n          if ( v69 || sub_8073C7A(v2) == 10 )\n          {\n            v56 = (const void *)v3[2];\n            if ( !*(_BYTE *)sub_80AB128(v2, v45) )\n            {\n              v57 = (_BYTE **)sub_8070CB3(v56);\n              if ( !v57 || (**v57 & 1) == 0 )\n              {\n                *(_BYTE *)v3 = 14;\n                byte_80DB76B = 7;\n                v3[1] = *((_DWORD *)off_80DB55C + 1);\n                v3[3] = sub_8076C9F();\n                return v3;\n              }\n            }\n            v21 = \"bad function name\";\nLABEL_91:\n            sub_8070172(v21);\n          }\nLABEL_44:\n          v7 = 10;\nLABEL_4:\n          sub_807275C(v7);\n        }\nLABEL_95:\n        byte_80DB76A = 1;\n        *v43 = 0;\n        *v70 = 0;\n        *v42 = 0;\n        v3 = sub_8070C51(0x14u);\n        v3[1] = v73;\n        v3[3] = v76;\n        v3[2] = v77;\n        v3[4] = v78;\n        return v3;\n      }\n    }\n    if ( v44 == 9 )\n      goto LABEL_83;\n    if ( v44 == 22 )\n    {\n      v46 = sub_8073C7A(v2);\n      byte_80DB76A = 1;\n      if ( v46 == 3 )\n      {\n        v69 = 1;\n        continue;\n      }\nLABEL_33:\n      v7 = 3;\n      goto LABEL_4;\n    }\n    goto LABEL_95;\n  }\n}\n"
        ],
        "134705957": [
            "sub_8077325",
            "0x8077325",
            "_DWORD *__fastcall sub_8077325(int a1)\n{\n  int v1; // ecx\n  int v2; // ebp\n  _DWORD *v3; // ebx\n  int v4; // ecx\n  _DWORD *v5; // edi\n  _DWORD *v6; // esi\n  _DWORD *v7; // ebx\n  int v8; // ecx\n  int v9; // ecx\n  _DWORD *v10; // eax\n\n  if ( sub_8073C7A(a1) == 13 )\n  {\n    byte_80DB76B = 3;\n    v2 = 1;\n  }\n  else\n  {\n    byte_80DB76A = 1;\n    v2 = 0;\n  }\n  v3 = sub_8076C9F(v1);\n  if ( sub_8073C7A(v4) == 8 )\n  {\n    v5 = sub_8070C51(8u);\n    *(_BYTE *)v5 = 1;\n    v6 = sub_8070C51(8u);\n    v5[1] = v6;\n    v6[1] = v3;\n    do\n    {\n      v7 = sub_8070C51(8u);\n      byte_80DB76B = 7;\n      v7[1] = sub_8076C9F(v8);\n      *v6 = v7;\n      v6 = v7;\n    }\n    while ( sub_8073C7A(v9) == 8 );\n    *v7 = 0;\n    v3 = v5;\n  }\n  byte_80DB76A = 1;\n  if ( v2 )\n  {\n    v10 = sub_8070C51(8u);\n    *(_BYTE *)v10 = 26;\n    v10[1] = v3;\n    return v10;\n  }\n  return v3;\n}\n"
        ],
        "134706124": [
            "sub_80773CC",
            "0x80773cc",
            "char __usercall sub_80773CC@<al>(int a1@<eax>)\n{\n  _DWORD *v2; // eax\n  void *v3; // ebx\n  _DWORD *v4; // esi\n  int v5; // edx\n  int v6; // edi\n  int v7; // eax\n  const void *v8; // esi\n  void (*v9)(void); // edx\n  char *v10; // eax\n  char v11; // cl\n  void *v13; // [esp+0h] [ebp-14h]\n\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v2 = dword_80DB694;\n  dword_80DB694 = *(void **)dword_80DB694;\n  v3 = (void *)v2[1];\n  free(v2);\n  while ( v3 )\n  {\n    v13 = *(void **)v3;\n    v4 = (_DWORD *)*((_DWORD *)v3 + 1);\n    if ( a1 )\n    {\n      v5 = *((_DWORD *)v3 + 2);\n      v6 = 4;\n      if ( v5 != 32 )\n      {\n        v6 = 12;\n        if ( v4[2] != *((_DWORD *)v3 + 3) )\n        {\n          v6 = 4;\n          if ( (v5 & 0x18) == 0 )\n            free(*((void **)v3 + 3));\n        }\n      }\n      v7 = v4[1] ^ v6 & (v4[1] ^ *((_DWORD *)v3 + 2));\n      v4[1] = v7;\n      if ( (v7 & 0x27) == 32 )\n        goto LABEL_14;\n    }\n    else\n    {\n      if ( !v4 )\n      {\n        v8 = (const void *)*((_DWORD *)v3 + 3);\n        qmemcpy((void *)(dword_80DBB8C + 45), v8, 0xFu);\n        free(*((void **)v3 + 3));\n        sub_8070672((__pid_t)v8 + 15);\n        goto LABEL_23;\n      }\n      if ( *((_DWORD *)v3 + 2) == 32 )\n      {\n        v4[1] &= 0xFFFFFFF9;\nLABEL_14:\n        sub_806FDFD(v4[2]);\n        goto LABEL_23;\n      }\n      v9 = (void (*)(void))v4[3];\n      if ( v9 )\n      {\n        v10 = (char *)*((_DWORD *)v3 + 3);\n        do\n        {\n          v11 = *v10;\n          if ( !*v10 )\n            break;\n          ++v10;\n        }\n        while ( v11 != 61 );\n        v9();\n      }\n      if ( (v4[1] & 0x18) == 0 )\n        free((void *)v4[2]);\n      v4[1] = *((_DWORD *)v3 + 2);\n      v4[2] = *((_DWORD *)v3 + 3);\n    }\nLABEL_23:\n    free(v3);\n    v3 = v13;\n  }\n  return sub_806F4A5();\n}\n"
        ],
        "134706396": [
            "sub_80774DC",
            "0x80774dc",
            "int __usercall sub_80774DC@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, char a4)\n{\n  int v4; // ebp\n  int v5; // eax\n  _DWORD *v6; // ebx\n  int v7; // edx\n  int v8; // ecx\n  int v9; // ebx\n  int v12; // [esp+4h] [ebp-58h]\n  int v15; // [esp+10h] [ebp-4Ch]\n  char v16[20]; // [esp+14h] [ebp-48h] BYREF\n  char v17[52]; // [esp+28h] [ebp-34h] BYREF\n\n  qmemcpy(v16, (const void *)dword_80DBB90, sizeof(v16));\n  v12 = dword_80DB698;\n  v15 = *(_DWORD *)(dword_80DBB8C + 32);\n  v4 = _setjmp((struct __jmp_buf_tag *)v17);\n  v5 = dword_80DBB8C;\n  if ( !v4 )\n  {\n    ++*(_DWORD *)(dword_80DBB8C + 36);\n    *(_DWORD *)(v5 + 32) = v17;\n    v6 = (_DWORD *)dword_80DBB90;\n    *(_BYTE *)(dword_80DBB90 + 12) = 0;\n    ++*(_DWORD *)a1;\n    dword_80DB698 = *(_DWORD *)(a1 + 8);\n    sub_806F4A5();\n    *v6 = a2 - 1;\n    v6[4] = a3 + 4;\n    v6[1] = 1;\n    v6[2] = -1;\n    sub_806F84B();\n    sub_8074EF2(v7, v8, *(char **)(a1 + 16), a4 & 2);\n    sub_80773CC(0);\n  }\n  v9 = dword_80DBB8C;\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  dword_80DB698 = v12;\n  sub_806EEEB((_DWORD *)a1);\n  sub_806EEC0(dword_80DBB90);\n  qmemcpy((void *)dword_80DBB90, v16, 0x14u);\n  *(_DWORD *)(v9 + 32) = v15;\n  sub_806F4A5();\n  byte_80DB76C &= ~4u;\n  return v4;\n}\n"
        ],
        "134706667": [
            "sub_80775EB",
            "0x80775eb",
            "char __usercall sub_80775EB@<al>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>, char *haystack)\n{\n  char *v6; // eax\n  char *v7; // eax\n  const char *v8; // eax\n  const char *v9; // ebp\n  char v10; // dl\n  int v11; // eax\n  char *v12; // eax\n  int v13; // eax\n  const char *v14; // edi\n  size_t v15; // eax\n  const char *v16; // eax\n  int v17; // eax\n  const char *v18; // eax\n  char *v19; // eax\n  char v21; // [esp-4h] [ebp-9Ch]\n  int v23; // [esp+4h] [ebp-94h]\n  char *v24; // [esp+8h] [ebp-90h]\n  _BYTE *v25; // [esp+Ch] [ebp-8Ch]\n  int v26; // [esp+10h] [ebp-88h]\n  _BOOL4 v27; // [esp+14h] [ebp-84h]\n  int v28; // [esp+18h] [ebp-80h]\n  int v29[3]; // [esp+1Ch] [ebp-7Ch] BYREF\n  char v30[16]; // [esp+28h] [ebp-70h] BYREF\n  int v31; // [esp+38h] [ebp-60h]\n\n  v6 = strchr(a1, 47);\n  if ( v6 )\n  {\n    *(_DWORD *)(a2 + 4) = -1;\n    if ( (a3 & 2) != 0 && (v6 = (char *)stat64(a1, v30), (int)v6 < 0) )\nLABEL_5:\n      *(_BYTE *)a2 = -1;\n    else\n      *(_BYTE *)a2 = 0;\n    return (char)v6;\n  }\n  v7 = (char *)(*(_DWORD *)(dword_80DBB90 + 208) + 5);\n  v27 = v7 == haystack;\n  if ( v7 != haystack )\n  {\n    if ( strstr(haystack, \"%builtin\") )\n      a3 |= 0x28u;\n    else\n      a3 |= 8u;\n  }\n  v8 = sub_806F11D(a1, 0);\n  v9 = v8;\n  if ( v8 )\n  {\n    v10 = v8[8];\n    v11 = 4;\n    if ( v10 != 1 )\n      v11 = v10 == 2 ? 32 : 8;\n    if ( (v11 & a3) != 0 )\n    {\n      v27 = 0;\n      v9 = 0;\n    }\n    else if ( !v9[9] )\n    {\n      goto LABEL_66;\n    }\n  }\n  v12 = (char *)sub_8070CB3(a1);\n  v24 = v12;\n  if ( !v12 )\n    goto LABEL_23;\n  if ( (**(_BYTE **)v12 & 2) != 0 )\n    goto LABEL_62;\n  if ( (a3 & 8) == 0 )\n  {\n    if ( dword_80DB554 > 0 )\n      goto LABEL_23;\nLABEL_62:\n    if ( v27 )\n    {\n      ++*(_DWORD *)(dword_80DBB8C + 36);\n      v9 = sub_806F11D(a1, 1);\n      *((_BYTE *)v9 + 8) = 2;\n      v17 = (int)v24;\n      goto LABEL_65;\n    }\n    *(_BYTE *)a2 = 2;\n    v6 = v24;\n    goto LABEL_67;\n  }\n  if ( (a3 & 0x20) == 0 )\n    goto LABEL_62;\nLABEL_23:\n  v26 = -1;\n  if ( v9 && v9[9] )\n  {\n    v13 = dword_80DB554;\n    if ( v9[8] != 2 )\n      v13 = *((_DWORD *)v9 + 1);\n    v26 = v13;\n  }\n  v28 = 2;\n  v23 = -1;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v6 = (char *)sub_8071D7C(&haystack, a1);\n          v14 = v6;\n          if ( !v6 )\n          {\n            if ( v9 && v27 )\n              LOBYTE(v6) = sub_806F817();\n            if ( (a3 & 1) != 0 )\n            {\n              v18 = sub_806F11D(\"command_not_found_handle\", 0);\n              if ( v18 && v18[8] == 1 )\n              {\n                v29[0] = (int)\"command_not_found_handle\";\n                v29[1] = (int)a1;\n                v29[2] = 0;\n                sub_80774DC(*((_DWORD *)v18 + 1), 2, (int)v29, 0);\n                *(_BYTE *)a2 = -1;\n                LOBYTE(v6) = v21;\n                return (char)v6;\n              }\n              v19 = sub_80720F6(v28, \"not found\");\n              LOBYTE(v6) = sub_8070501(\"%s: %s\", a1, v19);\n            }\n            goto LABEL_5;\n          }\n          sub_806EC35((int)v6);\n          ++v23;\n          v25 = (_BYTE *)dword_80DB6FC;\n          if ( !dword_80DB6FC )\n            break;\n          if ( sub_806EC47((_BYTE *)dword_80DB6FC, \"builtin\") )\n          {\n            if ( v24 )\n              goto LABEL_62;\n          }\n          else if ( (a3 & 4) == 0 && sub_806EC47(v25, \"func\") )\n          {\n            break;\n          }\n        }\n        if ( *v14 != 47 || v26 < v23 )\n          break;\n        if ( v26 <= v23 )\n          goto LABEL_66;\n      }\n      if ( stat64(v14, v30) >= 0 )\n        break;\n      if ( *(_DWORD *)dword_80DBB7C != 2 && *(_DWORD *)dword_80DBB7C != 20 )\n        v28 = *(_DWORD *)dword_80DBB7C;\n    }\n    if ( (v31 & 0xF000) == 0x8000 )\n      break;\n    v28 = 13;\n  }\n  if ( v25 )\n  {\n    v15 = strlen(v14);\n    sub_806FFC6(v15 + 1);\n    sub_807009B((int)v14, 1);\n    sub_8076A14(0);\n    sub_806F6F7();\n    v16 = sub_806F11D(a1, 0);\n    v9 = v16;\n    if ( !v16 || v16[8] != 1 )\n      sub_806FB57(\"%s not defined in %s\", a1, v14);\n    sub_806EC35((int)v14);\n    goto LABEL_66;\n  }\n  if ( !v27 )\n  {\n    *(_BYTE *)a2 = 0;\n    v6 = (char *)v23;\n    goto LABEL_67;\n  }\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v9 = sub_806F11D(a1, 1);\n  *((_BYTE *)v9 + 8) = 0;\n  v17 = v23;\nLABEL_65:\n  *((_DWORD *)v9 + 1) = v17;\n  sub_806F4A5();\nLABEL_66:\n  *((_BYTE *)v9 + 9) = 0;\n  *(_BYTE *)a2 = v9[8];\n  v6 = (char *)*((_DWORD *)v9 + 1);\nLABEL_67:\n  *(_DWORD *)(a2 + 4) = v6;\n  return (char)v6;\n}\n"
        ],
        "134707562": [
            "sub_807796A",
            "0x807796a",
            "int __usercall sub_807796A@<eax>(int a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  const char *v3; // esi\n  int v4; // ebx\n  int v5; // edi\n  int v6; // ecx\n  _BYTE **v7; // edi\n  int v8; // eax\n  int v9; // eax\n  const char *v10; // eax\n  const char *v11; // eax\n  char *v13; // [esp+0h] [ebp-1Ch] BYREF\n  char v14[4]; // [esp+4h] [ebp-18h] BYREF\n  _BYTE **v15; // [esp+8h] [ebp-14h]\n\n  v3 = (const char *)a1;\n  v13 = a2;\n  v4 = a3;\n  if ( !a2 )\n    a2 = (char *)(*(_DWORD *)(dword_80DBB90 + 208) + 5);\n  v13 = a2;\n  if ( a3 )\n    sub_8072DB0(a1);\n  if ( sub_8070CCB(v3) )\n  {\n    if ( v4 )\n      v3 = \" is a shell keyword\";\n    goto LABEL_24;\n  }\n  v5 = *sub_806F0C2(v3);\n  if ( v5 )\n  {\n    if ( !v4 )\n    {\n      sub_8072DB0((int)\"alias \");\n      sub_807176F(v5, v6);\n      return v4;\n    }\n    sub_80708A7(\" is an alias for %s\", *(_DWORD *)(v5 + 8));\nLABEL_30:\n    sub_8072DB0(135081797);\n    return 0;\n  }\n  sub_80775EB(v3, (int)v14, 2, v13);\n  switch ( v14[0] )\n  {\n    case 1:\n      if ( v4 )\n      {\n        v10 = \" is a shell function\";\nLABEL_22:\n        sub_8072DB0((int)v10);\n        goto LABEL_30;\n      }\nLABEL_24:\n      v10 = v3;\n      goto LABEL_22;\n    case 2:\n      if ( v4 )\n      {\n        v11 = \"special \";\n        if ( (**v15 & 1) == 0 )\n          v11 = (const char *)(dword_80DBB8C + 44);\n        sub_80708A7(\" is a %sshell builtin\", v11);\n        goto LABEL_30;\n      }\n      goto LABEL_24;\n    case 0:\n      v7 = v15;\n      if ( (int)v15 >= 0 )\n      {\n        do\n        {\n          v8 = sub_8071D7C(&v13, v3);\n          v9 = sub_806EC35(v8);\n          v7 = (_BYTE **)((char *)v7 - 1);\n        }\n        while ( v7 != (_BYTE **)-1 );\n        v3 = (const char *)v9;\n      }\n      if ( !v4 )\n        goto LABEL_24;\n      sub_80708A7(\" is %s\", v3);\n      goto LABEL_30;\n  }\n  if ( v4 )\n    sub_8072DB0((int)\": not found\\n\");\n  return 127;\n}\n"
        ],
        "134707875": [
            "sub_8077AA3",
            "0x8077aa3",
            "int __fastcall sub_8077AA3(int a1, int a2)\n{\n  _BYTE *v2; // eax\n  int v3; // edi\n  int v4; // eax\n  int v5; // esi\n  int i; // ebx\n  int v7; // eax\n\n  v2 = *(_BYTE **)(a2 + 4);\n  if ( v2 )\n  {\n    v3 = *v2 != 45;\n    v4 = (*v2 == 45) + 1;\n  }\n  else\n  {\n    v3 = 1;\n    v4 = 1;\n  }\n  v5 = a2 + 4 * v4;\n  for ( i = 0; ; i |= sub_807796A(v7, 0, v3) )\n  {\n    v5 += 4;\n    v7 = *(_DWORD *)(v5 - 4);\n    if ( !v7 )\n      break;\n  }\n  return i;\n}\n"
        ],
        "134707948": [
            "sub_8077AEC",
            "0x8077aec",
            "void __noreturn sub_8077AEC()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134708019": [
            "sub_8077B33",
            "0x8077b33",
            "int __cdecl sub_8077B33(int a1, int a2)\n{\n  _DWORD *v2; // edx\n  int v3; // eax\n  int v4; // ecx\n  int v5; // ebp\n  _DWORD *v6; // ebx\n  int v7; // esi\n  int v8; // edx\n  int v9; // edx\n  int v10; // ecx\n  int v11; // eax\n  int v13; // [esp-4h] [ebp-2Ch]\n  int v14; // [esp+0h] [ebp-28h]\n  int fd; // [esp+4h] [ebp-24h]\n  int pipedes[2]; // [esp+8h] [ebp-20h] BYREF\n  char v17[24]; // [esp+10h] [ebp-18h] BYREF\n\n  v2 = *(_DWORD **)(a1 + 4);\n  v3 = 0;\n  while ( v2 )\n  {\n    ++v3;\n    v2 = (_DWORD *)*v2;\n  }\n  ++*(_DWORD *)(dword_80DBB8C + 36);\n  v5 = sub_807151B(v3);\n  v6 = *(_DWORD **)(a1 + 4);\n  v7 = -1;\n  while ( v6 )\n  {\n    v8 = v6[1];\n    if ( !*(_BYTE *)v8 )\n    {\n      if ( *(_DWORD *)(v8 + 12) )\n      {\n        fd = v6[1];\n        if ( !*(_BYTE *)sub_80AB128(v4, v8) )\n          sub_80775EB(\n            *(const char **)(*(_DWORD *)(fd + 12) + 8),\n            (int)v17,\n            0,\n            (char *)(*(_DWORD *)(dword_80DBB90 + 208) + 5));\n      }\n    }\n    pipedes[1] = -1;\n    if ( *v6 && pipe(pipedes) < 0 )\n    {\n      close(v7);\n      sub_806FB57(\"can't create pipe: %m\");\n    }\n    if ( !sub_8072B54(v5, v6[1], *(char *)(a1 + 1)) )\n    {\n      sub_806F4A5();\n      if ( pipedes[1] >= 0 )\n      {\n        close(pipedes[0]);\n        v10 = v13;\n      }\n      if ( v7 > 0 )\n      {\n        dup2(v7, 0);\n        close(v7);\n      }\n      if ( pipedes[1] > 1 )\n      {\n        dup2(pipedes[1], 1);\n        close(pipedes[1]);\n      }\n      sub_8074EF2(v9, v10, (char *)v6[1], a2 | 1);\n    }\n    if ( v7 >= 0 )\n      close(v7);\n    v7 = a2 | 1;\n    if ( fd != -1 )\n      close(fd);\n    v6 = (_DWORD *)*v6;\n  }\n  v11 = 0;\n  if ( !*(_BYTE *)(a1 + 1) )\n    v11 = sub_8071014(v5);\n  v14 = v11;\n  sub_806F4A5();\n  return v14;\n}\n"
        ],
        "134708375": [
            "sub_8077C97",
            "0x8077c97",
            "void __noreturn sub_8077C97()\n{\n  ((void (__noreturn *)(void))loc_807018F)();\n}\n"
        ],
        "134708664": [
            "sub_8077DB8",
            "0x8077db8",
            "int __cdecl sub_8077DB8(_DWORD *a1, char a2)\n{\n  int v2; // ecx\n  int v3; // eax\n  int v4; // ebx\n  int v5; // eax\n  _BYTE **v6; // eax\n  int v7; // edx\n  int v8; // ecx\n  _BOOL4 v9; // esi\n  int v10; // ebx\n  int *v11; // edi\n  _BYTE *v12; // ebp\n  _BYTE *v13; // eax\n  unsigned int v14; // ecx\n  _DWORD *i; // eax\n  const char **v16; // eax\n  _DWORD *j; // edx\n  int *v18; // esi\n  char *v19; // eax\n  const char *v20; // ebx\n  const char **v21; // edx\n  int v22; // ebx\n  int v23; // edi\n  int v24; // ebp\n  int v25; // ebp\n  const char *v26; // eax\n  int v27; // edx\n  int v28; // ecx\n  int **v29; // edi\n  const char *v30; // ebp\n  _BYTE *v31; // eax\n  _BYTE *v32; // edx\n  const char *v33; // eax\n  int v34; // edi\n  bool v35; // zf\n  int v36; // edx\n  int v37; // ecx\n  _BYTE *v38; // eax\n  const char *v39; // eax\n  int v40; // ecx\n  int v41; // ebp\n  char v42; // si\n  const char **v43; // eax\n  const char *v44; // esi\n  char *v45; // edi\n  char v46; // cl\n  int v47; // ebx\n  int v48; // eax\n  int k; // eax\n  char v51; // [esp-4h] [ebp-58h]\n  int v52; // [esp+0h] [ebp-54h]\n  char *v53; // [esp+4h] [ebp-50h]\n  const char **v54; // [esp+8h] [ebp-4Ch]\n  const char *v55; // [esp+Ch] [ebp-48h]\n  const char *v56; // [esp+10h] [ebp-44h]\n  char *v57; // [esp+10h] [ebp-44h]\n  void *v58; // [esp+14h] [ebp-40h]\n  int v59; // [esp+18h] [ebp-3Ch]\n  _BYTE *v60; // [esp+1Ch] [ebp-38h]\n  _DWORD *v61; // [esp+20h] [ebp-34h] BYREF\n  int *v62; // [esp+24h] [ebp-30h]\n  int **v63; // [esp+28h] [ebp-2Ch] BYREF\n  int ***v64; // [esp+2Ch] [ebp-28h]\n  char v65[4]; // [esp+30h] [ebp-24h] BYREF\n  char **v66; // [esp+34h] [ebp-20h]\n  _DWORD v67[7]; // [esp+38h] [ebp-1Ch] BYREF\n\n  v2 = dword_80DBB90;\n  v3 = a1[1];\n  *(_DWORD *)(dword_80DBB90 + 328) = v3;\n  v4 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 12) = v3;\n  if ( dword_80DB698 )\n    *(_DWORD *)(v2 + 328) = v3 - (dword_80DB698 - 1);\n  sub_8070056(v67);\n  v58 = (void *)sub_806F84B();\n  *(_BYTE *)(v4 + 1) = 0;\n  v65[0] = 2;\n  v66 = (char **)&off_80B7D60;\n  v64 = &v63;\n  v63 = 0;\n  v62 = (int *)&v61;\n  v61 = 0;\n  v5 = a1[3];\n  v52 = 0;\n  if ( v5 )\n  {\n    v6 = (_BYTE **)sub_8070CB3(*(const void **)(v5 + 8));\n    v9 = 0;\n    if ( v6 )\n      v9 = (**v6 & 4) != 0;\n    v10 = a1[3];\n    v52 = 0;\n    while ( v10 )\n    {\n      v11 = v62;\n      if ( !v9 || (v12 = *(_BYTE **)(v10 + 8), v13 = (_BYTE *)sub_80AB128(v8, v7), v12 == v13) || (v14 = 4, *v13 != 61) )\n        v14 = 3;\n      sub_8075D0B(v10, (int)&v61, v14);\n      for ( i = (_DWORD *)*v11; i; i = (_DWORD *)*i )\n        ++v52;\n      v10 = *(_DWORD *)(v10 + 4);\n    }\n  }\n  v16 = (const char **)(sub_806FFC6(4 * v52 + 8) + 4);\n  v54 = v16;\n  for ( j = v61; j; j = (_DWORD *)*j )\n    *v16++ = (const char *)j[1];\n  *v16 = 0;\n  v55 = 0;\n  if ( *(_BYTE *)(dword_80DBB8C + 48) )\n  {\n    if ( dword_80DB698 || !v52 )\n      v55 = 0;\n    else\n      v55 = *(v16 - 1);\n  }\n  sub_8076588(a1[4]);\n  v59 = sub_806EE2E(a1[4]);\n  v18 = (int *)dword_80DBB90;\n  *(_DWORD *)(dword_80DBB90 + 24) = 2;\n  if ( *(_BYTE *)(dword_80DBB8C + 52) )\n  {\n    v19 = sub_8072EED(\"BASH_XTRACEFD\");\n    v20 = v19;\n    if ( v19 )\n    {\n      if ( sub_806EC60(v19) )\n        v18[6] = atoi(v20);\n    }\n  }\n  v22 = sub_80764FE((char *)a1[4]);\n  v53 = (char *)v18[52];\n  v23 = a1[2];\n  while ( v23 )\n  {\n    v24 = (int)v64;\n    sub_8075D0B(v23, (int)&v63, 4u);\n    sub_80706CA(*(_DWORD *)(*(_DWORD *)v24 + 4));\n    v25 = *(_DWORD *)(*(_DWORD *)v24 + 4);\n    if ( sub_806EC79(v25, (int)v53) )\n      v25 = (int)v53;\n    v23 = *(_DWORD *)(v23 + 4);\n    v53 = (char *)v25;\n  }\n  if ( *(_BYTE *)(dword_80DBB8C + 52) )\n  {\n    v26 = (const char *)sub_8074AA5((const char *)(v18[64] + 4), 1);\n    dprintf(v18[6], \"%s\", v26);\n    v29 = v63;\n    v30 = &data;\n    while ( v29 )\n    {\n      v56 = (const char *)v29[1];\n      v31 = (_BYTE *)strchrnul(v28, v27, v56, 61);\n      v32 = v31;\n      if ( *v31 )\n        v32 = v31 + 1;\n      v60 = v32;\n      v33 = sub_807189F(v32, (int)v32);\n      dprintf(v18[6], \"%s%.*s%s\", v30, v60 - v56, v56, v33);\n      v29 = (int **)*v29;\n      v30 = \"     \" + 4;\n    }\n    v34 = (int)v61;\n    while ( v34 )\n    {\n      v35 = sub_8070CCB(*(const void **)(v34 + 4)) == 0;\n      v38 = *(_BYTE **)(v34 + 4);\n      if ( v35 )\n        v39 = sub_807189F(v38, v36);\n      else\n        v39 = (const char *)sub_80716D8(v38, v37);\n      dprintf(v18[6], \"%s%s\", v30, v39);\n      v34 = *(_DWORD *)v34;\n      v30 = \"     \" + 4;\n    }\n    sub_804E65D(1u, (void *)\"\\n\", v18[6]);\n  }\n  if ( !v52 )\n  {\n    v41 = -1;\n    if ( v22 )\n    {\n      *(_BYTE *)dword_80DBB8C = v22;\n      goto LABEL_109;\n    }\nLABEL_72:\n    if ( v65[0] == 1 )\n    {\n      sub_80773CC(1);\n      sub_8070DA4(0, 0);\n      v48 = sub_80774DC((int)v66, v52, (int)v54, a2);\n      LOBYTE(v21) = v51;\n      if ( v48 )\n        goto LABEL_90;\n      v42 = 0;\n      goto LABEL_93;\n    }\n    if ( v65[0] == 2 )\n    {\n      v42 = 0;\n      goto LABEL_81;\n    }\n    if ( (a2 & 1) == 0 || *(_BYTE *)(dword_80DBB8C + 188) )\n    {\n      ++*(_DWORD *)(dword_80DBB8C + 36);\n      v47 = sub_807151B(1);\n      if ( sub_8072B54(v47, (int)a1, 0) )\n      {\n        v22 = sub_8071014(v47);\n        sub_806F4A5();\nLABEL_109:\n        v42 = 0;\n        goto LABEL_94;\n      }\n      sub_806F48C();\n    }\n    sub_806FCB3(v63, 17);\n    sub_8072C74(*v54, v54, (int)v53, (int)v66);\n  }\n  v57 = v53 + 5;\n  v53 += 5;\n  v40 = 1;\n  v41 = -1;\n  while ( 1 )\n  {\n    sub_80775EB(*v54, (int)v65, v40, v53);\n    if ( v65[0] == -1 )\n    {\n      sub_806F4BD();\n      v42 = 0;\n      v22 = 127;\n      goto LABEL_70;\n    }\n    if ( v65[0] != 2 )\n    {\n      if ( v22 )\n      {\n        v42 = 0;\nLABEL_70:\n        *(_BYTE *)dword_80DBB8C = v22;\n        if ( v41 == 1 )\n          sub_806F22F(1);\n        goto LABEL_94;\n      }\n      goto LABEL_72;\n    }\n    if ( v41 == -1 )\n    {\n      LOBYTE(v21) = **v66;\n      v41 = (unsigned __int8)v21 & 1;\n    }\n    if ( v66 == &off_80B5DE8 )\n    {\n      v42 = 1;\n      goto LABEL_105;\n    }\n    if ( v66 != &off_80B5DC8 )\n      goto LABEL_104;\n    v53 = v57;\n    v21 = v54;\nLABEL_56:\n    v43 = v21 + 1;\n    v44 = v21[1];\n    if ( !v44 )\n      goto LABEL_104;\n    if ( *v44 == 45 )\n    {\n      v45 = (char *)(v44 + 2);\n      v46 = v44[1];\n      if ( v46 )\n        break;\n    }\nLABEL_67:\n    v52 -= v43 - v54;\n    v40 = 5;\n    v54 = v43;\n  }\n  if ( v46 == 45 && !v44[2] )\n  {\n    v21 += 2;\n    if ( !v43[1] )\n      goto LABEL_104;\n    v43 = v21;\n    if ( !v21 )\n      goto LABEL_104;\n    goto LABEL_67;\n  }\n  while ( v46 == 112 )\n  {\n    v46 = *v45++;\n    v21 = v43;\n    v53 = \"/bin:/usr/bin\";\n    if ( !v46 )\n      goto LABEL_56;\n  }\nLABEL_104:\n  v42 = 0;\nLABEL_105:\n  if ( v22 )\n    goto LABEL_70;\nLABEL_81:\n  if ( v41 == 1 || !v52 )\n  {\n    sub_80773CC(1);\n    if ( v52 > 1 )\n    {\n      if ( v42 )\n        sub_806FCB3(v63, 1);\n    }\n  }\n  sub_8070DA4(0, 0);\n  if ( sub_8074D56((int)v66, (int)v54, a2) )\n  {\n    if ( *(_BYTE *)(dword_80DBB8C + 43) == 1 && v41 != 1 )\n    {\n      sub_806F48C();\n      goto LABEL_93;\n    }\nLABEL_90:\n    longjmp(*(struct __jmp_buf_tag **)(dword_80DBB8C + 32), 1);\n  }\nLABEL_93:\n  v22 = *(unsigned __int8 *)dword_80DBB8C;\nLABEL_94:\n  if ( !a1[4] )\n    goto LABEL_97;\n  for ( k = v42; ; k = 0 )\n  {\n    sub_806FF33(k, (char)v21);\nLABEL_97:\n    if ( v59 == *(_DWORD *)(dword_80DBB90 + 20) )\n      break;\n  }\n  while ( v58 != dword_80DB694 )\n    sub_80773CC(0);\n  if ( v55 )\n    sub_806FE06((int)\"_\", v55);\n  sub_806FA10(v67);\n  return v22;\n}\n"
        ],
        "134710171": [
            "sub_807839B",
            "0x807839b",
            "void __cdecl __noreturn sub_807839B(int a1, _BYTE **a2)\n{\n  _DWORD *v2; // eax\n  _DWORD *v3; // eax\n  char *v4; // ebx\n  _DWORD *v5; // edx\n  int i; // eax\n  int *v7; // esi\n  char v8; // dl\n  _DWORD *v9; // eax\n  int v10; // ebx\n  const char *v11; // eax\n  int v12; // ebx\n  _BYTE *v13; // eax\n  _BOOL4 v14; // edx\n  int v15; // esi\n  int *v16; // edi\n  int v17; // ebp\n  int v18; // eax\n  char *v19; // eax\n  _DWORD *v20; // eax\n  char *v21; // eax\n  char *v22; // eax\n  char *v23; // eax\n  int v24; // ecx\n  char *v25; // ebx\n  _BOOL4 v26; // [esp+4h] [ebp-44h] BYREF\n  _DWORD v27[3]; // [esp+8h] [ebp-40h] BYREF\n  char v28[52]; // [esp+14h] [ebp-34h] BYREF\n\n  v2 = sub_804DB2E(0x1DCu);\n  dword_80DBB8C = (int)v2;\n  v2[5] = v2 + 11;\n  v2[6] = v2 + 11;\n  v2[113] = v2 + 48;\n  v3 = sub_804DB2E(0x20Cu);\n  dword_80DBB88 = (int)v3;\n  *v3 = v3 + 4;\n  v3[1] = v3 + 5;\n  v3[3] = 504;\n  v3[2] = v3 + 131;\n  v4 = (char *)sub_804DB2E(0x160u);\n  dword_80DBB90 = (int)v4;\n  v5 = &unk_80B5F60;\n  for ( i = 0; i != 144; i += 16 )\n  {\n    *(_DWORD *)&v4[i + 188] = *v5;\n    *(_DWORD *)&v4[i + 192] = v5[1];\n    *(_DWORD *)&v4[i + 196] = v5[2];\n    v5 += 3;\n  }\n  strcpy(v4 + 332, \"LINENO=\");\n  *((_DWORD *)v4 + 72) = v4 + 332;\n  dword_80DB6F0 = (int)sub_804DB2E(0x9Cu);\n  dword_80DB6B0 = (int)sub_804DB2E(0x7Cu);\n  dword_80DB6F8 = sub_80AED15();\n  v7 = (int *)_setjmp((struct __jmp_buf_tag *)v28);\n  if ( v7 )\n  {\n    byte_80DB76C = 0;\n    dword_80DB69C = 0;\n    sub_806F5DA();\n    v9 = off_80DB55C;\n    *((_DWORD *)off_80DB55C + 4) = 0;\n    v9[3] = 0;\n    while ( off_80DB55C != &unk_80DB5E0 )\n      sub_806F6F7();\n    while ( *(_DWORD *)(dword_80DBB90 + 20) )\n      sub_806FF33(0, v8);\n    while ( dword_80DB694 )\n      sub_80773CC(0);\n    goto LABEL_54;\n  }\n  v12 = dword_80DBB8C;\n  *(_DWORD *)(dword_80DBB8C + 32) = v28;\n  *(_DWORD *)(v12 + 4) = getpid();\n  sub_8072F60();\n  sub_8070056(v27);\n  v13 = *a2;\n  v14 = 0;\n  if ( *a2 )\n    v14 = *v13 == 45;\n  v26 = v14;\n  *(_DWORD *)(v12 + 28) = v13;\n  do\n  {\n    *((_BYTE *)v7 + v12 + 45) = 2;\n    v7 = (int *)((char *)v7 + 1);\n  }\n  while ( v7 != (int *)15 );\n  dword_80DB708 = (int)(a2 + 1);\n  v15 = sub_80708D4(1, &v26);\n  if ( v15 )\n    sub_806F22F(1);\n  v16 = (int *)dword_80DB708;\n  v17 = *(_DWORD *)(v12 + 16);\n  if ( !*(_DWORD *)dword_80DB708 )\n  {\n    if ( v17 )\n      sub_806FB57(\"%s requires an argument\", \"-c\");\n    *(_BYTE *)(v12 + 51) = 1;\n  }\n  if ( (*(_DWORD *)(v12 + 48) & 0xFF0000FF) == 16777218 && isatty(0) && isatty(1) )\n    *(_BYTE *)(v12 + 48) = 1;\n  if ( *(_BYTE *)(v12 + 49) == 2 )\n    *(_BYTE *)(v12 + 49) = *(_BYTE *)(v12 + 48);\n  do\n  {\n    if ( *(_BYTE *)(v12 + v15 + 45) == 2 )\n      *(_BYTE *)(v12 + v15 + 45) = 0;\n    ++v15;\n  }\n  while ( v15 != 15 );\n  v18 = *v16;\n  if ( v17 )\n  {\n    v7 = v16 + 1;\n    *(_DWORD *)(v12 + 16) = v18;\n    if ( !v16[1] )\n    {\nLABEL_44:\n      v20 = (_DWORD *)dword_80DBB90;\n      *(_DWORD *)(dword_80DBB90 + 16) = v7;\n      v20[1] = 1;\n      v20[2] = -1;\n      while ( *v7 )\n      {\n        ++*v20;\n        ++v7;\n      }\n      sub_8070672((__pid_t)v7);\n      if ( v26 )\n      {\n        sub_8076BF3(\"/etc/profile\");\n        if ( sub_8072EED(\"HOME\") )\n          sub_8076BF3(\"$HOME/.profile\");\n      }\n      if ( *(_BYTE *)(dword_80DBB8C + 48) )\n      {\n        v21 = sub_8072EED(\"ENV\");\n        if ( v21 )\n        {\n          if ( *v21 )\n            sub_8076BF3(v21);\n        }\n      }\n      sub_806FA10(v27);\n      v10 = dword_80DBB8C;\n      v11 = *(const char **)(dword_80DBB8C + 16);\n      if ( v11 )\n        sub_8074C7C(v11, *(_BYTE *)(dword_80DBB8C + 51) == 0);\n      if ( *(_BYTE *)(v10 + 51) || !*(_DWORD *)(v10 + 16) )\n      {\n        if ( *(_BYTE *)(v10 + 48) )\n        {\n          v22 = sub_8072EED(\"HISTFILE\");\n          if ( v22\n            || (v23 = sub_8072EED(\"HOME\")) != 0\n            && (++*(_DWORD *)(v10 + 36),\n                v25 = (char *)sub_804D2D1((int)v23, \".ash_history\", v24),\n                sub_806FE06((int)\"HISTFILE\", v25),\n                free(v25),\n                sub_806F4A5(),\n                (v22 = sub_8072EED(\"HISTFILE\")) != 0) )\n          {\n            *(_DWORD *)(dword_80DB6F8 + 28) = v22;\n          }\n        }\n        sub_8076A14(1u);\n      }\nLABEL_54:\n      sub_80769A1((__pid_t)v7);\n    }\n  }\n  else\n  {\n    v7 = v16;\n    if ( *(_BYTE *)(v12 + 51) )\n      goto LABEL_44;\n    sub_807009B(v18, 0);\n  }\n  v19 = (char *)*v7;\n  *(_DWORD *)(v12 + 28) = *v7;\n  dword_80DB70C = v19;\n  ++v7;\n  goto LABEL_44;\n}\n"
        ],
        "134711232": [
            "sub_80787C0",
            "0x80787c0",
            "const char *__usercall sub_80787C0@<eax>(int a1@<eax>, char a2@<dl>, _DWORD *a3@<ecx>, _DWORD *a4)\n{\n  _DWORD *v5; // ebp\n  _DWORD *v6; // ecx\n  unsigned __int64 v7; // rdi\n  bool v8; // zf\n  unsigned __int64 v9; // rax\n  char v10; // al\n  int v11; // eax\n  __int64 v12; // rax\n  bool v13; // al\n  unsigned __int8 v14; // al\n  char v15; // cl\n  char v16; // cl\n  int v17; // ecx\n  unsigned __int64 v18; // rax\n  int v19; // ecx\n  bool v20; // cl\n  _DWORD *v22; // [esp+0h] [ebp-44h]\n  __int64 v23; // [esp+0h] [ebp-44h]\n  int v24; // [esp+8h] [ebp-3Ch]\n  unsigned __int64 i; // [esp+Ch] [ebp-38h]\n  char s[42]; // [esp+1Ah] [ebp-2Ah] BYREF\n\n  if ( (_DWORD *)*a4 == a3 )\n    return \"arithmetic syntax error\";\n  v5 = (_DWORD *)(*a4 - 24);\n  v22 = (_DWORD *)*a4;\n  v24 = sub_8078F03();\n  v6 = v22;\n  if ( !v24 )\n  {\n    HIDWORD(v7) = *(v22 - 6);\n    LODWORD(v7) = *(v22 - 5);\n    switch ( a2 )\n    {\n      case 17:\n        HIDWORD(v7) = -HIDWORD(v7);\n        LODWORD(v7) = (unsigned __int64)-__SPAIR64__(v7, HIDWORD(v7)) >> 32;\nLABEL_99:\n        if ( (unsigned __int8)((a2 & 0xF) - 2) > 1u )\n        {\nLABEL_106:\n          *v5 = HIDWORD(v7);\n          v5[1] = v7;\n          v5[5] = 0;\n          return (const char *)v24;\n        }\n        if ( v5[5] )\n        {\n          sprintf(s, \"%lld\", __PAIR64__(v7, HIDWORD(v7)));\n          (*(void (**)(void))(a1 + 8))();\n          if ( a2 == 19 )\n          {\n            LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) - 1) >> 32;\n            --HIDWORD(v7);\n          }\n          else if ( a2 == 51 )\n          {\n            LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) + 1) >> 32;\n            ++HIDWORD(v7);\n          }\n          goto LABEL_106;\n        }\n        return \"arithmetic syntax error\";\n      case 48:\n        v8 = v7 == 0;\nLABEL_46:\n        v13 = v8;\n        goto LABEL_34;\n      case 16:\n        v9 = ~v7;\nLABEL_30:\n        v7 = v9;\n        goto LABEL_99;\n    }\n    if ( (unsigned __int8)(a2 - 18) <= 1u )\n    {\n      LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) + 1) >> 32;\n      ++HIDWORD(v7);\n      goto LABEL_99;\n    }\n    if ( (unsigned __int8)(a2 - 50) <= 1u )\n    {\n      LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) - 1) >> 32;\n      --HIDWORD(v7);\n      goto LABEL_99;\n    }\n    if ( a2 == 49 )\n      goto LABEL_99;\n    if ( a3 != v5 )\n    {\n      *a4 = v5;\n      v10 = *((_BYTE *)v22 - 8);\n      if ( a2 == 4 )\n      {\n        if ( !v10 )\n          return \"malformed ?: operator\";\n        v5 = v22 - 12;\n      }\n      else\n      {\n        if ( v10 )\n          return \"malformed ?: operator\";\n        v5 = v22 - 12;\n        if ( a2 == 2 )\n        {\nLABEL_21:\n          v23 = *((_QWORD *)v6 - 6);\n          switch ( a2 )\n          {\n            case 4:\n              if ( !v23 )\n              {\n                HIDWORD(v7) = *(v6 - 4);\n                LODWORD(v7) = *(v6 - 3);\n              }\n              goto LABEL_99;\n            case 36:\n              if ( a3 == v5 )\n                return \"malformed ?: operator\";\n              *((_BYTE *)v6 - 32) = 36;\n              *(v6 - 10) = HIDWORD(v7);\n              *(v6 - 9) = v7;\nLABEL_98:\n              v7 = __PAIR64__(v23, HIDWORD(v23));\n              goto LABEL_99;\n            case 66:\n            case 7:\n              HIDWORD(v9) = HIDWORD(v7) | v23;\n              LODWORD(v9) = v7 | HIDWORD(v23);\n              goto LABEL_30;\n            case 5:\n              HIDWORD(v12) = HIDWORD(v7) | v23;\n              LODWORD(v12) = v7 | HIDWORD(v23);\nLABEL_33:\n              v13 = v12 != 0;\nLABEL_34:\n              HIDWORD(v7) = v13;\nLABEL_35:\n              LODWORD(v7) = 0;\n              goto LABEL_99;\n            case 9:\n            case 34:\n              HIDWORD(v9) = HIDWORD(v7) & v23;\n              LODWORD(v9) = v7 & HIDWORD(v23);\n              goto LABEL_30;\n            case 8:\n            case 98:\n              HIDWORD(v9) = HIDWORD(v7) ^ v23;\n              LODWORD(v9) = v7 ^ HIDWORD(v23);\n              goto LABEL_30;\n            case 6:\n              HIDWORD(v7) = v23 != 0 && v7 != 0;\n              goto LABEL_35;\n            case 10:\n              v8 = v7 == __PAIR64__(v23, HIDWORD(v23));\n              goto LABEL_46;\n            case 42:\n              HIDWORD(v12) = HIDWORD(v7) ^ v23;\n              LODWORD(v12) = v7 ^ HIDWORD(v23);\n              goto LABEL_33;\n            case 75:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) > v23 )\nLABEL_70:\n                v14 = 0;\n              break;\n            case -30:\n            case 44:\n              v15 = BYTE4(v7);\n              HIDWORD(v7) = (unsigned __int64)v23 >> SBYTE4(v7);\n              LODWORD(v7) = SHIDWORD(v23) >> v15;\n              if ( (v15 & 0x20) != 0 )\n              {\n                HIDWORD(v7) = SHIDWORD(v23) >> v15;\n                LODWORD(v7) = (int)v7 >> 31;\n              }\n              goto LABEL_99;\n            case -62:\n            case 12:\n              v16 = BYTE4(v7);\n              LODWORD(v7) = (unsigned __int64)(v23 << SBYTE4(v7)) >> 32;\n              HIDWORD(v7) = (_DWORD)v23 << SBYTE4(v7);\n              if ( (v16 & 0x20) != 0 )\n                v7 = HIDWORD(v7);\n              goto LABEL_99;\n            case 43:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) >= v23 )\n                goto LABEL_70;\n              break;\n            case 11:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) <= v23 )\n                goto LABEL_70;\n              break;\n            case 107:\n              v14 = 1;\n              if ( __SPAIR64__(v7, HIDWORD(v7)) < v23 )\n                goto LABEL_70;\n              break;\n            default:\n              switch ( a2 )\n              {\n                case 3:\n                case 14:\n                  v17 = HIDWORD(v7) * HIDWORD(v23) + v7 * v23;\n                  LODWORD(v7) = (HIDWORD(v7) * (unsigned __int64)(unsigned int)v23) >> 32;\n                  HIDWORD(v7) *= (_DWORD)v23;\n                  LODWORD(v7) = v17 + v7;\n                  goto LABEL_99;\n                case 13:\n                case -126:\n                  LODWORD(v7) = (v23 + __PAIR64__(v7, HIDWORD(v7))) >> 32;\n                  HIDWORD(v7) += v23;\n                  goto LABEL_99;\n                case -94:\n                case 45:\n                  v18 = v23 - __PAIR64__(v7, HIDWORD(v7));\n                  break;\n                default:\n                  if ( (unsigned __int8)(a2 - 1) <= 1u )\n                    goto LABEL_99;\n                  if ( a2 == 47 )\n                  {\n                    if ( (v7 & 0x80000000) != 0LL )\n                      return \"exponent less than 0\";\n                    for ( i = 1LL; ; HIDWORD(i) += v19 )\n                    {\n                      LODWORD(v7) = (__PAIR64__(v7, HIDWORD(v7)) - 1) >> 32;\n                      --HIDWORD(v7);\n                      if ( __PAIR64__(v7, HIDWORD(v7)) == -1LL )\n                        break;\n                      v19 = i * HIDWORD(v23) + HIDWORD(i) * v23;\n                      i = (unsigned int)v23 * (unsigned __int64)(unsigned int)i;\n                    }\n                    v7 = __PAIR64__(i, HIDWORD(i));\n                    goto LABEL_99;\n                  }\n                  if ( !v7 )\n                    return \"divide by zero\";\n                  v20 = a2 == 46 || a2 == 35;\n                  if ( a2 != 78 && a2 != 67 && !v20 )\n                    goto LABEL_98;\n                  if ( v7 == -1LL && !(2 * v23) )\n                    v7 = 0x100000000LL;\n                  if ( v20 )\n                    LODWORD(v18) = sub_80B492D(v23, HIDWORD(v23), HIDWORD(v7), v7);\n                  else\n                    LODWORD(v18) = sub_80B4A4A(v23, HIDWORD(v23), HIDWORD(v7), v7);\n                  break;\n              }\n              v7 = __PAIR64__(v18, HIDWORD(v18));\n              goto LABEL_99;\n          }\n          HIDWORD(v7) = v14;\n          goto LABEL_35;\n        }\n      }\n      v11 = sub_8078F03();\n      v6 = v22;\n      if ( v11 )\n        return (const char *)v11;\n      goto LABEL_21;\n    }\n    return \"arithmetic syntax error\";\n  }\n  return (const char *)v24;\n}\n"
        ],
        "134712402": [
            "sub_8078C52",
            "0x8078c52",
            "__int64 __usercall sub_8078C52@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  unsigned __int64 v3; // rax\n  __int64 *v4; // ecx\n  void *v5; // esp\n  void *v6; // esp\n  __int64 *v7; // edi\n  char *v8; // ebx\n  int v9; // eax\n  void *v10; // esp\n  int v11; // eax\n  _DWORD *v12; // ebx\n  char v13; // al\n  const char *v14; // ecx\n  char v15; // bl\n  char *v16; // ebx\n  const char *i; // eax\n  unsigned __int8 v18; // al\n  __int64 *v20; // [esp-4h] [ebp-2Ch]\n  int v21; // [esp-4h] [ebp-2Ch]\n  __int64 *v22; // [esp+0h] [ebp-28h]\n  __int64 v23; // [esp+4h] [ebp-24h] BYREF\n  unsigned __int8 v24; // [esp+Fh] [ebp-19h] BYREF\n  int v25; // [esp+10h] [ebp-18h]\n  char *nptr; // [esp+14h] [ebp-14h] BYREF\n  __int64 *v27; // [esp+18h] [ebp-10h] BYREF\n  int v28; // [esp+1Ch] [ebp-Ch] BYREF\n\n  LODWORD(v23) = a1;\n  HIDWORD(v23) = sub_80B2E8C(a3, a2);\n  nptr = (char *)HIDWORD(v23);\n  v3 = __PAIR64__(&v24, strlen((const char *)HIDWORD(v23)));\n  v4 = v20;\n  v5 = alloca(24 * ((unsigned int)(v3 + 2) >> 1) + 16);\n  v27 = &v23;\n  v6 = alloca(v3 + 17);\n  v22 = &v23;\n  v7 = (__int64 *)((char *)&v23 + 1);\n  LOBYTE(v23) = 0;\n  LOBYTE(v25) = 0;\nLABEL_2:\n  while ( 2 )\n  {\n    while ( 2 )\n    {\n      while ( 2 )\n      {\n        LODWORD(v3) = sub_80B2E8C(v4, HIDWORD(v3));\n        nptr = (char *)v3;\n        LOBYTE(v4) = *(_BYTE *)v3;\n        if ( !*(_BYTE *)v3 )\n        {\n          if ( HIDWORD(v23) == (_DWORD)v3 )\n          {\n            v23 = 0LL;\n            LODWORD(v3) = 0;\n          }\n          else\n          {\n            if ( (_UNKNOWN *)v3 != &unk_80D1094 )\n            {\n              nptr = (char *)&unk_80D1093;\n              continue;\n            }\n            if ( v27 != (__int64 *)&v28 )\n              goto LABEL_64;\n            LODWORD(v3) = 0;\n            if ( v27 )\n              LODWORD(v3) = sub_8078F03();\n          }\n          goto LABEL_68;\n        }\n        break;\n      }\n      v24 = *(_BYTE *)v3;\n      LODWORD(v3) = sub_80AB128(v4, HIDWORD(v3));\n      v8 = (char *)v3;\n      HIDWORD(v3) = nptr;\n      if ( nptr != (char *)v3 )\n      {\n        v9 = v3 - (_DWORD)nptr;\n        v25 = v9 + 1;\n        v10 = alloca(v9 + 16);\n        *((_DWORD *)v27 + 5) = &v23;\n        sub_80B2C4E(v25);\n        nptr = v8;\nLABEL_12:\n        v11 = (int)v27;\n        *((_BYTE *)v27 + 16) = 0;\n        v27 = (__int64 *)(v11 + 24);\n        LOBYTE(v25) = 20;\n        continue;\n      }\n      break;\n    }\n    if ( (unsigned __int8)(v24 - 48) <= 9u )\n    {\n      *((_DWORD *)v27 + 5) = 0;\n      v12 = (_DWORD *)dword_80DBB7C;\n      *(_DWORD *)dword_80DBB7C = 0;\n      v3 = strtoull((const char *)HIDWORD(v3), &nptr, 0);\n      v4 = v27;\n      *v27 = v3;\n      if ( *v12 )\n      {\n        *(_DWORD *)v4 = 0;\n        *((_DWORD *)v4 + 1) = 0;\n      }\n      goto LABEL_12;\n    }\n    if ( (_BYTE)v25 != 20 || *((_DWORD *)v27 - 1) )\n    {\n      v14 = \"<<=\";\n    }\n    else\n    {\n      v13 = *nptr;\n      v14 = \"<<=\";\n      if ( ((*nptr - 43) & 0xFD) == 0 && v13 == nptr[1] )\n      {\n        v15 = v13 != 43 ? 45 : 13;\n        HIDWORD(v3) = ++nptr;\n        goto LABEL_32;\n      }\n    }\nLABEL_22:\n    v16 = nptr;\n    for ( i = v14; *i; ++i )\n    {\n      if ( *i != *v16 )\n      {\n        while ( *i )\n          ++i;\n        v14 = i + 2;\n        if ( !i[2] )\n          goto LABEL_64;\n        goto LABEL_22;\n      }\n      ++v16;\n    }\n    nptr = v16;\n    v15 = i[1];\n    if ( (_BYTE)v25 == 19 )\n      goto LABEL_43;\nLABEL_32:\n    if ( (_BYTE)v25 == 51 || (_BYTE)v25 == 20 )\n    {\nLABEL_43:\n      LOBYTE(v25) = 20;\n      goto LABEL_44;\n    }\n    if ( v15 == 19 )\n    {\n      v15 = 18;\n    }\n    else if ( (unsigned __int8)v15 > 0x13u )\n    {\n      if ( v15 == 45 )\n      {\n        v15 = 17;\n      }\n      else if ( v15 == 51 )\n      {\n        v15 = 50;\n      }\n    }\n    else if ( v15 == 13 )\n    {\n      v15 = 49;\n    }\nLABEL_44:\n    v24 = v15 & 0x1F;\n    if ( (unsigned __int8)((v15 & 0x1F) - 1) > 0xEu && v24 != 20 )\n    {\n      v4 = v7;\n      goto LABEL_63;\n    }\n    if ( (_BYTE)v25 != 20 )\n      break;\n    while ( 1 )\n    {\n      v4 = v7;\n      if ( v7 == v22 )\n        break;\n      v7 = (__int64 *)((char *)v7 - 1);\n      HIDWORD(v3) = *(unsigned __int8 *)v7;\n      if ( v15 == 52 )\n      {\n        if ( !BYTE4(v3) )\n          goto LABEL_2;\n        goto LABEL_58;\n      }\n      v18 = BYTE4(v3) & 0x1F;\n      if ( v24 != 3 )\n      {\n        if ( v18 == 3 )\n          v18 = 2;\nLABEL_54:\n        if ( v18 < v24 )\n          goto LABEL_63;\n        if ( v18 != v24 )\n          goto LABEL_58;\n        goto LABEL_56;\n      }\n      v24 = 2;\n      if ( v18 != 3 )\n        goto LABEL_54;\nLABEL_56:\n      if ( ((v24 - 2) & 0xFD) == 0 || v24 == 15 )\n        goto LABEL_63;\nLABEL_58:\n      LODWORD(v3) = sub_80787C0(v23, SBYTE4(v3), &v23, &v27);\n      HIDWORD(v3) = v21;\n      if ( (_DWORD)v3 )\n        goto LABEL_65;\n    }\n    if ( v15 != 52 )\n    {\nLABEL_63:\n      v7 = (__int64 *)((char *)v4 + 1);\n      *(_BYTE *)v4 = v15;\n      LOBYTE(v25) = v15;\n      continue;\n    }\n    break;\n  }\nLABEL_64:\n  LODWORD(v3) = \"arithmetic syntax error\";\nLABEL_65:\n  v23 = -1LL;\nLABEL_68:\n  *(_DWORD *)v23 = v3;\n  return v23;\n}\n"
        ],
        "134713091": [
            "sub_8078F03",
            "0x8078f03",
            "const char *__usercall sub_8078F03@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v5; // ebp\n  const char *v6; // ecx\n  int i; // edx\n  int v8; // eax\n  int *v10; // [esp+0h] [ebp-20h]\n  const char *v11; // [esp+4h] [ebp-1Ch]\n  int v12[6]; // [esp+8h] [ebp-18h] BYREF\n\n  v2 = 0;\n  if ( *(_DWORD *)(a2 + 20) )\n  {\n    v2 = (*(int (**)(void))(a1 + 4))();\n    if ( v2 )\n    {\n      v5 = *(_DWORD *)(a1 + 12);\n      v6 = *(const char **)(a2 + 20);\n      for ( i = v5; ; i = *v10 )\n      {\n        if ( !i )\n        {\n          v12[1] = (int)v6;\n          v12[0] = v5;\n          *(_DWORD *)(a1 + 12) = v12;\n          *(_QWORD *)a2 = sub_8078C52(a1, v2, (int)v6);\n          *(_DWORD *)(a1 + 12) = v5;\n          return *(const char **)a1;\n        }\n        v11 = v6;\n        v10 = (int *)i;\n        v8 = strcmp(*(const char **)(i + 4), v6);\n        v6 = v11;\n        if ( !v8 )\n          break;\n      }\n      return \"expression recursion loop detected\";\n    }\n    else\n    {\n      *(_DWORD *)a2 = 0;\n      *(_DWORD *)(a2 + 4) = 0;\n    }\n  }\n  return (const char *)v2;\n}\n"
        ],
        "134713234": [
            "sub_8078F92",
            "0x8078f92",
            "__int64 __usercall sub_8078F92@<edx:eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  *(_DWORD *)a1 = 0;\n  *(_DWORD *)(a1 + 12) = 0;\n  return sub_8078C52(a1, a2, a3);\n}\n"
        ],
        "134713258": [
            "sub_8078FAA",
            "0x8078faa",
            "int __usercall sub_8078FAA@<eax>(__pid_t *a1@<eax>)\n{\n  __pid_t v2; // eax\n  __pid_t v3; // eax\n  int v4; // edi\n  int v5; // esi\n  unsigned int v6; // edx\n  unsigned int i; // ecx\n  unsigned int v8; // edx\n  int v9; // ebp\n  int v10; // eax\n\n  if ( !*a1 )\n  {\n    v2 = getpid();\n    a1[2] = v2;\n    *a1 = v2;\n    v3 = sub_804EBDE();\n    a1[3] = v3;\n    a1[1] = v3;\n  }\n  v4 = 1664525 * a1[1] + 1013904223;\n  a1[1] = v4;\n  v5 = 2 * *a1;\n  if ( *a1 < 0 )\n    v5 ^= 0x8000000B;\n  *a1 = v5;\n  v6 = a1[2];\n  for ( i = a1[3]; ; i = v10 )\n  {\n    v8 = (4 * v6) ^ v6;\n    v9 = v8 ^ i ^ (i >> 3);\n    v8 >>= 7;\n    v10 = v8 ^ v9;\n    if ( v9 != v8 )\n    {\n      a1[2] = i;\n      a1[3] = v10;\n      return ((_WORD)v5 - (_WORD)v4 + (_WORD)v10) & 0x7FFF;\n    }\n    v6 = i;\n    if ( i > 2 )\n      break;\n  }\n  a1[2] = i;\n  a1[3] = v10;\n  LOWORD(v10) = 0;\n  return ((_WORD)v5 - (_WORD)v4 + (_WORD)v10) & 0x7FFF;\n}\n"
        ],
        "134713399": [
            "sub_8079037",
            "0x8079037",
            "int __usercall sub_8079037@<eax>(char a1@<al>, unsigned int *a2@<edx>, char *a3@<ecx>)\n{\n  unsigned int v3; // esi\n  unsigned int v4; // edi\n  char v6; // cl\n  unsigned int v7; // esi\n  unsigned int v8; // edi\n  int v9; // [esp-4h] [ebp-Ch]\n\n  v3 = a2[2];\n  v4 = a2[3];\n  if ( (a1 & 1) == 0 )\n  {\n    v3 = *a2;\n    v4 = a2[1];\n  }\n  if ( v4 == -1 && v3 == -1 )\n  {\n    puts(\"unlimited\");\n    return v9;\n  }\n  else\n  {\n    v6 = *a3;\n    v7 = __PAIR64__(v4, v3) >> v6;\n    v8 = v4 >> v6;\n    if ( (v6 & 0x20) != 0 )\n    {\n      v7 = v8;\n      v8 = 0;\n    }\n    return printf(\"%llu\\n\", __PAIR64__(v8, v7));\n  }\n}\n"
        ],
        "134713478": [
            "sub_8079086",
            "0x8079086",
            "_BOOL4 __usercall sub_8079086@<eax>(_BYTE *a1@<eax>, char a2@<dl>)\n{\n  _BYTE *v2; // ecx\n  char v3; // bl\n  _BOOL4 result; // eax\n  char v5; // al\n\n  if ( !a1 )\n    return 0;\n  v2 = a1;\n  v3 = *a1;\n  if ( (unsigned __int8)((*a1 | 0x20) - 97) <= 0x19u || (result = 0, v3 == 95) )\n  {\n    do\n    {\n      do\n        v5 = *++v2;\n      while ( (unsigned __int8)(*v2 - 48) <= 9u );\n    }\n    while ( (unsigned __int8)((*v2 | 0x20) - 97) <= 0x19u || v5 == 95 );\n    return v5 == a2;\n  }\n  return result;\n}\n"
        ],
        "134713549": [
            "sub_80790CD",
            "0x80790cd",
            "int __userpurge sub_80790CD@<eax>(\n        void (*a1)(void)@<eax>,\n        _DWORD *a2@<edx>,\n        const char *a3@<ecx>,\n        char a4,\n        const char *a5,\n        int a6,\n        const char *a7,\n        const char *a8,\n        char *a9)\n{\n  char **i; // ebp\n  char *v10; // ebx\n  int v11; // edi\n  unsigned int v12; // ebp\n  int v13; // ecx\n  unsigned __int8 v14; // al\n  int v15; // edi\n  size_t v16; // esi\n  int v17; // eax\n  int v18; // ebp\n  int v19; // ecx\n  char *v20; // eax\n  bool v21; // al\n  int v22; // ecx\n  int v23; // eax\n  char *v24; // eax\n  char *v25; // eax\n  int v26; // eax\n  size_t v27; // eax\n  const char *j; // edx\n  int v30; // [esp-4h] [ebp-B0h]\n  int v31; // [esp-4h] [ebp-B0h]\n  int v32; // [esp-4h] [ebp-B0h]\n  int v33; // [esp-4h] [ebp-B0h]\n  _DWORD *v34; // [esp+0h] [ebp-ACh]\n  int v36; // [esp+8h] [ebp-A4h]\n  char v37; // [esp+Ch] [ebp-A0h]\n  char v39; // [esp+1Ah] [ebp-92h]\n  char v40; // [esp+1Bh] [ebp-91h]\n  struct pollfd fds; // [esp+1Ch] [ebp-90h] BYREF\n  struct termios termios_p; // [esp+24h] [ebp-88h] BYREF\n  struct termios v43; // [esp+60h] [ebp-4Ch] BYREF\n\n  v34 = a2;\n  *(_DWORD *)dword_80DBB7C = 0;\n  for ( i = (char **)a2; ; ++i )\n  {\n    v10 = *i;\n    if ( !*i )\n      break;\n    if ( !sub_8079086(*i, 0) )\n    {\n      sub_804D5F4(\"read: '%s': not a valid identifier\", v10);\n      return 1;\n    }\n  }\n  if ( a5 )\n  {\n    v36 = sub_804ED6C(10, a5, 0, 0);\n    v11 = (int)\"invalid count\";\n    if ( v36 < 0 || *(_DWORD *)dword_80DBB7C )\n      return v11;\n  }\n  else\n  {\n    v36 = 0;\n  }\n  if ( a7 )\n  {\n    v12 = sub_804ED6C(10, a7, (char **)&v43, 0);\n    if ( v12 > 0x1FFFFF )\n      v12 = 0x1FFFFF;\n    if ( *(_DWORD *)dword_80DBB7C )\n    {\n      if ( *(_DWORD *)dword_80DBB7C != 22 )\n        return (int)&unk_80D10BC;\n      v13 = 4;\n      if ( *(_BYTE *)v43.c_iflag != 46 )\n        return (int)&unk_80D10BC;\n      while ( 1 )\n      {\n        v14 = *(_BYTE *)++v43.c_iflag;\n        if ( !*(_BYTE *)v43.c_iflag )\n          break;\n        if ( v13 == 1 )\n          goto LABEL_26;\n        v12 = 10 * v12 + v14 - 48;\n        --v13;\n        if ( (unsigned __int8)(v14 - 48) > 9u )\n          return (int)&unk_80D10BC;\n      }\n    }\n    else\n    {\n      v13 = 4;\n    }\n    while ( --v13 > 0 )\n      v12 *= 10;\n  }\n  else\n  {\n    v12 = 0;\n  }\nLABEL_26:\n  fds.fd = 0;\n  if ( a8 )\n  {\n    fds.fd = sub_804ED6C(10, a8, 0, 0);\n    v11 = (int)\"invalid file descriptor\";\n    if ( fds.fd < 0 || *(_DWORD *)dword_80DBB7C )\n      return v11;\n  }\n  if ( a7 && !v12 )\n  {\n    fds.events = 1;\n    return poll(&fds, 1u, 0) <= 0;\n  }\n  if ( a6 && isatty(fds.fd) )\n  {\n    fputs_unlocked(a6, stderr);\n    sub_804DD8F();\n  }\n  if ( !a3 )\n    a3 = \" \\t\\n\";\n  if ( v36 || (a4 & 1) != 0 )\n  {\n    tcgetattr(fds.fd, &termios_p);\n    qmemcpy(&v43, &termios_p, sizeof(v43));\n    if ( v36 )\n    {\n      termios_p.c_lflag &= ~2u;\n      *(_WORD *)&termios_p.c_cc[5] = 256;\n    }\n    if ( (a4 & 1) != 0 )\n      termios_p.c_lflag &= 0xFFFFFF97;\n    a4 |= 1u;\n    tcsetattr(fds.fd, 0, &termios_p);\n  }\n  if ( a7 )\n    v12 += sub_804EC14();\n  v39 = 10;\n  if ( a9 )\n    v39 = *a9;\n  v37 = 0;\n  v15 = 1;\n  v16 = 0;\n  do\n  {\n    if ( !(_BYTE)v16 )\n      v10 = (char *)sub_804DB13(v10, v16 + 257);\n    if ( a7 )\n    {\n      v17 = v12 - sub_804EC14();\n      if ( v17 <= 0 )\n      {\n        v11 = 1;\n        v18 = 0;\n        goto LABEL_107;\n      }\n    }\n    else\n    {\n      v17 = -1;\n    }\n    *(_DWORD *)dword_80DBB7C = 0;\n    fds.events = 1;\n    if ( poll(&fds, 1u, v17) <= 0 )\n    {\n      v18 = *(_DWORD *)dword_80DBB7C;\n      v11 = 1;\n      goto LABEL_107;\n    }\n    if ( read(fds.fd, &v10[v16], 1u) != 1 )\n    {\n      v18 = *(_DWORD *)dword_80DBB7C;\n      v11 = 1;\n      goto LABEL_87;\n    }\n    LOBYTE(v19) = v10[v16];\n    if ( !(_BYTE)v19 )\n      goto LABEL_85;\n    if ( (a4 & 2) == 0 )\n    {\n      if ( v37 )\n      {\n        v37 = 0;\n        if ( (_BYTE)v19 != 10 )\n          goto LABEL_80;\n        goto LABEL_85;\n      }\n      if ( (_BYTE)v19 == 92 )\n      {\n        v37 = 1;\n        goto LABEL_85;\n      }\n    }\n    if ( v39 == (_BYTE)v19 )\n      break;\n    if ( a9 || !*v34 )\n      goto LABEL_80;\n    v40 = v10[v16];\n    v20 = strchr(a3, (unsigned __int8)v19);\n    v19 = v30;\n    v21 = v20 != 0;\n    LOBYTE(v19) = v40;\n    if ( v15 && v21 )\n    {\n      if ( (unsigned __int8)(v40 - 9) <= 4u || v40 == 32 )\n        goto LABEL_85;\n      if ( v15 == 2 )\n      {\n        v15 = 1;\n        goto LABEL_85;\n      }\n    }\n    if ( !v34[1] || !v21 )\n    {\n      v15 = 0;\nLABEL_80:\n      ++v16;\n      goto LABEL_85;\n    }\n    v10[v16] = 0;\n    ((void (__fastcall *)(int, char *))a1)(v19, v10);\n    ++v34;\n    LOBYTE(v22) = v40;\n    v19 = v22 - 9;\n    if ( (_BYTE)v19 == 23 || (v15 = 1, (unsigned __int8)v19 <= 4u) )\n      v15 = 2;\n    v16 = 0;\nLABEL_85:\n    --v36;\n  }\n  while ( v36 );\n  v11 = 0;\n  v18 = 0;\nLABEL_87:\n  if ( *v34 )\n  {\n    do\n    {\n      if ( --v16 == -1 )\n        break;\n      v23 = (unsigned __int8)v10[v16];\n      if ( (unsigned __int8)(v23 - 9) > 4u && (_BYTE)v23 != 32 )\n        break;\n      v24 = strchr(a3, v23);\n      v19 = v31;\n    }\n    while ( v24 );\n    v10[v16 + 1] = 0;\n    if ( v16 != -1 )\n    {\n      v25 = strchr(a3, (unsigned __int8)v10[v16]);\n      v19 = v32;\n      if ( v25 )\n      {\n        while ( v16 )\n        {\n          v26 = (unsigned __int8)v10[v16 - 1];\n          if ( (_BYTE)v26 != 32 && (unsigned __int8)(v26 - 9) > 4u || !strchr(a3, v26) )\n            goto LABEL_100;\n          --v16;\n        }\n        v16 = 0;\nLABEL_100:\n        v27 = strcspn(v10, a3);\n        v19 = v33;\n        if ( v27 >= v16 )\n          v10[v16] = 0;\n      }\n    }\n    for ( j = v10; ; j = &data )\n    {\n      ((void (__fastcall *)(int, const char *))a1)(v19, j);\n      if ( !*++v34 )\n        break;\n    }\n  }\n  else\n  {\n    v10[v16] = 0;\n    a1();\n  }\nLABEL_107:\n  free(v10);\n  if ( (a4 & 1) != 0 )\n    tcsetattr(fds.fd, 0, &v43);\n  *(_DWORD *)dword_80DBB7C = v18;\n  return v11;\n}\n"
        ],
        "134714871": [
            "sub_80795F7",
            "0x80795f7",
            "int __usercall sub_80795F7@<eax>(char **a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // eax\n  int i; // esi\n  char *v5; // esi\n  char *v6; // edi\n  __int64 v8; // rax\n  __int64 v9; // rax\n  int argc; // [esp+0h] [ebp-24h]\n  _QWORD v11[4]; // [esp+4h] [ebp-20h] BYREF\n\n  optind = 0;\n  argc = sub_804CD3D(a1);\n  v2 = 0;\n  do\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            v3 = getopt(argc, a1, \"-HSaf::t::d::s::c::m::l::p::n::v::w::e::r::\");\n            if ( v3 == -1 )\n              return 0;\n            if ( v3 != 72 )\n              break;\n            v2 |= 1u;\n          }\n          if ( v3 != 83 )\n            break;\n          v2 |= 2u;\n        }\n        if ( v3 != 97 )\n          break;\n        for ( i = 0; i != 26; i += 2 )\n        {\n          getrlimit64((unsigned __int8)byte_80B6020[i * 4], v11);\n          printf(\"-%c: %-30s \", (unsigned __int8)byte_80B6022[i * 4], (&off_80B6024)[i]);\n          sub_8079037(v2, (unsigned int *)v11, (char *)&unk_80B6021 + i * 4);\n        }\n      }\n      if ( v3 == 1 )\n        v3 = 102;\n      v5 = byte_80B6020;\n      while ( (unsigned __int8)v5[2] != v3 )\n      {\n        v5 += 8;\n        if ( v5 == (char *)&unk_80B6088 )\n          return 0;\n      }\n      getrlimit64((unsigned __int8)*v5, v11);\n      v6 = optarg;\n      if ( optarg )\n        break;\n      v6 = a1[optind];\n      if ( v6 && *v6 != 45 )\n      {\n        ++optind;\n        break;\n      }\n      sub_8079037(v2, (unsigned int *)v11, v5 + 1);\n    }\n    if ( !strcmp(v6, \"unlimited\") )\n    {\n      v9 = -1LL;\n    }\n    else\n    {\n      v8 = sub_804EC9E(v6, 0, 10);\n      if ( *(_DWORD *)dword_80DBB7C )\n      {\n        sub_804D5F4(\"invalid number '%s'\", v6);\n        return 1;\n      }\n      v9 = v8 << v5[1];\n    }\n    if ( !v2 )\n      v2 = 3;\n    if ( (v2 & 1) != 0 )\n      v11[1] = v9;\n    if ( (v2 & 2) != 0 )\n      v11[0] = v9;\n  }\n  while ( setrlimit64((unsigned __int8)*v5, v11) >= 0 );\n  sub_804D3A5((int)\"error setting limit\");\n  return 1;\n}\n"
        ],
        "134715303": [
            "sub_80797A7",
            "0x80797a7",
            "int __cdecl sub_80797A7(int a1, int a2)\n{\n  char v2; // si\n  int v3; // ebx\n  int v4; // ebx\n  int v5; // eax\n  char *v6; // ecx\n  char *v7; // edx\n  _BYTE *v8; // eax\n  _BYTE *v9; // esi\n  char *v10; // edi\n  char *v11; // edx\n  int v12; // eax\n  int v14; // [esp+0h] [ebp-14h] BYREF\n  char *endptr; // [esp+4h] [ebp-10h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"c:n\", &v14);\n  v3 = v2 & 1;\n  if ( (v2 & 1) != 0 )\n    v3 = sub_80B40CC(8, 1);\n  if ( (v2 & 2) == 0 )\n    sub_80B3C0D();\n  byte_80DB561 = 2;\n  klogctl(1, 0, 0);\n  openlog(\"kernel\", 0, 0);\n  if ( v3 )\n    klogctl(8, 0, v3);\n  signal(1, (__sighandler_t)1);\n  sub_804E6F4(117503054, (int)sub_804E68E);\n  syslog(5, \"klogd started: %s\", \"BusyBox v1.29.2 (2024-11-01 02:03:16 UTC)\");\n  v4 = 0;\nLABEL_8:\n  while ( !byte_80DBBA4 )\n  {\n    endptr = (char *)&buf + v4;\n    v5 = klogctl(2, (char *)&buf + v4, 1023 - v4);\n    if ( v5 >= 0 )\n    {\n      v7 = endptr;\n      endptr[v5] = 0;\n      for ( endptr = (char *)&buf; ; endptr = v10 )\n      {\n        v8 = (_BYTE *)strchrnul(v6, v7, endptr, 10);\n        v9 = v8;\n        if ( *v8 )\n        {\n          v10 = v8 + 1;\n          *v8 = 0;\n        }\n        else\n        {\n          sub_80B2C69(v6);\n          v4 = v9 - endptr;\n          if ( v9 - endptr <= 1022 )\n            goto LABEL_8;\n          v10 = 0;\n          v4 = 0;\n        }\n        v11 = endptr;\n        v12 = 6;\n        if ( *endptr == 60 )\n        {\n          v6 = ++endptr;\n          if ( v11[1] )\n            v12 = strtoul(v11 + 1, &endptr, 10);\n          if ( *endptr == 62 )\n            ++endptr;\n        }\n        v7 = endptr;\n        if ( *endptr )\n          syslog(v12, \"%s\", endptr);\n        if ( !v10 )\n          break;\n      }\n    }\n    else if ( *(_DWORD *)dword_80DBB7C != 4 )\n    {\n      sub_804D3A5((int)\"klogctl(2) error\");\n      break;\n    }\n  }\n  klogctl(7, 0, 0);\n  klogctl(0, 0, 0);\n  syslog(5, \"klogd: exiting\");\n  if ( byte_80DBBA4 )\n    sub_804E761(byte_80DBBA4);\n  return 1;\n}\n"
        ],
        "134715783": [
            "sub_8079987",
            "0x8079987",
            "int sub_8079987()\n{\n  char *v0; // eax\n  char *v1; // esi\n  int v2; // ebx\n  struct sockaddr addr[7]; // [esp+2h] [ebp-7Ah] BYREF\n\n  memset(addr[0].sa_data, 0, 0x6Cu);\n  addr[0].sa_family = 1;\n  strcpy(addr[0].sa_data, \"/dev/log\");\n  v0 = sub_804E1D0(\"/dev/log\");\n  if ( v0 )\n  {\n    v1 = v0;\n    sub_80B2C4E(108);\n    free(v1);\n  }\n  unlink(addr[0].sa_data);\n  v2 = sub_804DF99(0, 2, 1);\n  sub_804DFB3(0x6Eu, addr, v2);\n  chmod(\"/dev/log\", 0x1B6u);\n  return v2;\n}\n"
        ],
        "134715924": [
            "sub_8079A14",
            "0x8079a14",
            "int __usercall sub_8079A14@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  if ( (unsigned __int8)(*a1 - 48) <= 9u )\n    return atoi(a1);\n  while ( *(_DWORD *)a2 )\n  {\n    if ( !strcasecmp(a1, *(const char **)a2) )\n      return *(_DWORD *)(a2 + 4);\n    a2 += 8;\n  }\n  return -1;\n}\n"
        ],
        "134715983": [
            "sub_8079A4F",
            "0x8079a4f",
            "int __usercall sub_8079A4F@<eax>(size_t a1@<eax>, char *a2@<edx>, int a3@<ecx>)\n{\n  const char *v3; // esi\n  char *v4; // edi\n  const char **v5; // ebx\n  char **i; // eax\n  const char *v7; // ecx\n  char **j; // eax\n  int result; // eax\n  time_t v10; // esi\n  int v11; // eax\n  int v12; // ebx\n  int v13; // eax\n  bool v14; // dl\n  const char *v15; // eax\n  const char *v16; // edi\n  const char *v17; // eax\n  int v18; // eax\n  void *v19; // esp\n  void *v20; // esp\n  const char *v21; // edi\n  int v22; // [esp-4h] [ebp-84h]\n  int *v23; // [esp+0h] [ebp-80h] BYREF\n  char *old; // [esp+4h] [ebp-7Ch]\n  size_t n; // [esp+8h] [ebp-78h]\n  char *s; // [esp+Ch] [ebp-74h]\n  time_t timer; // [esp+10h] [ebp-70h] BYREF\n  char v28[16]; // [esp+14h] [ebp-6Ch] BYREF\n  int v29; // [esp+24h] [ebp-5Ch]\n  const char *v30; // [esp+40h] [ebp-40h]\n\n  n = a1;\n  v3 = a2;\n  if ( a3 > 15 && a2[3] == 32 && a2[6] == 32 && a2[9] == 58 && a2[12] == 58 && a2[15] == 32 )\n  {\n    timer = 0;\n    v4 = a2;\n    v3 = a2 + 16;\n  }\n  else\n  {\n    time(&timer);\n    v4 = ctime(&timer) + 4;\n  }\n  v4[15] = 0;\n  v5 = (const char **)dword_80DBB80;\n  s = (char *)(dword_80DBB80 + 808);\n  if ( (dword_80DBB9C & 0x10) != 0 )\n  {\n    sprintf(s, \"%s %s\\n\", v4, v3);\n  }\n  else\n  {\n    for ( i = &off_80B60C0; ; i += 2 )\n    {\n      v7 = *i;\n      if ( !*i )\n        break;\n      if ( (char *)(n & 0x3F8) == i[1] )\n      {\n        v23 = (int *)(n & 7);\n        for ( j = &off_80B6180; ; j += 2 )\n        {\n          old = *j;\n          if ( !old )\n            break;\n          if ( v23 == (int *)j[1] )\n          {\n            snprintf(v28, 0x14u, \"%s.%s\", v7, old);\n            goto LABEL_19;\n          }\n        }\n        break;\n      }\n    }\n    snprintf(v28, 0x14u, \"<%d>\", n);\nLABEL_19:\n    sprintf(s, \"%s %.64s %s %s\\n\", v4, v5[9], v28, v3);\n  }\n  result = n & 7;\n  if ( result < (int)v5[5] )\n  {\n    v10 = timer;\n    n = strlen(s);\n    if ( (int)v5[1] <= 1 )\n    {\n      if ( v5[1] == (const char *)1 )\n        goto LABEL_40;\n      if ( **v5 == 45 && !(*v5)[1] )\n      {\n        v5[1] = (const char *)1;\n        goto LABEL_40;\n      }\n    }\n    else\n    {\n      if ( !v10 )\n        v10 = time(0);\n      if ( v5[2] == (const char *)v10 )\n        goto LABEL_40;\n      v5[2] = (const char *)v10;\n      close((int)v5[1]);\n    }\n    while ( 1 )\n    {\n      v11 = open64(*v5);\n      v5[1] = (const char *)v11;\n      if ( v11 < 0 )\n      {\n        v12 = sub_80AA444();\n        if ( v12 < 0 )\n          v12 = 2;\n        result = sub_804E586(n, s);\n        if ( v12 != 2 )\n        {\n          close(v12);\n          return v22;\n        }\n        return result;\n      }\n      v13 = fstat64(v11, v28);\n      v14 = 0;\n      if ( !v13 )\n        v14 = (v29 & 0xF000) == 0x8000;\n      *((_BYTE *)v5 + 16) = v14;\n      v5[3] = v30;\nLABEL_40:\n      v15 = v5[6];\n      if ( !v15 || !*((_BYTE *)v5 + 16) || v15 >= v5[3] )\n        break;\n      v16 = v5[7];\n      v17 = *v5;\n      if ( v16 )\n      {\n        v23 = (int *)&v23;\n        v18 = (strlen(v17) + 7) & 0xFFFFFFFC;\n        v19 = alloca(v18);\n        old = (char *)&v23;\n        v20 = alloca(v18);\n        v21 = v16 - 1;\n        while ( 1 )\n        {\n          sprintf((char *)&v23, \"%s.%d\", *v5, v21);\n          if ( !v21 )\n            break;\n          sprintf(old, \"%s.%d\", *v5, --v21);\n          rename(old, (const char *)&v23);\n        }\n        rename(*v5, (const char *)&v23);\n      }\n      unlink(*v5);\n      close((int)v5[1]);\n    }\n    result = sub_804E586(n, s);\n    if ( result > 0 )\n      v5[3] += result;\n  }\n  return result;\n}\n"
        ],
        "134716674": [
            "sub_8079D02",
            "0x8079d02",
            "char *__usercall sub_8079D02@<eax>(char *result@<eax>)\n{\n  if ( (dword_80DBB9C & 0x100) != 0 )\n    return (char *)sub_8079A4F(0x2Eu, result, 0);\n  return result;\n}\n"
        ],
        "134716698": [
            "sub_8079D1A",
            "0x8079d1a",
            "void __cdecl __noreturn sub_8079D1A(int a1, int a2)\n{\n  _DWORD *v2; // ebx\n  char v3; // si\n  _DWORD *v4; // edi\n  int v5; // ecx\n  __int64 v6; // rax\n  int v7; // ecx\n  int v8; // eax\n  int v9; // esi\n  ssize_t v10; // edi\n  char v11; // al\n  _DWORD *i; // ebp\n  int v13; // ebx\n  int v14; // eax\n  int v15; // eax\n  int v16; // eax\n  int v17; // eax\n  unsigned int v18; // ebx\n  int v19; // eax\n  char *j; // ecx\n  char *v21; // edx\n  char v22; // dl\n  int v23; // [esp+0h] [ebp-28h] BYREF\n  int v24; // [esp+4h] [ebp-24h] BYREF\n  int v25; // [esp+8h] [ebp-20h] BYREF\n  int v26; // [esp+Ch] [ebp-1Ch] BYREF\n  int v27; // [esp+10h] [ebp-18h] BYREF\n  char *v28; // [esp+14h] [ebp-14h] BYREF\n\n  v27 = 0;\n  v2 = sub_804DB2E(0x5A8u);\n  qmemcpy(v2, &off_80B60A0, 0x20u);\n  dword_80DBB80 = (int)v2;\n  v3 = sub_80ABEAC(a2, \"^m:nO:l:Ss:b:R:*L\", &v23, v2, &v24, &v25, &v26, &v27);\n  while ( v27 )\n  {\n    v4 = sub_804DB2E(0x10u);\n    v4[3] = sub_80AFB01(v23);\n    *v4 = -1;\n    v4[1] = sub_804EC4A() - 121;\n    sub_80AFAC3(v5, v4);\n  }\n  if ( (v3 & 8) != 0 )\n    v2[5] = sub_80B40CC(8, 1);\n  if ( (v3 & 0x20) != 0 )\n    v2[6] = sub_80B40CC(0x1FFFFF, 0) << 10;\n  if ( (v3 & 0x40) != 0 )\n    v2[7] = sub_80B40CC(99, 0);\n  if ( (v3 & 0x80) == 0 )\n    dword_80DBB9C |= 0x100u;\n  v6 = sub_80B2BD8();\n  v2[9] = v6;\n  *(_BYTE *)strchrnul(v7, HIDWORD(v6), v6, 46) = 0;\n  if ( (v3 & 2) == 0 )\n    sub_80B3C0D();\n  sub_804E7B4(15, (int)sub_804E68E);\n  sub_804E7B4(2, (int)sub_804E68E);\n  signal(1, (__sighandler_t)1);\n  v8 = sub_8079987();\n  sub_804DC97(v8, 0);\n  sub_8079D02(\"syslogd started: BusyBox v1.29.2\");\nLABEL_15:\n  if ( byte_80DBBA4 )\n  {\nLABEL_57:\n    sub_8079D02(\"syslogd exiting\");\n    sub_804E761(byte_80DBBA4);\n  }\nLABEL_16:\n  v9 = dword_80DBB80;\n  v10 = read(0, (void *)(dword_80DBB80 + 40), 0xFFu);\n  if ( v10 < 0 )\n  {\n    if ( !byte_80DBBA4 )\n      sub_804D3A5((int)&unk_80D1B32);\n    goto LABEL_57;\n  }\n  while ( 1 )\n  {\n    if ( !v10 )\n      goto LABEL_16;\n    v11 = *(_BYTE *)(v9 + v10 - 1 + 40);\n    if ( v11 != 10 )\n    {\n      if ( v11 )\n        break;\n    }\n    --v10;\n  }\n  *(_BYTE *)(v9 + v10 + 40) = 10;\n  for ( i = *(_DWORD **)(v9 + 32); ; i = (_DWORD *)*i )\n  {\n    if ( !i )\n    {\n      if ( (dword_80DBB9C & 0x100) != 0 )\n      {\n        *(_BYTE *)(v9 + v10 + 40) = 0;\n        v28 = (char *)(v9 + 40);\n        v18 = v10 + v9 + 40;\n        while ( v18 > (unsigned int)v28 )\n        {\n          if ( *v28 != 60 )\n            goto LABEL_44;\n          v19 = sub_804ED6C(10, v28 + 1, &v28, v18);\n          if ( *v28 == 62 )\n            ++v28;\n          if ( (v19 & 0xFFFFFC00) != 0 )\nLABEL_44:\n            v19 = 13;\n          for ( j = (char *)(v9 + 296); ; ++j )\n          {\n            v21 = v28++;\n            v22 = *v21;\n            if ( !v22 )\n              break;\n            if ( v22 == 10 )\n              v22 = 32;\n            if ( (v22 & 0xE0) == 0 && v22 != 9 )\n            {\n              *j = 94;\n              v22 += 64;\n              ++j;\n            }\n            *j = v22;\n          }\n          *j = 0;\n          sub_8079A4F(v19, (char *)(v9 + 296), (int)&j[-v9 - 296]);\n        }\n      }\n      goto LABEL_15;\n    }\n    v13 = i[1];\n    if ( *(_DWORD *)v13 != -1 )\n      goto LABEL_37;\n    if ( !*(_DWORD *)(v13 + 8) )\n    {\n      v14 = sub_804EC4A();\n      if ( (unsigned int)(v14 - *(_DWORD *)(v13 + 4)) <= 0x77\n        || (*(_DWORD *)(v13 + 4) = v14, v15 = sub_80B45B2(), (*(_DWORD *)(v13 + 8) = v15) == 0) )\n      {\n        *(_DWORD *)v13 = -1;\n        continue;\n      }\n    }\n    v16 = sub_804DF99(0, 2, *(unsigned __int16 *)(*(_DWORD *)(v13 + 8) + 4));\n    *(_DWORD *)v13 = v16;\n    if ( v16 != -1 )\n    {\nLABEL_37:\n      if ( sendto(\n             *(_DWORD *)v13,\n             (const void *)(v9 + 40),\n             v10 + 1,\n             16448,\n             (const struct sockaddr *)(*(_DWORD *)(v13 + 8) + 4),\n             **(_DWORD **)(v13 + 8)) == -1 )\n      {\n        v17 = *(_DWORD *)dword_80DBB7C;\n        if ( *(_DWORD *)dword_80DBB7C == 104 || v17 == 107 || v17 == 32 )\n        {\n          close(*(_DWORD *)v13);\n          *(_DWORD *)v13 = -1;\n          free(*(void **)(v13 + 8));\n          *(_DWORD *)(v13 + 8) = 0;\n        }\n      }\n    }\n  }\n}\n"
        ],
        "134717542": [
            "sub_807A066",
            "0x807a066",
            "int __cdecl sub_807A066(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // eax\n  const char *v4; // esi\n  char *i; // edi\n  const char *v6; // eax\n  int v7; // ebx\n  int v8; // eax\n  int v9; // ebx\n  const char **v10; // edi\n  int v11; // ebp\n  char *v12; // esi\n  int v14; // [esp+0h] [ebp-1Ch]\n  const char *v15; // [esp+4h] [ebp-18h] BYREF\n  char *ident; // [esp+8h] [ebp-14h] BYREF\n\n  geteuid();\n  ident = (char *)sub_80A9A17();\n  v2 = sub_80ABEAC(a2, \"p:st:\", &v15, &ident);\n  v3 = v2 & 2;\n  if ( (v2 & 2) != 0 )\n    v3 = 32;\n  openlog(ident, v3, 0);\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = v15;\n    for ( i = (char *)v15; ; ++i )\n    {\n      if ( !*i )\n      {\n        v6 = v15;\n        LOWORD(v7) = 8;\n        goto LABEL_9;\n      }\n      if ( *i == 46 )\n        break;\n    }\n    *i = 0;\n    v7 = sub_8079A14(v4, (int)&off_80B60C0);\n    if ( v7 < 0 )\n      sub_804D5E0(\"unknown %s name: %s\", \"facility\", v4);\n    v6 = i + 1;\n    *i = 46;\nLABEL_9:\n    v8 = sub_8079A14(v6, (int)&off_80B6180);\n    if ( v8 < 0 )\n      sub_804D5E0(\"unknown %s name: %s\", \"priority\", v4);\n    v9 = v8 & 7 | v7 & 0x3F8;\n  }\n  else\n  {\n    v9 = 13;\n  }\n  v10 = (const char **)(a2 + 4 * optind);\n  if ( *v10 )\n  {\n    v11 = 0;\n    v12 = 0;\n    do\n    {\n      v14 = v11;\n      v11 += strlen(*v10) + 1;\n      v12 = (char *)sub_804DB13(v12, v11 + 1);\n      sprintf(&v12[v14], \" %s\", *v10++);\n    }\n    while ( *v10 );\n    syslog(v9, \"%s\", v12 + 1);\n  }\n  else\n  {\n    while ( fgets_unlocked(&buf, 1024, stdin) )\n    {\n      if ( (_BYTE)buf && (_WORD)buf != 10 )\n        syslog(v9, \"%s\", (const char *)&buf);\n    }\n  }\n  closelog();\n  return 0;\n}\n"
        ],
        "134717935": [
            "sub_807A1EF",
            "0x807a1ef",
            "int __cdecl sub_807A1EF(int a1, _DWORD *a2)\n{\n  int i; // eax\n\n  for ( i = 1; *++a2; i = 0 )\n    sub_80846BA(*a2);\n  sub_8084661(i);\n  return 0;\n}\n"
        ],
        "134717976": [
            "sub_807A218",
            "0x807a218",
            "int __usercall sub_807A218@<eax>(int a1@<eax>)\n{\n  int priority_max; // esi\n  int priority_min; // eax\n  const char *v4; // edx\n\n  priority_max = sched_get_priority_max(a1);\n  priority_min = sched_get_priority_min(a1);\n  v4 = \"%s not supported\\n\";\n  if ( (priority_min | priority_max) >= 0 )\n    v4 = \"%s min/max priority\\t: %u/%u\\n\";\n  return printf(v4, 12 * a1 + 134963712, priority_min, priority_max);\n}\n"
        ],
        "134718036": [
            "sub_807A254",
            "0x807a254",
            "int __cdecl sub_807A254(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // ebx\n  _DWORD *v4; // edi\n  __pid_t v5; // esi\n  const char *v6; // ebp\n  int v7; // eax\n  int priority_max; // [esp+8h] [ebp-18h]\n  struct sched_param param; // [esp+Ch] [ebp-14h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^+mprfobi\");\n  if ( (v2 & 1) != 0 )\n  {\n    sub_807A218(0);\n    sub_807A218(1);\n    sub_807A218(2);\n    sub_807A218(3);\n    sub_807A218(5);\n    sub_80AB247();\n  }\n  v3 = (v2 << 28 >> 31) + 2;\n  if ( (v2 & 0x10) != 0 )\n    v3 = 0;\n  if ( (v2 & 0x20) != 0 )\n    v3 = 3;\n  if ( (v2 & 0x40) != 0 )\n    v3 = 5;\n  v4 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v4 )\n    goto LABEL_10;\n  if ( (v2 & 2) == 0 )\n  {\n    if ( v4[1] )\n    {\n      v5 = 0;\n      v6 = \"current\";\n      goto LABEL_21;\n    }\nLABEL_10:\n    sub_804CDC2();\n  }\n  v5 = sub_80B40CC(0x7FFFFFFF, 1);\n  v6 = \"current\";\n  while ( 1 )\n  {\n    v7 = sched_getscheduler(v5);\n    if ( v7 < 0 )\n      sub_804D3C9((int)\"can't %cet pid %d's policy\", 103, v5);\n    printf(\"pid %d's %s scheduling policy: %s\\n\", v5, v6, (const char *)(12 * v7 + 134963712));\n    if ( sched_getparam(v5, &param) )\n      sub_804D3C9((int)\"can't get pid %d's attributes\", v5);\n    printf(\"pid %d's %s scheduling priority: %d\\n\", v5, v6, param.__sched_priority);\n    if ( !v4[1] )\n      break;\n    v4[1] = 0;\n    v6 += 8;\nLABEL_21:\n    priority_max = sched_get_priority_max(v3);\n    sched_get_priority_min(v3);\n    param.__sched_priority = sub_80B4093(priority_max);\n    if ( sched_setscheduler(v5, v3, &param) < 0 )\n      sub_804D3C9((int)\"can't %cet pid %d's policy\", 115, v5);\n    if ( v4[1] )\n      sub_80AB1EC();\n  }\n  return 0;\n}\n"
        ],
        "134718439": [
            "sub_807A3E7",
            "0x807a3e7",
            "int __cdecl sub_807A3E7(int a1, int a2)\n{\n  char v2; // al\n  char v3; // bl\n  char *v4; // esi\n  int v5; // eax\n  int v6; // ebx\n  int v7; // edi\n  unsigned __int8 v8; // al\n  unsigned __int8 *v9; // ecx\n  bool v10; // zf\n  int v12; // [esp+0h] [ebp-18h] BYREF\n  int len[5]; // [esp+4h] [ebp-14h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"cs:+n:+r\", &v12, len);\n  if ( (v2 & 4) != 0 )\n  {\n    if ( klogctl(8, 0, len[0]) )\n      goto LABEL_3;\n  }\n  else\n  {\n    v3 = v2;\n    if ( (v2 & 2) == 0 )\n      v12 = klogctl(10, 0, 0);\n    if ( v12 <= 0x3FFF )\n      v12 = 0x4000;\n    if ( v12 > 0x1000000 )\n      v12 = 0x1000000;\n    v4 = (char *)sub_804DAFA(v12);\n    v5 = klogctl((v3 & 1) + 3, v4, v12);\n    v12 = v5;\n    if ( v5 < 0 )\nLABEL_3:\n      sub_804D3C9((int)\"klogctl\");\n    if ( v5 )\n    {\n      if ( (v3 & 8) != 0 )\n      {\n        sub_804E586(v5, v4);\n        v10 = v4[v12 - 1] == 10;\n      }\n      else\n      {\n        v6 = 0;\n        v7 = 10;\n        do\n        {\n          v8 = v4[v6];\n          if ( v7 == 10 && v8 == 60 )\n          {\n            do\n              ++v6;\n            while ( v4[v6 - 1] != 62 && v12 > v6 );\n          }\n          else\n          {\n            ++v6;\n            v7 = v8;\n            v9 = *(unsigned __int8 **)(_stdout + 16);\n            if ( (unsigned int)v9 >= *(_DWORD *)(_stdout + 28) )\n            {\n              __fputc_unlocked(v8, _stdout);\n            }\n            else\n            {\n              *(_DWORD *)(_stdout + 16) = v9 + 1;\n              *v9 = v8;\n            }\n          }\n        }\n        while ( v12 > v6 );\n        v10 = v7 == 10;\n      }\n      if ( !v10 )\n        sub_804DD98(10);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134718742": [
            "sub_807A516",
            "0x807a516",
            "int __cdecl sub_807A516(int a1, int a2)\n{\n  char v2; // si\n  const char *v3; // ebx\n  int v4; // eax\n  unsigned int v5; // eax\n\n  v2 = sub_80ABEAC(a2, \"^tT\");\n  v3 = *(const char **)(a2 + 4 * optind);\n  if ( !v3 )\n    v3 = \"/dev/cdrom\";\n  v4 = sub_804DC1E(v3);\n  sub_804DC97(v4, 3);\n  if ( (v2 & 1) != 0 || (v2 & 2) != 0 && ioctl(3, 0x5326u) == 2 )\n    v5 = 21273;\n  else\n    v5 = 21257;\n  sub_804E029(3, v5, 0, \"%s\", v3);\n  return 0;\n}\n"
        ],
        "134718865": [
            "sub_807A591",
            "0x807a591",
            "int __cdecl sub_807A591(int a1, int a2)\n{\n  __int64 v2; // kr00_8\n  const char **v3; // ebx\n  int v4; // eax\n  int v5; // eax\n  __int64 v7; // [esp+0h] [ebp-1Ch]\n  int v8; // [esp+8h] [ebp-14h] BYREF\n  int v9[4]; // [esp+Ch] [ebp-10h] BYREF\n\n  v9[0] = 135052877;\n  if ( (sub_80ABEAC(a2, \"^l:o:\", &v8, v9) & 1) == 0 )\n    sub_804CDC2();\n  v7 = sub_80B3F8E();\n  v2 = sub_80B3F8E();\n  v3 = (const char **)(a2 + 4 * optind);\n  v4 = sub_804DBC2(*v3);\n  v5 = posix_fallocate64(v4, v7, HIDWORD(v7), v2, HIDWORD(v2));\n  *(_DWORD *)dword_80DBB7C = v5;\n  if ( v5 )\n    sub_804D3C9((int)\"fallocate '%s'\", *v3);\n  return 0;\n}\n"
        ],
        "134719032": [
            "sub_807A638",
            "0x807a638",
            "int __usercall sub_807A638@<eax>(char *s1@<ecx>, int *a2@<eax>, int a3@<edx>, char *s2)\n{\n  int result; // eax\n  int v7; // edx\n  int v8; // ebx\n\n  result = strcmp(s1, s2);\n  v7 = *a2;\n  if ( result )\n    v8 = v7 | a3;\n  else\n    v8 = v7 & ~a3;\n  *a2 = v8;\n  return result;\n}\n"
        ],
        "134719069": [
            "sub_807A65D",
            "0x807a65d",
            "int __usercall sub_807A65D@<eax>(int *a1@<eax>)\n{\n  unsigned int v2; // esi\n  int v3; // edi\n  int v4; // edx\n  int v5; // ecx\n  long double v6; // fst7\n  long double v7; // fst6\n  long double v8; // fst5\n  const char *v9; // eax\n  int v11; // [esp+0h] [ebp-58h]\n  int v12; // [esp+4h] [ebp-54h]\n  int v13; // [esp+8h] [ebp-50h]\n  int v14; // [esp+Ch] [ebp-4Ch]\n  int v15; // [esp+10h] [ebp-48h]\n  int v16; // [esp+14h] [ebp-44h]\n  int v17; // [esp+18h] [ebp-40h]\n  int v18; // [esp+1Ch] [ebp-3Ch]\n  int v19; // [esp+24h] [ebp-34h]\n  int v20; // [esp+28h] [ebp-30h]\n  int v21; // [esp+2Ch] [ebp-2Ch]\n  int v22; // [esp+30h] [ebp-28h]\n  int v23; // [esp+34h] [ebp-24h]\n\n  v2 = a1[25];\n  v3 = a1[26];\n  v4 = *a1;\n  v23 = a1[27];\n  v22 = a1[30];\n  v21 = a1[28];\n  v5 = a1[1];\n  v20 = a1[29];\n  v19 = a1[31];\n  if ( v2 )\n  {\n    v6 = 1.0e12 / (long double)v2;\n    v7 = v6 / (long double)(unsigned int)(v22 + v23 + v3 + v4);\n    v8 = v7 / (long double)(unsigned int)(v19 + v20 + v5 + v21);\n  }\n  else\n  {\n    v7 = 0.0;\n    v8 = 0.0;\n    v6 = 0.0;\n  }\n  v18 = a1[17];\n  v17 = a1[18];\n  v16 = a1[14];\n  v15 = a1[15];\n  v14 = a1[11];\n  v13 = a1[12];\n  v12 = a1[8];\n  v11 = a1[9];\n  v9 = \"/bin/false\" + 5;\n  if ( a1[24] )\n    v9 = \"true\";\n  return printf(\n           \"\\n\"\n           \"mode \\\"%ux%u-%u\\\"\\n\"\n           \"\\t# D: %.3f MHz, H: %.3f kHz, V: %.3f Hz\\n\"\n           \"\\tgeometry %u %u %u %u %u\\n\"\n           \"\\ttimings %u %u %u %u %u %u %u\\n\"\n           \"\\taccel %s\\n\"\n           \"\\trgba %u/%u,%u/%u,%u/%u,%u/%u\\n\"\n           \"endmode\\n\"\n           \"\\n\",\n           v4,\n           v5,\n           (int)(v8 + 0.5),\n           (double)(v6 / 1000000.0),\n           (double)(v7 / 1000.0),\n           (double)v8,\n           v4,\n           v5,\n           a1[2],\n           a1[3],\n           a1[6],\n           v2,\n           v3,\n           v23,\n           v21,\n           v20,\n           v22,\n           v19,\n           v9,\n           v11,\n           v12,\n           v13,\n           v14,\n           v15,\n           v16,\n           v17,\n           v18);\n}\n"
        ],
        "134719422": [
            "sub_807A7BE",
            "0x807a7be",
            "int __usercall sub_807A7BE@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int i; // ecx\n  int v3; // ebx\n  int v4; // ecx\n  int result; // eax\n  int v6; // edx\n  int j; // ecx\n  int v8; // ebx\n\n  for ( i = 0; i != 16; i += 4 )\n  {\n    v3 = *(_DWORD *)(a2 + i);\n    if ( v3 > 0 )\n      *(_DWORD *)(a1 + i) = v3;\n  }\n  v4 = *(_DWORD *)(a2 + 24);\n  if ( v4 > 0 )\n    *(_DWORD *)(a1 + 24) = v4;\n  result = a1 + 100;\n  v6 = a2 + 100;\n  for ( j = 0; j != 36; j += 4 )\n  {\n    v8 = *(_DWORD *)(v6 + j);\n    if ( v8 > 0 )\n      *(_DWORD *)(result + j) = v8;\n  }\n  return result;\n}\n"
        ],
        "134719481": [
            "sub_807A7F9",
            "0x807a7f9",
            "int __cdecl sub_807A7F9(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // edi\n  int v4; // esi\n  char *v5; // ebp\n  int v6; // ecx\n  const char *v7; // ebp\n  int v8; // eax\n  char *v9; // edx\n  char v10; // cl\n  int v11; // ebx\n  char *v12; // ebp\n  char *v13; // eax\n  char v14; // dl\n  int v15; // eax\n  char *needle; // [esp+4h] [ebp-18Ch]\n  char *s; // [esp+8h] [ebp-188h]\n  unsigned __int8 sa; // [esp+8h] [ebp-188h]\n  const char *v20; // [esp+Ch] [ebp-184h]\n  int v21; // [esp+14h] [ebp-17Ch]\n  char v22; // [esp+14h] [ebp-17Ch]\n  char *s1; // [esp+38h] [ebp-158h]\n  char *haystack; // [esp+3Ch] [ebp-154h]\n  int v25; // [esp+40h] [ebp-150h] BYREF\n  char v26; // [esp+44h] [ebp-14Ch] BYREF\n  char v27; // [esp+48h] [ebp-148h] BYREF\n  char v28; // [esp+4Ch] [ebp-144h] BYREF\n  int v29; // [esp+58h] [ebp-138h] BYREF\n  int v30; // [esp+94h] [ebp-FCh]\n  char v31; // [esp+A4h] [ebp-ECh] BYREF\n  char v32; // [esp+A8h] [ebp-E8h] BYREF\n  char v33; // [esp+ACh] [ebp-E4h] BYREF\n  char v34; // [esp+B0h] [ebp-E0h] BYREF\n  char v35; // [esp+B4h] [ebp-DCh] BYREF\n  char v36; // [esp+B8h] [ebp-D8h] BYREF\n  char v37; // [esp+BCh] [ebp-D4h] BYREF\n  int v38; // [esp+C0h] [ebp-D0h] BYREF\n  int v39[7]; // [esp+C4h] [ebp-CCh] BYREF\n  int v40[44]; // [esp+E0h] [ebp-B0h] BYREF\n\n  memset(v40, 255, 0xA0u);\n  v2 = a2 + 4;\n  v3 = a1 - 1;\n  v20 = \"/dev/fb0\";\n  v4 = 0;\n  while ( v3 > 0 )\n  {\n    v5 = *(char **)v2;\n    if ( !*(_DWORD *)v2 )\n      break;\n    if ( *v5 == 45 )\n    {\n      v6 = 0;\n      v7 = v5 + 1;\n      while ( 1 )\n      {\n        v21 = v6;\n        s = (char *)(11 * v6 + 134963808);\n        v8 = strcmp(v7, s);\n        v9 = s;\n        if ( !v8 )\n          break;\n        v6 = v21 + 1;\n        if ( v21 == 35 )\n          goto LABEL_6;\n      }\n      sa = s[9];\n      if ( sa >= v3 )\nLABEL_6:\n        sub_804CDC2();\n      v10 = v9[10];\n      if ( v10 == 7 )\n      {\n        v40[32] |= 2u;\n        goto LABEL_40;\n      }\n      if ( (unsigned __int8)v10 <= 7u )\n      {\n        if ( v10 == 3 )\n        {\n          v22 = 3;\n          v40[0] = sub_80B40EC();\n          v40[1] = sub_80B40EC();\n          v40[2] = sub_80B40EC();\n          v40[3] = sub_80B40EC();\n          v40[6] = sub_80B40EC();\n        }\n        else\n        {\n          if ( (unsigned __int8)v10 <= 3u )\n          {\n            if ( v10 == 1 )\n            {\n              v20 = *(const char **)(v2 + 4);\n              goto LABEL_40;\n            }\n            if ( v10 == 2 )\n            {\nLABEL_40:\n              if ( ((1 << v10) & 0x2806) == 0 )\n                goto LABEL_41;\n              goto LABEL_42;\n            }\nLABEL_39:\n            if ( (unsigned __int8)v10 <= 0xDu )\n              goto LABEL_40;\nLABEL_41:\n            v4 |= 1u;\nLABEL_42:\n            v3 -= sa;\n            v2 += 4 * sa;\n            v5 = needle;\n            goto LABEL_43;\n          }\n          if ( v10 != 4 )\n          {\n            if ( v10 == 6 )\n            {\n              v40[32] |= 1u;\n              goto LABEL_40;\n            }\n            goto LABEL_39;\n          }\n          v22 = 4;\n          v40[25] = sub_80B40EC();\n          v40[26] = sub_80B40EC();\n          v40[27] = sub_80B40EC();\n          v40[28] = sub_80B40EC();\n          v40[29] = sub_80B40EC();\n          v40[30] = sub_80B40EC();\n          v40[31] = sub_80B40EC();\n        }\n        v10 = v22;\n        goto LABEL_40;\n      }\n      if ( v10 == 100 )\n      {\n        v40[0] = sub_80B40EC();\n        goto LABEL_41;\n      }\n      if ( (unsigned __int8)v10 > 0x64u )\n      {\n        if ( v10 == 101 )\n        {\n          v40[1] = sub_80B40EC();\n          goto LABEL_41;\n        }\n        if ( v10 == 104 )\n        {\n          v40[6] = sub_80B40EC();\n          goto LABEL_41;\n        }\n      }\n      else\n      {\n        if ( v10 == 11 )\n        {\n          v4 |= 8u;\n          goto LABEL_40;\n        }\n        if ( v10 == 13 )\n        {\n          v4 |= 2u;\n          goto LABEL_40;\n        }\n      }\n      goto LABEL_39;\n    }\n    if ( v3 != 1 )\n      goto LABEL_6;\n    v4 |= 4u;\nLABEL_43:\n    --v3;\n    v2 += 4;\n    needle = v5;\n  }\n  v11 = sub_804DBE1(v20);\n  sub_804E0BE(v11, 0x4600u, (int)&v25, \"FBIOGET_VSCREENINFO\");\n  if ( (v4 & 4) != 0 )\n  {\n    sub_80B052C();\n    while ( sub_80B0560(\"# \\t\\r\") )\n    {\n      if ( !strcmp(s1, \"mode\") )\n      {\n        if ( haystack )\n        {\n          v12 = strstr(haystack, needle);\n          if ( v12 )\n          {\n            v13 = &v12[strlen(needle)];\n            v14 = *v13;\n            if ( ((*v13 & 0xDF) == 0 || (unsigned __int8)(v14 - 9) <= 4u) && *(v13 - 1) != 34 )\n              break;\n            if ( v14 == 34 && *(v12 - 1) == 34 )\n              break;\n          }\n        }\n      }\n    }\n    if ( !s1 )\nLABEL_56:\n      sub_804D5E0(\"unknown video mode '%s'\", needle);\n    while ( 1 )\n    {\n      if ( !sub_80B0560(\"# \\t\") )\n        goto LABEL_56;\n      if ( !strcmp(s1, \"endmode\") )\n        break;\n      v15 = sub_804D222(\"geometry\", s1);\n      switch ( v15 )\n      {\n        case 0:\n          sscanf(haystack, \"%d %d %d %d %d\", &v25, &v26, &v27, &v28, &v29);\n          break;\n        case 1:\n          sscanf(haystack, \"%d %d %d %d %d %d %d\", &v31, &v32, &v33, &v34, &v35, &v36, &v37);\n          break;\n        case 2:\n        case 3:\n          sub_807A638(haystack, v39, dword_80B7D90[v15], \"false\");\n          break;\n        case 4:\n          sub_807A638(haystack, &v38, (int)*(&off_80B7D7C + v15), \"low\");\n          break;\n        default:\n          continue;\n      }\n    }\n    v4 |= 1u;\n  }\n  if ( (v4 & 1) == 0 )\n  {\n    if ( v4 )\n      goto LABEL_74;\nLABEL_73:\n    sub_807A65D(&v25);\n    return 0;\n  }\n  sub_807A7BE((int)&v25, (int)v40);\n  if ( (v4 & 8) != 0 )\n    v30 = 64;\n  sub_804E0BE(v11, 0x4601u, (int)&v25, \"FBIOPUT_VSCREENINFO\");\nLABEL_74:\n  if ( (v4 & 2) != 0 )\n    goto LABEL_73;\n  return 0;\n}\n"
        ],
        "134720860": [
            "sub_807AD5C",
            "0x807ad5c",
            "int __cdecl sub_807AD5C(int a1, int a2)\n{\n  unsigned int v2; // esi\n  const char **v3; // ebx\n  int v4; // edi\n  const char *v5; // edx\n  unsigned int i; // ebx\n  size_t v7; // ebx\n  ssize_t v8; // ebp\n  void *buf; // [esp+10h] [ebp-9Ch]\n  char v11[4]; // [esp+14h] [ebp-98h] BYREF\n  int v12; // [esp+18h] [ebp-94h]\n  unsigned int v13; // [esp+1Ch] [ebp-90h]\n  unsigned int v14; // [esp+20h] [ebp-8Ch] BYREF\n  int v15; // [esp+24h] [ebp-88h]\n  int v16; // [esp+28h] [ebp-84h]\n  unsigned int v17; // [esp+2Ch] [ebp-80h]\n  char v18[16]; // [esp+3Ch] [ebp-70h] BYREF\n  int v19; // [esp+4Ch] [ebp-60h]\n\n  v2 = sub_80ABEAC(a2, \"^n\");\n  v3 = (const char **)(a2 + 4 * optind);\n  sub_804DFF3(*v3, (int)v18);\n  if ( (v19 & 0xF000) != 24576 )\n    sub_804D5E0(\"%s: not a block device\", *v3);\n  v4 = sub_804DBE1(*v3);\n  sub_804E0BE(v4, 0x801C0204, (int)&v14, \"FDGETPRM\");\n  v5 = \"Double\";\n  if ( v16 != 2 )\n    v5 = \"Single\";\n  printf(\"%s-sided, %u tracks, %u sec/track. Total capacity %d kB\\n\", v5, v17, v15, v14 >> 1);\n  printf(\"Formatting... \");\n  sub_804E0BE(v4, 0x247u, 0, \"FDFMTBEG\");\n  for ( i = 0; v17 > i; ++i )\n  {\n    v12 = 0;\n    v13 = i;\n    sub_804E0BE(v4, 0x400C0248u, (int)v11, \"FDFMTTRK\");\n    printf(\"%3d\\b\\b\\b\", i);\n    if ( v16 == 2 )\n    {\n      v12 = 1;\n      sub_804E0BE(v4, 0x400C0248u, (int)v11, \"FDFMTTRK\");\n    }\n  }\n  sub_804E0BE(v4, 0x249u, 0, \"FDFMTEND\");\n  puts(\"Done\");\n  if ( !v2 )\n  {\n    v7 = (v16 * v15) << 9;\n    buf = sub_804DAFA(v7);\n    printf(\"Verifying... \");\n    while ( v17 > v2 )\n    {\n      printf(\"%3d\\b\\b\\b\", v2);\n      v8 = sub_804E5BC(v7, buf, v4);\n      if ( v7 != v8 )\n      {\n        if ( v8 < 0 )\n          sub_804D3A5((int)\"read error\");\n        sub_804D5E0(\"problem reading cylinder %d, expected %d, read %d\", v2, v7, v8);\n      }\n      while ( --v8 >= 0 )\n      {\n        if ( *((_BYTE *)buf + v8) != 0xF6 )\n          printf(\"bad data in cyl %d\\nContinuing... \", v2);\n      }\n      ++v2;\n    }\n    puts(\"Done\");\n  }\n  return 0;\n}\n"
        ],
        "134721331": [
            "sub_807AF33",
            "0x807af33",
            "const char *__usercall sub_807AF33@<eax>(char a1@<al>)\n{\n  void **i; // ecx\n  _BYTE *v2; // edx\n\n  for ( i = &off_80B6400; ; ++i )\n  {\n    v2 = *i;\n    if ( !*i )\n      break;\n    if ( *v2 == a1 )\n      return v2 + 1;\n  }\n  return \"Unknown\";\n}\n"
        ],
        "134721359": [
            "sub_807AF4F",
            "0x807af4f",
            "_BOOL4 __usercall sub_807AF4F@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  char v2; // cl\n\n  v1 = 0;\n  v2 = 0;\n  do\n    v2 |= *(_BYTE *)(a1 + v1++);\n  while ( v1 != 16 );\n  return v2 == 0;\n}\n"
        ],
        "134721380": [
            "sub_807AF64",
            "0x807af64",
            "unsigned int __usercall sub_807AF64@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned int v4; // edi\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  unsigned int v7; // eax\n  unsigned int result; // eax\n  unsigned int v9; // [esp+0h] [ebp-18h]\n  char v10; // [esp+7h] [ebp-11h]\n\n  v9 = a2;\n  v10 = *(_BYTE *)(dword_80DBB80 + 43);\n  v4 = *(_DWORD *)(dword_80DBB80 + 32);\n  v5 = *(_DWORD *)(dword_80DBB80 + 28);\n  if ( v10 && a2 / (v5 * v4) > 0x3FF )\n    v9 = ((v5 * v4) << 10) - 1;\n  v6 = v9 / v4 / v5;\n  a1[1] = v9 / v4 % v5;\n  a1[3] = v6;\n  a1[2] = (v6 >> 2) & 0xC0 | (v9 % v4 + 1);\n  if ( v10 && a3 / (v5 * v4) > 0x3FF )\n    a3 = ((v5 * v4) << 10) - 1;\n  v7 = a3 / v4 / v5;\n  a1[5] = a3 / v4 % v5;\n  a1[7] = v7;\n  result = v7 >> 2;\n  a1[6] = (a3 % v4 + 1) | result & 0xC0;\n  return result;\n}\n"
        ],
        "134721544": [
            "sub_807B008",
            "0x807b008",
            "int sub_807B008()\n{\n  int result; // eax\n  int v1; // edx\n\n  result = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 32) * *(_DWORD *)(dword_80DBB80 + 28);\n  if ( *(_BYTE *)(dword_80DBB80 + 41) && v1 )\n    *(_DWORD *)(dword_80DBB80 + 12) = v1;\n  else\n    *(_DWORD *)(dword_80DBB80 + 12) = 1;\n  return result;\n}\n"
        ],
        "134721578": [
            "sub_807B02A",
            "0x807b02a",
            "int __usercall sub_807B02A@<eax>(int *a1@<eax>)\n{\n  _DWORD *v1; // ecx\n  int v2; // edi\n  int v3; // edx\n  unsigned int v4; // esi\n\n  v1 = (_DWORD *)(dword_80DBB80 + 2252);\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  while ( 1 )\n  {\n    if ( *(_DWORD *)(dword_80DBB80 + 8) == v3 )\n      return 0;\n    if ( v3 == 4 )\n    {\n      v2 = 4;\n      v4 = 0;\n    }\n    if ( *(_BYTE *)(*v1 + 4) )\n      break;\nLABEL_11:\n    ++v3;\n    v1 += 5;\n  }\n  if ( v4 <= v1[2] + *(_DWORD *)(*v1 + 8) )\n  {\n    v2 = v3;\n    v4 = v1[2] + *(_DWORD *)(*v1 + 8);\n    goto LABEL_11;\n  }\n  if ( a1 )\n    *a1 = v2;\n  return v3;\n}\n"
        ],
        "134721664": [
            "sub_807B080",
            "0x807b080",
            "int __usercall sub_807B080@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // edi\n  _DWORD *v3; // ebx\n  unsigned int i; // ecx\n  int v5; // esi\n  char v6; // bp\n  int v7; // ebp\n  int v8; // [esp+0h] [ebp-18h]\n\n  v8 = result;\n  v2 = dword_80DBB80;\n  v3 = (_DWORD *)(dword_80DBB80 + 2252);\n  for ( i = 0; *(_DWORD *)(v2 + 8) > i; ++i )\n  {\n    v5 = *v3;\n    v6 = *(_BYTE *)(*v3 + 4);\n    if ( v6 == 15 || v6 == 0 || (v6 & 0x7F) == 5 )\n    {\n      result = v8;\n      *(_DWORD *)(v8 + 4 * i) = -1;\n      *(_DWORD *)(a2 + 4 * i) = 0;\n    }\n    else\n    {\n      v7 = v3[2] + *(_DWORD *)(v5 + 8);\n      result = v8;\n      *(_DWORD *)(v8 + 4 * i) = v7;\n      *(_DWORD *)(a2 + 4 * i) = v7 + *(_DWORD *)(v5 + 12) - 1;\n    }\n    v3 += 5;\n  }\n  return result;\n}\n"
        ],
        "134721788": [
            "sub_807B0FC",
            "0x807b0fc",
            "int sub_807B0FC()\n{\n  int v0; // eax\n\n  v0 = sub_804DBE1(\"/dev/null\");\n  return sub_804DC97(v0, 3);\n}\n"
        ],
        "134721810": [
            "sub_807B112",
            "0x807b112",
            "int sub_807B112()\n{\n  int v0; // edx\n  const char *v1; // ebp\n  unsigned __int64 v3; // [esp+0h] [ebp-24h]\n  unsigned int v4; // [esp+8h] [ebp-1Ch]\n\n  v4 = *(_DWORD *)(dword_80DBB80 + 84);\n  v3 = (unsigned __int64)v4 << 9 >> 20;\n  if ( HIDWORD(v3) || (v0 = 77, (unsigned int)v3 > 0x270F) )\n  {\n    v3 = (v3 + 512) >> 10;\n    v0 = 71;\n  }\n  v1 = \"cylinders\";\n  if ( !*(_BYTE *)(dword_80DBB80 + 41) )\n    v1 = \"sectors\";\n  return printf(\n           \"Disk %s: %llu %cB, %llu bytes, %u sectors\\n\"\n           \"%u cylinders, %u heads, %u sectors/track\\n\"\n           \"Units: %s of %u * %u = %u bytes\\n\"\n           \"\\n\",\n           *(const char **)(dword_80DBB80 + 4),\n           v3,\n           v0,\n           (unsigned __int64)v4 << 9,\n           v4,\n           *(_DWORD *)(dword_80DBB80 + 36),\n           *(_DWORD *)(dword_80DBB80 + 28),\n           *(_DWORD *)(dword_80DBB80 + 32),\n           v1,\n           *(_DWORD *)(dword_80DBB80 + 12),\n           *(_DWORD *)(dword_80DBB80 + 16),\n           *(_DWORD *)(dword_80DBB80 + 16) * *(_DWORD *)(dword_80DBB80 + 12));\n}\n"
        ],
        "134722006": [
            "sub_807B1D6",
            "0x807b1d6",
            "int sub_807B1D6()\n{\n  int result; // eax\n  int v1; // [esp-8h] [ebp-8h]\n\n  result = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 + 40) && *(_DWORD *)(dword_80DBB80 + 36) > 0x400u && !*(_BYTE *)(dword_80DBB80 + 44) )\n  {\n    printf(\n      \"\\n\"\n      \"The number of cylinders for this disk is set to %u.\\n\"\n      \"There is nothing wrong with that, but this is larger than 1024,\\n\"\n      \"and could in certain setups cause problems with:\\n\"\n      \"1) software that runs at boot time (e.g., old versions of LILO)\\n\"\n      \"2) booting and partitioning software from other OSs\\n\"\n      \"   (e.g., DOS FDISK, OS/2 FDISK)\\n\",\n      *(_DWORD *)(dword_80DBB80 + 36));\n    return v1;\n  }\n  return result;\n}\n"
        ],
        "134722048": [
            "sub_807B200",
            "0x807b200",
            "int sub_807B200()\n{\n  _DWORD *v0; // ebx\n  int result; // eax\n\n  v0 = (_DWORD *)dword_80DBB80;\n  if ( !*(_DWORD *)(dword_80DBB80 + 28)\n    || !*(_DWORD *)(dword_80DBB80 + 32)\n    || (result = 0, !*(_DWORD *)(dword_80DBB80 + 36)) )\n  {\n    printf(\"Unknown value(s) for:\");\n    if ( !v0[7] )\n      printf(\" heads\");\n    if ( !v0[8] )\n      printf(\" sectors\");\n    if ( !v0[9] )\n      printf(\" cylinders\");\n    puts(\" (settable in the extra functions menu)\");\n    return 1;\n  }\n  return result;\n}\n"
        ],
        "134722155": [
            "sub_807B26B",
            "0x807b26b",
            "int sub_807B26B()\n{\n  puts(\"Command Action\");\n  if ( *(_BYTE *)(dword_80DBB80 + 40) == 5 )\n  {\n    puts(\"o\\tcreate a new empty DOS partition table\");\n    puts(\"p\\tprint the partition table\");\n    puts(\"q\\tquit without saving changes\");\n    return puts(\"s\\tcreate a new empty Sun disklabel\");\n  }\n  else\n  {\n    puts(\"a\\ttoggle a bootable flag\");\n    puts(\"b\\tedit bsd disklabel\");\n    puts(\"c\\ttoggle the dos compatibility flag\");\n    puts(\"d\\tdelete a partition\");\n    puts(\"l\\tlist known partition types\");\n    puts(\"n\\tadd a new partition\");\n    puts(\"o\\tcreate a new empty DOS partition table\");\n    puts(\"p\\tprint the partition table\");\n    puts(\"q\\tquit without saving changes\");\n    puts(\"s\\tcreate a new empty Sun disklabel\");\n    puts(\"t\\tchange a partition's system id\");\n    puts(\"u\\tchange display/entry units\");\n    puts(\"v\\tverify the partition table\");\n    puts(\"w\\twrite table to disk and exit\");\n    return puts(\"x\\textra functionality (experts only)\");\n  }\n}\n"
        ],
        "134722378": [
            "sub_807B34A",
            "0x807b34a",
            "void __usercall __noreturn sub_807B34A(char *a1@<eax>)\n{\n  int v1; // ebx\n\n  v1 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 42) )\n  {\n    sub_807B0FC();\n    longjmp((struct __jmp_buf_tag *)(v1 + 88), 1);\n  }\n  sub_804D5E0(a1, *(_DWORD *)(dword_80DBB80 + 4));\n}\n"
        ],
        "134722416": [
            "sub_807B370",
            "0x807b370",
            "int __usercall sub_807B370@<eax>(unsigned int a1@<eax>)\n{\n  signed __int64 v1; // rax\n  int result; // eax\n  int v3; // edx\n\n  v1 = *(unsigned int *)(dword_80DBB80 + 16) * (unsigned __int64)a1;\n  if ( v1 < 0 || (result = lseek64(3, v1, HIDWORD(v1), 0), v3 == -1) && (++result, !result) )\n    sub_807B34A(\"can't seek on %s\");\n  return result;\n}\n"
        ],
        "134722460": [
            "sub_807B39C",
            "0x807b39c",
            "ssize_t __usercall sub_807B39C@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v4; // esi\n  ssize_t result; // eax\n\n  *(_DWORD *)(a1 + 8) = a2;\n  v4 = dword_80DBB80;\n  *(_DWORD *)(a1 + 12) = sub_804DB2E(*(_DWORD *)(dword_80DBB80 + 16));\n  sub_807B370(a2);\n  result = sub_804E5E3(*(_DWORD *)(v4 + 16), *(char **)(a1 + 12), 3);\n  if ( result != *(_DWORD *)(v4 + 16) )\n    sub_807B34A(\"can't read from %s\");\n  *(_BYTE *)(a1 + 16) = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  *(_DWORD *)a1 = 0;\n  return result;\n}\n"
        ],
        "134722546": [
            "sub_807B3F2",
            "0x807b3f2",
            "void *__usercall sub_807B3F2@<eax>(void *result@<eax>)\n{\n  void *v1; // edx\n\n  if ( result )\n  {\n    v1 = result;\n    result = 0;\n    memset(v1, 0, 0x10u);\n  }\n  return result;\n}\n"
        ],
        "134722567": [
            "sub_807B407",
            "0x807b407",
            "void *__usercall sub_807B407@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // ebp\n  int v3; // esi\n  _BYTE *v4; // edi\n  int v5; // eax\n  _DWORD *v6; // edx\n  int v8; // ebp\n  _DWORD *v9; // eax\n  int v10; // edx\n  int v11; // edx\n  int v12; // edx\n  char *i; // eax\n  int v14; // [esp+0h] [ebp-14h]\n\n  v1 = a1;\n  v2 = dword_80DBB80;\n  v3 = dword_80DBB80 + 20 * a1;\n  v4 = *(_BYTE **)(v3 + 2252);\n  v14 = *(_DWORD *)(v3 + 2256);\n  v5 = sub_807B200();\n  v6 = (_DWORD *)v14;\n  if ( v5 )\n    return (void *)v14;\n  *(_BYTE *)(v3 + 2268) = 1;\n  if ( v1 > 3 )\n  {\n    if ( *(_BYTE *)(v14 + 4) || v1 == 4 )\n    {\n      if ( v1 == 4 )\n      {\n        if ( *(int *)(v2 + 8) > 5 )\n        {\n          v10 = *(_DWORD *)(v2 + 2352);\n          if ( v10 )\n            *(_DWORD *)(v10 + 8) = *(_DWORD *)(v10 + 8) - *(_DWORD *)(v2 + 80) + *(_DWORD *)(v2 + 2360);\n          *(_DWORD *)(v2 + 2360) = *(_DWORD *)(v2 + 80);\n          *(_BYTE *)(v2 + 2368) = 1;\n        }\n      }\n      else\n      {\n        v14 = v2 + 20 * (v1 - 1);\n        v9 = *(_DWORD **)(v14 + 2256);\n        qmemcpy(v9, v6, 0x10u);\n        v9[2] = v6[2];\n        v9[3] = v6[3];\n        *(_BYTE *)(v14 + 2268) = 1;\n      }\n      v11 = *(_DWORD *)(v2 + 8);\n      if ( v11 <= 5 )\n        return sub_807B3F2(*(void **)(v2 + 20 * v1 + 2252));\n      v12 = v11 - 1;\n      *(_DWORD *)(v2 + 8) = v12;\n      for ( i = (char *)(v2 + 20 * v1 + 2252); ; qmemcpy(i - 20, i, 0x14u) )\n      {\n        i += 20;\n        if ( v12 <= v1 )\n          break;\n        ++v1;\n      }\n    }\n    else\n    {\n      --*(_DWORD *)(v2 + 8);\n      v8 = 20 * (v1 - 1) + v2;\n      sub_807B3F2(*(void **)(v8 + 2256));\n      *(_BYTE *)(v8 + 2268) = 1;\n    }\n    return (void *)v14;\n  }\n  if ( ((v4[4] & 0x7F) == 5 || v4[4] == 15) && *(_DWORD *)(v2 + 48) == v1 )\n  {\n    *(_DWORD *)(v2 + 8) = 4;\n    *(_DWORD *)(v2 + 20 * v1 + 2256) = 0;\n    *(_DWORD *)(v2 + 80) = 0;\n  }\n  return sub_807B3F2(v4);\n}\n"
        ],
        "134722906": [
            "sub_807B55A",
            "0x807b55a",
            "int sub_807B55A()\n{\n  int *v0; // ebx\n  int v1; // esi\n  int v2; // eax\n  int v3; // eax\n  int result; // eax\n\n  v0 = (int *)dword_80DBB80;\n  v1 = dword_80DBB80 + 124;\n  v2 = sub_80AED5C(80);\n  if ( v2 <= 0 )\n    exit(0);\n  v3 = v2 - 1;\n  if ( *((_BYTE *)v0 + v3 + 124) == 10 )\n    *((_BYTE *)v0 + v3 + 124) = 0;\n  for ( *v0 = v1; ; ++*v0 )\n  {\n    result = *(unsigned __int8 *)*v0;\n    if ( (unsigned __int8)(result - 1) > 0x1Fu )\n      break;\n  }\n  return result;\n}\n"
        ],
        "134722977": [
            "sub_807B5A1",
            "0x807b5a1",
            "char sub_807B5A1()\n{\n  while ( !sub_807B55A() )\n    ;\n  return **(_BYTE **)dword_80DBB80;\n}\n"
        ],
        "134723002": [
            "sub_807B5BA",
            "0x807b5ba",
            "char *__usercall sub_807B5BA@<eax>(int a1@<eax>, int a2@<edx>, __int16 a3@<cx>)\n{\n  int v6; // edx\n  int v7; // ecx\n  char *v8; // edi\n\n  sub_804DB2E(0x24u);\n  v8 = (char *)sub_80A9707(v7, v6);\n  sprintf(v8, \"%u,%u,%u\", a1 | (4 * a3) & 0x300, a2, a3 & 0x3F);\n  return v8;\n}\n"
        ],
        "134723072": [
            "sub_807B600",
            "0x807b600",
            "void __noreturn sub_807B600()\n{\n  int v0; // ebx\n  int v1; // eax\n  int v2; // esi\n  int i; // edi\n  void *v4; // ebp\n\n  v0 = dword_80DBB80;\n  if ( !*(_BYTE *)(dword_80DBB80 + 40) )\n  {\n    if ( *(_BYTE *)(dword_80DBB80 + 2268) )\n      *(_BYTE *)(dword_80DBB80 + 2328) = 1;\n    if ( *(_BYTE *)(v0 + 2288) )\n      *(_BYTE *)(v0 + 2328) = 1;\n    if ( *(_BYTE *)(v0 + 2308) )\n      *(_BYTE *)(v0 + 2328) = 1;\n    v2 = v0 + 2320;\n    for ( i = 3; *(_DWORD *)(v0 + 8) > i; ++i )\n    {\n      if ( *(_BYTE *)(v2 + 8) )\n      {\n        *(_WORD *)(*(_DWORD *)(v2 + 4) + 510) = -21931;\n        v4 = *(void **)(v2 + 4);\n        sub_807B370(*(_DWORD *)v2);\n        sub_804DCAD(*(_DWORD *)(v0 + 16), v4);\n      }\n      v2 += 20;\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  puts(\"Calling ioctl() to re-read partition table\");\n  sync();\n  sleep(1u);\n  v1 = sub_804E062(3, 0x125Fu, 0, \"WARNING: rereading partition table failed, kernel still uses old table\");\n  exit(v1 != 0);\n}\n"
        ],
        "134723270": [
            "sub_807B6C6",
            "0x807b6c6",
            "int sub_807B6C6()\n{\n  int i; // ebx\n  unsigned int v1; // esi\n  int v2; // ebx\n  unsigned int v3; // eax\n  unsigned int v4; // edi\n  int v5; // edx\n  int v7[6]; // [esp+0h] [ebp-18h]\n\n  for ( i = 0; *(&off_80B6400 + i); ++i )\n    ;\n  v1 = (i + 2) / 3u;\n  v7[0] = v1;\n  v7[1] = v1 + ((i + 1 - v1) >> 1);\n  v7[2] = i;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  do\n  {\n    printf(\n      \"%c%2x %-22.22s\",\n      v2 == 0 ? 10 : 32,\n      *(unsigned __int8 *)*(&off_80B6400 + v3),\n      (const char *)*(&off_80B6400 + v3) + 1);\n    v5 = v2 + 1;\n    v3 = v4 + v7[v2];\n    if ( v2 + 1 <= 2 )\n    {\n      ++v2;\n      if ( v3 < v7[v5] )\n        continue;\n    }\n    v3 = ++v4;\n    v2 = 0;\n  }\n  while ( v4 < v1 );\n  return sub_804DD98(10);\n}\n"
        ],
        "134723418": [
            "sub_807B75A",
            "0x807b75a",
            "unsigned int __usercall sub_807B75A@<eax>(\n        unsigned int a1@<eax>,\n        unsigned int a2@<edx>,\n        unsigned int a3@<ecx>,\n        int a4,\n        int a5)\n{\n  int v6; // eax\n  int v7; // ebx\n  const char *v8; // eax\n  char v9; // cl\n  unsigned int v10; // eax\n  int i; // esi\n  int v12; // edx\n  char v13; // dl\n  unsigned __int8 v14; // dl\n  char v15; // cl\n  unsigned __int64 v16; // rax\n  __int64 v17; // rax\n  unsigned int v18; // ecx\n  unsigned int result; // eax\n  char v20; // [esp+3h] [ebp-21h]\n  int v21; // [esp+4h] [ebp-20h]\n  char *format; // [esp+10h] [ebp-14h]\n\n  if ( a2 <= a3 && a2 >= a1 )\n  {\n    format = \"%s (%u-%u, default %u): \";\n    v21 = 1;\n    goto LABEL_5;\n  }\n  format = \"%s (%u-%u): \";\n  v21 = 0;\n  printf(\"%s (%u-%u): \", a5, a1, a3);\n  while ( 1 )\n  {\n    v6 = sub_807B55A();\n    v7 = dword_80DBB80;\n    if ( !v6 )\n    {\n      *(_DWORD *)dword_80DBB80 = dword_80DBB80 + 124;\n      *(_WORD *)(v7 + 124) = 10;\n    }\n    v8 = *(const char **)v7;\n    v9 = **(_BYTE **)v7;\n    v20 = v9;\n    if ( v9 == 10 || (unsigned __int8)(v9 - 48) <= 9u )\n    {\n      result = strtoul(v8, 0, 10);\n      i = v21;\n      while ( (unsigned __int8)(**(_BYTE **)v7 - 48) <= 9u )\n      {\n        ++*(_DWORD *)v7;\n        i = 0;\n      }\n      goto LABEL_32;\n    }\n    if ( v9 == 45 || v9 == 43 )\n      break;\nLABEL_5:\n    printf(format, a5, a1, a3, a2);\n  }\n  v10 = strtoul(v8 + 1, 0, 10);\n  for ( i = v21; ; i = 0 )\n  {\n    v12 = (*(_DWORD *)v7)++;\n    v13 = *(_BYTE *)(v12 + 1);\n    if ( (unsigned __int8)(v13 - 48) > 9u )\n      break;\n  }\n  v14 = v13 | 0x20;\n  if ( v14 == 107 )\n  {\n    v15 = 10;\n    goto LABEL_24;\n  }\n  if ( v14 > 0x6Bu )\n  {\n    if ( v14 == 109 )\n    {\n      v15 = 20;\n    }\n    else\n    {\n      if ( v14 != 116 )\n        goto LABEL_26;\n      v15 = 40;\n    }\nLABEL_24:\n    v16 = ((unsigned int)(*(_DWORD *)(v7 + 12) * *(_DWORD *)(v7 + 16)) >> 1) + ((unsigned __int64)v10 << v15);\n    v17 = sub_80B4B88(v16, HIDWORD(v16), *(_DWORD *)(v7 + 12) * *(_DWORD *)(v7 + 16), 0);\n    v18 = v17;\n    v10 = 0;\n    if ( __PAIR64__(HIDWORD(v17), v18) )\n      v10 = v18 - 1;\n    goto LABEL_26;\n  }\n  if ( v14 == 103 )\n  {\n    v15 = 30;\n    goto LABEL_24;\n  }\nLABEL_26:\n  if ( v20 == 45 )\n    v10 = -v10;\n  result = a4 + v10;\nLABEL_32:\n  if ( i )\n  {\n    printf(\"Using default value %u\\n\", a2);\n    result = a2;\n  }\n  if ( result > a3 || result < a1 )\n  {\n    puts(\"Value is out of range\");\n    goto LABEL_5;\n  }\n  return result;\n}\n"
        ],
        "134723830": [
            "sub_807B8F6",
            "0x807b8f6",
            "unsigned int __usercall sub_807B8F6@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  unsigned int v3; // eax\n  unsigned int v4; // ebx\n\n  v3 = sub_807B75A(1u, 0, a2, 0, (int)\"Partition number\");\n  v4 = v3 - 1;\n  if ( a1 && !*(_BYTE *)(*(_DWORD *)(dword_80DBB80 + 20 * v4 + 2252) + 4) )\n    printf(\"Warning: partition %u has empty type\\n\", v3);\n  return v4;\n}\n"
        ],
        "134723904": [
            "sub_807B940",
            "0x807b940",
            "unsigned int __usercall sub_807B940@<eax>(int a1@<eax>, unsigned int a2@<edx>)\n{\n  int v3; // esi\n  int v4; // ebx\n  int v5; // eax\n  _BOOL4 v6; // eax\n  unsigned int v8; // [esp+0h] [ebp-10h]\n\n  v3 = 0;\n  v4 = -1;\n  while ( v3 != a2 )\n  {\n    v5 = *(_DWORD *)(dword_80DBB80 + 20 * v3 + 2252);\n    if ( v5 )\n    {\n      v8 = a2;\n      v6 = sub_807AF4F(v5);\n      a2 = v8;\n      if ( !v6 )\n      {\n        if ( v4 >= 0 )\n          return sub_807B8F6(a1, v8);\n        v4 = v3;\n      }\n    }\n    ++v3;\n  }\n  if ( v4 < 0 )\n  {\n    puts(\"No partition is defined yet!\");\n    return -1;\n  }\n  else\n  {\n    printf(\"Selected partition %u\\n\", v4 + 1);\n  }\n  return v4;\n}\n"
        ],
        "134724019": [
            "sub_807B9B3",
            "0x807b9b3",
            "unsigned int sub_807B9B3()\n{\n  int v0; // ebx\n  int i; // esi\n  int v2; // eax\n\n  v0 = -1;\n  for ( i = 0; i != 4; ++i )\n  {\n    v2 = *(_DWORD *)(dword_80DBB80 + 20 * i + 2252);\n    if ( v2 && sub_807AF4F(v2) )\n    {\n      if ( v0 != -1 )\n        return sub_807B8F6(0, 4u);\n      v0 = i;\n    }\n  }\n  if ( v0 == -1 )\n    puts(\"All primary partitions have been defined already!\");\n  else\n    printf(\"Selected partition %u\\n\", v0 + 1);\n  return v0;\n}\n"
        ],
        "134724121": [
            "sub_807BA19",
            "0x807ba19",
            "char __usercall sub_807BA19@<al>(unsigned int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // edi\n  unsigned int v4; // ebp\n  unsigned int v5; // ebx\n  __int16 v6; // dx\n  unsigned int v7; // edi\n  unsigned int v8; // edx\n  int v9; // ecx\n  unsigned int v10; // edx\n  unsigned int v11; // edi\n  unsigned int v12; // ebx\n  int v14; // [esp+0h] [ebp-3Ch]\n  int v15; // [esp+4h] [ebp-38h]\n  int v16; // [esp+8h] [ebp-34h]\n  int v17; // [esp+Ch] [ebp-30h]\n  int v18; // [esp+10h] [ebp-2Ch]\n  int v19; // [esp+14h] [ebp-28h]\n  int v20; // [esp+18h] [ebp-24h]\n  int v21; // [esp+1Ch] [ebp-20h]\n  int v22; // [esp+20h] [ebp-1Ch]\n  unsigned int v23; // [esp+24h] [ebp-18h]\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 + 28);\n  if ( v3 )\n  {\n    v4 = *(_DWORD *)(dword_80DBB80 + 32);\n    if ( a2 <= 3 )\n    {\n      if ( v4 )\n      {\n        v5 = a1;\n        LOBYTE(a1) = *(_BYTE *)(a1 + 2);\n        v14 = *(unsigned __int8 *)(v5 + 3) | (4 * (_WORD)a1) & 0x300;\n        HIBYTE(v6) = (unsigned __int16)((4 * a1) & 0x300) >> 8;\n        v15 = *(unsigned __int8 *)(v5 + 1);\n        v16 = a1 & 0x3F;\n        LOBYTE(v6) = *(_BYTE *)(v5 + 6);\n        v17 = *(unsigned __int8 *)(v5 + 7) | (4 * v6) & 0x300;\n        v18 = *(unsigned __int8 *)(v5 + 5);\n        v19 = v6 & 0x3F;\n        v7 = v4 * v3;\n        v8 = *(_DWORD *)(v5 + 8) % v7;\n        v21 = *(_DWORD *)(v5 + 8) / v7;\n        v22 = v8 / v4;\n        v20 = v8 % v4 + 1;\n        v9 = *(_DWORD *)(v5 + 12) + *(_DWORD *)(v5 + 8);\n        v23 = (v9 - 1) / v7;\n        a1 = (v9 - 1) % v7 / v4;\n        v10 = (v9 - 1) % v7 % v4;\n        v11 = a1;\n        v12 = v10 + 1;\n        if ( *(_DWORD *)(dword_80DBB80 + 36) <= 0x400u )\n        {\n          LOBYTE(a1) = v16 != v20;\n          if ( v16 != v20 || v15 != v22 || v14 != v21 )\n          {\n            printf(\"Partition %u has different physical/logical start (non-Linux?):\\n\", a2 + 1);\n            printf(\"     phys=(%u,%u,%u) \", v14, v15, v16);\n            LOBYTE(a1) = printf(\"logical=(%u,%u,%u)\\n\", v21, v22, v20);\n          }\n        }\n        if ( *(_DWORD *)(v2 + 36) <= 0x400u )\n        {\n          LOBYTE(a1) = v17 != v23;\n          if ( v17 != v23 || v19 != v12 || v18 != v11 )\n          {\n            printf(\"Partition %u has different physical/logical end:\\n\", a2 + 1);\n            printf(\"     phys=(%u,%u,%u) \", v17, v18, v19);\n            LOBYTE(a1) = printf(\"logical=(%u,%u,%u)\\n\", v23, v11, v12);\n          }\n        }\n      }\n    }\n  }\n  return a1;\n}\n"
        ],
        "134724520": [
            "sub_807BBA8",
            "0x807bba8",
            "char __usercall sub_807BBA8@<al>(int a1@<eax>)\n{\n  int v1; // esi\n  char result; // al\n  __int16 v3; // dx\n  __int16 v4; // cx\n  unsigned __int8 **v5; // ebp\n  int i; // edi\n  unsigned __int8 *v7; // ebx\n\n  v1 = dword_80DBB80;\n  printf(\n    \"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n    *(const char **)(dword_80DBB80 + 4),\n    *(_DWORD *)(dword_80DBB80 + 28),\n    *(_DWORD *)(dword_80DBB80 + 32),\n    *(_DWORD *)(dword_80DBB80 + 36));\n  result = puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n  v5 = (unsigned __int8 **)(v1 + 2252);\n  for ( i = 0; *(_DWORD *)(v1 + 8) > i; ++i )\n  {\n    if ( a1 )\n      v7 = v5[1];\n    else\n      v7 = *v5;\n    result = i + 1;\n    if ( v7 )\n    {\n      LOBYTE(v3) = v7[6];\n      LOBYTE(v4) = v7[2];\n      result = printf(\n                 \"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n                 i + 1,\n                 *v7,\n                 v7[1],\n                 v4 & 0x3F,\n                 v7[3] | (4 * v4) & 0x300,\n                 v7[5],\n                 v3 & 0x3F,\n                 (4 * v3) & 0x300 | v7[7],\n                 *((_DWORD *)v7 + 2),\n                 *((_DWORD *)v7 + 3),\n                 v7[4]);\n      if ( v7[4] )\n        result = sub_807BA19((unsigned int)v7, i);\n    }\n    v5 += 5;\n  }\n  return result;\n}\n"
        ],
        "134724750": [
            "sub_807BC8E",
            "0x807bc8e",
            "int sub_807BC8E()\n{\n  _DWORD *v0; // ebx\n  int v1; // eax\n  void *v2; // esp\n  void *v3; // esp\n  int result; // eax\n  unsigned __int8 *v5; // edi\n  unsigned __int8 v6; // al\n  int v7; // esi\n  unsigned __int8 v8; // al\n  unsigned int v9; // edx\n  unsigned int v10; // edi\n  int i; // edi\n  unsigned int v12; // edx\n  unsigned int v13; // ecx\n  unsigned int v14; // eax\n  unsigned int v15; // edx\n  unsigned int v16; // eax\n  unsigned int v17; // eax\n  unsigned int v18; // edx\n  int v19; // eax\n  unsigned int v20; // esi\n  int v21; // edi\n  int v22; // eax\n  int v23; // edx\n  unsigned int v24; // eax\n  int v25; // [esp-8h] [ebp-40h]\n  int v26[2]; // [esp+0h] [ebp-38h] BYREF\n  unsigned int v27; // [esp+8h] [ebp-30h]\n  unsigned int v28; // [esp+Ch] [ebp-2Ch]\n  int v29; // [esp+10h] [ebp-28h]\n  int v30; // [esp+14h] [ebp-24h]\n  unsigned __int8 **v31; // [esp+18h] [ebp-20h]\n  int v32; // [esp+1Ch] [ebp-1Ch]\n  int *v33; // [esp+20h] [ebp-18h]\n  int *v34; // [esp+24h] [ebp-14h]\n  unsigned int v35; // [esp+28h] [ebp-10h]\n\n  v26[1] = (int)v26;\n  v0 = (_DWORD *)dword_80DBB80;\n  v1 = 4 * *(_DWORD *)(dword_80DBB80 + 8) + 4;\n  v2 = alloca(v1);\n  v34 = v26;\n  v3 = alloca(v1);\n  v33 = v26;\n  result = sub_807B200();\n  if ( !result )\n  {\n    sub_807B080((int)v34, (int)v33);\n    v31 = (unsigned __int8 **)(v0 + 563);\n    v32 = 0;\n    v35 = 1;\n    while ( v32 < v0[2] )\n    {\n      v5 = *v31;\n      v6 = (*v31)[4];\n      v7 = v32 + 1;\n      if ( v6 != 0 && v6 != 15 && (v6 & 0x7F) != 5 )\n      {\n        sub_807BA19((unsigned int)v5, v32);\n        if ( v34[v7 - 1] > (unsigned int)&v31[2][*((_DWORD *)*v31 + 2)] )\n          printf(\"Warning: bad start-of-data in partition %u\\n\", v7);\n        v30 = v33[v7 - 1];\n        v8 = v5[6];\n        v29 = v8;\n        v9 = v5[5];\n        v28 = (v8 & 0x3F) - 1;\n        v10 = v5[7] | (4 * v8) & 0x300;\n        v27 = v9 + v0[7] * (v28 + v0[8] * v10);\n        if ( !v27 )\n        {\n          v26[0] = v9;\n          printf(\"Partition %u contains sector 0\\n\", v7);\n          v9 = v26[0];\n        }\n        if ( v9 >= v0[7] )\n          printf(\"Partition %u: head %u greater than maximum %u\\n\", v7, v9 + 1, v0[7]);\n        if ( v28 >= v0[8] )\n          printf(\"Partition %u: sector %u greater than maximum %u\\n\", v7, v29, v0[8]);\n        if ( v10 >= v0[9] )\n          printf(\"Partition %u: cylinder %u greater than maximum %u\\n\", v7, v10 + 1, v0[9]);\n        if ( v0[9] <= 0x400u && v30 != v27 )\n          printf(\"Partition %u: previous sectors %u disagrees with total %u\\n\", v7, v30, v27);\n        v35 = v35 + v33[v7 - 1] + 1 - v34[v7 - 1];\n        for ( i = 0; i != v32; ++i )\n        {\n          v12 = v34[v7 - 1];\n          v13 = v34[i];\n          v14 = v33[i];\n          if ( v12 < v13 || v12 > v14 )\n          {\n            v15 = v33[v7 - 1];\n            if ( v13 > v15 || v15 > v14 )\n              continue;\n          }\n          printf(\"Warning: partition %u overlaps partition %u\\n\", i + 1, v7);\n          v16 = v34[v7 - 1];\n          if ( v16 < v34[i] )\n            v16 = v34[i];\n          v17 = v35 + v16;\n          v18 = v33[v7 - 1];\n          if ( v18 > v33[i] )\n            v18 = v33[i];\n          v35 = v17 - v18;\n        }\n      }\n      v31 += 5;\n      v32 = v7;\n    }\n    if ( v0[20] )\n    {\n      v19 = v0[5 * v0[12] + 563];\n      v20 = *(_DWORD *)(v19 + 12) + *(_DWORD *)(v19 + 8) - 1;\n      v21 = 4;\n      while ( 1 )\n      {\n        v22 = v0[2];\n        if ( v21 >= v22 )\n          break;\n        ++v35;\n        v23 = v0[5 * v21++ + 563];\n        if ( *(_BYTE *)(v23 + 4) )\n        {\n          if ( (unsigned int)v34[v21 - 1] < v0[20] || v33[v21 - 1] > v20 )\n            printf(\"Logical partition %u not entirely in partition %u\\n\", v21, v0[12] + 1);\n        }\n        else if ( v22 > 5 || v21 != 5 )\n        {\n          printf(\"Warning: partition %u is empty\\n\", v21);\n        }\n      }\n    }\n    v24 = v0[9] * v0[8] * v0[7];\n    if ( v35 <= v24 )\n    {\n      result = v24 - v35;\n      if ( result )\n      {\n        printf(\"%u unallocated sectors\\n\", result);\n        return v25;\n      }\n    }\n    else\n    {\n      return printf(\"Total allocated sectors %u greater than CHS size %u\\n\", v35, v0[9] * v0[8] * v0[7]);\n    }\n  }\n  return result;\n}\n"
        ],
        "134725462": [
            "sub_807BF56",
            "0x807bf56",
            "char sub_807BF56()\n{\n  int v0; // esi\n  int v1; // eax\n  unsigned int v2; // edi\n  int v3; // ebx\n  int v4; // ebx\n  int i; // eax\n  __int16 v6; // dx\n  const char *v7; // ebx\n  signed int v8; // eax\n  int v9; // esi\n  int j; // ebp\n  int v11; // edi\n  unsigned __int8 *v12; // ebx\n  const char *v13; // edi\n  int v14; // edx\n  int v15; // ecx\n  size_t v16; // eax\n  char *v17; // edx\n  int v18; // eax\n  const char *v19; // edx\n  size_t v20; // eax\n  char v22; // [esp-4h] [ebp-74h]\n  char v23; // [esp-4h] [ebp-74h]\n  int v24; // [esp+0h] [ebp-70h]\n  int v25; // [esp+8h] [ebp-68h]\n  int v26; // [esp+Ch] [ebp-64h]\n  int v27; // [esp+10h] [ebp-60h]\n  char *v28; // [esp+14h] [ebp-5Ch]\n  size_t v29; // [esp+18h] [ebp-58h]\n  const char *v30; // [esp+20h] [ebp-50h]\n  char *v31; // [esp+24h] [ebp-4Ch]\n  char *v32; // [esp+28h] [ebp-48h]\n  size_t v33; // [esp+2Ch] [ebp-44h]\n  const char *v34; // [esp+2Ch] [ebp-44h]\n  char *v35; // [esp+30h] [ebp-40h]\n  char s[6]; // [esp+35h] [ebp-3Bh] BYREF\n  char v37[53]; // [esp+3Bh] [ebp-35h] BYREF\n\n  v0 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 + 40) == 5 )\n  {\n    *(_BYTE *)sub_80AD152(\" KMGTPEZY\") = 0;\n    printf(\"Disk %s: %llu sectors, %s\\n\", *(const char **)(v0 + 4), (unsigned __int64)*(unsigned int *)(v0 + 84), s);\n    printf(\"Logical sector size: %u\\n\", *(_DWORD *)(v0 + 16));\n    printf(\"Disk identifier (GUID): \");\n    printf(\n      \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n      *(unsigned __int8 *)(dword_80DB71C + 59),\n      *(unsigned __int8 *)(dword_80DB71C + 58),\n      *(unsigned __int8 *)(dword_80DB71C + 57),\n      *(unsigned __int8 *)(dword_80DB71C + 56),\n      *(unsigned __int8 *)(dword_80DB71C + 61),\n      *(unsigned __int8 *)(dword_80DB71C + 60),\n      *(unsigned __int8 *)(dword_80DB71C + 63),\n      *(unsigned __int8 *)(dword_80DB71C + 62),\n      *(unsigned __int8 *)(dword_80DB71C + 64),\n      *(unsigned __int8 *)(dword_80DB71C + 65),\n      *(unsigned __int8 *)(dword_80DB71C + 66),\n      *(unsigned __int8 *)(dword_80DB71C + 67),\n      *(unsigned __int8 *)(dword_80DB71C + 68),\n      *(unsigned __int8 *)(dword_80DB71C + 69),\n      *(unsigned __int8 *)(dword_80DB71C + 70),\n      *(unsigned __int8 *)(dword_80DB71C + 71));\n    printf(\"\\nPartition table holds up to %u entries\\n\", *(_DWORD *)(dword_80DB71C + 80));\n    printf(\n      \"First usable sector is %llu, last usable sector is %llu\\n\\n\",\n      *(_QWORD *)(dword_80DB71C + 40),\n      *(_QWORD *)(dword_80DB71C + 48));\n    LOBYTE(v1) = puts(\"Number  Start (sector)    End (sector)  Size Name\");\n    v2 = 0;\n    while ( v2 < dword_80DB714 )\n    {\n      v3 = dword_80DB718 + v2 * dword_80DB710;\n      ++v2;\n      LOBYTE(v1) = *(_DWORD *)(v3 + 32) | *(_DWORD *)(v3 + 36);\n      if ( *(_QWORD *)(v3 + 32) )\n      {\n        *(_BYTE *)sub_80AD152(\" KMGTPEZY\") = 0;\n        printf(\"%6u %15llu %15llu %s \", v2, *(_QWORD *)(v3 + 32), *(_QWORD *)(v3 + 40), s);\n        v4 = v3 + 56;\n        for ( i = 0; i != 36; ++i )\n        {\n          v6 = *(_WORD *)(v4 + 2 * i);\n          if ( !v6 )\n            break;\n          if ( (unsigned __int16)(v6 - 32) > 0x5Eu )\n            LOBYTE(v6) = 63;\n          v37[i] = v6;\n        }\n        v37[i] = 0;\n        fputs_unlocked(v37, stdout);\n        sub_804DD98(10);\n        LOBYTE(v1) = v22;\n      }\n    }\n  }\n  else\n  {\n    sub_807B112();\n    v7 = *(const char **)(v0 + 4);\n    v8 = strlen(v7);\n    v9 = 7;\n    if ( v8 )\n    {\n      if ( (unsigned __int8)(v7[v8 - 1] - 48) <= 9u )\n        ++v8;\n      v9 = v8;\n      if ( v8 < 7 )\n        v9 = 7;\n    }\n    LOBYTE(v1) = printf(\n                   \"%-*s Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\\n\",\n                   v9 - 1,\n                   \"Device\");\n    for ( j = 0; ; ++j )\n    {\n      v11 = dword_80DBB80;\n      if ( j >= *(_DWORD *)(dword_80DBB80 + 8) )\n        break;\n      LOBYTE(v1) = 20 * j;\n      v12 = *(unsigned __int8 **)(dword_80DBB80 + 20 * j + 2252);\n      if ( v12 )\n      {\n        v1 = sub_807AF4F(*(_DWORD *)(dword_80DBB80 + 20 * j + 2252));\n        if ( !v1 )\n        {\n          sprintf(s, \"%02x\", *v12);\n          if ( (*v12 & 0x7F) == 0 )\n          {\n            s[0] = *v12 == 0 ? 32 : 42;\n            s[1] = 32;\n          }\n          v25 = *(_DWORD *)(*(_DWORD *)(v11 + 20 * j + 2252) + 8) + *(_DWORD *)(v11 + 20 * j + 2260);\n          v24 = *((_DWORD *)v12 + 3);\n          v27 = v25;\n          if ( v24 )\n            v27 = v25 + v24 - 1;\n          *(_BYTE *)sub_80AD152(\" KMGTPEZY\") = 0;\n          v26 = v12[4];\n          v30 = sub_807AF33(v12[4]);\n          v31 = sub_807B5BA(v12[7], v12[5], v12[6]);\n          v32 = sub_807B5BA(v12[3], v12[1], v12[2]);\n          v13 = *(const char **)(v11 + 4);\n          sub_804DB2E(0x50u);\n          v28 = (char *)sub_80A9707(v15, v14);\n          v16 = strlen(v13);\n          v29 = v16;\n          v17 = \"p\";\n          if ( (unsigned __int8)(v13[v16 - 1] - 48) > 9u )\n            v17 = (char *)&data;\n          v35 = v17;\n          v33 = v16 - 4;\n          v18 = strcmp(&v13[v16 - 4], \"disc\");\n          v19 = v35;\n          if ( !v18 )\n          {\n            v29 = v33;\n            v19 = \"part\";\n          }\n          v34 = v19;\n          v20 = strlen(v19);\n          snprintf(v28, 0x50u, \"%*.*s%s%-2u\", v9 - v20, v29, v13, v34, j + 1);\n          printf(\"%s%s %-11s %-11s %10u %10u %10u %s %2x %s\\n\", v28, s, v32, v31, v25, v27, v24, v37, v26, v30);\n          LOBYTE(v1) = sub_807BA19((unsigned int)v12, j);\n        }\n      }\n    }\n    if ( !*(_BYTE *)(dword_80DBB80 + 40) )\n    {\n      v1 = sub_807B02A(0);\n      if ( v1 )\n      {\n        puts(\"\\nPartition table entries are not in disk order\");\n        LOBYTE(v1) = v23;\n      }\n    }\n  }\n  return v1;\n}\n"
        ],
        "134726513": [
            "sub_807C371",
            "0x807c371",
            "int __usercall sub_807C371@<eax>(int a1@<eax>)\n{\n  int v1; // ebp\n  int v2; // edx\n  int v3; // eax\n  int v4; // esi\n  char *v5; // eax\n  int v6; // eax\n  int v7; // eax\n  unsigned int v8; // eax\n  int v9; // ecx\n  unsigned int v10; // eax\n  int v11; // ebx\n  unsigned int v12; // ebx\n  unsigned int v13; // eax\n  size_t v14; // ebx\n  char *v15; // esi\n  int v16; // eax\n  int v17; // edi\n  int v18; // ebx\n  int v19; // esi\n  __int64 v20; // rax\n  int result; // eax\n  int v22; // eax\n  char v23; // dl\n  _DWORD *v24; // ebx\n  _DWORD *v25; // eax\n  int v26; // edx\n  int v27; // edi\n  int v28; // edi\n  _DWORD *v29; // eax\n  _DWORD *v30; // eax\n  int v31; // esi\n  _DWORD *v32; // ebx\n  char v33; // dl\n  int v34; // eax\n  int i; // esi\n  _BYTE *v36; // esi\n  int v37; // eax\n  int v38; // edx\n  int v39; // ecx\n  int v40; // ebx\n  int v42; // [esp+0h] [ebp-3Ch]\n  int v43; // [esp+4h] [ebp-38h]\n  int v44; // [esp+4h] [ebp-38h]\n  int v45; // [esp+8h] [ebp-34h]\n  int v46; // [esp+8h] [ebp-34h]\n  int v47; // [esp+Ch] [ebp-30h]\n  unsigned int v48; // [esp+14h] [ebp-28h] BYREF\n  unsigned __int64 v49; // [esp+18h] [ebp-24h] BYREF\n  _DWORD *v50; // [esp+24h] [ebp-18h]\n\n  v1 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 8) = 4;\n  v2 = v1 + 650;\n  v3 = v1 + 2252;\n  do\n  {\n    *(_DWORD *)v3 = v2;\n    *(_DWORD *)(v3 + 4) = 0;\n    *(_DWORD *)(v3 + 8) = 0;\n    *(_DWORD *)(v3 + 12) = v1 + 204;\n    *(_BYTE *)(v3 + 16) = a1 == 2;\n    v2 += 16;\n    v3 += 20;\n  }\n  while ( v1 + 2332 != v3 );\n  if ( a1 == 2 )\n    goto LABEL_76;\n  v4 = open64(*(_DWORD *)(v1 + 4));\n  if ( v4 < 0 )\n  {\n    v4 = open64(*(_DWORD *)(v1 + 4));\n    if ( v4 < 0 )\n    {\n      v5 = \"can't open '%s'\";\n      if ( a1 == 1 )\n        return 1;\nLABEL_40:\n      sub_807B34A(v5);\n    }\n    printf(\"'%s' is opened for read only\\n\", *(const char **)(v1 + 4));\n  }\n  sub_804DC97(v4, 3);\n  if ( sub_804E5E3(0x200u, (char *)(v1 + 204), 3) == 512 )\n  {\n    if ( !*(_DWORD *)(v1 + 20) )\n    {\n      if ( !ioctl(3, 0x1268u, &v49) )\n        *(_DWORD *)(v1 + 16) = v49;\n      if ( *(_DWORD *)(v1 + 16) != 512 )\n        printf(\"Note: sector size is %u (not 512)\\n\", *(_DWORD *)(v1 + 16));\n    }\n    v45 = *(_DWORD *)(v1 + 16) >> 9;\n    *(_DWORD *)(v1 + 32) = 0;\n    *(_DWORD *)(v1 + 36) = 0;\n    *(_DWORD *)(v1 + 28) = 0;\n    *(_DWORD *)(v1 + 76) = 0;\n    *(_DWORD *)(v1 + 72) = 0;\n    *(_DWORD *)(v1 + 68) = 0;\n    *(_DWORD *)(v1 + 64) = 0;\n    if ( !ioctl(3, 0x301u, &v49) )\n    {\n      *(_DWORD *)(v1 + 72) = (unsigned __int8)v49;\n      *(_DWORD *)(v1 + 76) = BYTE1(v49);\n    }\n    if ( *(_BYTE *)(v1 + 714) == 85 && *(_BYTE *)(v1 + 715) == 0xAA )\n    {\n      v16 = 0;\n      v43 = 0;\n      v17 = 0;\n      v18 = 0;\n      v19 = 1;\n      do\n      {\n        if ( *(_BYTE *)(v1 + v16 + 654) )\n        {\n          if ( v19 )\n          {\n            v17 = *(_BYTE *)(v1 + v16 + 656) & 0x3F;\n            v18 = *(unsigned __int8 *)(v1 + v16 + 655) + 1;\n            v19 = 0;\n          }\n          else if ( (*(_BYTE *)(v1 + v16 + 656) & 0x3F) != v17 || *(unsigned __int8 *)(v1 + v16 + 655) + 1 != v18 )\n          {\n            v43 = 1;\n          }\n        }\n        v16 += 16;\n      }\n      while ( v16 != 64 );\n      if ( !(v19 | v43) )\n      {\n        *(_DWORD *)(v1 + 64) = v18;\n        *(_DWORD *)(v1 + 68) = v17;\n      }\n    }\n    v6 = *(_DWORD *)(v1 + 56);\n    if ( !v6 )\n    {\n      v6 = *(_DWORD *)(v1 + 64);\n      if ( !v6 )\n      {\n        v6 = *(_DWORD *)(v1 + 72);\n        if ( !v6 )\n          v6 = 255;\n      }\n    }\n    *(_DWORD *)(v1 + 28) = v6;\n    v7 = *(_DWORD *)(v1 + 60);\n    if ( !v7 )\n    {\n      v7 = *(_DWORD *)(v1 + 68);\n      if ( !v7 )\n      {\n        v7 = *(_DWORD *)(v1 + 76);\n        if ( !v7 )\n          v7 = 63;\n      }\n    }\n    *(_DWORD *)(v1 + 32) = v7;\n    if ( ioctl(3, 0x80041272, &v49) )\n    {\n      if ( ioctl(3, 0x1260u, &v48) )\n      {\n        LODWORD(v20) = lseek64(3, 0, 0, 2);\n        v48 = 0;\n        if ( v20 > 0 )\n          v48 = sub_80B4B88(v20, HIDWORD(v20), *(_DWORD *)(v1 + 16), 0);\n        lseek64(3, 0, 0, 0);\n      }\n      v8 = v48;\n    }\n    else\n    {\n      v49 >>= 9;\n      if ( HIDWORD(v49) )\n      {\n        sub_804D5F4(\"device has more than 2^32 sectors, can't use all of them\");\n        v49 = 0xFFFFFFFFLL;\n      }\n      v8 = v49;\n    }\n    *(_DWORD *)(v1 + 84) = v8;\n    *(_DWORD *)(v1 + 24) = 1;\n    v9 = *(_DWORD *)(v1 + 32);\n    if ( *(_BYTE *)(v1 + 43) )\n      *(_DWORD *)(v1 + 24) = v9;\n    v10 = v8 / (v45 * *(_DWORD *)(v1 + 28) * v9);\n    *(_DWORD *)(v1 + 36) = v10;\n    if ( !v10 )\n      *(_DWORD *)(v1 + 36) = *(_DWORD *)(v1 + 52);\n    sub_807B008();\n    if ( *(_BYTE *)(v1 + 714) == 85\n      && *(_BYTE *)(v1 + 715) == 0xAA\n      && *(_BYTE *)(v1 + 654) == 0xEE\n      && (sub_807B39C((int)&v49, 1u), dword_80DB71C = (int)v50, v50[1] == 1414676816)\n      && *v50 == 541673029 )\n    {\n      if ( !dword_80DBB98 )\n        sub_80AA3E8();\n      v11 = *(_DWORD *)(dword_80DB71C + 16);\n      *(_DWORD *)(dword_80DB71C + 16) = 0;\n      if ( v11 != ~sub_80AA41E(dword_80DBB98) )\n        puts(\"\\nwarning: GPT header CRC is invalid\\n\");\n      v12 = *(_DWORD *)(dword_80DB71C + 80);\n      dword_80DB714 = v12;\n      v13 = *(_DWORD *)(dword_80DB71C + 84);\n      dword_80DB710 = v13;\n      if ( v12 <= 0x100 && v13 <= 0x1000 && *(_DWORD *)(dword_80DB71C + 12) <= *(_DWORD *)(v1 + 16) )\n      {\n        v14 = v13 * v12;\n        v15 = (char *)sub_804DAFA(v14);\n        dword_80DB718 = (int)v15;\n        sub_807B370(*(_DWORD *)(dword_80DB71C + 72));\n        if ( v14 != sub_804E5E3(v14, v15, 3) )\n          goto LABEL_39;\n        if ( *(_DWORD *)(dword_80DB71C + 88) != ~sub_80AA41E(dword_80DBB98) )\n          puts(\"\\nwarning: GPT array CRC is invalid\\n\");\n        puts(\"Found valid GPT with protective MBR; using GPT\\n\");\n        *(_BYTE *)(v1 + 40) = 5;\n        return 0;\n      }\n      puts(\"\\nwarning: unable to parse GPT disklabel\\n\");\n      *(_BYTE *)(v1 + 40) = 0;\n    }\n    else\n    {\n      *(_BYTE *)(v1 + 40) = 0;\n    }\n    if ( *(_BYTE *)(v1 + 714) != 85 || *(_BYTE *)(v1 + 715) != 0xAA )\n    {\n      result = -1;\n      if ( a1 )\n        return result;\n      puts(\"Device contains neither a valid DOS partition table, nor Sun, SGI, OSF or GPT disklabel\");\n      sub_807CB4E();\n      return 0;\n    }\nLABEL_76:\n    sub_807B1D6();\n    sub_807B200();\n    v22 = 0;\n    do\n    {\n      v23 = *(_BYTE *)(*(_DWORD *)(v1 + 20 * v22 + 2252) + 4);\n      v46 = v22 + 1;\n      if ( (v23 & 0x7F) == 5 || v23 == 15 )\n      {\n        if ( *(_DWORD *)(v1 + 8) == 4 )\n        {\n          v24 = (_DWORD *)dword_80DBB80;\n          *(_DWORD *)(dword_80DBB80 + 48) = v22;\n          v25 = &v24[5 * v22];\n          v26 = v25[563];\n          v25[564] = v26;\n          v27 = v26;\n          if ( *(_DWORD *)(v26 + 8) )\n          {\n            while ( 1 )\n            {\n              v31 = v24[2];\n              if ( (*(_BYTE *)(v27 + 4) & 0x7F) != 5 && *(_BYTE *)(v27 + 4) != 15 )\n                break;\n              if ( v31 > 59 )\n              {\n                printf(\"Warning: deleting partitions after %u\\n\", v24[2]);\n                v32 = &v24[5 * v31 - 5];\n                *((_BYTE *)v32 + 2268) = 1;\n                sub_807B3F2((void *)v32[564]);\n                goto LABEL_117;\n              }\n              sub_807B39C((int)&v24[5 * v31 + 563], v24[20] + *(_DWORD *)(v27 + 8));\n              if ( !v24[20] )\n                v24[20] = *(_DWORD *)(v27 + 8);\n              v44 = v24[5 * v31 + 566];\n              v42 = v44 + 446;\n              v28 = v44 + 446;\n              v47 = 5 * v31;\n              do\n              {\n                if ( *(_DWORD *)(v28 + 12) )\n                {\n                  v33 = *(_BYTE *)(v28 + 4);\n                  if ( (v33 & 0x7F) == 5 || v33 == 15 )\n                  {\n                    if ( v24[v47 + 564] )\n                      printf(\"Warning: extra link pointer in partition table %u\\n\");\n                    else\n                      v24[v47 + 564] = v28;\n                  }\n                  else if ( v33 )\n                  {\n                    if ( v24[v47 + 563] )\n                      printf(\"Warning: ignoring extra data in partition table %u\\n\");\n                    else\n                      v24[v47 + 563] = v28;\n                  }\n                }\n                v28 += 16;\n              }\n              while ( v28 != v44 + 510 );\n              v29 = &v24[5 * v31];\n              if ( !v29[563] )\n              {\n                if ( v29[564] == v42 )\n                  v29[563] = v44 + 462;\n                else\n                  v29[563] = v42;\n              }\n              v30 = &v24[5 * v31];\n              if ( !v30[564] )\n              {\n                if ( v42 == v30[563] )\n                  v30[564] = v44 + 462;\n                else\n                  v30[564] = v42;\n              }\n              v27 = v24[5 * v31 + 564];\n              ++v24[2];\n            }\nLABEL_110:\n            v34 = v24[2];\n            for ( i = 4; i < v34; ++i )\n            {\n              if ( !*(_DWORD *)(v24[5 * i + 563] + 12) && (v34 > 5 || *(_BYTE *)(v24[583] + 4)) )\n              {\n                printf(\"Omitting empty partition (%u)\\n\", i + 1);\n                sub_807B407(i);\n                goto LABEL_110;\n              }\n            }\n          }\n          else\n          {\n            puts(\"Bad offset in primary extended partition\");\n          }\n        }\n        else\n        {\n          printf(\"Ignoring extra extended partition %u\\n\", v46);\n        }\n      }\nLABEL_117:\n      v22 = v46;\n    }\n    while ( v46 != 4 );\n    v36 = (_BYTE *)(v1 + 2324);\n    v37 = 3;\n    while ( *(_DWORD *)(v1 + 8) > v37 )\n    {\n      v38 = *(unsigned __int8 *)(*(_DWORD *)v36 + 510);\n      v39 = *(unsigned __int8 *)(*(_DWORD *)v36 + 511);\n      v40 = v37 + 1;\n      if ( __PAIR16__(v39, v38) != 0xAA55 )\n      {\n        printf(\n          \"Warning: invalid flag 0x%02x,0x%02x of partition table %u will be corrected by w(rite)\\n\",\n          v38,\n          v39,\n          v37 + 1);\n        v36[4] = 1;\n      }\n      v37 = v40;\n      v36 += 20;\n    }\n    return 0;\n  }\n  if ( a1 != 1 )\n  {\nLABEL_39:\n    v5 = \"can't read from %s\";\n    goto LABEL_40;\n  }\n  sub_807B0FC();\n  return 1;\n}\n"
        ],
        "134728526": [
            "sub_807CB4E",
            "0x807cb4e",
            "int sub_807CB4E()\n{\n  int v0; // edx\n  int v1; // eax\n\n  printf(\n    \"Building a new %s. Changes will remain in memory only,\\n\"\n    \"until you decide to write them. After that the previous content\\n\"\n    \"won't be recoverable.\\n\"\n    \"\\n\",\n    \"DOS disklabel\");\n  v0 = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + 40) = 0;\n  *(_DWORD *)(v0 + 8) = 4;\n  v1 = 0;\n  memset((void *)(v0 + 650), 0, 0x40u);\n  *(_WORD *)(v0 + 714) = -21931;\n  *(_DWORD *)(v0 + 80) = 0;\n  do\n  {\n    *(_BYTE *)(v0 + v1 + 2268) = 0;\n    v1 += 20;\n  }\n  while ( v1 != 1200 );\n  *(_BYTE *)(v0 + 2268) = 1;\n  return sub_807C371(2);\n}\n"
        ],
        "134728632": [
            "sub_807CBB8",
            "0x807cbb8",
            "int __usercall sub_807CBB8@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // eax\n  FILE *v5; // ebx\n  _BYTE *v6; // eax\n  _BOOL4 v7; // edx\n  _DWORD *v8; // ebx\n  _BOOL4 v11; // [esp+8h] [ebp-D0h]\n  char v12[96]; // [esp+Ch] [ebp-CCh] BYREF\n  char s[108]; // [esp+6Ch] [ebp-6Ch] BYREF\n\n  v2 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 4) = a1;\n  result = _setjmp((struct __jmp_buf_tag *)(v2 + 88));\n  if ( result )\n    return result;\n  if ( !a2 && sub_804D210((_BYTE *)a1, \"/dev/hd\") )\n  {\n    snprintf(s, 0x64u, \"/proc/ide/%s/media\", (const char *)(a1 + 5));\n    v4 = sub_80B3D37();\n    v5 = (FILE *)v4;\n    if ( v4 && fgets_unlocked(s, 100, v4) )\n    {\n      v6 = sub_804D210(s, \"cdrom\");\n      v7 = 1;\n      if ( !v6 )\n        v7 = sub_804D210(s, \"tape\") != 0;\n      goto LABEL_13;\n    }\n    result = stat64(a1, v12);\n    if ( !result )\n    {\n      v7 = (v12[16] & 0x92) == 0;\n      if ( !v5 )\n        goto LABEL_14;\n      goto LABEL_13;\n    }\n    if ( v5 )\n    {\n      v7 = 0;\nLABEL_13:\n      v11 = v7;\n      result = fclose(v5);\n      v7 = v11;\nLABEL_14:\n      if ( v7 )\n        return result;\n    }\n  }\n  v8 = (_DWORD *)dword_80DBB7C;\n  *(_DWORD *)dword_80DBB7C = 0;\n  result = sub_807C371(1);\n  if ( result <= 0 )\n  {\n    if ( result )\n    {\n      sub_807B112();\n      printf(\"Disk %s doesn't contain a valid partition table\\n\", (const char *)a1);\n    }\n    else\n    {\n      sub_807BF56();\n      if ( *(int *)(dword_80DBB80 + 8) > 4 )\n        sub_807B407(*(_DWORD *)(dword_80DBB80 + 48));\n    }\n    return sub_807B0FC();\n  }\n  else if ( a2 || *v8 == 13 )\n  {\n    return sub_804D3A5((int)\"can't open '%s'\", (const char *)a1);\n  }\n  return result;\n}\n"
        ],
        "134728989": [
            "sub_807CD1D",
            "0x807cd1d",
            "int __fastcall sub_807CD1D(int a1)\n{\n  int v1; // esi\n  int result; // eax\n  int v3; // edi\n  int v4; // ebp\n  size_t v5; // eax\n  char v6; // [esp+0h] [ebp-164h] BYREF\n  char v7; // [esp+4h] [ebp-160h] BYREF\n  char v8; // [esp+8h] [ebp-15Ch] BYREF\n  char v9[4]; // [esp+Ch] [ebp-158h] BYREF\n  int v10; // [esp+10h] [ebp-154h]\n  char s[100]; // [esp+14h] [ebp-150h] BYREF\n  char v12[100]; // [esp+78h] [ebp-ECh] BYREF\n  char v13[136]; // [esp+DCh] [ebp-88h] BYREF\n\n  v1 = sub_80B3D18(a1, \"r\");\n  while ( 1 )\n  {\n    result = fgets_unlocked(s, 100, v1);\n    if ( !result )\n      return result;\n    if ( sscanf(s, \" %u %u %u %[^\\n ]\", &v6, &v7, &v8, v12) == 4 )\n    {\n      sprintf(v13, \"/dev/%s\", v12);\n      v3 = open64(v13);\n      if ( v3 == -1 || (v4 = ioctl(v3, 0x301u, v9), close(v3), v4) )\n      {\n        v5 = strlen(v13);\n        if ( !v5 || (unsigned __int8)(v12[v5 + 99] - 48) > 9u )\nLABEL_7:\n          sub_807CBB8((int)v13, 0);\n      }\n      else if ( !v10 )\n      {\n        goto LABEL_7;\n      }\n    }\n  }\n}\n"
        ],
        "134729213": [
            "sub_807CDFD",
            "0x807cdfd",
            "unsigned int __usercall sub_807CDFD@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebx\n  int v3; // esi\n  int v4; // eax\n  void *v5; // esp\n  void *v6; // esp\n  unsigned int result; // eax\n  unsigned int v8; // edi\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // eax\n  int i; // ecx\n  unsigned int v13; // esi\n  unsigned int v14; // eax\n  int v15; // edx\n  unsigned int v16; // esi\n  int k; // eax\n  int v18; // ecx\n  unsigned int v19; // ecx\n  unsigned int v20; // edi\n  unsigned int v21; // ecx\n  unsigned int v22; // eax\n  int v23; // ecx\n  int v24; // edx\n  int v25; // ecx\n  int m; // eax\n  unsigned int v27; // edx\n  unsigned int v28; // edx\n  unsigned int v29; // edi\n  const char *v30; // eax\n  unsigned int v31; // ecx\n  int v32; // edi\n  unsigned int v33; // edx\n  unsigned int v34; // eax\n  int v35; // edi\n  int v36; // eax\n  int v37; // edx\n  unsigned int v38; // edx\n  int v39; // eax\n  int v40; // ecx\n  int v41; // eax\n  char *v42; // eax\n  unsigned int v43; // eax\n  int v44; // [esp-8h] [ebp-138h]\n  int v45; // [esp+0h] [ebp-130h] BYREF\n  int v46; // [esp+4h] [ebp-12Ch]\n  int *v47; // [esp+8h] [ebp-128h]\n  int *v48; // [esp+Ch] [ebp-124h]\n  int v49; // [esp+10h] [ebp-120h]\n  int j; // [esp+14h] [ebp-11Ch]\n  int *v51; // [esp+18h] [ebp-118h]\n  int v52; // [esp+1Ch] [ebp-114h]\n  unsigned int v53; // [esp+20h] [ebp-110h]\n  char s[268]; // [esp+24h] [ebp-10Ch] BYREF\n\n  v52 = a1;\n  v46 = a2;\n  v47 = &v45;\n  v2 = dword_80DBB80;\n  v49 = *(_DWORD *)(dword_80DBB80 + 20 * a1 + 2252);\n  v3 = *(_DWORD *)(dword_80DBB80 + 20 * *(_DWORD *)(dword_80DBB80 + 48) + 2252);\n  v4 = 4 * *(_DWORD *)(dword_80DBB80 + 8) + 4;\n  v5 = alloca(v4);\n  v51 = &v45;\n  v6 = alloca(v4);\n  v48 = &v45;\n  if ( v49 && *(_BYTE *)(v49 + 4) )\n  {\n    printf(\"Partition %u is already defined, delete it before re-adding\\n\", v52 + 1);\n    return v44;\n  }\n  sub_807B080((int)v51, (int)v48);\n  if ( v52 > 3 )\n  {\n    v8 = *(_DWORD *)(v2 + 80) + *(_DWORD *)(v2 + 24);\n    v53 = *(_DWORD *)(v3 + 8) + *(_DWORD *)(v3 + 12) - 1;\n  }\n  else\n  {\n    v8 = *(_DWORD *)(v2 + 24);\n    if ( *(_BYTE *)(v2 + 41) || (v9 = *(_DWORD *)(v2 + 84), v53 = v9 - 1, !v9) )\n      v53 = *(_DWORD *)(v2 + 36) * *(_DWORD *)(v2 + 32) * *(_DWORD *)(v2 + 28) - 1;\n    v10 = *(_DWORD *)(v2 + 80);\n    if ( v10 )\n    {\n      v51[*(_DWORD *)(v2 + 48)] = v10;\n      v48[*(_DWORD *)(v2 + 48)] = *(_DWORD *)(v3 + 8) + *(_DWORD *)(v3 + 12) - 1;\n    }\n  }\n  if ( *(_BYTE *)(v2 + 41) )\n  {\n    for ( i = 0; ; ++i )\n    {\n      LOBYTE(j) = *(_BYTE *)(v2 + 41);\n      if ( i >= *(_DWORD *)(v2 + 8) )\n        break;\n      v13 = *(_DWORD *)(v2 + 12);\n      v14 = v51[i];\n      v15 = v14 - 1;\n      if ( (_BYTE)j )\n        v15 = v14 / v13;\n      v51[i] = v15 * v13;\n    }\n  }\n  v11 = \"cylinder\";\n  if ( !*(_BYTE *)(v2 + 41) )\n    v11 = \"single port, single-sector\" + 20;\n  snprintf(s, 0x100u, \"First %s\", v11);\nLABEL_20:\n  for ( j = 0; ; j = 1 )\n  {\n    v45 = *(_DWORD *)(v2 + 8);\n    v16 = v8;\n    for ( k = 0; k < v45; ++k )\n    {\n      if ( *(_DWORD *)(v2 + 20 * k + 2260) == v16 )\n        v16 += *(_DWORD *)(v2 + 24);\n      v18 = 0;\n      if ( v52 > 3 )\n        v18 = *(_DWORD *)(v2 + 24);\n      v19 = v48[k] + v18;\n      if ( v51[k] <= v16 && v19 >= v16 )\n        v16 = v19 + 1;\n    }\n    if ( v53 < v16 )\n      break;\n    if ( v8 + *(_DWORD *)(v2 + 12) > v16 )\n    {\n      if ( j )\n      {\n        v43 = v8;\n        v8 = v16;\n        v16 = v43;\n        goto LABEL_74;\n      }\nLABEL_36:\n      if ( v8 != v16 )\n      {\n        v8 = v16;\n        goto LABEL_20;\n      }\n      goto LABEL_38;\n    }\n    if ( !j )\n      goto LABEL_36;\n    printf(\"Sector %u is already allocated\\n\", v8);\nLABEL_38:\n    if ( *(_BYTE *)(v2 + 41) )\n    {\n      v20 = *(_DWORD *)(v2 + 12);\n      v21 = v53 / v20 + 1;\n      v22 = v16 / v20 + 1;\n    }\n    else\n    {\n      v22 = v16;\n      v21 = v53;\n    }\n    v8 = sub_807B75A(v22, v22, v21, 0, (int)s);\n    if ( *(_BYTE *)(v2 + 41) )\n    {\n      v8 = *(_DWORD *)(v2 + 12) * (v8 - 1);\n      if ( v16 >= v8 )\n        break;\n    }\nLABEL_74:\n    if ( v8 == v16 )\n      break;\n  }\n  if ( v52 > 4 )\n  {\n    v23 = *(_DWORD *)(v2 + 24);\n    v24 = v2 + 20 * v52;\n    *(_DWORD *)(v24 + 2260) = v16 - v23;\n    if ( v16 - v23 == *(_DWORD *)(v2 + 80) )\n    {\n      *(_DWORD *)(v24 + 2260) = v16 - v23 + 1;\n      if ( v23 == 1 )\n        ++v16;\n    }\n  }\n  v25 = *(_DWORD *)(v2 + 8);\n  for ( m = 0; m < v25; ++m )\n  {\n    v27 = *(_DWORD *)(v2 + 20 * m + 2260);\n    if ( v27 > v16 && v27 <= v53 )\n      v53 = v27 - 1;\n    v28 = v51[m];\n    if ( v53 >= v28 && v28 > v16 )\n      v53 = v28 - 1;\n  }\n  if ( v53 < v16 )\n  {\n    result = puts(\"No free sectors available\");\n    if ( v52 > 4 )\n      --*(_DWORD *)(v2 + 8);\n    return result;\n  }\n  if ( *(_BYTE *)(v2 + 41) )\n  {\n    v29 = *(_DWORD *)(v2 + 12);\n    v51 = (int *)v53;\n    if ( v16 / v29 + 1 != v53 / v29 + 1 )\n    {\n      v30 = \"cylinder\";\nLABEL_62:\n      snprintf(s, 0x100u, \"Last %s or +size{,K,M,G,T}\", v30);\n      if ( *(_BYTE *)(v2 + 41) )\n      {\n        v31 = *(_DWORD *)(v2 + 12);\n        v32 = v16 / v31 + 1;\n        v33 = v53 / v31 + 1;\n      }\n      else\n      {\n        v32 = v16;\n        v33 = v53;\n      }\n      v34 = sub_807B75A(v32, v33, v33, v32, (int)s);\n      v51 = (int *)v34;\n      if ( *(_BYTE *)(v2 + 41) )\n      {\n        v51 = (int *)(*(_DWORD *)(v2 + 12) * v34 - 1);\n        if ( (unsigned int)v51 > v53 )\n          v51 = (int *)v53;\n      }\n    }\n  }\n  else\n  {\n    v51 = (int *)v16;\n    v30 = \"single port, single-sector\" + 20;\n    if ( v53 != v16 )\n      goto LABEL_62;\n  }\n  v35 = v2 + 20 * v52;\n  v36 = *(_DWORD *)(v35 + 2252);\n  v37 = *(_DWORD *)(v35 + 2260);\n  *(_BYTE *)v36 = 0;\n  *(_BYTE *)(v36 + 4) = v46;\n  *(_DWORD *)(v36 + 8) = v16 - v37;\n  *(_DWORD *)(v36 + 12) = (char *)v51 + 1 - v16;\n  result = sub_807AF64((_BYTE *)v36, v16, (unsigned int)v51);\n  *(_BYTE *)(v35 + 2268) = 1;\n  if ( v52 > 4 )\n  {\n    v38 = *(_DWORD *)(v35 + 2260);\n    v53 = 20 * (v52 - 1) + v2;\n    v39 = *(_DWORD *)(v53 + 2256);\n    v40 = *(_DWORD *)(v2 + 80);\n    *(_BYTE *)v39 = 0;\n    *(_BYTE *)(v39 + 4) = 5;\n    *(_DWORD *)(v39 + 8) = v38 - v40;\n    *(_DWORD *)(v39 + 12) = (char *)v51 + 1 - v38;\n    sub_807AF64((_BYTE *)v39, v38, (unsigned int)v51);\n    result = v53;\n    *(_BYTE *)(v53 + 2268) = 1;\n  }\n  if ( v46 == 5 )\n  {\n    v41 = v52;\n    *(_DWORD *)(v2 + 48) = v52;\n    *(_DWORD *)(v2 + 20 * v41 + 2256) = v49;\n    *(_DWORD *)(v2 + 80) = v16;\n    *(_DWORD *)(v2 + 2340) = v16;\n    v42 = (char *)sub_804DB2E(*(_DWORD *)(v2 + 16));\n    *(_DWORD *)(v2 + 2344) = v42;\n    *(_DWORD *)(v2 + 2332) = v42 + 446;\n    result = (unsigned int)(v42 + 462);\n    *(_DWORD *)(v2 + 2336) = result;\n    *(_BYTE *)(v2 + 2348) = 1;\n    *(_DWORD *)(v2 + 8) = 5;\n  }\n  return result;\n}\n"
        ],
        "134730524": [
            "sub_807D31C",
            "0x807d31c",
            "unsigned int sub_807D31C()\n{\n  int v0; // esi\n  int v1; // ebx\n  char *v2; // eax\n  int v3; // edx\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 8);\n  if ( v1 > 5 || *(_BYTE *)(*(_DWORD *)(dword_80DBB80 + 2332) + 4) )\n  {\n    v2 = (char *)sub_804DB2E(*(_DWORD *)(dword_80DBB80 + 16));\n    v3 = v0 + 20 * v1;\n    *(_DWORD *)(v3 + 2264) = v2;\n    *(_DWORD *)(v3 + 2252) = v2 + 446;\n    *(_DWORD *)(v3 + 2256) = v2 + 462;\n    *(_DWORD *)(v3 + 2260) = 0;\n    *(_BYTE *)(v3 + 2268) = 1;\n    ++*(_DWORD *)(v0 + 8);\n  }\n  return sub_807CDFD(*(_DWORD *)(v0 + 8) - 1, 131);\n}\n"
        ],
        "134730630": [
            "sub_807D386",
            "0x807d386",
            "int __cdecl sub_807D386(int a1, int a2)\n{\n  _DWORD *v2; // ebp\n  char v3; // al\n  int v4; // ecx\n  int *v5; // ebx\n  int v6; // edx\n  unsigned __int8 v7; // al\n  unsigned int v8; // ebx\n  _BYTE *v9; // esi\n  char v10; // al\n  int v11; // eax\n  int v12; // eax\n  int i; // edx\n  const char *v14; // eax\n  unsigned __int8 v15; // al\n  int v16; // eax\n  int v17; // edx\n  unsigned int v18; // eax\n  int v19; // ebx\n  int v20; // esi\n  unsigned int v21; // eax\n  unsigned int v22; // edi\n  unsigned int v23; // eax\n  const char *v24; // eax\n  char *v25; // esi\n  int v26; // ebx\n  char v27; // al\n  int v28; // edi\n  unsigned int v29; // edx\n  unsigned int v30; // eax\n  unsigned int v31; // esi\n  unsigned int v32; // eax\n  int j; // esi\n  int v34; // edi\n  unsigned int k; // ebx\n  int v36; // eax\n  char *v37; // ebx\n  int v38; // eax\n  char *v39; // edx\n  void *v40; // eax\n  int v41; // eax\n  int m; // eax\n  int v43; // edx\n  int v44; // ecx\n  int *v45; // esi\n  _DWORD *v46; // esi\n  _DWORD *v47; // eax\n  _DWORD *v48; // edx\n  int v49; // ebx\n  _DWORD *v50; // ecx\n  int v51; // esi\n  int n; // eax\n  unsigned int v53; // eax\n  unsigned int v54; // eax\n  int result; // eax\n  void *src; // [esp+8h] [ebp-78h]\n  unsigned int srca; // [esp+8h] [ebp-78h]\n  unsigned __int8 *srcb; // [esp+8h] [ebp-78h]\n  char *srcd; // [esp+8h] [ebp-78h]\n  _DWORD *srce; // [esp+8h] [ebp-78h]\n  int srcc; // [esp+8h] [ebp-78h]\n  int v62; // [esp+Ch] [ebp-74h]\n  char *v63; // [esp+Ch] [ebp-74h]\n  int v64; // [esp+Ch] [ebp-74h]\n  unsigned int v65; // [esp+10h] [ebp-70h]\n  int v66; // [esp+10h] [ebp-70h]\n  int v67; // [esp+14h] [ebp-6Ch]\n  int v68; // [esp+1Ch] [ebp-64h] BYREF\n  char s[96]; // [esp+20h] [ebp-60h] BYREF\n\n  v2 = sub_804DB2E(0xD7Cu);\n  dword_80DBB80 = (int)v2;\n  v2[4] = 512;\n  v2[6] = 1;\n  v2[2] = 4;\n  v2[3] = 1;\n  *((_BYTE *)v2 + 43) = 1;\n  sub_807B0FC();\n  v3 = sub_80ABEAC(a2, \"b:+C:+H:+lS:+u\", v2 + 4, v2 + 13, v2 + 14, v2 + 15);\n  v5 = (int *)(a2 + 4 * optind);\n  if ( (v3 & 1) != 0 )\n  {\n    v6 = v2[4];\n    if ( (unsigned int)(v6 - 512) > 0xFE00 )\n      goto LABEL_3;\n    v4 = v6 - 1;\n    if ( (v6 & (v6 - 1)) != 0 )\n      goto LABEL_3;\n    v2[6] = 2;\n    v2[5] = 1;\n  }\n  if ( (unsigned int)(v2[14] - 1) > 0xFE )\n    v2[14] = 0;\n  if ( (unsigned int)(v2[15] - 1) > 0x3E )\n    v2[15] = 0;\n  if ( (v3 & 0x20) != 0 )\n    *((_BYTE *)v2 + 41) = 0;\n  if ( (v3 & 8) == 0 )\n  {\n    if ( *v5 && !v5[1] )\n    {\n      v2[1] = *v5;\n      sub_807C371(0);\n      while ( 1 )\n      {\nLABEL_21:\n        sub_804DD98(10);\n        v7 = sub_807B5A1() | 0x20;\n        switch ( v7 )\n        {\n          case 'a':\n            if ( *((_BYTE *)v2 + 40) )\n              goto LABEL_35;\n            v8 = sub_807B8F6(1, v2[2]);\n            v9 = (_BYTE *)v2[5 * v8 + 563];\n            if ( ((v9[4] & 0x7F) == 5 || v9[4] == 15) && !*v9 )\n              printf(\"WARNING: Partition %u is an extended partition\\n\", v8 + 1);\n            *v9 = *v9 == 0 ? 0x80 : 0;\n            LOBYTE(v2[5 * v8 + 567]) = 1;\n            continue;\n          case 'b':\n          case 's':\n            continue;\n          case 'c':\n            if ( *((_BYTE *)v2 + 40) )\n            {\nLABEL_35:\n              printf(\"%c: unknown command\\n\");\n            }\n            else\n            {\n              v10 = 1 - *((_BYTE *)v2 + 43);\n              *((_BYTE *)v2 + 43) = v10;\n              if ( v10 )\n                v2[6] = v2[8];\n              else\n                v2[6] = 1;\n              printf(\"DOS Compatibility flag is %sset\\n\");\n            }\n            continue;\n          case 'd':\n            v11 = sub_807B940(1, v2[2]);\n            if ( v11 >= 0 )\n              sub_807B407(v11);\n            continue;\n          case 'i':\n            printf(\"%c: unknown command\\n\", 105);\n            goto LABEL_39;\n          case 'l':\nLABEL_39:\n            sub_807B6C6();\n            continue;\n          case 'm':\n            sub_807B26B();\n            continue;\n          case 'n':\n            v12 = sub_807B200();\n            if ( v12 )\n              continue;\n            for ( i = 0; i != 20; i += 5 )\n              v12 += *(_BYTE *)(v2[i + 563] + 4) == 0;\n            if ( v12 )\n            {\n              v14 = \"l   logical (5 or over)\";\n              if ( !v2[20] )\n                v14 = \"e   extended\";\n              snprintf(s, 0x50u, \"Partition type\\n   p   primary partition (1-4)\\n   %s\\n\", v14);\n              while ( 2 )\n              {\n                v15 = sub_807B5A1();\n                if ( (v15 | 0x20) == 112 )\n                {\n                  v16 = sub_807B9B3();\n                  v17 = 131;\n                  if ( v16 >= 0 )\n                    goto LABEL_62;\n                }\n                else\n                {\n                  if ( v15 == 108 )\n                  {\n                    if ( v2[20] )\n                      goto LABEL_57;\nLABEL_63:\n                    printf(\"Invalid partition number for type '%c'\\n\", v15);\n                    continue;\n                  }\n                  if ( v15 != 101 || v2[20] )\n                    goto LABEL_63;\n                  v16 = sub_807B9B3();\n                  if ( v16 >= 0 )\n                  {\n                    v17 = 5;\nLABEL_62:\n                    sub_807CDFD(v16, v17);\n                  }\n                }\n                break;\n              }\n            }\n            else if ( (int)v2[2] <= 59 )\n            {\n              if ( v2[20] )\nLABEL_57:\n                sub_807D31C();\n              else\n                puts(\"You must delete some partition and add an extended partition first\");\n            }\n            else\n            {\n              puts(\"The maximum number of partitions has been created\");\n            }\n            break;\n          case 'o':\n            sub_807CB4E();\n            continue;\n          case 'p':\n            sub_807BF56();\n            continue;\n          case 'q':\n            sub_804DD98(10);\n            return 0;\n          case 't':\n            v18 = sub_807B940(0, v2[2]);\n            v19 = v18;\n            if ( v18 != -1 )\n            {\n              v20 = v2[5 * v18 + 563];\n              src = (void *)*(unsigned __int8 *)(v20 + 4);\n              if ( *(_BYTE *)(v20 + 4) || *(_DWORD *)(v20 + 12) )\n              {\n                do\n                {\n                  while ( 1 )\n                  {\n                    sub_807B5A1();\n                    if ( (*(_BYTE *)*v2 | 0x20) != 108 )\n                      break;\n                    sub_807B6C6();\n                  }\n                  v21 = sub_804ED6C(16, (const char *)*v2, 0, v19);\n                  v22 = v21;\n                }\n                while ( v21 > 0xFF );\n                if ( !v21 )\n                  puts(\n                    \"Type 0 means free space to many systems\\n\"\n                    \"(but not to Linux). Having partitions of\\n\"\n                    \"type 0 is probably unwise.\");\n                v23 = v22;\n                LOBYTE(v23) = v22 & 0x7F;\n                if ( (v23 == 5 || v22 == 15) == ((*(_BYTE *)(v20 + 4) & 0x7F) == 5 || *(_BYTE *)(v20 + 4) == 15) )\n                {\n                  if ( src != (void *)v22 )\n                  {\n                    *(_BYTE *)(v20 + 4) = v22;\n                    v24 = sub_807AF33(v22);\n                    printf(\"Changed system type of partition %u to %x (%s)\\n\", v19 + 1, v22, v24);\n                    LOBYTE(v2[5 * v19 + 567]) = 1;\n                  }\n                }\n                else\n                {\n                  puts(\"You cannot change a partition into an extended one or vice versa\");\n                }\n              }\n              else\n              {\n                printf(\"Partition %u does not exist yet!\\n\");\n              }\n            }\n            continue;\n          case 'u':\n            *((_BYTE *)v2 + 41) = *((_BYTE *)v2 + 41) == 0;\n            sub_807B008();\n            printf(\"Changing display/entry units to %s\\n\");\n            continue;\n          case 'v':\n            sub_807BC8E();\n            continue;\n          case 'w':\nLABEL_82:\n            sub_807B600();\n          case 'x':\nLABEL_84:\n            while ( 2 )\n            {\n              sub_804DD98(10);\n              switch ( (unsigned __int8)sub_807B5A1() | 0x20 )\n              {\n                case 'a':\n                case 'g':\n                case 'i':\n                case 'o':\n                case 'y':\n                  continue;\n                case 'b':\n                  if ( !*((_BYTE *)v2 + 40) )\n                  {\n                    srca = sub_807B8F6(0, v2[2]);\n                    v25 = (char *)&v2[5 * srca];\n                    v26 = *((_DWORD *)v25 + 563);\n                    if ( !sub_807B200() )\n                    {\n                      v62 = *(_DWORD *)(v26 + 12);\n                      v27 = *(_BYTE *)(v26 + 4);\n                      if ( v27 == 15 || v27 == 0 || v62 == 0 || (v27 & 0x7F) == 5 )\n                      {\n                        printf(\"Partition %u has no data area\\n\", srca + 1);\n                      }\n                      else\n                      {\n                        v28 = *(_DWORD *)(*((_DWORD *)v25 + 563) + 8) + *((_DWORD *)v25 + 565);\n                        v29 = sub_807B75A(0, v28, v62 + v28 - 1, v28, (int)\"New beginning of data\");\n                        if ( v28 != v29 )\n                        {\n                          v65 = v29;\n                          v30 = v29 - *((_DWORD *)v25 + 565);\n                          v31 = *(_DWORD *)(v26 + 8) + v62 - v30;\n                          *(_DWORD *)(v26 + 8) = v30;\n                          *(_DWORD *)(v26 + 12) = v31;\n                          sub_807B5A1();\n                          if ( (*(_BYTE *)*v2 | 0x20) == 121 )\n                            sub_807AF64((_BYTE *)v26, v65, v65 + v31 - 1);\n                          LOBYTE(v2[5 * srca + 567]) = 1;\n                        }\n                      }\n                    }\n                  }\n                  continue;\n                case 'c':\n                  v32 = sub_807B75A(1u, v2[9], 0x100000u, 0, (int)&unk_80D28ED);\n                  v2[9] = v32;\n                  v2[13] = v32;\n                  if ( !*((_BYTE *)v2 + 40) )\n                    sub_807B1D6();\n                  continue;\n                case 'd':\n                  printf(\"Device: %s\\n\", (const char *)v2[1]);\n                  for ( j = 3; j < v2[2]; ++j )\n                  {\n                    srcb = (unsigned __int8 *)v2[5 * j + 566];\n                    v34 = 0;\n                    for ( k = 0; k < v2[4]; ++k )\n                    {\n                      if ( !v34 )\n                        printf(\"0x%03X:\", k);\n                      printf(\" %02X\", srcb[k]);\n                      if ( v34 == 15 )\n                      {\n                        sub_804DD98(10);\n                        v34 = -1;\n                      }\n                      ++v34;\n                    }\n                    if ( v34 )\n                      sub_804DD98(10);\n                    sub_804DD98(10);\n                  }\n                  continue;\n                case 'e':\n                  v36 = 1;\n                  if ( *((_BYTE *)v2 + 40) )\n                    continue;\n                  goto LABEL_131;\n                case 'f':\n                  if ( *((_BYTE *)v2 + 40) )\n                    continue;\n                  if ( !sub_807B02A(0) )\n                  {\n                    puts(\"Ordering is already correct\\n\");\n                    continue;\n                  }\n                  while ( 1 )\n                  {\n                    v41 = sub_807B02A(&v68);\n                    if ( !v41 )\n                      goto LABEL_128;\n                    if ( v41 > 3 )\n                      break;\n                    v37 = (char *)&v2[5 * v41];\n                    v38 = *((_DWORD *)v37 + 564);\n                    v39 = (char *)&v2[5 * v68];\n                    *((_DWORD *)v37 + 564) = *((_DWORD *)v39 + 564);\n                    *((_DWORD *)v39 + 564) = v38;\n                    v40 = (void *)*((_DWORD *)v37 + 563);\n                    v63 = v39;\n                    srcd = (char *)*((_DWORD *)v39 + 563);\n                    qmemcpy(s, v40, 0x10u);\n                    memmove(v40, srcd, 0x10u);\n                    qmemcpy(srcd, s, 0x10u);\n                    v63[2268] = 1;\n                    v37[2268] = 1;\n                  }\n                  break;\n                case 'h':\n                  v53 = sub_807B75A(1u, v2[7], 0x100u, 0, (int)&unk_80D2938);\n                  v2[7] = v53;\n                  v2[14] = v53;\n                  sub_807B008();\n                  continue;\n                case 'p':\n                  v36 = 0;\nLABEL_131:\n                  sub_807BBA8(v36);\n                  continue;\n                case 'q':\n                  sub_804DD98(10);\n                  exit(0);\n                  return result;\n                case 'r':\n                  goto LABEL_21;\n                case 's':\n                  v54 = sub_807B75A(1u, v2[8], 0x3Fu, 0, (int)&unk_80D2948);\n                  v2[8] = v54;\n                  v2[15] = v54;\n                  if ( *((_BYTE *)v2 + 43) )\n                  {\n                    v2[6] = v54;\n                    puts(\"Warning: setting sector offset for DOS compatibility\");\n                  }\n                  sub_807B008();\n                  continue;\n                case 'v':\n                  sub_807BC8E();\n                  continue;\n                case 'w':\n                  goto LABEL_82;\n                default:\n                  puts(\"Command Action\");\n                  puts(\"b\\tmove beginning of data in a partition\");\n                  puts(\"c\\tchange number of cylinders\");\n                  puts(\"d\\tprint the raw data in the partition table\");\n                  puts(\"e\\tlist extended partitions\");\n                  puts(\"f\\tfix partition order\");\n                  puts(\"h\\tchange number of heads\");\n                  puts(\"p\\tprint the partition table\");\n                  puts(\"q\\tquit without saving changes\");\n                  puts(\"r\\treturn to main menu\");\n                  puts(\"s\\tchange number of sectors/track\");\n                  puts(\"v\\tverify the partition table\");\n                  puts(\"w\\twrite table to disk and exit\");\n                  continue;\n              }\n              break;\n            }\n            while ( 1 )\n            {\n              v45 = v2 + 590;\n              for ( m = 5; ; ++m )\n              {\n                if ( m >= v2[2] - 1 )\n                {\n                  while ( 1 )\n                  {\n                    v51 = v2[2];\n                    v50 = v2 + 583;\n                    srcc = 4;\n                    do\n                    {\n                      if ( srcc >= v51 - 1 )\n                      {\n                        for ( n = 4; v51 > n; ++n )\n                          LOBYTE(v2[5 * n + 567]) = 1;\nLABEL_128:\n                        puts(\"Done\");\n                        goto LABEL_84;\n                      }\n                      v47 = (_DWORD *)*v50;\n                      ++srcc;\n                      v48 = (_DWORD *)v50[5];\n                      v64 = v50[2];\n                      v66 = v50[7];\n                      v67 = *(_DWORD *)(*v50 + 8) + v64;\n                      v49 = v48[2] + v66;\n                      v50 += 5;\n                    }\n                    while ( v67 <= v49 );\n                    qmemcpy(s, v47, 0x10u);\n                    qmemcpy(v47, v48, 0x10u);\n                    qmemcpy(v48, s, 0x10u);\n                    v47[2] = v49 - v64;\n                    v48[2] = v67 - v66;\n                  }\n                }\n                v43 = *v45;\n                v44 = v45[5];\n                v45 += 5;\n                if ( v43 > v44 )\n                  break;\n              }\n              v46 = &v2[5 * m];\n              v46[565] = v44;\n              srce = &v2[5 * m + 5];\n              srce[565] = v43;\n              *(_DWORD *)(v46[563] + 8) += v43 - v44;\n              *(_DWORD *)(srce[563] + 8) += v44 - v43;\n              *(_DWORD *)(v2[5 * m + 559] + 8) = v44 - v2[20];\n              *(_DWORD *)(v46[564] + 8) = v43 - v2[20];\n            }\n          default:\n            printf(\"%c: unknown command\\n\", v7);\n            sub_807B26B();\n            continue;\n        }\n      }\n    }\nLABEL_3:\n    sub_804CDC2();\n  }\n  *((_BYTE *)v2 + 44) = 1;\n  if ( *v5 )\n  {\n    *((_BYTE *)v2 + 42) = 1;\n    do\n      sub_807CBB8(*v5++, 1);\n    while ( *v5 );\n  }\n  else\n  {\n    sub_807CD1D(v4);\n  }\n  return 0;\n}\n"
        ],
        "134733056": [
            "sub_807DD00",
            "0x807dd00",
            "decompilation failure at 807DD00!\n"
        ],
        "134733357": [
            "sub_807DE2D",
            "0x807de2d",
            "int __cdecl sub_807DE2D(int a1, int a2)\n{\n  const char *v2; // eax\n  int v3; // eax\n\n  v2 = (const char *)sub_80B2E5A();\n  v3 = sub_804DBE1(v2);\n  sub_804E029(v3, ident[1] == 114 ? 4705 : 587, 0, \"%s\", *(const char **)(a2 + 4));\n  return 0;\n}\n"
        ],
        "134733432": [
            "sub_807DE78",
            "0x807de78",
            "int __cdecl sub_807DE78(int a1, int a2)\n{\n  char v2; // bl\n  int v3; // eax\n\n  v2 = sub_80ABEC2(a2, &unk_80D2E74, \"freeze\");\n  v3 = sub_804DBE1(*(const char **)(a2 + 4 * optind));\n  sub_804E0BE(v3, -(v2 & 1) - 1073457032, 0, \"(opts & 1) ? FIFREEZE : FITHAW\");\n  return 0;\n}\n"
        ],
        "134733504": [
            "sub_807DEC0",
            "0x807dec0",
            "int __cdecl sub_807DEC0(int a1, int a2)\n{\n  char v2; // bl\n  const char *v3; // ebp\n  int v4; // eax\n  int v6; // [esp+0h] [ebp-34h] BYREF\n  int v7; // [esp+4h] [ebp-30h] BYREF\n  int v8; // [esp+8h] [ebp-2Ch] BYREF\n  __int64 v9[5]; // [esp+Ch] [ebp-28h] BYREF\n\n  v2 = sub_80ABEC2(a2, \"^o:l:m:v\", \"offset\", &v6, &v7, &v8);\n  memset(v9, 0, 0x18u);\n  v9[1] = -1LL;\n  if ( (v2 & 1) != 0 )\n    v9[0] = sub_80B3F8E();\n  if ( (v2 & 2) != 0 )\n    v9[1] = sub_80B3F8E();\n  if ( (v2 & 4) != 0 )\n    v9[2] = sub_80B3F8E();\n  v3 = *(const char **)(a2 + 4 * optind);\n  v4 = sub_804DC1E(v3);\n  sub_804E0BE(v4, 0xC0185879, (int)v9, \"FITRIM\");\n  if ( (v2 & 8) != 0 )\n    printf(\"%s: %llu bytes trimmed\\n\", v3, v9[1]);\n  return 0;\n}\n"
        ],
        "134733732": [
            "sub_807DFA4",
            "0x807dfa4",
            "char *__usercall sub_807DFA4@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  size_t v3; // eax\n  _BYTE *v4; // ebp\n  char *v5; // edx\n  int v6; // esi\n  char v7; // cl\n\n  v1 = a1;\n  if ( (dword_80DBB9C & 0x40) != 0 )\n    return sub_804DB46(a1);\n  v3 = strlen(a1);\n  v4 = sub_804DAFA(4 * v3 + 3);\n  v5 = v4 + 1;\n  *v4 = 39;\n  v6 = dword_80DBB9C & 0x8000;\n  while ( 1 )\n  {\n    v7 = *v1;\n    if ( !*v1 )\n      break;\n    if ( v7 == 39 )\n    {\n      *(_DWORD *)v5 = 656890919;\nLABEL_10:\n      v5 += 4;\n      goto LABEL_17;\n    }\n    if ( v6 )\n    {\n      if ( v7 == 33 )\n      {\n        *(_DWORD *)v5 = 656497703;\n        goto LABEL_10;\n      }\n      if ( v7 == 10 )\n      {\n        *(_WORD *)v5 = 28252;\n        v5 += 2;\n        goto LABEL_17;\n      }\n      if ( (unsigned __int8)(v7 - 9) <= 4u || v7 == 32 )\n      {\n        *(_WORD *)v5 = 23591;\n        v5[2] = v7;\n        v5[3] = 39;\n        goto LABEL_10;\n      }\n    }\n    *v5++ = v7;\nLABEL_17:\n    ++v1;\n  }\n  *(_WORD *)v5 = 39;\n  return v4;\n}\n"
        ],
        "134733894": [
            "sub_807E046",
            "0x807e046",
            "int __usercall sub_807E046@<eax>(char *s@<ecx>, int argc@<edx>, char *const *a3@<eax>, struct option *longopts)\n{\n  int v7; // eax\n  int v8; // edx\n  const char *v9; // eax\n  char *v10; // eax\n  char *v11; // eax\n  char *const *v12; // ebx\n  const char *v13; // eax\n  char *v14; // eax\n  int v16; // [esp+0h] [ebp-1Ch]\n  int c; // [esp+4h] [ebp-18h]\n  int longind[5]; // [esp+8h] [ebp-14h] BYREF\n\n  if ( (dword_80DBB9C & 4) != 0 )\n    opterr = 0;\n  optind = 0;\n  v16 = 0;\n  while ( 1 )\n  {\n    v7 = (dword_80DBB9C & 0x80u) == 0\n       ? getopt_long(argc, a3, s, longopts, longind)\n       : getopt_long_only(argc, a3, s, longopts, longind);\n    v8 = v7;\n    if ( v7 == -1 )\n      break;\n    if ( v7 == 58 || v7 == 63 )\n    {\n      v16 = 1;\n    }\n    else if ( (dword_80DBB9C & 8) == 0 )\n    {\n      if ( v7 == 2 )\n      {\n        printf(\" --%s\", longopts[longind[0]].name);\n        if ( longopts[longind[0]].has_arg )\n          goto LABEL_17;\n      }\n      else\n      {\n        v9 = optarg;\n        if ( v8 == 1 )\n          goto LABEL_19;\n        c = v8;\n        printf(\" -%c\", v8);\n        v10 = strchr(s, c);\n        if ( v10 && v10[1] == 58 )\n        {\nLABEL_17:\n          v9 = optarg;\n          if ( !optarg )\n            v9 = &data;\nLABEL_19:\n          v11 = sub_807DFA4(v9);\n          printf(\" %s\", v11);\n        }\n      }\n    }\n  }\n  if ( (dword_80DBB9C & 8) == 0 )\n  {\n    printf(\" --\");\n    v12 = &a3[optind];\n    while ( 1 )\n    {\n      v13 = (const char *)*((_DWORD *)++v12 - 1);\n      if ( !v13 )\n        break;\n      v14 = sub_807DFA4(v13);\n      printf(\" %s\", v14);\n    }\n    sub_804DD98(10);\n  }\n  return v16;\n}\n"
        ],
        "134734246": [
            "sub_807E1A6",
            "0x807e1a6",
            "int __cdecl sub_807E1A6(int a1, int a2)\n{\n  char *v2; // eax\n  const char *v3; // esi\n  size_t v5; // eax\n  char *v6; // eax\n  struct option *v7; // ebp\n  char *v8; // eax\n  char *v9; // edi\n  int v10; // esi\n  size_t v11; // eax\n  size_t v12; // edx\n  struct option *v13; // edx\n  char *v14; // esi\n  int v15; // edx\n  int v16; // ecx\n  char **v17; // eax\n  struct option *v18; // [esp+0h] [ebp-28h]\n  int v19; // [esp+0h] [ebp-28h]\n  char v20; // [esp+4h] [ebp-24h]\n  char *s; // [esp+8h] [ebp-20h] BYREF\n  int v22; // [esp+Ch] [ebp-1Ch] BYREF\n  char *s1; // [esp+10h] [ebp-18h] BYREF\n  int v24[5]; // [esp+14h] [ebp-14h] BYREF\n\n  s = 0;\n  v22 = 0;\n  v24[0] = 0;\n  v2 = getenv(\"GETOPT_COMPATIBLE\");\n  v3 = *(const char **)(a2 + 4);\n  if ( !v3 )\n  {\n    if ( v2 )\n    {\n      puts(\" --\");\n      return 0;\n    }\nLABEL_4:\n    sub_804D5E0(\"missing optstring argument\");\n  }\n  if ( *v3 == 45 && !v2 )\n  {\n    v20 = sub_80ABEC2(a2, \"+o:n:qQs:Tual:*\", \"options\", &s, &v22, &s1, v24);\n    v7 = 0;\n    while ( v24[0] )\n    {\n      v8 = (char *)sub_80AFB01(v18);\n      v9 = strtok(v8, \", \\t\\n\");\n      v10 = 0;\n      if ( v7 )\n      {\n        while ( v7[v10].name )\n          ++v10;\n      }\n      while ( v9 )\n      {\n        v11 = strlen(v9);\n        if ( v11 )\n        {\n          v12 = v11 - 1;\n          if ( v9[v11 - 1] == 58 )\n          {\n            v19 = 1;\n            if ( v11 != 1 && v9[v12 - 1] == 58 )\n            {\n              v12 = v11 - 2;\n              v19 = 2;\n            }\n            v9[v12] = 0;\n            if ( !v12 )\n              sub_804D5E0(\"empty long option specified\");\n          }\n          else\n          {\n            v19 = 0;\n          }\n          v7 = (struct option *)sub_80B4733(v10, 4100);\n          v13 = &v7[v10];\n          v13->has_arg = v19;\n          v13->val = 2;\n          v18 = v13;\n          v13->name = sub_804DB46(v9);\n          ++v10;\n        }\n        v9 = strtok(0, \", \\t\\n\");\n      }\n    }\n    if ( (v20 & 0x10) != 0 )\n    {\n      v14 = s1;\n      if ( strcmp(s1, \"bash\") )\n      {\n        if ( strcmp(v14, \"sh\") )\n        {\n          if ( !strcmp(v14, \"tcsh\") || !strcmp(v14, \"csh\") )\n            dword_80DBB9C |= 0x8000u;\n          else\n            sub_804D5F4(\"unknown shell '%s', assuming bash\");\n        }\n      }\n    }\n    if ( (v20 & 0x20) != 0 )\n    {\n      return 4;\n    }\n    else\n    {\n      v15 = optind - 1;\n      if ( !s )\n      {\n        s = *(char **)(a2 + 4 * optind);\n        if ( !s )\n          goto LABEL_4;\n        v15 = optind;\n      }\n      v16 = v22;\n      if ( !v22 )\n        v16 = *(_DWORD *)a2;\n      v17 = (char **)(a2 + 4 * v15);\n      *v17 = (char *)v16;\n      return sub_807E046(s, a1 - v15, v17, v7);\n    }\n  }\n  else\n  {\n    dword_80DBB9C |= 0x40u;\n    v5 = strspn(v3, \"-+\");\n    v6 = sub_804DB46(&v3[v5]);\n    *(_DWORD *)(a2 + 4) = *(_DWORD *)a2;\n    return sub_807E046(v6, a1 - 1, (char *const *)(a2 + 4), 0);\n  }\n}\n"
        ],
        "134734843": [
            "sub_807E3FB",
            "0x807e3fb",
            "int __cdecl sub_807E3FB(int a1, char **argv)\n{\n  int v2; // ebx\n  int v3; // eax\n  int v4; // esi\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // ebp\n  int v9; // ecx\n  int v10; // ecx\n  const char *v11; // edx\n  FILE *v12; // ebp\n  int v13; // edx\n  int v14; // ecx\n  void *v15; // esi\n  _BYTE *v16; // eax\n  int v17; // ecx\n  int v19; // [esp-8h] [ebp-1Ch]\n  int v20; // [esp-4h] [ebp-18h]\n\n  v2 = sub_80AAA6C();\n  while ( 1 )\n  {\n    v3 = getopt(a1, argv, \"bcdoxCe:f:n:s:v\");\n    v4 = v3;\n    if ( v3 <= 0 )\n      break;\n    v5 = strchr(\"bcdoxCe:f:n:s:v\", v3);\n    v6 = v19;\n    v7 = v20;\n    if ( !v5 )\n      sub_804CDC2();\n    v8 = v5 - \"bcdoxCe:f:n:s:v\";\n    if ( v5 - \"bcdoxCe:f:n:s:v\" <= 4 )\n    {\n      sub_80AAFEF(v20, \"\\\"%07.7_Ax\\n\\\"\");\n      sub_80AAFEF(v9, off_80B7E64[v8]);\n    }\n    switch ( v4 )\n    {\n      case 'C':\n        sub_80AAFEF(v7, \"\\\"%08.8_Ax\\n\\\"\");\n        sub_80AAFEF(v10, \"\\\"%08.8_ax  \\\"8/1 \\\"%02x \\\"\\\"  \\\"8/1 \\\"%02x \\\"\");\n        v11 = \"\\\"  |\\\"16/1 \\\"%_p\\\"\\\"|\\n\\\"\";\n        goto LABEL_11;\n      case 'e':\n        v11 = optarg;\nLABEL_11:\n        sub_80AAFEF(v7, v11);\n        break;\n      case 'f':\n        v12 = (FILE *)sub_80B3D45(v7, v6);\n        while ( 1 )\n        {\n          v15 = (void *)sub_80AB85A();\n          if ( !v15 )\n            break;\n          v16 = (_BYTE *)sub_80B2E8C(v14, v13);\n          if ( *v16 )\n          {\n            if ( *v16 != 35 )\n              sub_80AAFEF(v17, v16);\n          }\n          free(v15);\n        }\n        fclose(v12);\n        break;\n      case 'n':\n        *(_DWORD *)(v2 + 8) = sub_80B4187(v7, v6);\n        break;\n      case 's':\n        *(_QWORD *)v2 = sub_80B3DD5(v7, 0, 0, 0, -1, 0x7FFFFFFF, &unk_80B7580);\n        break;\n      case 'v':\n        *(_BYTE *)(v2 + 12) = 0;\n        break;\n    }\n  }\n  if ( !*(_DWORD *)(v2 + 16) )\n  {\n    ((void (*)(void))sub_80AAFEF)();\n    ((void (*)(void))sub_80AAFEF)();\n  }\n  return sub_80AAA86(a1, &argv[optind]);\n}\n"
        ],
        "134735225": [
            "sub_807E579",
            "0x807e579",
            "int __cdecl sub_807E579(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // ecx\n  char v4; // si\n  int v5; // esi\n  int v6; // ecx\n  int v7; // ecx\n  void *v8; // ebp\n  int v9; // ecx\n  unsigned int i; // edi\n  int v11; // eax\n  int v12; // ecx\n  int v13; // ecx\n  const char *v15; // [esp-8h] [ebp-7Ch]\n  unsigned int v16; // [esp-4h] [ebp-78h]\n  int v17; // [esp+0h] [ebp-74h]\n  int v18; // [esp+4h] [ebp-70h] BYREF\n  int v19; // [esp+8h] [ebp-6Ch] BYREF\n  unsigned int v20; // [esp+Ch] [ebp-68h] BYREF\n  unsigned int v21; // [esp+10h] [ebp-64h] BYREF\n  char s[96]; // [esp+14h] [ebp-60h] BYREF\n\n  v20 = 2;\n  v21 = 0;\n  v2 = sub_80AAA6C();\n  v4 = sub_80ABEAC(a2, \"^l:s:apg:+c:+\", &v18, &v19, &v20, &v21);\n  v17 = a2 + 4 * optind;\n  *(_BYTE *)(v2 + 12) = 0;\n  if ( (v4 & 1) != 0 )\n    *(_DWORD *)(v2 + 8) = sub_80B4093(0x7FFFFFFF);\n  if ( (v4 & 2) != 0 )\n    *(_QWORD *)v2 = sub_80B3F1E(0, 0, -1, 0x7FFFFFFF);\n  v5 = v4 & 8;\n  if ( v5 )\n  {\n    if ( !v21 )\n      v21 = 30;\n    v20 = v21;\n  }\n  else\n  {\n    if ( !v21 )\n      v21 = 16;\n    sub_80AAFEF(v3, \"\\\"%08.8_ax: \\\"\");\n  }\n  if ( !v20 || v20 >= v21 )\n  {\n    v16 = v21;\n    v15 = \"%u/1 \\\"%%02x\\\"\";\nLABEL_17:\n    sprintf(s, v15, v16, v17);\n    sub_80AAFEF(v6, s);\n    goto LABEL_26;\n  }\n  if ( v20 == 1 )\n  {\n    v16 = v21;\n    v15 = \"%u/1 \\\"%%02x \\\"\";\n    goto LABEL_17;\n  }\n  v8 = sub_804DAFA(10 * v21);\n  v9 = (int)v8;\n  for ( i = 1; v21 >= i; ++i )\n  {\n    if ( v21 == i || i % v20 )\n      v11 = stpcpy(v9, \"/1 \\\"%02x\\\"\");\n    else\n      v11 = stpcpy(v9, 135082001);\n    v9 = v11;\n  }\n  sub_80AAFEF(v9, v8);\n  free(v8);\nLABEL_26:\n  if ( v5 )\n  {\n    sub_80AAFEF(v7, \"\\\"\\n\\\"\");\n  }\n  else\n  {\n    sprintf(s, \"\\\"  \\\"%u/1 \\\"%%_p\\\"\\\"\\n\\\"\", v21);\n    sub_80AAFEF(v12, s);\n  }\n  return sub_80AAA86(v13, v17);\n}\n"
        ],
        "134735632": [
            "sub_807E710",
            "0x807e710",
            "int __cdecl sub_807E710(int a1, int a2)\n{\n  char v2; // di\n  int v3; // esi\n  int v4; // eax\n  int v5; // ebp\n  struct tm *v6; // ecx\n  char *v7; // ebx\n  int v9; // [esp+0h] [ebp-58h] BYREF\n  struct timeval tv; // [esp+4h] [ebp-54h] BYREF\n  struct timezone v11; // [esp+Ch] [ebp-4Ch] BYREF\n  struct timeval v12; // [esp+14h] [ebp-44h] BYREF\n  struct tm tp; // [esp+1Ch] [ebp-3Ch] BYREF\n\n  v9 = 0;\n  tzset();\n  v2 = sub_80ABEC2(a2, \"^lurswtf:\", \"localtime\", &v9);\n  if ( (v2 & 3) != 0 )\n    v3 = v2 & 2;\n  else\n    v3 = sub_80B29EC(v9);\n  if ( (v2 & 8) != 0 )\n  {\n    v11.tz_minuteswest = timezone / 60;\n    v11.tz_dsttime = 0;\n    sub_80B2A42();\n    sub_80B2AC7();\n    tv.tv_sec = sub_80B2AF7();\n    tv.tv_usec = 0;\n    v4 = settimeofday(&tv, &v11);\nLABEL_6:\n    if ( v4 )\n      sub_804D3C9((int)\"settimeofday\");\n    return 0;\n  }\n  if ( (v2 & 0x10) == 0 )\n  {\n    if ( (v2 & 0x20) == 0 )\n    {\n      sub_80B2A42();\n      sub_80B2AC7();\n      tp.tm_sec = sub_80B2AF7();\n      v7 = ctime(&tp.tm_sec);\n      sub_80A9BE3();\n      printf(\"%s  0.000000 seconds\\n\", v7);\n      return 0;\n    }\n    gettimeofday(&v12, 0);\n    v6 = localtime(&v12.tv_sec);\n    tp.tm_sec = timezone / 60;\n    if ( v6->tm_isdst > 0 )\n      tp.tm_sec = timezone / 60 - 60;\n    tp.tm_min = 0;\n    gettimeofday(&v12, 0);\n    if ( !v3 )\n      v12.tv_sec += 60 * tp.tm_sec;\n    v4 = settimeofday(&v12, (const struct timezone *)&tp);\n    goto LABEL_6;\n  }\n  v5 = sub_80B2A42();\n  gettimeofday(&v12, 0);\n  if ( v3 )\n    gmtime_r(&v12.tv_sec, &tp);\n  else\n    localtime_r(&v12.tv_sec, &tp);\n  tp.tm_isdst = 0;\n  sub_804E0BE(v5, 0x4024700Au, (int)&tp, \"RTC_SET_TIME\");\n  return 0;\n}\n"
        ],
        "134736060": [
            "sub_807E8BC",
            "0x807e8bc",
            "int __cdecl sub_807E8BC(int argc, char **argv)\n{\n  char *v2; // edx\n  char v3; // al\n  bool v4; // zf\n  int v5; // edi\n  const char **v6; // esi\n  int v7; // ebx\n  int v8; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // ebp\n  key_t v12; // eax\n  int v13; // eax\n  int v14; // edx\n  const char *v15; // eax\n  int v16; // eax\n  const char *v17; // ecx\n  int v18; // edx\n  const char *v19; // eax\n\n  if ( argc == 1 )\n    return 0;\n  v2 = argv[1];\n  v3 = *v2;\n  if ( *v2 == 109 )\n  {\n    if ( v2[1] != 115 )\n    {\nLABEL_34:\n      v7 = 0;\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v10 = getopt(argc, argv, \"q:m:s:Q:M:S:\");\n          v11 = v10;\n          if ( v10 == -1 )\n          {\n            if ( optind == argc )\n              return v7;\nLABEL_12:\n            sub_804CDC2();\n          }\n          if ( v10 == 63 )\n            goto LABEL_12;\n          if ( (v10 & 0x20) == 0 )\n            break;\n          v13 = sub_80B40EC();\n          if ( v11 != 113 )\n          {\n            if ( v11 == 109 )\n              goto LABEL_55;\nLABEL_57:\n            v16 = semctl(v13, 0, 0, 0);\n            goto LABEL_58;\n          }\nLABEL_53:\n          v16 = msgctl(v13, 0, 0);\nLABEL_58:\n          if ( v16 )\n          {\n            v17 = \"t\\tchange a partition's system id\" + 30;\n            if ( (v11 & 0x20) == 0 )\n              v17 = \"error: '%s' is an unknown key\" + 26;\n            ++v7;\n            v18 = *(_DWORD *)dword_80DBB7C;\n            if ( *(_DWORD *)dword_80DBB7C == 13 )\n            {\nLABEL_68:\n              v19 = (const char *)&unk_80D31E2;\n              goto LABEL_70;\n            }\n            if ( *(int *)dword_80DBB7C <= 13 )\n            {\n              if ( v18 == 1 )\n                goto LABEL_68;\nLABEL_69:\n              v19 = \"unknown error in\";\n              goto LABEL_70;\n            }\n            v19 = \"invalid\";\n            if ( v18 != 22 )\n            {\n              v19 = \"already removed\";\n              if ( v18 != 43 )\n                goto LABEL_69;\n            }\nLABEL_70:\n            sub_804D5F4(\"%s %s (%s)\", v19, v17, optarg);\n          }\n        }\n        v12 = sub_80B40AC();\n        if ( v12 )\n        {\n          if ( (v11 | 0x20) != 113 )\n          {\n            if ( (v11 | 0x20) == 109 )\n            {\n              v13 = shmget(v12, 0, 0);\n              if ( v13 < 0 )\n                goto LABEL_42;\nLABEL_55:\n              v16 = shmctl(v13, 0, 0);\n              goto LABEL_58;\n            }\n            v13 = semget(v12, 0, 0);\n            if ( v13 < 0 )\n              goto LABEL_42;\n            goto LABEL_57;\n          }\n          v13 = msgget(v12, 0);\n          if ( v13 >= 0 )\n            goto LABEL_53;\nLABEL_42:\n          ++v7;\n          v14 = *(_DWORD *)dword_80DBB7C;\n          v15 = (const char *)&unk_80D31E2;\n          if ( *(_DWORD *)dword_80DBB7C != 13 )\n          {\n            v15 = \"already removed\";\n            if ( v14 != 43 )\n            {\n              v15 = \"invalid\";\n              if ( v14 != 2 )\n                v15 = \"unknown error in\";\n            }\n          }\n          sub_804D5F4(\"%s %s (%s)\", v15, \"key\", optarg);\n        }\n        else\n        {\n          ++v7;\n          sub_804D5F4(\"illegal key (%s)\", optarg);\n        }\n      }\n    }\n    v4 = v2[2] == 103;\n  }\n  else\n  {\n    if ( v3 != 115 )\n      goto LABEL_34;\n    v3 = v2[1];\n    if ( v3 != 101 && v3 != 104 )\n      goto LABEL_34;\n    v4 = v2[2] == 109;\n  }\n  if ( !v4 || v2[3] )\n    goto LABEL_34;\n  if ( argc <= 2 )\n    goto LABEL_12;\n  v5 = 0;\n  if ( v3 != 104 )\n  {\n    v5 = 2;\n    if ( v3 != 109 )\n      v5 = v3 == 101;\n  }\n  v6 = (const char **)(argv + 2);\n  v7 = 0;\n  while ( *v6 )\n  {\n    v8 = sub_804ED6C(10, *v6, 0, v7);\n    if ( *(_DWORD *)dword_80DBB7C || v8 < 0 )\n    {\n      sub_804D5F4(\"invalid id: %s\", *v6);\nLABEL_29:\n      ++v7;\n      goto LABEL_30;\n    }\n    if ( v5 == 1 )\n    {\n      v9 = semctl(v8, 0, 0, 0);\n    }\n    else if ( v5 == 2 )\n    {\n      v9 = msgctl(v8, 0, 0);\n    }\n    else\n    {\n      if ( v5 )\n        goto LABEL_30;\n      v9 = shmctl(v8, 0, 0);\n    }\n    if ( v9 )\n    {\n      sub_804D3A5((int)\"can't remove id %s\", *v6);\n      goto LABEL_29;\n    }\nLABEL_30:\n    ++v6;\n  }\n  if ( v7 )\n    sub_80AB247();\n  puts(\"resource(s) deleted\");\n  return v7;\n}\n"
        ],
        "134736749": [
            "sub_807EB6D",
            "0x807eb6d",
            "__int64 __usercall sub_807EB6D@<edx:eax>(int a1@<eax>, __uid_t *a2@<edx>)\n{\n  struct group *v3; // eax\n  __int64 v5; // [esp-8h] [ebp-Ch]\n\n  printf(\"%-10d %-10o\", a1, a2[5] & 0x1FF);\n  if ( getpwuid(a2[3]) )\n    printf(\" %-10s\");\n  else\n    printf(\" %-10d\");\n  if ( getgrgid(a2[4]) )\n    printf(\" %-10s\");\n  else\n    printf(\" %-10d\");\n  if ( getpwuid(a2[1]) )\n    printf(\" %-10s\");\n  else\n    printf(\" %-10d\");\n  v3 = getgrgid(a2[2]);\n  if ( v3 )\n    printf(\" %-10s\\n\", v3->gr_name);\n  else\n    printf(\" %-10d\\n\", a2[2]);\n  return v5;\n}\n"
        ],
        "134736925": [
            "sub_807EC1D",
            "0x807ec1d",
            "int __usercall sub_807EC1D@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // ebp\n  int i; // esi\n  int v6; // ebx\n  struct passwd *v7; // eax\n  const char *v8; // eax\n  const char *v9; // eax\n  const char *v10; // eax\n  struct passwd *v11; // [esp+0h] [ebp-8Ch]\n  struct msqid_ds buf; // [esp+4h] [ebp-88h] BYREF\n  int v13; // [esp+60h] [ebp-2Ch]\n  int v14; // [esp+64h] [ebp-28h]\n  int v15; // [esp+6Ch] [ebp-20h]\n  int v16; // [esp+70h] [ebp-1Ch]\n\n  v2 = msgctl(0, 12, &buf);\n  if ( v2 < 0 )\n    return printf(\"kernel not configured for %s\\n\", \"message queues\");\n  v4 = v2;\n  switch ( a1 )\n  {\n    case 1:\n      result = msgctl(0, 3, &buf);\n      if ( result >= 0 )\n      {\n        printf(\"------ Message%s --------\\n\", \"s: Limits\");\n        return printf(\n                 \"max queues system wide = %d\\n\"\n                 \"max size of message (bytes) = %d\\n\"\n                 \"default max size of queue (bytes) = %d\\n\",\n                 buf.msg_perm.cgid,\n                 buf.msg_perm.gid,\n                 buf.msg_perm.cuid);\n      }\n      return result;\n    case 2:\n      printf(\"------ Message%s --------\\n\", \"s: Status\");\n      return printf(\n               \"allocated queues = %d\\nused headers = %d\\nused space = %d bytes\\n\",\n               buf.msg_perm.__key,\n               buf.msg_perm.uid,\n               *(_DWORD *)&buf.msg_perm.__seq);\n    case 3:\n      printf(\"------ Message%s --------\\n\", \" Queues: Creators/Owners\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s %-10s\\n\", \"msqid\", \"perms\", \"cuid\", \"cgid\", \"uid\", 135036634);\n      goto LABEL_10;\n    case 4:\n      printf(\"------ Message%s --------\\n\", \" Queues Send/Recv/Change Times\");\n      printf(\"%-8s %-10s %-20s %-20s %-20s\\n\", \"msqid\", \"owner\", \"send\", \"recv\", \"change\");\n      goto LABEL_10;\n    case 5:\n      printf(\"------ Message%s --------\\n\", \" Queues PIDs\");\n      printf(\"%-10s %-10s %-10s %-10s\\n\", \"msqid\", \"owner\", \"lspid\", \"lrpid\");\n      goto LABEL_10;\n    default:\n      printf(\"------ Message%s --------\\n\", \" Queues\");\n      printf(\"%-10s %-10s %-10s %-10s %-12s %-12s\\n\", 135069882, \"msqid\", \"owner\", \"perms\", \"used-bytes\", \"messages\");\nLABEL_10:\n      for ( i = 0; i <= v4; ++i )\n      {\n        result = msgctl(i, 11, (struct msqid_ds *)&buf.msg_perm.__unused2);\n        v6 = result;\n        if ( result >= 0 )\n        {\n          if ( a1 == 3 )\n          {\n            result = sub_807EB6D(result, &buf.msg_perm.__unused2);\n          }\n          else\n          {\n            v7 = getpwuid(buf.msg_stime);\n            if ( a1 == 4 )\n            {\n              if ( v7 )\n                printf(\"%-8d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-8d %-10d\", v6, buf.msg_stime);\n              v8 = \"Not set\";\n              if ( buf.msg_qbytes )\n                v8 = ctime((const time_t *)&buf.msg_qbytes) + 4;\n              printf(\" %-20.16s\", v8);\n              v9 = \"Not set\";\n              if ( buf.msg_lrpid )\n                v9 = ctime(&buf.msg_lrpid) + 4;\n              printf(\" %-20.16s\", v9);\n              v10 = \"Not set\";\n              if ( buf.__unused5 )\n                v10 = ctime((const time_t *)&buf.__unused5) + 4;\n              result = printf(\" %-20.16s\\n\", v10);\n            }\n            else if ( a1 == 5 )\n            {\n              if ( v7 )\n                printf(\"%-8d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-8d %-10d\", v6, buf.msg_stime);\n              result = printf(\"  %5d     %5d\\n\", v15, v16);\n            }\n            else\n            {\n              v11 = v7;\n              printf(\"0x%08x \", buf.msg_perm.__unused2);\n              if ( v11 )\n                printf(\"%-10d %-10.10s\", v6, v11->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, buf.msg_stime);\n              result = printf(\" %-10o %-12ld %-12ld\\n\", buf.msg_ctime & 0x1FF, v13, v14);\n            }\n          }\n        }\n      }\n      break;\n  }\n  return result;\n}\n"
        ],
        "134737716": [
            "sub_807EF34",
            "0x807ef34",
            "int __usercall sub_807EF34@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  int v4; // ebp\n  int i; // esi\n  int v6; // ebx\n  struct passwd *v7; // eax\n  const char *v8; // eax\n  const char *v9; // eax\n  const char *v10; // eax\n  const char *v11; // ecx\n  const char *v12; // edx\n  struct passwd *v13; // [esp+0h] [ebp-80h]\n  int v14[6]; // [esp+4h] [ebp-7Ch] BYREF\n  __uid_t v15; // [esp+1Ch] [ebp-64h] BYREF\n  __uid_t uid; // [esp+20h] [ebp-60h]\n  int v17; // [esp+24h] [ebp-5Ch]\n  int v18; // [esp+2Ch] [ebp-54h]\n  int v19; // [esp+30h] [ebp-50h]\n  int v20; // [esp+40h] [ebp-40h]\n  time_t timer; // [esp+44h] [ebp-3Ch] BYREF\n  time_t v22; // [esp+4Ch] [ebp-34h] BYREF\n  time_t v23; // [esp+54h] [ebp-2Ch] BYREF\n  int v24; // [esp+5Ch] [ebp-24h]\n  int v25; // [esp+60h] [ebp-20h]\n  int v26; // [esp+64h] [ebp-1Ch]\n\n  v2 = shmctl(0, 14, v14);\n  if ( v2 < 0 )\n    return printf(\"kernel not configured for %s\\n\", \"shared memory\");\n  v4 = v2;\n  switch ( a1 )\n  {\n    case 1:\n      printf(\"------ Shared Memory %s --------\\n\", \"Limits\");\n      result = shmctl(0, 3, &v15);\n      if ( result >= 0 )\n        return printf(\n                 \"max number of segments = %lu\\n\"\n                 \"max seg size (kbytes) = %lu\\n\"\n                 \"max total shared memory (pages) = %lu\\n\"\n                 \"min seg size (bytes) = %lu\\n\",\n                 v17,\n                 v15 >> 10,\n                 v18,\n                 uid);\n      return result;\n    case 2:\n      printf(\"------ Shared Memory %s --------\\n\", \"Status\");\n      return printf(\n               \"segments allocated %d\\n\"\n               \"pages allocated %lu\\n\"\n               \"pages resident  %lu\\n\"\n               \"pages swapped   %lu\\n\"\n               \"Swap performance: %lu attempts\\t%lu successes\\n\",\n               v14[0],\n               v14[1],\n               v14[2],\n               v14[3],\n               v14[4],\n               v14[5]);\n    case 3:\n      printf(\"------ Shared Memory %s --------\\n\", \"Segment Creators/Owners\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s %-10s\\n\", \"shmid\", \"perms\", \"cuid\", \"cgid\", \"uid\", \"gid\");\n      goto LABEL_9;\n    case 4:\n      printf(\"------ Shared Memory %s --------\\n\", \"Attach/Detach/Change Times\");\n      printf(\"%-10s %-10s %-20s %-20s %-20s\\n\", \"shmid\", \"owner\", \"attached\", \"detached\", \"changed\");\n      goto LABEL_9;\n    case 5:\n      printf(\"------ Shared Memory %s --------\\n\", \"Creator/Last-op\");\n      printf(\"%-10s %-10s %-10s %-10s\\n\", \"shmid\", \"owner\", \"cpid\", \"lpid\");\n      goto LABEL_9;\n    default:\n      printf(\"------ Shared Memory %s --------\\n\", \"Segments\");\n      printf(\n        \"%-10s %-10s %-10s %-10s %-10s %-10s %-12s\\n\",\n        \"key\",\n        \"shmid\",\n        \"owner\",\n        \"perms\",\n        \"bytes\",\n        \"nattch\",\n        \"status\");\nLABEL_9:\n      for ( i = 0; i <= v4; ++i )\n      {\n        result = shmctl(i, 13, &v15);\n        v6 = result;\n        if ( result >= 0 )\n        {\n          if ( a1 == 3 )\n          {\n            result = sub_807EB6D(result, &v15);\n          }\n          else\n          {\n            v7 = getpwuid(uid);\n            if ( a1 == 4 )\n            {\n              if ( v7 )\n                printf(\"%-10d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, uid);\n              v8 = \"Not set\";\n              if ( timer )\n                v8 = ctime(&timer) + 4;\n              printf(\" %-20.16s\", v8);\n              v9 = \"Not set\";\n              if ( v22 )\n                v9 = ctime(&v22) + 4;\n              printf(\" %-20.16s\", v9);\n              v10 = \"Not set\";\n              if ( v23 )\n                v10 = ctime(&v23) + 4;\n              result = printf(\" %-20.16s\\n\", v10);\n            }\n            else if ( a1 == 5 )\n            {\n              if ( v7 )\n                printf(\"%-10d %-10.10s\", v6, v7->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, uid);\n              result = printf(\" %-10d %-10d\\n\", v24, v25);\n            }\n            else\n            {\n              v13 = v7;\n              printf(\"0x%08x \", v15);\n              if ( v13 )\n                printf(\"%-10d %-10.10s\", v6, v13->pw_name);\n              else\n                printf(\"%-10d %-10d\", v6, uid);\n              v11 = \"password for %s is already %slocked\" + 29;\n              if ( (v19 & 0x400) == 0 )\n                v11 = \"     \" + 4;\n              v12 = \"dest\";\n              if ( (v19 & 0x200) == 0 )\n                v12 = \"     \" + 4;\n              result = printf(\" %-10o %-10lu %-10ld %-6s %-6s\\n\", v19 & 0x1FF, v20, v26, v12, v11);\n            }\n          }\n        }\n      }\n      break;\n  }\n  return result;\n}\n"
        ],
        "134738580": [
            "sub_807F294",
            "0x807f294",
            "struct passwd *__usercall sub_807F294@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  struct passwd *result; // eax\n  int v4; // ebp\n  int i; // esi\n  struct passwd *v6; // ebx\n  char *v7; // eax\n  char *v8; // eax\n  struct passwd *v9; // [esp+0h] [ebp-7Ch]\n  char v10[4]; // [esp+4h] [ebp-78h] BYREF\n  int v11; // [esp+8h] [ebp-74h]\n  int v12; // [esp+Ch] [ebp-70h]\n  int v13; // [esp+14h] [ebp-68h]\n  int v14; // [esp+18h] [ebp-64h]\n  int v15; // [esp+20h] [ebp-5Ch]\n  int v16; // [esp+24h] [ebp-58h]\n  int v17; // [esp+28h] [ebp-54h]\n  __uid_t v18; // [esp+2Ch] [ebp-50h] BYREF\n  __uid_t uid; // [esp+30h] [ebp-4Ch]\n  int v20; // [esp+40h] [ebp-3Ch]\n  time_t timer; // [esp+50h] [ebp-2Ch] BYREF\n  time_t v22; // [esp+58h] [ebp-24h] BYREF\n  int v23; // [esp+60h] [ebp-1Ch]\n\n  v2 = semctl(0, 0, 19, v10);\n  if ( v2 < 0 )\n    return (struct passwd *)printf(\"kernel not configured for %s\\n\", \"semaphores\");\n  v4 = v2;\n  switch ( a1 )\n  {\n    case 1:\n      printf(\"------ Semaphore %s --------\\n\", \"Limits\");\n      result = (struct passwd *)semctl(0, 0, 3, v10);\n      if ( (int)result >= 0 )\n        return (struct passwd *)printf(\n                                  \"max number of arrays = %d\\n\"\n                                  \"max semaphores per array = %d\\n\"\n                                  \"max semaphores system wide = %d\\n\"\n                                  \"max ops per semop call = %d\\n\"\n                                  \"semaphore max value = %d\\n\",\n                                  v11,\n                                  v13,\n                                  v12,\n                                  v14,\n                                  v16);\n      return result;\n    case 2:\n      printf(\"------ Semaphore %s --------\\n\", \"Status\");\n      return (struct passwd *)printf(\"used arrays = %d\\nallocated semaphores = %d\\n\", v15, v17);\n    case 3:\n      printf(\"------ Semaphore %s --------\\n\", \"Arrays Creators/Owners\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s %-10s\\n\", \"semid\", \"perms\", \"cuid\", \"cgid\", \"uid\", \"gid\");\n      goto LABEL_9;\n    case 4:\n      printf(\"------ Shared Memory %s --------\\n\", \"Operation/Change Times\");\n      printf(\"%-8s %-10s %-26.24s %-26.24s\\n\", \"shmid\", \"owner\", \"last-op\", \"last-changed\");\n      goto LABEL_9;\n    case 5:\n      goto LABEL_9;\n    default:\n      printf(\"------ Semaphore %s --------\\n\", \"Arrays\");\n      printf(\"%-10s %-10s %-10s %-10s %-10s\\n\", \"key\", \"semid\", \"owner\", \"perms\", \"nsems\");\nLABEL_9:\n      for ( i = 0; i <= v4; ++i )\n      {\n        result = (struct passwd *)semctl(i, 0, 18, &v18);\n        v6 = result;\n        if ( (int)result >= 0 )\n        {\n          if ( a1 == 3 )\n          {\n            result = (struct passwd *)sub_807EB6D((int)result, &v18);\n          }\n          else\n          {\n            result = getpwuid(uid);\n            if ( a1 == 4 )\n            {\n              if ( result )\n                printf(\"%-8d %-10.10s\", v6, result->pw_name);\n              else\n                printf(\"%-8d %-10d\", v6, uid);\n              v7 = \"Not set\";\n              if ( timer )\n                v7 = ctime(&timer);\n              printf(\"  %-26.24s\", v7);\n              v8 = \"Not set\";\n              if ( v22 )\n                v8 = ctime(&v22);\n              result = (struct passwd *)printf(\" %-26.24s\\n\", v8);\n            }\n            else if ( a1 != 5 )\n            {\n              v9 = result;\n              printf(\"0x%08x \", v18);\n              if ( v9 )\n                printf(\"%-10d %-10.9s\", v6, v9->pw_name);\n              else\n                printf(\"%-10d %-9d\", v6, uid);\n              result = (struct passwd *)printf(\" %-10o %-10ld\\n\", v20 & 0x1FF, v23);\n            }\n          }\n        }\n      }\n      break;\n  }\n  return result;\n}\n"
        ],
        "134739216": [
            "sub_807F510",
            "0x807f510",
            "void __cdecl __noreturn sub_807F510(int a1, int a2)\n{\n  unsigned int v2; // edi\n  int v3; // ebx\n  int v4; // ebx\n  unsigned int v5; // esi\n  char *v6; // eax\n  char *v7; // eax\n  char *v8; // eax\n  char *v9; // eax\n  char *v10; // eax\n  int v11; // ebp\n  int v12; // eax\n  char *v13; // eax\n  char *v14; // eax\n  char *v15; // eax\n  int v16; // [esp+0h] [ebp-74h]\n  int v17; // [esp+4h] [ebp-70h]\n  int v18; // [esp+8h] [ebp-6Ch] BYREF\n  struct msqid_ds buf; // [esp+Ch] [ebp-68h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"i:aqsmtcplu\", &v18);\n  v3 = (v2 >> 3) & 4;\n  if ( (v2 & 0x40) != 0 )\n    v3 = 3;\n  if ( (v2 & 0x80) != 0 )\n    v3 = 5;\n  if ( (v2 & 0x100) != 0 )\n    v3 = 1;\n  if ( (v2 & 0x200) != 0 )\n    v3 = 2;\n  if ( (v2 & 1) != 0 )\n  {\n    v4 = sub_80B4170();\n    v5 = v2 & 0x10;\n    if ( (v2 & 0x10) != 0 )\n    {\n      if ( shmctl(v4, 2, &buf) == -1 )\n      {\n        sub_804D3A5((int)\"shmctl\");\n      }\n      else\n      {\n        printf(\n          \"\\n\"\n          \"Shared memory Segment shmid=%d\\n\"\n          \"uid=%d\\tgid=%d\\tcuid=%d\\tcgid=%d\\n\"\n          \"mode=%#o\\taccess_perms=%#o\\n\"\n          \"bytes=%ld\\tlpid=%d\\tcpid=%d\\tnattch=%ld\\n\",\n          v4,\n          buf.msg_perm.uid,\n          buf.msg_perm.gid,\n          buf.msg_perm.cuid,\n          buf.msg_perm.cgid,\n          buf.msg_perm.mode,\n          buf.msg_perm.mode & 0x1FF,\n          buf.msg_stime,\n          buf.msg_qbytes,\n          buf.msg_qnum,\n          buf.msg_lspid);\n        v6 = \"Not set\";\n        if ( buf.__unused1 )\n          v6 = ctime((const time_t *)&buf.__unused1);\n        printf(\"att_time=%-26.24s\\n\", v6);\n        v7 = \"Not set\";\n        if ( buf.__unused2 )\n          v7 = ctime((const time_t *)&buf.__unused2);\n        printf(\"det_time=%-26.24s\\n\", v7);\n        v8 = ctime((const time_t *)&buf.__unused3);\n        printf(\"change_time=%-26.24s\\n\\n\", v8);\n      }\n      goto LABEL_18;\n    }\n    if ( (v2 & 8) != 0 )\n    {\n      if ( semctl(v4, 0, 2, &buf) )\n      {\n        sub_804D3A5((int)\"semctl\");\n        goto LABEL_18;\n      }\n      v9 = \"Not set\";\n      if ( buf.msg_stime )\n        v9 = ctime(&buf.msg_stime);\n      printf(\n        \"\\n\"\n        \"Semaphore Array semid=%d\\n\"\n        \"uid=%d\\t gid=%d\\t cuid=%d\\t cgid=%d\\n\"\n        \"mode=%#o, access_perms=%#o\\n\"\n        \"nsems = %ld\\n\"\n        \"otime = %-26.24s\\n\",\n        v4,\n        buf.msg_perm.uid,\n        buf.msg_perm.gid,\n        buf.msg_perm.cuid,\n        buf.msg_perm.cgid,\n        buf.msg_perm.mode,\n        buf.msg_perm.mode & 0x1FF,\n        buf.msg_ctime,\n        v9);\n      v10 = ctime(&buf.msg_rtime);\n      printf(\"ctime = %-26.24s\\n%-10s %-10s %-10s %-10s %-10s\\n\", v10, \"semnum\", \"value\", \"ncount\", \"zcount\", \"pid\");\n      while ( v5 < buf.msg_ctime )\n      {\n        v16 = semctl(v4, v5, 12, 0);\n        v17 = semctl(v4, v5, 14, 0);\n        v11 = semctl(v4, v5, 15, 0);\n        v12 = semctl(v4, v5, 11, 0);\n        if ( v11 < 0 || v16 < 0 || v17 < 0 || v12 < 0 )\n          sub_804D3C9((int)\"semctl\");\n        printf(\"%-10u %-10d %-10d %-10d %-10d\\n\", v5++, v16, v17, v11, v12);\n      }\n      goto LABEL_50;\n    }\n    if ( (v2 & 4) == 0 )\n      sub_804CDC2();\n    if ( msgctl(v4, 2, &buf) == -1 )\n    {\n      sub_804D3A5((int)\"msgctl\");\n    }\n    else\n    {\n      printf(\n        \"\\n\"\n        \"Message Queue msqid=%d\\n\"\n        \"uid=%d\\tgid=%d\\tcuid=%d\\tcgid=%d\\tmode=%#o\\n\"\n        \"cbytes=%ld\\tqbytes=%ld\\tqnum=%ld\\tlspid=%d\\tlrpid=%d\\n\",\n        v4,\n        buf.msg_perm.uid,\n        buf.msg_perm.gid,\n        buf.msg_perm.cuid,\n        buf.msg_perm.cgid,\n        buf.msg_perm.mode,\n        buf.__msg_cbytes,\n        buf.msg_qbytes,\n        buf.msg_qnum,\n        buf.msg_lspid,\n        buf.msg_lrpid);\n      v13 = \"Not set\";\n      if ( buf.msg_stime )\n        v13 = ctime(&buf.msg_stime);\n      printf(\"send_time=%-26.24s\\n\", v13);\n      v14 = \"Not set\";\n      if ( buf.msg_rtime )\n        v14 = ctime(&buf.msg_rtime);\n      printf(\"rcv_time=%-26.24s\\n\", v14);\n      v15 = \"Not set\";\n      if ( buf.msg_ctime )\n        v15 = ctime(&buf.msg_ctime);\n      printf(\"change_time=%-26.24s\\n\\n\", v15);\n    }\n  }\n  else\n  {\n    if ( (v2 & 2) != 0 || (v2 & 0x1C) == 0 )\n      LOBYTE(v2) = v2 | 0x1C;\n    sub_804DD98(10);\n    if ( (v2 & 4) != 0 )\n    {\n      sub_807EC1D(v3);\n      sub_804DD98(10);\n    }\n    if ( (v2 & 0x10) != 0 )\n    {\n      sub_807EF34(v3);\n      sub_804DD98(10);\n    }\n    if ( (v2 & 8) != 0 )\n    {\n      sub_807F294(v3);\nLABEL_50:\n      sub_804DD98(10);\n    }\n  }\nLABEL_18:\n  sub_80AB247();\n}\n"
        ],
        "134740143": [
            "sub_807F8AF",
            "0x807f8af",
            "void __cdecl __noreturn sub_807F8AF(int a1, int a2)\n{\n  int v2; // ebx\n  __int64 v3; // rax\n  unsigned int v4; // edi\n  unsigned int i; // esi\n  __int64 v6; // kr00_8\n  ssize_t v7; // eax\n  int v8; // eax\n  char *v9; // eax\n  int v10; // [esp+0h] [ebp-19Ch]\n  time_t timer; // [esp+8h] [ebp-194h] BYREF\n  int buf; // [esp+Ch] [ebp-190h] BYREF\n  char dest[36]; // [esp+14h] [ebp-188h] BYREF\n  char s1[32]; // [esp+38h] [ebp-164h] BYREF\n  char v15[264]; // [esp+58h] [ebp-144h] BYREF\n  time_t v16; // [esp+160h] [ebp-3Ch]\n\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  v2 = sub_804DBE1(\"/var/log/wtmp\");\n  printf(\"%-10s %-14s %-18s %-12.12s %s\\n\", \"USER\", \"TTY\", \"HOST\", \"LOGIN\", \"TIME\");\n  LODWORD(v3) = sub_804DD09(v2, 0, 0, 2);\n  v6 = lseek64(v2, (int)v3 - 384, (unsigned __int64)(v3 - 384) >> 32, 0);\n  v4 = HIDWORD(v6);\n  for ( i = v6; ; sub_804DD09(v2, i, v4, 0) )\n  {\n    v7 = sub_804E5E3(0x180u, (char *)&buf, v2);\n    if ( v7 <= 0 )\nLABEL_31:\n      sub_80AB247();\n    if ( v7 != 384 )\n      sub_804D3C9((int)\"short read\");\n    v10 = sub_804D222(\"~\", dest);\n    if ( v10 )\n    {\n      if ( !s1[0] || !strcmp(s1, \"LOGIN\") )\n        goto LABEL_30;\n      if ( (_WORD)buf != 8 && dest[0] )\n        LOWORD(buf) = 7;\n      if ( !strcmp(s1, \"date\") )\n      {\n        if ( v10 == 2 )\n        {\n          LOWORD(buf) = 4;\n        }\n        else if ( v10 == 1 )\n        {\n          LOWORD(buf) = 3;\n        }\n      }\n    }\n    else\n    {\n      v8 = sub_804D222(\"runlevel\", s1) + 1;\n      if ( v8 > 0 )\n      {\n        if ( v8 == 3 )\n          LOWORD(v8) = 254;\n        LOWORD(buf) = v8;\n      }\n    }\n    if ( (_WORD)buf == 7 )\n      goto LABEL_29;\n    if ( (__int16)buf > 4 )\n    {\n      if ( (_WORD)buf == 254 )\n        goto LABEL_30;\n      goto LABEL_29;\n    }\n    if ( (__int16)buf < 3 && (_WORD)buf != 1 )\n    {\n      if ( (_WORD)buf == 2 )\n        strcpy(dest, \"system boot\");\nLABEL_29:\n      timer = v16;\n      v9 = ctime(&timer);\n      printf(\"%-10s %-14s %-18s %-12.12s\\n\", s1, dest, v15, v9 + 4);\n    }\nLABEL_30:\n    v4 = (__PAIR64__(v4, i) - 384) >> 32;\n    i -= 384;\n    if ( __SPAIR64__(v4, i) <= 0 )\n      goto LABEL_31;\n  }\n}\n"
        ],
        "134740623": [
            "sub_807FA8F",
            "0x807fa8f",
            "int __cdecl sub_807FA8F(int a1, int a2)\n{\n  unsigned int v2; // esi\n  const char **v3; // ebx\n  const char *v4; // eax\n  int i; // ebx\n  const char *v6; // eax\n  char *v7; // esi\n  int v8; // eax\n  int v9; // eax\n  int v10; // edx\n  int v12; // [esp+0h] [ebp-38h]\n  void *v13; // [esp+4h] [ebp-34h]\n  int v14; // [esp+8h] [ebp-30h] BYREF\n  char *v15; // [esp+Ch] [ebp-2Ch]\n  char s[39]; // [esp+11h] [ebp-27h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^do:far\", &v14);\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( !v2 )\n  {\n    if ( *v3 && !v3[1] )\n    {\n      v4 = (const char *)sub_80AFD97();\n      if ( v4 )\n      {\n        printf(\"%s: %s\\n\", *v3, v4);\n        return 0;\n      }\nLABEL_32:\n      sub_804D3FF(*v3);\n    }\n    goto LABEL_16;\n  }\n  if ( v2 == 1 )\n  {\n    if ( *v3 )\n    {\n      if ( !sub_80AFDF4() )\n        return 0;\n      goto LABEL_32;\n    }\nLABEL_16:\n    if ( (v2 & 4) != 0 )\n    {\n      v8 = 0;\n      while ( 1 )\n      {\n        v12 = v8 + 1;\n        sprintf(s, \"/dev/loop%u\", v8);\n        v13 = (void *)sub_80AFD97();\n        free(v13);\n        if ( !v13 )\n          break;\n        v8 = v12;\n        if ( v12 == 1024 )\n          sub_804D5E0(\"no free loop devices\");\n      }\n      if ( v2 == 4 && !*v3 )\n      {\n        puts(s);\n        return 0;\n      }\n    }\n    if ( !*v3 || (v2 & 4) == 0 && !v3[1] )\n      goto LABEL_33;\n    v15 = s;\n    if ( (v2 & 2) != 0 )\n    {\n      v9 = sub_80B3FAA();\n      if ( (v2 & 4) != 0 )\n        goto LABEL_30;\n    }\n    else\n    {\n      v9 = 0;\n      v10 = 0;\n      if ( (v2 & 4) != 0 )\n      {\nLABEL_31:\n        if ( (int)sub_80AFE28(v9, v10, (v2 >> 4) & 1) >= 0 )\n          return 0;\n        goto LABEL_32;\n      }\n    }\n    v15 = (char *)*v3++;\nLABEL_30:\n    if ( *v3 )\n      goto LABEL_31;\nLABEL_33:\n    sub_804CDC2();\n  }\n  if ( v2 != 8 )\n    goto LABEL_16;\n  for ( i = 0; i != 1023; ++i )\n  {\n    sprintf(s, \"/dev/loop%u\", i);\n    v6 = (const char *)sub_80AFD97();\n    v7 = (char *)v6;\n    if ( v6 )\n    {\n      printf(\"%s: %s\\n\", s, v6);\n      free(v7);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134741035": [
            "sub_807FC2B",
            "0x807fc2b",
            "int __userpurge sub_807FC2B@<eax>(int a1@<eax>, int a2@<ecx>, int a3)\n{\n  void *v3; // ebx\n  int v4; // ecx\n  int v5; // ebp\n  char *v6; // ebx\n  char *v7; // edi\n  int v8; // ecx\n  int v9; // ecx\n  int v11; // [esp-4h] [ebp-34h]\n  int v12; // [esp-4h] [ebp-34h]\n  int v13; // [esp-4h] [ebp-34h]\n  int v14; // [esp+0h] [ebp-30h]\n  unsigned int v15; // [esp+4h] [ebp-2Ch]\n  int v16; // [esp+8h] [ebp-28h]\n  int v17; // [esp+Ch] [ebp-24h]\n  char *s1; // [esp+14h] [ebp-1Ch]\n  const char *v19; // [esp+18h] [ebp-18h]\n  const char *v20; // [esp+1Ch] [ebp-14h]\n\n  v3 = (void *)sub_804D2D1(a1, \"/uevent\", a2);\n  sub_80B0511(v4, sub_80B3D37);\n  free(v3);\n  v16 = 0;\n  v17 = 0;\n  v5 = 0;\n  v14 = 0;\n  v15 = 0;\n  v6 = 0;\n  v7 = 0;\n  while ( sub_80B0560((char *)&byte_80D3C06) )\n  {\n    if ( !strcmp(s1, \"DRIVER\") )\n    {\n      v6 = sub_804DB46(v19);\n    }\n    else if ( !strcmp(s1, \"PCI_CLASS\") )\n    {\n      v15 = (unsigned int)sub_80B40AC(v11, 16) >> 8;\n    }\n    else if ( !strcmp(s1, \"PCI_ID\") )\n    {\n      v14 = sub_80B40AC(v12, 16);\n      v5 = sub_80B40AC(v8, 16);\n    }\n    else if ( !strcmp(s1, \"PCI_SUBSYS_ID\") )\n    {\n      v17 = sub_80B40AC(v13, 16);\n      v16 = sub_80B40AC(v9, 16);\n    }\n    else if ( !strcmp(s1, \"PCI_SLOT_NAME\") )\n    {\n      v7 = sub_804DB46(v20);\n    }\n  }\n  sub_80B0536();\n  if ( (dword_80DBB9C & 1) != 0 )\n    printf(\"%s \\\"Class %04x\\\" \\\"%04x\\\" \\\"%04x\\\" \\\"%04x\\\" \\\"%04x\\\"\", v7, v15, v14, v5, v17, v16);\n  else\n    printf(\"%s Class %04x: %04x:%04x\", v7, v15, v14, v5);\n  if ( (dword_80DBB9C & 2) != 0 && v6 )\n  {\n    if ( (dword_80DBB9C & 1) != 0 )\n      printf(\" \\\"%s\\\"\", v6);\n    else\n      printf(\" %s\", v6);\n  }\n  sub_804DD98(10);\n  free(v6);\n  free(v7);\n  return 1;\n}\n"
        ],
        "134741516": [
            "sub_807FE0C",
            "0x807fe0c",
            "int __cdecl sub_807FE0C(int a1, int a2)\n{\n  sub_80ABEAC(a2, \"mknv\");\n  sub_80B2549(0, 0, 0);\n  return 0;\n}\n"
        ],
        "134741561": [
            "sub_807FE39",
            "0x807fe39",
            "int __userpurge sub_807FE39@<eax>(int a1@<eax>, int a2@<ecx>, int a3)\n{\n  void *v3; // ebx\n  int v4; // ecx\n  int v5; // ebp\n  char *v6; // edi\n  char *v7; // ebx\n  int v8; // edx\n  int v9; // ecx\n  int v10; // eax\n  int v11; // ecx\n  int v13; // [esp-8h] [ebp-30h]\n  int v14; // [esp-4h] [ebp-2Ch]\n  int v15; // [esp-4h] [ebp-2Ch]\n  int v16; // [esp+0h] [ebp-28h]\n  int v17; // [esp+4h] [ebp-24h]\n  char *s1; // [esp+8h] [ebp-20h]\n  const char *v19; // [esp+Ch] [ebp-1Ch]\n\n  v3 = (void *)sub_804D2D1(a1, \"/uevent\", a2);\n  v5 = sub_80B0511(v4, sub_80B3D37);\n  free(v3);\n  v16 = 0;\n  v17 = 0;\n  v6 = 0;\n  v7 = 0;\n  while ( sub_80B0560(\"\\\\/=\") )\n  {\n    if ( *(_DWORD *)(v5 + 24) == 1 )\n    {\n      v10 = strcmp(s1, \"DEVTYPE\");\n      v8 = v13;\n      v9 = v14;\n      if ( !v10 )\n        break;\n    }\n    if ( !strcmp(s1, \"PRODUCT\") )\n    {\n      v17 = sub_80B40AC(v15, 16);\n      v16 = sub_80B40AC(v11, 16);\n    }\n    else if ( !strcmp(s1, \"BUSNUM\") )\n    {\n      v7 = sub_804DB46(v19);\n    }\n    else if ( !strcmp(s1, \"DEVNUM\") )\n    {\n      v6 = sub_804DB46(v19);\n    }\n  }\n  sub_80B0536(v9, v8);\n  if ( v7 )\n  {\n    printf(\"Bus %s Device %s: ID %04x:%04x\\n\", v7, v6, v17, v16);\n    free(v7);\n    free(v6);\n  }\n  return 1;\n}\n"
        ],
        "134741858": [
            "sub_807FF62",
            "0x807ff62",
            "int sub_807FF62()\n{\n  sub_80B2549(0, 0, 0);\n  return 0;\n}\n"
        ],
        "134741887": [
            "sub_807FF7F",
            "0x807ff7f",
            "int __stdcall sub_807FF7F(int a1)\n{\n  return (a1 > 2) + 1;\n}\n"
        ],
        "134741901": [
            "sub_807FF8D",
            "0x807ff8d",
            "int sub_807FF8D()\n{\n  int result; // eax\n\n  result = 0;\n  memset(&buf + 9, 0, 0x4Cu);\n  *((_QWORD *)&buf + 5) = -4294966864LL;\n  return result;\n}\n"
        ],
        "134741940": [
            "sub_807FFB4",
            "0x807ffb4",
            "int sub_807FFB4()\n{\n  int i; // ebx\n\n  free(seconds);\n  free((void *)n);\n  if ( *((_BYTE *)&buf + 37) )\n    regfree(&preg);\n  free(dword_80DB7C0);\n  for ( i = dword_80DB7E4; i; i = *(_DWORD *)i )\n  {\n    free(*(void **)(i + 4));\n    regfree((regex_t *)(i + 8));\n  }\n  return sub_807FF8D();\n}\n"
        ],
        "134742036": [
            "sub_8080014",
            "0x8080014",
            "__int64 sub_8080014()\n{\n  __int64 v1; // [esp-8h] [ebp-Ch]\n\n  umask(0x12u);\n  sub_80B00B9(4, 493);\n  umask(0);\n  return v1;\n}\n"
        ],
        "134742074": [
            "sub_808003A",
            "0x808003a",
            "int __usercall sub_808003A@<eax>(char *a1@<eax>, const char *a2@<edx>, int a3@<ecx>)\n{\n  size_t v4; // eax\n  char *v5; // ebx\n  int v6; // eax\n  int v7; // eax\n  char *v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  size_t v11; // ecx\n  size_t **v12; // edx\n  size_t *v13; // ebx\n  char *v14; // edi\n  int *v15; // eax\n  int *v16; // ebp\n  int v17; // ebx\n  char *v18; // eax\n  int v19; // edx\n  const char *v20; // esi\n  int v21; // eax\n  int v22; // edx\n  int v23; // ecx\n  char *v24; // esi\n  char *v25; // ebx\n  int v26; // eax\n  int v27; // edx\n  int v28; // ecx\n  int v29; // edx\n  size_t i; // esi\n  char *v31; // eax\n  int v32; // eax\n  char *v33; // esi\n  size_t v34; // eax\n  int v35; // eax\n  size_t v36; // eax\n  char *v37; // ebp\n  const char *v38; // edi\n  char v39; // al\n  bool v40; // zf\n  const char *v41; // esi\n  char *v42; // eax\n  int v43; // ecx\n  char *v44; // eax\n  int v45; // ecx\n  __dev_t v46; // rax\n  int result; // eax\n  int v48; // [esp-8h] [ebp-44h]\n  int v49; // [esp-4h] [ebp-40h]\n  int v50; // [esp-4h] [ebp-40h]\n  char v53; // [esp+Bh] [ebp-31h]\n  int v54; // [esp+Ch] [ebp-30h]\n  char v55; // [esp+10h] [ebp-2Ch]\n  char *v56; // [esp+10h] [ebp-2Ch]\n  char *v57; // [esp+10h] [ebp-2Ch]\n  char *v58; // [esp+10h] [ebp-2Ch]\n  __int64 v59; // [esp+14h] [ebp-28h] BYREF\n  regmatch_t v60; // [esp+1Ch] [ebp-20h] BYREF\n  char *v61; // [esp+28h] [ebp-14h]\n\n  v4 = strlen(a2);\n  v5 = (char *)&a2[v4];\n  LODWORD(v59) = -1;\n  if ( !a3 )\n  {\n    strcpy((char *)&a2[v4], \"/dev\");\n    v6 = sub_804E632((int)a2, v5 + 1, 0x7Fu);\n    *v5 = 0;\n    if ( v6 > 0 )\n    {\n      if ( sscanf(v5 + 1, \"%u:%u\", &v59, (char *)&v59 + 4) == 2 )\n      {\n        if ( *((_BYTE *)&buf + 8) )\n          sub_804D5F4(\"dev %u,%u\", (_DWORD)v59, HIDWORD(v59));\n      }\n      else\n      {\n        LODWORD(v59) = -1;\n      }\n    }\n  }\n  if ( !a1 )\n  {\n    strcpy(v5, \"/uevent\");\n    v7 = sub_804E632((int)a2, v5 + 1, 0x7Fu);\n    *v5 = 0;\n    if ( v7 < 0 )\n      v7 = 0;\n    v5[v7 + 1] = 0;\n    v8 = strstr(v5 + 1, \"\\nDEVNAME=\");\n    if ( v8 )\n    {\n      a1 = v8 + 9;\n      *(_BYTE *)strchrnul(v10, v9, v8 + 9, 10) = 0;\n    }\n    else\n    {\n      a1 = sub_804D315(a2);\n    }\n  }\n  if ( strstr(a2, \"/block/\") || *(&buf + 3) && sub_804D210((_BYTE *)*(&buf + 3), \"block\") )\n    v54 = 24576;\n  else\n    v54 = 0x2000;\n  *(&buf + 8) = 0;\n  do\n  {\n    while ( 1 )\n    {\nLABEL_19:\n      if ( !*(&buf + 6) && *(&buf + 5) )\n      {\n        *(&buf + 6) = sub_80B0511(v11, sub_80B3D37);\n        *(&buf + 5) = 0;\n      }\n      if ( *(&buf + 7) )\n      {\n        v12 = (size_t **)(*(&buf + 7) + 4 * *(&buf + 8));\n        if ( *v12 )\n        {\n          ++*(&buf + 8);\n          v13 = *v12;\n          goto LABEL_59;\n        }\n        sub_807FF8D();\n      }\n      else\n      {\n        sub_807FFB4();\n      }\n      if ( !*(&buf + 6) )\n        goto LABEL_28;\n      while ( sub_80B0560(\"# \\t\") )\n      {\n        *((_BYTE *)&buf + 36) = *(_BYTE *)v60.rm_so == 45;\n        v17 = *((unsigned __int8 *)&buf + 36) + v60.rm_so;\n        v16 = &dword_80DB7E4;\n        while ( 1 )\n        {\n          v18 = strchr((const char *)v17, 61);\n          v20 = v18;\n          if ( !v18 )\n            break;\n          if ( v18 != (char *)sub_80AB128(v48, v19) )\n            break;\n          v14 = strchr(v20, 59);\n          if ( !v14 )\n            break;\n          v15 = (int *)sub_804DB2E(0x28u);\n          *v16 = (int)v15;\n          v16 = v15;\n          v15[1] = (int)sub_804DB5D((_BYTE *)v17, (int)&v20[-v17]);\n          *v14 = 0;\n          sub_80B47BA(1, v20 + 1);\n          *v14 = 59;\n          v17 = (int)(v14 + 1);\n        }\n        if ( *(_BYTE *)v17 == 64 )\n        {\n          v21 = sscanf((const char *)v17, \"@%u,%u-%u\", &buf + 11, &buf + 12, &buf + 13);\n          if ( v21 <= 1 || (*(&buf + 11) & 0x80000000) != 0 )\n          {\n            sub_804D5F4(\"bad @maj,min on line %d\", *(_DWORD *)(*(&buf + 6) + 24));\n            goto LABEL_36;\n          }\n          if ( v21 == 2 )\n            *(&buf + 13) = *(&buf + 12);\n        }\n        else\n        {\n          v55 = *(_BYTE *)v17;\n          v24 = strchr((const char *)v17, 61);\n          if ( v55 == 36 )\n          {\n            if ( !v24 )\n            {\n              sub_804D5F4(\"bad $envvar=regex on line %d\", *(_DWORD *)(*(&buf + 6) + 24));\n              goto LABEL_36;\n            }\n            seconds = sub_804DB5D((_BYTE *)(v17 + 1), (int)&v24[-v17 - 1]);\n            v17 = (int)(v24 + 1);\n          }\n          sub_80B47BA(1, v17);\n          *((_BYTE *)&buf + 37) = 1;\n        }\n        if ( sub_80B47DD() )\n        {\n          *(&buf + 10) = sub_80B07AF();\n          v25 = v61;\n          if ( !v61 )\n            goto LABEL_57;\n          if ( strchr(\">=!\", (unsigned __int8)*v61) )\n          {\n            v26 = sub_80B2E9F();\n            n = (size_t)sub_804DB5D(v25, v26 - (_DWORD)v25);\n            v25 = (char *)sub_80B2E8C(v28, v27);\n            if ( !v25 )\n              goto LABEL_57;\n          }\n          if ( !*v25 )\n            goto LABEL_57;\n          if ( strchr(\"$@*\", (unsigned __int8)*v25) )\n          {\n            dword_80DB7C0 = sub_804DB46(v25);\n            goto LABEL_57;\n          }\n          sub_804D5F4(\"bad line %u\", *(_DWORD *)(*(&buf + 6) + 24));\n        }\n        else\n        {\n          sub_804D5F4(\"unknown user/group '%s' on line %d\", (const char *)v60.rm_eo, *(_DWORD *)(*(&buf + 6) + 24));\n        }\nLABEL_36:\n        sub_807FFB4();\n      }\n      sub_80B0536(v23, v22);\n      *(&buf + 6) = 0;\nLABEL_57:\n      if ( *(&buf + 7) )\n      {\n        v13 = (size_t *)sub_804DB8D(&buf + 9, 0x4Cu);\n        *(&buf + 7) = sub_80B4733(*(&buf + 8), 1028);\n        v29 = *(&buf + 8);\n        v11 = ++*(&buf + 8);\n        *(_DWORD *)(*(&buf + 7) + 4 * v29) = v13;\n        goto LABEL_59;\n      }\nLABEL_28:\n      v13 = &buf + 9;\nLABEL_59:\n      for ( i = v13[18]; i; i = *(_DWORD *)i )\n      {\n        v31 = getenv(*(const char **)(i + 4));\n        if ( !v31 || regexec((const regex_t *)(i + 8), v31, 0, 0, 0) )\n          goto LABEL_19;\n      }\n      v32 = v13[2];\n      if ( v32 >= 0 )\n      {\n        if ( v32 == (_DWORD)v59 && (int)v13[3] <= SHIDWORD(v59) && SHIDWORD(v59) <= (int)v13[4] )\n        {\n          memset(&v60, 0, sizeof(v60));\n          break;\n        }\n        continue;\n      }\n      if ( v13[7] )\n      {\n        v33 = getenv((const char *)v13[7]);\n        if ( v33 )\n          goto LABEL_73;\n        continue;\n      }\n      v33 = a1;\nLABEL_73:\n      if ( !*((_BYTE *)v13 + 1) )\n        break;\n      if ( !regexec((const regex_t *)(v13 + 10), v33, 1u, &v60, 0) && !v60.rm_so )\n      {\n        v34 = strlen(v33);\n        if ( v60.rm_eo == v34 )\n          break;\n      }\n    }\n    if ( *((char *)&buf + 8) > 1 )\n    {\n      v35 = -1;\n      if ( *(&buf + 6) )\n        v35 = *(_DWORD *)(*(&buf + 6) + 24);\n      sub_804D5F4(\"rule matched, line %d\", v35);\n    }\n    v36 = v13[8];\n    v37 = 0;\n    if ( v36 )\n    {\n      v53 = *(_BYTE *)v36;\n      if ( *(_BYTE *)v36 == 33 )\n      {\n        LODWORD(v59) = -2;\n      }\n      else if ( (unsigned __int8)(v53 - 61) <= 1u )\n      {\n        v37 = sub_804DB46((const char *)(v36 + 1));\n      }\n    }\n    v38 = (const char *)v13[9];\n    if ( !v38 )\n      goto LABEL_96;\n    v39 = *v38;\n    if ( *v38 != 64 )\n    {\n      if ( v39 == 36 )\n        v40 = a3 == 1;\n      else\n        v40 = v39 == 42;\n      if ( v40 )\nLABEL_94:\n        ++v38;\n      else\n        v38 = 0;\nLABEL_96:\n      v41 = a1;\n      if ( v37 )\n      {\nLABEL_100:\n        v42 = strrchr(v37, 47);\n        v41 = v37;\n        if ( v42 )\n        {\n          *v42 = 0;\n          v56 = v42;\n          sub_8080014();\n          *v56 = 47;\n          if ( !v56[1] )\n          {\n            v41 = (const char *)sub_804D2D1((int)v37, a1, v43);\n            free(v37);\n            v37 = (char *)v41;\n          }\n        }\n      }\n      if ( a3 )\n      {\n        if ( !v38 )\n          goto LABEL_125;\n      }\n      else\n      {\n        if ( (int)v59 >= 0 )\n        {\n          v44 = strrchr(v41, 47);\n          v45 = v49;\n          if ( v44 )\n          {\n            *v44 = 0;\n            v57 = v44;\n            sub_8080014();\n            *v57 = 47;\n          }\n          if ( *((_BYTE *)&buf + 8) )\n            sub_804D5F4(\"mknod %s (%d,%d) %o %u:%u\", v41, v59, v13[1] | v54, v13[5], v13[6]);\n          v46 = sub_80B0220(v45, HIDWORD(v59));\n          if ( mknod(v41, v13[1] | v54, v46) && *(_DWORD *)dword_80DBB7C != 17 )\n            sub_804D3A5((int)\"can't create '%s'\", v41);\n          chmod(v41, v13[1]);\n          chown(v41, v13[5], v13[6]);\n          if ( *(_QWORD *)&buf == v59 )\n            symlink(v41, \"root\");\n          if ( v53 == 62 && v37 )\n          {\n            if ( *((_BYTE *)&buf + 8) )\n              sub_804D5F4(\"symlink: %s\", a1);\n            symlink(v41, a1);\n          }\n        }\n        if ( !v38 )\n          goto LABEL_135;\n      }\n      v58 = sub_804DDBF(\"%s=%s\", \"MDEV\", v41);\n      putenv(v58);\n      if ( *((_BYTE *)&buf + 8) )\n        sub_804D5F4(\"running: %s\", v38);\n      if ( system(v38) == -1 )\n        sub_804D3A5((int)\"can't run '%s'\", v38);\n      sub_804DE4D(v58);\n      goto LABEL_125;\n    }\n    if ( !a3 )\n      goto LABEL_94;\n    v41 = a1;\n    if ( v37 )\n    {\n      v38 = 0;\n      goto LABEL_100;\n    }\nLABEL_125:\n    if ( a3 == 1 && (int)v59 >= -1 )\n    {\n      if ( v53 == 62 && v37 )\n      {\n        if ( *((_BYTE *)&buf + 8) )\n          sub_804D5F4(\"unlink: %s\", a1);\n        unlink(a1);\n      }\n      if ( *((_BYTE *)&buf + 8) )\n        sub_804D5F4(\"unlink: %s\", v41);\n      unlink(v41);\n    }\nLABEL_135:\n    free(v37);\n    result = v50;\n  }\n  while ( *(_BYTE *)v13 );\n  return result;\n}\n"
        ],
        "134744050": [
            "sub_80807F2",
            "0x80807f2",
            "int __userpurge sub_80807F2@<eax>(char *src@<ecx>, const char *a2@<eax>, int a3)\n{\n  size_t v5; // ebp\n  unsigned int v6; // edi\n  ssize_t v7; // eax\n  char *v8; // eax\n  char dest[4112]; // [esp+4h] [ebp-1010h] BYREF\n\n  v5 = strlen(a2);\n  v6 = v5 - 4;\n  if ( strcmp(&a2[v5 - 4], \"/dev\") || v6 > 0xFDF )\n    return 0;\n  strcpy(src, a2);\n  src[v5 - 4] = 0;\n  strcpy(dest, src);\n  strcpy(&dest[v6], \"/subsystem\");\n  v7 = readlink(dest, dest, 0xFFFu);\n  if ( v7 > 0 )\n  {\n    dest[v7] = 0;\n    free((void *)*(&buf + 3));\n    if ( *(&buf + 4) )\n    {\n      sub_804DE4D((char *)*(&buf + 4));\n      *(&buf + 4) = 0;\n    }\n    v8 = strrchr(dest, 47);\n    *(&buf + 3) = (size_t)v8;\n    if ( v8 )\n    {\n      *(&buf + 3) = (size_t)sub_804DB46(v8 + 1);\n      *(&buf + 4) = (size_t)sub_804DDBF(\"%s=%s\", \"SUBSYSTEM\", (const char *)*(&buf + 3));\n      putenv((char *)*(&buf + 4));\n    }\n  }\n  sub_808003A(0, src, 0);\n  return 1;\n}\n"
        ],
        "134744301": [
            "sub_80808ED",
            "0x80808ed",
            "char *sub_80808ED()\n{\n  __suseconds_t tv_usec; // esi\n  char *v1; // eax\n  struct timeval tv; // [esp+0h] [ebp-10h] BYREF\n\n  gettimeofday(&tv, 0);\n  tv_usec = tv.tv_usec;\n  v1 = sub_804EB80(&tv.tv_sec, 0x10u, byte_80DB7E8, (time_t)&tv);\n  sprintf(v1, \".%06u\", tv_usec);\n  return byte_80DB7E8;\n}\n"
        ],
        "134744362": [
            "sub_808092A",
            "0x808092a",
            "int __cdecl sub_808092A(int a1, int a2)\n{\n  const char *v2; // eax\n  unsigned __int64 v3; // kr00_8\n  char *v4; // esi\n  int v5; // eax\n  const char *v6; // eax\n  int v7; // ebx\n  int v8; // ebp\n  int v9; // esi\n  int v10; // eax\n  char *v11; // eax\n  int v12; // ecx\n  unsigned int v13; // eax\n  char *v14; // eax\n  const char *v15; // edi\n  const char *v16; // esi\n  int v17; // ebp\n  char *v18; // eax\n  int v19; // ecx\n  char *v20; // eax\n  char *v21; // eax\n  int v22; // ecx\n  int v23; // ecx\n  int v24; // ebx\n  const char *v25; // eax\n  char *v26; // eax\n  int v27; // eax\n  int v29; // [esp-4h] [ebp-A0h]\n  unsigned int v30; // [esp+4h] [ebp-98h]\n  char *s; // [esp+8h] [ebp-94h]\n  char *v32; // [esp+Ch] [ebp-90h]\n  char *v33; // [esp+10h] [ebp-8Ch]\n  char *v34; // [esp+14h] [ebp-88h]\n  char *v35; // [esp+18h] [ebp-84h]\n  unsigned __int8 v36; // [esp+1Ch] [ebp-80h]\n  unsigned int v37; // [esp+20h] [ebp-7Ch]\n  int v38[2]; // [esp+24h] [ebp-78h] BYREF\n  unsigned __int64 dev[14]; // [esp+2Ch] [ebp-70h] BYREF\n\n  s = (char *)sub_804DAFA(0x1080u);\n  *(&buf + 5) = (size_t)\"/etc/mdev.conf\";\n  sub_80B3CDB();\n  umask(0);\n  sub_804DF04(\"/dev\");\n  v2 = *(const char **)(a2 + 4);\n  if ( v2 && !strcmp(v2, \"-s\") )\n  {\n    *(&buf + 7) = (size_t)sub_804DB2E(0x40u);\n    sub_804DFF3(\"/\", (int)dev);\n    v3 = dev[0];\n    buf = gnu_dev_major(dev[0]);\n    *(&buf + 1) = gnu_dev_minor(v3);\n    putenv(\"ACTION=add\");\n    sub_80B2549(sub_807FF7F, s, 0);\n    return 0;\n  }\n  v32 = getenv(\"DEVNAME\");\n  *(&buf + 3) = (size_t)getenv(\"SUBSYSTEM\");\n  v33 = getenv(\"ACTION\");\n  v34 = getenv(\"DEVPATH\");\n  if ( !v33 || !v34 )\n    sub_804CDC2();\n  v35 = getenv(\"FIRMWARE\");\n  v4 = getenv(\"SEQNUM\");\n  v36 = sub_804D222(\"add\", v33);\n  v37 = getpid();\n  v5 = open64(\"mdev.log\");\n  if ( v5 >= 0 )\n  {\n    sub_804DC97(v5, 2);\n    *((_BYTE *)&buf + 8) = 2;\n    v6 = v4;\n    if ( !v4 )\n      v6 = sub_804D6F7(v37);\n    ident = sub_804DDBF(\"%s[%s]\", ident, v6);\n  }\n  v7 = -1;\n  if ( v4 )\n  {\n    v30 = atoll(v4);\n    v38[0] = 0;\n    v38[1] = 0;\n    sigaddset((sigset_t *)v38, 17);\n    sigprocmask(0, (const sigset_t *)v38, 0);\n    v8 = 1;\n    v9 = 62;\n    while ( 1 )\n    {\n      if ( v7 == -1 )\n      {\n        v7 = open64(\"mdev.seq\");\n        if ( v7 < 0 )\n          goto LABEL_32;\n        sub_804D670(v7);\n      }\n      v10 = pread64(v7, dev, 13, 0, 0);\n      if ( v10 < 0 )\n      {\nLABEL_23:\n        close(v7);\n        v7 = -1;\n        goto LABEL_32;\n      }\n      *((_BYTE *)dev + v10) = 0;\n      if ( !LOBYTE(dev[0]) || LOBYTE(dev[0]) == 10 )\n      {\n        v11 = sub_804D6F7(v30);\n        sub_804DCD4(v12, v11);\n        sub_804DD09(v7, 0, 0, 0);\n        if ( *((char *)&buf + 8) > 1 )\n          sub_804D5F4(\"first seq written\");\n        goto LABEL_32;\n      }\n      v13 = atoll((const char *)dev);\n      if ( v30 == v13 )\n        goto LABEL_32;\n      if ( v30 < v13 )\n        goto LABEL_23;\n      if ( v8 && *((char *)&buf + 8) > 1 )\n      {\n        v14 = sub_80808ED();\n        sub_804D5F4(\"%s mdev.seq='%s', need '%u'\", v14, (const char *)dev, v30);\n      }\n      if ( sigtimedwait((const sigset_t *)v38, 0, &timeout) < 0 && !--v9 )\n        break;\n      v8 = 0;\n    }\n    if ( *((_BYTE *)&buf + 8) )\n      sub_804D5F4(\"%s mdev.seq='%s'\", \"timed out\", (const char *)dev);\nLABEL_32:\n    sigprocmask(1, (const sigset_t *)v38, 0);\n  }\n  if ( *((_BYTE *)&buf + 8) )\n  {\n    if ( v35 )\n    {\n      v15 = v35;\n      v16 = \" FW:\";\n    }\n    else\n    {\n      v15 = &data;\n      v16 = &data;\n    }\n    v17 = *(&buf + 3);\n    v18 = sub_80808ED();\n    sub_804D5F4(\"%s ACTION:%s SUBSYSTEM:%s DEVNAME:%s DEVPATH:%s%s%s\", v18, v33, v17, v32, v34, v16, v15);\n  }\n  snprintf(s, 0x1000u, \"/sys%s\", v34);\n  if ( v36 == 1 )\n  {\n    v19 = 1;\n    if ( v35 )\n      goto LABEL_43;\n  }\n  else\n  {\n    v19 = v36;\n  }\n  sub_808003A(v32, s, v19);\nLABEL_43:\n  if ( *((_BYTE *)&buf + 8) )\n  {\n    v20 = sub_80808ED();\n    sub_804D5F4(\"%s exiting\", v20);\n  }\n  if ( v7 >= 0 )\n  {\n    v21 = sub_804D6F7(v30 + 1);\n    sub_804DCD4(v22, v21);\n    while ( 1 )\n    {\n      v24 = sub_80B0EC0(v23, 128);\n      if ( !v24 )\n        break;\n      if ( v37 != *(_DWORD *)(v24 + 36) )\n      {\n        v25 = *(const char **)(v24 + 8);\n        if ( v25 )\n        {\n          v26 = sub_804D315(v25);\n          v27 = strcmp(v26, \"mdev\");\n          v23 = v29;\n          if ( !v27 )\n            kill(*(_DWORD *)(v24 + 36), 17);\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
        ],
        "134745408": [
            "sub_8080D40",
            "0x8080d40",
            "int __cdecl sub_8080D40(int a1, int a2)\n{\n  char *v2; // eax\n  char v3; // bl\n  const char *v4; // edx\n  __mode_t v5; // edx\n  int v7; // [esp-8h] [ebp-6Ch]\n  int v8; // [esp-4h] [ebp-68h]\n  int v9; // [esp+0h] [ebp-64h] BYREF\n  int v10; // [esp+10h] [ebp-54h]\n\n  v2 = *(char **)(a2 + 4);\n  if ( v2 )\n  {\n    if ( *(_DWORD *)(a2 + 8) || (v3 = *v2, *v2 != 121) && v3 != 110 )\n      sub_804CDC2();\n  }\n  else\n  {\n    v3 = 0;\n  }\n  if ( !isatty(0) )\n    sub_804D5E0(\"not a tty\");\n  sub_804E010(0, (int)&v9, \"stdin\");\n  if ( v3 )\n  {\n    v5 = v10 & 0xFFFFFFED;\n    if ( v3 == 121 )\n      v5 = v10 | 0x10;\n    if ( fchmod(0, v5) )\n      sub_80B0A23(v8, v7);\n  }\n  else\n  {\n    v4 = \"is n\";\n    if ( (v10 & 0x12) != 0 )\n      v4 = \"is y\";\n    puts(v4);\n  }\n  return 0;\n}\n"
        ],
        "134745556": [
            "sub_8080DD4",
            "0x8080dd4",
            "int __usercall sub_8080DD4@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int *v1; // edx\n\n  v1 = (unsigned int *)&unk_80B6598;\n  while ( *--v1 != a1 )\n  {\n    if ( *v1 < a1 )\n      return 0;\n  }\n  return 1;\n}\n"
        ],
        "134745579": [
            "sub_8080DEB",
            "0x8080deb",
            "int __usercall sub_8080DEB@<eax>(char *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, unsigned int a4)\n{\n  int result; // eax\n  unsigned int v6; // edx\n\n  result = 255;\n  memset(a1, 0, a2);\n  memset(a1, 255, a3 >> 3);\n  a1[a3 >> 3] = (1 << (a3 & 7)) - 1;\n  v6 = a2 - (a4 >> 3);\n  a1[v6 - 1] |= 32512 >> (a4 & 7);\n  memset(&a1[v6], 255, a4 >> 3);\n  return result;\n}\n"
        ],
        "134745668": [
            "sub_8080E44",
            "0x8080e44",
            "void __usercall sub_8080E44(unsigned int a1@<eax>, unsigned int a2@<edx>, void *a3@<ecx>, size_t a4)\n{\n  sub_804DD09(3, a1, a2, 0);\n  sub_804DCAD(a4, a3);\n}\n"
        ],
        "134745708": [
            "sub_8080E6C",
            "0x8080e6c",
            "int __cdecl sub_8080E6C(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // eax\n  unsigned __int64 v4; // rax\n  unsigned int v5; // esi\n  unsigned int v6; // edi\n  unsigned int v7; // ebx\n  size_t v8; // ebp\n  unsigned __int64 v9; // rax\n  unsigned int v10; // edi\n  size_t v11; // esi\n  unsigned int v12; // ebx\n  unsigned int v13; // eax\n  int v14; // ecx\n  unsigned int v15; // ecx\n  int v16; // eax\n  int v17; // eax\n  int v18; // edx\n  int v19; // ebx\n  int v20; // edi\n  unsigned int j; // esi\n  const char *v22; // ecx\n  _DWORD *v23; // esi\n  unsigned __int16 v24; // ax\n  char *v25; // ebx\n  unsigned int *v26; // edi\n  int v27; // eax\n  int v28; // edx\n  unsigned int v29; // ecx\n  int v30; // eax\n  unsigned int *m; // esi\n  int n; // edi\n  unsigned __int64 v33; // rax\n  unsigned int v34; // eax\n  unsigned __int64 v35; // rax\n  int v36; // eax\n  unsigned __int64 v37; // rax\n  unsigned int ii; // edi\n  int v39; // eax\n  unsigned __int64 v40; // rax\n  int v42; // [esp+0h] [ebp-D4h]\n  unsigned int v43; // [esp+0h] [ebp-D4h]\n  unsigned int v44; // [esp+4h] [ebp-D0h]\n  size_t v45; // [esp+8h] [ebp-CCh]\n  int v46; // [esp+Ch] [ebp-C8h]\n  unsigned int *v47; // [esp+Ch] [ebp-C8h]\n  unsigned int v48; // [esp+10h] [ebp-C4h]\n  unsigned int k; // [esp+10h] [ebp-C4h]\n  unsigned int v50; // [esp+14h] [ebp-C0h]\n  unsigned int v51; // [esp+18h] [ebp-BCh]\n  int i; // [esp+1Ch] [ebp-B8h]\n  time_t v53; // [esp+1Ch] [ebp-B8h]\n  unsigned int v54; // [esp+20h] [ebp-B4h]\n  int v55; // [esp+24h] [ebp-B0h]\n  unsigned __int64 v56; // [esp+24h] [ebp-B0h]\n  unsigned int v57; // [esp+2Ch] [ebp-A8h]\n  int v58; // [esp+30h] [ebp-A4h]\n  unsigned int v59; // [esp+34h] [ebp-A0h]\n  unsigned int v60; // [esp+34h] [ebp-A0h]\n  int v61; // [esp+38h] [ebp-9Ch]\n  int v62; // [esp+38h] [ebp-9Ch]\n  size_t v63; // [esp+3Ch] [ebp-98h]\n  int v64; // [esp+40h] [ebp-94h]\n  unsigned int v65; // [esp+44h] [ebp-90h]\n  size_t v66; // [esp+50h] [ebp-84h] BYREF\n  unsigned int v67; // [esp+54h] [ebp-80h] BYREF\n  unsigned int v68; // [esp+58h] [ebp-7Ch] BYREF\n  unsigned int v69; // [esp+5Ch] [ebp-78h] BYREF\n  const char *v70; // [esp+60h] [ebp-74h] BYREF\n  char v71[16]; // [esp+64h] [ebp-70h] BYREF\n  int v72; // [esp+74h] [ebp-60h]\n\n  v69 = 5;\n  v70 = &data;\n  sub_80ABEAC(\n    a2,\n    \"cl:b:+f:i:+I:+J:G:N:m:+o:g:L:M:O:r:E:T:U:jnqvFS\",\n    0,\n    &v66,\n    0,\n    &v67,\n    &v68,\n    0,\n    0,\n    0,\n    &v69,\n    0,\n    0,\n    &v70,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0);\n  v2 = (const char **)(a2 + 4 * optind);\n  v3 = sub_804DBE1(*v2);\n  sub_804DC97(v3, 3);\n  sub_804E010(3, (int)v71, *v2);\n  if ( (v72 & 0xF000) != 24576 && (dword_80DBB9C & 0x800000) == 0 )\n    sub_804D5E0(\"%s: not a block device\", *v2);\n  if ( sub_80AB375() )\n    sub_804D5E0(\"can't format mounted filesystem\");\n  v4 = sub_80AB8B7((((unsigned int)dword_80DBB9C >> 20) ^ 1) & 1);\n  v5 = v4 >> 10;\n  v6 = HIDWORD(v4) >> 10;\n  if ( v4 >> 10 > 0x7FFFF )\n  {\n    v7 = 0x4000;\n  }\n  else\n  {\n    v7 = 0x2000;\n    if ( v5 > 0xBFF )\n      v7 = 4096;\n  }\n  if ( (dword_80DBB9C & 0x10) != 0 )\n    v7 = v67;\n  if ( v6 || v5 > 0x7FFFF )\n  {\n    v45 = 256;\n    v8 = 4096;\n  }\n  else\n  {\n    v45 = 128;\n    v8 = 1024;\n  }\n  while ( HIDWORD(v4) >= v8 )\n    v8 *= 2;\n  if ( (dword_80DBB9C & 4) != 0 )\n    v8 = v66;\n  if ( v8 - 1024 > 0xFC00 || (v42 = v8 & (v8 - 1)) != 0 )\n    sub_804D5E0(\"blocksize %u is bad\", v8);\n  if ( (dword_80DBB9C & 0x20) != 0 )\n  {\n    if ( v68 <= 0x7F || v68 > v8 || (v68 & (v68 - 1)) != 0 )\n      sub_804D5F4(\"-%c is bad\", 73);\n    else\n      v45 = v68;\n  }\n  if ( v7 < v8 )\n    sub_804D5E0(\"-%c is bad\", 105);\n  v51 = v8 == 1024;\n  v54 = v8;\n  while ( 1 )\n  {\n    v54 >>= 1;\n    if ( !v54 )\n      break;\n    ++v42;\n  }\n  v46 = v42 - 10;\n  v9 = __PAIR64__(v6, v5) >> ((unsigned __int8)v42 - 10);\n  v10 = v9;\n  if ( HIDWORD(v9) )\n    sub_804D5E0(\"block count doesn't fit in 32 bits\");\n  if ( (unsigned int)v9 <= 0x3B )\n    sub_804D5E0(\"need >= 60 blocks\");\n  if ( v69 > 0x32 )\n    sub_804D5E0(\"-%c is bad\", 109);\n  v61 = sub_80B4B88((unsigned int)v9 * v69, ((unsigned int)v9 * (unsigned __int64)v69) >> 32, 100, 0);\n  v43 = 8 * v8;\n  v11 = v8 >> 5;\n  v12 = sub_80B4B88(v10 * v8, (v10 * (unsigned __int64)v8) >> 32, v7, 0);\n  if ( v12 < 0xC )\n    v12 = 12;\n  v58 = 16 >> v46;\n  if ( 16 >> v46 > 12 )\n    v58 = 12;\n  for ( i = v10; ; i -= v59 )\n  {\n    v57 = i - v51;\n    v59 = (i - v51) % v43;\n    v44 = (i - v51) / v43;\n    if ( i - v51 != v44 * v43 )\n      ++v44;\n    v55 = v44 / v11;\n    if ( v11 * (v44 / v11) != v44 )\n      ++v55;\n    v13 = v12 / v44;\n    if ( v12 / v44 * v44 != v12 )\n      ++v13;\n    v14 = 16;\n    if ( v13 > 0xF )\n    {\n      v14 = 8 * v8;\n      if ( v43 > v13 )\n        v14 = v13;\n    }\n    v15 = v45 * v14;\n    v16 = v15 / v8;\n    if ( v15 != v15 / v8 * v8 )\n      ++v16;\n    v48 = (v8 * v16 / v45) & 0xFFFFFFF8;\n    v50 = v48 * v45 / v8;\n    if ( v48 * v45 != v8 * v50 )\n      ++v50;\n    v17 = sub_8080DD4(v44 - 1);\n    v18 = 2;\n    if ( v17 )\n      v18 = v55 + 3;\n    if ( !v59 || v18 + v50 + 50 <= v59 )\n      break;\n  }\n  if ( v10 != i )\n    printf(\"warning: %u blocks unused\\n\\n\", v10 - i);\n  v19 = v44 * v48;\n  printf(\n    \"Filesystem label=%s\\n\"\n    \"OS type: Linux\\n\"\n    \"Block size=%u (log=%u)\\n\"\n    \"Fragment size=%u (log=%u)\\n\"\n    \"%u inodes, %u blocks\\n\"\n    \"%u blocks (%u%%) reserved for the super user\\n\"\n    \"First data block=%u\\n\"\n    \"Maximum filesystem blocks=%u\\n\"\n    \"%u block groups\\n\"\n    \"%u blocks per group, %u fragments per group\\n\"\n    \"%u inodes per group\",\n    v70,\n    v8,\n    v46,\n    v8,\n    v46,\n    v44 * v48,\n    i,\n    v61,\n    v69,\n    v51,\n    v55 * v11 * v43,\n    v44,\n    v43,\n    v43,\n    v48);\n  v20 = v8 == 1024;\n  for ( j = 1; j < v44; ++j )\n  {\n    v20 += v43;\n    if ( sub_8080DD4(j) )\n      printf(v22, v20);\n  }\n  sub_804DD98(10);\n  if ( (dword_80DBB9C & 0x100000) == 0 )\n  {\n    v23 = sub_804DB2E(0x400u);\n    v23[19] = 1;\n    *((_WORD *)v23 + 28) = -4269;\n    *((_WORD *)v23 + 44) = v45;\n    if ( v45 != 128 )\n      v23[87] = 1835036;\n    v23[21] = 11;\n    v23[6] = v46;\n    v23[7] = v46;\n    v23[5] = v51;\n    v23[8] = v43;\n    v23[9] = v43;\n    v23[1] = i;\n    v23[2] = v61;\n    v23[10] = v48;\n    *v23 = v19;\n    v23[4] = v19 - 11;\n    v53 = time(0);\n    v23[66] = v53;\n    v23[12] = v53;\n    v23[16] = v53;\n    v23[18] = 0;\n    v23[17] = 15552000;\n    *(_DWORD *)((char *)v23 + 58) = 65537;\n    v23[23] = 32;\n    v23[24] = 2;\n    v23[25] = 1;\n    v23[88] = 2;\n    sub_804E101((_BYTE *)v23 + 104);\n    *((_BYTE *)v23 + 252) = 1;\n    sub_804E101((_BYTE *)v23 + 236);\n    LOBYTE(v24) = *((_BYTE *)v23 + 119) / 0x14u;\n    HIBYTE(v24) = *((_BYTE *)v23 + 119) % 0x14u;\n    *((_WORD *)v23 + 27) = HIBYTE(v24) + 20;\n    sub_80B2C4E(16);\n    v63 = v8 * v55;\n    v47 = (unsigned int *)sub_804DB2E(v8 * v55);\n    v25 = (char *)sub_804DAFA(v8);\n    v23[3] = 0;\n    v26 = v47;\n    v64 = v8 == 1024;\n    v60 = 0;\n    while ( v60 != v44 )\n    {\n      v27 = sub_8080DD4(v60);\n      v28 = 0;\n      if ( v27 )\n        v28 = v55 + 1;\n      *v26 = v28 + v64;\n      v26[1] = v28 + v64 + 1;\n      v26[2] = v28 + v64 + 2;\n      v29 = v28 + v50 + 2;\n      *((_WORD *)v26 + 7) = v48;\n      if ( !v60 )\n      {\n        v29 += v58 + 1;\n        *((_WORD *)v26 + 8) = 2;\n        *((_WORD *)v26 + 7) = v48 - 11;\n      }\n      v62 = 8 * v8;\n      if ( v43 > v57 )\n        v62 = v57;\n      v65 = v62 - v29;\n      sub_8080DEB(v25, v8, v29, v43 - v62);\n      sub_8080E44(*v26 * v8, (*v26 * (unsigned __int64)v8) >> 32, v25, v8);\n      *((_WORD *)v26 + 6) = v65;\n      sub_8080DEB(v25, v8, v48 - *((unsigned __int16 *)v26 + 7), v43 - v48);\n      sub_804DCAD(v8, v25);\n      v23[3] += v65;\n      ++v60;\n      v64 += v43;\n      v57 -= v43;\n      v26 += 8;\n    }\n    for ( k = 0; k != v44; ++k )\n    {\n      if ( sub_8080DD4(k) )\n      {\n        v56 = v8 * (unsigned __int64)v51;\n        if ( v8 == 1024 || (v30 = 1024, k) )\n          v30 = 0;\n        sub_8080E44(v56 + v30, (v56 + (unsigned int)v30) >> 32, v23, 0x400u);\n        sub_8080E44(v8 + v56, (v8 + v56) >> 32, v47, v63);\n      }\n      v51 += v43;\n    }\n    memset(v25, 0, v8);\n    for ( m = v47 + 2; &v47[8 * k + 2] != m; m += 8 )\n    {\n      for ( n = 0; n != v50; ++n )\n      {\n        v33 = v8 * (unsigned __int64)(n + *m);\n        sub_8080E44(v33, HIDWORD(v33), v25, v8);\n      }\n    }\n    *(_WORD *)v25 = 16877;\n    *((_DWORD *)v25 + 4) = v53;\n    *((_DWORD *)v25 + 2) = v53;\n    *((_DWORD *)v25 + 3) = v53;\n    *((_DWORD *)v25 + 1) = v8;\n    *((_DWORD *)v25 + 7) = v8 >> 9;\n    *((_WORD *)v25 + 13) = 3;\n    v34 = v47[2];\n    *((_DWORD *)v25 + 10) = v34 + v50;\n    v35 = v45 + v8 * (unsigned __int64)v34;\n    sub_8080E44(v35, HIDWORD(v35), v25, v45);\n    *((_WORD *)v25 + 13) = 2;\n    *((_DWORD *)v25 + 1) = v8 * v58;\n    *((_DWORD *)v25 + 7) = (v8 * v58) >> 9;\n    v36 = *((_DWORD *)v25 + 10) + 1;\n    while ( v58 != v54 )\n    {\n      *(_DWORD *)&v25[4 * v54 + 40] = v36 + v54;\n      ++v54;\n    }\n    v37 = 10 * v45 + v47[2] * (unsigned __int64)v8;\n    sub_8080E44(v37, HIDWORD(v37), v25, v45);\n    memset(v25, 0, v8);\n    *((_WORD *)v25 + 2) = v8;\n    for ( ii = 1; ; ++ii )\n    {\n      v39 = v50 + v47[2] + 1;\n      if ( ii >= v54 )\n        break;\n      sub_8080E44(v8 * (ii + v39), (v8 * (unsigned __int64)(ii + v39)) >> 32, v25, v8);\n    }\n    *(_DWORD *)v25 = 11;\n    *((_DWORD *)v25 + 1) = 33619980;\n    v25[8] = 46;\n    *((_DWORD *)v25 + 3) = 2;\n    *((_WORD *)v25 + 8) = v8 - 12;\n    *(_DWORD *)(v25 + 18) = 774767106;\n    sub_8080E44(v8 * v39, (v8 * (unsigned __int64)(unsigned int)v39) >> 32, v25, v8);\n    *(_DWORD *)v25 = 2;\n    *((_WORD *)v25 + 8) = 12;\n    *((_DWORD *)v25 + 6) = 11;\n    *((_WORD *)v25 + 14) = v8 - 24;\n    *((_WORD *)v25 + 15) = 522;\n    strcpy(v25 + 32, \"lost+found\");\n    v40 = v8 * (unsigned __int64)(v47[2] + v50);\n    sub_8080E44(v40, HIDWORD(v40), v25, v8);\n    sub_804DCF3(3);\n  }\n  return 0;\n}\n"
        ],
        "134747929": [
            "sub_8081719",
            "0x8081719",
            "int __cdecl sub_8081719(int a1, int a2)\n{\n  int v2; // ebx\n  int v3; // eax\n  size_t v4; // ebp\n  unsigned __int64 v5; // kr00_8\n  int v6; // esi\n  unsigned __int8 v7; // di\n  unsigned int v8; // eax\n  unsigned __int64 v9; // rax\n  unsigned int v10; // ecx\n  char *v11; // ebx\n  char *v12; // eax\n  char *v13; // edi\n  unsigned int j; // esi\n  unsigned int k; // esi\n  unsigned int v16; // ebp\n  unsigned __int64 v18; // [esp+4h] [ebp-D0h]\n  int fd; // [esp+Ch] [ebp-C8h]\n  unsigned int i; // [esp+10h] [ebp-C4h]\n  unsigned __int8 v21; // [esp+15h] [ebp-BFh]\n  unsigned __int16 v22; // [esp+16h] [ebp-BEh]\n  char *v23; // [esp+18h] [ebp-BCh]\n  const char *v24; // [esp+20h] [ebp-B4h]\n  int v25; // [esp+20h] [ebp-B4h]\n  int v26; // [esp+24h] [ebp-B0h]\n  time_t v27; // [esp+28h] [ebp-ACh]\n  size_t v28; // [esp+2Ch] [ebp-A8h]\n  int v29; // [esp+2Ch] [ebp-A8h]\n  int v30; // [esp+30h] [ebp-A4h]\n  int v31; // [esp+38h] [ebp-9Ch]\n  char *src; // [esp+3Ch] [ebp-98h] BYREF\n  unsigned __int8 v33; // [esp+40h] [ebp-94h] BYREF\n  unsigned __int8 v34; // [esp+41h] [ebp-93h]\n  int v35[7]; // [esp+48h] [ebp-8Ch] BYREF\n  char v36[16]; // [esp+64h] [ebp-70h] BYREF\n  int v37; // [esp+74h] [ebp-60h]\n\n  src = (char *)&data;\n  v30 = sub_80ABEAC(a2, \"^Ab:cCf:F:h:Ii:l:m:n:r:R:s:S:v\", 0, 0, 0, 0, 0, 0, 0, &src, 0, 0, 0, 0);\n  v2 = a2 + 4 * optind;\n  v24 = *(const char **)v2;\n  v27 = time(0);\n  fd = sub_804DBE1(v24);\n  sub_804E010(fd, (int)v36, v24);\n  v3 = v37 & 0xF000;\n  if ( v3 == 24576 )\n  {\n    sub_804E0BE(fd, 0x1268u, (int)v35, \"BLKSSZGET\");\n    v4 = 512;\n    if ( v35[0] > 512 )\n    {\n      v4 = v35[0];\n      sub_804D5F4(\"for this device sector size is %u\", v35[0]);\n    }\n  }\n  else\n  {\n    if ( v3 != 0x8000 && !*(_DWORD *)(v2 + 4) )\n      sub_804D5E0(\"image size must be specified\");\n    v30 &= ~4u;\n    v4 = 512;\n  }\n  v5 = sub_80AB8B7(1);\n  v18 = sub_80B4B88(v5, HIDWORD(v5), v4, 0);\n  if ( ioctl(fd, 0x301u, &v33) || !v34 || (v21 = v33) == 0 )\n  {\n    if ( ioctl(fd, 0x801C0204, v35) )\n    {\n      if ( v18 != 2400 )\n      {\n        if ( v18 <= 0x960 )\n        {\n          if ( v18 != 720 )\n          {\n            if ( v18 != 1440 )\n            {\nLABEL_17:\n              v21 = -1;\n              v22 = 63;\n              goto LABEL_18;\n            }\n            goto LABEL_25;\n          }\nLABEL_57:\n          v7 = -3;\n          goto LABEL_26;\n        }\n        if ( v18 != 2880 && v18 != 5760 )\n          goto LABEL_17;\n        goto LABEL_56;\n      }\n    }\n    else\n    {\n      v18 = (unsigned int)v35[0];\n      if ( v35[0] != 1440 && v35[0] != 2400 )\n      {\n        if ( v35[0] == 720 )\n        {\n          v18 = 720LL;\n          goto LABEL_57;\n        }\nLABEL_56:\n        v7 = -16;\n        goto LABEL_26;\n      }\n    }\nLABEL_25:\n    v7 = -7;\nLABEL_26:\n    v22 = (unsigned int)v18 / 0xA0;\n    if ( v22 < 9u )\n      v22 = 9;\n    v21 = 2;\n    LOBYTE(v6) = 1;\n    goto LABEL_31;\n  }\n  v22 = v34;\nLABEL_18:\n  if ( v5 <= 0x103FFFFF )\n  {\n    LOBYTE(v6) = 1;\n  }\n  else\n  {\n    LOBYTE(v6) = 8;\n    if ( HIDWORD(v5) > 1 )\n      v6 = HIDWORD(v5) < 4 ? 16 : 32;\n  }\n  v7 = -8;\nLABEL_31:\n  if ( (__int64)(v18 - 6) <= 3 )\n    sub_804D5E0(\"the image is too small for FAT32\");\n  v28 = v4 >> 2;\n  v31 = (v4 >> 2) + 1;\n  for ( i = 1; ; i = (i >> 1) | 1 )\n  {\n    while ( 1 )\n    {\n      v9 = sub_80B4B88(v18 - 6 - 2 * i, (v18 - 6 - 2 * i) >> 32, (unsigned __int8)v6, 0);\n      v10 = v9;\n      v26 = v9;\n      if ( v9 > 0x80FFFFFF )\n        goto LABEL_39;\n      v8 = ((int)v9 + v31) / v28 - i;\n      if ( (int)((v10 + v31) / v28 - i) <= 0 )\n        break;\n      i += (v8 >> 1) | 1;\n    }\n    if ( v10 <= 0xFFFFFF0 )\n      break;\nLABEL_39:\n    if ( (_BYTE)v6 == 0x80 )\n      sub_804D5E0(\"can't make FAT32 with >128 sectors/cluster\");\n    LOBYTE(v6) = 2 * v6;\n  }\n  v29 = v7;\n  if ( (v30 & 0x10000) != 0 )\n    fprintf(\n      stderr,\n      \"Device '%s':\\n\"\n      \"heads:%u, sectors/track:%u, bytes/sector:%u\\n\"\n      \"media descriptor:%02x\\n\"\n      \"total sectors:%llu, clusters:%u, sectors/cluster:%u\\n\"\n      \"FATs:2, sectors/FAT:%u\\n\"\n      \"volumeID:%08x, label:'%s'\\n\",\n      v24,\n      v21,\n      v22,\n      v4,\n      v7,\n      v18,\n      v10,\n      (unsigned __int8)v6,\n      i,\n      v27,\n      src);\n  v25 = (unsigned __int8)v6;\n  v11 = (char *)sub_804DB2E(v4 * ((unsigned __int8)v6 | 6));\n  v23 = &v11[v4];\n  strcpy(v11, &byte_80D41F6);\n  *(_WORD *)(v11 + 11) = v4;\n  v11[13] = v6;\n  *((_WORD *)v11 + 7) = 6;\n  v11[16] = 2;\n  if ( v18 <= 0xFFFF )\n    *(_WORD *)(v11 + 19) = v18;\n  v11[21] = v7;\n  *((_WORD *)v11 + 12) = v22;\n  *((_WORD *)v11 + 13) = v21;\n  *((_DWORD *)v11 + 8) = v18;\n  *((_DWORD *)v11 + 9) = i;\n  *((_DWORD *)v11 + 11) = 2;\n  *((_DWORD *)v11 + 12) = 196609;\n  v11[66] = 41;\n  *(_DWORD *)(v11 + 67) = v27;\n  *(_DWORD *)(v11 + 82) = 861159750;\n  *(_DWORD *)(v11 + 86) = 538976306;\n  strncpy(v11 + 71, src, 0xBu);\n  qmemcpy(v11 + 90, &unk_80D4223, 0x3Bu);\n  *((_WORD *)v11 + 255) = -21931;\n  v12 = &v11[v4];\n  *(_DWORD *)v12 = 1096897106;\n  *((_DWORD *)v12 + 121) = 1631679090;\n  v13 = &v11[v4];\n  *((_DWORD *)v13 + 122) = v26 - 1;\n  *((_DWORD *)v13 + 123) = 2;\n  *((_WORD *)v13 + 255) = -21931;\n  sub_804DCAD(3 * v4, v11);\n  sub_804DCAD(3 * v4, v11);\n  memset(v11, 0, 2 * v4);\n  *(_DWORD *)v11 = v29 | 0xFFFFF00;\n  *((_DWORD *)v11 + 1) = -1;\n  *((_DWORD *)v11 + 2) = 268435448;\n  sub_804DCAD(v4, v11);\n  for ( j = 1; i > j; ++j )\n    sub_804DCAD(v4, v23);\n  sub_804DCAD(v4, v11);\n  for ( k = 1; i > k; ++k )\n    sub_804DCAD(v4, v23);\n  v16 = v25 * v4;\n  memset(v11, 0, v16);\n  if ( *src )\n  {\n    strncpy(v11, src, 0xBu);\n    v11[11] = 8;\n  }\n  sub_804DCAD(v16, v11);\n  return 0;\n}\n"
        ],
        "134749342": [
            "sub_8081C9E",
            "0x8081c9e",
            "int __cdecl sub_8081C9E(int a1, int a2)\n{\n  int v2; // ebx\n  __int64 v3; // kr00_8\n  __int64 v4; // kr08_8\n  int v6; // [esp+0h] [ebp-1Ch]\n  const char *v7; // [esp+8h] [ebp-14h] BYREF\n\n  v7 = &data;\n  sub_80ABEAC(a2, \"^L:\", &v7);\n  v2 = sub_804DBE1(*(const char **)(a2 + 4 * optind));\n  v3 = sub_80AB8B7(1);\n  v6 = getpagesize();\n  v4 = v3 - (unsigned int)v6;\n  printf(\"Setting up swapspace version 1, size = %llu bytes\\n\", v4);\n  sub_804DCAD(0x400u, &buf);\n  buf = 1;\n  *(&buf + 1) = sub_80B4B88(v4, HIDWORD(v4), v6, 0);\n  sub_80B2C4E(16);\n  sub_804DCAD(0x204u, &buf);\n  sub_804DD09(v2, v6 - 10, 0, 0);\n  sub_804DCAD(0xAu, \"SWAPSPACE2dflsu\");\n  fsync(v2);\n  return 0;\n}\n"
        ],
        "134749590": [
            "sub_8081D96",
            "0x8081d96",
            "_BOOL4 sub_8081D96()\n{\n  _BOOL4 result; // eax\n\n  result = sub_804D878(buf, (int *)&buf + 1, (int *)&buf + 2);\n  --*(&buf + 2);\n  return result;\n}\n"
        ],
        "134749617": [
            "sub_8081DB1",
            "0x8081db1",
            "void __fastcall __noreturn sub_8081DB1(int a1, int a2)\n{\n  sub_804D830(10, a2);\n  tcsetattr(buf, 0, (const struct termios *)(&buf + 3));\n  _exit(1);\n}\n"
        ],
        "134749652": [
            "sub_8081DD4",
            "0x8081dd4",
            "int __cdecl sub_8081DD4(int a1, int a2)\n{\n  int v3; // ecx\n  int v4; // esi\n  FILE *v5; // ebp\n  int v6; // eax\n  size_t v7; // ebx\n  int v8; // edi\n  char *IO_write_base; // eax\n  int v10; // ebx\n  unsigned __int64 v11; // rdi\n  __int64 v12; // kr00_8\n  __int64 v13; // rax\n  int v14; // eax\n  char *v15; // eax\n  char v16; // al\n  unsigned __int8 v17; // dl\n  size_t v18; // edx\n  _BYTE *v19; // edx\n  int v20; // [esp-4h] [ebp-8Ch]\n  int v21; // [esp+0h] [ebp-88h]\n  _DWORD *v22; // [esp+4h] [ebp-84h]\n  FILE *stream; // [esp+8h] [ebp-80h]\n  int v24; // [esp+Ch] [ebp-7Ch]\n  __int64 v25; // [esp+Ch] [ebp-7Ch]\n  int v26; // [esp+14h] [ebp-74h]\n  char v27[44]; // [esp+18h] [ebp-70h] BYREF\n  __int64 v28; // [esp+44h] [ebp-44h]\n\n  sub_80ABEAC(a2, 135086754);\n  v22 = (_DWORD *)(a2 + 4 * optind);\n  if ( !isatty(1) )\n    return sub_80A98A4();\n  stream = (FILE *)sub_80B3D37();\n  if ( !stream )\n    return sub_80A98A4();\n  buf = fileno_unlocked(stream);\n  sub_804DA14(0, (struct termios *)(&buf + 3), buf);\n  sub_804E6C8(117503054, (void (*)(int))sub_8081DB1);\n  v3 = v20;\n  v4 = 0;\n  while ( 1 )\n  {\n    v5 = stdin;\n    if ( !*v22 )\n      break;\n    v5 = (FILE *)sub_80B3D18(v3, \"r\");\n    if ( v5 )\n      break;\nLABEL_44:\n    if ( *v22 )\n    {\n      if ( *++v22 )\n        continue;\n    }\n    goto LABEL_46;\n  }\n  v28 = 0LL;\n  v6 = fileno_unlocked(v5);\n  fstat64(v6, v27);\n  sub_8081D96();\n  v24 = 0;\n  v7 = 0;\n  v8 = 0;\n  v26 = 0;\n  v21 = -1;\nLABEL_8:\n  if ( !v26 )\n  {\n    IO_write_base = v5->_IO_write_base;\n    if ( IO_write_base < v5->_IO_write_end )\n    {\n      v5->_IO_write_base = IO_write_base + 1;\n      v21 = (unsigned __int8)*IO_write_base;\n      goto LABEL_13;\n    }\n    v21 = __fgetc_unlocked(v5);\n    if ( v21 != -1 )\n      goto LABEL_13;\n    fclose(v5);\n    sub_804DD8F();\n    goto LABEL_44;\n  }\n  --v26;\nLABEL_13:\n  while ( v4 == 114 || !v8 )\n  {\nLABEL_30:\n    if ( v21 == 9 )\n    {\n      v26 = ~(_BYTE)v7 & 7;\n      v21 = 32;\n    }\n    v18 = ++v7;\n    if ( v7 > *(&buf + 1) || v21 == 10 )\n    {\n      if ( ++v24 >= *(&buf + 2) || v4 == 10 )\n        v8 = 1;\n      v7 = 0;\n      if ( v21 != 10 && v18 > *(&buf + 1) )\n        continue;\n    }\n    v19 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v19 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked(v21, _stdout);\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v19 + 1;\n      *v19 = v21;\n    }\n    sub_804DD80();\n    goto LABEL_8;\n  }\n  v10 = printf(\"--More-- \");\n  v25 = v28;\n  if ( v28 )\n  {\n    v12 = sub_80B4B88(v28, HIDWORD(v28), 100, 0);\n    v11 = __PAIR64__(v12, HIDWORD(v12));\n    if ( !v12 )\n      v11 = 0x100000000LL;\n    v13 = ftello64(v5);\n    v14 = sub_80B4B88(v13, HIDWORD(v13), HIDWORD(v11), v11);\n    v10 += printf(\"(%u%% of %llu bytes)\", v14, v25);\n  }\n  while ( 1 )\n  {\n    sub_804DD8F();\n    v15 = stream->_IO_write_base;\n    if ( v15 >= stream->_IO_write_end )\n    {\n      v16 = __fgetc_unlocked(stream);\n    }\n    else\n    {\n      stream->_IO_write_base = v15 + 1;\n      v16 = *v15;\n    }\n    v17 = v16;\n    if ( (unsigned __int8)(v16 - 65) <= 0x19u )\n      v17 = v16 + 32;\n    v4 = v17;\n    printf(\"\\r%*s\\r\", v10, &data);\n    if ( v4 == 113 )\n      break;\n    if ( v4 == 32 || v4 == 10 || v4 == 114 )\n    {\n      sub_8081D96();\n      v24 = 0;\n      v7 = 0;\n      v8 = 0;\n      goto LABEL_30;\n    }\n    v10 = printf(\"(Enter:next line Space:next page Q:quit R:show the rest)\");\n  }\nLABEL_46:\n  tcsetattr(buf, 0, (const struct termios *)(&buf + 3));\n  return 0;\n}\n"
        ],
        "134750406": [
            "sub_80820C6",
            "0x80820c6",
            "int __usercall sub_80820C6@<eax>(const char *a1@<eax>, const char **a2@<edx>)\n{\n  char *v4; // eax\n  char *v5; // esi\n  const char *v6; // edi\n  int v7; // edx\n  int v8; // eax\n  size_t v9; // edi\n  size_t v10; // eax\n  const char *v11; // eax\n  size_t n; // [esp+4h] [ebp-1Ch]\n  char *v14; // [esp+4h] [ebp-1Ch]\n  int v15; // [esp+8h] [ebp-18h]\n  int v16; // [esp+Ch] [ebp-14h]\n\n  v15 = 0x8000;\n  while ( 2 )\n  {\n    v4 = strchr(a1, 44);\n    v5 = v4;\n    if ( v4 )\n      *v4 = 0;\n    v6 = \"loop\";\n    v7 = 0;\n    do\n    {\n      v16 = v7;\n      n = strlen(v6);\n      if ( !strncasecmp(v6, a1, n) && (!a1[n] || v6[n - 1] == 61) )\n      {\n        v8 = dword_80B65E0[v16];\n        if ( v8 >= 0 )\n          v15 |= v8;\n        else\n          v15 &= v8;\n        goto LABEL_20;\n      }\n      v6 += n + 1;\n      v7 = v16 + 1;\n    }\n    while ( v16 != 43 );\n    if ( *a1 && a2 )\n    {\n      v14 = (char *)*a2;\n      v9 = 0;\n      if ( *a2 )\n        v9 = strlen(*a2);\n      v10 = strlen(a1);\n      v11 = (const char *)sub_804DB13(v14, v10 + v9 + 2);\n      *a2 = v11;\n      if ( v9 )\n        v11[v9++] = 44;\n      strcpy((char *)&v11[v9], a1);\n    }\nLABEL_20:\n    if ( v5 )\n    {\n      *v5 = 44;\n      a1 = v5 + 1;\n      continue;\n    }\n    return v15;\n  }\n}\n"
        ],
        "134750636": [
            "sub_80821AC",
            "0x80821ac",
            "const char *__usercall sub_80821AC@<eax>(void **a1@<eax>, const char *a2@<edx>, const char *a3@<ecx>)\n{\n  const char *v4; // ebx\n  _BYTE *v5; // eax\n  size_t v6; // edi\n  char *v7; // eax\n  const char *v8; // ebp\n  const char *i; // edx\n  char v10; // al\n  char *v11; // eax\n  char *v12; // ebp\n\n  v4 = a2;\n  v5 = *a1;\n  if ( v5 && *v5 )\n  {\n    while ( *v4 )\n    {\n      v6 = strlen(v4);\n      v7 = strchr(v4, 44);\n      if ( v7 )\n        v6 = v7 - v4;\n      v8 = (const char *)*a1;\n      for ( i = (const char *)*a1; ; i = v11 + 1 )\n      {\n        a3 = i;\n        if ( !strncmp(i, v4, v6) )\n        {\n          v10 = a3[v6];\n          if ( !v10 || v10 == 44 )\n            break;\n        }\n        v11 = strchr(a3, 44);\n        if ( !v11 )\n        {\n          v12 = sub_804DDBF(\"%s,%.*s\", v8, v6, v4);\n          free(*a1);\n          *a1 = v12;\n          break;\n        }\n      }\n      for ( v4 += v6; *v4 == 44; ++v4 )\n        ;\n    }\n  }\n  else\n  {\n    *a1 = sub_804DB46(a2);\n  }\n  return a3;\n}\n"
        ],
        "134750816": [
            "sub_8082260",
            "0x8082260",
            "int __usercall sub_8082260@<eax>(void *data@<ecx>, const char **a2@<eax>, int a3@<edx>)\n{\n  unsigned int i; // ebx\n  int *v6; // ebp\n  int result; // eax\n  int v8; // edx\n\n  for ( i = a3 & 0x87FFFFFF; ; i |= 1u )\n  {\n    v6 = (int *)dword_80DBB7C;\n    *(_DWORD *)dword_80DBB7C = 0;\n    result = mount(*a2, a2[1], a2[2], i, data);\n    if ( !result )\n      break;\n    v8 = *v6;\n    if ( (i & 1) != 0 || v8 != 30 && v8 != 13 )\n    {\n      if ( v8 == 1 )\n        sub_804D5E0(\"permission denied (are you root?)\");\n      return result;\n    }\n    if ( (i & 0x8000) == 0 )\n      sub_804D5F4(\"%s is write-protected, mounting read-only\", *a2);\n  }\n  return result;\n}\n"
        ],
        "134750929": [
            "sub_80822D1",
            "0x80822d1",
            "int __usercall sub_80822D1@<eax>(const char **a1@<eax>, int a2@<edx>)\n{\n  const char *v3; // eax\n  char *v4; // esi\n  const char *v5; // edi\n  char v6; // al\n  const char *v7; // edi\n  size_t v8; // eax\n  const char *v9; // esi\n  int v10; // edx\n  char v11; // bp\n  size_t v12; // eax\n  char *v13; // edx\n  char *v14; // eax\n  int v15; // edi\n  const char *v16; // eax\n  char *v17; // eax\n  const char *v18; // ebp\n  char *v19; // esi\n  char *v20; // eax\n  int v21; // ecx\n  char *v22; // edi\n  const char *v23; // eax\n  const char *v24; // edx\n  char *v25; // eax\n  int v26; // eax\n  int v27; // edi\n  int v28; // esi\n  int v29; // ebx\n  const char *v30; // ebp\n  char *v31; // eax\n  int v32; // edx\n  int v33; // ecx\n  _BYTE *v34; // eax\n  _BYTE *v35; // ebp\n  char *v36; // eax\n  int v37; // ecx\n  _DWORD *v38; // ebp\n  int v40; // [esp-8h] [ebp-94h]\n  int v41; // [esp-8h] [ebp-94h]\n  int v42; // [esp-4h] [ebp-90h]\n  int v43; // [esp-4h] [ebp-90h]\n  int v44; // [esp-4h] [ebp-90h]\n  int v45; // [esp+0h] [ebp-8Ch]\n  int v46; // [esp+0h] [ebp-8Ch]\n  const char *v47; // [esp+4h] [ebp-88h]\n  int v48; // [esp+4h] [ebp-88h]\n  int v49; // [esp+4h] [ebp-88h]\n  const char *v50; // [esp+Ch] [ebp-80h]\n  char *haystack; // [esp+14h] [ebp-78h] BYREF\n  size_t v53; // [esp+18h] [ebp-74h]\n  char v54[16]; // [esp+1Ch] [ebp-70h] BYREF\n  int v55; // [esp+2Ch] [ebp-60h]\n\n  haystack = 0;\n  *(_DWORD *)dword_80DBB7C = 0;\n  v45 = sub_80820C6(a1[3], (const char **)&haystack);\n  v3 = a1[2];\n  if ( v3 && !strcmp(v3, \"auto\") )\n    a1[2] = 0;\n  v4 = (char *)a1[2];\n  if ( !v4 || !strcmp(v4, \"cifs\") )\n  {\n    v5 = *a1;\n    v6 = **a1;\n    if ( (v6 == 47 || v6 == 92) && v6 == v5[1] )\n    {\n      v7 = v5 + 2;\n      v8 = strcspn(v7, \"/\\\\\");\n      v9 = &v7[v8 + 1];\n      v10 = -1;\n      if ( v8 )\n      {\n        v11 = v7[v8];\n        if ( v11 )\n        {\n          if ( *v9 )\n          {\n            v7[v8] = 0;\n            v12 = strcspn(v9, \"/\\\\\");\n            v13 = \"unc=\\\\\\\\%s\\\\%.*s\";\n            if ( v9[v12] )\n              v13 = \"unc=\\\\\\\\%s\\\\%.*s,prefixpath=%s\";\n            v14 = sub_804DDBF(v13, v7, v12, v9, &v9[v12 + 1]);\n            sub_80820C6(v14, (const char **)&haystack);\n            v15 = sub_80B45B2();\n            *((_BYTE *)v9 - 1) = v11;\n            v10 = -1;\n            if ( v15 )\n            {\n              if ( !sub_804D210(haystack, \"ip=\") && !strstr(haystack, \",ip=\") )\n              {\n                v16 = (const char *)sub_80B46B6(v42, v40);\n                v17 = sub_804DDBF(\"ip=%s\", v16);\n                sub_80820C6(v17, (const char **)&haystack);\n              }\n              a1[2] = \"cifs\";\n              v10 = sub_8082260(haystack, a1, v45);\n            }\n          }\n        }\n      }\n      goto LABEL_77;\n    }\n    if ( !v4 )\n      goto LABEL_88;\n  }\n  if ( sub_804D210(v4, \"nfs\") )\n  {\nLABEL_88:\n    v18 = *a1;\n    if ( strchr(*a1, 58) )\n    {\n      if ( !a1[2] )\n        a1[2] = \"nfs\";\n      v19 = haystack;\n      v20 = strchr(v18, 93);\n      v21 = v43;\n      if ( !v20 || (v22 = v20 + 1, v20[1] != 58) )\n        v22 = strchr(v18, 58);\n      *v22 = 0;\n      sub_80B45BD(v21, 0);\n      *v22 = 58;\n      v23 = (const char *)((int (*)(void))sub_80B46B6)();\n      v24 = \"Linux User,,,\" + 12;\n      if ( !v19 )\n      {\n        v24 = &data;\n        v19 = (char *)&data;\n      }\n      v25 = sub_804DDBF(\"%s%saddr=%s\", v19, v24, v23);\n      v10 = sub_8082260(v25, a1, v45);\n      goto LABEL_77;\n    }\n  }\n  if ( stat64(*a1, v54) || (v45 & 0x3020) != 0 )\n    goto LABEL_44;\n  v26 = v55 & 0xF000;\n  if ( v26 != 0x8000 )\n  {\n    v27 = (int)a1[2];\n    if ( v26 == 0x4000 && !v27 )\n    {\n      v45 |= 0x1000u;\nLABEL_45:\n      v28 = -1;\nLABEL_46:\n      if ( a1[2] || (v45 & 0x3020) != 0 )\n      {\n        while ( 1 )\n        {\n          v30 = a1[2];\n          if ( v30 )\n          {\n            v31 = strchr(v30, 44);\n            v30 = v31;\n            if ( v31 )\n              *v31 = 0;\n          }\n          v10 = sub_8082260(haystack, a1, v45);\n          if ( !v10 )\n            break;\n          if ( !v30 )\n            goto LABEL_73;\n          a1[2] = v30 + 1;\n        }\nLABEL_52:\n        v10 = 0;\n      }\n      else\n      {\n        if ( !buf )\n        {\n          v53 = 0;\n          v47 = \"/etc/filesystems\";\n          do\n          {\n            if ( sub_80B3D37() )\n            {\n              while ( 1 )\n              {\n                v34 = (_BYTE *)sub_80AB85A();\n                v35 = v34;\n                if ( !v34 )\n                  break;\n                if ( !sub_804D210(v34, \"nodev\") || v35[5] != 32 && (unsigned __int8)(v35[5] - 9) > 4u )\n                {\n                  v50 = (const char *)sub_80B2E8C(v33, v32);\n                  if ( *v50 != 42 && *v50 != 35 )\n                  {\n                    if ( *v50 )\n                    {\n                      v36 = sub_804DB46(v50);\n                      sub_80AFADF(v37, v36);\n                    }\n                  }\n                }\n                free(v35);\n              }\n            }\n            v47 += 18;\n          }\n          while ( v47 != (const char *)&unk_80B65C4 );\n          buf = v53;\n        }\n        v38 = (_DWORD *)buf;\n        v10 = -1;\n        while ( v38 )\n        {\n          a1[2] = (const char *)v38[1];\n          v10 = sub_8082260(haystack, a1, v45);\n          if ( !v10 )\n            goto LABEL_52;\n          v38 = (_DWORD *)*v38;\n        }\nLABEL_73:\n        if ( v27 )\n        {\n          v48 = v10;\n          sub_80AFDF4();\n          v10 = v48;\n        }\n      }\n      if ( v28 != -1 )\n      {\n        v49 = v10;\n        close(v28);\n        v10 = v49;\n      }\nLABEL_77:\n      if ( *(_DWORD *)dword_80DBB7C == 16 )\n      {\n        if ( !a2 )\n          goto LABEL_82;\n      }\n      else if ( *(_DWORD *)dword_80DBB7C != 2 || (v45 & 0x10000000) == 0 )\n      {\nLABEL_82:\n        if ( v10 )\n        {\n          v46 = v10;\n          sub_804D3A5((int)\"mounting %s on %s failed\", *a1, a1[1]);\n          return v46;\n        }\n        return v10;\n      }\n      return 0;\n    }\nLABEL_44:\n    v27 = 0;\n    goto LABEL_45;\n  }\n  v27 = sub_80B2E23(v44, v41);\n  *a1 = 0;\n  v28 = sub_80AFE28(0, 0, v45 & 1 | 4);\n  if ( v28 >= 0 )\n    goto LABEL_46;\n  v29 = dword_80DBB7C;\n  if ( *(_DWORD *)dword_80DBB7C == 13 || *(_DWORD *)dword_80DBB7C == 1 )\n    sub_804D5F4(\"permission denied (are you root?)\");\n  else\n    sub_804D3A5((int)\"can't setup loop device\");\n  return *(_DWORD *)v29;\n}\n"
        ],
        "134752064": [
            "sub_8082740",
            "0x8082740",
            "int __cdecl sub_8082740(int a1, int a2)\n{\n  const char *v2; // ecx\n  int *v3; // edi\n  int v4; // ebx\n  int v5; // edx\n  int v6; // edx\n  const char *v7; // ecx\n  char v8; // bl\n  const char *v9; // eax\n  const char *v10; // ecx\n  FILE *v11; // ebx\n  char *mnt_type; // esi\n  char *v13; // eax\n  struct mntent *v14; // eax\n  int v15; // eax\n  struct mntent *v16; // edi\n  struct mntent *v17; // ebx\n  char *i; // eax\n  bool v19; // zf\n  const char *v20; // esi\n  const char *mnt_fsname; // ebp\n  const char *mnt_dir; // ebp\n  int v23; // eax\n  int v24; // edx\n  char *v25; // ecx\n  char *v26; // ebp\n  int v27; // esi\n  size_t v28; // ebx\n  const char *j; // ecx\n  int v30; // eax\n  char v31; // al\n  char *v32; // eax\n  const char *v33; // ecx\n  char *v35; // [esp-8h] [ebp-7Ch]\n  int v36; // [esp-8h] [ebp-7Ch]\n  char *v37; // [esp-4h] [ebp-78h]\n  char *s1; // [esp+0h] [ebp-74h]\n  const char *s1a; // [esp+0h] [ebp-74h]\n  int v40; // [esp+4h] [ebp-70h]\n  int v41; // [esp+8h] [ebp-6Ch]\n  int v42; // [esp+Ch] [ebp-68h]\n  char *mnt_opts; // [esp+10h] [ebp-64h]\n  FILE *stream; // [esp+14h] [ebp-60h]\n  _BYTE *v45; // [esp+18h] [ebp-5Ch]\n  char *s; // [esp+1Ch] [ebp-58h]\n  char *v47; // [esp+20h] [ebp-54h] BYREF\n  char *s2; // [esp+24h] [ebp-50h] BYREF\n  char *v49; // [esp+28h] [ebp-4Ch] BYREF\n  int v50; // [esp+2Ch] [ebp-48h] BYREF\n  char *file; // [esp+30h] [ebp-44h] BYREF\n  struct mntent result[2]; // [esp+34h] [ebp-40h] BYREF\n\n  v47 = (char *)sub_804DB2E(1u);\n  s2 = 0;\n  v49 = 0;\n  v50 = 0;\n  file = \"/etc/fstab\";\n  v40 = sub_80AFD54();\n  v3 = (int *)(a2 + 4);\n  v4 = 1;\n  while ( 1 )\n  {\n    v5 = *v3;\n    if ( !*v3 )\n      break;\n    if ( *(_BYTE *)v5 == 45 && *(_BYTE *)(v5 + 1) == 45 )\n      sub_80821AC((void **)&v47, (const char *)(v5 + 2), v2);\n    else\n      *(_DWORD *)(a2 + 4 * v4++) = v5;\n    ++v3;\n  }\n  *(_DWORD *)(a2 + 4 * v4) = 0;\n  v8 = sub_80ABEAC(a2, \"^o:*t:rwanfvsiO:T:\", &v50, &s2, &v49, &file);\n  while ( v50 )\n  {\n    v9 = (const char *)sub_80AFB01(s1);\n    sub_80821AC((void **)&v47, v9, v10);\n  }\n  if ( (v8 & 4) != 0 )\n    sub_80821AC((void **)&v47, \"ro\", v7);\n  if ( (v8 & 8) != 0 )\n    sub_80821AC((void **)&v47, \"rw\", v7);\n  v41 = a2 + 4 * optind;\n  s1a = *(const char **)v41;\n  if ( *(_DWORD *)v41 )\n  {\n    v13 = *(char **)(v41 + 4);\n    if ( v13 )\n    {\n      if ( !v40 )\n      {\n        result[0].mnt_fsname = *(char **)v41;\n        result[0].mnt_dir = v13;\n        result[0].mnt_type = s2;\n        result[0].mnt_opts = v47;\n        v14 = result;\n        return sub_80822D1((const char **)&v14->mnt_fsname, 0);\n      }\nLABEL_27:\n      sub_804D5E0(\"you must be root\");\n    }\n    s1a = (const char *)sub_80B2E23(v7, v6);\n  }\n  else if ( (v8 & 0x10) == 0 )\n  {\n    v11 = setmntent(\"/proc/mounts\", \"r\");\n    if ( !v11 )\n      sub_804D5E0(\"no %s\", \"/proc/mounts\");\n    while ( getmntent_r(v11, result, (char *)&buf + 4, 1020) )\n    {\n      mnt_type = result[0].mnt_type;\n      if ( !s2 || !strcmp(result[0].mnt_type, s2) )\n        printf(\"%s on %s type %s (%s)\\n\", result[0].mnt_fsname, result[0].mnt_dir, mnt_type, result[0].mnt_opts);\n    }\n    return 0;\n  }\n  v15 = sub_80820C6(v47, 0);\n  if ( v40 && (v15 & 0xFFFF7FFF) != 0 )\n    goto LABEL_27;\n  if ( (v15 & 0x1E0000) != 0 )\n  {\n    if ( mount(&data, *(const char **)v41, &data, v15, &data) )\n      sub_804D3FF(*(const char **)v41);\n    return 0;\n  }\n  if ( v40 )\n    file = \"/etc/fstab\";\n  if ( (v15 & 0x20) != 0 )\n    file = \"/proc/mounts\";\n  stream = setmntent(file, \"r\");\n  if ( !stream )\n    sub_804D3C9((int)\"can't read '%s'\", file);\n  memset(result, 0, sizeof(result));\n  v16 = result;\n  v42 = 0;\nLABEL_42:\n  v17 = &result[1];\n  for ( i = (char *)&dword_80DB978 + 2; ; i = (char *)(&buf + 1) )\n  {\n    v19 = getmntent_r(stream, v16, i, 510) == 0;\n    v20 = *(const char **)v41;\n    if ( v19 )\n      break;\n    if ( v20 )\n    {\n      mnt_fsname = v16->mnt_fsname;\n      if ( !strcmp(v20, v16->mnt_fsname)\n        || !strcmp(s1a, mnt_fsname)\n        || (mnt_dir = v16->mnt_dir, !strcmp(v20, mnt_dir))\n        || !strcmp(s1a, mnt_dir) )\n      {\n        v16 = v17;\n      }\n    }\n    else\n    {\n      if ( v40 )\n        goto LABEL_27;\n      if ( sub_80B0232() )\n      {\n        if ( (sub_80820C6(v16->mnt_opts, 0) & 0x60000000) == 0 )\n        {\n          v23 = strcasecmp(v16->mnt_type, \"swap\");\n          v25 = v35;\n          if ( v23 )\n          {\n            v26 = v49;\n            mnt_opts = v16->mnt_opts;\n            if ( v49 )\n            {\n              while ( *v26 )\n              {\n                v27 = 0;\n                if ( *v26 == 110 && v26[1] == 111 )\n                {\n                  v26 += 2;\n                  v27 = 1;\n                }\n                v45 = (_BYTE *)strchrnul(v25, v24, v26, 44);\n                v28 = v45 - v26;\n                for ( j = mnt_opts; ; j = v32 + 1 )\n                {\n                  s = (char *)j;\n                  v30 = strncmp(j, v26, v28);\n                  v25 = s;\n                  if ( !v30 )\n                  {\n                    v31 = s[v28];\n                    if ( v31 == 44 || !v31 )\n                    {\n                      if ( v27 )\n                        goto LABEL_49;\n                      goto LABEL_73;\n                    }\n                  }\n                  v32 = strchr(s, 44);\n                  v24 = v36;\n                  v25 = v37;\n                  if ( !v32 )\n                    break;\n                }\n                if ( !v27 )\n                  goto LABEL_49;\nLABEL_73:\n                if ( !*v45 )\n                  break;\n                v26 = v45 + 1;\n              }\n            }\n            v16->mnt_opts = sub_804DB46(mnt_opts);\n            if ( !sub_80AB375() && sub_80822D1((const char **)&v16->mnt_fsname, 1) )\n              ++v42;\n            free(v16->mnt_opts);\n          }\n        }\n      }\n    }\nLABEL_49:\n    v17 = result;\n    if ( v16 == result )\n      goto LABEL_42;\n  }\n  if ( v20 )\n  {\n    if ( !v17->mnt_fsname )\n      sub_804D5E0(\"can't find %s in %s\", v20, file);\n    if ( !v40 || (sub_80820C6(v17->mnt_opts, 0) & 0x8000000) != 0 )\n    {\n      v17->mnt_opts = sub_804DB46(v17->mnt_opts);\n      sub_80821AC((void **)&v17->mnt_opts, v47, v33);\n      v14 = v17;\n      return sub_80822D1((const char **)&v14->mnt_fsname, 0);\n    }\n    goto LABEL_27;\n  }\n  return v42;\n}\n"
        ],
        "134753221": [
            "sub_8082BC5",
            "0x8082bc5",
            "int __cdecl sub_8082BC5(int a1, int a2)\n{\n  char v2; // di\n  const char *v3; // esi\n  int v4; // ebx\n  unsigned __int64 v5; // kr00_8\n  unsigned int v6; // ebp\n  unsigned int v7; // eax\n  const char *v8; // eax\n  char *v9; // ebp\n  int v10; // edx\n  int v11; // ecx\n  unsigned int v12; // ebp\n  unsigned int v13; // eax\n  const char *v14; // eax\n  const char *v15; // eax\n  __int64 v17; // [esp+0h] [ebp-80h]\n  unsigned __int64 v18; // [esp+8h] [ebp-78h]\n  __int64 v19[2]; // [esp+10h] [ebp-70h] BYREF\n  int v20; // [esp+20h] [ebp-60h]\n  unsigned __int64 dev; // [esp+30h] [ebp-50h]\n  unsigned int v22; // [esp+68h] [ebp-18h]\n  unsigned int v23; // [esp+6Ch] [ebp-14h]\n\n  v2 = sub_80ABEAC(a2, \"^qdxn\");\n  v3 = *(const char **)(a2 + 4 * optind);\n  if ( (v2 & 4) != 0 )\n  {\n    v4 = stat64(v3, v19);\n    if ( !v4 )\n    {\n      if ( (v20 & 0xF000) == 24576 )\n      {\n        v5 = dev;\n        v6 = gnu_dev_minor(dev);\n        v7 = gnu_dev_major(v5);\n        printf(\"%u:%u\\n\", v7, v6);\n        return v4;\n      }\n      *(_DWORD *)dword_80DBB7C = 0;\n      v8 = \"%s: not a block device\";\n      goto LABEL_25;\n    }\nLABEL_24:\n    v8 = \"\\r\\n%s\" + 2;\nLABEL_25:\n    v4 = v2 & 1;\n    if ( (v2 & 1) == 0 )\n    {\n      sub_804D3A5((int)v8, v3);\n      return 1;\n    }\n    return v4;\n  }\n  if ( lstat64(v3, v19) )\n    goto LABEL_24;\n  *(_DWORD *)dword_80DBB7C = 20;\n  if ( (v20 & 0xF000) != 0x4000 )\n    goto LABEL_24;\n  v17 = v19[0];\n  v18 = __PAIR64__(v22, v23);\n  v9 = sub_804DDBF(\"%s/..\", v3);\n  v4 = stat64(v9, v19);\n  v10 = HIDWORD(v18);\n  v11 = v18;\n  if ( v4 )\n  {\n    v3 = v9;\n    goto LABEL_24;\n  }\n  if ( v19[0] == v17 )\n  {\n    v11 = v23 ^ v18;\n    v10 = v23 ^ v18 | v22 ^ HIDWORD(v18);\n    v4 = v18 != __PAIR64__(v22, v23);\n  }\n  if ( (v2 & 2) != 0 )\n  {\n    v12 = gnu_dev_minor(v17);\n    v13 = gnu_dev_major(v17);\n    printf(\"%u:%u\\n\", v13, v12);\n  }\n  if ( (v2 & 8) != 0 )\n  {\n    v14 = (const char *)sub_80AB672(v11, v10);\n    if ( !v14 )\n      v14 = \"UNKNOWN\";\n    printf(\"%s %s\\n\", v14, v3);\n  }\n  if ( (v2 & 0xB) == 0 )\n  {\n    v15 = \"not \";\n    if ( !v4 )\n      v15 = &data;\n    printf(\"%s is %sa mountpoint\\n\", v3, v15);\n  }\n  return v4;\n}\n"
        ],
        "134753692": [
            "sub_8082D9C",
            "0x8082d9c",
            "int __cdecl sub_8082D9C(int a1, int a2)\n{\n  int v3; // [esp-8h] [ebp-8h]\n  int v4; // [esp-4h] [ebp-4h]\n\n  if ( a1 != 3 )\n    sub_804CDC2();\n  if ( pivot_root(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8)) < 0 )\n    sub_80B0A23(v4, v3);\n  return 0;\n}\n"
        ],
        "134753733": [
            "sub_8082DC5",
            "0x8082dc5",
            "void __cdecl __noreturn sub_8082DC5(int a1)\n{\n  sub_804D5E0(\"timeout connecting to time server\");\n}\n"
        ],
        "134753743": [
            "sub_8082DCF",
            "0x8082dcf",
            "int __cdecl sub_8082DCF(int a1, int a2)\n{\n  time_t v2; // ecx\n  int v3; // ebx\n  const char *v4; // esi\n  int v5; // eax\n  char *v6; // eax\n  time_t buf[3]; // [esp+0h] [ebp-Ch] BYREF\n\n  buf[0] = v2;\n  v3 = sub_80ABEAC(a2, \"^sp\");\n  v4 = *(const char **)(a2 + 4 * optind);\n  alarm(0xAu);\n  signal(14, (__sighandler_t)sub_8082DC5);\n  v5 = sub_80B4645();\n  if ( sub_804E5BC(4u, buf, v5) != 4 )\n    sub_804D5E0(\"%s: %s\", v4, \"short read\");\n  buf[0] = _byteswap_ulong(buf[0]) + 2085978496;\n  if ( (v3 & 2) != 0 )\n    goto LABEL_4;\n  if ( time(0) == buf[0] )\n  {\n    sub_804D5F4(\"current time matches remote time\");\n  }\n  else if ( stime(buf) < 0 )\n  {\n    sub_804D3C9((int)\"can't set time of day\");\n  }\n  if ( v3 != 1 )\n  {\nLABEL_4:\n    v6 = ctime(buf);\n    printf(\"%s\", v6);\n  }\n  return 0;\n}\n"
        ],
        "134753936": [
            "sub_8082E90",
            "0x8082e90",
            "int __cdecl sub_8082E90(int a1, int a2)\n{\n  __int16 v2; // ax\n  size_t v3; // ebx\n  int v4; // edi\n  unsigned int *v5; // ecx\n  unsigned int v6; // eax\n  _DWORD *v7; // edx\n  int v8; // ebx\n  unsigned int *i; // eax\n  bool v10; // cl\n  unsigned int v11; // ebx\n  unsigned int v12; // esi\n  int v13; // esi\n  unsigned __int64 v14; // rax\n  long double v15; // fst7\n  unsigned __int64 v16; // rcx\n  unsigned int v17; // edi\n  unsigned int k; // esi\n  bool v20; // [esp+1h] [ebp-209h]\n  int v21; // [esp+Eh] [ebp-1FCh]\n  int v22; // [esp+12h] [ebp-1F8h]\n  __int64 v23; // [esp+12h] [ebp-1F8h]\n  unsigned __int64 v24; // [esp+12h] [ebp-1F8h]\n  unsigned int v25; // [esp+1Ah] [ebp-1F0h]\n  int j; // [esp+1Eh] [ebp-1ECh]\n  unsigned int v27; // [esp+22h] [ebp-1E8h]\n  unsigned int v28; // [esp+26h] [ebp-1E4h]\n  unsigned int *v29; // [esp+32h] [ebp-1D8h]\n  __int64 v30; // [esp+3Ah] [ebp-1D0h]\n  __int16 v31; // [esp+42h] [ebp-1C8h]\n  const char *v32; // [esp+52h] [ebp-1B8h] BYREF\n  const char *v33; // [esp+56h] [ebp-1B4h] BYREF\n  unsigned int v34; // [esp+5Ah] [ebp-1B0h]\n  int v35; // [esp+5Eh] [ebp-1ACh] BYREF\n  __int64 v36; // [esp+62h] [ebp-1A8h] BYREF\n  __int64 v37; // [esp+6Ah] [ebp-1A0h] BYREF\n  unsigned __int8 v38; // [esp+72h] [ebp-198h] BYREF\n  char s1[128]; // [esp+7Ah] [ebp-190h] BYREF\n  char src[128]; // [esp+FAh] [ebp-110h] BYREF\n  char s[128]; // [esp+17Ah] [ebp-90h] BYREF\n  int *v42; // [esp+1FAh] [ebp-10h]\n\n  v42 = &a1;\n  v33 = \"/proc/profile\";\n  v32 = \"/boot/System.map\";\n  v35 = 0;\n  v2 = sub_80ABEAC(a2, \"M:+m:p:nabsirv\", &v35, &v32, &v33);\n  v31 = v2;\n  if ( (v2 & 0x101) != 0 )\n  {\n    v3 = (v2 & 1) == 0 ? 1 : 4;\n    v4 = sub_804DBE1(\"/proc/profile\");\n    sub_804DCAD(v3, &v35);\n    close(v4);\n  }\n  else\n  {\n    v34 = 0x7FFFFFFF;\n    v29 = (unsigned int *)sub_80B2528();\n    v6 = v34;\n    v7 = (_DWORD *)(v34 >> 2);\n    v34 >>= 2;\n    if ( (v31 & 8) == 0 )\n    {\n      v7 = v29 + 1;\n      v5 = 0;\n      v8 = 0;\n      while ( v7 < (unsigned int *)((char *)v29 + (v6 & 0xFFFFFFFC)) )\n      {\n        v8 += (*v7 & 0xFFFF0000) != 0;\n        if ( (unsigned __int16)*v7 )\n          v5 = (unsigned int *)((char *)v5 + 1);\n        ++v7;\n      }\n      if ( v8 > (int)v5 )\n      {\n        sub_804D5F4(\"assuming reversed byte order, use -n to force native byte order\");\n        v5 = &v29[v34];\n        for ( i = v29; v5 > i; ++i )\n        {\n          v7 = (_DWORD *)_byteswap_ulong(*i);\n          *i = (unsigned int)v7;\n        }\n      }\n    }\n    v25 = *v29;\n    if ( (v31 & 0x80u) == 0 )\n    {\n      v21 = sub_80B3D45(v5, v7);\n      for ( j = 1; ; ++j )\n      {\n        if ( !fgets_unlocked(s, 128, v21) )\n          goto LABEL_20;\n        if ( sscanf(s, \"%llx %s %s\", &v36, &v38, s1) != 3 )\nLABEL_26:\n          sub_804D5E0(\"%s(%i): wrong map line\", v32, j);\n        if ( !strcmp(s1, \"_stext\") )\n          break;\n      }\n      v30 = v36;\n      if ( !v36 )\nLABEL_20:\n        sub_804D5E0(\"can't find \\\"_stext\\\" in %s\", v32);\n      v27 = 0;\n      v28 = 1;\n      while ( fgets_unlocked(s, 128, v21) )\n      {\n        if ( sscanf(s, \"%llx %s %s\", &v37, &v38, src) != 3 )\n          goto LABEL_26;\n        if ( ((v38 - 63) & 0xFD) != 0 || v27 )\n        {\n          v10 = (v38 | 0x20) != 116 && (v38 | 0x20) != 119;\n          if ( v10 )\n            break;\n          if ( v28 >= v34 )\n            sub_804D5E0(\"profile address out of range. Wrong map file?\");\n          v22 = v25 * (v28 - 1);\n          v11 = 0;\n          while ( 1 )\n          {\n            v20 = v10;\n            v13 = v37;\n            v14 = sub_80B4B88((int)v37 - (int)v30, (unsigned __int64)(v37 - v30) >> 32, v25, 0);\n            v10 = v20;\n            if ( v28 >= v14 )\n              break;\n            v12 = v29[v28];\n            if ( (v31 & 0x20) != 0 && (v12 || (v31 & 0x10) != 0) )\n            {\n              if ( !v20 )\n                printf(\"%s:\\n\", s1);\n              printf(\"\\t%llx\\t%u\\n\", v30 + (unsigned int)v22, v12);\n              v10 = 1;\n            }\n            ++v28;\n            v11 += v12;\n            v22 += v25;\n          }\n          v27 += v11;\n          if ( (v31 & 0x20) != 0 )\n          {\n            if ( v11 | v31 & 0x200 )\n              printf(\"  total\\t\\t\\t\\t%u\\n\", v11);\n          }\n          else if ( (v11 || (v31 & 0x10) != 0) && v13 != (_DWORD)v36 )\n          {\n            v15 = (long double)v11 / (long double)(unsigned int)(v13 - v36);\n            if ( (v31 & 0x200) != 0 )\n              printf(\"%016llx %-40s %6u %8.4f\\n\", v36, s1, v11, (double)v15);\n            else\n              printf(\"%6u %-40s %8.4f\\n\", v11, s1, (double)v15);\n            if ( (v31 & 0x40) != 0 )\n            {\n              v23 = sub_80B4B88((int)v36 - (int)v30, (unsigned __int64)(v36 - v30) >> 32, v25, 0);\n              v16 = v23 + 1;\n              v17 = (v30 + (unsigned __int64)v25 * v23) >> 32;\n              for ( k = v30 + v25 * v23; ; k += v25 )\n              {\n                v24 = v16;\n                if ( sub_80B4B88((int)v37 - (int)v30, (unsigned __int64)(v37 - v30) >> 32, v25, 0) <= v16 )\n                  break;\n                printf(\"\\t%#llx\\t%s+%#llx\\t%u\\n\", __PAIR64__(v17, k), s1, __PAIR64__(v17, k) - v36, v29[(_DWORD)v24]);\n                v16 = v24 + 1;\n                v17 = (v25 + __PAIR64__(v17, k)) >> 32;\n              }\n            }\n          }\n          v36 = v37;\n          strcpy(s1, src);\n          ++j;\n        }\n      }\n      printf(\"%6u *unknown*\\n\", v29[v34 - 1]);\n      if ( (v31 & 0x200) != 0 )\n        printf(\n          \"%016x %-40s %6u %8.4f\\n\",\n          0,\n          \"total\",\n          v27,\n          (double)((long double)v27 / (double)(unsigned __int64)(v36 - v30)));\n      else\n        printf(\"%6u %-40s %8.4f\\n\", v27, \"total\", (double)((long double)v27 / (double)(unsigned __int64)(v36 - v30)));\n    }\n    else\n    {\n      printf(\"Sampling_step: %u\\n\", v25);\n    }\n  }\n  return 0;\n}\n"
        ],
        "134755859": [
            "sub_8083613",
            "0x8083613",
            "int __cdecl sub_8083613(int a1, int a2)\n{\n  _BYTE *v2; // eax\n  _BYTE *v3; // eax\n  int v4; // ebp\n  __priority_which_t v5; // edi\n  int v6; // esi\n  int v7; // ebx\n  char *v8; // eax\n  struct passwd *v9; // eax\n  int pw_uid; // edx\n  _DWORD *v11; // ebx\n  int v12; // eax\n  int v13; // eax\n  int *v15; // [esp+0h] [ebp-1Ch]\n  int v16; // [esp+4h] [ebp-18h]\n  id_t who; // [esp+8h] [ebp-14h]\n\n  v15 = (int *)(a2 + 4);\n  v2 = *(_BYTE **)(a2 + 4);\n  if ( !v2 )\n    goto LABEL_8;\n  if ( *v2 == 45 && v2[1] == 110 )\n  {\n    if ( v2[2] )\n    {\n      v3 = v2 + 2;\n    }\n    else\n    {\n      v15 = (int *)(a2 + 8);\n      v3 = *(_BYTE **)(a2 + 8);\n    }\n    if ( !v3 )\nLABEL_8:\n      sub_804CDC2();\n    v4 = 1;\n  }\n  else\n  {\n    v4 = 0;\n  }\n  v16 = sub_80B4160(0x3FFFFFFF, -1073741824);\n  v5 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    v7 = *++v15;\n    if ( !*v15 )\n      return v6;\n    if ( *(_BYTE *)v7 != 45 )\n      goto LABEL_18;\n    if ( !*(_BYTE *)(v7 + 1) )\n      goto LABEL_18;\n    v8 = strchr(\"pgu\", *(unsigned __int8 *)(v7 + 1));\n    if ( !v8 )\n      goto LABEL_18;\n    v5 = (unsigned __int8)v8[4];\n    if ( *(_BYTE *)(v7 + 2) )\n    {\n      v7 += 2;\nLABEL_18:\n      if ( v5 == 2 )\n      {\n        v9 = getpwnam((const char *)v7);\n        if ( !v9 )\n        {\n          sub_804D5F4(\"unknown user %s\", v7);\n          goto LABEL_32;\n        }\n        pw_uid = v9->pw_uid;\nLABEL_25:\n        if ( !v4 )\n        {\n          v13 = v16;\n          goto LABEL_30;\n        }\n        v11 = (_DWORD *)dword_80DBB7C;\n        *(_DWORD *)dword_80DBB7C = 0;\n        who = pw_uid;\n        v12 = getpriority(v5, pw_uid);\n        pw_uid = who;\n        if ( *v11 )\n        {\n          sub_804D3A5((int)\"%cetpriority\", 103);\n          v6 = v4;\n        }\n        else\n        {\n          v13 = v16 + v12;\nLABEL_30:\n          if ( setpriority(v5, pw_uid, v13) )\n          {\n            sub_804D3A5((int)\"%cetpriority\", 115);\n            goto LABEL_32;\n          }\n        }\n      }\n      else\n      {\n        pw_uid = sub_804ED6C(10, (const char *)v7, 0, v7);\n        if ( !*(_DWORD *)dword_80DBB7C )\n          goto LABEL_25;\n        sub_804D5F4(\"invalid number '%s'\", v7);\nLABEL_32:\n        v6 = 1;\n      }\n    }\n  }\n}\n"
        ],
        "134756205": [
            "sub_808376D",
            "0x808376d",
            "void __cdecl __noreturn sub_808376D(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  char v4; // al\n  unsigned int v5; // esi\n  _DWORD *v6; // eax\n\n  v2 = a2;\n  if ( *ident == 115 )\n  {\n    v3 = *(_BYTE **)(a2 + 4);\n    if ( v3 )\n    {\n      if ( sub_804D210(v3, \"linux\") )\n      {\n        ident = *(char **)(a2 + 4);\n        v2 = a2 + 4;\n      }\n    }\n  }\n  v4 = ident[5];\n  if ( v4 == 54 )\n  {\n    v5 = 0;\n  }\n  else\n  {\n    if ( v4 != 51 )\n      sub_804CDC2();\n    v5 = 8;\n  }\n  if ( sub_80ABEAC(v2, &unk_80D478F) )\n    v5 |= 0x40000u;\n  if ( personality(v5) < 0 )\n    sub_804D3C9((int)\"personality(0x%lx)\", v5);\n  v6 = (_DWORD *)(v2 + 4 * optind);\n  if ( !*v6 )\n    *(v6 - 1) = \"/bin/sh\";\n  sub_80AB1EC();\n}\n"
        ],
        "134756356": [
            "sub_8083804",
            "0x8083804",
            "int __usercall sub_8083804@<eax>(const char *a1@<eax>)\n{\n  if ( *a1 != 43 && *a1 != 45 )\n    sub_804D5E0(\"invalid capability '%s'\", a1);\n  return sub_80A9AA8();\n}\n"
        ],
        "134756385": [
            "sub_8083821",
            "0x8083821",
            "int __cdecl sub_8083821(int a1, int a2)\n{\n  int v2; // ebx\n  _DWORD *v3; // esi\n  int v4; // edi\n  int v5; // esi\n  int v6; // ebx\n  const char *v7; // eax\n  int v8; // ebx\n  const char *v9; // eax\n  int v10; // ebx\n  const char *v11; // esi\n  int v12; // eax\n  int v13; // ebx\n  const char *v14; // esi\n  int v15; // eax\n  char *v16; // ebp\n  char *i; // eax\n  const char *v18; // ebp\n  unsigned int v19; // ecx\n  int v20; // edx\n  int v21; // ecx\n  int v22; // eax\n  char *j; // eax\n  char *v24; // ebx\n  int v25; // eax\n  int v27; // [esp+0h] [ebp-5Ch]\n  char *s; // [esp+4h] [ebp-58h] BYREF\n  char *v29; // [esp+8h] [ebp-54h] BYREF\n  int v30; // [esp+Ch] [ebp-50h] BYREF\n  int v31; // [esp+10h] [ebp-4Ch] BYREF\n  char v32[4]; // [esp+14h] [ebp-48h] BYREF\n  int v33; // [esp+18h] [ebp-44h] BYREF\n  int v34; // [esp+1Ch] [ebp-40h] BYREF\n  char v35[4]; // [esp+20h] [ebp-3Ch] BYREF\n  int v36; // [esp+24h] [ebp-38h]\n  char v37[8]; // [esp+28h] [ebp-34h] BYREF\n  unsigned int v38; // [esp+30h] [ebp-2Ch]\n  char v39[40]; // [esp+34h] [ebp-28h] BYREF\n\n  v2 = sub_80ABEC2(a2, &unk_80D47BD, \"dump\", &s, &v29);\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v2 & 1) == 0 )\n  {\n    if ( (v2 & 8) != 0 && prctl(38, 1, 0, 0, 0) )\n      sub_804D3C9((int)\"prctl: %s\", \"SET_NO_NEW_PRIVS\");\n    if ( (v2 & 2) != 0 )\n    {\n      v16 = s;\n      sub_80A9B19();\n      for ( i = strtok(v16, \",\"); ; i = strtok(0, \",\") )\n      {\n        v18 = i;\n        if ( !i )\n          break;\n        v19 = sub_8083804(i);\n        if ( v19 >> 5 >= v38 )\n          sub_804D5E0(\"invalid capability '%s'\", v18);\n        v20 = 12 * (v19 >> 5);\n        v27 = *(_DWORD *)&v39[v20 + 8];\n        v21 = 1 << v19;\n        if ( *v18 == 43 )\n          v22 = v21 | v27;\n        else\n          v22 = ~v21 & v27;\n        *(_DWORD *)&v39[v20 + 8] = v22;\n      }\n      if ( capset(v37, v39) )\n        sub_804D3C9((int)\"capset\");\n    }\n    if ( (v2 & 4) != 0 )\n    {\n      for ( j = strtok(v29, \",\"); ; j = strtok(0, \",\") )\n      {\n        v24 = j;\n        if ( !j )\n          break;\n        v25 = sub_8083804(j);\n        if ( *v24 == 43 )\n        {\n          if ( prctl(47, 2, v25, 0, 0) < 0 )\n            sub_804D3A5((int)\"cap_ambient_raise\");\n        }\n        else if ( prctl(47, 3, v25, 0, 0) < 0 )\n        {\n          sub_804D3A5((int)\"cap_ambient_lower\");\n        }\n      }\n    }\n    if ( *v3 )\n      sub_80AB1EC();\nLABEL_4:\n    sub_804CDC2();\n  }\n  if ( *v3 || v2 != 1 )\n    goto LABEL_4;\n  getresuid(&v30, &v31, v32);\n  getresgid(&v33, &v34, v35);\n  v36 = 0;\n  v4 = sub_80A991A();\n  v5 = prctl(39, 0, 0, 0, 0);\n  if ( v5 < 0 )\n    sub_804D3C9((int)\"prctl: %s\", \"GET_NO_NEW_PRIVS\");\n  printf(\"uid: %u\\n\", v30);\n  printf(\"euid: %u\\n\", v31);\n  printf(\"gid: %u\\n\", v33);\n  printf(\"egid: %u\\n\", v34);\n  printf(\"Supplementary groups: \");\n  if ( v36 )\n  {\n    v6 = 0;\n    v7 = \"%u\";\n    while ( v6 < v36 )\n    {\n      printf(v7, *(_DWORD *)(v4 + 4 * v6++));\n      v7 = \"dev %u,%u\" + 6;\n    }\n  }\n  else\n  {\n    printf(\"[none]\");\n  }\n  printf(\"\\nno_new_privs: %d\\n\", v5);\n  sub_80A9B19();\n  printf(\"Inheritable capabilities: \");\n  v8 = 0;\n  v9 = &data;\n  while ( v8 != 38 )\n  {\n    if ( v8 >> 5 >= v38 )\n    {\n      printf(\"\\nindex: %u u32s: %u capability: %u\\n\", v8 >> 5, v38, v8);\n      sub_804D5E0(\"unsupported capability\");\n    }\n    if ( ((1 << v8) & *(_DWORD *)&v39[12 * (v8 >> 5) + 8]) != 0 )\n    {\n      sub_80A9AF5();\n      v9 = \"Linux User,,,\" + 12;\n    }\n    ++v8;\n  }\n  if ( !*v9 )\n    printf(\"[none]\");\n  printf(\"\\nAmbient capabilities: \");\n  v10 = 0;\n  v11 = &data;\n  while ( v10 != 38 )\n  {\n    v12 = prctl(47, 1, v10, 0, 0);\n    if ( v12 < 0 )\n      sub_804D3C9((int)\"prctl: %s\", \"CAP_AMBIENT_IS_SET\");\n    if ( v12 )\n    {\n      sub_80A9AF5();\n      v11 = \"Linux User,,,\" + 12;\n    }\n    ++v10;\n  }\n  if ( !*v11 )\n    printf(\"[none]\");\n  printf(\"\\nCapability bounding set: \");\n  v13 = 0;\n  v14 = &data;\n  while ( v13 != 38 )\n  {\n    v15 = prctl(23, v13, 0, 0, 0);\n    if ( v15 < 0 )\n      sub_804D3C9((int)\"prctl: %s\", \"CAPBSET_READ\");\n    if ( v15 )\n    {\n      sub_80A9AF5();\n      v14 = \"Linux User,,,\" + 12;\n    }\n    ++v13;\n  }\n  if ( !*v14 )\n    printf(\"[none]\");\n  sub_804DD98(10);\n  return 0;\n}\n"
        ],
        "134757327": [
            "sub_8083BCF",
            "0x8083bcf",
            "int __cdecl sub_8083BCF(int a1, int a2)\n{\n  int v2; // esi\n\n  v2 = sub_80ABEAC(a2, &unk_80D4933);\n  if ( setsid() >= 0 )\n    goto LABEL_4;\n  if ( !sub_804E17C() )\n  {\n    setsid();\nLABEL_4:\n    if ( v2 )\n      ioctl(0, 0x540Eu, 1);\n    sub_80AB1EC();\n  }\n  return 0;\n}\n"
        ],
        "134757412": [
            "sub_8083C24",
            "0x8083c24",
            "int __usercall sub_8083C24@<eax>(char *a1@<eax>)\n{\n  int v1; // eax\n  int v2; // ebx\n  int v3; // eax\n  char v4; // dl\n  char *path; // [esp+0h] [ebp-70h] BYREF\n  char v7[16]; // [esp+4h] [ebp-6Ch] BYREF\n  int v8; // [esp+14h] [ebp-5Ch]\n  __int64 v9; // [esp+30h] [ebp-40h]\n  __int64 v10; // [esp+3Ch] [ebp-34h]\n\n  path = a1;\n  sub_808487E(&path);\n  if ( ident[5] == 102 )\n  {\n    v1 = swapoff(path);\n    if ( (dword_80DBB9C & 1) != 0 && (*(_DWORD *)dword_80DBB7C == 2 || *(_DWORD *)dword_80DBB7C == 22) || !v1 )\n      return 0;\n    goto LABEL_20;\n  }\n  v2 = stat64(path, v7);\n  if ( v2 )\n  {\n    v4 = 0;\n    goto LABEL_15;\n  }\n  if ( (v8 & 0xF000) != 0x8000 || v10 << 9 >= v9 )\n  {\n    v3 = swapon(path, 0);\n    if ( (dword_80DBB9C & 1) != 0 )\n      LOBYTE(v2) = *(_DWORD *)dword_80DBB7C == 16;\n    v4 = v2;\n    v2 = v3;\n    if ( !v3 )\n    {\n      v2 = 0;\nLABEL_18:\n      if ( v2 && (v4 & 1) == 0 )\n      {\nLABEL_20:\n        sub_804D3F1(path);\n        return 1;\n      }\n      return 0;\n    }\nLABEL_15:\n    if ( (dword_80DBB9C & 2) != 0 && *(_DWORD *)dword_80DBB7C == 2 )\n      return 0;\n    goto LABEL_18;\n  }\n  sub_804D5F4(\"%s: file has holes\", path);\n  return 1;\n}\n"
        ],
        "134757684": [
            "sub_8083D34",
            "0x8083d34",
            "int __usercall sub_8083D34@<eax>(int a1@<ebx>, int a2, int a3)\n{\n  int v3; // edx\n  int v4; // ecx\n  char **v5; // edi\n  int v6; // ebx\n  char *v7; // eax\n  char *v8; // esi\n  int v9; // esi\n  struct mntent *v10; // eax\n  const struct mntent *v11; // ebp\n  int v12; // ebx\n  char *v13; // eax\n  FILE *stream; // [esp+0h] [ebp-14h]\n\n  sub_80ABEAC(a3, \"ae\", a1);\n  v5 = (char **)(a3 + 4 * optind);\n  if ( (dword_80DBB9C & 1) != 0 )\n  {\n    if ( ident[5] == 102 && sub_80B3D37() )\n    {\n      v6 = 0;\n      while ( 1 )\n      {\n        v7 = (char *)sub_80AB85A();\n        v8 = v7;\n        if ( !v7 )\n          break;\n        if ( *v7 == 47 )\n        {\n          *(_BYTE *)strchrnul(v4, v3, v7, 32) = 0;\n          v6 |= sub_8083C24(v8);\n        }\n        free(v8);\n      }\n    }\n    else\n    {\n      v6 = 0;\n    }\n    stream = (FILE *)sub_80B3D45(v4, v3);\n    v9 = 0;\n    while ( 1 )\n    {\n      v10 = getmntent(stream);\n      v11 = v10;\n      if ( !v10 )\n        break;\n      if ( !strcmp(v10->mnt_type, \"swap\") && (ident[5] == 102 || !hasmntopt(v11, \"noauto\")) )\n        v9 |= sub_8083C24(v11->mnt_fsname);\n    }\n    v12 = v9 | v6;\n  }\n  else\n  {\n    if ( !*v5 )\n      sub_804CDC2();\n    v12 = 0;\n  }\n  dword_80DBB9C &= ~1u;\n  while ( 1 )\n  {\n    v13 = *v5;\n    if ( !*v5 )\n      break;\n    ++v5;\n    v12 |= sub_8083C24(v13);\n  }\n  return v12;\n}\n"
        ],
        "134757949": [
            "sub_8083E3D",
            "0x8083e3d",
            "int __usercall sub_8083E3D@<eax>(const char *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n  int v5; // ebx\n  int v6; // [esp+0h] [ebp-34h] BYREF\n  int v7; // [esp+4h] [ebp-30h] BYREF\n  char s[44]; // [esp+8h] [ebp-2Ch] BYREF\n\n  result = sub_804E632((int)a1, s, 0x1Fu);\n  if ( result >= 0 )\n  {\n    s[result] = 0;\n    if ( sscanf(s, \"%u %u\", &v6, &v7) != 2 )\n      sub_804D3C9((int)\"can't parse file '%s'\", a1);\n    if ( a2 > 31 )\n      v7 &= __ROL4__(-2, a2 - 32);\n    else\n      v6 &= __ROL4__(-2, a2);\n    v5 = sub_804DBE1(a1);\n    dprintf(v5, \"%u %u\", v6, v7);\n    return close(v5);\n  }\n  return result;\n}\n"
        ],
        "134758106": [
            "sub_8083EDA",
            "0x8083eda",
            "int __usercall sub_8083EDA@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int result; // eax\n  int v7; // edi\n  _BYTE *v8; // edx\n  int v9; // ecx\n  DIR *v10; // esi\n  _BYTE *v11; // eax\n  void *v12; // ebp\n  int v13; // [esp-4h] [ebp-78h]\n  int v14; // [esp-4h] [ebp-78h]\n  int v15; // [esp+0h] [ebp-74h]\n  int v16; // [esp+4h] [ebp-70h] BYREF\n  int v17; // [esp+8h] [ebp-6Ch]\n  int v18; // [esp+14h] [ebp-60h]\n\n  result = lstat64(a1, &v16);\n  if ( !result )\n  {\n    result = v16;\n    v15 = v16;\n    v7 = v17;\n    if ( v17 == a3 && v16 == a2 )\n    {\n      if ( (v18 & 0xF000) == 0x4000 )\n      {\n        v10 = opendir(a1);\n        result = v13;\n        if ( v10 )\n        {\n          while ( 1 )\n          {\n            v11 = (_BYTE *)readdir64(v9, v8, v10);\n            if ( !v11 )\n              break;\n            v8 = v11 + 19;\n            if ( v11[19] == 46 )\n            {\n              LOBYTE(v9) = v11[20];\n              if ( !(_BYTE)v9 || (_BYTE)v9 == 46 && !v11[21] )\n                continue;\n            }\n            v12 = (void *)sub_804D2D1((int)a1, v8, v9);\n            sub_8083EDA(v7, v15);\n            free(v12);\n          }\n          closedir(v10);\n          return rmdir(a1);\n        }\n      }\n      else\n      {\n        unlink(a1);\n        return v14;\n      }\n    }\n  }\n  return result;\n}\n"
        ],
        "134758285": [
            "sub_8083F8D",
            "0x8083f8d",
            "int __cdecl sub_8083F8D(int a1, int a2)\n{\n  int v2; // ebx\n  char *i; // edi\n  int v4; // esi\n  int v5; // eax\n  const char **v6; // esi\n  int v7; // ebp\n  int v8; // eax\n  const char *v9; // eax\n  const char *v11; // [esp-4h] [ebp-D4h]\n  int v12; // [esp+0h] [ebp-D0h]\n  const char *v13; // [esp+8h] [ebp-C8h] BYREF\n  char *s[21]; // [esp+Ch] [ebp-C4h] BYREF\n  int v15; // [esp+60h] [ebp-70h] BYREF\n  int v16; // [esp+64h] [ebp-6Ch]\n  char v17[4]; // [esp+6Ch] [ebp-64h] BYREF\n  int v18; // [esp+70h] [ebp-60h]\n  int v19[23]; // [esp+74h] [ebp-5Ch]\n\n  v13 = 0;\n  if ( *ident == 115 )\n  {\n    sub_80ABEAC(a2, \"^+c:\", &v13);\n    v2 = 0;\n  }\n  else\n  {\n    s[0] = 0;\n    v2 = sub_80ABEAC(a2, \"^+c:d:n\", &v13, s) >> 2;\n    if ( s[0] )\n    {\n      for ( i = strtok(s[0], \",\"); ; i = strtok(0, \",\") )\n      {\n        if ( !i )\n          goto LABEL_15;\n        v4 = sub_80A9AA8();\n        sub_8083E3D(\"/proc/sys/kernel/usermodehelper/bset\", v4);\n        sub_8083E3D(\"/proc/sys/kernel/usermodehelper/inheritable\", v4);\n        v5 = prctl(23, v4, 0, 0, 0);\n        if ( v5 < 0 )\n          break;\n        if ( v5 == 1 && prctl(24, v4, 0, 0, 0) )\n        {\n          v11 = \"PR_CAPBSET_DROP\";\nLABEL_11:\n          sub_804D3C9((int)\"prctl: %s\", v11);\n        }\n        sub_80A9B19();\n        v19[3 * (v4 >> 5)] &= ~(1 << v4);\n        if ( capset(&v15, v17) )\n          sub_804D3C9((int)\"capset\");\n        sub_804D5F4(\"dropped capability: %s\", i);\n      }\n      v11 = (const char *)&unk_80D49DD;\n      goto LABEL_11;\n    }\n  }\nLABEL_15:\n  v6 = (const char **)(a2 + 4 * optind);\n  sub_804DF04(*v6);\n  sub_804DFF3(\"/\", (int)&v15);\n  v7 = v15;\n  v12 = v16;\n  sub_804DFF3(\".\", (int)&v15);\n  if ( v16 == v12 && v15 == v7 || !v2 && getpid() != 1 )\n    sub_804CDC2();\n  if ( stat64(\"/init\", &v15) || (v18 & 0xF000) != 0x8000 )\n    sub_804D5E0(\"'%s' is not a regular file\", \"/init\");\n  statfs64(\"/\", s);\n  if ( s[0] != (char *)16914836 && s[0] != (char *)-2054924042 )\n    sub_804D5E0(\"root filesystem is not ramfs/tmpfs\");\n  if ( !v2 )\n  {\n    sub_8083EDA(\"/\", v7, v12);\n    if ( mount(\".\", \"/\", 0, 0x2000u, 0) )\n      sub_804D3C9((int)&unk_80D4A58);\n  }\n  sub_804DF35(\".\");\n  if ( v13 )\n  {\n    v8 = sub_804DC14(v13);\n    if ( v8 >= 0 )\n    {\n      sub_804DC97(v8, 0);\n      sub_804DC7B(0, 1);\n      sub_804DC7B(0, 2);\n    }\n  }\n  v9 = v6[1];\n  if ( !v2 )\n  {\n    execv(v9, (char *const *)v6 + 1);\nLABEL_36:\n    sub_804D3C9((int)\"can't execute '%s'\", v6[1]);\n  }\n  if ( access(v9, 1) )\n    goto LABEL_36;\n  return 0;\n}\n"
        ],
        "134758983": [
            "sub_8084247",
            "0x8084247",
            "void __cdecl __noreturn sub_8084247(int a1, int a2)\n{\n  int v2; // esi\n  char *v3; // eax\n  char *v4; // ebx\n  ssize_t v5; // eax\n  _BYTE *v6; // edx\n  const char *v7; // ebp\n  int v8; // edi\n  char *v9; // eax\n  int v10; // ecx\n  size_t *v11; // edi\n  size_t *i; // edx\n  size_t *v13; // edx\n  char *v14; // eax\n  const char *v15; // eax\n  size_t *v16; // [esp+0h] [ebp-24h]\n  int v17; // [esp+4h] [ebp-20h]\n  struct sockaddr addr; // [esp+8h] [ebp-1Ch] BYREF\n\n  v17 = a2 + 4;\n  *(_DWORD *)&addr.sa_family = 16;\n  *(_DWORD *)&addr.sa_data[2] = getpid();\n  *(_DWORD *)&addr.sa_data[6] = 1;\n  v2 = sub_804DF99(15, 2, 16);\n  sub_804DFB3(0xCu, &addr, v2);\n  sub_804D670(v2);\n  sub_80B424A(0, 8);\n  sub_80B424A(0, 33);\n  while ( 1 )\n  {\n    v3 = (char *)mmap64(0, 0x4000, 3, 34, -1, 0, 0);\n    v4 = v3;\n    if ( v3 == (char *)-1 )\n      break;\n    v5 = sub_804E5BC(0x3FFFu, v3, v2);\n    if ( v5 < 0 )\n      sub_804D3C9(135046626);\n    v16 = (size_t *)&v4[v5];\n    v4[v5] = 0;\n    if ( !*(_DWORD *)(a2 + 4) )\n    {\n      v6 = *(_BYTE **)(_stdout + 16);\n      if ( (unsigned int)v6 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked(10, _stdout);\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v6 + 1;\n        *v6 = 10;\n      }\n    }\n    v7 = v4;\n    v8 = 0;\n    while ( v7 < (const char *)v16 )\n    {\n      if ( !*(_DWORD *)(a2 + 4) )\n        puts(v7);\n      v9 = strchr(v7, 61);\n      v10 = 4 * v8;\n      if ( v8 <= 254 )\n      {\n        if ( v9 )\n        {\n          ++v8;\n          *(size_t *)((char *)&buf + v10) = (size_t)v7;\n        }\n      }\n      v7 += strlen(v7) + 1;\n    }\n    *(&buf + v8) = 0;\n    v11 = &buf;\n    for ( i = &buf; ; i = v16 )\n    {\n      v13 = i + 1;\n      v14 = (char *)*(v13 - 1);\n      if ( !v14 )\n        break;\n      v16 = v13;\n      putenv(v14);\n    }\n    if ( *(_DWORD *)(a2 + 4) )\n      sub_80B3C03(\n        v16,\n        v17,\n        *(_DWORD *)&addr.sa_family,\n        *(_DWORD *)&addr.sa_data[2],\n        *(_DWORD *)&addr.sa_data[6],\n        *(_DWORD *)&addr.sa_data[10]);\n    while ( 1 )\n    {\n      v15 = (const char *)*v11++;\n      if ( !v15 )\n        break;\n      sub_804DDFA(v15);\n    }\n    munmap(v4, 0x4000u);\n  }\n  sub_804D3C9((int)\"mmap\");\n}\n"
        ],
        "134759394": [
            "sub_80843E2",
            "0x80843e2",
            "int __cdecl sub_80843E2(int a1, int a2)\n{\n  FILE *v2; // eax\n  FILE *v3; // ebx\n  const char **v4; // edi\n  const char **v5; // esi\n  const char **i; // ebp\n  bool j; // zf\n  const char *v8; // ebx\n  char *v9; // esi\n  int v11; // [esp-8h] [ebp-48h]\n  int v12; // [esp-4h] [ebp-44h]\n  char v13; // [esp+0h] [ebp-40h]\n  const char **v14; // [esp+4h] [ebp-3Ch]\n  int v15; // [esp+8h] [ebp-38h]\n  int v16; // [esp+14h] [ebp-2Ch] BYREF\n  struct mntent result; // [esp+18h] [ebp-28h] BYREF\n\n  v16 = 0;\n  v13 = sub_80ABEAC(a2, \"fldnrat:cvi\", &v16);\n  v14 = (const char **)(a2 + 4 * optind);\n  v2 = setmntent(\"/proc/mounts\", \"r\");\n  if ( v2 )\n  {\n    v3 = v2;\n    v4 = 0;\n    while ( getmntent_r(v3, &result, (char *)&buf, 1024) )\n    {\n      if ( sub_80B0232() )\n      {\n        v5 = (const char **)sub_804DB2E(0xCu);\n        v5[2] = (const char *)v4;\n        v5[1] = sub_804DB46(result.mnt_fsname);\n        *v5 = sub_804DB46(result.mnt_dir);\n        v4 = v5;\n      }\n    }\n    endmntent(v3);\n  }\n  else\n  {\n    if ( (v13 & 0x20) != 0 )\n      sub_804D5E0(\"can't open '%s'\", \"/proc/mounts\");\n    v4 = 0;\n  }\n  if ( (v13 & 0x20) != 0 )\n  {\n    i = v4;\n  }\n  else\n  {\n    i = 0;\n    if ( !*v14 )\n      sub_804CDC2();\n  }\n  v15 = 0;\n  while ( 1 )\n  {\n    v8 = *v14;\n    if ( i )\n    {\n      v9 = sub_804DB46(*i);\nLABEL_42:\n      v8 = *i;\n      goto LABEL_19;\n    }\n    if ( !v8 || (v13 & 0x20) != 0 )\n      return v15;\n    ++v14;\n    v9 = sub_804E29C(v8);\n    if ( v9 )\n    {\n      for ( i = v4; i; i = (const char **)i[2] )\n      {\n        if ( !strcmp(v9, *i) || !strcmp(v9, i[1]) )\n          goto LABEL_42;\n      }\n    }\nLABEL_19:\n    if ( umount2(v8, v13 & 3) )\n    {\n      if ( (v13 & 0x10) != 0 && *(_DWORD *)dword_80DBB7C == 16 && i )\n      {\n        if ( mount(i[1], v8, 0, 0x21u, 0) )\n        {\n          v15 = 1;\n          sub_804D5F4(\"can't remount %s read-only\", i[1]);\n        }\n        else\n        {\n          sub_804D5F4(\"%s busy - remounted read-only\", i[1]);\n        }\n        goto LABEL_39;\n      }\n      sub_804D3A5((int)\"can't unmount %s\", v8);\n      v15 = 1;\n    }\n    else if ( (v13 & 4) != 0 )\n    {\n      if ( i )\n      {\n        sub_80AFDF4(v11, v12);\n        goto LABEL_39;\n      }\n      goto LABEL_24;\n    }\n    for ( j = i == 0; !j; j = strcmp(v9, i[1]) == 0 )\n    {\nLABEL_39:\n      i = (const char **)i[2];\n      if ( !i || (v13 & 0x20) != 0 )\n        break;\n    }\nLABEL_24:\n    free(v9);\n  }\n}\n"
        ],
        "134759984": [
            "sub_8084630",
            "0x8084630",
            "int __usercall sub_8084630@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n\n  v1 = dword_80DB720;\n  if ( !dword_80DB720 )\n  {\n    if ( a1 )\n      sub_80B2549(0, 0, 0);\n    return dword_80DB720;\n  }\n  return v1;\n}\n"
        ],
        "134760033": [
            "sub_8084661",
            "0x8084661",
            "int __cdecl sub_8084661(int a1)\n{\n  int result; // eax\n  int i; // ebx\n  const char *v3; // eax\n\n  result = sub_8084630(a1);\n  for ( i = result; i; i = *(_DWORD *)i )\n  {\n    printf(\"%s:\", *(const char **)(i + 4));\n    v3 = *(const char **)(i + 8);\n    if ( *v3 )\n      printf(\" LABEL=\\\"%s\\\"\", v3);\n    if ( **(_BYTE **)(i + 12) )\n      printf(\" UUID=\\\"%s\\\"\", *(const char **)(i + 12));\n    result = sub_804DD98(10);\n  }\n  return result;\n}\n"
        ],
        "134760122": [
            "sub_80846BA",
            "0x80846ba",
            "int __usercall sub_80846BA@<eax>(_BYTE *a1@<edi>, _BYTE *a2@<esi>, const char *a3)\n{\n  int v3; // eax\n  int v5; // ebp\n  int v6; // ebx\n  int v7; // ebp\n  char *v8; // ebx\n  _DWORD *v9; // ebp\n  _DWORD *v10; // eax\n  int v11; // [esp+0h] [ebp-18h] BYREF\n  int v12; // [esp+4h] [ebp-14h]\n\n  v3 = open64(a3);\n  if ( v3 < 0 )\n    return 0;\n  v5 = v3;\n  v6 = sub_8084935();\n  if ( ioctl(v5, 0x80041272, &v11) )\n  {\n    v11 = 0;\n    v12 = 0;\n  }\n  v7 = sub_80848D5(v12, v11);\n  if ( !v7 && (*(_BYTE *)(v6 + 32) || *(_BYTE *)(v6 + 97)) )\n  {\n    a1 = sub_804DB5D((_BYTE *)(v6 + 32), 65);\n    a2 = sub_804DB5D((_BYTE *)(v6 + 97), 37);\n  }\n  else\n  {\n    v7 = 1;\n  }\n  sub_8084946();\n  if ( v7 )\n    return 0;\n  v8 = sub_804DB46(a3);\n  v9 = (_DWORD *)dword_80DB720;\n  if ( dword_80DB720 )\n  {\n    while ( *v9 )\n      v9 = (_DWORD *)*v9;\n    v10 = sub_804DB2E(0x10u);\n    *v9 = v10;\n  }\n  else\n  {\n    v10 = sub_804DB2E(0x10u);\n    dword_80DB720 = (int)v10;\n  }\n  v10[1] = v8;\n  v10[2] = a1;\n  v10[3] = a2;\n  return 1;\n}\n"
        ],
        "134760364": [
            "sub_80847AC",
            "0x80847ac",
            "int __userpurge sub_80847AC@<eax>(const char *a1@<eax>, int a2@<edx>, _BYTE *a3@<edi>, int a4)\n{\n  int v6; // eax\n  char *v7; // eax\n\n  v6 = *(_DWORD *)(a2 + 16) & 0xF000;\n  if ( v6 == 24576 || v6 == 0x2000 && (v7 = sub_804D315(a1), !strncmp(v7, \"ubi\", 3u)) )\n  {\n    if ( gnu_dev_major(*(_QWORD *)(a2 + 32)) != 2 )\n      sub_80846BA(a3, (_BYTE *)a2, a1);\n  }\n  return 1;\n}\n"
        ],
        "134760456": [
            "sub_8084808",
            "0x8084808",
            "char *__cdecl sub_8084808(char *s1)\n{\n  int i; // ebx\n\n  for ( i = sub_8084630(1); i; i = *(_DWORD *)i )\n  {\n    if ( **(_BYTE **)(i + 8) && !strcmp(s1, *(const char **)(i + 8)) )\n      return sub_804DB46(*(const char **)(i + 4));\n  }\n  return 0;\n}\n"
        ],
        "134760518": [
            "sub_8084846",
            "0x8084846",
            "char *__cdecl sub_8084846(char *s1)\n{\n  int i; // ebx\n\n  for ( i = sub_8084630(1); i; i = *(_DWORD *)i )\n  {\n    if ( !strcasecmp(s1, *(const char **)(i + 12)) )\n      return sub_804DB46(*(const char **)(i + 4));\n  }\n  return 0;\n}\n"
        ],
        "134760574": [
            "sub_808487E",
            "0x808487e",
            "int __cdecl sub_808487E(char **a1)\n{\n  char *v1; // esi\n  char *v2; // eax\n  int result; // eax\n\n  v1 = *a1;\n  if ( sub_804D210(*a1, \"UUID=\") )\n  {\n    v2 = sub_8084846(*a1 + 5);\n  }\n  else\n  {\n    if ( !sub_804D210(*a1, \"LABEL=\") )\n      goto LABEL_6;\n    v2 = sub_8084808(*a1 + 6);\n  }\n  v1 = v2;\nLABEL_6:\n  result = 0;\n  if ( *a1 != v1 )\n  {\n    result = 1;\n    if ( v1 )\n      *a1 = v1;\n  }\n  return result;\n}\n"
        ],
        "134760661": [
            "sub_80848D5",
            "0x80848d5",
            "int __usercall sub_80848D5@<eax>(int a1@<eax>)\n{\n  int i; // esi\n\n  if ( sub_8084B80() && !*(_DWORD *)(a1 + 4) && sub_8084966() && !*(_DWORD *)(a1 + 4) )\n  {\n    sub_80851AF(a1, 0, 0, 69632);\n    for ( i = 0; i != 4; ++i )\n    {\n      if ( !funcs_808490F[i]() )\n        break;\n      if ( *(_DWORD *)(a1 + 4) )\n        break;\n    }\n  }\n  sub_808516C(a1);\n  return -*(_DWORD *)(a1 + 4);\n}\n"
        ],
        "134760757": [
            "sub_8084935",
            "0x8084935",
            "_DWORD *__usercall sub_8084935@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x88u);\n  *result = a1;\n  return result;\n}\n"
        ],
        "134760774": [
            "sub_8084946",
            "0x8084946",
            "void __usercall sub_8084946(int *a1@<eax>)\n{\n  if ( a1 )\n  {\n    close(*a1);\n    sub_808516C(a1);\n    free(a1);\n  }\n}\n"
        ],
        "134760806": [
            "sub_8084966",
            "0x8084966",
            "int __usercall sub_8084966@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v3; // ebx\n  unsigned int v4; // edi\n  int v5; // esi\n  int v6; // ebx\n  _BYTE *v7; // eax\n  int v9; // [esp+0h] [ebp-20h]\n  unsigned __int64 v10; // [esp+4h] [ebp-1Ch]\n  _BYTE *v11; // [esp+Ch] [ebp-14h]\n\n  v2 = sub_80851AF(a1, 0, 0, 111);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  v9 = memcmp((const void *)(v2 + 3), \"EXFAT   \", 8u);\n  if ( v9 )\n    return -1;\n  v4 = ((unsigned int)((*(_DWORD *)(v3 + 96) - 2) * (1 << *(_BYTE *)(v3 + 108) << *(_BYTE *)(v3 + 109)))\n      + (unsigned __int64)(unsigned int)(*(_DWORD *)(v3 + 88) << *(_BYTE *)(v3 + 108))) >> 32;\n  v5 = (*(_DWORD *)(v3 + 96) - 2) * (1 << *(_BYTE *)(v3 + 108) << *(_BYTE *)(v3 + 109))\n     + (*(_DWORD *)(v3 + 88) << *(_BYTE *)(v3 + 108));\n  sub_808504A(a1, v3 + 100, 0);\n  v10 = __PAIR64__(v4, v5) + 3200;\n  v6 = 3;\n  do\n  {\n    v7 = (_BYTE *)sub_80851AF(a1, v5, v4, 32);\n    if ( !v7 || !*v7 )\n      break;\n    if ( *v7 == 0x83 )\n    {\n      v11 = v7;\n      sub_808502B(a1, v7 + 2, 0, 2 * (unsigned __int8)v7[1]);\n      v6 &= ~1u;\n      v7 = v11;\n    }\n    if ( *v7 == 0xA0 )\n    {\n      sub_808504A(a1, v7 + 6, 2);\n      v6 &= ~2u;\n    }\n    if ( !v6 )\n      break;\n    v4 = (__PAIR64__(v4, v5) + 32) >> 32;\n    v5 += 32;\n  }\n  while ( v10 != __PAIR64__(v4, v5) );\n  return v9;\n}\n"
        ],
        "134761081": [
            "sub_8084A79",
            "0x8084a79",
            "int __usercall sub_8084A79@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v3; // ebx\n  int result; // eax\n\n  v2 = sub_80851AF(a1, 1024, 0, 512);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  result = -1;\n  if ( *(_WORD *)(v3 + 56) == 0xEF53 )\n  {\n    sub_8084FE4(a1, v3 + 120, 16);\n    sub_808504A(a1, v3 + 104, 2);\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134761160": [
            "sub_8084AC8",
            "0x8084ac8",
            "int __usercall sub_8084AC8@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v3; // ebx\n  int result; // eax\n\n  v2 = sub_80851AF(a1, 1024, 0, 1148);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  result = -1;\n  if ( *(_DWORD *)v3 == -218816496 )\n  {\n    if ( *(_WORD *)(v3 + 4) != 1 || (result = 0, *(_WORD *)(v3 + 6)) )\n    {\n      sub_808502B(a1, v3 + 124, 0, 64);\n      sub_808504A(a1, v3 + 108, 2);\n      return 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134761257": [
            "sub_8084B29",
            "0x8084b29",
            "int __usercall sub_8084B29@<eax>(int result@<eax>, int a2@<edx>)\n{\n  while ( 1 )\n  {\n    if ( --a2 == -1 || !*(_BYTE *)result )\n      return 0;\n    if ( *(_BYTE *)result != 0xE5 )\n      break;\n    result += 32;\n  }\nLABEL_6:\n  if ( (*(_BYTE *)(result + 11) & 0x3F) == 15\n    || (*(_BYTE *)(result + 11) & 0x18) != 8\n    || *(_WORD *)(result + 20)\n    || *(_WORD *)(result + 26) )\n  {\n    while ( 1 )\n    {\n      result += 32;\n      if ( --a2 == -1 || !*(_BYTE *)result )\n        return 0;\n      if ( *(_BYTE *)result != 0xE5 )\n        goto LABEL_6;\n    }\n  }\n  return result;\n}\n"
        ],
        "134761344": [
            "sub_8084B80",
            "0x8084b80",
            "int __usercall sub_8084B80@<eax>(int a1@<eax>)\n{\n  int v2; // eax\n  int v4; // ebx\n  int v6; // eax\n  unsigned __int8 v7; // al\n  unsigned int v8; // ecx\n  int v9; // eax\n  int v10; // edi\n  int v11; // ebp\n  unsigned int v12; // ebp\n  int v13; // eax\n  const void *v14; // edi\n  int v15; // ebx\n  int v16; // edi\n  __int64 v17; // rax\n  int v18; // eax\n  const void *v19; // ebp\n  _DWORD *v20; // eax\n  int v21; // ebx\n  unsigned int v22; // [esp+0h] [ebp-2Ch]\n  unsigned int v23; // [esp+4h] [ebp-28h]\n  int v24; // [esp+8h] [ebp-24h]\n  int v25; // [esp+8h] [ebp-24h]\n  int v26; // [esp+10h] [ebp-1Ch]\n  __int64 v27; // [esp+14h] [ebp-18h]\n\n  v2 = sub_80851AF(a1, 0, 0, 512);\n  if ( !v2 )\n    return -1;\n  v4 = v2;\n  if ( !memcmp((const void *)(v2 + 3), \"NTFS\", 4u) )\n    return -1;\n  if ( memcmp((const void *)(v4 + 82), \"MSWIN\", 5u)\n    && memcmp((const void *)(v4 + 82), \"FAT32   \", 8u)\n    && memcmp((const void *)(v4 + 54), \"FAT16   \", 8u)\n    && memcmp((const void *)(v4 + 54), \"MSDOS\", 5u)\n    && memcmp((const void *)(v4 + 54), \"FAT12   \", 8u) )\n  {\n    if ( !(*(_BYTE *)v4 == 0xEB ? *(_BYTE *)(v4 + 2) == 0x90 : *(_BYTE *)v4 == 0xE9) )\n      return -1;\n    if ( !*(_WORD *)(v4 + 26) )\n      return -1;\n    v6 = *(unsigned __int8 *)(v4 + 13);\n    if ( !(_BYTE)v6 )\n      return -1;\n    if ( (v6 & (v6 - 1)) != 0 )\n      return -1;\n    v7 = *(_BYTE *)(v4 + 21);\n    if ( v7 != 0xF0 && v7 <= 0xF7u )\n      return -1;\n    if ( *(_BYTE *)(v4 + 16) != 2 )\n      return -1;\n  }\n  v8 = *(unsigned __int16 *)(v4 + 11);\n  if ( (((_WORD)v8 - 2048) & 0xF7FF) != 0 && (((_WORD)v8 - 512) & 0xFDFF) != 0 )\n    return -1;\n  v10 = *(unsigned __int16 *)(v4 + 19);\n  if ( !*(_WORD *)(v4 + 19) )\n    v10 = *(_DWORD *)(v4 + 32);\n  v11 = *(unsigned __int16 *)(v4 + 22);\n  if ( !*(_WORD *)(v4 + 22) )\n    v11 = *(_DWORD *)(v4 + 36);\n  v24 = *(unsigned __int16 *)(v4 + 17);\n  v9 = *(unsigned __int16 *)(v4 + 14);\n  v12 = v9 + *(unsigned __int8 *)(v4 + 16) * v11;\n  if ( (v10 - (32 * v24 + v8 - 1) / v8 - v12) / *(unsigned __int8 *)(v4 + 13) > 0xFFF3 )\n  {\n    v22 = v8 * *(unsigned __int8 *)(v4 + 13);\n    v16 = *(_DWORD *)(v4 + 44);\n    v26 = v8 * v9;\n    v25 = 100;\n    v27 = v12;\n    v23 = *(unsigned __int16 *)(v4 + 11);\n    do\n    {\n      if ( !--v25 )\n        break;\n      v17 = v27 + *(unsigned __int8 *)(v4 + 13) * (unsigned __int64)(unsigned int)(v16 - 2);\n      v18 = sub_80851AF(a1, v23 * v17, HIDWORD(v17) * v23 + ((v23 * (unsigned __int64)(unsigned int)v17) >> 32), v22);\n      if ( !v18 )\n        return 0;\n      v19 = (const void *)sub_8084B29(v18, v22 >> 5);\n      if ( v19 )\n        goto LABEL_40;\n      v20 = (_DWORD *)sub_80851AF(a1, v26 + 4 * v16, 0, v22);\n      if ( !v20 )\n        return 0;\n      v16 = *v20 & 0xFFFFFFF;\n    }\n    while ( (unsigned int)(v16 - 2) <= 0xFFFFFF4 );\n    v19 = 0;\nLABEL_40:\n    v21 = sub_80851AF(a1, 0, 0, 512);\n    if ( v21 )\n    {\n      if ( !v19 || !memcmp(v19, \"NO NAME    \", 0xBu) )\n      {\n        if ( memcmp((const void *)(v21 + 71), \"NO NAME    \", 0xBu) )\n          sub_8084FE4(a1, v21 + 71, 11);\n      }\n      else\n      {\n        sub_8084FE4(a1, v19, 11);\n      }\n      sub_808504A(a1, v21 + 67, 0);\n      return 0;\n    }\n    return -1;\n  }\n  v13 = sub_80851AF(a1, v12 * v8, 0, 32 * v24);\n  if ( v13 )\n  {\n    v14 = (const void *)sub_8084B29(v13, v24);\n    v15 = sub_80851AF(a1, 0, 0, 512);\n    if ( v15 )\n    {\n      if ( v14 && memcmp(v14, \"NO NAME    \", 0xBu)\n        || (v14 = (const void *)(v15 + 43), memcmp((const void *)(v15 + 43), \"NO NAME    \", 0xBu)) )\n      {\n        sub_8084FE4(a1, v14, 11);\n      }\n      sub_808504A(a1, v15 + 39, 0);\n      return 0;\n    }\n    return -1;\n  }\n  return 0;\n}\n"
        ],
        "134762147": [
            "sub_8084EA3",
            "0x8084ea3",
            "int __usercall sub_8084EA3@<eax>(int a1@<eax>)\n{\n  int v1; // eax\n  __int16 v2; // dx\n\n  v1 = sub_80851AF(a1, 1024, 0, 512);\n  if ( !v1 )\n    return -1;\n  v2 = *(_WORD *)(v1 + 16);\n  if ( ((v2 - 4991) & 0xFFEF) == 0 || (v2 & 0xFFEF) == 9320 )\n    return 0;\n  else\n    return -(*(_WORD *)(v1 + 24) != 19802);\n}\n"
        ],
        "134762221": [
            "sub_8084EED",
            "0x8084eed",
            "int __usercall sub_8084EED@<eax>(int a1@<eax>)\n{\n  _DWORD *v2; // eax\n  _DWORD *v3; // edx\n  int result; // eax\n\n  v2 = (_DWORD *)sub_80851AF(a1, 0, 0, 128);\n  if ( !v2 )\n    return -1;\n  v3 = v2;\n  result = -1;\n  if ( *v3 == 101718065 )\n  {\n    sub_808504A(a1, v3 + 27, 2);\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134762283": [
            "sub_8084F2B",
            "0x8084f2b",
            "unsigned int __cdecl sub_8084F2B(int a1, unsigned int a2, int a3, int a4, unsigned int a5)\n{\n  int v5; // edx\n  int v6; // edi\n  int v7; // esi\n  unsigned int v8; // eax\n  char v9; // di\n  unsigned int v11; // [esp+0h] [ebp-14h]\n\n  v5 = 0;\n  v11 = 0;\n  while ( 1 )\n  {\n    v11 += 2;\n    if ( v11 > a5 )\n      break;\n    v6 = *(unsigned __int8 *)(a3 + v11 - 2);\n    v7 = *(unsigned __int8 *)(a3 + v11 - 1);\n    v8 = a4 ? v7 | (v6 << 8) : v6 | (v7 << 8);\n    if ( !v8 || v5 + 1 >= a2 )\n      break;\n    if ( v8 > 0x7F )\n    {\n      if ( v5 + 2 >= a2 )\n        break;\n      if ( v8 <= 0x7FF )\n      {\n        v9 = -64;\n      }\n      else\n      {\n        if ( v5 + 3 >= a2 )\n          break;\n        *(_BYTE *)(a1 + v5++) = (v8 >> 12) | 0xE0;\n        v9 = 0x80;\n      }\n      *(_BYTE *)(a1 + v5) = v9 | (v8 >> 6) & 0x3F;\n      LOBYTE(v8) = v8 & 0x3F | 0x80;\n      ++v5;\n    }\n    *(_BYTE *)(a1 + v5++) = v8;\n  }\n  *(_BYTE *)(a1 + v5) = 0;\n  return v11;\n}\n"
        ],
        "134762468": [
            "sub_8084FE4",
            "0x8084fe4",
            "int __cdecl sub_8084FE4(int a1, const void *a2, unsigned int a3)\n{\n  int result; // eax\n\n  qmemcpy((void *)(a1 + 32), a2, a3);\n  for ( result = strnlen(a1 + 32);\n        result && ((unsigned __int8)(*(_BYTE *)(a1 + result + 31) - 9) <= 4u || *(_BYTE *)(a1 + result + 31) == 32);\n        --result )\n  {\n    ;\n  }\n  *(_BYTE *)(a1 + result + 32) = 0;\n  return result;\n}\n"
        ],
        "134762539": [
            "sub_808502B",
            "0x808502b",
            "unsigned int __cdecl sub_808502B(int a1, int a2, int a3, unsigned int a4)\n{\n  return sub_8084F2B(a1 + 32, 0x41u, a2, a3, a4);\n}\n"
        ],
        "134762570": [
            "sub_808504A",
            "0x808504a",
            "int __cdecl sub_808504A(int a1, unsigned __int8 *a2, int a3)\n{\n  int result; // eax\n  unsigned int v4; // edx\n  int i; // ebx\n\n  result = a1;\n  v4 = 36;\n  if ( a3 != 3 )\n    v4 = 4 << a3;\n  for ( i = 0; i != v4; ++i )\n  {\n    if ( a2[i] )\n    {\n      switch ( a3 )\n      {\n        case 1:\n          return sprintf(\n                   (char *)(a1 + 97),\n                   \"%02X%02X%02X%02X%02X%02X%02X%02X\",\n                   a2[7],\n                   a2[6],\n                   a2[5],\n                   a2[4],\n                   a2[3],\n                   a2[2],\n                   a2[1],\n                   *a2);\n        case 0:\n          return sprintf((char *)(a1 + 97), \"%02X%02X-%02X%02X\", a2[3], a2[2], a2[1], *a2);\n        case 2:\n          return sprintf(\n                   (char *)(a1 + 97),\n                   \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n                   *a2,\n                   a2[1],\n                   a2[2],\n                   a2[3],\n                   a2[4],\n                   a2[5],\n                   a2[6],\n                   a2[7],\n                   a2[8],\n                   a2[9],\n                   a2[10],\n                   a2[11],\n                   a2[12],\n                   a2[13],\n                   a2[14],\n                   a2[15]);\n        case 3:\n          qmemcpy((void *)(a1 + 97), a2, v4);\n          *(_BYTE *)(a1 + v4 + 97) = 0;\n          break;\n      }\n      return result;\n    }\n  }\n  return result;\n}\n"
        ],
        "134762860": [
            "sub_808516C",
            "0x808516c",
            "__int64 __cdecl sub_808516C(int a1)\n{\n  __int64 v2; // [esp-8h] [ebp-Ch]\n\n  free(*(void **)(a1 + 16));\n  *(_DWORD *)(a1 + 16) = 0;\n  *(_DWORD *)(a1 + 8) = 0;\n  free(*(void **)(a1 + 20));\n  *(_DWORD *)(a1 + 20) = 0;\n  *(_DWORD *)(a1 + 12) = 0;\n  *(_DWORD *)(a1 + 24) = 0;\n  *(_DWORD *)(a1 + 28) = 0;\n  return v2;\n}\n"
        ],
        "134762927": [
            "sub_80851AF",
            "0x80851af",
            "char *__cdecl sub_80851AF(int *a1, unsigned __int64 a2, size_t a3)\n{\n  size_t v3; // edi\n  int v4; // ebp\n  char *v5; // esi\n  char *result; // eax\n  unsigned __int64 v7; // [esp+0h] [ebp-20h]\n  __int64 v8; // [esp+8h] [ebp-18h]\n\n  v3 = a3;\n  v7 = a2 + a3;\n  if ( v7 > 0x11000 )\n  {\n    result = 0;\n    if ( a3 > 0x10000 )\n      return result;\n    v5 = (char *)a1[5];\n    LODWORD(v8) = a1[6];\n    if ( *((_QWORD *)a1 + 3) <= a2 )\n    {\n      HIDWORD(v8) = a1[7];\n      if ( v7 <= v8 + (unsigned __int64)(unsigned int)a1[3] )\n      {\n        v4 = a2 - v8;\n        return &v5[v4];\n      }\n    }\n    *((_QWORD *)a1 + 3) = a2;\n    a1[3] = a3;\n    v5 = (char *)sub_804DB13(v5, a3);\n    a1[5] = (int)v5;\n    v4 = 0;\n  }\n  else\n  {\n    if ( !a1[4] )\n      a1[4] = (int)sub_804DAFA(0x11000u);\n    v4 = a2;\n    v5 = (char *)a1[4];\n    v3 = a2 + a3;\n    if ( a1[2] >= (unsigned int)a2 + a3 )\n      return &v5[v4];\n    a1[2] = v3;\n    a2 = 0LL;\n  }\n  if ( lseek64(*a1, a2, HIDWORD(a2), 0) == a2 && sub_804E5E3(v3, v5, *a1) == v3 )\n    return &v5[v4];\n  if ( a2 <= 0xFFFF )\n    a1[1] = 1;\n  sub_808516C((int)a1);\n  return 0;\n}\n"
        ],
        "134763254": [
            "sub_80852F6",
            "0x80852f6",
            "int __usercall sub_80852F6@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  char *v3; // eax\n\n  v2 = sub_80B028A();\n  v3 = ctime((const time_t *)(a1 + 28));\n  v3[16] = 32;\n  *(_DWORD *)(v3 + 17) = *((_DWORD *)v3 + 5);\n  v3[21] = 0;\n  return printf(\n           \"%s %u/%u%7llu %s %s\\n\",\n           (const char *)(v2 + 1),\n           *(_DWORD *)(a1 + 16),\n           *(_DWORD *)(a1 + 20),\n           *(_QWORD *)(a1 + 8),\n           v3 + 4,\n           *(const char **)a1);\n}\n"
        ],
        "134763327": [
            "sub_808533F",
            "0x808533f",
            "int __usercall sub_808533F@<eax>(int a1@<eax>)\n{\n  const char **v2; // esi\n  __int64 v3; // kr00_8\n  unsigned int v4; // edx\n  unsigned int v5; // eax\n  int result; // eax\n  __int64 v7; // [esp+0h] [ebp-14h]\n\n  v2 = *(const char ***)(a1 + 24);\n  if ( (*(_BYTE *)(a1 + 44) & 1) != 0 )\n  {\n    sub_804DCAD(1u, (void *)\"\\n\");\n    ++*(_QWORD *)(a1 + 44);\n  }\n  v3 = *((_QWORD *)v2 + 1);\n  LODWORD(v7) = v3;\n  if ( v3 >= 0xFFFFFFFFLL )\n    sub_804D5E0(\"'%s' is bigger than ar can handle\", *v2);\n  v4 = (unsigned int)v2[5];\n  if ( v4 > 0x1869F )\n    v4 = 0;\n  v5 = (unsigned int)v2[4];\n  if ( v5 > 0x1869F )\n    v5 = 0;\n  HIDWORD(v7) = v2[3];\n  result = dprintf(\n             *(_DWORD *)(a1 + 4),\n             \"%-16.16s%-12lu%-6u%-6u%-8o%-10llu`\\n\",\n             *v2,\n             v2[7],\n             v5,\n             v4,\n             (unsigned int)v2[6] & 0x1FFFFF,\n             v7);\n  *(_QWORD *)(a1 + 44) += 60LL;\n  return result;\n}\n"
        ],
        "134763488": [
            "sub_80853E0",
            "0x80853e0",
            "__int64 __usercall sub_80853E0@<edx:eax>(int *a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // esi\n  __int64 result; // rax\n\n  v2 = a1[26];\n  v3 = a1[6];\n  *(_DWORD *)(v2 + 24) = v3;\n  sub_808533F(v2);\n  sub_804E51A(a1[1], *(_DWORD *)(v2 + 4), *(_QWORD *)(v3 + 8));\n  result = *(_QWORD *)(v3 + 8);\n  *(_QWORD *)(v2 + 44) += result;\n  return result;\n}\n"
        ],
        "134763561": [
            "sub_8085429",
            "0x8085429",
            "int __cdecl sub_8085429(int a1, int a2)\n{\n  int v2; // ebx\n  _BYTE *v3; // eax\n  unsigned int v4; // eax\n  int v5; // edi\n  int v6; // esi\n  int *v7; // ebp\n  int v8; // ecx\n  int v9; // edx\n  int v10; // esi\n  const char *v11; // eax\n  const char *v12; // ebx\n  _DWORD *v13; // ecx\n  int v14; // edx\n  char *v15; // eax\n  int v16; // ebx\n  _DWORD v18[5]; // [esp+0h] [ebp-E4h] BYREF\n  char v19[44]; // [esp+14h] [ebp-D0h] BYREF\n  __int64 v20; // [esp+40h] [ebp-A4h]\n  char v21[16]; // [esp+74h] [ebp-70h] BYREF\n  int v22; // [esp+84h] [ebp-60h]\n  int v23; // [esp+8Ch] [ebp-58h]\n  int v24; // [esp+90h] [ebp-54h]\n  __int64 v25; // [esp+A0h] [ebp-44h]\n  int v26; // [esp+BCh] [ebp-28h]\n\n  v2 = sub_808E331();\n  v3 = *(_BYTE **)(a2 + 4);\n  if ( v3 && *v3 && *v3 != 45 )\n    *(_DWORD *)(a2 + 4) = sub_804DDBF((char *)\"-%s\", *(const char **)(a2 + 4));\n  v4 = sub_80ABEAC(a2, \"^vocptxr\");\n  v5 = a2 + 4 * optind;\n  if ( ((v4 >> 3) & ((v4 >> 3) - 1)) != 0 )\n    sub_804CDC2();\n  if ( (v4 & 8) != 0 )\n    *(_DWORD *)(v2 + 36) = sub_8089994;\n  if ( (v4 & 0x10) != 0 )\n    *(_DWORD *)(v2 + 32) = sub_808E264;\n  if ( (v4 & 0x20) != 0 )\n    *(_DWORD *)(v2 + 36) = sub_8089512;\n  if ( (v4 & 2) != 0 )\n    *(_DWORD *)v2 |= 1u;\n  if ( (v4 & 1) != 0 )\n    *(_DWORD *)(v2 + 32) = sub_80852F6;\n  *(_DWORD *)(v2 + 100) = *(_DWORD *)v5;\n  v6 = v4 & 0x40;\n  v7 = (int *)(v5 + 4);\n  *(_DWORD *)(v2 + 4) = sub_804DBE1(*(const char **)v5);\n  if ( *(_DWORD *)(v5 + 4) )\n    *(_DWORD *)(v2 + 8) = sub_808D814;\n  while ( 1 )\n  {\n    v9 = *v7;\n    if ( !*v7 )\n      break;\n    ++v7;\n    sub_80AFADF(v8, v9);\n  }\n  if ( v6 )\n  {\n    sub_804E010(*(_DWORD *)(v2 + 4), (int)v19, *(const char **)(v2 + 100));\n    v10 = v2;\n    if ( v20 )\n    {\n      v10 = sub_808E331();\n      sub_804DC28(*(const char **)(v2 + 100));\n      *(_DWORD *)(v10 + 4) = sub_804DBE1(*(const char **)(v2 + 100));\n      *(_DWORD *)(v10 + 12) = *(_DWORD *)(v2 + 12);\n    }\n    *(_DWORD *)(v2 + 104) = v10;\n    sub_804DCAD(8u, \"!<arch>\\n\");\n    *(_QWORD *)(v10 + 44) += 8LL;\n    if ( v20 )\n    {\n      *(_DWORD *)(v2 + 8) = sub_8085416;\n      *(_DWORD *)(v2 + 36) = sub_80853E0;\n      sub_808EF94();\n    }\n    while ( 1 )\n    {\n      v11 = (const char *)sub_80AFB01(v18[0]);\n      v12 = v11;\n      if ( !v11 )\n        break;\n      sub_804DFF3(v11, (int)v21);\n      v13 = *(_DWORD **)(v10 + 24);\n      v13[7] = v26;\n      v13[4] = v23;\n      v13[5] = v24;\n      v13[6] = v22;\n      v14 = HIDWORD(v25);\n      v13[2] = v25;\n      v13[3] = v14;\n      *v13 = (char *)v18 + 3;\n      v15 = sub_804D315(v12);\n      sprintf((char *)v18 + 3, \"%.15s/\", v15);\n      sub_808533F(v10);\n      v16 = sub_804DBE1(v12);\n      sub_804E51A(v16, *(_DWORD *)(v10 + 4), v25);\n      close(v16);\n      *(_QWORD *)(v10 + 44) += v25;\n    }\n  }\n  else\n  {\n    sub_808EF94();\n  }\n  return 0;\n}\n"
        ],
        "134764116": [
            "sub_8085654",
            "0x8085654",
            "const char *__usercall sub_8085654@<eax>(const char *a1@<eax>, const char *a2@<edx>)\n{\n  char *v4; // eax\n  char *v5; // ebx\n\n  v4 = strrchr(a1, 46);\n  v5 = v4;\n  if ( v4 )\n  {\n    if ( !strcmp(v4 + 1, a2) )\n    {\n      *v5 = 0;\n      return a1;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  return v5;\n}\n"
        ],
        "134764284": [
            "sub_80856FC",
            "0x80856fc",
            "int __userpurge sub_80856FC@<eax>(int *a1@<eax>, __int64 (*a2)(void)@<edx>, int (*a3)(void)@<ecx>, int a4)\n{\n  char v5; // di\n  int v6; // esi\n  int v7; // eax\n  int v8; // eax\n  const char *v9; // eax\n  char *v10; // ebx\n  int v11; // eax\n  size_t v12; // eax\n  int v13; // eax\n  const char *v14; // eax\n  __int64 v16; // [esp+0h] [ebp-C8h]\n  size_t v17; // [esp+8h] [ebp-C0h]\n  struct timeval tvp; // [esp+14h] [ebp-B4h] BYREF\n  __time_t v21; // [esp+1Ch] [ebp-ACh]\n  int v22; // [esp+20h] [ebp-A8h]\n  int v23; // [esp+30h] [ebp-98h]\n  __time_t v24; // [esp+54h] [ebp-74h]\n  char v25[16]; // [esp+58h] [ebp-70h] BYREF\n  __int64 v26; // [esp+84h] [ebp-44h]\n\n  v5 = 0;\n  do\n  {\n    v6 = *a1;\n    if ( *a1 )\n    {\n      if ( *(_BYTE *)v6 == 45 && !*(_BYTE *)(v6 + 1) )\n      {\n        v6 = 0;\n      }\n      else\n      {\n        if ( stat64(v6, v25) )\n        {\n          sub_804D3F1((const char *)v6);\nLABEL_49:\n          v5 = 1;\n          v10 = 0;\nLABEL_50:\n          free(v10);\n          goto LABEL_51;\n        }\n        v7 = sub_804DBEB((const char *)v6);\n        if ( v7 < 0 )\n          goto LABEL_49;\n        sub_804DC97(v7, 0);\n      }\n    }\n    if ( (dword_80DBB9C & 0x41) != 0 )\n    {\n      if ( (dword_80DBB9C & 0x40) != 0 )\n      {\n        v8 = sub_804DBEB(\"/dev/null\");\n        if ( v8 < 0 )\n          sub_804D604();\n        sub_804DC97(v8, 1);\n      }\n      v6 = 0;\nLABEL_23:\n      v10 = 0;\n      goto LABEL_24;\n    }\n    if ( !v6 )\n      goto LABEL_23;\n    v9 = (const char *)a3();\n    v10 = (char *)v9;\n    if ( !v9 )\n    {\n      sub_804D5F4(\"%s: unknown suffix - ignored\", (const char *)v6);\n      v5 = 1;\n      goto LABEL_50;\n    }\n    if ( (dword_80DBB9C & 2) != 0 )\n      unlink(v9);\n    v11 = sub_804DBEB(v10);\n    if ( v11 < 0 )\n    {\n      v5 = 1;\n      goto LABEL_47;\n    }\n    sub_804DC97(v11, 1);\nLABEL_24:\n    if ( (dword_80DBB9C & 2) == 0 && isatty(0) )\n      sub_804D5E0(\"compressed data not read from terminal, use -f to force it\");\n    sub_808EE43();\n    v23 = 1;\n    v16 = a2();\n    if ( v16 < 0 )\n      v5 = 1;\n    if ( (dword_80DBB9C & 1) == 0 )\n      sub_804DCF3(1);\n    if ( !v6 )\n      goto LABEL_51;\n    if ( v16 < 0 )\n    {\n      if ( !v10 )\n        goto LABEL_50;\n      v14 = v10;\nLABEL_45:\n      sub_804DC28(v14);\n      goto LABEL_47;\n    }\n    if ( v24 )\n    {\n      tvp.tv_sec = v24;\n      v21 = v24;\n      tvp.tv_usec = 0;\n      v22 = 0;\n      utimes(v10, &tvp);\n    }\n    v12 = strlen(v10);\n    v17 = v12;\n    if ( v10 == (char *)v6 )\n      v10[v12] = 46;\n    if ( (dword_80DBB9C & 8) != 0 )\n    {\n      v13 = 0;\n      if ( v16 )\n        v13 = sub_80B4B88(100 * (int)v26, (unsigned __int64)(100 * v26) >> 32, v16, HIDWORD(v16));\n      fprintf(stderr, \"%s: %u%% - replaced with %.*s\\n\", (const char *)v6, 100 - v13, v17, v10);\n    }\n    v14 = (const char *)v6;\n    if ( (dword_80DBB9C & 4) == 0 )\n      goto LABEL_45;\nLABEL_47:\n    if ( (char *)v6 != v10 )\n      goto LABEL_50;\nLABEL_51:\n    if ( !*a1 )\n      break;\n    ++a1;\n  }\n  while ( *a1 );\n  if ( (dword_80DBB9C & 1) != 0 )\n    sub_804DCF3(1);\n  return v5;\n}\n"
        ],
        "134764921": [
            "sub_8085979",
            "0x8085979",
            "int __cdecl sub_8085979(int a1, int a2)\n{\n  sub_80ABEC2(a2, \"cfkvqdtn\", \"stdout\");\n  if ( ident[1] == 99 )\n    dword_80DBB9C |= 1u;\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808B384, sub_808568A, 0);\n}\n"
        ],
        "134764991": [
            "sub_80859BF",
            "0x80859bf",
            "int __cdecl sub_80859BF(int a1, int a2)\n{\n  sub_80ABEAC(a2, \"cfkvqdt\");\n  if ( ident[2] == 99 )\n    dword_80DBB9C |= 1u;\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808A1F9, (int (*)(void))sub_8085654, (int)\"bz2\");\n}\n"
        ],
        "134765058": [
            "sub_8085A02",
            "0x8085a02",
            "int __cdecl sub_8085A02(int a1, int a2)\n{\n  char v2; // al\n  char v3; // dl\n\n  v2 = sub_80ABEAC(a2, \"cfkvqdt\");\n  v3 = ident[2];\n  if ( v3 == 109 )\n  {\n    if ( (v2 & 0x60) == 0 )\n      sub_804CDC2();\n  }\n  else if ( v3 == 99 )\n  {\n    dword_80DBB9C |= 1u;\n  }\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808B67C, (int (*)(void))sub_8085654, (int)\"lzma\");\n}\n"
        ],
        "134765141": [
            "sub_8085A55",
            "0x8085a55",
            "int __cdecl sub_8085A55(int a1, int a2)\n{\n  char v2; // al\n  char v3; // dl\n\n  v2 = sub_80ABEAC(a2, \"cfkvqdt\");\n  v3 = ident[2];\n  if ( v3 )\n  {\n    if ( v3 == 99 )\n      dword_80DBB9C |= 1u;\n  }\n  else if ( (v2 & 0x60) == 0 )\n  {\n    sub_804CDC2();\n  }\n  return sub_80856FC((int *)(a2 + 4 * optind), (__int64 (*)(void))sub_808CF10, (int (*)(void))sub_8085654, (int)\"xz\");\n}\n"
        ],
        "134765223": [
            "sub_8085AA7",
            "0x8085aa7",
            "int __cdecl sub_8085AA7(int a1, int a2)\n{\n  int v2; // edi\n  int v3; // ecx\n  __int16 v4; // bx\n  _DWORD *v5; // esi\n  int v6; // eax\n  const char *v8; // [esp+0h] [ebp-14h] BYREF\n  int v9[4]; // [esp+4h] [ebp-10h] BYREF\n\n  *(_QWORD *)&buf = -1LL;\n  v2 = sub_808E331();\n  *(_DWORD *)v2 = 8;\n  v4 = sub_80ABEC2(a2, \"it0uvdmLF:R:\", \"extract\", &v8, v9);\n  v5 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v4 & 0x200) != 0 )\n  {\n    sub_80B48BE();\n    *(_QWORD *)(v2 + 84) = *(_QWORD *)&buf;\n  }\n  if ( (v4 & 0x100) != 0 )\n  {\n    v6 = sub_804DBE1(v8);\n    sub_804DC97(v6, 0);\n  }\n  if ( (v4 & 3) == 0 )\n    sub_804CDC2();\n  if ( (v4 & 2) != 0 )\n  {\n    v4 &= ~1u;\n    *(_DWORD *)(v2 + 32) = sub_808E264;\n  }\n  if ( (v4 & 1) != 0 )\n  {\n    *(_DWORD *)(v2 + 36) = sub_8089512;\n    if ( (v4 & 0x800) != 0 )\n      *(_DWORD *)(v2 + 36) = sub_8089994;\n  }\n  if ( (v4 & 8) != 0 )\n    *(_DWORD *)v2 = *(_DWORD *)v2 & 0xFFFFFFF3 | 4;\n  if ( (v4 & 0x10) != 0 )\n  {\n    if ( *(int (**)())(v2 + 32) == sub_808E264 )\n      *(_DWORD *)(v2 + 32) = sub_808E26D;\n    else\n      *(_DWORD *)(v2 + 32) = sub_808E264;\n  }\n  if ( (v4 & 0x20) != 0 )\n    *(_DWORD *)v2 |= 2u;\n  if ( (v4 & 0x40) != 0 )\n    *(_DWORD *)v2 |= 1u;\n  while ( *v5 )\n  {\n    *(_DWORD *)(v2 + 8) = sub_808D814;\n    sub_80AFAC3(v3, *v5++);\n  }\n  *(_DWORD *)(v2 + 76) = -1;\n  *(_DWORD *)(v2 + 80) = -1;\n  while ( !(unsigned __int8)sub_808D8F8() )\n    ;\n  sub_808F0AE();\n  if ( (*(_DWORD *)(v2 + 80) != -1 || *(_DWORD *)(v2 + 76) != -1) && (v4 & 0x400) == 0 )\n    fprintf(stderr, \"%llu blocks\\n\", *(_QWORD *)(v2 + 76));\n  return 0;\n}\n"
        ],
        "134765588": [
            "sub_8085C14",
            "0x8085c14",
            "int sub_8085C14()\n{\n  int result; // eax\n  int i; // edx\n  int j; // edx\n  int k; // edx\n\n  result = dword_80DBB80;\n  for ( i = 0; i != 286; ++i )\n    *(_WORD *)(result + 4 * i + 1156) = 0;\n  for ( j = 0; j != 30; ++j )\n    *(_WORD *)(result + 4 * j + 3448) = 0;\n  for ( k = 0; k != 19; ++k )\n    *(_WORD *)(result + 4 * k + 4964) = 0;\n  *(_WORD *)(result + 2180) = 1;\n  *(_DWORD *)(result + 7860) = 0;\n  *(_DWORD *)(result + 7856) = 0;\n  *(_DWORD *)(result + 7840) = 0;\n  *(_DWORD *)(result + 7844) = 0;\n  *(_DWORD *)(result + 7848) = 0;\n  *(_WORD *)(result + 7852) = 256;\n  return result;\n}\n"
        ],
        "134765719": [
            "sub_8085C97",
            "0x8085c97",
            "unsigned __int16 __usercall sub_8085C97@<ax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ecx\n  int v4; // eax\n  unsigned __int16 *v5; // ebx\n  int v6; // esi\n  int v7; // ebx\n  unsigned __int16 v8; // dx\n  unsigned __int16 v9; // bx\n  unsigned __int16 result; // ax\n  int v11; // [esp+0h] [ebp-24h]\n  unsigned __int16 v12; // [esp+6h] [ebp-1Eh]\n  unsigned __int16 v13; // [esp+8h] [ebp-1Ch]\n  int v14; // [esp+Ch] [ebp-18h]\n  unsigned __int16 *v15; // [esp+10h] [ebp-14h]\n\n  v11 = a2;\n  v3 = dword_80DBB80;\n  v12 = *(_WORD *)(dword_80DBB80 + 2 * a2);\n  v4 = 2 * a2;\n  v14 = *(_DWORD *)(dword_80DBB80 + 1148);\n  v15 = (unsigned __int16 *)(a1 + 4 * v12);\n  while ( v14 >= v4 )\n  {\n    v5 = (unsigned __int16 *)(v3 + 2 * v4);\n    v6 = *v5;\n    if ( v14 > v4 )\n    {\n      v7 = v5[1];\n      v8 = *(_WORD *)(a1 + 4 * v6);\n      if ( *(_WORD *)(a1 + 4 * v7) < v8\n        || *(_WORD *)(a1 + 4 * v7) == v8 && *(_BYTE *)(v3 + v7 + 5236) <= *(_BYTE *)(v3 + v6 + 5236) )\n      {\n        ++v4;\n      }\n    }\n    v13 = *(_WORD *)(v3 + 2 * v4);\n    v9 = *(_WORD *)(a1 + 4 * v13);\n    if ( *v15 < v9 || *v15 == v9 && *(_BYTE *)(v3 + v12 + 5236) <= *(_BYTE *)(v3 + v13 + 5236) )\n      break;\n    *(_WORD *)(v3 + 2 * v11) = v13;\n    v11 = v4;\n    v4 *= 2;\n  }\n  result = v12;\n  *(_WORD *)(v3 + 2 * v11) = v12;\n  return result;\n}\n"
        ],
        "134765920": [
            "sub_8085D60",
            "0x8085d60",
            "int __usercall sub_8085D60@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ecx\n  int v4; // ebx\n  int i; // edi\n  int v6; // esi\n  unsigned int v7; // ebx\n  int j; // ecx\n  int v9; // ecx\n  __int16 v10[24]; // [esp+0h] [ebp-30h]\n\n  v2 = dword_80DBB80;\n  v3 = 1;\n  v4 = 0;\n  do\n  {\n    LOWORD(v4) = *(_WORD *)(v2 + 2 * v3 + 5202) + v4;\n    v4 *= 2;\n    v10[v3++] = v4;\n  }\n  while ( v3 != 16 );\n  for ( i = 0; i <= a2; ++i )\n  {\n    v6 = *(unsigned __int16 *)(result + 4 * i + 2);\n    if ( *(_WORD *)(result + 4 * i + 2) )\n    {\n      v7 = (unsigned __int16)v10[v6];\n      v10[v6] = v7 + 1;\n      for ( j = 0; ; j = 2 * v9 )\n      {\n        v9 = v7 & 1 | j;\n        if ( !--v6 )\n          break;\n        v7 >>= 1;\n      }\n      *(_WORD *)(result + 4 * i) = v9;\n    }\n  }\n  return result;\n}\n"
        ],
        "134766021": [
            "sub_8085DC5",
            "0x8085dc5",
            "int __usercall sub_8085DC5@<eax>(int *a1@<eax>)\n{\n  int v2; // edx\n  int v3; // edi\n  int v4; // ecx\n  int i; // eax\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebp\n  int v9; // eax\n  int v10; // ebp\n  int v11; // ebp\n  unsigned __int16 v12; // bp\n  int v13; // eax\n  int v14; // eax\n  int v15; // edx\n  int v16; // ecx\n  int v17; // edx\n  _WORD *v18; // ebp\n  unsigned __int8 v19; // dl\n  char v20; // al\n  __int16 v21; // ax\n  int v22; // ebp\n  int v23; // edx\n  int v24; // eax\n  int j; // ecx\n  int v26; // edi\n  int v27; // ecx\n  int v28; // edx\n  int v29; // ecx\n  int v31; // edx\n  int k; // edx\n  __int16 v33; // si\n  int v34; // ecx\n  int v35; // edx\n  unsigned __int16 *v36; // ecx\n  int v37; // esi\n  int v38; // [esp+0h] [ebp-38h]\n  int v39; // [esp+4h] [ebp-34h]\n  _WORD *v40; // [esp+8h] [ebp-30h]\n  int v41; // [esp+8h] [ebp-30h]\n  unsigned __int16 *v42; // [esp+Ch] [ebp-2Ch]\n  int v43; // [esp+10h] [ebp-28h]\n  int v44; // [esp+14h] [ebp-24h]\n  int v45; // [esp+18h] [ebp-20h]\n  int v46; // [esp+1Ch] [ebp-1Ch]\n  int v47; // [esp+20h] [ebp-18h]\n  int v48; // [esp+24h] [ebp-14h]\n\n  v38 = *a1;\n  v2 = a1[1];\n  v3 = a1[4];\n  v4 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 1148) = 0;\n  *(_DWORD *)(v4 + 1152) = 573;\n  v39 = -1;\n  for ( i = 0; i < v3; ++i )\n  {\n    if ( *(_WORD *)(v38 + 4 * i) )\n    {\n      v6 = *(_DWORD *)(v4 + 1148) + 1;\n      *(_DWORD *)(v4 + 1148) = v6;\n      *(_WORD *)(v4 + 2 * v6) = i;\n      *(_BYTE *)(v4 + i + 5236) = 0;\n      v39 = i;\n    }\n    else\n    {\n      *(_WORD *)(v38 + 4 * i + 2) = 0;\n    }\n  }\n  v7 = dword_80DBB80;\n  while ( 1 )\n  {\n    v8 = *(_DWORD *)(v7 + 1148);\n    if ( v8 > 1 )\n      break;\n    v9 = 0;\n    if ( v39 <= 1 )\n      v9 = (unsigned __int16)++v39;\n    v10 = v8 + 1;\n    *(_DWORD *)(v7 + 1148) = v10;\n    *(_WORD *)(v7 + 2 * v10) = v9;\n    *(_WORD *)(v38 + 4 * v9) = 1;\n    *(_BYTE *)(v7 + v9 + 5236) = 0;\n    --*(_DWORD *)(v7 + 7856);\n    if ( v2 )\n      *(_DWORD *)(v7 + 7860) -= *(unsigned __int16 *)(v2 + 4 * v9 + 2);\n  }\n  a1[6] = v39;\n  v11 = v8 >> 1;\n  do\n    sub_8085C97(v38, v11--);\n  while ( v11 );\n  do\n  {\n    v12 = *(_WORD *)(v7 + 2);\n    v13 = *(_DWORD *)(v7 + 1148);\n    *(_DWORD *)(v7 + 1148) = v13 - 1;\n    *(_WORD *)(v7 + 2) = *(_WORD *)(v7 + 2 * v13);\n    sub_8085C97(v38, 1);\n    v14 = *(unsigned __int16 *)(v7 + 2);\n    v15 = *(_DWORD *)(v7 + 1152);\n    v16 = v7 + 2 * v15;\n    *(_WORD *)(v16 - 2) = v12;\n    *(_DWORD *)(v7 + 1152) = v15 - 2;\n    *(_WORD *)(v16 - 4) = v14;\n    v17 = v12;\n    v40 = (_WORD *)(v38 + 4 * v12);\n    v18 = (_WORD *)(v38 + 4 * v14);\n    *(_WORD *)(v38 + 4 * v3) = *v40 + *v18;\n    v19 = *(_BYTE *)(v7 + v17 + 5236);\n    LOBYTE(v16) = *(_BYTE *)(v7 + v14 + 5236);\n    v20 = v16 + 1;\n    if ( v19 > (unsigned __int8)v16 )\n      v20 = v19 + 1;\n    *(_BYTE *)(v7 + v3 + 5236) = v20;\n    v21 = v3;\n    v18[1] = v3;\n    v40[1] = v3++;\n    *(_WORD *)(v7 + 2) = v21;\n    sub_8085C97(v38, 1);\n  }\n  while ( *(int *)(v7 + 1148) > 1 );\n  v22 = *(_DWORD *)(v7 + 1152);\n  *(_DWORD *)(v7 + 1152) = v22 - 1;\n  v23 = *(unsigned __int16 *)(v7 + 2);\n  *(_WORD *)(v7 + 2 * (v22 - 1)) = v23;\n  v41 = *a1;\n  v48 = a1[2];\n  v44 = a1[3];\n  v45 = a1[6];\n  v24 = a1[5];\n  v46 = a1[1];\n  for ( j = 0; j != 16; ++j )\n    *(_WORD *)(v7 + 2 * j + 5204) = 0;\n  *(_WORD *)(v41 + 4 * v23 + 2) = 0;\n  v26 = 0;\n  while ( v22 <= 572 )\n  {\n    v27 = *(unsigned __int16 *)(v7 + 2 * v22);\n    v47 = 4 * v27;\n    v42 = (unsigned __int16 *)(4 * v27 + v41);\n    v28 = *(unsigned __int16 *)(v41 + 4 * v42[1] + 2) + 1;\n    if ( v24 < v28 )\n    {\n      ++v26;\n      v28 = v24;\n    }\n    v42[1] = v28;\n    if ( v45 >= v27 )\n    {\n      ++*(_WORD *)(v7 + 2 * v28 + 5204);\n      v43 = 0;\n      if ( v44 <= v27 )\n        v43 = *(unsigned __int8 *)(v48 + v27 - v44);\n      v29 = *v42;\n      *(_DWORD *)(v7 + 7856) += v29 * (v43 + v28);\n      if ( v46 )\n        *(_DWORD *)(v7 + 7860) += v29 * (*(unsigned __int16 *)(v46 + v47 + 2) + v43);\n    }\n    ++v22;\n  }\n  if ( v26 )\n  {\n    do\n    {\n      for ( k = v24 - 1; ; --k )\n      {\n        v33 = *(_WORD *)(v7 + 2 * k + 5204);\n        if ( v33 )\n          break;\n      }\n      v31 = v7 + 2 * k;\n      *(_WORD *)(v31 + 5204) = v33 - 1;\n      *(_WORD *)(v31 + 5206) += 2;\n      --*(_WORD *)(v7 + 2 * v24 + 5204);\n      v26 -= 2;\n    }\n    while ( v26 > 0 );\n    while ( v24 )\n    {\n      v35 = *(unsigned __int16 *)(v7 + 2 * v24 + 5204);\n      while ( v35 )\n      {\n        --v22;\n        v34 = *(unsigned __int16 *)(v7 + 2 * v22);\n        if ( v45 >= v34 )\n        {\n          v36 = (unsigned __int16 *)(v41 + 4 * v34);\n          v37 = v36[1];\n          if ( v37 != v24 )\n          {\n            *(_DWORD *)(v7 + 7856) += *v36 * (v24 - v37);\n            v36[1] = v24;\n          }\n          --v35;\n        }\n      }\n      --v24;\n    }\n  }\n  return sub_8085D60(v38, v39);\n}\n"
        ],
        "134766861": [
            "sub_808610D",
            "0x808610d",
            "int __usercall sub_808610D@<eax>(int result@<eax>, int a2@<edx>)\n{\n  int v2; // edx\n  int v3; // edi\n  int v4; // ecx\n  int v5; // esi\n  int i; // ebp\n  int v7; // [esp+0h] [ebp-1Ch]\n  int v8; // [esp+4h] [ebp-18h]\n\n  v2 = *(unsigned __int16 *)(result + 2);\n  v3 = 4 - (v2 == 0);\n  v4 = v2 == 0 ? 138 : 7;\n  *(_WORD *)(result + 4 * a2 + 6) = -1;\n  v5 = 0;\n  v8 = -1;\n  for ( i = 0; i <= a2; ++i )\n  {\n    v7 = *(unsigned __int16 *)(result + 4 * i + 6);\n    if ( v4 <= ++v5 )\n      goto LABEL_7;\n    if ( v2 == *(unsigned __int16 *)(result + 4 * i + 6) )\n    {\n      v2 = v8;\n      goto LABEL_18;\n    }\n    if ( v3 <= v5 )\n    {\nLABEL_7:\n      if ( v2 )\n      {\n        if ( v8 != v2 )\n          ++*(_WORD *)(dword_80DBB80 + 4 * v2 + 4964);\n        ++*(_WORD *)(dword_80DBB80 + 5028);\n      }\n      else if ( v5 > 10 )\n      {\n        ++*(_WORD *)(dword_80DBB80 + 5036);\n      }\n      else\n      {\n        ++*(_WORD *)(dword_80DBB80 + 5032);\n      }\n    }\n    else\n    {\n      *(_WORD *)(dword_80DBB80 + 4 * v2 + 4964) += v5;\n    }\n    if ( v7 )\n    {\n      v3 = (v2 != v7) + 3;\n      v4 = (v2 != v7) + 6;\n      v5 = 0;\n    }\n    else\n    {\n      v5 = 0;\n      v3 = 3;\n      v4 = 138;\n    }\nLABEL_18:\n    v8 = v2;\n    v2 = v7;\n  }\n  return result;\n}\n"
        ],
        "134767107": [
            "sub_8086203",
            "0x8086203",
            "_BOOL4 __usercall sub_8086203@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ecx\n  int v3; // esi\n  int v4; // ebx\n  int v5; // eax\n  int v6; // edx\n  int v7; // ebx\n  int v8; // edx\n  unsigned int v9; // edx\n  int v10; // eax\n  unsigned int v11; // eax\n  int i; // ebx\n  unsigned int v13; // ebx\n  _BOOL4 result; // eax\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 68);\n  v4 = *(_DWORD *)(dword_80DBB80 + 7840);\n  *(_DWORD *)(dword_80DBB80 + 7840) = v4 + 1;\n  *(_BYTE *)(v3 + v4) = a2;\n  if ( a1 )\n  {\n    v5 = a1 - 1;\n    ++*(_WORD *)(v2 + 4 * *(unsigned __int8 *)(v2 + a2 + 5809) + 2184);\n    if ( v5 > 255 )\n      v6 = *(unsigned __int8 *)(v2 + (v5 >> 7) + 6321);\n    else\n      v6 = *(unsigned __int8 *)(v2 + v5 + 6065);\n    ++*(_WORD *)(v2 + 4 * v6 + 3448);\n    v7 = *(_DWORD *)(v2 - 64);\n    v8 = *(_DWORD *)(v2 + 7844);\n    *(_DWORD *)(v2 + 7844) = v8 + 1;\n    *(_WORD *)(v7 + 2 * v8) = v5;\n    *(_BYTE *)(v2 + 7852) |= *(_BYTE *)(v2 + 7853);\n  }\n  else\n  {\n    ++*(_WORD *)(v2 + 4 * a2 + 1156);\n  }\n  *(_BYTE *)(v2 + 7853) *= 2;\n  v9 = *(_DWORD *)(v2 + 7840);\n  if ( (v9 & 7) == 0 )\n  {\n    v10 = *(_DWORD *)(v2 + 7848);\n    *(_DWORD *)(v2 + 7848) = v10 + 1;\n    *(_BYTE *)(v2 + v10 + 6816) = *(_BYTE *)(v2 + 7852);\n    *(_WORD *)(v2 + 7852) = 256;\n  }\n  if ( (v9 & 0xFFF) != 0 )\n    goto LABEL_14;\n  v11 = 8 * v9;\n  for ( i = 0; i != 30; ++i )\n    v11 += *(unsigned __int16 *)(v2 + 4 * i + 3448) * ((unsigned __int8)byte_80D4D27[i] + 5);\n  v13 = v11 >> 3;\n  if ( *(_DWORD *)(v2 + 7844) >= v9 >> 1\n    || (result = 1, (unsigned int)(*(_DWORD *)(v2 - 32) - *(_DWORD *)(v2 - 44)) >> 1 <= v13) )\n  {\nLABEL_14:\n    result = 1;\n    if ( v9 != 0x1FFF )\n      return *(_DWORD *)(v2 + 7844) == 0x2000;\n  }\n  return result;\n}\n"
        ],
        "134767408": [
            "sub_8086330",
            "0x8086330",
            "ssize_t __usercall sub_8086330@<eax>(void *a1@<eax>, size_t a2@<edx>)\n{\n  ssize_t v2; // ebx\n  int v3; // esi\n\n  v2 = sub_804E5BC(a2, a1, 0);\n  if ( (unsigned int)(v2 - 1) <= 0xFFFFFFFD )\n  {\n    v3 = dword_80DBB80;\n    *(_DWORD *)(v3 - 48) = sub_80AA41E(dword_80DBB98);\n    *(_DWORD *)(v3 - 20) += v2;\n  }\n  return v2;\n}\n"
        ],
        "134767468": [
            "sub_808636C",
            "0x808636c",
            "void sub_808636C()\n{\n  int v0; // ebx\n  unsigned int v1; // ebp\n  unsigned int v2; // eax\n  unsigned int v3; // ebp\n  size_t v4; // edx\n  int v5; // eax\n  int v6; // ecx\n  int i; // edx\n  int v8; // esi\n  int j; // edx\n  int v10; // esi\n  ssize_t v11; // eax\n\nLABEL_1:\n  v0 = dword_80DBB80;\n  while ( 1 )\n  {\n    v1 = *(_DWORD *)(v0 - 24);\n    if ( v1 > 0x105 || *(_BYTE *)(v0 - 12) )\n      break;\n    v2 = *(_DWORD *)(v0 - 32);\n    v3 = v2 + v1;\n    v4 = 0x10000 - v3;\n    if ( v3 == 65537 )\n    {\n      v4 = -2;\n    }\n    else if ( v2 > 0xFEF9 )\n    {\n      v5 = *(_DWORD *)(v0 - 56);\n      qmemcpy((void *)v5, (const void *)(v5 + 0x8000), 0x8000u);\n      *(_DWORD *)(v0 - 28) -= 0x8000;\n      *(_DWORD *)(v0 - 32) -= 0x8000;\n      *(_DWORD *)(v0 - 44) -= 0x8000;\n      v6 = *(_DWORD *)(v0 - 52);\n      for ( i = 0; i != 0x2000; ++i )\n      {\n        LOWORD(v5) = *(_WORD *)(v6 + 2 * i + 0x10000);\n        HIWORD(v8) = HIWORD(v5);\n        LOWORD(v8) = (__int16)v5 >> 15;\n        LOWORD(v5) = v5 + 0x8000;\n        v5 &= v8;\n        *(_WORD *)(v6 + 2 * i + 0x10000) = v5;\n      }\n      for ( j = 0; j != 0x8000; ++j )\n      {\n        LOWORD(v5) = *(_WORD *)(v6 + 2 * j);\n        HIWORD(v10) = HIWORD(v5);\n        LOWORD(v10) = (__int16)v5 >> 15;\n        LOWORD(v5) = v5 + 0x8000;\n        v5 &= v10;\n        *(_WORD *)(v6 + 2 * j) = v5;\n      }\n      v4 = 98304 - v3;\n    }\n    if ( !*(_BYTE *)(v0 - 12) )\n    {\n      v11 = sub_8086330((void *)(*(_DWORD *)(v0 - 56) + *(_DWORD *)(v0 - 32) + *(_DWORD *)(v0 - 24)), v4);\n      if ( (unsigned int)(v11 - 1) <= 0xFFFFFFFD )\n        *(_DWORD *)(v0 - 24) += v11;\n      else\n        *(_BYTE *)(v0 - 12) = 1;\n      goto LABEL_1;\n    }\n  }\n}\n"
        ],
        "134767711": [
            "sub_808645F",
            "0x808645f",
            "void sub_808645F()\n{\n  int v0; // ebx\n  size_t v1; // ecx\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 - 16);\n  if ( v1 )\n  {\n    sub_804DCAD(v1, *(void **)(dword_80DBB80 - 60));\n    *(_DWORD *)(v0 - 16) = 0;\n  }\n}\n"
        ],
        "134767747": [
            "sub_8086483",
            "0x8086483",
            "void __usercall sub_8086483(unsigned __int16 a1@<ax>)\n{\n  int v1; // ebx\n  unsigned int v2; // edx\n  _BYTE *v3; // ecx\n  __int16 v4; // si\n  unsigned int v5; // edx\n  int v6; // edx\n  int v7; // eax\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 - 16);\n  v3 = (_BYTE *)(v2 + *(_DWORD *)(dword_80DBB80 - 60));\n  if ( v2 > 0x1FFD )\n  {\n    *v3 = a1;\n    v4 = HIBYTE(a1);\n    v5 = v2 + 1;\n    *(_DWORD *)(v1 - 16) = v5;\n    if ( v5 == 0x2000 )\n      sub_808645F();\n    v6 = *(_DWORD *)(v1 - 60);\n    v7 = *(_DWORD *)(v1 - 16);\n    *(_DWORD *)(v1 - 16) = v7 + 1;\n    *(_BYTE *)(v6 + v7) = v4;\n    if ( *(_DWORD *)(v1 - 16) == 0x2000 )\n      sub_808645F();\n  }\n  else\n  {\n    *(_WORD *)v3 = a1;\n    *(_DWORD *)(v1 - 16) = v2 + 2;\n  }\n}\n"
        ],
        "134767843": [
            "sub_80864E3",
            "0x80864e3",
            "void __usercall sub_80864E3(int a1@<eax>)\n{\n  unsigned __int16 v1; // ebx^2\n\n  v1 = HIWORD(a1);\n  sub_8086483(a1);\n  sub_8086483(v1);\n}\n"
        ],
        "134767865": [
            "sub_80864F9",
            "0x80864f9",
            "void __usercall sub_80864F9(unsigned int a1@<eax>, int a2@<edx>)\n{\n  int v2; // ebp\n  int v3; // ecx\n  int v4; // edi\n  int v5; // ebx\n  int v6; // esi\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 4);\n  v4 = *(_DWORD *)(dword_80DBB80 - 8) | (a1 << v3);\n  v5 = v3 + a2;\n  if ( (unsigned int)(v3 + a2) > 0x1F )\n  {\n    v6 = a1 >> (32 - v3);\n    sub_80864E3(v4);\n    v5 -= 32;\n    v4 = v6;\n  }\n  *(_DWORD *)(v2 - 8) = v4;\n  *(_DWORD *)(v2 - 4) = v5;\n}\n"
        ],
        "134767929": [
            "sub_8086539",
            "0x8086539",
            "int __usercall sub_8086539@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v2; // esi\n  int v3; // ecx\n  int result; // eax\n  int v5; // edi\n  int v6; // edx\n  int v7; // ebp\n  int v8; // ebx\n  int v9; // edi\n  int v10; // ecx\n  unsigned int v11; // eax\n  int v12; // edx\n  int v13; // [esp+0h] [ebp-20h]\n  int v16; // [esp+Ch] [ebp-14h]\n\n  v2 = *(unsigned __int16 *)(a1 + 2);\n  v3 = 4 - (v2 == 0);\n  result = v2 == 0 ? 138 : 7;\n  v5 = 0;\n  v6 = -1;\n  v13 = 0;\n  while ( v13 <= a2 )\n  {\n    v7 = *(unsigned __int16 *)(a1 + 4 * v13 + 6);\n    v8 = v5 + 1;\n    if ( result <= v5 + 1 )\n      goto LABEL_9;\n    if ( v2 == v7 )\n    {\n      v2 = v6;\n      goto LABEL_21;\n    }\n    if ( v3 <= v8 )\n    {\nLABEL_9:\n      v10 = dword_80DBB80;\n      if ( v2 )\n      {\n        if ( v6 != v2 )\n        {\n          v16 = dword_80DBB80;\n          sub_80864F9(\n            *(unsigned __int16 *)(dword_80DBB80 + 4 * v2 + 4964),\n            *(unsigned __int16 *)(dword_80DBB80 + 4 * v2 + 4966));\n          v8 = v5;\n          v10 = v16;\n        }\n        sub_80864F9(*(unsigned __int16 *)(v10 + 5028), *(unsigned __int16 *)(v10 + 5030));\n        v11 = v8 - 3;\n        v12 = 2;\n      }\n      else if ( v8 > 10 )\n      {\n        sub_80864F9(*(unsigned __int16 *)(dword_80DBB80 + 5036), *(unsigned __int16 *)(dword_80DBB80 + 5038));\n        v11 = v5 - 10;\n        v12 = 7;\n      }\n      else\n      {\n        sub_80864F9(*(unsigned __int16 *)(dword_80DBB80 + 5032), *(unsigned __int16 *)(dword_80DBB80 + 5034));\n        v11 = v5 - 2;\n        v12 = 3;\n      }\n      sub_80864F9(v11, v12);\n    }\n    else\n    {\n      v9 = dword_80DBB80 + 4 * v2;\n      do\n      {\n        sub_80864F9(*(unsigned __int16 *)(v9 + 4964), *(unsigned __int16 *)(v9 + 4966));\n        --v8;\n      }\n      while ( v8 );\n    }\n    if ( v7 )\n    {\n      v3 = (v2 != v7) + 3;\n      result = (v2 != v7) + 6;\n      v8 = 0;\n    }\n    else\n    {\n      v8 = 0;\n      v3 = 3;\n      result = 138;\n    }\nLABEL_21:\n    ++v13;\n    v5 = v8;\n    v6 = v2;\n    v2 = v7;\n  }\n  return result;\n}\n"
        ],
        "134768264": [
            "sub_8086688",
            "0x8086688",
            "void __usercall sub_8086688(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebp\n  unsigned int i; // eax\n  int v5; // ebx\n  int v6; // esi\n  unsigned __int16 *v7; // eax\n  int v8; // edx\n  unsigned int v9; // eax\n  int v10; // edx\n  unsigned int v11; // esi\n  int v12; // ecx\n  int v13; // [esp+0h] [ebp-28h]\n  unsigned __int8 v14; // [esp+7h] [ebp-21h]\n  unsigned int v15; // [esp+8h] [ebp-20h]\n  int v16; // [esp+Ch] [ebp-1Ch]\n  int v18; // [esp+14h] [ebp-14h]\n\n  if ( *(_DWORD *)(dword_80DBB80 + 7840) )\n  {\n    v14 = 0;\n    v13 = 0;\n    v3 = 0;\n    for ( i = 0; ; i = v15 )\n    {\n      v5 = dword_80DBB80;\n      if ( (i & 7) == 0 )\n        v14 = *(_BYTE *)(dword_80DBB80 + v13++ + 6816);\n      v15 = i + 1;\n      v6 = *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB80 - 68) + i);\n      if ( (v14 & 1) == 0 )\n        break;\n      v16 = *(unsigned __int8 *)(dword_80DBB80 + v6 + 5809);\n      sub_80864F9(*(unsigned __int16 *)(a1 + 4 * v16 + 1028), *(unsigned __int16 *)(a1 + 4 * v16 + 1030));\n      v10 = (unsigned __int8)byte_80D4D45[v16];\n      if ( (_BYTE)v10 )\n        sub_80864F9(v6 - *(_DWORD *)(v5 + 4 * v16 + 6580), v10);\n      v11 = *(unsigned __int16 *)(*(_DWORD *)(v5 - 64) + 2 * v3);\n      if ( v11 > 0xFF )\n        v12 = *(unsigned __int8 *)(v5 + (v11 >> 7) + 6321);\n      else\n        v12 = *(unsigned __int8 *)(v5 + v11 + 6065);\n      v18 = v12;\n      sub_80864F9(*(unsigned __int16 *)(a2 + 4 * v12), *(unsigned __int16 *)(a2 + 4 * v12 + 2));\n      v8 = (unsigned __int8)byte_80D4D27[v18];\n      ++v3;\n      if ( (_BYTE)v8 )\n      {\n        v9 = v11 - *(_DWORD *)(v5 + 4 * v18 + 6696);\n        goto LABEL_14;\n      }\nLABEL_15:\n      v14 >>= 1;\n      if ( *(_DWORD *)(v5 + 7840) <= v15 )\n        goto LABEL_17;\n    }\n    v7 = (unsigned __int16 *)(a1 + 4 * v6);\n    v8 = v7[1];\n    v9 = *v7;\nLABEL_14:\n    sub_80864F9(v9, v8);\n    goto LABEL_15;\n  }\nLABEL_17:\n  sub_80864F9(*(unsigned __int16 *)(a1 + 1024), *(unsigned __int16 *)(a1 + 1026));\n}\n"
        ],
        "134768587": [
            "sub_80867CB",
            "0x80867cb",
            "void sub_80867CB()\n{\n  int v0; // ebx\n  unsigned int v1; // edi\n  int i; // esi\n  int v3; // edx\n  int v4; // eax\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 - 8);\n  for ( i = *(_DWORD *)(dword_80DBB80 - 4); i > 0; i -= 8 )\n  {\n    v3 = *(_DWORD *)(v0 - 60);\n    v4 = *(_DWORD *)(v0 - 16);\n    *(_DWORD *)(v0 - 16) = v4 + 1;\n    *(_BYTE *)(v3 + v4) = v1;\n    if ( *(_DWORD *)(v0 - 16) == 0x2000 )\n      sub_808645F();\n    v1 >>= 8;\n  }\n  *(_DWORD *)(v0 - 8) = 0;\n  *(_DWORD *)(v0 - 4) = 0;\n}\n"
        ],
        "134768663": [
            "sub_8086817",
            "0x8086817",
            "void __usercall sub_8086817(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)\n{\n  int *v5; // ebx\n  int i; // esi\n  int v7; // eax\n  unsigned int v8; // ecx\n  unsigned int v9; // eax\n  unsigned int v10; // edx\n  int v11; // edi\n  int v12; // ecx\n  int v13; // eax\n  int v14; // edx\n  int v15; // eax\n  unsigned int v16; // edi\n  int v17; // ebp\n  int v18; // ecx\n  int v20; // [esp+Ch] [ebp-14h]\n\n  v5 = (int *)dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 + *(_DWORD *)(dword_80DBB80 + 7848) + 6816) = *(_BYTE *)(dword_80DBB80 + 7852);\n  sub_8085DC5(v5 + 1280);\n  sub_8085DC5(v5 + 1287);\n  sub_808610D((int)(v5 + 289), v5[1286]);\n  sub_808610D((int)(v5 + 862), v5[1293]);\n  sub_8085DC5(v5 + 1294);\n  for ( i = 18; i != 2; --i )\n  {\n    if ( HIWORD(v5[(unsigned __int8)byte_80D4D01[i] + 1241]) )\n      break;\n  }\n  v7 = 3 * (i + 1) + v5[1964] + 14;\n  v5[1964] = v7;\n  v8 = (unsigned int)(v7 + 10) >> 3;\n  v9 = (unsigned int)(v5[1965] + 10) >> 3;\n  v10 = v8;\n  if ( v8 > v9 )\n    v10 = (unsigned int)(v5[1965] + 10) >> 3;\n  if ( a2 + 4 <= v10 && a1 )\n  {\n    sub_80864F9(a3, 3);\n    sub_80867CB();\n    sub_80864E3((unsigned __int16)a2 | (~a2 << 16));\n    v11 = a1 + a2;\n    while ( a1 != v11 )\n    {\n      ++a1;\n      v12 = *(v5 - 15);\n      v13 = *(v5 - 4);\n      *(v5 - 4) = v13 + 1;\n      *(_BYTE *)(v12 + v13) = *(_BYTE *)(a1 - 1);\n      if ( *(v5 - 4) == 0x2000 )\n        sub_808645F();\n    }\n  }\n  else\n  {\n    if ( v8 < v9 )\n    {\n      sub_80864F9(a3 + 4, 3);\n      v16 = v5[1293];\n      v17 = v5[1286];\n      sub_80864F9(v17 - 256, 5);\n      sub_80864F9(v16, 5);\n      sub_80864F9(i - 3, 4);\n      v18 = 0;\n      do\n      {\n        v20 = v18;\n        sub_80864F9(HIWORD(v5[(unsigned __int8)byte_80D4D01[v18] + 1241]), 3);\n        v18 = v20 + 1;\n      }\n      while ( v20 + 1 <= i );\n      sub_8086539((int)(v5 + 289), v17);\n      sub_8086539((int)(v5 + 862), v16);\n      v14 = (int)(v5 + 862);\n      v15 = (int)(v5 + 289);\n    }\n    else\n    {\n      sub_80864F9(a3 + 2, 3);\n      v14 = (int)(v5 + 1211);\n      v15 = (int)(v5 + 923);\n    }\n    sub_8086688(v15, v14);\n  }\n  sub_8085C14();\n  if ( a3 )\n    sub_80867CB();\n}\n"
        ],
        "134769162": [
            "sub_8086A0A",
            "0x8086a0a",
            "void sub_8086A0A()\n{\n  unsigned int v0; // esi\n  int v1; // ebx\n  unsigned int v2; // edi\n  int v3; // eax\n  _WORD *v4; // eax\n  _BYTE *v5; // ebp\n  int v6; // eax\n  _BYTE *v7; // esi\n  _BYTE *v8; // esi\n  _BYTE *v9; // eax\n  unsigned int v10; // eax\n  int v11; // esi\n  unsigned int v12; // edx\n  int v13; // eax\n  int v14; // edx\n  int v15; // ebp\n  int v16; // edx\n  int v17; // eax\n  _WORD *v18; // eax\n  int v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int v22; // edx\n  int v23; // ecx\n  int v24; // eax\n  int v25; // ecx\n  int v26; // eax\n  unsigned int v27; // [esp+0h] [ebp-40h]\n  int v28; // [esp+0h] [ebp-40h]\n  unsigned int v29; // [esp+4h] [ebp-3Ch]\n  _BOOL4 v30; // [esp+8h] [ebp-38h]\n  int v31; // [esp+Ch] [ebp-34h]\n  int v32; // [esp+10h] [ebp-30h]\n  int v33; // [esp+14h] [ebp-2Ch]\n  unsigned int v34; // [esp+1Ch] [ebp-24h]\n  unsigned int v35; // [esp+20h] [ebp-20h]\n  int v36; // [esp+24h] [ebp-1Ch]\n  unsigned int v37; // [esp+28h] [ebp-18h]\n  char v38; // [esp+2Dh] [ebp-13h]\n  char v39; // [esp+2Eh] [ebp-12h]\n\n  v0 = 2;\n  v30 = 0;\n  while ( 1 )\n  {\n    v1 = dword_80DBB80;\n    v34 = *(_DWORD *)(dword_80DBB80 - 24);\n    v2 = *(_DWORD *)(dword_80DBB80 - 32);\n    if ( !v34 )\n      break;\n    v31 = *(_DWORD *)(dword_80DBB80 - 56);\n    v3 = (*(unsigned __int8 *)(v31 + v2 + 2) ^ (unsigned __int16)(32 * *(_DWORD *)(dword_80DBB80 - 40))) & 0x1FFF;\n    *(_DWORD *)(dword_80DBB80 - 40) = v3;\n    v32 = *(_DWORD *)(v1 - 52);\n    v4 = (_WORD *)(v32 + 2 * v3 + 0x10000);\n    v27 = (unsigned __int16)*v4;\n    *(_WORD *)(v32 + 2 * (v2 & 0x7FFF)) = v27;\n    *v4 = v2;\n    *(_DWORD *)(v1 - 36) = v0;\n    v36 = *(_DWORD *)(v1 - 28);\n    if ( !v27 || v0 > 0x101 || v2 - v27 > 0x7EFA )\n      goto LABEL_41;\n    v5 = (_BYTE *)(v31 + v2);\n    v29 = v0;\n    v6 = v2;\n    if ( v2 < 0x7EFA )\n      v6 = 32506;\n    v37 = v6 - 32506;\n    v35 = v31 + v2 + 258;\n    v39 = v5[v0 - 1];\n    v38 = v5[v0];\n    v33 = v0 < 0x20 ? 4096 : 1024;\n    while ( 1 )\n    {\n      v7 = (_BYTE *)(v31 + v27);\n      if ( *(_BYTE *)(v31 + v27 + v29) != v38 || v7[v29 - 1] != v39 || *v7 != *v5 || v7[1] != v5[1] )\n        goto LABEL_33;\n      v8 = v7 + 2;\n      v9 = (_BYTE *)(v31 + v2 + 2);\n      while ( v9[1] == v8[1] )\n      {\n        if ( v9[2] != v8[2] )\n        {\n          v9 += 2;\n          goto LABEL_30;\n        }\n        if ( v9[3] != v8[3] )\n        {\n          v9 += 3;\n          goto LABEL_30;\n        }\n        if ( v9[4] != v8[4] )\n        {\n          v9 += 4;\n          goto LABEL_30;\n        }\n        if ( v9[5] != v8[5] )\n        {\n          v9 += 5;\n          goto LABEL_30;\n        }\n        if ( v9[6] != v8[6] )\n        {\n          v9 += 6;\n          goto LABEL_30;\n        }\n        if ( v9[7] != v8[7] )\n        {\n          v9 += 7;\n          goto LABEL_30;\n        }\n        v9 += 8;\n        v8 += 8;\n        if ( v35 <= (unsigned int)v9 || *v9 != *v8 )\n          goto LABEL_30;\n      }\n      ++v9;\nLABEL_30:\n      v10 = v35 - (_DWORD)v9;\n      v11 = 258 - v10;\n      if ( (int)v29 >= (int)(258 - v10) )\n        goto LABEL_33;\n      *(_DWORD *)(v1 - 28) = v27;\n      if ( v11 > 257 )\n        break;\n      v39 = v5[v11 - 1];\n      v38 = v5[v11];\n      v29 = 258 - v10;\nLABEL_33:\n      v27 = *(unsigned __int16 *)(v32 + 2 * (v27 & 0x7FFF));\n      if ( v37 < v27 )\n      {\n        if ( --v33 )\n          continue;\n      }\n      goto LABEL_37;\n    }\n    v29 = 258 - v10;\nLABEL_37:\n    v0 = v34;\n    if ( v34 > v29 )\n      v0 = v29;\n    if ( v0 == 3 && v2 - *(_DWORD *)(v1 - 28) > 0x1000 )\nLABEL_41:\n      v0 = 2;\n    v12 = *(_DWORD *)(v1 - 36);\n    v13 = *(_DWORD *)(v1 - 32);\n    if ( v12 <= 2 || v12 < v0 )\n    {\n      if ( v30 )\n      {\n        if ( sub_8086203(0, *(unsigned __int8 *)(*(_DWORD *)(v1 - 56) + v13 - 1)) )\n        {\n          v23 = *(_DWORD *)(v1 - 44);\n          v24 = 0;\n          if ( v23 >= 0 )\n            v24 = v23 + *(_DWORD *)(v1 - 56);\n          sub_8086817(v24, *(_DWORD *)(v1 - 32) - v23, 0);\n          *(_DWORD *)(v1 - 44) = *(_DWORD *)(v1 - 32);\n        }\n        ++*(_DWORD *)(v1 - 32);\n        --*(_DWORD *)(v1 - 24);\n      }\n      else\n      {\n        *(_DWORD *)(v1 - 32) = v13 + 1;\n        --*(_DWORD *)(v1 - 24);\n        v30 = 1;\n      }\n    }\n    else\n    {\n      v30 = sub_8086203(v13 - 1 - v36, v12 - 3);\n      v14 = *(_DWORD *)(v1 - 36);\n      *(_DWORD *)(v1 - 24) = *(_DWORD *)(v1 - 24) + 1 - v14;\n      *(_DWORD *)(v1 - 36) = v14 - 2;\n      v28 = *(_DWORD *)(v1 - 56);\n      v15 = *(_DWORD *)(v1 - 52);\n      do\n      {\n        v16 = *(_DWORD *)(v1 - 32);\n        *(_DWORD *)(v1 - 32) = v16 + 1;\n        v17 = ((unsigned __int16)(32 * *(_DWORD *)(v1 - 40)) ^ *(unsigned __int8 *)(v28 + v16 + 3)) & 0x1FFF;\n        *(_DWORD *)(v1 - 40) = v17;\n        v18 = (_WORD *)(v15 + 2 * v17 + 0x10000);\n        *(_WORD *)(v15 + 2 * (((_WORD)v16 + 1) & 0x7FFF)) = *v18;\n        *v18 = v16 + 1;\n        v19 = *(_DWORD *)(v1 - 36) - 1;\n        *(_DWORD *)(v1 - 36) = v19;\n      }\n      while ( v19 );\n      v20 = v16 + 2;\n      *(_DWORD *)(v1 - 32) = v20;\n      v0 = 2;\n      if ( v30 )\n      {\n        v21 = *(_DWORD *)(v1 - 44);\n        v22 = v20 - v21;\n        if ( v21 >= 0 )\n          v19 = v21 + v28;\n        sub_8086817(v19, v22, 0);\n        *(_DWORD *)(v1 - 44) = *(_DWORD *)(v1 - 32);\n        v0 = 2;\n        v30 = 0;\n      }\n    }\n    sub_808636C();\n  }\n  if ( v30 )\n    sub_8086203(0, *(unsigned __int8 *)(*(_DWORD *)(dword_80DBB80 - 56) + v2 - 1));\n  v25 = *(_DWORD *)(v1 - 44);\n  v26 = 0;\n  if ( v25 >= 0 )\n    v26 = v25 + *(_DWORD *)(v1 - 56);\n  sub_8086817(v26, *(_DWORD *)(v1 - 32) - v25, 1u);\n}\n"
        ],
        "134770088": [
            "sub_8086DA8",
            "0x8086da8",
            "__int64 sub_8086DA8()\n{\n  int v0; // ebx\n  int v1; // eax\n  int v2; // esi\n  int v3; // edx\n  int i; // ecx\n  int v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int j; // esi\n  int v9; // edx\n  int v10; // ecx\n  int k; // esi\n  int m; // eax\n  unsigned int n; // eax\n  unsigned int v14; // ecx\n  int v15; // esi\n  int ii; // edx\n  int v17; // edx\n  ssize_t v18; // eax\n  unsigned __int8 *v19; // edx\n  int v20; // eax\n\n  v0 = dword_80DBB80;\n  memset((void *)(dword_80DBB80 - 48), 0, 0x1EE8u);\n  *(_DWORD *)(v0 + 5120) = v0 + 1156;\n  *(_DWORD *)(v0 + 5124) = v0 + 3692;\n  *(_DWORD *)(v0 + 5128) = byte_80D4D45;\n  *(_DWORD *)(v0 + 5132) = 257;\n  *(_DWORD *)(v0 + 5136) = 286;\n  *(_DWORD *)(v0 + 5140) = 15;\n  *(_DWORD *)(v0 + 5148) = v0 + 3448;\n  *(_DWORD *)(v0 + 5152) = v0 + 4844;\n  *(_DWORD *)(v0 + 5156) = byte_80D4D27;\n  *(_DWORD *)(v0 + 5164) = 30;\n  *(_DWORD *)(v0 + 5168) = 15;\n  *(_DWORD *)(v0 + 5176) = v0 + 4964;\n  *(_DWORD *)(v0 + 5184) = &unk_80D4D14;\n  *(_DWORD *)(v0 + 5192) = 19;\n  *(_DWORD *)(v0 + 5196) = 7;\n  sub_80864E3(559903);\n  sub_80864E3(0);\n  *(_DWORD *)(v0 - 48) = -1;\n  v1 = 0;\n  v2 = 0;\n  do\n  {\n    *(_DWORD *)(v0 + 4 * v1 + 6580) = v2;\n    v3 = 1 << byte_80D4D45[v1];\n    for ( i = 0; i < v3; ++i )\n      *(_BYTE *)(v0 + v2 + i + 5809) = v1;\n    if ( v3 < 0 )\n      v3 = 0;\n    v2 += v3;\n    ++v1;\n  }\n  while ( v1 != 28 );\n  *(_BYTE *)(v0 + v2 + 5808) = 28;\n  v5 = 0;\n  v6 = 0;\n  do\n  {\n    *(_DWORD *)(v0 + 4 * v5 + 6696) = v6;\n    v7 = 1 << byte_80D4D27[v5];\n    for ( j = 0; j < v7; ++j )\n      *(_BYTE *)(v0 + v6 + j + 6065) = v5;\n    if ( v7 < 0 )\n      v7 = 0;\n    v6 += v7;\n    ++v5;\n  }\n  while ( v5 != 16 );\n  v9 = v6 >> 7;\n  do\n  {\n    *(_DWORD *)(v0 + 4 * v5 + 6696) = v9 << 7;\n    v10 = 1 << (byte_80D4D27[v5] - 7);\n    for ( k = 0; k < v10; ++k )\n      *(_BYTE *)(v0 + v9 + k + 6321) = v5;\n    if ( v10 < 0 )\n      v10 = 0;\n    v9 += v10;\n    ++v5;\n  }\n  while ( v5 != 30 );\n  for ( m = 0; m != 144; *(_WORD *)(v0 + 4 * m + 3690) = 8 )\n    ++m;\n  do\n  {\n    ++m;\n    *(_WORD *)(v0 + 4 * m + 3690) = 9;\n  }\n  while ( m != 256 );\n  do\n  {\n    ++m;\n    *(_WORD *)(v0 + 4 * m + 3690) = 7;\n  }\n  while ( m != 280 );\n  *(_WORD *)(v0 + 4814) = 8;\n  *(_WORD *)(v0 + 4818) = 8;\n  *(_WORD *)(v0 + 4822) = 8;\n  *(_WORD *)(v0 + 4826) = 8;\n  *(_WORD *)(v0 + 4830) = 8;\n  *(_WORD *)(v0 + 4834) = 8;\n  *(_WORD *)(v0 + 4838) = 8;\n  *(_WORD *)(v0 + 4842) = 8;\n  *(_DWORD *)(v0 + 5218) = 9961496;\n  *(_WORD *)(v0 + 5222) = 112;\n  sub_8085D60(v0 + 3692, 287);\n  for ( n = 0; n != 30; ++n )\n  {\n    *(_WORD *)(v0 + 4 * n + 4846) = 5;\n    v14 = n;\n    v15 = 5;\n    for ( ii = 0; ; ii = 2 * v17 )\n    {\n      v17 = v14 & 1 | ii;\n      if ( !--v15 )\n        break;\n      v14 >>= 1;\n    }\n    *(_WORD *)(v0 + 4 * n + 4844) = v17;\n  }\n  sub_8085C14();\n  memset((void *)(*(_DWORD *)(v0 - 52) + 0x10000), 0, 0x4000u);\n  v18 = sub_8086330(*(void **)(v0 - 56), 0x10000u);\n  *(_DWORD *)(v0 - 24) = v18;\n  if ( (unsigned int)(v18 - 1) <= 0xFFFFFFFD )\n  {\n    sub_808636C();\n    v19 = *(unsigned __int8 **)(v0 - 56);\n    v20 = (*v19 ^ (unsigned __int16)(32 * *(_DWORD *)(v0 - 40))) & 0x1FFF;\n    *(_DWORD *)(v0 - 40) = v20;\n    *(_DWORD *)(v0 - 40) = (v19[1] ^ (unsigned __int16)(32 * v20)) & 0x1FFF;\n  }\n  else\n  {\n    *(_BYTE *)(v0 - 12) = 1;\n    *(_DWORD *)(v0 - 24) = 0;\n  }\n  sub_8086483(0x302u);\n  sub_8086A0A();\n  sub_80864E3(~*(_DWORD *)(v0 - 48));\n  sub_80864E3(*(_DWORD *)(v0 - 20));\n  sub_808645F();\n  return 0LL;\n}\n"
        ],
        "134770860": [
            "sub_80870AC",
            "0x80870ac",
            "int __cdecl sub_80870AC(int a1, int a2)\n{\n  char *v2; // ebx\n\n  v2 = (char *)sub_804DB2E(0x1EFCu) + 68;\n  dword_80DBB80 = (int)v2;\n  if ( (sub_80ABEAC(a2, \"cfkvqdtn123456789\") & 0x60) != 0 )\n    return sub_8085979(a1, a2);\n  dword_80DBB9C &= 0x1Fu;\n  *((_DWORD *)v2 - 17) = sub_804DB2E(0x2000u);\n  *((_DWORD *)v2 - 15) = sub_804DB2E(0x2000u);\n  *((_DWORD *)v2 - 16) = sub_804DB2E(0x4000u);\n  *((_DWORD *)v2 - 14) = sub_804DB2E(0x10000u);\n  *((_DWORD *)v2 - 13) = sub_804DB2E(0x20000u);\n  sub_80AA3E8();\n  return sub_80856FC((int *)(a2 + 4 * optind), sub_8086DA8, sub_80856EC, (int)\"gz\");\n}\n"
        ],
        "134771032": [
            "sub_8087158",
            "0x8087158",
            "_BYTE *__usercall sub_8087158@<eax>(_BYTE *result@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  char v3; // dl\n\n  *result = *a2;\n  if ( a3 == 1 )\n  {\n    v3 = *a2;\n    result[1] = v3;\n  }\n  else\n  {\n    result[1] = a2[1];\n    if ( a3 == 2 )\n      v3 = *a2;\n    else\n      v3 = a2[2];\n  }\n  result[2] = v3;\n  return result;\n}\n"
        ],
        "134771072": [
            "sub_8087180",
            "0x8087180",
            "int __usercall sub_8087180@<eax>(unsigned int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned int v3; // esi\n  unsigned int v4; // eax\n  unsigned __int8 *v5; // edi\n  unsigned int v6; // ebx\n  int v7; // eax\n  unsigned __int8 *v8; // eax\n\n  v3 = (unsigned __int16)a1;\n  v4 = HIWORD(a1);\n  if ( !a2 )\n    return 1;\n  v5 = a2;\n  v6 = v4;\n  while ( a3 )\n  {\n    v7 = a3;\n    if ( a3 > 0x15B0 )\n      v7 = 5552;\n    a3 -= v7;\n    v8 = &v5[v7];\n    do\n    {\n      v3 += *v5++;\n      v6 += v3;\n    }\n    while ( v5 != v8 );\n    v3 %= 0xFFF1u;\n    v6 %= 0xFFF1u;\n  }\n  return v3 | (v6 << 16);\n}\n"
        ],
        "134771168": [
            "sub_80871E0",
            "0x80871e0",
            "char *__usercall sub_80871E0@<eax>(const char *a1@<eax>)\n{\n  const char *v1; // ebx\n  char *v2; // eax\n  char *v3; // esi\n\n  v1 = a1;\n  if ( (dword_80DBB9C & 0x20) == 0 )\n    return sub_804DDBF(\"%s.lzo\", a1);\n  v2 = strrchr(a1, 46);\n  v3 = v2;\n  if ( !v2 || strcmp(v2 + 1, \"lzo\") )\n    return sub_804DDBF(\"%s.out\", v1);\n  *v3 = 0;\n  return (char *)v1;\n}\n"
        ],
        "134771250": [
            "sub_8087232",
            "0x8087232",
            "unsigned __int32 __usercall sub_8087232@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v2; // [esp+0h] [ebp-4h] BYREF\n\n  v2 = a1;\n  sub_80B24F6(4, &v2);\n  return _byteswap_ulong(v2);\n}\n"
        ],
        "134771272": [
            "sub_8087248",
            "0x8087248",
            "int sub_8087248()\n{\n  return ~sub_80AA41E(dword_80DBB98);\n}\n"
        ],
        "134771288": [
            "sub_8087258",
            "0x8087258",
            "int __usercall sub_8087258@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>)\n{\n  int result; // eax\n\n  buf = sub_8087180(buf, a1, a2);\n  result = sub_8087248();\n  *(&buf + 1) = result;\n  return result;\n}\n"
        ],
        "134771335": [
            "sub_8087287",
            "0x8087287",
            "int __usercall sub_8087287@<eax>(unsigned __int8 *a1@<eax>, unsigned int a2@<edx>)\n{\n  sub_80B24F6(a2, a1);\n  return sub_8087258(a1, a2);\n}\n"
        ],
        "134771363": [
            "sub_80872A3",
            "0x80872a3",
            "int __usercall sub_80872A3@<eax>(unsigned int a1@<eax>)\n{\n  char *v1; // edi\n  unsigned __int32 v2; // eax\n  unsigned int v3; // esi\n  unsigned __int32 v4; // eax\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  size_t v7; // ebx\n  unsigned __int8 *v8; // ebx\n  size_t v11; // [esp+4h] [ebp-34h]\n  unsigned int v12; // [esp+8h] [ebp-30h]\n  unsigned __int32 v13; // [esp+Ch] [ebp-2Ch]\n  unsigned __int32 v14; // [esp+10h] [ebp-28h]\n  unsigned int v15; // [esp+14h] [ebp-24h]\n  unsigned __int32 v16; // [esp+18h] [ebp-20h]\n  unsigned int v17[5]; // [esp+24h] [ebp-14h] BYREF\n\n  v1 = 0;\n  v11 = 278595;\n  v15 = 0;\n  v16 = 0;\n  v14 = 1;\n  v13 = 1;\n  v12 = 0x40000;\n  while ( 1 )\n  {\n    v2 = sub_8087232(a1);\n    v3 = v2;\n    if ( !v2 )\n      break;\n    if ( v2 == -1 )\n      sub_804D5E0(\"this file is a split lzop file\");\n    if ( v2 > 0x4000000 || (v4 = sub_8087232(v2), v5 = v4, v3 < v4) || !v4 )\nLABEL_6:\n      sub_804D5E0(\"corrupted data\");\n    if ( v12 < v3 )\n    {\n      if ( v1 )\n        free(v1);\n      v11 = v3 + (v3 >> 4) + 67;\n      v12 = v3;\n      v1 = 0;\n    }\n    if ( (a1 & 1) != 0 )\n      v14 = sub_8087232(a1 & 1);\n    v6 = a1 & 0x100;\n    if ( (a1 & 0x100) != 0 )\n    {\n      v6 = sub_8087232(v6);\n      v15 = v6;\n    }\n    v7 = v11 - v5;\n    if ( v3 <= v5 )\n    {\n      if ( v1 )\n      {\n        v8 = (unsigned __int8 *)&v1[v7];\n        sub_80B24F6(v5, v8);\n        goto LABEL_33;\n      }\nLABEL_23:\n      v1 = (char *)sub_804DB2E(v11);\n      v8 = (unsigned __int8 *)&v1[v7];\n      sub_80B24F6(v5, v8);\n      if ( v3 <= v5 )\n        goto LABEL_33;\n      goto LABEL_24;\n    }\n    if ( (a1 & 2) != 0 )\n      v13 = sub_8087232(v6);\n    if ( (a1 & 0x200) != 0 )\n      v16 = sub_8087232(a1);\n    if ( !v1 )\n      goto LABEL_23;\n    v8 = (unsigned __int8 *)&v1[v7];\n    sub_80B24F6(v5, v8);\nLABEL_24:\n    v17[0] = v3;\n    if ( (dword_80DBB9C & 0x20000) == 0\n      && ((a1 & 2) != 0 && sub_8087180(1u, v8, v5) != v13 || (a1 & 0x200) != 0 && sub_8087248() != v16) )\n    {\nLABEL_27:\n      sub_804D5E0(\"checksum error\");\n    }\n    if ( sub_808EA8F(v8, v5, v1, v17) || v17[0] != v3 )\n      goto LABEL_6;\n    v8 = (unsigned __int8 *)v1;\nLABEL_33:\n    if ( (dword_80DBB9C & 0x20000) == 0\n      && ((a1 & 1) != 0 && v14 != sub_8087180(1u, v8, v3) || (a1 & 0x100) != 0 && v15 != sub_8087248()) )\n    {\n      goto LABEL_27;\n    }\n    sub_804DCAD(v3, v8);\n  }\n  free(v1);\n  return 1;\n}\n"
        ],
        "134771904": [
            "sub_80874C0",
            "0x80874c0",
            "int sub_80874C0()\n{\n  unsigned __int16 v0; // ax\n  unsigned __int16 v1; // ax\n  int v2; // eax\n  int v3; // eax\n  size_t v4; // ebx\n  int v5; // eax\n  unsigned __int32 v6; // ebx\n  int i; // esi\n  size_t v8; // ebx\n  unsigned int v10; // [esp+0h] [ebp-128h] BYREF\n  unsigned __int8 s1[6]; // [esp+4h] [ebp-124h] BYREF\n  char v12; // [esp+Ah] [ebp-11Eh]\n  char v13; // [esp+Bh] [ebp-11Dh]\n  int v14; // [esp+Ch] [ebp-11Ch]\n  unsigned __int8 v15; // [esp+1Ch] [ebp-10Ch]\n  unsigned __int8 v16[267]; // [esp+1Dh] [ebp-10Bh] BYREF\n\n  sub_80B24F6(9, s1);\n  if ( memcmp(s1, &unk_80D4E1C, 9u) )\n    sub_804D5E0(\"bad magic number\");\n  *(_QWORD *)&buf = 1LL;\n  sub_8087287(s1, 0x19u);\n  LOBYTE(v0) = s1[1];\n  HIBYTE(v0) = s1[0];\n  if ( v0 <= 0x93Fu )\n    goto LABEL_32;\n  LOBYTE(v1) = s1[5];\n  HIBYTE(v1) = s1[4];\n  if ( v1 > 0x1010u )\n  {\nLABEL_5:\n    v2 = 16;\n    goto LABEL_38;\n  }\n  if ( v1 <= 0x93Fu )\n    goto LABEL_32;\n  switch ( v12 )\n  {\n    case 0:\n      v2 = 14;\n      goto LABEL_38;\n    case 1:\n      if ( !v13 )\n        v13 = 3;\n      break;\n    case 2:\n      if ( !v13 )\n        v13 = 1;\n      break;\n    case 3:\n      if ( !v13 )\n        v13 = 9;\n      break;\n    default:\n      v2 = -1;\n      goto LABEL_38;\n  }\n  if ( (unsigned __int8)(v13 - 1) > 8u )\n  {\n    v2 = 15;\n    goto LABEL_38;\n  }\n  v3 = _byteswap_ulong(v14);\n  v14 = v3;\n  if ( (v3 & 0x800) != 0 )\n    goto LABEL_5;\n  if ( (v3 & 0xFC000) != 0 )\n  {\n    v2 = -13;\n    goto LABEL_38;\n  }\n  if ( v15 )\n    v3 = sub_8087287(v16, v15);\n  v4 = buf;\n  if ( (v14 & 0x1000) != 0 )\n    v4 = *(&buf + 1);\n  if ( sub_8087232(v3) != v4 )\n  {\n    v2 = 2;\nLABEL_38:\n    sub_804D5E0(\"header_error %d\", v2);\n  }\n  if ( (v14 & 0x40) != 0 )\n  {\n    *(_QWORD *)&buf = 1LL;\n    v5 = sub_8087287((unsigned __int8 *)&v10, 4u);\n    v6 = _byteswap_ulong(v10);\n    for ( i = 0; i != v6; ++i )\n      v5 = sub_8087287((unsigned __int8 *)&v10, 1u);\n    v8 = buf;\n    if ( (v14 & 0x1000) != 0 )\n      v8 = *(&buf + 1);\n    if ( sub_8087232(v5) != v8 )\n    {\nLABEL_32:\n      v2 = 3;\n      goto LABEL_38;\n    }\n  }\n  return sub_80872A3(v14);\n}\n"
        ],
        "134772362": [
            "sub_808768A",
            "0x808768a",
            "int __usercall sub_808768A@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _DWORD *a4)\n{\n  _BYTE *v4; // ebp\n  int v5; // ebx\n  unsigned int v6; // ebx\n  _BYTE *v7; // edx\n  int m; // esi\n  _BYTE *v9; // ecx\n  unsigned __int8 *v10; // ebp\n  _BYTE *v11; // edi\n  unsigned __int8 *v12; // eax\n  int v13; // ecx\n  _BYTE *v14; // edx\n  _BYTE *v15; // ecx\n  int v16; // eax\n  _BYTE *v17; // esi\n  char v18; // dl\n  char v19; // al\n  int v20; // ecx\n  _BYTE *v21; // esi\n  int v22; // ebx\n  int j; // ecx\n  int v24; // edx\n  int v25; // ecx\n  int ii; // ebx\n  int v27; // edx\n  int v28; // edx\n  _BYTE *v29; // edx\n  int v30; // ebx\n  unsigned __int8 v31; // al\n  int k; // ecx\n  unsigned int v33; // edi\n  _BYTE *v34; // ecx\n  char v35; // al\n  int i; // edx\n  int v37; // ebx\n  int result; // eax\n  size_t n; // [esp+0h] [ebp-30h]\n  _BYTE *v40; // [esp+4h] [ebp-2Ch]\n  _BYTE *v41; // [esp+8h] [ebp-28h]\n  int v42; // [esp+8h] [ebp-28h]\n  _BYTE *v43; // [esp+Ch] [ebp-24h]\n  int v44; // [esp+Ch] [ebp-24h]\n  unsigned int v46; // [esp+14h] [ebp-1Ch]\n  _BYTE *v47; // [esp+18h] [ebp-18h]\n  unsigned int v48; // [esp+18h] [ebp-18h]\n  unsigned int v49; // [esp+18h] [ebp-18h]\n  unsigned int v50; // [esp+1Ch] [ebp-14h]\n\n  v4 = a1;\n  v46 = (unsigned int)&a1[a2];\n  v50 = (unsigned int)&a3[*a4];\n  *a4 = 0;\n  v5 = *a1;\n  if ( (unsigned __int8)v5 > 0x11u )\n  {\n    v4 = a1 + 1;\n    v6 = v5 - 17;\n    if ( (int)v6 > 3 )\n    {\n      v7 = a3;\n      n = 0;\n      v40 = 0;\n      goto LABEL_7;\n    }\n    v11 = a3;\n    n = 0;\n    v40 = 0;\n    goto LABEL_70;\n  }\n  v11 = a3;\n  n = 0;\n  v40 = 0;\nLABEL_24:\n  if ( (unsigned int)v4 >= v46 || (unsigned int)v11 > v50 )\n  {\nLABEL_90:\n    *a4 = v11 - a3;\n    return -7;\n  }\n  v12 = v4 + 1;\n  v6 = (unsigned __int8)*v4;\n  if ( v6 <= 0xF )\n  {\n    if ( !*v4 )\n    {\n      for ( i = 15; ; i += 255 )\n      {\n        v37 = *v12++;\n        if ( (_BYTE)v37 )\n          break;\n      }\n      v6 = i + v37;\n    }\n    n = v6 + 3;\n    v41 = v12;\n    goto LABEL_6;\n  }\n  while ( 1 )\n  {\nLABEL_27:\n    if ( v6 > 0x3F )\n    {\n      v4 = v12 + 1;\n      v20 = ~((v6 >> 2) & 7) - 8 * *v12;\n      v21 = &v11[v20];\n      v22 = (v6 >> 5) - 1;\n      v44 = v22;\n      if ( !v40 )\n        goto LABEL_63;\n      if ( v22 != 1 )\n        goto LABEL_63;\n      if ( (*(v12 - 1) & 3) != 0 )\n        goto LABEL_63;\n      if ( n <= 3 )\n        goto LABEL_63;\n      v6 = v12[1];\n      if ( (unsigned __int8)(v6 - 1) > 0xEu )\n        goto LABEL_63;\n      v48 = v6 + n;\n      if ( v6 + n + 3 > 0xF )\n        goto LABEL_63;\n      v41 = v12 + 2;\n      sub_8087158(v12 - 1, v21, -v20);\n      n = v48 + 6;\n      *v40 = v48 + 3;\n      *v11 = *v21;\n      v11[1] = v21[1];\n      v11[2] = v21[2];\n      v4 = v40;\n      goto LABEL_62;\n    }\n    if ( v6 <= 0x1F )\n      break;\n    v44 = v6 & 0x1F;\n    if ( (v6 & 0x1F) == 0 )\n    {\n      for ( j = 31; ; j += 255 )\n      {\n        v24 = *v12++;\n        if ( (_BYTE)v24 )\n          break;\n      }\n      v44 = v24 + j;\n    }\n    v4 = v12 + 2;\n    v21 = &v11[~(*v12 >> 2) - (v12[1] << 6)];\nLABEL_49:\n    if ( !v40 || v44 != 1 )\n    {\nLABEL_63:\n      v42 = -1;\nLABEL_64:\n      *v11 = *v21;\n      v29 = v11 + 2;\n      v11[1] = v21[1];\n      v30 = 0;\n      do\n      {\n        v29[v30] = v21[v30 + 2];\n        ++v30;\n      }\n      while ( v44 != v30 );\n      v11 = &v29[v44];\n      while ( 1 )\n      {\n        if ( v42 != -1 )\n          goto LABEL_24;\nLABEL_67:\n        v31 = *(v4 - 2) & 3;\n        v6 = v31;\n        v40 = v4 - 2;\n        n = v31;\n        if ( !v31 )\n        {\n          n = 0;\n          goto LABEL_24;\n        }\nLABEL_70:\n        for ( k = 0; ; ++k )\n        {\n          v11[k] = v4[k];\n          if ( v6 == k + 1 )\n            break;\n        }\n        v43 = &v11[k];\n        v47 = &v4[k];\n        v15 = &v4[v6];\n        v11 += v6;\n        v12 = v47 + 2;\n        v6 = (unsigned __int8)v4[v6];\n        if ( v46 <= (unsigned int)(v47 + 2) || v50 < (unsigned int)v11 )\n          goto LABEL_90;\n        if ( v6 > 0xF )\n          goto LABEL_27;\n        v4 = v15 + 2;\n        v16 = (v6 >> 2) + 4 * (unsigned __int8)v15[1];\n        v17 = &v43[-v16];\n        if ( !v40 )\n          goto LABEL_83;\n        v18 = v6 & 3;\n        if ( n != 1 || v18 )\n          break;\n        if ( v15[2] <= 0xFu )\n          goto LABEL_75;\n        *v40 |= 3u;\n        *v15 = *v17;\n        if ( v16 )\n          v19 = v17[1];\n        else\n          v19 = *v17;\n        v15[1] = v19;\n        v42 = 0;\n        n = 3;\nLABEL_22:\n        v43[1] = *v17;\n        v11 = v43 + 3;\n        v43[2] = v17[1];\n      }\n      if ( !v18 )\n      {\nLABEL_75:\n        v6 = (unsigned __int8)v15[2];\n        if ( (unsigned __int8)(v6 - 1) <= 0xEu )\n        {\n          v33 = v6 + n;\n          if ( v6 + n + 2 <= 0xF )\n          {\n            v41 = v15 + 3;\n            *v40 &= 0xFCu;\n            v34 = v47;\n            v47[2] = *v17;\n            if ( v16 )\n            {\n              v35 = v17[1];\n              v34 = v47;\n            }\n            else\n            {\n              v35 = *v17;\n            }\n            v34[3] = v35;\n            v4 = v40 + 2;\n            if ( n )\n              memmove(v40 + 3, v40 + 2, n);\n            n = v33 + 5;\n            v40[2] = v33 + 2;\n            v43[1] = *v17;\n            v11 = v43 + 3;\n            v43[2] = v17[1];\n            goto LABEL_6;\n          }\n        }\n      }\nLABEL_83:\n      v42 = -1;\n      goto LABEL_22;\n    }\n    if ( !n && (*(v4 - 2) & 3) == 0 && *v4 > 0xFu )\n    {\n      *v40 |= 3u;\n      sub_8087158(v4 - 3, v21, v11 - v21);\n      v42 = 0;\n      n = 3;\n      goto LABEL_64;\n    }\n    if ( n > 3 )\n      goto LABEL_63;\n    if ( (*(v4 - 2) & 3) != 0 )\n      goto LABEL_63;\n    v6 = (unsigned __int8)*v4;\n    if ( (unsigned __int8)(v6 - 1) > 0xEu )\n      goto LABEL_63;\n    v49 = v6 + n;\n    if ( v6 + n + 3 > 0xF )\n      goto LABEL_63;\n    v41 = v4 + 1;\n    *v40 &= 0xFCu;\n    sub_8087158(v4 - 2, v21, v11 - v21);\n    v4 = v40 + 2;\n    if ( n )\n      memmove(v40 + 3, v40 + 2, n);\n    n = v49 + 6;\n    v40[2] = v49 + 3;\n    *v11 = *v21;\n    v11[1] = v21[1];\n    v11[2] = v21[2];\nLABEL_62:\n    v11 += 3;\nLABEL_6:\n    *v11 = *v41;\n    v11[1] = v41[1];\n    v7 = v11 + 3;\n    v11[2] = v41[2];\n    v40 = v4;\n    v4 = v41 + 3;\nLABEL_7:\n    for ( m = 0; ; ++m )\n    {\n      v7[m] = v4[m];\n      if ( v6 == m + 1 )\n        break;\n    }\n    v9 = &v4[m];\n    v10 = &v4[v6];\n    v11 = &v7[v6];\n    v12 = v9 + 2;\n    v6 = *v10;\n    v13 = (unsigned __int8)v9[2];\n    if ( v6 <= 0xF )\n    {\n      v4 = v10 + 2;\n      v14 = &v7[-2048 - (v6 >> 2) - 4 * v13 + m];\n      *v11 = *v14;\n      v11[1] = v14[1];\n      v11[2] = v14[2];\n      v11 += 3;\n      goto LABEL_67;\n    }\n  }\n  v25 = ((_WORD)v6 << 11) & 0x4000;\n  v44 = v6 & 7;\n  if ( (v6 & 7) == 0 )\n  {\n    for ( ii = 7; ; ii += 255 )\n    {\n      v27 = *v12++;\n      if ( (_BYTE)v27 )\n        break;\n    }\n    v44 = v27 + ii;\n  }\n  v4 = v12 + 2;\n  v28 = (*v12 >> 2) + v25 + (v12[1] << 6);\n  if ( v11 != &v11[-v28] )\n  {\n    v21 = &v11[-v28 - 0x4000];\n    goto LABEL_49;\n  }\n  *a4 = v11 - a3;\n  result = 0;\n  if ( (_BYTE *)v46 != v4 )\n    return (unsigned int)v4 < v46 ? -8 : -4;\n  return result;\n}\n"
        ],
        "134773827": [
            "sub_8087C43",
            "0x8087c43",
            "int __usercall sub_8087C43@<eax>(int a1@<eax>)\n{\n  char *v1; // ebp\n  size_t v2; // eax\n  ssize_t v3; // eax\n  unsigned int v4; // esi\n  unsigned __int32 v5; // ebx\n  int v6; // edi\n  int v7; // eax\n  int v8; // edi\n  unsigned __int32 *v9; // ebx\n  size_t v10; // ecx\n  void *v11; // edx\n  unsigned __int8 *v13; // [esp+0h] [ebp-48h]\n  void *ptr; // [esp+8h] [ebp-40h]\n  int v16; // [esp+10h] [ebp-38h]\n  int v17; // [esp+14h] [ebp-34h]\n  unsigned int v18; // [esp+18h] [ebp-30h] BYREF\n  unsigned int v19; // [esp+1Ch] [ebp-2Ch] BYREF\n  unsigned __int32 v20; // [esp+20h] [ebp-28h] BYREF\n  unsigned __int32 v21; // [esp+24h] [ebp-24h]\n  unsigned __int32 v22; // [esp+28h] [ebp-20h] BYREF\n  char v23; // [esp+2Ch] [ebp-1Ch] BYREF\n\n  v1 = (char *)sub_804DB2E(0x40000u);\n  v13 = (unsigned __int8 *)sub_804DB2E(0x44043u);\n  if ( *(_BYTE *)(a1 + 6) == 1 )\n    v2 = 0x10000;\n  else\n    v2 = 0x20000;\n  ptr = sub_804DB2E(v2);\n  v17 = 0;\n  v16 = 1;\n  while ( 1 )\n  {\n    v3 = sub_804E5E3(0x40000u, v1, 0);\n    v4 = v3;\n    if ( v3 < 0 )\n      v4 = 0;\n    if ( v3 <= 0 )\n      break;\n    v5 = _byteswap_ulong(v4);\n    v20 = v5;\n    v6 = *(_DWORD *)(a1 + 8);\n    if ( (v6 & 1) != 0 )\n      v16 = sub_8087180(1u, (unsigned __int8 *)v1, v4);\n    if ( (v6 & 0x100) != 0 )\n      v17 = sub_8087248();\n    if ( *(_BYTE *)(a1 + 6) == 1 )\n      v7 = sub_808E648(v1, v4, v13, &v18, ptr);\n    else\n      v7 = sub_808E9D3(v1, v4, v13, &v18, ptr);\n    if ( v7 )\n      sub_804D5E0(\"%s: %s\", \"internal error\", \"compression\");\n    if ( v18 >= v4 )\n    {\n      v21 = v5;\n    }\n    else\n    {\n      if ( *(_BYTE *)(a1 + 6) == 3 )\n      {\n        v19 = v4;\n        if ( sub_808768A(v13, v18, v1, &v19) || v19 != v4 )\n          sub_804D5E0(\"%s: %s\", \"internal error\", \"optimization\");\n      }\n      v21 = _byteswap_ulong(v18);\n    }\n    v8 = *(_DWORD *)(a1 + 8);\n    v9 = &v22;\n    if ( (v8 & 1) != 0 )\n    {\n      v22 = _byteswap_ulong(v16);\n      v9 = (unsigned __int32 *)&v23;\n    }\n    if ( (v8 & 0x100) != 0 )\n      *v9++ = _byteswap_ulong(v17);\n    if ( v18 < v4 )\n    {\n      if ( (v8 & 2) != 0 )\n        *v9++ = _byteswap_ulong(sub_8087180(1u, v13, v18));\n      if ( (v8 & 0x200) != 0 )\n        *v9++ = _byteswap_ulong(sub_8087248());\n    }\n    sub_804DCAD((char *)v9 - (char *)&v20, &v20);\n    v10 = v18;\n    v11 = v13;\n    if ( v18 >= v4 )\n    {\n      v10 = v4;\n      v11 = v1;\n    }\n    sub_804DCAD(v10, v11);\n  }\n  v20 = 0;\n  sub_804DCAD(4u, &v20);\n  free(ptr);\n  free(v1);\n  free(v13);\n  return 1;\n}\n"
        ],
        "134774380": [
            "sub_8087E6C",
            "0x8087e6c",
            "int sub_8087E6C()\n{\n  char v0; // dl\n  unsigned int v1; // eax\n  unsigned __int32 v3; // [esp+0h] [ebp-128h] BYREF\n  int v4[73]; // [esp+4h] [ebp-124h] BYREF\n\n  memset(v4, 0, 0x11Cu);\n  BYTE2(v4[1]) = 1;\n  v0 = 5;\n  if ( (dword_80DBB9C & 0x80u) != 0 )\n  {\n    BYTE2(v4[1]) = 2;\n    v0 = 1;\n  }\n  if ( (dword_80DBB9C & 0xE000) != 0 )\n    sub_804D5E0(\"high compression not compiled in\");\n  HIBYTE(v4[1]) = v0;\n  v4[0] = 807407632;\n  LOWORD(v4[1]) = 16393;\n  v4[2] = 3;\n  if ( (dword_80DBB9C & 0x20000) == 0 )\n  {\n    v4[2] = 16777219;\n    if ( (dword_80DBB9C & 0x10000) != 0 )\n      v4[2] = 50331651;\n  }\n  sub_804DCAD(9u, &unk_80D4E1C);\n  *(_QWORD *)&buf = 1LL;\n  sub_804DCAD(0x19u, v4);\n  sub_8087258((unsigned __int8 *)v4, 0x19u);\n  v4[2] = _byteswap_ulong(v4[2]);\n  v1 = buf;\n  if ( (v4[2] & 0x1000) != 0 )\n    v1 = *(&buf + 1);\n  v3 = _byteswap_ulong(v1);\n  sub_804DCAD(4u, &v3);\n  return sub_8087C43((int)v4);\n}\n"
        ],
        "134774636": [
            "sub_8087F6C",
            "0x8087f6c",
            "__int64 sub_8087F6C()\n{\n  __int64 result; // rax\n\n  if ( (dword_80DBB9C & 0x20) != 0 )\n    LODWORD(result) = sub_80874C0();\n  else\n    LODWORD(result) = sub_8087E6C();\n  return (int)result;\n}\n"
        ],
        "134774665": [
            "sub_8087F89",
            "0x8087f89",
            "int __cdecl sub_8087F89(int a1, int a2)\n{\n  int *v2; // ebx\n  int v3; // eax\n  char v4; // al\n\n  sub_80ABEAC(a2, \"cfUvqdt123456789CFk\");\n  v2 = (int *)(a2 + 4 * optind);\n  v3 = dword_80DBB9C;\n  dword_80DBB9C ^= 4u;\n  if ( (dword_80DBB9C & 0x40000) != 0 )\n    dword_80DBB9C = v3 | 4;\n  v4 = ident[4];\n  if ( v4 == 99 )\n  {\n    dword_80DBB9C |= 0x21u;\n  }\n  else if ( v4 == 111 )\n  {\n    dword_80DBB9C |= 0x20u;\n  }\n  sub_80AA3E8();\n  return sub_80856FC(v2, sub_8087F6C, (int (*)(void))sub_80871E0, 0);\n}\n"
        ],
        "134774779": [
            "sub_8087FFB",
            "0x8087ffb",
            "int __usercall sub_8087FFB@<eax>(int a1@<eax>)\n{\n  FILE *v1; // esi\n  const char *v2; // eax\n  const char *v3; // ebx\n  const char *v4; // eax\n  int v5; // ecx\n  int v7; // [esp+0h] [ebp-10h]\n\n  v7 = a1;\n  while ( v7 )\n  {\n    sub_80AFB01(v7);\n    v1 = (FILE *)sub_80B3D9B();\n    while ( 1 )\n    {\n      v2 = (const char *)sub_80AB85A();\n      v3 = v2;\n      if ( !v2 )\n        break;\n      v4 = sub_804D378(v2, 47);\n      if ( v3 < v4 )\n        *v4 = 0;\n      sub_80AFADF(v5, v3);\n    }\n    fclose(v1);\n  }\n  return 0;\n}\n"
        ],
        "134774879": [
            "sub_808805F",
            "0x808805f",
            "int __usercall sub_808805F@<eax>(int *a1@<eax>, _DWORD *a2@<ecx>)\n{\n  int v4; // ebp\n\n  sub_804E010(*a1, (int)(a1 + 5), \"can't stat tar file\");\n  v4 = 0;\n  while ( a2 )\n  {\n    if ( !sub_80B2549(sub_808859C, a1, 0) )\n      v4 = 1;\n    a2 = (_DWORD *)*a2;\n  }\n  memset(&buf, 0, 0x400u);\n  sub_804DCAD(0x400u, &buf);\n  close(*a1);\n  if ( v4 )\n    sub_804D5F4(\"error exit delayed from previous errors\");\n  return v4;\n}\n"
        ],
        "134775004": [
            "sub_80880DC",
            "0x80880dc",
            "unsigned int __usercall sub_80880DC@<eax>(char *a1@<eax>, unsigned int a2@<edx>, __int64 a3)\n{\n  unsigned int result; // eax\n  char *v6; // esi\n  char s[41]; // [esp+3h] [ebp-29h] BYREF\n\n  result = sprintf(s, \"%0*llo\", a2, a3) - a2;\n  v6 = &s[result];\n  if ( s[result] == 48 )\n    ++v6;\n  qmemcpy(a1, v6, a2);\n  return result;\n}\n"
        ],
        "134775066": [
            "sub_808811A",
            "0x808811a",
            "void __fastcall sub_808811A(int a1, int a2)\n{\n  int v3; // edx\n  int v4; // esi\n\n  strcpy((char *)(a2 + 257), \"ustar  \");\n  *(_DWORD *)(a2 + 148) = 538976288;\n  *(_DWORD *)(a2 + 152) = 538976288;\n  v3 = 0;\n  v4 = 0;\n  do\n    v4 += *(unsigned __int8 *)(a2 + v3++);\n  while ( v3 != 512 );\n  sub_80880DC((char *)(a2 + 148), 7u, v4);\n  sub_804DCAD(0x200u, (void *)a2);\n}\n"
        ],
        "134775172": [
            "sub_8088184",
            "0x8088184",
            "void __usercall sub_8088184(char *s@<ecx>, char a2@<dl>, int a3)\n{\n  signed int v3; // ebx\n  int v4; // ecx\n  int v5; // ebx\n  char dest[528]; // [esp+Ch] [ebp-210h] BYREF\n\n  v3 = strlen(s) + a3 + 1;\n  memset(dest, 0, 0x200u);\n  strcpy(dest, \"././@LongLink\");\n  qmemcpy(&dest[100], \"0000000\", 0x30u);\n  sub_80880DC(&dest[124], 0xCu, v3);\n  dest[156] = a2;\n  sub_808811A(v4, (int)dest);\n  sub_804DCAD(v3 - 2 * a3, s);\n  sub_804DCAD(2 * a3, (void *)\"/\");\n  v5 = -v3 & 0x1FF;\n  memset(dest, 0, v5);\n  sub_804DCAD(v5, dest);\n}\n"
        ],
        "134775381": [
            "sub_8088255",
            "0x8088255",
            "int __usercall sub_8088255@<eax>(_DWORD *a1@<eax>, char *a2@<edx>, const char *a3@<ecx>, int a4)\n{\n  int v6; // eax\n  char *v7; // ecx\n  int v8; // edi\n  char *v9; // edi\n  int v10; // eax\n  char *v11; // edi\n  int result; // eax\n  unsigned int v13; // eax\n  unsigned int v14; // eax\n  unsigned __int64 v15; // rax\n  char v16; // bp\n  FILE *v17; // edx\n  const char *v18; // ecx\n  char *v19; // [esp-4h] [ebp-218h]\n  char dest[528]; // [esp+4h] [ebp-210h] BYREF\n\n  memset(dest, 0, 0x200u);\n  strncpy(dest, a2, 0x64u);\n  sub_80880DC(&dest[100], 8u, *(_DWORD *)(a4 + 16) & 0xFFFLL);\n  sub_80880DC(&dest[108], 8u, *(unsigned int *)(a4 + 24));\n  sub_80880DC(&dest[116], 8u, *(unsigned int *)(a4 + 28));\n  memset(&dest[124], 48, 0xBu);\n  v6 = *(_DWORD *)(a4 + 72);\n  if ( v6 < 0 )\n    v6 = 0;\n  sub_80880DC(&dest[136], 0xCu, v6);\n  sub_80B0E79();\n  sub_80B2C4E(32);\n  sub_80B0E8A();\n  sub_80B2C4E(32);\n  v8 = a1[4];\n  if ( v8 )\n  {\n    dest[156] = 49;\n    v9 = (char *)(v8 + 20);\n    strncpy(&dest[157], v9, 0x64u);\n    if ( !dest[256] )\n      goto LABEL_30;\n    sub_8088184(v9, 75, 0);\n    goto LABEL_11;\n  }\n  v10 = *(_DWORD *)(a4 + 16) & 0xF000;\n  if ( v10 == 40960 )\n  {\n    v11 = (char *)sub_804E261(a3);\n    result = 0;\n    if ( !v11 )\n      return result;\n    dest[156] = 50;\n    strncpy(&dest[157], v11, 0x64u);\n    if ( dest[256] )\n      sub_8088184(v11, 75, 0);\n    free(v11);\nLABEL_11:\n    v7 = v19;\n    goto LABEL_30;\n  }\n  if ( v10 != 0x4000 )\n  {\n    if ( v10 == 0x2000 )\n    {\n      dest[156] = 51;\n    }\n    else\n    {\n      if ( v10 != 24576 )\n      {\n        if ( v10 == 4096 )\n        {\n          dest[156] = 54;\n        }\n        else\n        {\n          if ( v10 != 0x8000 )\n          {\n            sub_804D5F4(\"%s: unknown file type\", a3);\n            return 0;\n          }\n          v15 = *(_QWORD *)(a4 + 44);\n          if ( HIDWORD(v15) > 0xF )\n          {\n            v7 = &dest[136];\n            do\n            {\n              --v7;\n              v16 = v15;\n              *v7 = v15;\n              v15 >>= 8;\n            }\n            while ( v7 != &dest[124] );\n            dest[124] = v16 | 0x80;\n          }\n          else\n          {\n            sub_80880DC(&dest[124], 0xCu, *(_QWORD *)(a4 + 44));\n          }\n          dest[156] = 48;\n        }\nLABEL_30:\n        if ( !dest[99] )\n          goto LABEL_32;\n        goto LABEL_31;\n      }\n      dest[156] = 52;\n    }\n    v13 = gnu_dev_major(*(_QWORD *)(a4 + 32));\n    sub_80880DC(&dest[329], 8u, v13);\n    v14 = gnu_dev_minor(*(_QWORD *)(a4 + 32));\n    sub_80880DC(&dest[337], 8u, v14);\n    goto LABEL_30;\n  }\n  dest[156] = 53;\n  if ( !dest[99] )\n  {\n    dest[strlen(dest)] = 47;\n    goto LABEL_30;\n  }\nLABEL_31:\n  sub_8088184(a2, 76, (*(_DWORD *)(a4 + 16) & 0xF000) == 0x4000);\nLABEL_32:\n  sub_808811A((int)v7, (int)dest);\n  result = 1;\n  if ( a1[1] )\n  {\n    v17 = stdout;\n    if ( *a1 == 1 )\n      v17 = stderr;\n    v18 = &data;\n    if ( (*(_DWORD *)(a4 + 16) & 0xF000) == 0x4000 )\n      v18 = \"/\";\n    fprintf(v17, \"%s%s\\n\", a2, v18);\n    return 1;\n  }\n  return result;\n}\n"
        ],
        "134776220": [
            "sub_808859C",
            "0x808859c",
            "int __userpurge sub_808859C@<eax>(const char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)\n{\n  char *v6; // eax\n  char *v7; // edi\n  int v8; // eax\n  _DWORD *i; // eax\n  size_t v11; // eax\n  void *v12; // eax\n  int v13; // ecx\n  int v14; // ecx\n  int j; // edx\n  const char *v16; // eax\n  int v17; // eax\n  const char *k; // ebp\n  int v19; // eax\n  int v20; // ebp\n  int v21; // edx\n  int v23; // [esp+4h] [ebp-14h]\n  int v24; // [esp+4h] [ebp-14h]\n\n  v6 = (char *)sub_808EFDF();\n  if ( !*v6 )\n    return 1;\n  v7 = v6;\n  v8 = *(_DWORD *)(a2 + 16) & 0xF000;\n  if ( v8 == 49152 )\n  {\n    sub_804D5F4(\"%s: socket ignored\");\n    return 1;\n  }\n  a3[4] = 0;\n  if ( v8 != 0x4000 && *(_DWORD *)(a2 + 20) > 1u )\n  {\n    for ( i = (_DWORD *)a3[3];\n          i\n       && (*(_DWORD *)(a2 + 92) != i[4]\n        || *(_DWORD *)(a2 + 88) != i[3]\n        || *(_DWORD *)(a2 + 4) != i[2]\n        || *(_DWORD *)a2 != i[1]);\n          i = (_DWORD *)*i )\n    {\n      ;\n    }\n    a3[4] = (int)i;\n    if ( !i )\n    {\n      v11 = strlen(v7);\n      v12 = sub_804DAFA(v11 + 24);\n      *(_DWORD *)v12 = a3[3];\n      a3[3] = (int)v12;\n      v13 = *(_DWORD *)(a2 + 4);\n      *((_DWORD *)v12 + 1) = *(_DWORD *)a2;\n      *((_DWORD *)v12 + 2) = v13;\n      v14 = *(_DWORD *)(a2 + 92);\n      *((_DWORD *)v12 + 3) = *(_DWORD *)(a2 + 88);\n      *((_DWORD *)v12 + 4) = v14;\n      strcpy((char *)v12 + 20, v7);\n    }\n  }\n  if ( a3[6] == *(_DWORD *)(a2 + 4)\n    && a3[5] == *(_DWORD *)a2\n    && a3[28] == *(_DWORD *)(a2 + 92)\n    && a3[27] == *(_DWORD *)(a2 + 88) )\n  {\n    sub_804D5F4(\"%s: file is the archive; skipping\");\n    return 1;\n  }\n  for ( j = a3[2]; j; j = *(_DWORD *)j )\n  {\n    v16 = *(const char **)(j + 4);\n    if ( *v16 == 47 )\n    {\n      v23 = j;\n      v17 = fnmatch(v16, v7, 9);\n      j = v23;\n      if ( !v17 )\n        return 2;\n    }\n    else\n    {\n      for ( k = v7; *k; ++k )\n      {\n        if ( (v7 == k || *(k - 1) == 47) && *k != 47 )\n        {\n          v24 = j;\n          v19 = fnmatch(*(const char **)(j + 4), k, 9);\n          j = v24;\n          if ( !v19 )\n            return 2;\n        }\n      }\n    }\n  }\n  if ( a3[4] || (*(_DWORD *)(a2 + 16) & 0xF000) != 0x8000 )\n  {\n    v20 = -1;\n  }\n  else\n  {\n    v20 = sub_804DC14(a1);\n    if ( v20 < 0 )\n      return 0;\n  }\n  if ( sub_8088255(a3, v7, a1, a2) )\n  {\n    if ( v20 != -1 )\n    {\n      sub_804E51A(v20, *a3, *(_QWORD *)(a2 + 44));\n      close(v20);\n      v21 = -*(_DWORD *)(a2 + 44) & 0x1FF;\n      memset(&buf, 0, v21);\n      sub_804DCAD(v21, &buf);\n    }\n    return 1;\n  }\n  return 0;\n}\n"
        ],
        "134776706": [
            "sub_8088782",
            "0x8088782",
            "int __cdecl sub_8088782(int a1, int a2)\n{\n  unsigned int *v2; // ebx\n  const char *v3; // ebp\n  int v4; // esi\n  char *v5; // eax\n  char v6; // dl\n  int v7; // esi\n  const char **v8; // edi\n  int v9; // eax\n  const char *v10; // eax\n  unsigned int v11; // eax\n  _DWORD *v12; // eax\n  char v13; // dl\n  _DWORD *v14; // ecx\n  const char *v15; // eax\n  int v16; // ecx\n  unsigned int v17; // eax\n  int v18; // ecx\n  int *v19; // eax\n  const char *v21; // [esp+0h] [ebp-20h] BYREF\n  const char *v22; // [esp+4h] [ebp-1Ch] BYREF\n  int v23; // [esp+8h] [ebp-18h] BYREF\n  int v24[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v21 = 0;\n  v22 = \"-\";\n  v23 = 0;\n  v24[0] = 0;\n  v2 = (unsigned int *)sub_808E331();\n  *v2 = 7;\n  if ( getuid() )\n    *v2 |= 0x20u;\n  v3 = *(const char **)(a2 + 4);\n  if ( v3 )\n  {\n    v4 = strcmp(v3, \"--version\");\n    if ( !v4 )\n    {\n      puts(\"tar (busybox) 1.29.2\");\n      return v4;\n    }\n    if ( *v3 && *v3 != 45 )\n    {\n      v5 = strchr(v3, 102);\n      if ( v5 )\n      {\n        while ( 1 )\n        {\n          v6 = v5[1];\n          if ( !v6 )\n            break;\n          *v5++ = v6;\n        }\n        *v5 = 102;\n      }\n      *(_DWORD *)(a2 + 4) = sub_804DDBF((char *)\"-%s\", *(const char **)(a2 + 4));\n    }\n  }\n  v7 = sub_80ABEC2(a2, &unk_80D4F1E, \"list\", &v21, &v22, v2 + 3, v2 + 4, v2 + 13, v2 + 17, v24, &v23, &v23);\n  v8 = (const char **)(a2 + 4 * optind);\n  v9 = v23;\n  if ( v23 )\n  {\n    v2[8] = (unsigned int)sub_808E26D;\n    if ( v9 == 1 )\n      v2[8] = (unsigned int)sub_808E264;\n  }\n  if ( (v7 & 2) != 0 )\n    v2[9] = (unsigned int)sub_8089512;\n  if ( (v7 & 0x10) != 0 )\n    v2[9] = (unsigned int)sub_8089994;\n  if ( (v7 & 0x8000) != 0 )\n  {\n    putenv(\"TAR_FILETYPE=f\");\n    signal(13, (__sighandler_t)1);\n    v2[9] = (unsigned int)sub_8089805;\n    v10 = (const char *)sub_80AB879();\n    v2[18] = (unsigned int)sub_804DB46(v10);\n  }\n  if ( (v7 & 0x100) != 0 )\n    *v2 &= ~4u;\n  if ( (v7 & 0x10000) != 0 )\n    *v2 |= 0x40u;\n  if ( (v7 & 0x20) != 0 )\n    *v2 |= 0x10u;\n  if ( (v7 & 0x20000) != 0 )\n    *v2 |= 0x20u;\n  if ( (v7 & 0x40000) != 0 )\n  {\n    v11 = *v2 & 0xFFFFFFFB;\n    LOBYTE(v11) = *(_BYTE *)v2 & 0x7B | 0x80;\n    *v2 = v11;\n  }\n  v2[4] = sub_8087FFB(v2[4]);\n  v12 = (_DWORD *)v24[0];\n  v13 = 0;\n  while ( v12 )\n  {\n    v14 = (_DWORD *)*v12;\n    *v12 = v2[4];\n    v2[4] = (unsigned int)v12;\n    v13 = 1;\n    v12 = v14;\n  }\n  if ( v13 )\n    v24[0] = 0;\n  v2[3] = sub_8087FFB(v2[3]);\n  while ( *v8 )\n  {\n    v15 = sub_804D378(*v8, 47);\n    if ( *v8 < v15 )\n      *v15 = 0;\n    sub_80AFADF(v16, *v8++);\n  }\n  v17 = v2[3];\n  if ( v17 || v2[4] )\n    v2[2] = (unsigned int)sub_808D827;\n  if ( (v7 & 0x200) != 0 )\n  {\n    if ( !v17 )\n      sub_804D5E0(\"empty archive\");\n    v18 = 1;\n  }\n  else\n  {\n    v18 = 0;\n  }\n  if ( *v22 != 45 || v22[1] )\n  {\n    v2[1] = sub_804DBE1(v22);\n  }\n  else\n  {\n    v2[1] = v18;\n    v2[10] = (unsigned int)sub_808EF81;\n  }\n  if ( v21 )\n    sub_804DF04(v21);\n  if ( (v7 & 0x200) != 0 )\n  {\n    v19 = (int *)sub_804DB2E(0x74u);\n    *v19 = v2[1];\n    v19[1] = v23;\n    v19[2] = v2[4];\n    return sub_808805F(v19, (_DWORD *)v2[3]);\n  }\n  else\n  {\n    byte_80DBBA4 = 1;\n    while ( !(unsigned __int8)sub_808DCAD() )\n      byte_80DBBA4 = 0;\n    sub_808F0AE();\n    while ( v2[3] )\n    {\n      if ( !sub_808D85A() && !sub_808D85A() )\n        sub_804D5E0(\"%s: not found in archive\", *(const char **)(v2[3] + 4));\n      v2[3] = *(_DWORD *)v2[3];\n    }\n    return byte_80DBBA4;\n  }\n}\n"
        ],
        "134777484": [
            "sub_8088A8C",
            "0x8088a8c",
            "int __usercall sub_8088A8C@<eax>(const char *a1@<eax>)\n{\n  int result; // eax\n  _DWORD v3[25]; // [esp+0h] [ebp-64h] BYREF\n\n  result = lstat64(a1, v3);\n  if ( result != -1 )\n    return v3[4];\n  if ( *(_DWORD *)dword_80DBB7C != 2 )\n    sub_804D3C9((int)\"can't stat '%s'\", a1);\n  return result;\n}\n"
        ],
        "134777535": [
            "sub_8088ABF",
            "0x8088abf",
            "int __usercall sub_8088ABF@<eax>(const char *a1@<eax>)\n{\n  char *v1; // ebx\n  int v3; // [esp-4h] [ebp-8h]\n\n  v1 = sub_804DB46(a1);\n  dirname(v1);\n  if ( sub_80B00B9(4, -1) )\n    sub_804D604();\n  free(v1);\n  return v3;\n}\n"
        ],
        "134777581": [
            "sub_8088AED",
            "0x8088aed",
            "decompilation failure at 8088AED!\n"
        ],
        "134777631": [
            "sub_8088B1F",
            "0x8088b1f",
            "decompilation failure at 8088B1F!\n"
        ],
        "134777672": [
            "sub_8088B48",
            "0x8088b48",
            "decompilation failure at 8088B48!\n"
        ],
        "134780178": [
            "sub_8089512",
            "0x8089512",
            "decompilation failure at 8089512!\n"
        ],
        "134780916": [
            "sub_80897F4",
            "0x80897f4",
            "decompilation failure at 80897F4!\n"
        ],
        "134780933": [
            "sub_8089805",
            "0x8089805",
            "decompilation failure at 8089805!\n"
        ],
        "134781332": [
            "sub_8089994",
            "0x8089994",
            "decompilation failure at 8089994!\n"
        ],
        "134781357": [
            "sub_80899AD",
            "0x80899ad",
            "int __usercall sub_80899AD@<eax>(int a1@<eax>)\n{\n  return (*(int (__fastcall **)(_DWORD, _DWORD))(a1 + 40))(\n           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 12),\n           *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8));\n}\n"
        ],
        "134781377": [
            "sub_80899C1",
            "0x80899c1",
            "decompilation failure at 80899C1!\n"
        ],
        "134781542": [
            "sub_8089A66",
            "0x8089a66",
            "int __usercall sub_8089A66@<eax>(\n        int *a1@<eax>,\n        int a2@<ecx>,\n        int a3,\n        int a4,\n        unsigned int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10,\n        int a11,\n        int a12,\n        int a13,\n        int a14,\n        int a15,\n        int a16,\n        int a17,\n        int a18,\n        int a19,\n        int a20,\n        int a21,\n        int a22,\n        int a23,\n        int a24,\n        int a25,\n        int a26,\n        int a27,\n        int a28,\n        int a29,\n        int a30,\n        int a31,\n        int a32,\n        int a33,\n        int a34,\n        int a35,\n        int a36,\n        int a37,\n        int a38)\n{\n  int v39; // esi\n  int v40; // ecx\n  int v41; // edi\n  int v42; // ecx\n  int v43; // ecx\n  int v44; // edx\n  int v45; // eax\n  int v46; // ecx\n  int v47; // ecx\n  char *v48; // ecx\n  __int16 v49; // di\n  int i; // esi\n  __int16 v51; // ax\n  int v52; // ecx\n  int j; // eax\n  int v54; // ecx\n  int v55; // edi\n  int v56; // esi\n  char v57; // al\n  _DWORD *v58; // esi\n  int v59; // ecx\n  unsigned int v60; // edi\n  int v61; // ebp\n  int v62; // eax\n  unsigned int *v63; // edx\n  int v64; // eax\n  int v65; // ecx\n  int v66; // edx\n  int v67; // edi\n  int v68; // ecx\n  int v69; // edx\n  int v70; // edi\n  int v71; // edx\n  int v72; // edx\n  int k; // eax\n  unsigned int v74; // esi\n  unsigned int v75; // ebp\n  int v76; // eax\n  int v77; // eax\n  int v78; // edx\n  int v79; // ecx\n  int v80; // ecx\n  int v81; // eax\n  int v82; // edx\n  int m; // edi\n  int v84; // ecx\n  unsigned int v85; // eax\n  int v86; // ecx\n  int v87; // eax\n  int v88; // eax\n  int v89; // ecx\n  int v90; // eax\n  unsigned int v91; // edx\n  int n; // eax\n  unsigned int v93; // ecx\n  unsigned int ii; // eax\n  int v95; // ecx\n  int v96; // edx\n  unsigned int v97; // edx\n  char *retaddr; // [esp+6A0h] [ebp+0h]\n  int v100; // [esp+6A4h] [ebp+4h]\n  int v101; // [esp+6A4h] [ebp+4h]\n  int v102; // [esp+6A8h] [ebp+8h]\n  int v103; // [esp+6B0h] [ebp+10h]\n  int v104; // [esp+6B0h] [ebp+10h]\n  int v105; // [esp+6B4h] [ebp+14h]\n  int v106; // [esp+6B4h] [ebp+14h]\n  int v107; // [esp+6B8h] [ebp+18h]\n  char *v108; // [esp+6BCh] [ebp+1Ch]\n  unsigned int v109; // [esp+6BCh] [ebp+1Ch]\n  unsigned int v110; // [esp+6C0h] [ebp+20h]\n  int v111; // [esp+6C4h] [ebp+24h]\n  _DWORD *v112; // [esp+6C8h] [ebp+28h]\n  _DWORD *v113; // [esp+6CCh] [ebp+2Ch]\n  int v114; // [esp+6CCh] [ebp+2Ch]\n  int v115; // [esp+6D0h] [ebp+30h]\n  int v116; // [esp+6D4h] [ebp+34h]\n\n  v102 = a1[15];\n  v112 = a1 + 274;\n  v39 = sub_80899C1(a2, 24);\n  v41 = sub_80899C1(v40, 24);\n  a1[12] = sub_80899C1(v42, 32);\n  if ( v39 == 1536581 )\n    return (v41 == 3690640) - 2;\n  if ( v41 != 2511705 || v39 != 3227993 )\n    return -2;\n  v45 = sub_80899C1(v43, 1);\n  v44 = -7;\n  if ( !v45 )\n  {\n    v110 = sub_80899C1(v46, 24);\n    if ( a1[16] < v110 )\n      return -5;\n    v49 = sub_80899C1(v47, 16);\n    retaddr = 0;\n    for ( i = 0; i <= 255; i += 16 )\n    {\n      if ( (v49 & 0x8000) != 0 )\n      {\n        v51 = sub_80899C1(v48, 16);\n        while ( 1 )\n        {\n          if ( (v51 & 0x8000) != 0 )\n          {\n            *((_BYTE *)&a38 + (_DWORD)retaddr) = i;\n            v48 = ++retaddr;\n          }\n          v51 *= 2;\n          if ( (((_BYTE)i + 1) & 0xF) == 0 )\n            break;\n          ++i;\n        }\n        i -= 15;\n      }\n      v49 *= 2;\n    }\n    v103 = sub_80899C1(v48, 3);\n    if ( (unsigned int)(v103 - 2) > 4 )\n      return -5;\n    for ( j = 0; j != v103; ++j )\n      *((_BYTE *)&STACK[0x830] + j) = j;\n    v111 = sub_80899C1(v52, 15);\n    v55 = 0;\n    if ( !v111 )\n      return -5;\n    while ( v55 < v111 )\n    {\n      v56 = 0;\n      while ( sub_80899C1(v54, 1) )\n      {\n        if ( v56 == v103 )\n          return -5;\n        ++v56;\n      }\n      v57 = *((_BYTE *)&STACK[0x830] + v56);\n      while ( --v56 != -1 )\n        *((_BYTE *)&STACK[0x831] + v56) = *((_BYTE *)&STACK[0x830] + v56);\n      *((_BYTE *)v112 + v55) = v57;\n      LOBYTE(STACK[0x830]) = v57;\n      ++v55;\n    }\n    v108 = retaddr + 2;\n    v58 = a1 + 8465;\n    v107 = 0;\nLABEL_32:\n    if ( v107 != v103 )\n    {\n      v60 = sub_80899C1(v54, 5) - 1;\n      v61 = 1;\n      while ( v60 <= 0x13 )\n      {\n        v62 = sub_80899C1(v59, 2);\n        if ( v62 > 1 )\n        {\n          v60 = v60 + (((_BYTE)v62 + 1) & 2) - 1;\n        }\n        else\n        {\n          ++*a1;\n          *((_BYTE *)&STACK[0x92F] + v61++) = v60 + 1;\n          if ( retaddr + 3 == (char *)v61 )\n          {\n            v100 = LOBYTE(STACK[0x930]);\n            v63 = &STACK[0x930];\n            v64 = v100;\n            do\n            {\n              v65 = *((unsigned __int8 *)v63 + 1);\n              if ( v65 > v64 )\n              {\n                v64 = *((unsigned __int8 *)v63 + 1);\n              }\n              else if ( v100 > v65 )\n              {\n                v100 = *((unsigned __int8 *)v63 + 1);\n              }\n              v63 = (unsigned int *)((char *)v63 + 1);\n            }\n            while ( (unsigned int *)((char *)&STACK[0x931] + (_DWORD)retaddr) != v63 );\n            v58[300] = v100;\n            v58[301] = v64;\n            v113 = v58 + 21;\n            v66 = v100;\n            v67 = 0;\n            while ( v66 <= v64 )\n            {\n              v58[v66] = 0;\n              *(&a17 + v66) = 0;\n              v68 = 0;\n              do\n              {\n                if ( *((unsigned __int8 *)&STACK[0x930] + v68) == v66 )\n                  v58[v67++ + 42] = v68;\n                ++v68;\n              }\n              while ( (int)v108 > v68 );\n              ++v66;\n            }\n            v69 = 0;\n            do\n              ++*(&a17 + *((unsigned __int8 *)&STACK[0x930] + v69++));\n            while ( (int)v108 > v69 );\n            v105 = 0;\n            v70 = v100;\n            v71 = 0;\n            while ( v70 < v64 )\n            {\n              v72 = *(&a17 + v70) + v71;\n              v58[v70] = (v72 << (v64 - v70)) - 1;\n              v71 = 2 * v72;\n              v105 += *(&a17 + v70++);\n              v113[v70] = v71 - v105;\n            }\n            v54 = *(&a17 + v64);\n            v58[v64] = v71 + v54 - 1;\n            v58[v64 + 1] = 0x7FFFFFFF;\n            v113[v100] = 0;\n            ++v107;\n            v58 += 301;\n            goto LABEL_32;\n          }\n        }\n      }\n      return -5;\n    }\n    for ( k = 0; k != 256; ++k )\n    {\n      *(&STACK[0x930] + k) = 0;\n      *((_BYTE *)&STACK[0x830] + k) = k;\n    }\n    v74 = 0;\n    v75 = 0;\n    v104 = 0;\nLABEL_60:\n    if ( v104 >= v111 )\n      return -5;\n    v76 = *((unsigned __int8 *)v112 + v104++);\n    if ( v76 >= v107 )\n      return -5;\n    v101 = (int)&a1[301 * v76 + 8466];\n    v115 = (int)&a1[301 * v76 + 8486];\n    v116 = (int)&a1[301 * v76 + 8465];\n    v109 = v74;\n    v114 = 49;\n    while ( 1 )\n    {\n      v77 = *a1;\n      v78 = *(_DWORD *)(v101 + 1200);\n      v79 = *a1 - v78;\n      if ( v79 >= 0 )\n      {\n        *a1 = v79;\n        v81 = ((1 << v78) - 1) & ((unsigned int)a1[1] >> v79);\n      }\n      else\n      {\n        v80 = a1[5];\n        if ( v80 != a1[4] )\n        {\n          v82 = a1[1] << 8;\n          a1[5] = v80 + 1;\n          a1[1] = *(unsigned __int8 *)(a1[6] + v80) | v82;\n          *a1 = v77 + 8;\n          goto LABEL_67;\n        }\n        v81 = sub_80899C1(v80, v78);\n      }\n      v106 = *(_DWORD *)(v101 + 1196);\n      for ( m = 4 * v106; *(_DWORD *)(v116 + m) < v81; m += 4 )\n        ++v106;\n      v84 = *(_DWORD *)(v101 + 1200) - v106;\n      if ( v84 < 0 )\n        return -5;\n      *a1 += v84;\n      v85 = (v81 >> v84) - *(_DWORD *)(v115 + m);\n      if ( v85 > 0x101 )\n        return -5;\n      v86 = *(_DWORD *)(v101 + 4 * v85 + 164);\n      if ( (unsigned int)v86 > 1 )\n      {\n        if ( v74 )\n        {\n          if ( v75 + a5 > a1[16] )\n            return -5;\n          v87 = *((unsigned __int8 *)&a38 + LOBYTE(STACK[0x830]));\n          *(&STACK[0x930] + v87) += a5;\n          while ( (--a5 & 0x80000000) == 0 )\n          {\n            ++v75;\n            *(_DWORD *)(v102 + 4 * v75 - 4) = v87;\n          }\n        }\n        if ( (int)retaddr < v86 )\n        {\n          v91 = 0;\n          for ( n = 0; n != 256; ++n )\n          {\n            v93 = v91 + *(&STACK[0x930] + n);\n            *(&STACK[0x930] + n) = v91;\n            v91 = v93;\n          }\n          for ( ii = 0; ii != v75; ++ii )\n          {\n            v95 = *(unsigned __int8 *)(v102 + 4 * ii);\n            v96 = *(&STACK[0x930] + v95);\n            *(_DWORD *)(v102 + 4 * v96) |= ii << 8;\n            *(&STACK[0x930] + v95) = v96 + 1;\n          }\n          if ( ii )\n          {\n            if ( ii > v110 )\n            {\n              v97 = *(_DWORD *)(v102 + 4 * v110);\n              a1[11] = (unsigned __int8)v97;\n              a1[8] = v97 >> 8;\n              a1[9] = 5;\n              goto LABEL_100;\n            }\n            return -5;\n          }\nLABEL_100:\n          a1[10] = ii;\n          return 0;\n        }\n        if ( a1[16] <= v75 )\n          return -5;\n        v88 = *((unsigned __int8 *)&STACK[0x82F] + v86);\n        v89 = v86 - 1;\n        do\n        {\n          --v89;\n          *((_BYTE *)&STACK[0x831] + v89) = *((_BYTE *)&STACK[0x830] + v89);\n        }\n        while ( v89 );\n        LOBYTE(STACK[0x830]) = v88;\n        v90 = *((unsigned __int8 *)&a38 + v88);\n        ++*(&STACK[0x930] + v90);\n        *(_DWORD *)(v102 + 4 * v75) = v90;\n        v74 = 0;\n        ++v75;\n      }\n      else\n      {\n        if ( v74 )\n          v109 = a5;\n        else\n          v74 = 1;\n        a5 = v109 + (v74 << v86);\n        if ( a1[16] > v74 )\n          v74 *= 2;\n      }\n      if ( --v114 < 0 )\n        goto LABEL_60;\nLABEL_67:\n      v109 = v74;\n    }\n  }\n  return v44;\n}\n"
        ],
        "134783042": [
            "sub_808A042",
            "0x808a042",
            "decompilation failure at 808A042!\n"
        ],
        "134783280": [
            "sub_808A130",
            "0x808a130",
            "decompilation failure at 808A130!\n"
        ],
        "134783460": [
            "sub_808A1E4",
            "0x808a1e4",
            "decompilation failure at 808A1E4!\n"
        ],
        "134783481": [
            "sub_808A1F9",
            "0x808a1f9",
            "decompilation failure at 808A1F9!\n"
        ],
        "134783878": [
            "sub_808A386",
            "0x808a386",
            "decompilation failure at 808A386!\n"
        ],
        "134783902": [
            "sub_808A39E",
            "0x808a39e",
            "int __usercall sub_808A39E@<eax>(\n        int a1@<eax>,\n        unsigned int a2@<edx>,\n        unsigned int a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        char *a10,\n        int a11,\n        int a12,\n        int a13,\n        int a14,\n        int a15,\n        unsigned int a16,\n        int a17,\n        int a18,\n        int a19,\n        int a20,\n        int a21,\n        int a22,\n        int a23,\n        int a24,\n        int a25,\n        int a26,\n        int a27,\n        int a28,\n        int a29,\n        int a30,\n        int a31,\n        int a32,\n        int a33,\n        int a34,\n        int a35,\n        int a36,\n        int a37,\n        int a38,\n        int a39,\n        int a40,\n        int a41,\n        int a42,\n        int a43,\n        int a44,\n        int a45,\n        int a46,\n        int a47,\n        int a48,\n        int a49,\n        int a50,\n        int a51,\n        int a52,\n        int a53,\n        int a54,\n        int a55,\n        int a56,\n        int a57,\n        int a58,\n        int a59,\n        int a60,\n        int a61,\n        int a62,\n        int a63)\n{\n  int v66; // esi\n  _WORD *v67; // eax\n  int result; // eax\n  unsigned int i; // ecx\n  int v70; // edx\n  unsigned int v71; // edi\n  int v72; // eax\n  int v73; // edi\n  int v74; // eax\n  int v75; // eax\n  unsigned int k; // edx\n  unsigned int v77; // eax\n  int v78; // edx\n  int v79; // ecx\n  int v80; // ebx\n  char *v81; // edx\n  int v82; // ebp\n  int v83; // edi\n  unsigned int v84; // esi\n  char *v85; // edx\n  unsigned int v86; // ebx\n  unsigned int v87; // eax\n  unsigned int v88; // eax\n  int *v89; // ecx\n  unsigned int v90; // eax\n  unsigned int v91; // ebp\n  char *v92; // eax\n  _DWORD *v93; // ecx\n  int v94; // ebx\n  unsigned int v95; // ecx\n  char v96; // si\n  int v97; // ecx\n  unsigned int m; // ecx\n  int v99; // eax\n  unsigned int n; // ecx\n  int v101; // esi\n  int j; // [esp+5D8h] [ebp+0h]\n  int v103; // [esp+5DCh] [ebp+4h]\n  unsigned int v104; // [esp+5E4h] [ebp+Ch]\n  unsigned int v105; // [esp+5E8h] [ebp+10h]\n  unsigned int v106; // [esp+5ECh] [ebp+14h]\n  unsigned int v107; // [esp+5F0h] [ebp+18h]\n  unsigned int *v108; // [esp+5F8h] [ebp+20h]\n  int v110; // [esp+608h] [ebp+30h]\n\n  v106 = 16;\n  if ( a2 > 0x100 )\n    v106 = *(_DWORD *)(a1 + 1024);\n  *(_DWORD *)STACK[0xBBC] = 0;\n  memset(&a33, 0, 0x44u);\n  v66 = 0;\n  do\n    ++*(&a33 + *(_DWORD *)(a1 + 4 * v66++));\n  while ( v66 != a2 );\n  if ( a33 == v66 )\n  {\n    v67 = sub_804DB2E(0x18u);\n    v67[4] = 355;\n    v67[8] = 355;\n    *(_DWORD *)STACK[0xBBC] = v67 + 4;\n    *(_DWORD *)STACK[0xBC0] = 1;\n    return 0;\n  }\n  else\n  {\n    for ( i = 1; i != 17; ++i )\n    {\n      if ( *(&a33 + i) )\n        break;\n    }\n    v103 = i;\n    for ( j = 16; ; --j )\n    {\n      v70 = *(&a33 + j);\n      if ( v70 )\n        break;\n      if ( !j )\n      {\n        v70 = 0;\n        break;\n      }\n    }\n    v71 = *(_DWORD *)STACK[0xBC0];\n    v72 = i;\n    if ( v71 >= i )\n    {\n      v72 = j;\n      if ( j > v71 )\n        v72 = *(_DWORD *)STACK[0xBC0];\n    }\n    *(_DWORD *)STACK[0xBC0] = v72;\n    v73 = 1 << i;\n    while ( j > i )\n    {\n      v74 = v73 - *(&a33 + i);\n      if ( v74 < 0 )\n        return 2;\n      ++i;\n      v73 = 2 * v74;\n    }\n    result = 2;\n    v110 = v73 - v70;\n    if ( v73 - v70 >= 0 )\n    {\n      *(&a33 + j) = v73;\n      STACK[0x6DC] = 0;\n      v75 = 0;\n      for ( k = 0; j != ++v75; *(&STACK[0x6DC] + v75) = k )\n        k += *(&a33 + v75);\n      memset(&STACK[0x71C], 255, 0x484u);\n      v77 = 0;\n      do\n      {\n        v78 = *(_DWORD *)(a1 + 4 * v77);\n        if ( v78 )\n        {\n          v79 = *(&a65 + v78);\n          *(&a65 + v78) = v79 + 1;\n          *(&STACK[0x71C] + v79) = v77;\n        }\n        ++v77;\n      }\n      while ( v66 != v77 );\n      a65 = 0;\n      a50 = 0;\n      a17 = 0;\n      v107 = 0;\n      LOBYTE(v80) = 0;\n      v81 = 0;\n      v108 = &STACK[0x71C];\n      v104 = 0;\n      v82 = -1;\n      while ( v103 <= j )\n      {\n        v105 = *(&a33 + v103);\n        a16 = 1 << (v103 - 1);\n        while ( v105 )\n        {\n          while ( 1 )\n          {\n            v83 = v82 + 1;\n            v84 = *(&a50 + v82 + 1);\n            if ( (int)v84 >= v103 )\n              break;\n            v85 = *(char **)STACK[0xBC0];\n            if ( (unsigned int)v85 > j - v84 )\n              v85 = (char *)(j - v84);\n            v86 = v103 - v84;\n            v87 = 1 << (v103 - v84);\n            if ( v105 < v87 )\n            {\n              v88 = v87 - v105;\n              v89 = &a33 + v103 - v86;\n              while ( (unsigned int)v85 > ++v86 )\n              {\n                v90 = 2 * v88;\n                v91 = v89[v86];\n                if ( v91 >= v90 )\n                  break;\n                v88 = v90 - v91;\n              }\n            }\n            if ( v84 + v86 > v106 && v84 < v106 )\n              v86 = v106 - v84;\n            v107 = 1 << v86;\n            *(&a51 + v83) = v84 + v86;\n            v92 = (char *)sub_804DB2E(8 * (1 << v86) + 8);\n            v81 = v92 + 8;\n            *(_DWORD *)STACK[0xBBC] = v92 + 8;\n            STACK[0xBBC] = (unsigned int)(v92 + 4);\n            *(&a17 + v83) = (int)(v92 + 8);\n            if ( v83 )\n            {\n              *(&a65 + v83) = v104;\n              a10 = v92 + 8;\n              v93 = (_DWORD *)(*(&a16 + v83) + 8 * ((v104 & ((1 << v84) - 1)) >> *((_BYTE *)&a49 + 4 * v83)));\n              LOBYTE(a5) = v86 + 16;\n              v94 = a5;\n              BYTE1(v94) = v84 - *((_BYTE *)&a49 + 4 * v83);\n              a5 = v94;\n              *v93 = v94;\n              v93[1] = v81;\n            }\n            LOBYTE(v80) = v84;\n            v82 = v83;\n          }\n          v95 = *v108;\n          v96 = 99;\n          if ( *v108 != -1 )\n          {\n            ++v108;\n            if ( v95 >= a3 )\n            {\n              v97 = v95 - a3;\n              v96 = *(_BYTE *)(STACK[0xBB8] + v97);\n              LOWORD(a10) = *(_WORD *)(STACK[0xBB4] + 2 * v97);\n            }\n            else\n            {\n              v96 = (v95 != 256) + 15;\n              LOWORD(a10) = v95;\n            }\n          }\n          for ( m = v104 >> v80; m < v107; m += 1 << (v103 - v80) )\n          {\n            LOBYTE(a5) = v96;\n            v99 = a5;\n            BYTE1(v99) = v103 - v80;\n            a5 = v99;\n            *(_DWORD *)&v81[8 * m] = v99;\n            *(_DWORD *)&v81[8 * m + 4] = a10;\n          }\n          for ( n = a16; ; n >>= 1 )\n          {\n            v101 = n & v104;\n            v104 ^= n;\n            if ( !v101 )\n              break;\n          }\n          --v105;\n          while ( (v104 & ((1 << v80) - 1)) != *(&a65 + v82) )\n          {\n            --v82;\n            v80 = *(&a50 + v82);\n          }\n        }\n        ++v103;\n      }\n      *(_DWORD *)STACK[0xBC0] = a51;\n      return j != 1 && v110 != 0;\n    }\n  }\n  return result;\n}\n"
        ],
        "134784950": [
            "sub_808A7B6",
            "0x808a7b6",
            "decompilation failure at 808A7B6!\n"
        ],
        "134784994": [
            "sub_808A7E2",
            "0x808a7e2",
            "int __usercall sub_808A7E2@<eax>(\n        int *a1@<eax>,\n        int a2@<edx>,\n        unsigned int *a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        unsigned int a9)\n{\n  size_t v12; // ecx\n  ssize_t v13; // eax\n  int v14; // eax\n  ssize_t retaddr; // [esp+14h] [ebp+0h]\n\n  while ( *a3 < a9 )\n  {\n    if ( a1[12] >= (unsigned int)a1[13] )\n    {\n      v12 = a1[10];\n      if ( *((_QWORD *)a1 + 5) > 0x3FFBuLL )\n        v12 = 16380;\n      v13 = sub_804E5BC(v12, (void *)(a1[9] + 4), a1[3]);\n      a1[13] = v13;\n      if ( v13 <= 0 )\n      {\n        a1[30] = (int)\"unexpected end of file\";\n        sub_808A7B6();\n      }\n      if ( a1[11] >= 0 )\n      {\n        retaddr = v13;\n        *((_QWORD *)a1 + 5) -= (unsigned int)v13;\n      }\n      a1[13] = v13 + 4;\n      a1[12] = 4;\n    }\n    v14 = a1[12];\n    a2 |= *(unsigned __int8 *)(a1[9] + v14) << *a3;\n    a1[12] = v14 + 1;\n    *a3 += 8;\n  }\n  return a2;\n}\n"
        ],
        "134785167": [
            "sub_808A88F",
            "0x808a88f",
            "decompilation failure at 808A88F!\n"
        ],
        "134785274": [
            "sub_808A8FA",
            "0x808a8fa",
            "decompilation failure at 808A8FA!\n"
        ],
        "134786623": [
            "sub_808AE3F",
            "0x808ae3f",
            "decompilation failure at 808AE3F!\n"
        ],
        "134787251": [
            "sub_808B0B3",
            "0x808b0b3",
            "decompilation failure at 808B0B3!\n"
        ],
        "134787855": [
            "sub_808B30F",
            "0x808b30f",
            "decompilation failure at 808B30F!\n"
        ],
        "134787972": [
            "sub_808B384",
            "0x808b384",
            "decompilation failure at 808B384!\n"
        ],
        "134788548": [
            "sub_808B5C4",
            "0x808b5c4",
            "decompilation failure at 808B5C4!\n"
        ],
        "134788631": [
            "sub_808B617",
            "0x808b617",
            "int __usercall sub_808B617@<eax>(_DWORD *a1@<eax>, _WORD *a2@<edx>)\n{\n  int v4; // edi\n  unsigned int v5; // ebp\n  unsigned int v6; // eax\n  unsigned int v7; // ecx\n\n  if ( a1[4] <= 0xFFFFFFu )\n    sub_808B5C4();\n  v4 = (unsigned __int16)*a2;\n  v5 = a1[4];\n  v6 = v4 * (v5 >> 11);\n  a1[5] = v6;\n  v7 = a1[3];\n  if ( v6 <= v7 )\n  {\n    a1[4] = v5 - v6;\n    a1[3] = v7 - v6;\n    *a2 = v4 - ((unsigned __int16)v4 >> 5);\n    return 1;\n  }\n  else\n  {\n    a1[4] = v6;\n    *a2 = v4 + ((2048 - v4) >> 5);\n    return 0;\n  }\n}\n"
        ],
        "134788732": [
            "sub_808B67C",
            "0x808b67c",
            "decompilation failure at 808B67C!\n"
        ],
        "134790243": [
            "sub_808BC63",
            "0x808bc63",
            "decompilation failure at 808BC63!\n"
        ],
        "134790344": [
            "sub_808BCC8",
            "0x808bcc8",
            "_DWORD *__usercall sub_808BCC8@<eax>(_DWORD *result@<eax>, unsigned __int16 *a2@<edx>, int a3@<ecx>)\n{\n  int v3; // esi\n  int v4; // ebx\n  int v5; // ecx\n  int v6; // ebp\n  unsigned int v7; // edi\n  unsigned int v8; // ebx\n  unsigned int v9; // ecx\n  unsigned int v10; // ebx\n  int v11; // esi\n  int v12; // ecx\n  int v13; // ebp\n  unsigned int v14; // ebx\n  unsigned int v15; // esi\n  unsigned int v16; // ebp\n  unsigned int v17; // edx\n  int v18; // ecx\n  int v19; // esi\n  int v20; // ebx\n  int v21; // ecx\n  unsigned int v22; // ebx\n  unsigned int v23; // esi\n  _WORD *v25; // [esp+20h] [ebp+4h]\n\n  v3 = result[1];\n  if ( *result <= 0xFFFFFFu )\n  {\n    *result <<= 8;\n    v4 = result[3];\n    v5 = result[4];\n    result[4] = v5 + 1;\n    result[1] = *(unsigned __int8 *)(v4 + v5) + (v3 << 8);\n  }\n  v6 = *a2;\n  v7 = v6 * (*result >> 11);\n  v8 = result[1];\n  if ( v7 <= v8 )\n  {\n    v9 = *result - v7;\n    *result = v9;\n    v10 = v8 - v7;\n    result[1] = v10;\n    *a2 = v6 - ((unsigned __int16)v6 >> 5);\n    if ( v9 <= 0xFFFFFF )\n    {\n      *result = v9 << 8;\n      v11 = result[3];\n      v12 = result[4];\n      result[4] = v12 + 1;\n      result[1] = *(unsigned __int8 *)(v11 + v12) + (v10 << 8);\n    }\n    v13 = a2[1];\n    v14 = v13 * (*result >> 11);\n    v15 = result[1];\n    if ( v14 <= v15 )\n    {\n      *result -= v14;\n      result[1] = v15 - v14;\n      a2[1] = v13 - ((unsigned __int16)v13 >> 5);\n      a3 = (int)(a2 + 258);\n      result[26] = 18;\n      v16 = 256;\n      goto LABEL_11;\n    }\n    *result = v14;\n    a2[1] = ((2048 - v13) >> 5) + v13;\n    a3 = (int)&a2[8 * a3 + 130];\n    result[26] = 10;\n  }\n  else\n  {\n    *result = v7;\n    *a2 = ((2048 - v6) >> 5) + v6;\n    a3 = (int)&a2[8 * a3 + 2];\n    result[26] = 2;\n  }\n  v16 = 8;\nLABEL_11:\n  v17 = 1;\n  do\n  {\n    v25 = (_WORD *)(a3 + 2 * v17);\n    v18 = result[1];\n    if ( *result <= 0xFFFFFFu )\n    {\n      *result <<= 8;\n      v19 = result[3];\n      v20 = result[4];\n      result[4] = v20 + 1;\n      result[1] = *(unsigned __int8 *)(v19 + v20) + (v18 << 8);\n    }\n    v21 = (unsigned __int16)*v25;\n    v22 = v21 * (*result >> 11);\n    v23 = result[1];\n    v17 *= 2;\n    if ( v22 <= v23 )\n    {\n      *result -= v22;\n      result[1] = v23 - v22;\n      *v25 = v21 - ((unsigned __int16)v21 >> 5);\n      ++v17;\n    }\n    else\n    {\n      *result = v22;\n      *v25 = ((2048 - v21) >> 5) + v21;\n    }\n  }\n  while ( v16 > v17 );\n  result[26] = result[26] - v16 + v17;\n  return result;\n}\n"
        ],
        "134790794": [
            "sub_808BE8A",
            "0x808be8a",
            "char __usercall sub_808BE8A@<al>(int a1@<eax>)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // eax\n  unsigned int v5; // edx\n  int v6; // ecx\n  int v7; // esi\n  int v8; // ebp\n  int v9; // esi\n  unsigned int v10; // edi\n  unsigned int v11; // ecx\n  int v12; // ecx\n  int v13; // ebp\n  unsigned int v14; // esi\n  unsigned int v15; // ebp\n  _WORD *v16; // ecx\n  int v17; // eax\n  int v18; // esi\n  int v19; // edx\n  unsigned int v20; // eax\n  unsigned int v21; // edx\n  unsigned int v22; // esi\n  int v23; // edx\n  int v24; // eax\n  unsigned int v25; // eax\n  unsigned int v26; // eax\n  unsigned int v27; // eax\n  unsigned int v28; // esi\n  unsigned int v29; // ecx\n  unsigned int v30; // edx\n  int v31; // eax\n  int v32; // edi\n  int v33; // eax\n  int v34; // ecx\n  int v35; // edx\n  int v36; // eax\n  unsigned int v37; // edx\n  unsigned int v38; // ecx\n  unsigned int v39; // eax\n  unsigned int v40; // edx\n  unsigned int v41; // ecx\n  int v42; // edx\n  int v43; // eax\n  unsigned __int16 *v44; // eax\n  int v45; // esi\n  unsigned int v46; // edi\n  unsigned int v47; // ecx\n  unsigned int v48; // eax\n  unsigned int v49; // eax\n  _WORD *v50; // edx\n  int v51; // ecx\n  int v52; // edi\n  int v53; // esi\n  unsigned int v54; // ecx\n  unsigned int v55; // esi\n  unsigned int v56; // edi\n  unsigned int v57; // eax\n  int v58; // edx\n  int v59; // edx\n  int v60; // ebp\n  _WORD *v61; // edi\n  int v62; // eax\n  int v63; // ecx\n  int v64; // edx\n  int v65; // eax\n  unsigned int v66; // edx\n  int v67; // ecx\n  int v68; // edx\n  int v69; // eax\n  int v70; // eax\n  int v71; // edx\n  int v72; // eax\n  int v73; // eax\n  _WORD *v74; // ebp\n  int v75; // edx\n  int v76; // esi\n  int v77; // ecx\n  int v78; // edx\n  unsigned int v79; // ecx\n  unsigned int v80; // edx\n  unsigned int v81; // ecx\n  int v82; // esi\n  int v83; // edx\n  int v84; // edi\n  unsigned int v85; // ecx\n  unsigned int v86; // edx\n  int v87; // ecx\n  int v88; // eax\n  unsigned int v89; // esi\n  unsigned int v90; // edx\n  int v91; // esi\n  int v92; // ecx\n  int v93; // edi\n  unsigned int v94; // edx\n  unsigned int v95; // ecx\n  int v96; // ebp\n  unsigned int v97; // edi\n  unsigned int v98; // ecx\n  unsigned int v99; // ecx\n  int v100; // esi\n  int v101; // edx\n  int v102; // edx\n  unsigned int v103; // ecx\n  unsigned int v104; // esi\n  unsigned int v105; // ebp\n  unsigned int v106; // eax\n  char result; // al\n  unsigned int retaddr; // [esp+2Ch] [ebp+0h]\n  int v109; // [esp+30h] [ebp+4h]\n  unsigned int v110; // [esp+30h] [ebp+4h]\n  int v111; // [esp+30h] [ebp+4h]\n  unsigned int v112; // [esp+30h] [ebp+4h]\n  unsigned int v113; // [esp+30h] [ebp+4h]\n  _WORD *v114; // [esp+34h] [ebp+8h]\n  unsigned int v115; // [esp+34h] [ebp+8h]\n  unsigned int v116; // [esp+34h] [ebp+8h]\n  int v117; // [esp+38h] [ebp+Ch]\n  int v118; // [esp+3Ch] [ebp+10h]\n  int v119; // [esp+40h] [ebp+14h]\n  int v120; // [esp+44h] [ebp+18h]\n\n  if ( *(_DWORD *)(a1 + 40) > *(_DWORD *)(a1 + 32) )\n  {\n    if ( *(_DWORD *)(a1 + 104) )\n      sub_808BC63(*(_DWORD *)(a1 + 84), a1 + 104);\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v27 = *(_DWORD *)(a1 + 32);\n        v28 = *(_DWORD *)a1;\n        if ( v27 >= *(_DWORD *)(a1 + 40) )\n          goto LABEL_2;\n        v5 = *(_DWORD *)(a1 + 16);\n        if ( v5 > *(_DWORD *)(a1 + 20) )\n          goto LABEL_2;\n        v109 = v27 & *(_DWORD *)(a1 + 116);\n        retaddr = *(_DWORD *)(a1 + 100);\n        v6 = *(_DWORD *)(a1 + 4);\n        if ( v28 <= 0xFFFFFF )\n        {\n          *(_DWORD *)a1 = v28 << 8;\n          v7 = *(_DWORD *)(a1 + 12);\n          *(_DWORD *)(a1 + 16) = v5 + 1;\n          *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v7 + v5) + (v6 << 8);\n        }\n        v8 = a1 + 2 * (v109 + 16 * retaddr);\n        v9 = *(unsigned __int16 *)(v8 + 120);\n        v10 = v9 * (*(_DWORD *)a1 >> 11);\n        v11 = *(_DWORD *)(a1 + 4);\n        if ( v10 <= v11 )\n          break;\n        *(_DWORD *)a1 = v10;\n        *(_WORD *)(v8 + 120) = ((2048 - v9) >> 5) + v9;\n        v12 = v27 - 1;\n        if ( !v27 )\n          v12 = *(_DWORD *)(a1 + 44) - 1;\n        v13 = *(_DWORD *)(a1 + 36);\n        v14 = 0;\n        if ( v13 )\n          v14 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 24) + v12);\n        v117 = a1\n             + 1536 * (((v27 & *(_DWORD *)(a1 + 112)) << *(_BYTE *)(a1 + 108)) + (v14 >> (8 - *(_BYTE *)(a1 + 108))))\n             + 3812;\n        if ( retaddr > 6 )\n        {\n          v29 = *(_DWORD *)(a1 + 84);\n          v30 = v27 - 1 - v29;\n          if ( v27 <= v29 )\n            v30 += *(_DWORD *)(a1 + 44);\n          v31 = 0;\n          if ( v13 )\n            v31 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 24) + v30);\n          retaddr = 2 * v31;\n          v32 = 256;\n          v15 = 1;\n          do\n          {\n            v110 = v32 & retaddr;\n            retaddr *= 2;\n            v114 = (_WORD *)(v117 + 2 * (v110 + v32 + v15));\n            v33 = *(_DWORD *)(a1 + 4);\n            if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n            {\n              *(_DWORD *)a1 <<= 8;\n              v34 = *(_DWORD *)(a1 + 12);\n              v35 = *(_DWORD *)(a1 + 16);\n              *(_DWORD *)(a1 + 16) = v35 + 1;\n              *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v34 + v35) + (v33 << 8);\n            }\n            v36 = (unsigned __int16)*v114;\n            v37 = v36 * (*(_DWORD *)a1 >> 11);\n            v38 = *(_DWORD *)(a1 + 4);\n            v15 *= 2;\n            if ( v37 <= v38 )\n            {\n              *(_DWORD *)a1 -= v37;\n              *(_DWORD *)(a1 + 4) = v38 - v37;\n              *v114 = v36 - ((unsigned __int16)v36 >> 5);\n              ++v15;\n              v32 = v110;\n            }\n            else\n            {\n              *(_DWORD *)a1 = v37;\n              *v114 = ((2048 - v36) >> 5) + v36;\n              v32 &= ~v110;\n            }\n          }\n          while ( v15 <= 0xFF );\n        }\n        else\n        {\n          v15 = 1;\n          do\n          {\n            v16 = (_WORD *)(v117 + 2 * v15);\n            v17 = *(_DWORD *)(a1 + 4);\n            if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n            {\n              *(_DWORD *)a1 <<= 8;\n              v18 = *(_DWORD *)(a1 + 12);\n              v19 = *(_DWORD *)(a1 + 16);\n              *(_DWORD *)(a1 + 16) = v19 + 1;\n              *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v18 + v19) + (v17 << 8);\n            }\n            v20 = (unsigned __int16)*v16;\n            retaddr = v20;\n            v21 = v20 * (*(_DWORD *)a1 >> 11);\n            v22 = *(_DWORD *)(a1 + 4);\n            v15 *= 2;\n            if ( v21 <= v22 )\n            {\n              *(_DWORD *)a1 -= v21;\n              *(_DWORD *)(a1 + 4) = v22 - v21;\n              *v16 = v20 - ((unsigned __int16)v20 >> 5);\n              ++v15;\n            }\n            else\n            {\n              *(_DWORD *)a1 = v21;\n              *v16 = ((int)(2048 - retaddr) >> 5) + v20;\n            }\n          }\n          while ( v15 <= 0xFF );\n        }\n        v23 = *(_DWORD *)(a1 + 24);\n        v24 = *(_DWORD *)(a1 + 32);\n        *(_DWORD *)(a1 + 32) = v24 + 1;\n        *(_BYTE *)(v23 + v24) = v15;\n        v25 = *(_DWORD *)(a1 + 32);\n        if ( *(_DWORD *)(a1 + 36) < v25 )\n          *(_DWORD *)(a1 + 36) = v25;\n        v26 = *(_DWORD *)(a1 + 100);\n        if ( v26 > 3 )\n        {\n          if ( v26 > 9 )\n            v39 = v26 - 6;\n          else\n            v39 = v26 - 3;\n          *(_DWORD *)(a1 + 100) = v39;\n        }\n        else\n        {\n          *(_DWORD *)(a1 + 100) = 0;\n        }\n      }\n      v40 = *(_DWORD *)a1 - v10;\n      *(_DWORD *)a1 = v40;\n      v41 = v11 - v10;\n      *(_DWORD *)(a1 + 4) = v41;\n      *(_WORD *)(v8 + 120) = v9 - ((unsigned __int16)v9 >> 5);\n      if ( v40 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = v40 << 8;\n        v42 = *(_DWORD *)(a1 + 12);\n        v43 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v43 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v42 + v43) + (v41 << 8);\n      }\n      v44 = (unsigned __int16 *)(a1 + 2 * retaddr);\n      v45 = v44[252];\n      v46 = v45 * (*(_DWORD *)a1 >> 11);\n      v47 = *(_DWORD *)(a1 + 4);\n      if ( v46 > v47 )\n      {\n        *(_DWORD *)a1 = v46;\n        v44[252] = ((2048 - v45) >> 5) + v45;\n        *(_DWORD *)(a1 + 100) = retaddr < 7 ? 7 : 10;\n        *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 92);\n        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 88);\n        *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 84);\n        sub_808BCC8((_DWORD *)a1, (unsigned __int16 *)(a1 + 1756), v109);\n        v48 = *(_DWORD *)(a1 + 104);\n        if ( v48 > 5 )\n          v48 = 5;\n        v111 = (v48 << 7) + 728;\n        v49 = 1;\n        do\n        {\n          v50 = (_WORD *)(a1 + v111 + 2 * v49);\n          v51 = *(_DWORD *)(a1 + 4);\n          if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n          {\n            *(_DWORD *)a1 <<= 8;\n            v52 = *(_DWORD *)(a1 + 12);\n            v53 = *(_DWORD *)(a1 + 16);\n            *(_DWORD *)(a1 + 16) = v53 + 1;\n            *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v52 + v53) + (v51 << 8);\n          }\n          v54 = (unsigned __int16)*v50;\n          retaddr = v54;\n          v55 = v54 * (*(_DWORD *)a1 >> 11);\n          v56 = *(_DWORD *)(a1 + 4);\n          v49 *= 2;\n          if ( v55 <= v56 )\n          {\n            *(_DWORD *)a1 -= v55;\n            *(_DWORD *)(a1 + 4) = v56 - v55;\n            *v50 = v54 - ((unsigned __int16)v54 >> 5);\n            ++v49;\n          }\n          else\n          {\n            *(_DWORD *)a1 = v55;\n            *v50 = ((int)(2048 - retaddr) >> 5) + v54;\n          }\n        }\n        while ( v49 <= 0x3F );\n        v57 = v49 - 64;\n        if ( v57 > 3 )\n        {\n          v112 = (v57 >> 1) - 1;\n          v58 = (v57 & 1) + 2;\n          *(_DWORD *)(a1 + 84) = v58;\n          if ( v57 > 0xD )\n          {\n            retaddr = (v57 >> 1) - 5;\n            do\n            {\n              v67 = *(_DWORD *)(a1 + 4);\n              if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n              {\n                *(_DWORD *)a1 <<= 8;\n                v68 = *(_DWORD *)(a1 + 12);\n                v69 = *(_DWORD *)(a1 + 16);\n                *(_DWORD *)(a1 + 16) = v69 + 1;\n                *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v68 + v69) + (v67 << 8);\n              }\n              v70 = *(_DWORD *)a1 >> 1;\n              *(_DWORD *)a1 = v70;\n              v71 = (*(_DWORD *)(a1 + 4) - v70) >> 31;\n              *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) - v70 + (v71 & v70);\n              v72 = v71 + 2 * *(_DWORD *)(a1 + 84) + 1;\n              *(_DWORD *)(a1 + 84) = v72;\n              --retaddr;\n            }\n            while ( retaddr );\n            *(_DWORD *)(a1 + 84) = 16 * v72;\n            v73 = 1;\n            do\n            {\n              v74 = (_WORD *)(a1 + 1724 + 2 * v73);\n              v75 = *(_DWORD *)(a1 + 4);\n              if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n              {\n                *(_DWORD *)a1 <<= 8;\n                v76 = *(_DWORD *)(a1 + 12);\n                v77 = *(_DWORD *)(a1 + 16);\n                *(_DWORD *)(a1 + 16) = v77 + 1;\n                *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v76 + v77) + (v75 << 8);\n              }\n              v78 = (unsigned __int16)*v74;\n              v79 = v78 * (*(_DWORD *)a1 >> 11);\n              v113 = *(_DWORD *)(a1 + 4);\n              v73 *= 2;\n              v118 = *(_DWORD *)(a1 + 84);\n              if ( v79 <= v113 )\n              {\n                *(_DWORD *)a1 -= v79;\n                *(_DWORD *)(a1 + 4) = v113 - v79;\n                *v74 = v78 - ((unsigned __int16)v78 >> 5);\n                ++v73;\n                *(_DWORD *)(a1 + 84) = v118 + (1 << retaddr);\n              }\n              else\n              {\n                *(_DWORD *)a1 = v79;\n                *v74 = ((2048 - v78) >> 5) + v78;\n              }\n              ++retaddr;\n            }\n            while ( retaddr != 4 );\n          }\n          else\n          {\n            v59 = v58 << v112;\n            *(_DWORD *)(a1 + 84) = v59;\n            v120 = 2 * (v59 - v57 + 0x7FFFFFFF);\n            retaddr = 0;\n            v60 = 1;\n            do\n            {\n              v61 = (_WORD *)(v120 + 2 * v60 + a1 + 1496);\n              v62 = *(_DWORD *)(a1 + 4);\n              if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n              {\n                *(_DWORD *)a1 <<= 8;\n                v63 = *(_DWORD *)(a1 + 12);\n                v64 = *(_DWORD *)(a1 + 16);\n                *(_DWORD *)(a1 + 16) = v64 + 1;\n                *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v63 + v64) + (v62 << 8);\n              }\n              v65 = (unsigned __int16)*v61;\n              v66 = v65 * (*(_DWORD *)a1 >> 11);\n              v115 = *(_DWORD *)(a1 + 4);\n              v60 *= 2;\n              v119 = *(_DWORD *)(a1 + 84);\n              if ( v66 <= v115 )\n              {\n                *(_DWORD *)a1 -= v66;\n                *(_DWORD *)(a1 + 4) = v115 - v66;\n                *v61 = v65 - ((unsigned __int16)v65 >> 5);\n                ++v60;\n                *(_DWORD *)(a1 + 84) = (1 << retaddr) + v119;\n              }\n              else\n              {\n                *(_DWORD *)a1 = v66;\n                *v61 = ((2048 - v65) >> 5) + v65;\n              }\n              ++retaddr;\n            }\n            while ( v112 > retaddr );\n          }\n        }\n        else\n        {\n          *(_DWORD *)(a1 + 84) = v57;\n        }\n        goto LABEL_99;\n      }\n      v80 = *(_DWORD *)a1 - v46;\n      *(_DWORD *)a1 = v80;\n      v81 = v47 - v46;\n      *(_DWORD *)(a1 + 4) = v81;\n      v44[252] = v45 - ((unsigned __int16)v45 >> 5);\n      if ( v80 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = v80 << 8;\n        v82 = *(_DWORD *)(a1 + 12);\n        v83 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v83 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v82 + v83) + (v81 << 8);\n      }\n      v84 = v44[264];\n      v85 = v84 * (*(_DWORD *)a1 >> 11);\n      v86 = *(_DWORD *)(a1 + 4);\n      if ( v85 <= v86 )\n        break;\n      *(_DWORD *)a1 = v85;\n      v44[264] = v84 + ((2048 - v84) >> 5);\n      if ( v85 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = v85 << 8;\n        v87 = *(_DWORD *)(a1 + 12);\n        v88 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v88 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v87 + v88) + (v86 << 8);\n      }\n      v93 = *(unsigned __int16 *)(v8 + 600);\n      v94 = v93 * (*(_DWORD *)a1 >> 11);\n      v95 = *(_DWORD *)(a1 + 4);\n      if ( v94 <= v95 )\n      {\n        *(_DWORD *)a1 -= v94;\n        *(_DWORD *)(a1 + 4) = v95 - v94;\n        *(_WORD *)(v8 + 600) = v93 - ((unsigned __int16)v93 >> 5);\nLABEL_98:\n        *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 100) < 7u ? 8 : 11;\n        sub_808BCC8((_DWORD *)a1, (unsigned __int16 *)(a1 + 2784), v109);\n        goto LABEL_99;\n      }\n      *(_DWORD *)a1 = v94;\n      *(_WORD *)(v8 + 600) = ((2048 - v93) >> 5) + v93;\n      *(_DWORD *)(a1 + 100) = retaddr < 7 ? 9 : 11;\n      *(_DWORD *)(a1 + 104) = 1;\nLABEL_99:\n      result = sub_808BC63(*(_DWORD *)(a1 + 84), a1 + 104);\n      if ( !result )\n        return result;\n    }\n    v89 = *(_DWORD *)a1 - v85;\n    *(_DWORD *)a1 = v89;\n    v90 = v86 - v85;\n    *(_DWORD *)(a1 + 4) = v90;\n    v44[264] = v84 - ((unsigned __int16)v84 >> 5);\n    if ( v89 <= 0xFFFFFF )\n    {\n      *(_DWORD *)a1 = v89 << 8;\n      v91 = *(_DWORD *)(a1 + 12);\n      v92 = *(_DWORD *)(a1 + 16);\n      *(_DWORD *)(a1 + 16) = v92 + 1;\n      *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v91 + v92) + (v90 << 8);\n    }\n    v116 = *(_DWORD *)a1;\n    v96 = v44[276];\n    v97 = v96 * (*(_DWORD *)a1 >> 11);\n    v98 = *(_DWORD *)(a1 + 4);\n    retaddr = *(_DWORD *)(a1 + 88);\n    if ( v97 <= v98 )\n    {\n      *(_DWORD *)a1 = v116 - v97;\n      v99 = v98 - v97;\n      *(_DWORD *)(a1 + 4) = v99;\n      v44[276] = v96 - ((unsigned __int16)v96 >> 5);\n      if ( v116 - v97 <= 0xFFFFFF )\n      {\n        *(_DWORD *)a1 = (v116 - v97) << 8;\n        v100 = *(_DWORD *)(a1 + 12);\n        v101 = *(_DWORD *)(a1 + 16);\n        *(_DWORD *)(a1 + 16) = v101 + 1;\n        *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v100 + v101) + (v99 << 8);\n      }\n      v102 = v44[288];\n      v103 = v102 * (*(_DWORD *)a1 >> 11);\n      v104 = *(_DWORD *)(a1 + 4);\n      v105 = *(_DWORD *)(a1 + 92);\n      if ( v103 <= v104 )\n      {\n        *(_DWORD *)a1 -= v103;\n        *(_DWORD *)(a1 + 4) = v104 - v103;\n        v44[288] = v102 - ((unsigned __int16)v102 >> 5);\n        v106 = *(_DWORD *)(a1 + 96);\n        *(_DWORD *)(a1 + 96) = v105;\n        v105 = v106;\n      }\n      else\n      {\n        *(_DWORD *)a1 = v103;\n        v44[288] = ((2048 - v102) >> 5) + v102;\n      }\n      *(_DWORD *)(a1 + 92) = retaddr;\n      retaddr = v105;\n    }\n    else\n    {\n      *(_DWORD *)a1 = v97;\n      v44[276] = ((2048 - v96) >> 5) + v96;\n    }\n    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 84);\n    *(_DWORD *)(a1 + 84) = retaddr;\n    goto LABEL_98;\n  }\nLABEL_2:\n  if ( *(_DWORD *)a1 <= 0xFFFFFFu )\n  {\n    *(_DWORD *)a1 <<= 8;\n    v2 = *(_DWORD *)(a1 + 4) << 8;\n    v3 = *(_DWORD *)(a1 + 12);\n    v4 = *(_DWORD *)(a1 + 16);\n    *(_DWORD *)(a1 + 16) = v4 + 1;\n    *(_DWORD *)(a1 + 4) = v2 + *(unsigned __int8 *)(v3 + v4);\n  }\n  return 1;\n}\n"
        ],
        "134793051": [
            "sub_808C75B",
            "0x808c75b",
            "int __userpurge sub_808C75B@<eax>(_DWORD *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)\n{\n  char v5; // dl\n  int v6; // ebp\n  int v7; // edi\n  int v8; // esi\n  unsigned int v9; // ecx\n\n  if ( !a1[1] )\n  {\n    a1[2] = 0;\n    a1[3] = 0;\n  }\n  while ( 1 )\n  {\n    v9 = *a3;\n    if ( *a3 >= a4 )\n      return 0;\n    v5 = *(_BYTE *)(a2 + v9);\n    *a3 = v9 + 1;\n    v6 = a1[1];\n    v7 = (unsigned __int64)(v5 & 0x7F) << v6 >> 32;\n    v8 = (v5 & 0x7F) << v6;\n    if ( (v6 & 0x20) != 0 )\n    {\n      v7 = (v5 & 0x7F) << v6;\n      v8 = 0;\n    }\n    a1[2] |= v8;\n    a1[3] |= v7;\n    if ( v5 >= 0 )\n      break;\n    a1[1] = v6 + 7;\n    if ( v6 == 56 )\n      return 7;\n  }\n  if ( v6 && !v5 )\n    return 7;\n  a1[1] = 0;\n  return 1;\n}\n"
        ],
        "134793213": [
            "sub_808C7FD",
            "0x808c7fd",
            "int __usercall sub_808C7FD@<eax>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v2; // ebp\n  int v3; // esi\n  int v4; // ecx\n  int v5; // ebx\n  unsigned int v6; // ecx\n\n  v2 = a2[2];\n  while ( 1 )\n  {\n    v3 = a2[1];\n    if ( v3 == v2 )\n      return 0;\n    v4 = *(_DWORD *)(a1 + 4);\n    v5 = *(_DWORD *)(a1 + 24) >> v4;\n    a2[1] = v3 + 1;\n    if ( *(_BYTE *)(*a2 + v3) != (_BYTE)v5 )\n      break;\n    v6 = v4 + 8;\n    *(_DWORD *)(a1 + 4) = v6;\n    if ( v6 > 0x1F )\n    {\n      *(_DWORD *)(a1 + 24) = 0;\n      *(_DWORD *)(a1 + 4) = 0;\n      return 1;\n    }\n  }\n  return 7;\n}\n"
        ],
        "134793294": [
            "sub_808C84E",
            "0x808c84e",
            "int __usercall sub_808C84E@<eax>(int a1@<eax>)\n{\n  void *v2; // ebx\n  int result; // eax\n\n  *(_DWORD *)a1 = 0;\n  *(_BYTE *)(a1 + 36) = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  *(_DWORD *)(a1 + 24) = 0;\n  v2 = (void *)(a1 + 60);\n  result = 0;\n  memset(v2, 0, 0x2Cu);\n  memset((void *)(a1 + 104), 0, 0x28u);\n  *(_DWORD *)(a1 + 144) = 0;\n  *(_DWORD *)(a1 + 148) = 12;\n  return result;\n}\n"
        ],
        "134793371": [
            "sub_808C89B",
            "0x808c89b",
            "decompilation failure at 808C89B!\n"
        ],
        "134793397": [
            "sub_808C8B5",
            "0x808c8b5",
            "int __usercall sub_808C8B5@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebp\n  int result; // eax\n\n  v3 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 16);\n  *(_QWORD *)(a1 + 108) += (unsigned int)v3;\n  result = sub_808C89B(*(_DWORD *)(a1 + 24), v3);\n  *(_DWORD *)(a1 + 24) = result;\n  return result;\n}\n"
        ],
        "134793439": [
            "sub_808C8DF",
            "0x808c8df",
            "char __usercall sub_808C8DF@<al>(int a1@<eax>, _DWORD *a2@<edx>)\n{\n  int v3; // edi\n  int v4; // esi\n  unsigned int v5; // eax\n  unsigned int v6; // edx\n  char result; // al\n\n  v3 = *(_DWORD *)(a1 + 144);\n  v4 = a2[1];\n  v5 = *(_DWORD *)(a1 + 148) - v3;\n  if ( v5 > a2[2] - v4 )\n    v5 = a2[2] - v4;\n  qmemcpy((void *)(a1 + v3 + 152), (const void *)(*a2 + v4), v5);\n  a2[1] += v5;\n  v6 = *(_DWORD *)(a1 + 144) + v5;\n  *(_DWORD *)(a1 + 144) = v6;\n  result = 0;\n  if ( v6 == *(_DWORD *)(a1 + 148) )\n  {\n    *(_DWORD *)(a1 + 144) = 0;\n    return 1;\n  }\n  return result;\n}\n"
        ],
        "134793532": [
            "sub_808C93C",
            "0x808c93c",
            "decompilation failure at 808C93C!\n"
        ],
        "134795024": [
            "sub_808CF10",
            "0x808cf10",
            "decompilation failure at 808CF10!\n"
        ],
        "134797332": [
            "sub_808D814",
            "0x808d814",
            "bool __usercall sub_808D814@<al>(int a1@<eax>, int a2@<ecx>)\n{\n  return sub_808D85A(a2, **(_DWORD **)(a1 + 24)) == 0;\n}\n"
        ],
        "134797351": [
            "sub_808D827",
            "0x808d827",
            "bool __usercall sub_808D827@<al>(int a1@<eax>, int a2@<ecx>)\n{\n  int v3; // esi\n  int v4; // eax\n  int v5; // ecx\n  char v6; // dl\n\n  v3 = **(_DWORD **)(a1 + 24);\n  v4 = sub_808D87F(a2, v3);\n  v6 = 1;\n  if ( !v4 )\n  {\n    v6 = 0;\n    if ( *(_DWORD *)(a1 + 12) )\n      return sub_808D87F(v5, v3) == 0;\n  }\n  return v6;\n}\n"
        ],
        "134797402": [
            "sub_808D85A",
            "0x808d85a",
            "decompilation failure at 808D85A!\n"
        ],
        "134797439": [
            "sub_808D87F",
            "0x808d87f",
            "decompilation failure at 808D87F!\n"
        ],
        "134797560": [
            "sub_808D8F8",
            "0x808d8f8",
            "decompilation failure at 808D8F8!\n"
        ],
        "134798408": [
            "sub_808DC48",
            "0x808dc48",
            "decompilation failure at 808DC48!\n"
        ],
        "134798509": [
            "sub_808DCAD",
            "0x808dcad",
            "decompilation failure at 808DCAD!\n"
        ],
        "134799972": [
            "sub_808E264",
            "0x808e264",
            "decompilation failure at 808E264!\n"
        ],
        "134799981": [
            "sub_808E26D",
            "0x808e26d",
            "decompilation failure at 808E26D!\n"
        ],
        "134800177": [
            "sub_808E331",
            "0x808e331",
            "_DWORD *sub_808E331()\n{\n  _DWORD *v0; // ebx\n\n  v0 = sub_804DB2E(0x6Cu);\n  v0[6] = sub_804DB2E(0x28u);\n  v0[8] = nullsub_1;\n  v0[9] = sub_80899AD;\n  v0[2] = sub_808F154;\n  v0[10] = sub_808EF39;\n  v0[21] = -1;\n  v0[22] = -1;\n  return v0;\n}\n"
        ],
        "134800249": [
            "sub_808E379",
            "0x808e379",
            "unsigned int __usercall sub_808E379@<eax>(\n        unsigned int a1@<eax>,\n        int a2@<edx>,\n        _BYTE *a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10,\n        int a11,\n        int a12,\n        int a13,\n        _DWORD *a14,\n        int a15)\n{\n  unsigned __int8 *v15; // ecx\n  unsigned __int8 *v16; // ebp\n  _BYTE *v17; // edx\n  unsigned int v18; // ebx\n  int v19; // edi\n  _BYTE *v20; // esi\n  unsigned __int8 *v21; // eax\n  unsigned __int8 *v22; // ebx\n  unsigned int v23; // ebx\n  _BYTE *v24; // edi\n  unsigned int v25; // eax\n  int v26; // edi\n  char v27; // cl\n  char v28; // cl\n  _BYTE *v29; // esi\n  char *v30; // eax\n  unsigned int v31; // edi\n  char v32; // cl\n  _BYTE *i; // esi\n  unsigned int v34; // ecx\n  unsigned int v35; // ebp\n  unsigned __int8 *retaddr; // [esp+28h] [ebp+0h]\n  unsigned __int8 v39; // [esp+30h] [ebp+8h]\n  unsigned __int8 v40; // [esp+31h] [ebp+9h]\n  unsigned __int8 v41; // [esp+32h] [ebp+Ah]\n  unsigned int v42; // [esp+34h] [ebp+Ch]\n  unsigned int v43; // [esp+38h] [ebp+10h]\n\n  v42 = a2 + a1;\n  v43 = a1 + a2 - 13;\n  v15 = (unsigned __int8 *)(a1 + 4);\n  v16 = (unsigned __int8 *)a1;\n  v17 = a3;\n  while ( 1 )\n  {\n    v39 = v15[3];\n    v40 = v15[2];\n    v41 = v15[1];\n    v18 = (unsigned int)(33 * (*v15 ^ (32 * (v41 ^ (32 * (v40 ^ (v39 << 6))))))) >> 5;\n    v19 = v18 & 0x3FFF;\n    retaddr = &v15[-*(_DWORD *)(a15 + 4 * v19)];\n    v20 = *(_BYTE **)(a15 + 4 * v19);\n    if ( (unsigned int)(retaddr - 1) > 0xBFFE )\n      break;\n    if ( (unsigned int)v20 < a1 )\n      break;\n    if ( (unsigned int)retaddr > 0x800 && v39 != v20[3] )\n    {\n      v19 = v18 & 0x7FF ^ 0x201F;\n      v21 = &v15[-*(_DWORD *)(a15 + 4 * v19)];\n      retaddr = v21;\n      v20 = *(_BYTE **)(a15 + 4 * v19);\n      if ( (unsigned int)(v21 - 1) > 0xBFFE || (unsigned int)v20 < a1 || (unsigned int)v21 > 0x800 && v39 != v20[3] )\n        break;\n    }\n    if ( *v15 != *v20 || v41 != v20[1] || v40 != v20[2] )\n      break;\n    *(_DWORD *)(a15 + 4 * v19) = v15;\n    if ( v15 != v16 )\n    {\n      v23 = v15 - v16;\n      v24 = v17 + 1;\n      if ( (unsigned int)(v15 - v16) > 3 )\n      {\n        if ( v23 > 0x12 )\n        {\n          v25 = v23 - 18;\n          *v17 = 0;\n          while ( 1 )\n          {\n            v17 = v24 + 1;\n            if ( v25 <= 0xFF )\n              break;\n            v25 -= 255;\n            *v24++ = 0;\n          }\n          *v24 = v25;\n        }\n        else\n        {\n          *v17++ = v23 - 3;\n        }\n      }\n      else\n      {\n        *(v17 - 2) |= v23;\n      }\n      v26 = 0;\n      do\n      {\n        v17[v26] = v16[v26];\n        ++v26;\n      }\n      while ( v23 != v26 );\n      v17 += v23;\n      v16 = v15;\n    }\n    v22 = v15 + 4;\n    if ( v20[3] == v15[3] )\n    {\n      v22 = v15 + 5;\n      if ( v20[4] == v15[4] )\n      {\n        v22 = v15 + 6;\n        if ( v20[5] == v15[5] )\n        {\n          v22 = v15 + 7;\n          if ( v20[6] == v15[6] )\n          {\n            v22 = v15 + 8;\n            if ( v20[7] == v15[7] )\n            {\n              v22 = v15 + 9;\n              if ( v20[8] == v15[8] )\n              {\n                for ( i = v20 + 9; (unsigned int)v22 < v42 && *i == *v22; ++i )\n                  ++v22;\n                v34 = v22 - v16;\n                v29 = v17 + 1;\n                if ( (unsigned int)retaddr <= 0x4000 )\n                {\n                  v30 = (char *)(retaddr - 1);\n                  if ( v34 <= 0x21 )\n                  {\n                    v28 = v34 - 2;\nLABEL_47:\n                    v32 = v28 | 0x20;\nLABEL_39:\n                    *v17 = v32;\nLABEL_55:\n                    *v29 = 4 * (_BYTE)v30;\n                    v17 = v29 + 2;\n                    v29[1] = (unsigned int)v30 >> 6;\n                    goto LABEL_56;\n                  }\n                  v35 = v34 - 33;\n                  *v17 = 32;\nLABEL_52:\n                  while ( v35 > 0xFF )\n                  {\n                    v35 -= 255;\n                    *v29++ = 0;\n                  }\n                  *v29++ = v35;\n                  goto LABEL_55;\n                }\n                v30 = (char *)(retaddr - 0x4000);\n                v31 = ((unsigned int)(retaddr - 0x4000) >> 11) & 8 | 0x10;\n                if ( v34 > 9 )\n                {\n                  v35 = v34 - 9;\n                  *v17 = v31;\n                  goto LABEL_52;\n                }\n                v28 = v34 - 2;\nLABEL_38:\n                v32 = v31 | v28;\n                goto LABEL_39;\n              }\n            }\n          }\n        }\n      }\n    }\n    v27 = (_BYTE)--v22 - (_BYTE)v16;\n    if ( (unsigned int)retaddr > 0x800 )\n    {\n      v28 = v27 - 2;\n      v29 = v17 + 1;\n      if ( (unsigned int)retaddr <= 0x4000 )\n      {\n        v30 = (char *)(retaddr - 1);\n        goto LABEL_47;\n      }\n      v30 = (char *)(retaddr - 0x4000);\n      v31 = ((unsigned int)(retaddr - 0x4000) >> 11) & 8 | 0x10;\n      goto LABEL_38;\n    }\n    *v17 = (4 * ((_BYTE)retaddr - 1)) & 0x1C | (32 * (v27 - 1));\n    v17[1] = (unsigned int)(retaddr - 1) >> 3;\n    v17 += 2;\nLABEL_56:\n    if ( (unsigned int)v22 >= v43 )\n      goto LABEL_59;\n    v16 = v22;\nLABEL_14:\n    v15 = v22;\n  }\n  *(_DWORD *)(a15 + 4 * v19) = v15;\n  v22 = v15 + 1;\n  if ( v43 > (unsigned int)(v15 + 1) )\n    goto LABEL_14;\n  v22 = v16;\nLABEL_59:\n  *a14 = v17 - a3;\n  return v42 - (_DWORD)v22;\n}\n"
        ],
        "134800968": [
            "sub_808E648",
            "0x808e648",
            "decompilation failure at 808E648!\n"
        ],
        "134801156": [
            "sub_808E704",
            "0x808e704",
            "unsigned int __usercall sub_808E704@<eax>(\n        unsigned int a1@<eax>,\n        int a2@<edx>,\n        _BYTE *a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10,\n        int a11,\n        int a12,\n        int a13,\n        _DWORD *a14,\n        int a15)\n{\n  unsigned __int8 *v15; // ecx\n  unsigned __int8 *v16; // ebp\n  _BYTE *v17; // edx\n  unsigned int v18; // ebx\n  int v19; // edi\n  _BYTE *v20; // esi\n  unsigned __int8 *v21; // eax\n  unsigned __int8 *v22; // ebx\n  unsigned int v23; // ebx\n  _BYTE *v24; // edi\n  unsigned int v25; // eax\n  int v26; // edi\n  char v27; // cl\n  char v28; // cl\n  _BYTE *v29; // esi\n  char *v30; // eax\n  unsigned int v31; // edi\n  char v32; // cl\n  _BYTE *i; // esi\n  unsigned int v34; // ecx\n  unsigned int v35; // ebp\n  unsigned __int8 *retaddr; // [esp+28h] [ebp+0h]\n  unsigned __int8 v39; // [esp+30h] [ebp+8h]\n  unsigned __int8 v40; // [esp+31h] [ebp+9h]\n  unsigned __int8 v41; // [esp+32h] [ebp+Ah]\n  unsigned int v42; // [esp+34h] [ebp+Ch]\n  unsigned int v43; // [esp+38h] [ebp+10h]\n\n  v42 = a2 + a1;\n  v43 = a1 + a2 - 13;\n  v15 = (unsigned __int8 *)(a1 + 4);\n  v16 = (unsigned __int8 *)a1;\n  v17 = a3;\n  while ( 1 )\n  {\n    v39 = v15[3];\n    v40 = v15[2];\n    v41 = v15[1];\n    v18 = (unsigned int)(33 * (*v15 ^ (32 * (v41 ^ (32 * (v40 ^ (v39 << 6))))))) >> 5;\n    v19 = v18 & 0x7FFF;\n    retaddr = &v15[-*(_DWORD *)(a15 + 4 * v19)];\n    v20 = *(_BYTE **)(a15 + 4 * v19);\n    if ( (unsigned int)(retaddr - 1) > 0xBFFE )\n      break;\n    if ( (unsigned int)v20 < a1 )\n      break;\n    if ( (unsigned int)retaddr > 0x800 && v39 != v20[3] )\n    {\n      v19 = v18 & 0x7FF ^ 0x401F;\n      v21 = &v15[-*(_DWORD *)(a15 + 4 * v19)];\n      retaddr = v21;\n      v20 = *(_BYTE **)(a15 + 4 * v19);\n      if ( (unsigned int)(v21 - 1) > 0xBFFE || (unsigned int)v20 < a1 || (unsigned int)v21 > 0x800 && v39 != v20[3] )\n        break;\n    }\n    if ( *v15 != *v20 || v41 != v20[1] || v40 != v20[2] )\n      break;\n    *(_DWORD *)(a15 + 4 * v19) = v15;\n    if ( v15 != v16 )\n    {\n      v23 = v15 - v16;\n      v24 = v17 + 1;\n      if ( (unsigned int)(v15 - v16) > 3 )\n      {\n        if ( v23 > 0x12 )\n        {\n          v25 = v23 - 18;\n          *v17 = 0;\n          while ( 1 )\n          {\n            v17 = v24 + 1;\n            if ( v25 <= 0xFF )\n              break;\n            v25 -= 255;\n            *v24++ = 0;\n          }\n          *v24 = v25;\n        }\n        else\n        {\n          *v17++ = v23 - 3;\n        }\n      }\n      else\n      {\n        *(v17 - 2) |= v23;\n      }\n      v26 = 0;\n      do\n      {\n        v17[v26] = v16[v26];\n        ++v26;\n      }\n      while ( v23 != v26 );\n      v17 += v23;\n      v16 = v15;\n    }\n    v22 = v15 + 4;\n    if ( v20[3] == v15[3] )\n    {\n      v22 = v15 + 5;\n      if ( v20[4] == v15[4] )\n      {\n        v22 = v15 + 6;\n        if ( v20[5] == v15[5] )\n        {\n          v22 = v15 + 7;\n          if ( v20[6] == v15[6] )\n          {\n            v22 = v15 + 8;\n            if ( v20[7] == v15[7] )\n            {\n              v22 = v15 + 9;\n              if ( v20[8] == v15[8] )\n              {\n                for ( i = v20 + 9; (unsigned int)v22 < v42 && *i == *v22; ++i )\n                  ++v22;\n                v34 = v22 - v16;\n                v29 = v17 + 1;\n                if ( (unsigned int)retaddr <= 0x4000 )\n                {\n                  v30 = (char *)(retaddr - 1);\n                  if ( v34 <= 0x21 )\n                  {\n                    v28 = v34 - 2;\nLABEL_47:\n                    v32 = v28 | 0x20;\nLABEL_39:\n                    *v17 = v32;\nLABEL_55:\n                    *v29 = 4 * (_BYTE)v30;\n                    v17 = v29 + 2;\n                    v29[1] = (unsigned int)v30 >> 6;\n                    goto LABEL_56;\n                  }\n                  v35 = v34 - 33;\n                  *v17 = 32;\nLABEL_52:\n                  while ( v35 > 0xFF )\n                  {\n                    v35 -= 255;\n                    *v29++ = 0;\n                  }\n                  *v29++ = v35;\n                  goto LABEL_55;\n                }\n                v30 = (char *)(retaddr - 0x4000);\n                v31 = ((unsigned int)(retaddr - 0x4000) >> 11) & 8 | 0x10;\n                if ( v34 > 9 )\n                {\n                  v35 = v34 - 9;\n                  *v17 = v31;\n                  goto LABEL_52;\n                }\n                v28 = v34 - 2;\nLABEL_38:\n                v32 = v31 | v28;\n                goto LABEL_39;\n              }\n            }\n          }\n        }\n      }\n    }\n    v27 = (_BYTE)--v22 - (_BYTE)v16;\n    if ( (unsigned int)retaddr > 0x800 )\n    {\n      v28 = v27 - 2;\n      v29 = v17 + 1;\n      if ( (unsigned int)retaddr <= 0x4000 )\n      {\n        v30 = (char *)(retaddr - 1);\n        goto LABEL_47;\n      }\n      v30 = (char *)(retaddr - 0x4000);\n      v31 = ((unsigned int)(retaddr - 0x4000) >> 11) & 8 | 0x10;\n      goto LABEL_38;\n    }\n    *v17 = (4 * ((_BYTE)retaddr - 1)) & 0x1C | (32 * (v27 - 1));\n    v17[1] = (unsigned int)(retaddr - 1) >> 3;\n    v17 += 2;\nLABEL_56:\n    if ( (unsigned int)v22 >= v43 )\n      goto LABEL_59;\n    v16 = v22;\nLABEL_14:\n    v15 = v22;\n  }\n  *(_DWORD *)(a15 + 4 * v19) = v15;\n  v22 = v15 + 1;\n  if ( v43 > (unsigned int)(v15 + 1) )\n    goto LABEL_14;\n  v22 = v16;\nLABEL_59:\n  *a14 = v17 - a3;\n  return v42 - (_DWORD)v22;\n}\n"
        ],
        "134801875": [
            "sub_808E9D3",
            "0x808e9d3",
            "decompilation failure at 808E9D3!\n"
        ],
        "134802063": [
            "sub_808EA8F",
            "0x808ea8f",
            "int __cdecl sub_808EA8F(\n        int a1,\n        int a2,\n        int a3,\n        int a4,\n        int a5,\n        int a6,\n        unsigned __int8 *a7,\n        int a8,\n        unsigned int a9,\n        unsigned int *a10)\n{\n  unsigned int v10; // ebp\n  int v11; // eax\n  unsigned __int8 *v12; // edi\n  unsigned int v13; // edx\n  unsigned int v14; // ebx\n  int v15; // eax\n  unsigned __int8 *v16; // ecx\n  unsigned __int8 *v17; // eax\n  unsigned __int8 *v18; // edx\n  unsigned int v19; // ebx\n  unsigned __int8 *v20; // edx\n  int v21; // ecx\n  unsigned int v22; // edx\n  unsigned int v23; // ebx\n  bool v24; // cf\n  unsigned __int8 *v25; // ecx\n  unsigned int v26; // ebp\n  unsigned int v27; // edx\n  int v28; // ecx\n  int v29; // ebp\n  int v30; // ecx\n  unsigned __int8 *v31; // ecx\n  int v32; // ebx\n  unsigned __int8 *v33; // ebx\n  _BYTE *v34; // edx\n  int v35; // eax\n  unsigned __int8 v36; // dl\n  unsigned __int8 *v37; // edx\n  unsigned __int8 *v38; // ebp\n  int v39; // ecx\n  unsigned __int8 *v40; // ecx\n  _BYTE *v41; // edi\n  int v42; // eax\n  int result; // eax\n  unsigned __int8 *retaddr; // [esp+18h] [ebp+0h]\n  unsigned int v45; // [esp+1Ch] [ebp+4h]\n\n  retaddr = &a7[a8];\n  v10 = *a10;\n  v45 = a9 + *a10;\n  *a10 = 0;\n  v11 = *a7;\n  if ( (unsigned __int8)v11 <= 0x11u )\n  {\n    v12 = a7;\n    v17 = (unsigned __int8 *)a9;\n    goto LABEL_14;\n  }\n  v12 = a7 + 1;\n  v13 = v11 - 17;\n  v14 = v11 - 17;\n  if ( v11 - 17 <= 3 )\n  {\n    v37 = (unsigned __int8 *)a9;\n    goto LABEL_51;\n  }\n  if ( v10 < v13 )\n  {\n    v17 = (unsigned __int8 *)a9;\n    goto LABEL_77;\n  }\n  if ( a8 - 1 < (unsigned int)(v11 - 16) )\n  {\n    v17 = (unsigned __int8 *)a9;\n    goto LABEL_74;\n  }\n  v15 = 0;\n  do\n  {\n    *(_BYTE *)(a9 + v15) = a7[v15 + 1];\n    ++v15;\n  }\n  while ( v13 != v15 );\n  v16 = &v12[v13];\n  v17 = (unsigned __int8 *)(a9 + v13);\n  while ( 2 )\n  {\n    v18 = v16 + 1;\n    v19 = *v16;\n    if ( v19 <= 0xF )\n    {\n      v12 = v16 + 2;\n      v20 = &v17[-2049 - (v19 >> 2) - 4 * v16[1]];\n      if ( a9 > (unsigned int)v20 || v17 <= v20 )\n      {\nLABEL_78:\n        *a10 = (unsigned int)&v17[-a9];\n        return -6;\n      }\n      if ( v45 - (unsigned int)v17 > 2 )\n      {\n        *v17 = *v20;\n        v17[1] = v20[1];\n        v17[2] = v20[2];\n        v17 += 3;\n        goto LABEL_48;\n      }\nLABEL_77:\n      *a10 = (unsigned int)&v17[-a9];\n      return -5;\n    }\n    do\n    {\n      while ( 1 )\n      {\n        if ( v19 > 0x3F )\n        {\n          v12 = v18 + 1;\n          v21 = ~((v19 >> 2) & 7) - 8 * *v18;\n          v22 = v19 >> 5;\n          v23 = (v19 >> 5) - 1;\n          v24 = __CFADD__(v17, v21);\n          v25 = &v17[v21];\n          if ( !v24 || a9 > (unsigned int)v25 )\n            goto LABEL_78;\n          v26 = v45 - (_DWORD)v17;\n          v27 = v22 + 1;\nLABEL_44:\n          if ( v26 < v27 )\n            goto LABEL_77;\n          *v17 = *v25;\n          v34 = v17 + 2;\n          v17[1] = v25[1];\n          v35 = 0;\n          do\n          {\n            v34[v35] = v25[v35 + 2];\n            ++v35;\n          }\n          while ( v23 != v35 );\n          v17 = &v34[v23];\n          goto LABEL_48;\n        }\n        if ( v19 > 0x1F )\n        {\n          v23 = v19 & 0x1F;\n          if ( !v23 )\n          {\n            while ( v18 != retaddr )\n            {\n              v28 = *v18;\n              if ( (_BYTE)v28 )\n              {\n                if ( v23 > 0xFFFFFE01 )\n                  goto LABEL_74;\n                ++v18;\n                v23 += v28 + 31;\n                goto LABEL_27;\n              }\n              v23 += 255;\n              ++v18;\n            }\n            goto LABEL_74;\n          }\nLABEL_27:\n          v25 = &v17[~((v18[1] << 6) + (*v18 >> 2))];\n          v12 = v18 + 2;\nLABEL_41:\n          if ( v17 <= v25 || (unsigned int)v25 < a9 )\n            goto LABEL_78;\n          v26 = v45 - (_DWORD)v17;\n          v27 = v23 + 2;\n          goto LABEL_44;\n        }\n        if ( v19 > 0xF )\n        {\n          v29 = ((_WORD)v19 << 11) & 0x4000;\n          v23 = v19 & 7;\n          if ( !v23 )\n          {\n            while ( v18 != retaddr )\n            {\n              v30 = *v18;\n              if ( (_BYTE)v30 )\n              {\n                if ( v23 > 0xFFFFFE01 )\n                  goto LABEL_74;\n                ++v18;\n                v23 += v30 + 7;\n                goto LABEL_35;\n              }\n              v23 += 255;\n              ++v18;\n            }\n            goto LABEL_74;\n          }\nLABEL_35:\n          v31 = &v17[-v29 - (*v18 >> 2) + -64 * v18[1]];\n          v12 = v18 + 2;\n          if ( v17 == v31 )\n          {\n            *a10 = (unsigned int)&v17[-a9];\n            result = 0;\n            if ( retaddr != v12 )\n              return v12 < retaddr ? -8 : -4;\n            return result;\n          }\n          v25 = v31 - 0x4000;\n          goto LABEL_41;\n        }\n        v12 = v18 + 1;\n        v32 = ~(v19 >> 2) - 4 * *v18;\n        v24 = __CFADD__(v17, v32);\n        v33 = &v17[v32];\n        if ( !v24 || a9 > (unsigned int)v33 )\n          goto LABEL_78;\n        if ( v45 - (unsigned int)v17 <= 1 )\n          goto LABEL_77;\n        *v17 = *v33;\n        v17[1] = v33[1];\n        v17 += 2;\nLABEL_48:\n        v36 = *(v12 - 2) & 3;\n        v14 = v36;\n        if ( !v36 )\n          break;\n        v37 = v17;\nLABEL_51:\n        if ( v45 - (unsigned int)v37 < v14 )\n        {\n          v17 = v37;\n          goto LABEL_77;\n        }\n        if ( retaddr - v12 < v14 + 1 )\n        {\n          v17 = v37;\n          goto LABEL_74;\n        }\n        v38 = v12 + 1;\n        v17 = v37 + 1;\n        *v37 = *v12;\n        if ( v14 > 1 )\n        {\n          v38 = v12 + 2;\n          v17 = v37 + 2;\n          v37[1] = v12[1];\n          if ( v14 == 3 )\n          {\n            v38 = v12 + 3;\n            v17 = v37 + 3;\n            v37[2] = v12[2];\n          }\n        }\n        v18 = v38 + 1;\n        v19 = *v38;\n        if ( retaddr <= v38 + 1 )\n        {\nLABEL_69:\n          *a10 = (unsigned int)&v17[-a9];\n          return -7;\n        }\n      }\nLABEL_14:\n      if ( v12 >= retaddr )\n        goto LABEL_69;\n      v18 = v12 + 1;\n      v19 = *v12;\n    }\n    while ( v19 > 0xF );\n    if ( *v12 )\n    {\nLABEL_64:\n      if ( v45 - (unsigned int)v17 < v19 + 3 )\n        goto LABEL_77;\n      if ( retaddr - v18 >= v19 + 4 )\n      {\n        *v17 = *v18;\n        v17[1] = v18[1];\n        v40 = v18 + 3;\n        v41 = v17 + 3;\n        v17[2] = v18[2];\n        v42 = 0;\n        do\n        {\n          v41[v42] = v40[v42];\n          ++v42;\n        }\n        while ( v19 != v42 );\n        v16 = &v40[v19];\n        v17 = &v41[v19];\n        continue;\n      }\n    }\n    else\n    {\n      while ( v18 != retaddr )\n      {\n        v39 = *v18;\n        if ( (_BYTE)v39 )\n        {\n          if ( v19 > 0xFFFFFE01 )\n            goto LABEL_74;\n          ++v18;\n          v19 += v39 + 15;\n          goto LABEL_64;\n        }\n        v19 += 255;\n        ++v18;\n      }\n    }\n    break;\n  }\nLABEL_74:\n  *a10 = (unsigned int)&v17[-a9];\n  return -4;\n}\n"
        ],
        "134803011": [
            "sub_808EE43",
            "0x808ee43",
            "int __usercall sub_808EE43@<eax>(void *a1@<eax>)\n{\n  int result; // eax\n\n  result = 0;\n  memset(a1, 0, 0x34u);\n  return result;\n}\n"
        ],
        "134803027": [
            "sub_808EE53",
            "0x808ee53",
            "decompilation failure at 808EE53!\n"
        ],
        "134803100": [
            "sub_808EE9C",
            "0x808ee9c",
            "decompilation failure at 808EE9C!\n"
        ],
        "134803236": [
            "sub_808EF24",
            "0x808ef24",
            "int __fastcall sub_808EF24(int a1, int a2)\n{\n  if ( a1 != sub_808EE9C(a1, a2) )\n    sub_804D604();\n  return a1;\n}\n"
        ],
        "134803257": [
            "sub_808EF39",
            "0x808ef39",
            "decompilation failure at 808EF39!\n"
        ],
        "134803329": [
            "sub_808EF81",
            "0x808ef81",
            "decompilation failure at 808EF81!\n"
        ],
        "134803348": [
            "sub_808EF94",
            "0x808ef94",
            "decompilation failure at 808EF94!\n"
        ],
        "134803423": [
            "sub_808EFDF",
            "0x808efdf",
            "decompilation failure at 808EFDF!\n"
        ],
        "134803524": [
            "sub_808F044",
            "0x808f044",
            "decompilation failure at 808F044!\n"
        ],
        "134803630": [
            "sub_808F0AE",
            "0x808f0ae",
            "decompilation failure at 808F0AE!\n"
        ],
        "134803725": [
            "sub_808F10D",
            "0x808f10d",
            "decompilation failure at 808F10D!\n"
        ],
        "134803796": [
            "sub_808F154",
            "0x808f154",
            "bool __usercall sub_808F154@<al>(int a1@<eax>)\n{\n  return **(_DWORD **)(a1 + 24) == 0;\n}\n"
        ],
        "134803806": [
            "sub_808F15E",
            "0x808f15e",
            "decompilation failure at 808F15E!\n"
        ],
        "134803835": [
            "sub_808F17B",
            "0x808f17b",
            "decompilation failure at 808F17B!\n"
        ],
        "134804222": [
            "nullsub_1",
            "0x808f2fe",
            "void nullsub_1()\n{\n  ;\n}\n"
        ],
        "134804223": [
            "sub_808F2FF",
            "0x808f2ff",
            "int sub_808F2FF()\n{\n  sub_80B2E5A();\n  sub_80B40CC(63, 1);\n  sub_80AB6D3();\n  sub_80AB77C();\n  return 0;\n}\n"
        ],
        "134804266": [
            "sub_808F32A",
            "0x808f32a",
            "_BOOL4 sub_808F32A()\n{\n  return sub_804D846(\"\\x1B[H\\x1B[J\") != 6;\n}\n"
        ],
        "134804286": [
            "sub_808F33E",
            "0x808f33e",
            "decompilation failure at 808F33E!\n"
        ],
        "134804356": [
            "sub_808F384",
            "0x808f384",
            "decompilation failure at 808F384!\n"
        ],
        "134804510": [
            "sub_808F41E",
            "0x808f41e",
            "decompilation failure at 808F41E!\n"
        ],
        "134805529": [
            "sub_808F819",
            "0x808f819",
            "decompilation failure at 808F819!\n"
        ],
        "134805721": [
            "sub_808F8D9",
            "0x808f8d9",
            "decompilation failure at 808F8D9!\n"
        ],
        "134805764": [
            "sub_808F904",
            "0x808f904",
            "decompilation failure at 808F904!\n"
        ],
        "134806162": [
            "sub_808FA92",
            "0x808fa92",
            "decompilation failure at 808FA92!\n"
        ],
        "134806209": [
            "sub_808FAC1",
            "0x808fac1",
            "decompilation failure at 808FAC1!\n"
        ],
        "134806230": [
            "sub_808FAD6",
            "0x808fad6",
            "decompilation failure at 808FAD6!\n"
        ],
        "134806442": [
            "sub_808FBAA",
            "0x808fbaa",
            "decompilation failure at 808FBAA!\n"
        ],
        "134806515": [
            "sub_808FBF3",
            "0x808fbf3",
            "decompilation failure at 808FBF3!\n"
        ],
        "134806649": [
            "sub_808FC79",
            "0x808fc79",
            "decompilation failure at 808FC79!\n"
        ],
        "134806732": [
            "sub_808FCCC",
            "0x808fccc",
            "decompilation failure at 808FCCC!\n"
        ],
        "134806875": [
            "sub_808FD5B",
            "0x808fd5b",
            "decompilation failure at 808FD5B!\n"
        ],
        "134807293": [
            "sub_808FEFD",
            "0x808fefd",
            "decompilation failure at 808FEFD!\n"
        ],
        "134807351": [
            "sub_808FF37",
            "0x808ff37",
            "decompilation failure at 808FF37!\n"
        ],
        "134807521": [
            "sub_808FFE1",
            "0x808ffe1",
            "decompilation failure at 808FFE1!\n"
        ],
        "134807663": [
            "sub_809006F",
            "0x809006f",
            "int __userpurge sub_809006F@<eax>(const char *a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4)\n{\n  int v6; // ebx\n  int v7; // esi\n  int v8; // edx\n\n  v6 = *a3;\n  if ( *a3 == -1 )\n    v6 = *(_DWORD *)(a2 + 24);\n  v7 = a3[1];\n  if ( v7 == -1 )\n    v7 = *(_DWORD *)(a2 + 28);\n  if ( ((int (__cdecl *)(const char *, int, int))a3[2])(a1, v6, v7) )\n  {\n    v8 = 0;\n    if ( (dword_80DBB9C & 0x10) == 0 )\n    {\n      sub_804D3F1(a1);\n      return 0;\n    }\n  }\n  else if ( (dword_80DBB9C & 4) != 0\n         || (v8 = 1, (dword_80DBB9C & 8) != 0) && (*(_DWORD *)(a2 + 24) != v6 || *(_DWORD *)(a2 + 28) != v7) )\n  {\n    printf(\"changed ownership of '%s' to %u:%u\\n\", a1, v6, v7);\n    return 1;\n  }\n  return v8;\n}\n"
        ],
        "134807786": [
            "sub_80900EA",
            "0x80900ea",
            "int __cdecl sub_80900EA(int a1, int a2)\n{\n  char v2; // al\n  _DWORD *v3; // esi\n  int v4; // edi\n  int v6; // [esp-4h] [ebp-20h]\n  int v7; // [esp+0h] [ebp-1Ch] BYREF\n  int (*v8)(const char *, __uid_t, __gid_t); // [esp+8h] [ebp-14h]\n\n  v2 = sub_80ABEAC(a2, \"^RhvcfLHP\");\n  v3 = (_DWORD *)(a2 + 4 * optind);\n  v8 = chown;\n  if ( (v2 & 2) != 0 || (v2 & 0x61) == 1 )\n    v8 = lchown;\n  sub_80B48BE(v6, *v3);\n  v4 = 0;\n  while ( *++v3 )\n  {\n    if ( !sub_80B2549(sub_809006F, &v7, 0) )\n      v4 = 1;\n  }\n  return v4;\n}\n"
        ],
        "134807937": [
            "sub_8090181",
            "0x8090181",
            "void __cdecl __noreturn sub_8090181(int a1, _DWORD *a2)\n{\n  const char *v2; // eax\n\n  v2 = (const char *)a2[1];\n  if ( !v2 )\n    sub_804CDC2();\n  sub_804DF35(v2);\n  if ( !a2[2] )\n  {\n    *a2 = sub_80AB879();\n    a2[1] = 135047570;\n  }\n  sub_80AB1EC();\n}\n"
        ],
        "134807989": [
            "sub_80901B5",
            "0x80901b5",
            "void __thiscall __noreturn sub_80901B5(void *this, int a2, int a3)\n{\n  _DWORD *v3; // ebx\n  int v4; // esi\n  ssize_t v5; // eax\n  unsigned __int64 v6; // rdi\n  int v7; // eax\n  int v8; // eax\n  int v9; // ebp\n  const char *v10; // eax\n  __int64 v11; // [esp+0h] [ebp-20h]\n  int v12; // [esp+Ch] [ebp-14h]\n\n  v12 = sub_80AA37D(this, 1);\n  sub_80ABEAC(a3, &data);\n  v3 = (_DWORD *)(a3 + 4 * optind);\n  while ( 1 )\n  {\n    v4 = sub_80B3DAA();\n    if ( v4 >= 0 )\n    {\n      v11 = 0LL;\n      do\n      {\n        v5 = sub_804E5BC(0x400u, &buf, v4);\n        if ( v5 <= 0 )\n        {\n          close(v4);\n          v6 = __PAIR64__(v11, HIDWORD(v11));\n          v7 = 0;\n          while ( v6 )\n          {\n            byte_80DB777[++v7] = BYTE4(v6);\n            HIDWORD(v6) = __PAIR64__(v6, HIDWORD(v6)) >> 8;\n            LODWORD(v6) = (unsigned int)v6 >> 8;\n          }\n          v4 = -1;\n        }\n        else\n        {\n          v11 += v5;\n        }\n        v8 = sub_80AA3F3(v12);\n      }\n      while ( v4 != -1 );\n      v9 = ~v8;\n      v10 = \"%u %llu %s\\n\";\n      if ( !*v3 )\n        v10 = \"%u %llu\\n\";\n      printf(v10, v9, v11, *v3);\n    }\n    if ( *v3 )\n    {\n      if ( *++v3 )\n        continue;\n    }\n    sub_80AB247();\n  }\n}\n"
        ],
        "134808265": [
            "sub_80902C9",
            "0x80902c9",
            "int __cdecl sub_80902C9(int a1, int a2)\n{\n  int v2; // eax\n  int v3; // edx\n  const char **v4; // esi\n  const char *v5; // edi\n  int (__cdecl *v6)(_DWORD, _DWORD); // ecx\n  int v7; // eax\n  int v8; // ecx\n  char *v9; // ebp\n  int v10; // ebx\n  char *v11; // eax\n  int v12; // ecx\n  int v14; // [esp+0h] [ebp-D8h]\n  int v15; // [esp+4h] [ebp-D4h]\n  int v16; // [esp+4h] [ebp-D4h]\n  char v17[96]; // [esp+8h] [ebp-D0h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^pdRfilsLHarPvuT\");\n  v3 = a1 - optind;\n  v4 = (const char **)(a2 + 4 * optind);\n  v14 = v2 ^ 2;\n  if ( ((v2 ^ 2) & 0x80) != 0 )\n    v14 = v2 | 2;\n  v5 = v4[v3 - 1];\n  if ( v3 == 2 )\n  {\n    v6 = stat64;\n    if ( (v14 & 2) == 0 )\n      v6 = lstat64;\n    v15 = sub_809A567(v6, v17);\n    if ( v15 < 0 )\n      return 1;\n    v7 = sub_809A5B0();\n    if ( v7 < 0 )\n      return 1;\n    v8 = v14 & 0x4000;\n    if ( (v14 & 0x4000) != 0 && (v15 & 2) == 0 && (v7 & 2) != 0 )\n      sub_804D5E0(\"'%s' is a directory\", v5);\n    v9 = (char *)v5;\n    v10 = ((unsigned __int8)v7 | (unsigned __int8)v15) & 2;\n    if ( (((unsigned __int8)v7 | (unsigned __int8)v15) & 2) == 0 )\n      goto LABEL_21;\n    if ( (v14 & 4) != 0 && (v15 & 2) != 0 && !v7 || (v14 & 0x4000) != 0 )\n    {\n      v9 = (char *)v5;\n      v10 = 0;\n      goto LABEL_21;\n    }\n  }\n  else\n  {\n    v8 = v14 & 0x4000;\n    if ( (v14 & 0x4000) != 0 )\n      sub_804D5E0(\"too many arguments\");\n  }\n  while ( 1 )\n  {\n    v16 = v8;\n    v11 = sub_804D34F(*v4, v8);\n    v9 = (char *)sub_804D2D1((int)v5, v11, v12);\n    v10 = v16;\nLABEL_21:\n    if ( sub_80A9C77(v14) < 0 )\n      v10 = 1;\n    if ( v4[1] == v5 )\n      break;\n    free(v9);\n    v8 = v10;\n    ++v4;\n  }\n  return v10;\n}\n"
        ],
        "134808591": [
            "sub_809040F",
            "0x809040f",
            "int __cdecl sub_809040F(_DWORD *a1, _DWORD *a2)\n{\n  return *a1 - *a2;\n}\n"
        ],
        "134808604": [
            "sub_809041C",
            "0x809041c",
            "void __cdecl __noreturn sub_809041C(int a1, int a2)\n{\n  char v2; // al\n  int *v3; // ebx\n  char *v4; // eax\n  char *v5; // eax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // edi\n  int v9; // eax\n  int v10; // esi\n  int v11; // eax\n  int *v12; // eax\n  char *v13; // eax\n  char v14; // si\n  int v15; // edi\n  signed int v16; // esi\n  int v17; // eax\n  char *v18; // edx\n  unsigned int v19; // ebp\n  char *v20; // ecx\n  int v21; // eax\n  int v22; // edx\n  int v23; // ecx\n  char *v24; // ebp\n  int v25; // edi\n  int v26; // esi\n  unsigned __int8 *v27; // edx\n  int v28; // eax\n  _BYTE *v29; // edx\n  int v30; // [esp-4h] [ebp-40h]\n  int v31; // [esp+0h] [ebp-3Ch]\n  int nmemb; // [esp+4h] [ebp-38h]\n  unsigned __int8 v33; // [esp+Bh] [ebp-31h]\n  _DWORD *v34; // [esp+Ch] [ebp-30h]\n  _BYTE *ptr; // [esp+10h] [ebp-2Ch]\n  char *s; // [esp+14h] [ebp-28h]\n  int i; // [esp+18h] [ebp-24h]\n  signed int v38; // [esp+1Ch] [ebp-20h]\n  int v39; // [esp+1Ch] [ebp-20h]\n  int v40; // [esp+2Ch] [ebp-10h]\n  char delim[2]; // [esp+36h] [ebp-6h] BYREF\n  char *stringp; // [esp+38h] [ebp-4h] BYREF\n  char *v43; // [esp+3Ch] [ebp+0h] BYREF\n  char *v44; // [esp+40h] [ebp+4h] BYREF\n\n  v2 = sub_80ABEAC(a2, \"^b:c:f:d:sn\", &stringp, &stringp, &stringp);\n  v34 = (_DWORD *)(a2 + 4 * optind);\n  if ( (v2 & 7) == 0 )\n    sub_804D5E0(\"expected a list of bytes, characters, or fields\");\n  if ( (v2 & 8) != 0 )\n  {\n    v33 = *v43;\n    if ( *v43 && v43[1] )\n      sub_804D5E0(\"the delimiter must be a single character\");\n  }\n  else\n  {\n    v33 = 9;\n  }\n  if ( (v2 & 4) != 0 )\n  {\n    nmemb = 0;\n  }\n  else\n  {\n    nmemb = v2 & 0x10;\n    if ( (v2 & 0x10) != 0 )\n      sub_804D5E0(\"suppressing non-delimited lines makes sense%s\", \" only when operating on fields\");\n    if ( v33 != 9 )\n      sub_804D5E0(\"a delimiter may be specified%s\", \" only when operating on fields\");\n  }\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = strsep(&stringp, \",\");\n    v43 = v4;\n    if ( !v4 )\n      break;\n    if ( *v4 )\n    {\n      v5 = strsep(&v43, \"-\");\n      v6 = v30;\n      v7 = v31;\n      if ( *v5 && (v9 = sub_80B4187(v31, v30)) != 0 )\n        v8 = v9 - 1;\n      else\n        v8 = 0;\n      if ( !v43 )\n        goto LABEL_22;\n      v10 = 0x7FFFFFFF;\n      if ( *v43 )\n      {\n        v11 = sub_80B4187(v7, v6);\n        if ( !v11 )\n          v11 = 0x7FFFFFFF;\n        v10 = v11 - 1;\n        if ( v8 == v11 - 1 )\nLABEL_22:\n          v10 = -1;\n      }\n      v3 = (int *)sub_80B4733(nmemb, 2052);\n      v12 = &v3[2 * nmemb];\n      *v12 = v8;\n      v12[1] = v10;\n      ++nmemb;\n    }\n  }\n  if ( !nmemb )\n    sub_804D5E0(\"missing list of positions\");\n  qsort(v3, nmemb, 8u, (__compar_fn_t)sub_809040F);\n  if ( !*v34 )\n    *--v34 = \"-\";\n  while ( !sub_80B3D76(nmemb) )\n  {\nLABEL_80:\n    if ( !*++v34 )\n      sub_80AB247();\n  }\n  for ( i = 0; ; ++i )\n  {\n    v13 = (char *)sub_80AB85A();\n    v44 = v13;\n    if ( !v13 )\n    {\n      sub_80AB218();\n      goto LABEL_80;\n    }\n    v38 = strlen(v13);\n    ptr = sub_804DB2E(v38 + 1);\n    s = v44;\n    v14 = dword_80DBB9C;\n    if ( (dword_80DBB9C & 3) != 0 )\n    {\n      v15 = 0;\n      do\n      {\n        v16 = v3[2 * v15];\n        do\n        {\n          v17 = _stdout;\n          v18 = *(char **)(_stdout + 16);\n          v19 = *(_DWORD *)(_stdout + 28);\n          if ( v38 <= v16 )\n            break;\n          if ( !ptr[v16] )\n          {\n            ptr[v16] = 88;\n            v20 = &v44[v16];\n            if ( (unsigned int)v18 >= v19 )\n            {\n              __fputc_unlocked((unsigned __int8)*v20, v17);\n            }\n            else\n            {\n              *(_DWORD *)(v17 + 16) = v18 + 1;\n              *v18 = *v20;\n            }\n          }\n          ++v16;\n        }\n        while ( v16 <= v3[2 * v15 + 1] );\n        ++v15;\n      }\n      while ( v15 != nmemb );\n    }\n    else\n    {\n      if ( v33 == 10 )\n      {\n        v21 = *v3;\n        v22 = 0;\n        if ( *v3 > i )\n          goto LABEL_78;\n        while ( i > v21 )\n        {\n          ++v21;\n          v23 = v3[2 * v22 + 1];\n          if ( v23 == -1 || v21 > v23 )\n          {\n            if ( ++v22 == nmemb )\n              goto LABEL_78;\n            v21 = v3[2 * v22];\n            if ( i < v21 )\n              goto LABEL_78;\n          }\n        }\nLABEL_56:\n        puts(s);\n        goto LABEL_78;\n      }\n      delim[0] = v33;\n      delim[1] = 0;\n      if ( !strchr(v44, v33) )\n      {\n        if ( (v14 & 0x10) != 0 )\n          goto LABEL_78;\n        goto LABEL_56;\n      }\n      v24 = 0;\n      v40 = 0;\n      v25 = -1;\n      v26 = 0;\n      do\n      {\n        if ( !v44 )\n          break;\n        v39 = v3[2 * v26];\n        do\n        {\n          while ( v44 && v25 < v39 )\n          {\n            v24 = strsep(&v44, delim);\n            ++v25;\n          }\n          if ( v25 == v39 && v24 && !ptr[v25] )\n          {\n            if ( v40 )\n            {\n              v27 = *(unsigned __int8 **)(_stdout + 16);\n              if ( (unsigned int)v27 >= *(_DWORD *)(_stdout + 28) )\n              {\n                __fputc_unlocked(v33, _stdout);\n              }\n              else\n              {\n                *(_DWORD *)(_stdout + 16) = v27 + 1;\n                *v27 = v33;\n              }\n            }\n            fputs_unlocked(v24, stdout);\n            ptr[v25] = 88;\n            ++v40;\n          }\n          ++v39;\n          v28 = v3[2 * v26 + 1];\n        }\n        while ( v39 <= v28 && v44 && v28 != -1 );\n        ++v26;\n      }\n      while ( v26 != nmemb );\n    }\n    v29 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v29 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked(10, _stdout);\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v29 + 1;\n      *v29 = 10;\n    }\nLABEL_78:\n    free(ptr);\n    free(s);\n  }\n}\n"
        ],
        "134809595": [
            "sub_80907FB",
            "0x80907fb",
            "decompilation failure at 80907FB!\n"
        ],
        "134810325": [
            "sub_8090AD5",
            "0x8090ad5",
            "decompilation failure at 8090AD5!\n"
        ],
        "134810415": [
            "sub_8090B2F",
            "0x8090b2f",
            "decompilation failure at 8090B2F!\n"
        ],
        "134810506": [
            "sub_8090B8A",
            "0x8090b8a",
            "decompilation failure at 8090B8A!\n"
        ],
        "134810574": [
            "sub_8090BCE",
            "0x8090bce",
            "decompilation failure at 8090BCE!\n"
        ],
        "134812027": [
            "sub_809117B",
            "0x809117b",
            "decompilation failure at 809117B!\n"
        ],
        "134812797": [
            "sub_809147D",
            "0x809147d",
            "decompilation failure at 809147D!\n"
        ],
        "134812825": [
            "sub_8091499",
            "0x8091499",
            "decompilation failure at 8091499!\n"
        ],
        "134813249": [
            "sub_8091641",
            "0x8091641",
            "decompilation failure at 8091641!\n"
        ],
        "134813306": [
            "sub_809167A",
            "0x809167a",
            "decompilation failure at 809167A!\n"
        ],
        "134813687": [
            "sub_80917F7",
            "0x80917f7",
            "decompilation failure at 80917F7!\n"
        ],
        "134813978": [
            "sub_809191A",
            "0x809191a",
            "decompilation failure at 809191A!\n"
        ],
        "134814290": [
            "sub_8091A52",
            "0x8091a52",
            "decompilation failure at 8091A52!\n"
        ],
        "134814473": [
            "sub_8091B09",
            "0x8091b09",
            "_BOOL4 __usercall sub_8091B09@<eax>(int a1@<eax>)\n{\n  _BYTE *v1; // edx\n  _BOOL4 result; // eax\n\n  v1 = *(_BYTE **)(a1 + 4);\n  if ( !*(_BYTE *)a1 )\n    return *(_QWORD *)(a1 + 4) == 0LL;\n  result = 1;\n  if ( *v1 )\n  {\n    result = 0;\n    if ( *v1 == 48 )\n      return v1[1] == 0;\n  }\n  return result;\n}\n"
        ],
        "134814515": [
            "sub_8091B33",
            "0x8091b33",
            "decompilation failure at 8091B33!\n"
        ],
        "134814551": [
            "sub_8091B57",
            "0x8091b57",
            "_DWORD *__usercall sub_8091B57@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v2; // ebx\n\n  v2 = sub_804DB2E(0xCu);\n  *(_BYTE *)v2 = 1;\n  v2[1] = sub_804DB46(a1);\n  return v2;\n}\n"
        ],
        "134814585": [
            "sub_8091B79",
            "0x8091b79",
            "decompilation failure at 8091B79!\n"
        ],
        "134814679": [
            "sub_8091BD7",
            "0x8091bd7",
            "decompilation failure at 8091BD7!\n"
        ],
        "134814885": [
            "sub_8091CA5",
            "0x8091ca5",
            "decompilation failure at 8091CA5!\n"
        ],
        "134814911": [
            "sub_8091CBF",
            "0x8091cbf",
            "decompilation failure at 8091CBF!\n"
        ],
        "134814961": [
            "sub_8091CF1",
            "0x8091cf1",
            "decompilation failure at 8091CF1!\n"
        ],
        "134815198": [
            "sub_8091DDE",
            "0x8091dde",
            "int sub_8091DDE()\n{\n  int v0; // ebx\n  int v1; // edi\n\n  v0 = sub_809214F();\n  while ( sub_8091CBF() )\n  {\n    buf += 4;\n    sub_809214F();\n    v1 = sub_8091CF1();\n    sub_8091CA5();\n    sub_8091CA5();\n    v0 = v1;\n  }\n  return v0;\n}\n"
        ],
        "134815271": [
            "sub_8091E27",
            "0x8091e27",
            "char *sub_8091E27()\n{\n  char *i; // ebx\n  int v1; // esi\n  int v2; // ebp\n  __int64 v3; // kr00_8\n\n  for ( i = (char *)sub_8091DDE(); ; *(_QWORD *)(i + 4) = v3 )\n  {\n    v1 = sub_8091CBF();\n    if ( !v1 )\n    {\n      v1 = sub_8091CBF();\n      if ( !v1 )\n      {\n        v1 = sub_8091CBF();\n        if ( !v1 )\n          break;\n      }\n    }\n    buf += 4;\n    v2 = sub_8091DDE();\n    v3 = sub_8091BD7(v1, v2);\n    sub_8091CA5();\n    sub_8091CA5();\n    i = (char *)sub_804DB2E(0xCu);\n  }\n  return i;\n}\n"
        ],
        "134815400": [
            "sub_8091EA8",
            "0x8091ea8",
            "char *sub_8091EA8()\n{\n  char *i; // ebx\n  int v1; // esi\n  char *v2; // ebp\n  __int64 v3; // kr00_8\n\n  for ( i = sub_8091E27(); ; *(_QWORD *)(i + 4) = v3 )\n  {\n    v1 = sub_8091CBF();\n    if ( !v1 )\n    {\n      v1 = sub_8091CBF();\n      if ( !v1 )\n        break;\n    }\n    buf += 4;\n    v2 = sub_8091E27();\n    v3 = sub_8091BD7(v1, v2);\n    sub_8091CA5();\n    sub_8091CA5();\n    i = (char *)sub_804DB2E(0xCu);\n  }\n  return i;\n}\n"
        ],
        "134815513": [
            "sub_8091F19",
            "0x8091f19",
            "decompilation failure at 8091F19!\n"
        ],
        "134815889": [
            "sub_8092091",
            "0x8092091",
            "_DWORD *sub_8092091()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n\n  v0 = (_DWORD *)sub_8091F19();\n  while ( sub_8091CBF() )\n  {\n    buf += 4;\n    v1 = sub_8091F19();\n    if ( sub_8091B09((int)v0) || sub_8091B09(v1) )\n    {\n      sub_8091CA5();\n      sub_8091CA5();\n      v0 = sub_804DB2E(0xCu);\n      v0[1] = 0;\n      v0[2] = 0;\n    }\n    else\n    {\n      sub_8091CA5();\n    }\n  }\n  return v0;\n}\n"
        ],
        "134816004": [
            "sub_8092104",
            "0x8092104",
            "_DWORD *sub_8092104()\n{\n  _DWORD *v0; // ebx\n  _DWORD *v1; // esi\n\n  v0 = sub_8092091();\n  while ( sub_8091CBF() )\n  {\n    buf += 4;\n    v1 = sub_8092091();\n    if ( sub_8091B09((int)v0) )\n    {\n      sub_8091CA5();\n    }\n    else\n    {\n      sub_8091CA5();\n      v1 = v0;\n    }\n    v0 = v1;\n  }\n  return v0;\n}\n"
        ],
        "134816079": [
            "sub_809214F",
            "0x809214f",
            "decompilation failure at 809214F!\n"
        ],
        "134816692": [
            "sub_80923B4",
            "0x80923b4",
            "decompilation failure at 80923B4!\n"
        ],
        "134817070": [
            "sub_809252E",
            "0x809252e",
            "decompilation failure at 809252E!\n"
        ],
        "134817135": [
            "sub_809256F",
            "0x809256f",
            "decompilation failure at 809256F!\n"
        ],
        "134817243": [
            "sub_80925DB",
            "0x80925db",
            "int sub_80925DB()\n{\n  return 1;\n}\n"
        ],
        "134817249": [
            "sub_80925E1",
            "0x80925e1",
            "unsigned int __usercall sub_80925E1@<eax>(int a1@<eax>, char a2@<dl>)\n{\n  int v2; // ecx\n  int v4; // eax\n\n  v2 = dword_80DBB9C & 1;\n  if ( (dword_80DBB9C & 1) != 0 )\n    return a1 + 1;\n  switch ( a2 )\n  {\n    case 9:\n      return (a1 & 0xFFFFFFF8) + 8;\n    case 8:\n      v4 = a1 - 1;\n      if ( v4 >= 0 )\n        return v4;\n      break;\n    case 13:\n      break;\n    default:\n      return a1 + 1;\n  }\n  return v2;\n}\n"
        ],
        "134817297": [
            "sub_8092611",
            "0x8092611",
            "decompilation failure at 8092611!\n"
        ],
        "134817316": [
            "sub_8092624",
            "0x8092624",
            "decompilation failure at 8092624!\n"
        ],
        "134817855": [
            "sub_809283F",
            "0x809283f",
            "decompilation failure at 809283F!\n"
        ],
        "134818681": [
            "sub_8092B79",
            "0x8092b79",
            "decompilation failure at 8092B79!\n"
        ],
        "134818719": [
            "sub_8092B9F",
            "0x8092b9f",
            "decompilation failure at 8092B9F!\n"
        ],
        "134818918": [
            "sub_8092C66",
            "0x8092c66",
            "decompilation failure at 8092C66!\n"
        ],
        "134818942": [
            "sub_8092C7E",
            "0x8092c7e",
            "decompilation failure at 8092C7E!\n"
        ],
        "134818966": [
            "sub_8092C96",
            "0x8092c96",
            "void __cdecl __noreturn sub_8092C96(int a1, int a2)\n{\n  int v2; // eax\n  __gid_t v3; // esi\n  __gid_t v4; // edi\n  __uid_t v5; // ebp\n  int v6; // ebx\n  int v7; // ebx\n  void *v8; // ebp\n  int i; // ecx\n  int v10; // eax\n  int v11; // ebx\n  int v12; // [esp+0h] [ebp-20h]\n  __uid_t v13; // [esp+4h] [ebp-1Ch]\n  int v14; // [esp+8h] [ebp-18h]\n  int ngroups[5]; // [esp+Ch] [ebp-14h] BYREF\n\n  v12 = sub_80ABEAC(a2, \"^rnugG\");\n  if ( *(_DWORD *)(a2 + 4 * optind) )\n  {\n    v2 = sub_80A999C();\n    v3 = *(_DWORD *)(v2 + 12);\n    if ( !v12 )\n    {\n      v11 = sub_8092C66();\n      v7 = sub_8092C7E() | v11;\n      v4 = v3;\n      goto LABEL_13;\n    }\n    v4 = *(_DWORD *)(v2 + 12);\n  }\n  else\n  {\n    v4 = getegid();\n    v3 = getgid();\n    v13 = geteuid();\n    v5 = getuid();\n    if ( !v12 )\n    {\n      v6 = sub_8092C66();\n      v7 = sub_8092C7E() | v6;\n      if ( v13 != v5 )\n        v7 |= sub_8092C66();\n      if ( v4 == v3 )\n        goto LABEL_13;\n      goto LABEL_12;\n    }\n  }\n  if ( (v12 & 0x10) == 0 )\n    goto LABEL_25;\n  v7 = sub_8092C7E();\n  if ( v4 == v3 )\n  {\nLABEL_13:\n    v8 = sub_804DAFA(0x100u);\n    ngroups[0] = 64;\n    if ( (int)sub_8092B9F((__gid_t *)v8, v3, ngroups) < 0 )\n    {\n      v8 = sub_804DB13(v8, 4 * ngroups[0]);\n      sub_8092B9F((__gid_t *)v8, v3, ngroups);\n    }\n    if ( ngroups[0] <= 0 )\n    {\n      if ( ngroups[0] )\n        sub_804D5E0(\"can't get groups\");\n    }\n    else\n    {\n      for ( i = 0; ngroups[0] > i; ++i )\n      {\n        v10 = *((_DWORD *)v8 + i);\n        if ( !v12 || v10 != v3 && v10 != v4 )\n        {\n          v14 = i;\n          v7 |= sub_8092C7E();\n          i = v14;\n        }\n      }\n    }\nLABEL_25:\n    if ( (v12 & 4) != 0 )\n    {\n      sub_8092C66();\n    }\n    else if ( (v12 & 8) != 0 )\n    {\n      sub_8092C7E();\n    }\n    sub_804DD98(10);\n    sub_80AB247();\n  }\nLABEL_12:\n  v7 |= sub_8092C7E();\n  goto LABEL_13;\n}\n"
        ],
        "134819445": [
            "sub_8092E75",
            "0x8092e75",
            "int __cdecl sub_8092E75(int a1, int a2)\n{\n  __int16 v2; // bp\n  int v3; // ebx\n  int v4; // edi\n  __uid_t v5; // eax\n  __gid_t v6; // eax\n  const char **v7; // edx\n  const char *v8; // eax\n  int v9; // eax\n  int v10; // esi\n  const char *v11; // ebx\n  char *v12; // eax\n  char *v13; // eax\n  int v14; // ecx\n  char *file; // [esp+0h] [ebp-B4h]\n  int v17; // [esp+4h] [ebp-B0h]\n  int v18; // [esp+8h] [ebp-ACh]\n  int v19; // [esp+Ch] [ebp-A8h]\n  char *ptr; // [esp+10h] [ebp-A4h]\n  int mode; // [esp+14h] [ebp-A0h]\n  __uid_t owner; // [esp+18h] [ebp-9Ch]\n  __gid_t group; // [esp+1Ch] [ebp-98h]\n  const char *v24; // [esp+24h] [ebp-90h] BYREF\n  int v25; // [esp+28h] [ebp-8Ch] BYREF\n  int v26; // [esp+2Ch] [ebp-88h] BYREF\n  int v27[5]; // [esp+30h] [ebp-84h] BYREF\n  char v28[16]; // [esp+44h] [ebp-70h] BYREF\n  int v29; // [esp+54h] [ebp-60h]\n\n  v2 = sub_80ABEC2(a2, \"^cvbDdpsg:m:o:t:\", \"verbose\", &v25, v27, &v26, &v24);\n  v3 = a1 - optind;\n  v19 = a2 + 4 * optind;\n  v4 = (v2 & 2) == 0 ? 10 : 4106;\n  v17 = (v2 & 2) == 0 ? 4 : 4100;\n  if ( (v2 & 0x20) != 0 )\n    v4 |= 1u;\n  mode = 493;\n  if ( (v2 & 0x100) != 0 )\n    mode = sub_80B07AF();\n  if ( (v2 & 0x200) != 0 )\n    v5 = sub_80A9A55();\n  else\n    v5 = getuid();\n  owner = v5;\n  if ( (v2 & 0x80) != 0 )\n    v6 = sub_80A9A55();\n  else\n    v6 = getgid();\n  group = v6;\n  v18 = v2 & 0x410;\n  if ( (v2 & 0x410) != 0 )\n  {\n    v9 = v2 & 0x400;\n    goto LABEL_15;\n  }\n  --v3;\n  v7 = (const char **)(v19 + 4 * v3);\n  v24 = *v7;\n  v8 = v24;\n  *v7 = 0;\n  if ( stat64(v8, v28) >= 0 )\n  {\n    v9 = (v29 & 0xF000) == 0x4000;\nLABEL_15:\n    v18 = v9;\n  }\n  if ( v3 <= 0 )\n    sub_804CDC2();\n  v10 = 0;\n  while ( 1 )\n  {\n    v19 += 4;\n    file = *(char **)(v19 - 4);\n    if ( !file )\n      return v10;\n    if ( (v2 & 0x10) != 0 )\n    {\n      if ( sub_80B00B9(v17, 493) )\n        goto LABEL_38;\n      v11 = file;\n      goto LABEL_33;\n    }\n    v11 = v24;\n    if ( (v2 & 8) != 0 )\n    {\n      v12 = sub_804DB46(v24);\n      ptr = v12;\n      if ( (v2 & 0x400) == 0 )\n        dirname(v12);\n      sub_80B00B9(v17, 493);\n      free(ptr);\n    }\n    if ( v18 )\n    {\n      v13 = sub_804D315(file);\n      v11 = (const char *)sub_804D2D1((int)v24, v13, v14);\n    }\n    if ( sub_80A9C77(v4) )\n    {\nLABEL_38:\n      v10 = 1;\n    }\n    else\n    {\n      if ( (v2 & 0x40) != 0 )\n      {\n        v27[1] = (int)\"strip\";\n        v27[2] = (int)\"-p\";\n        v27[3] = (int)v11;\n        v27[4] = 0;\n        if ( sub_80B3C03(file, v17, v18, v19, ptr, mode) )\n        {\n          sub_804D3A5((int)\"strip\");\n          v10 = 1;\n        }\n      }\nLABEL_33:\n      if ( chmod(v11, mode) == -1 )\n      {\n        sub_804D3A5((int)\"can't change %s of %s\", \"permissions\", v11);\n        v10 = 1;\n      }\n      if ( (v2 & 0x280) != 0 && lchown(v11, owner, group) == -1 )\n      {\n        sub_804D3A5((int)\"can't change %s of %s\", \"ownership\", v11);\n        goto LABEL_38;\n      }\n    }\n  }\n}\n"
        ],
        "134820135": [
            "sub_8093127",
            "0x8093127",
            "int __cdecl sub_8093127(int a1, int a2)\n{\n  const char **v2; // ebx\n\n  sub_80ABEAC(a2, &unk_80D60E5);\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( link(*v2, v2[1]) )\n    sub_804D3C9((int)\"can't create %slink '%s' to '%s'\", \"hard\", v2[1], *v2);\n  return 0;\n}\n"
        ],
        "134820200": [
            "sub_8093168",
            "0x8093168",
            "int __cdecl sub_8093168(int a1, int a2)\n{\n  char *v2; // edi\n  const char **v3; // ebx\n  char *v4; // eax\n  int v5; // ecx\n  char *v6; // esi\n  int v7; // ecx\n  char *v8; // eax\n  int v9; // ecx\n  char *v10; // ebp\n  const char *v11; // esi\n  char v13; // [esp+0h] [ebp-90h]\n  int ptr; // [esp+4h] [ebp-8Ch]\n  int (*v15)(const char *, const char *); // [esp+Ch] [ebp-84h]\n  char *v16; // [esp+18h] [ebp-78h]\n  char *v17; // [esp+1Ch] [ebp-74h] BYREF\n  char v18[16]; // [esp+20h] [ebp-70h] BYREF\n  int v19; // [esp+30h] [ebp-60h]\n\n  v17 = \"~\";\n  v13 = sub_80ABEAC(a2, \"^sfnbS:vT\", &v17);\n  v2 = *(char **)(a2 + 4 * a1 - 4);\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( a1 - optind > 2 && (v13 & 0x40) != 0 )\n    sub_804D5E0(\"-T accepts 2 args max\");\n  if ( !v3[1] )\n  {\n    *(v3 - 1) = v2;\n    v4 = sub_804DB46(v2);\n    v2 = sub_804D34F(v4, v5);\n    --v3;\n  }\n  v15 = link;\n  if ( (v13 & 1) != 0 )\n    v15 = symlink;\n  ptr = 0;\n  do\n  {\n    if ( sub_80AD83E() )\n    {\n      if ( (v13 & 0x40) != 0 )\n        sub_804D5E0(\"'%s' is a directory\", v2);\n      v6 = sub_804DB46(*v3);\n      v8 = sub_804D34F(v6, v7);\n      v10 = (char *)sub_804D2D1((int)v2, v8, v9);\n      free(v6);\n      v11 = v10;\n    }\n    else\n    {\n      v11 = v2;\n      v10 = 0;\n    }\n    if ( (v13 & 1) == 0 && stat64(*v3, v18) && (lstat64(*v3, v18) || (v19 & 0xF000) != 40960) )\n    {\n      sub_804D3F1(*v3);\n      free(v10);\nLABEL_23:\n      ptr = 1;\n      goto LABEL_32;\n    }\n    if ( (v13 & 8) != 0 )\n    {\n      v16 = sub_804DDBF(\"%s%s\", v11, v17);\n      if ( rename(v11, v16) < 0 && *(_DWORD *)dword_80DBB7C != 2 )\n      {\n        sub_804D3F1(v11);\n        free(v16);\n        goto LABEL_23;\n      }\n      free(v16);\n      unlink(v11);\n    }\n    else if ( (v13 & 2) != 0 )\n    {\n      unlink(v11);\n    }\n    if ( (v13 & 0x20) != 0 )\n      printf(\"'%s' -> '%s'\\n\", v11, *v3);\n    if ( v15(*v3, v11) )\n    {\n      sub_804D3F1(v11);\n      ptr = 1;\n    }\n    free(v10);\nLABEL_32:\n    ++v3;\n  }\n  while ( v3[1] );\n  return ptr;\n}\n"
        ],
        "134820720": [
            "sub_8093370",
            "0x8093370",
            "int __cdecl sub_8093370(int a1, int a2)\n{\n  char name[68]; // [esp+0h] [ebp-44h] BYREF\n\n  if ( *(_DWORD *)(a2 + 4) )\n    sub_804CDC2();\n  if ( getlogin_r(name, 0x40u) )\n    sub_804D3C9((int)\"getlogin\");\n  puts(name);\n  return sub_804DD8F();\n}\n"
        ],
        "134820783": [
            "sub_80933AF",
            "0x80933af",
            "char __usercall sub_80933AF@<al>(unsigned __int16 a1@<ax>)\n{\n  int v2; // ecx\n  char result; // al\n\n  if ( (dword_80DBB9C & 0x3000) == 0 )\n    return 0;\n  v2 = a1 & 0xF000;\n  result = 47;\n  if ( v2 != 0x4000 )\n  {\n    result = 0;\n    if ( (dword_80DBB9C & 0x1000) != 0 )\n    {\n      if ( v2 != 0x8000 )\n        return byte_80D6124[a1 >> 12];\n      result = 42;\n      if ( (a1 & 0x49) == 0 )\n        return byte_80D6124[a1 >> 12];\n    }\n  }\n  return result;\n}\n"
        ],
        "134820856": [
            "sub_80933F8",
            "0x80933f8",
            "decompilation failure at 80933F8!\n"
        ],
        "134820945": [
            "sub_8093451",
            "0x8093451",
            "void *__usercall sub_8093451@<eax>(int a1@<eax>)\n{\n  if ( a1 )\n    return sub_804DB2E(4 * a1 + 4);\n  else\n    return 0;\n}\n"
        ],
        "134820964": [
            "sub_8093464",
            "0x8093464",
            "int *__usercall sub_8093464@<eax>(int *a1@<eax>, int a2@<edx>)\n{\n  int *v2; // ebx\n  int v4; // eax\n  _DWORD *v5; // edi\n  int v6; // edx\n  int v7; // ecx\n  _BYTE *v8; // ebp\n  char v9; // al\n\n  v2 = a1;\n  if ( a1 )\n  {\n    v4 = sub_80933F8();\n    v5 = sub_8093451(v4);\n    v6 = 0;\n    while ( 1 )\n    {\n      v7 = *v2;\n      if ( !*v2 )\n        return v5;\n      if ( (*(_DWORD *)(v7 + 24) & 0xF000) != 0x4000 )\n        break;\n      if ( a2 )\n      {\n        v8 = *(_BYTE **)v7;\n        if ( a2 == 1 )\n          goto LABEL_13;\n        if ( *v8 != 46 )\n          goto LABEL_13;\n        v9 = v8[1];\n        if ( v9 )\n        {\n          if ( v9 != 46 || v8[2] )\n            goto LABEL_13;\n        }\n      }\nLABEL_14:\n      ++v2;\n    }\n    if ( a2 )\n      goto LABEL_14;\nLABEL_13:\n    v5[v6++] = v7;\n    goto LABEL_14;\n  }\n  return v2;\n}\n"
        ],
        "134821069": [
            "sub_80934CD",
            "0x80934cd",
            "decompilation failure at 80934CD!\n"
        ],
        "134821333": [
            "sub_80935D5",
            "0x80935d5",
            "int __usercall sub_80935D5@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int v2; // eax\n  char *v3; // esi\n  int v4; // ebx\n  _BYTE *v5; // edx\n  char *v6; // edx\n  char v7; // cl\n  _BYTE *v8; // edx\n  unsigned int v9; // edi\n  int v11; // [esp+8h] [ebp-10h]\n\n  v2 = sub_80B0C58(a2, a1);\n  v3 = (char *)v2;\n  if ( (dword_80DBB9C & 0x8000) != 0 )\n  {\n    v4 = v11 + 2;\n    v5 = *(_BYTE **)(_stdout + 16);\n    if ( (unsigned int)v5 >= *(_DWORD *)(_stdout + 28) )\n    {\n      __fputc_unlocked(34, _stdout);\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v5 + 1;\n      *v5 = 34;\n    }\n    while ( 1 )\n    {\n      v7 = *v3;\n      v8 = *(_BYTE **)(_stdout + 16);\n      v9 = *(_DWORD *)(_stdout + 28);\n      if ( !*v3 )\n        break;\n      if ( v7 == 34 || v7 == 92 )\n      {\n        if ( (unsigned int)v8 >= v9 )\n        {\n          __fputc_unlocked(92, _stdout);\n        }\n        else\n        {\n          *(_DWORD *)(_stdout + 16) = v8 + 1;\n          *v8 = 92;\n        }\n        ++v4;\n      }\n      v6 = *(char **)(_stdout + 16);\n      if ( (unsigned int)v6 >= *(_DWORD *)(_stdout + 28) )\n      {\n        __fputc_unlocked((unsigned __int8)*v3, _stdout);\n      }\n      else\n      {\n        *(_DWORD *)(_stdout + 16) = v6 + 1;\n        *v6 = *v3;\n      }\n      ++v3;\n    }\n    if ( (unsigned int)v8 >= v9 )\n    {\n      __fputc_unlocked(34, _stdout);\n    }\n    else\n    {\n      *(_DWORD *)(_stdout + 16) = v8 + 1;\n      *v8 = 34;\n    }\n  }\n  else\n  {\n    fputs_unlocked(v2, stdout);\n    return v11;\n  }\n  return v4;\n}\n"
        ],
        "134821552": [
            "sub_80936B0",
            "0x80936b0",
            "decompilation failure at 80936B0!\n"
        ],
        "134821570": [
            "sub_80936C2",
            "0x80936c2",
            "decompilation failure at 80936C2!\n"
        ],
        "134821777": [
            "sub_8093791",
            "0x8093791",
            "decompilation failure at 8093791!\n"
        ],
        "134822738": [
            "sub_8093B52",
            "0x8093b52",
            "decompilation failure at 8093B52!\n"
        ],
        "134823113": [
            "sub_8093CC9",
            "0x8093cc9",
            "decompilation failure at 8093CC9!\n"
        ],
        "134823633": [
            "sub_8093ED1",
            "0x8093ed1",
            "int __cdecl sub_8093ED1(int a1, int a2)\n{\n  int v2; // edx\n  int v3; // ebx\n  char *v4; // eax\n  int v5; // eax\n  int v6; // eax\n  _DWORD *v7; // esi\n  int v8; // ebx\n  int v9; // edi\n  unsigned int v10; // ecx\n  int v11; // eax\n  int *v12; // eax\n  int *v13; // ebp\n  int v14; // ebp\n  const char *v16; // [esp+0h] [ebp-14h] BYREF\n\n  v16 = \"always\";\n  memset(&buf, 0, 0xCu);\n  *(&buf + 1) = 80;\n  time((time_t *)&buf + 2);\n  *(&buf + 1) = sub_804D986(0, v2) - 1;\n  v3 = sub_80ABEC2(a2, \"^Cadi1lgnsxAkFpRQctuSXrvLHhT:w:\", \"full-time\", 0, &buf + 1, &v16);\n  if ( isatty(1) )\n  {\n    v4 = getenv(\"LS_COLORS\");\n    if ( !v4 || *v4 && strcmp(v4, \"none\") )\n      LOBYTE(buf) = 1;\n  }\n  if ( (v3 & 0x40000000) != 0 )\n  {\n    if ( *v16 == 110 )\n    {\n      LOBYTE(buf) = 0;\n    }\n    else\n    {\n      v5 = sub_804D254(\"always\", v16);\n      if ( v5 >= 0 && (v5 <= 2 || v5 <= 5 && isatty(1)) )\n        LOBYTE(buf) = 1;\n    }\n  }\n  v6 = dword_80DBB9C;\n  if ( (v3 & 4) != 0 )\n  {\n    BYTE1(v6) = BYTE1(dword_80DBB9C) & 0xBF;\n    dword_80DBB9C = v6;\n  }\n  if ( (v3 & 0x20) == 0 && (v3 & 0x50000) != 0 )\n    dword_80DBB9C |= 0x20000u;\n  if ( (dword_80DBB9C & 0x231) == 0 )\n    dword_80DBB9C |= isatty(1) == 0 ? 16 : 1;\n  v7 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v7 )\n    *--v7 = 135072092;\n  if ( v7[1] )\n    BYTE2(buf) = 1;\n  v8 = 0;\n  v9 = 0;\n  do\n  {\n    v10 = 1;\n    if ( (dword_80DBB9C & 0x1120) != 0 )\n      v10 = HIBYTE(dword_80DBB9C) & 1;\n    v11 = sub_80934CD(v10, *v7++);\n    if ( v11 )\n    {\n      *(_DWORD *)(v11 + 8) = v9;\n      ++v8;\n      v9 = v11;\n    }\n  }\n  while ( *v7 );\n  if ( v8 )\n  {\n    v12 = (int *)sub_8093451(v8);\n    v13 = v12;\n    do\n    {\n      *v12 = v9;\n      v9 = *(_DWORD *)(v9 + 8);\n      ++v12;\n    }\n    while ( v9 );\n    if ( (dword_80DBB9C & 4) != 0 )\n    {\n      sub_80936B0();\n      sub_8093B52();\n    }\n    else\n    {\n      sub_8093464(v13, 1);\n      sub_8093464(v13, 0);\n      v14 = sub_80933F8();\n      if ( v8 != v14 )\n      {\n        sub_80936B0();\n        sub_8093B52();\n      }\n      if ( v14 )\n      {\n        sub_80936B0();\n        sub_8093CC9();\n      }\n    }\n  }\n  return SBYTE1(buf);\n}\n"
        ],
        "134824184": [
            "sub_80940F8",
            "0x80940f8",
            "void *__usercall sub_80940F8@<eax>(const char *a1@<eax>, unsigned int a2@<edx>)\n{\n  int v3; // eax\n  int v4; // ebp\n  char v5; // al\n  void (*v6)(void); // esi\n  int (*v7)(); // edi\n  int v8; // ebx\n  ssize_t v9; // eax\n  void *v10; // esi\n  void *ptr; // [esp+0h] [ebp-E8h]\n\n  v3 = sub_80B3DAA();\n  if ( v3 < 0 )\n    return 0;\n  v4 = v3;\n  v5 = ident[3];\n  switch ( v5 )\n  {\n    case 's':\n      sub_80ACCF3();\n      v6 = (void (*)(void))sub_80ACD79;\n      v7 = (int (*)())sub_80ACD25;\n      v8 = 16;\n      break;\n    case '1':\n      sub_80ACD9C();\n      v6 = (void (*)(void))sub_80ACEAA;\n      v7 = (int (*)())sub_80ACD25;\n      v8 = 20;\n      break;\n    case '2':\n      sub_80ACDD5();\n      v6 = (void (*)(void))sub_80ACEAA;\n      v7 = (int (*)())sub_80ACD25;\n      v8 = 32;\n      break;\n    case '5':\n      sub_80ACDF2();\n      v6 = (void (*)(void))sub_80ACEEC;\n      v7 = sub_80ACE29;\n      v8 = 64;\n      break;\n    case '3':\n      sub_80ACFB1();\n      if ( a2 - 1 > 0x31E || (a2 & 0x1F) != 0 )\n        sub_804D5E0(\"bad -a%u\", a2);\n      v8 = a2 >> 3;\n      v6 = (void (*)(void))sub_80AD028;\n      v7 = sub_80ACFCB;\n      break;\n    default:\n      sub_804D604();\n  }\n  for ( ptr = sub_804DAFA(0x1000u); ; ((void (__fastcall *)(ssize_t, void *))v7)(v9, ptr) )\n  {\n    v9 = sub_804E5BC(0x1000u, ptr, v4);\n    if ( v9 <= 0 )\n      break;\n  }\n  if ( v9 )\n  {\n    sub_804D3A5((int)\"can't read '%s'\", a1);\n    v10 = 0;\n  }\n  else\n  {\n    v6();\n    v10 = sub_804DB2E(2 * v8 + 1);\n    sub_804D727((int)v10, (int)ptr, v8);\n  }\n  free(ptr);\n  if ( v4 )\n    close(v4);\n  return v10;\n}\n"
        ],
        "134824562": [
            "sub_8094272",
            "0x8094272",
            "int __cdecl sub_8094272(int a1, int a2)\n{\n  const char **v2; // ebx\n  int v3; // ebp\n  int v4; // esi\n  const char *v5; // eax\n  char *v6; // edi\n  char *v7; // eax\n  int v8; // edx\n  int v9; // eax\n  const char *v10; // eax\n  char *v11; // esi\n  char v13; // [esp+0h] [ebp-2Ch]\n  int i; // [esp+4h] [ebp-28h]\n  const char *v15; // [esp+8h] [ebp-24h]\n  char *s1; // [esp+Ch] [ebp-20h]\n  unsigned int v17[5]; // [esp+18h] [ebp-14h] BYREF\n\n  v17[0] = 224;\n  if ( ident[3] == 51 )\n    v13 = sub_80ABEAC(a2, \"^scwbta:+\", v17);\n  else\n    v13 = sub_80ABEAC(a2, \"^scwbt\");\n  v2 = (const char **)(a2 + 4 * optind);\n  if ( !*v2 )\n    *--v2 = \"-\";\n  v3 = 0;\n  do\n  {\n    if ( (v13 & 2) != 0 )\n    {\n      sub_80B3D9B();\n      v4 = 0;\n      for ( i = 0; ; ++i )\n      {\n        v5 = (const char *)sub_80AB85A();\n        v6 = (char *)v5;\n        if ( !v5 )\n          break;\n        v7 = strstr(v5, \"  \");\n        if ( v7 || (v7 = strstr(v6, \" *\")) != 0 )\n        {\n          *v7 = 0;\n          v15 = v7 + 2;\n          s1 = (char *)sub_80940F8(v7 + 2, v17[0]);\n          v8 = v13 & 1;\n          if ( !s1 || (v9 = strcmp(s1, v6), v8 = v13 & 1, v9) )\n          {\n            if ( !v8 )\n              printf(\"%s: FAILED\\n\", v15);\n            ++v4;\n            v3 = 1;\n          }\n          else if ( (v13 & 1) == 0 )\n          {\n            printf(\"%s: OK\\n\", v15);\n          }\n          free(s1);\n          free(v6);\n        }\n        else\n        {\n          if ( (v13 & 4) != 0 )\n            sub_804D5F4(\"invalid format\");\n          ++v4;\n          free(v6);\n          v3 = 1;\n        }\n      }\n      if ( v4 && (v13 & 1) == 0 )\n        sub_804D5F4(\"WARNING: %d of %d computed checksums did NOT match\", v4, i);\n      if ( !i )\n      {\n        sub_804D5F4(\"%s: no checksum lines found\", *v2);\n        v3 = 1;\n      }\n      sub_80AB218();\n    }\n    else\n    {\n      v10 = (const char *)sub_80940F8(*v2, v17[0]);\n      v11 = (char *)v10;\n      if ( v10 )\n      {\n        printf(\"%s  %s\\n\", v10, *v2);\n        free(v11);\n      }\n      else\n      {\n        v3 = 1;\n      }\n    }\n    ++v2;\n  }\n  while ( *v2 );\n  return v3;\n}\n"
        ],
        "134825037": [
            "sub_809444D",
            "0x809444d",
            "int __cdecl sub_809444D(int a1, int a2)\n{\n  const char *v2; // ecx\n  char v3; // bl\n  int v4; // edi\n  int v5; // esi\n  _DWORD *v6; // ebx\n  int v7; // ebp\n  const char *v9; // [esp+0h] [ebp-14h] BYREF\n\n  v9 = v2;\n  v3 = sub_80ABEC2(a2, \"m:pv\", \"mode\", &v9);\n  if ( (v3 & 1) != 0 )\n  {\n    v4 = sub_80B07AF();\n    if ( v4 == -1 )\n      sub_804D5E0(\"invalid mode '%s'\", v9);\n  }\n  else\n  {\n    v4 = -1;\n  }\n  v5 = (2 * v3) & 4;\n  if ( (v3 & 4) != 0 )\n    v5 |= 0x1000u;\n  v6 = (_DWORD *)(a2 + 4 * optind);\n  if ( !*v6 )\n    sub_804CDC2();\n  v7 = 0;\n  do\n  {\n    if ( sub_80B00B9(v5, v4) )\n      v7 = 1;\n    ++v6;\n  }\n  while ( *v6 );\n  return v7;\n}\n"
        ],
        "134825182": [
            "sub_80944DE",
            "0x80944de",
            "int __cdecl sub_80944DE(int a1, int a2)\n{\n  __mode_t v2; // edi\n  const char **v3; // ebx\n  int v4; // esi\n\n  v2 = sub_809A5BA();\n  v3 = (const char **)(a2 + 4 * optind);\n  if ( !*v3 )\n    sub_804CDC2();\n  v4 = 0;\n  do\n  {\n    if ( mkfifo(*v3, v2) < 0 )\n    {\n      sub_804D3F1(*v3);\n      v4 = 1;\n    }\n    ++v3;\n  }\n  while ( *v3 );\n  return v4;\n}\n"
        ],
        "134825258": [
            "sub_809452A",
            "0x809452a",
            "int __cdecl sub_809452A(int a1, int a2)\n{\n  int v2; // esi\n  int v3; // ebx\n  unsigned __int8 *v4; // eax\n  char *v5; // eax\n  int v6; // esi\n  int v7; // ecx\n  unsigned int v8; // eax\n  int v9; // edi\n  unsigned int v10; // eax\n  int v11; // ecx\n  __dev_t v12; // rax\n\n  v2 = sub_809A5BA();\n  v3 = a2 + 4 * optind;\n  if ( !*(_DWORD *)v3 )\n    goto LABEL_3;\n  v4 = *(unsigned __int8 **)(v3 + 4);\n  if ( !v4 )\n    goto LABEL_3;\n  v5 = strchr(\"pcub\", *v4);\n  if ( !v5 )\n    goto LABEL_3;\n  v6 = dword_80B7F40[(unsigned __int8)v5[4]] | v2;\n  v7 = *(_DWORD *)(v3 + 8);\n  if ( *v5 != 112 )\n  {\n    if ( v7 && *(_DWORD *)(v3 + 12) )\n    {\n      v8 = gnu_dev_minor(0xFFFFFFFFuLL);\n      v9 = sub_80B40CC(v8, 0);\n      v10 = gnu_dev_major(0xFFFFFFFFuLL);\n      sub_80B40CC(v10, 0);\n      v12 = sub_80B0220(v11, v9);\n      v7 = *(_DWORD *)(v3 + 16);\n      goto LABEL_10;\n    }\nLABEL_3:\n    sub_804CDC2();\n  }\n  v12 = 0LL;\nLABEL_10:\n  if ( v7 )\n    goto LABEL_3;\n  if ( mknod(*(const char **)v3, v6, v12) )\n    sub_804D3FF(*(const char **)v3);\n  return 0;\n}\n"
        ],
        "134825446": [
            "sub_80945E6",
            "0x80945e6",
            "decompilation failure at 80945E6!\n"
        ],
        "134825632": [
            "sub_80946A0",
            "0x80946a0",
            "decompilation failure at 80946A0!\n"
        ],
        "134826138": [
            "sub_809489A",
            "0x809489a",
            "decompilation failure at 809489A!\n"
        ],
        "134826292": [
            "sub_8094934",
            "0x8094934",
            "decompilation failure at 8094934!\n"
        ],
        "134826485": [
            "sub_80949F5",
            "0x80949f5",
            "decompilation failure at 80949F5!\n"
        ],
        "134826698": [
            "sub_8094ACA",
            "0x8094aca",
            "decompilation failure at 8094ACA!\n"
        ],
        "134826791": [
            "nullsub_2",
            "0x8094b27",
            "void nullsub_2()\n{\n  ;\n}\n"
        ],
        "134826792": [
            "sub_8094B28",
            "0x8094b28",
            "int sub_8094B28()\n{\n  int v0; // edi\n  void *i; // ebp\n  int v2; // eax\n  unsigned int v3; // esi\n  unsigned int v4; // ecx\n  int v5; // edx\n  void *retaddr; // [esp+14h] [ebp+0h]\n\n  retaddr = (void *)*(&buf + 2);\n  v0 = 1;\n  for ( i = 0; retaddr != i; i = (char *)i + 1 )\n  {\n    v2 = *(_DWORD *)(*(&buf + 3) + 24 * (_DWORD)i + 4);\n    v3 = byte_80D67C7[v2];\n    v4 = v0;\n    while ( v3 )\n    {\n      v5 = v4 % v3;\n      v4 = v3;\n      v3 = v5;\n    }\n    if ( v4 )\n      v4 = v0 * byte_80D67C7[v2] / v4;\n    v0 = v4;\n  }\n  return v0;\n}\n"
        ],
        "134826884": [
            "sub_8094B84",
            "0x8094b84",
            "decompilation failure at 8094B84!\n"
        ],
        "134827011": [
            "sub_8094C03",
            "0x8094c03",
            "int __cdecl sub_8094C03(char *format, int a2, char a3)\n{\n  *((_BYTE *)&buf + 48) = a3;\n  return printf((const char *)&buf + 42, format, a2);\n}\n"
        ],
        "134827049": [
            "sub_8094C29",
            "0x8094c29",
            "decompilation failure at 8094C29!\n"
        ],
        "134827160": [
            "sub_8094C98",
            "0x8094c98",
            "decompilation failure at 8094C98!\n"
        ],
        "134827342": [
            "sub_8094D4E",
            "0x8094d4e",
            "decompilation failure at 8094D4E!\n"
        ],
        "134827409": [
            "sub_8094D91",
            "0x8094d91",
            "decompilation failure at 8094D91!\n"
        ],
        "134827453": [
            "sub_8094DBD",
            "0x8094dbd",
            "decompilation failure at 8094DBD!\n"
        ],
        "134827493": [
            "sub_8094DE5",
            "0x8094de5",
            "decompilation failure at 8094DE5!\n"
        ],
        "134827651": [
            "sub_8094E83",
            "0x8094e83",
            "decompilation failure at 8094E83!\n"
        ],
        "134827866": [
            "sub_8094F5A",
            "0x8094f5a",
            "decompilation failure at 8094F5A!\n"
        ],
        "134828004": [
            "sub_8094FE4",
            "0x8094fe4",
            "decompilation failure at 8094FE4!\n"
        ],
        "134828774": [
            "sub_80952E6",
            "0x80952e6",
            "_BYTE *__usercall sub_80952E6@<eax>(_BYTE *result@<eax>)\n{\n  _BYTE *v1; // ebx\n  void *retaddr; // [esp+28h] [ebp+0h] BYREF\n\n  v1 = result;\n  while ( *v1 )\n  {\n    v1 = (_BYTE *)sub_8094FE4(&retaddr, v1);\n    *(&buf + 3) = sub_80B4733(*(&buf + 2), 6148);\n    result = (_BYTE *)(24 * *(&buf + 2) + *(&buf + 3));\n    qmemcpy(result, &retaddr, 0x18u);\n    ++*(&buf + 2);\n  }\n  return result;\n}\n"
        ],
        "134828865": [
            "sub_8095341",
            "0x8095341",
            "decompilation failure at 8095341!\n"
        ],
        "134828937": [
            "sub_8095389",
            "0x8095389",
            "decompilation failure at 8095389!\n"
        ],
        "134829033": [
            "sub_80953E9",
            "0x80953e9",
            "decompilation failure at 80953E9!\n"
        ],
        "134829282": [
            "sub_80954E2",
            "0x80954e2",
            "decompilation failure at 80954E2!\n"
        ],
        "134829357": [
            "sub_809552D",
            "0x809552d",
            "decompilation failure at 809552D!\n"
        ],
        "134829800": [
            "sub_80956E8",
            "0x80956e8",
            "decompilation failure at 80956E8!\n"
        ],
        "134831819": [
            "sub_8095ECB",
            "0x8095ecb",
            "decompilation failure at 8095ECB!\n"
        ],
        "134832321": [
            "sub_80960C1",
            "0x80960c1",
            "decompilation failure at 80960C1!\n"
        ],
        "134832410": [
            "sub_809611A",
            "0x809611a",
            "decompilation failure at 809611A!\n"
        ],
        "134832453": [
            "sub_8096145",
            "0x8096145",
            "__int64 __usercall sub_8096145@<edx:eax>(char *a1@<eax>, __int64 *a2@<edx>)\n{\n  __int64 result; // rax\n\n  result = sub_804ED01(a1, 0, 0);\n  *a2 = result;\n  return result;\n}\n"
        ],
        "134832472": [
            "sub_8096158",
            "0x8096158",
            "decompilation failure at 8096158!\n"
        ],
        "134832552": [
            "sub_80961A8",
            "0x80961a8",
            "decompilation failure at 80961A8!\n"
        ],
        "134832989": [
            "sub_809635D",
            "0x809635d",
            "int __usercall sub_809635D@<eax>(char *a1@<eax>, __int64 *a2@<edx>)\n{\n  __int64 v4; // rax\n\n  *a2 = sub_804EC9E(a1, 0, 0);\n  LODWORD(v4) = dword_80DBB7C;\n  if ( *(_DWORD *)dword_80DBB7C )\n  {\n    v4 = sub_804ED01(a1, 0, 0);\n    *a2 = v4;\n  }\n  return v4;\n}\n"
        ],
        "134833038": [
            "sub_809638E",
            "0x809638e",
            "decompilation failure at 809638E!\n"
        ],
        "134833116": [
            "sub_80963DC",
            "0x80963dc",
            "decompilation failure at 80963DC!\n"
        ],
        "134834018": [
            "sub_8096762",
            "0x8096762",
            "decompilation failure at 8096762!\n"
        ],
        "134834276": [
            "sub_8096864",
            "0x8096864",
            "decompilation failure at 8096864!\n"
        ],
        "134834389": [
            "sub_80968D5",
            "0x80968d5",
            "decompilation failure at 80968D5!\n"
        ],
        "134834468": [
            "sub_8096924",
            "0x8096924",
            "decompilation failure at 8096924!\n"
        ],
        "134834624": [
            "sub_80969C0",
            "0x80969c0",
            "decompilation failure at 80969C0!\n"
        ],
        "134834788": [
            "sub_8096A64",
            "0x8096a64",
            "decompilation failure at 8096A64!\n"
        ],
        "134835234": [
            "sub_8096C22",
            "0x8096c22",
            "decompilation failure at 8096C22!\n"
        ],
        "134835583": [
            "sub_8096D7F",
            "0x8096d7f",
            "decompilation failure at 8096D7F!\n"
        ],
        "134835985": [
            "sub_8096F11",
            "0x8096f11",
            "decompilation failure at 8096F11!\n"
        ],
        "134836024": [
            "sub_8096F38",
            "0x8096f38",
            "decompilation failure at 8096F38!\n"
        ],
        "134836537": [
            "sub_8097139",
            "0x8097139",
            "decompilation failure at 8097139!\n"
        ],
        "134837317": [
            "sub_8097445",
            "0x8097445",
            "decompilation failure at 8097445!\n"
        ],
        "134838169": [
            "sub_8097799",
            "0x8097799",
            "unsigned int __usercall sub_8097799@<eax>(unsigned int result@<eax>, int a2@<edx>, unsigned int *a3@<ecx>)\n{\n  unsigned int v3; // ebx\n  int *v4; // ebx\n  int v5; // ecx\n  int v6; // ecx\n  unsigned int v7; // eax\n  unsigned int v8; // eax\n  unsigned int v9; // ebx\n  unsigned int v10; // ebx\n  int i; // eax\n  unsigned int v12; // edx\n  int *v13; // ebx\n  int v14; // edx\n  int v15; // edx\n  unsigned int v16; // eax\n  unsigned int v17; // eax\n  unsigned int v18; // ebx\n  unsigned int v19; // ebx\n  unsigned int v20; // eax\n  unsigned int v21; // ebx\n  unsigned int v22; // esi\n  unsigned int v23; // ebx\n  unsigned int v24; // eax\n  unsigned int v25; // esi\n  unsigned int v26; // ebx\n\n  v3 = *(unsigned __int8 *)result;\n  if ( v3 <= 3 )\n  {\n    v4 = (int *)((char *)a3 + (unsigned __int8)byte_80D6B85[v3]);\n    if ( v4 )\n    {\n      v5 = *v4 & ~*(unsigned __int16 *)(result + 2);\n      result = *(_DWORD *)(result + 4);\n      if ( a2 )\n      {\n        result = ~result;\n        v6 = result & v5;\n      }\n      else\n      {\n        v6 = result | v5;\n      }\n      *v4 = v6;\n      return result;\n    }\n  }\n  if ( (char *)result == &byte_80B6780 || (_UNKNOWN *)result == &unk_80B6788 )\n  {\n    v7 = a3[2];\n    if ( !a2 )\n    {\n      result = v7 & 0xFFFFFCCF | 0x120;\nLABEL_11:\n      a3[2] = result;\n      return result;\n    }\nLABEL_14:\n    result = v7 & 0xFFFFFECF | 0x30;\n    goto LABEL_11;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B6790 )\n  {\n    v7 = a3[2];\n    if ( !a2 )\n    {\n      result = v7 & 0xFFFFFCCF | 0x320;\n      goto LABEL_11;\n    }\n    goto LABEL_14;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B6798 )\n  {\n    v8 = a3[1];\n    v9 = *a3;\n    if ( a2 )\n    {\n      v10 = v9 & 0xFFFFFE3F;\n      BYTE1(v10) |= 1u;\n      *a3 = v10;\n      result = v8 & 0xFFFFFFD3 | 4;\n    }\n    else\n    {\n      BYTE1(v9) &= ~1u;\n      *a3 = v9;\n      result = v8 & 0xFFFFFFFB;\n    }\nLABEL_72:\n    a3[1] = result;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67A0 )\n  {\n    *(_WORD *)((char *)a3 + 19) = 5503;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67A8 )\n  {\n    for ( i = 0; i != 34; i += 2 )\n      *((_BYTE *)a3 + (unsigned __int8)byte_80B8619[i] + 17) = byte_80B8618[i];\n    result = (unsigned int)&byte_80B6780;\n    while ( 1 )\n    {\n      v12 = *(unsigned __int8 *)result;\n      if ( v12 > 3 )\n        goto LABEL_33;\n      v13 = (int *)((char *)a3 + (unsigned __int8)byte_80D6B85[v12]);\n      if ( !v13 )\n        goto LABEL_33;\n      v14 = *v13 & ~*(unsigned __int16 *)(result + 2);\n      if ( (*(_BYTE *)(result + 1) & 1) != 0 )\n        break;\n      if ( (*(_BYTE *)(result + 1) & 2) != 0 )\n      {\n        v15 = ~*(_DWORD *)(result + 4) & v14;\n        goto LABEL_32;\n      }\nLABEL_33:\n      result += 8;\n      if ( &byte_80B6A40 == (char *)result )\n        return result;\n    }\n    v15 = *(_DWORD *)(result + 4) | v14;\nLABEL_32:\n    *v13 = v15;\n    goto LABEL_33;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67D0 )\n  {\n    v16 = a3[3];\n    if ( a2 )\n      result = v16 | 2;\n    else\n      result = v16 & 0xFFFFFFFD;\n    a3[3] = result;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67C0 )\n  {\n    v17 = a3[2] & 0xFFFFFECF;\n    v18 = *a3;\n    if ( a2 )\n    {\n      result = v17 | 0x120;\n      a3[2] = result;\n      v19 = v18 | 0x20;\n    }\n    else\n    {\n      result = v17 | 0x30;\n      a3[2] = result;\n      v19 = v18 & 0xFFFFFFDF;\n    }\n    *a3 = v19;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67C8 )\n  {\n    v20 = a3[2] & 0xFFFFFECF;\n    v21 = a3[1];\n    v22 = *a3;\n    if ( a2 )\n    {\n      result = v20 | 0x120;\n      a3[2] = result;\n      *a3 = v22 | 0x20;\n      v23 = v21 | 1;\n    }\n    else\n    {\n      result = v20 | 0x30;\n      a3[2] = result;\n      *a3 = v22 & 0xFFFFFFDF;\n      v23 = v21 & 0xFFFFFFFE;\n    }\n    a3[1] = v23;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67B8 )\n  {\n    if ( a2 )\n    {\nLABEL_56:\n      *a3 |= 0x526u;\n      a3[1] |= 1u;\n      a3[3] |= 3u;\n      return result;\n    }\nLABEL_57:\n    *a3 = 0;\n    a3[1] &= ~1u;\n    a3[3] &= 0xFFFFFFF8;\n    *((_WORD *)a3 + 11) = 256;\n    return result;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67B0 )\n  {\n    if ( !a2 )\n      goto LABEL_56;\n    goto LABEL_57;\n  }\n  if ( (_UNKNOWN *)result == &unk_80B67E8 )\n  {\n    result = *a3;\n    if ( a2 )\n      BYTE1(result) |= 8u;\n    else\n      BYTE1(result) &= ~8u;\n    *a3 = result;\n  }\n  else\n  {\n    if ( (_UNKNOWN *)result == &unk_80B67F0 )\n    {\n      result = a3[1];\n      if ( a2 )\n        BYTE1(result) |= 0x18u;\n      else\n        BYTE1(result) &= 0xE7u;\n      goto LABEL_72;\n    }\n    if ( (_UNKNOWN *)result == &unk_80B67F8 || (_UNKNOWN *)result == &unk_80B6800 )\n    {\n      v24 = a3[1];\n      v25 = a3[3];\n      v26 = *a3;\n      if ( a2 )\n      {\n        a3[3] = v25 & 0xFFFFFFFB;\n        BYTE1(v26) &= ~2u;\n        *a3 = v26;\n        result = v24 & 0xFFFFFFFD;\n      }\n      else\n      {\n        a3[3] = v25 | 4;\n        BYTE1(v26) |= 2u;\n        *a3 = v26;\n        result = v24 | 2;\n      }\n      goto LABEL_72;\n    }\n    if ( (_UNKNOWN *)result == &unk_80B67D8 )\n    {\n      a3[3] |= 0xA10u;\n    }\n    else if ( (_UNKNOWN *)result == &unk_80B67E0 )\n    {\n      *((_BYTE *)a3 + 17) = 3;\n      *(_WORD *)((char *)a3 + 19) = 5503;\n      a3[3] |= 0xA10u;\n      *a3 &= ~0x800u;\n    }\n  }\n  return result;\n}\n"
        ],
        "134838856": [
            "sub_8097A48",
            "0x8097a48",
            "decompilation failure at 8097A48!\n"
        ],
        "134838924": [
            "sub_8097A8C",
            "0x8097a8c",
            "decompilation failure at 8097A8C!\n"
        ],
        "134839074": [
            "sub_8097B22",
            "0x8097b22",
            "decompilation failure at 8097B22!\n"
        ],
        "134839095": [
            "sub_8097B37",
            "0x8097b37",
            "char *__usercall sub_8097B37@<eax>(const char *a1@<eax>)\n{\n  int v1; // eax\n\n  v1 = sub_804D222(\"evenp\", a1);\n  if ( v1 < 0 )\n    return 0;\n  else\n    return &byte_80B6780[8 * v1];\n}\n"
        ],
        "134839122": [
            "sub_8097B52",
            "0x8097b52",
            "char __usercall sub_8097B52@<al>(const char *a1@<eax>)\n{\n  int v1; // edx\n  char result; // al\n\n  v1 = sub_804D222(\"line\", a1);\n  result = v1 + 1;\n  if ( v1 != -1 && (unsigned int)(v1 - 4) > 1 )\n    return result | 0x80;\n  return result;\n}\n"
        ],
        "134839150": [
            "sub_8097B6E",
            "0x8097b6e",
            "decompilation failure at 8097B6E!\n"
        ],
        "134839291": [
            "sub_8097BFB",
            "0x8097bfb",
            "decompilation failure at 8097BFB!\n"
        ],
        "134839393": [
            "sub_8097C61",
            "0x8097c61",
            "decompilation failure at 8097C61!\n"
        ],
        "134839472": [
            "sub_8097CB0",
            "0x8097cb0",
            "decompilation failure at 8097CB0!\n"
        ],
        "134839835": [
            "sub_8097E1B",
            "0x8097e1b",
            "decompilation failure at 8097E1B!\n"
        ],
        "134839976": [
            "sub_8097EA8",
            "0x8097ea8",
            "decompilation failure at 8097EA8!\n"
        ],
        "134840030": [
            "sub_8097EDE",
            "0x8097ede",
            "decompilation failure at 8097EDE!\n"
        ],
        "134840042": [
            "sub_8097EEA",
            "0x8097eea",
            "decompilation failure at 8097EEA!\n"
        ],
        "134840176": [
            "sub_8097F70",
            "0x8097f70",
            "decompilation failure at 8097F70!\n"
        ],
        "134841336": [
            "sub_80983F8",
            "0x80983f8",
            "int sub_80983F8()\n{\n  sub_80B3CE5();\n  sync();\n  return 0;\n}\n"
        ],
        "134841356": [
            "sub_809840C",
            "0x809840c",
            "int __usercall sub_809840C@<eax>(_BYTE *a1@<eax>, int a2@<ecx>)\n{\n  if ( *a1 == 43 )\n    LOBYTE(buf) = 1;\n  return sub_80B40DC(a2, &unk_80B7580);\n}\n"
        ],
        "134841389": [
            "sub_809842D",
            "0x809842d",
            "decompilation failure at 809842D!\n"
        ],
        "134843008": [
            "sub_8098A80",
            "0x8098a80",
            "decompilation failure at 8098A80!\n"
        ],
        "134843316": [
            "sub_8098BB4",
            "0x8098bb4",
            "decompilation failure at 8098BB4!\n"
        ],
        "134843371": [
            "sub_8098BEB",
            "0x8098beb",
            "decompilation failure at 8098BEB!\n"
        ],
        "134843468": [
            "sub_8098C4C",
            "0x8098c4c",
            "int __usercall sub_8098C4C@<eax>(const char *a1@<eax>)\n{\n  _DWORD *v1; // ebx\n  int v2; // edx\n  int result; // eax\n\n  v1 = dword_80DBB94;\n  *((_DWORD *)dword_80DBB94 + 1) = &unk_80D6EB9;\n  if ( !a1 )\n    return 0;\n  v2 = sub_804D222(\"-r\", a1);\n  result = 39;\n  if ( v2 >= 0 )\n  {\n    v1[1] = 2 * v2 + 134965824;\n    return (unsigned __int8)byte_80B6A40[2 * v2];\n  }\n  return result;\n}\n"
        ],
        "134843534": [
            "sub_8098C8E",
            "0x8098c8e",
            "decompilation failure at 8098C8E!\n"
        ],
        "134844038": [
            "sub_8098E86",
            "0x8098e86",
            "decompilation failure at 8098E86!\n"
        ],
        "134844781": [
            "sub_809916D",
            "0x809916d",
            "int sub_809916D()\n{\n  unsigned __int64 v0; // rdi\n  __int64 v1; // kr00_8\n  const char ***v2; // ebx\n  const char **v3; // edx\n  const char **v4; // edx\n\n  v1 = sub_8098E86();\n  v0 = __PAIR64__(v1, HIDWORD(v1));\n  v2 = (const char ***)dword_80DBB94;\n  v3 = (const char **)(*(_DWORD *)dword_80DBB94 + 4);\n  *(_DWORD *)dword_80DBB94 = v3;\n  if ( sub_8098C4C(*v3) == 35 )\n  {\n    v4 = *v2 + 1;\n    *v2 = v4;\n    sub_8098C4C(*v4);\n    HIDWORD(v0) = (__PAIR64__(v1, HIDWORD(v1)) != 0) & (sub_809916D() != 0);\n  }\n  else\n  {\n    --*v2;\n  }\n  return HIDWORD(v0);\n}\n"
        ],
        "134844877": [
            "sub_80991CD",
            "0x80991cd",
            "_BOOL4 sub_80991CD()\n{\n  int v0; // esi\n  int v1; // edx\n  int v2; // edi\n  const char ***v3; // ebx\n  const char **v4; // edx\n  const char **v5; // edx\n  __int64 v6; // rax\n\n  v0 = sub_809916D();\n  v2 = v1;\n  v3 = (const char ***)dword_80DBB94;\n  v4 = (const char **)(*(_DWORD *)dword_80DBB94 + 4);\n  *(_DWORD *)dword_80DBB94 = v4;\n  if ( sub_8098C4C(*v4) == 36 )\n  {\n    v5 = *v3 + 1;\n    *v3 = v5;\n    sub_8098C4C(*v5);\n    v6 = sub_80991CD();\n    return (v2 | HIDWORD(v6) | v0 | (unsigned int)v6) != 0;\n  }\n  else\n  {\n    --*v3;\n  }\n  return v0;\n}\n"
        ],
        "134844968": [
            "sub_8099228",
            "0x8099228",
            "decompilation failure at 8099228!\n"
        ],
        "134845378": [
            "sub_80993C2",
            "0x80993c2",
            "decompilation failure at 80993C2!\n"
        ],
        "134845708": [
            "sub_809950C",
            "0x809950c",
            "decompilation failure at 809950C!\n"
        ],
        "134845777": [
            "sub_8099551",
            "0x8099551",
            "decompilation failure at 8099551!\n"
        ],
        "134846456": [
            "sub_80997F8",
            "0x80997f8",
            "decompilation failure at 80997F8!\n"
        ],
        "134846947": [
            "sub_80999E3",
            "0x80999e3",
            "int sub_80999E3()\n{\n  return 0;\n}\n"
        ],
        "134846950": [
            "sub_80999E6",
            "0x80999e6",
            "decompilation failure at 80999E6!\n"
        ],
        "134847158": [
            "sub_8099AB6",
            "0x8099ab6",
            "decompilation failure at 8099AB6!\n"
        ],
        "134847240": [
            "sub_8099B08",
            "0x8099b08",
            "decompilation failure at 8099B08!\n"
        ],
        "134847496": [
            "sub_8099C08",
            "0x8099c08",
            "decompilation failure at 8099C08!\n"
        ],
        "134847897": [
            "sub_8099D99",
            "0x8099d99",
            "decompilation failure at 8099D99!\n"
        ],
        "134847932": [
            "sub_8099DBC",
            "0x8099dbc",
            "decompilation failure at 8099DBC!\n"
        ],
        "134847963": [
            "sub_8099DDB",
            "0x8099ddb",
            "void __cdecl __noreturn sub_8099DDB(int a1)\n{\n  a1 = 0x10000;\n  sub_80AB359(&a1, 135081797);\n}\n"
        ],
        "134848269": [
            "sub_8099F0D",
            "0x8099f0d",
            "decompilation failure at 8099F0D!\n"
        ],
        "134848569": [
            "sub_809A039",
            "0x809a039",
            "decompilation failure at 809A039!\n"
        ],
        "134848886": [
            "sub_809A176",
            "0x809a176",
            "decompilation failure at 809A176!\n"
        ],
        "134849400": [
            "sub_809A378",
            "0x809a378",
            "decompilation failure at 809A378!\n"
        ],
        "134849740": [
            "sub_809A4CC",
            "0x809a4cc",
            "decompilation failure at 809A4CC!\n"
        ],
        "134849777": [
            "sub_809A4F1",
            "0x809a4f1",
            "decompilation failure at 809A4F1!\n"
        ],
        "134849895": [
            "sub_809A567",
            "0x809a567",
            "decompilation failure at 809A567!\n"
        ],
        "134849968": [
            "sub_809A5B0",
            "0x809a5b0",
            "int __fastcall sub_809A5B0(int a1, int a2)\n{\n  return sub_809A567(stat64, a2);\n}\n"
        ],
        "134849978": [
            "sub_809A5BA",
            "0x809a5ba",
            "decompilation failure at 809A5BA!\n"
        ],
        "134850044": [
            "sub_809A5FC",
            "0x809a5fc",
            "decompilation failure at 809A5FC!\n"
        ],
        "134850147": [
            "sub_809A663",
            "0x809a663",
            "decompilation failure at 809A663!\n"
        ],
        "134850351": [
            "sub_809A72F",
            "0x809a72f",
            "decompilation failure at 809A72F!\n"
        ],
        "134850661": [
            "sub_809A865",
            "0x809a865",
            "decompilation failure at 809A865!\n"
        ],
        "134851051": [
            "sub_809A9EB",
            "0x809a9eb",
            "decompilation failure at 809A9EB!\n"
        ],
        "134852043": [
            "sub_809ADCB",
            "0x809adcb",
            "decompilation failure at 809ADCB!\n"
        ],
        "134852236": [
            "sub_809AE8C",
            "0x809ae8c",
            "int __cdecl sub_809AE8C(int a1, int a2, _DWORD *a3)\n{\n  int v3; // ecx\n  int result; // eax\n\n  while ( 1 )\n  {\n    result = *++a3;\n    if ( !*a3 )\n      break;\n    sub_80B2709(v3, 12);\n  }\n  return result;\n}\n"
        ],
        "134852264": [
            "sub_809AEA8",
            "0x809aea8",
            "decompilation failure at 809AEA8!\n"
        ],
        "134852722": [
            "sub_809B072",
            "0x809b072",
            "decompilation failure at 809B072!\n"
        ],
        "134852993": [
            "sub_809B181",
            "0x809b181",
            "decompilation failure at 809B181!\n"
        ],
        "134853030": [
            "sub_809B1A6",
            "0x809b1a6",
            "decompilation failure at 809B1A6!\n"
        ],
        "134853324": [
            "sub_809B2CC",
            "0x809b2cc",
            "decompilation failure at 809B2CC!\n"
        ],
        "134853383": [
            "sub_809B307",
            "0x809b307",
            "decompilation failure at 809B307!\n"
        ],
        "134853471": [
            "sub_809B35F",
            "0x809b35f",
            "decompilation failure at 809B35F!\n"
        ],
        "134853618": [
            "sub_809B3F2",
            "0x809b3f2",
            "decompilation failure at 809B3F2!\n"
        ],
        "134853803": [
            "sub_809B4AB",
            "0x809b4ab",
            "size_t sub_809B4AB()\n{\n  size_t v0; // edx\n\n  buf = sub_80B4733(*(&buf + 1), 1026);\n  v0 = (*(&buf + 1))++;\n  return buf + 4 * v0;\n}\n"
        ],
        "134853848": [
            "sub_809B4D8",
            "0x809b4d8",
            "decompilation failure at 809B4D8!\n"
        ],
        "134854005": [
            "sub_809B575",
            "0x809b575",
            "decompilation failure at 809B575!\n"
        ],
        "134854122": [
            "sub_809B5EA",
            "0x809b5ea",
            "decompilation failure at 809B5EA!\n"
        ],
        "134854199": [
            "sub_809B637",
            "0x809b637",
            "decompilation failure at 809B637!\n"
        ],
        "134854386": [
            "sub_809B6F2",
            "0x809b6f2",
            "decompilation failure at 809B6F2!\n"
        ],
        "134854541": [
            "sub_809B78D",
            "0x809b78d",
            "decompilation failure at 809B78D!\n"
        ],
        "134854602": [
            "sub_809B7CA",
            "0x809b7ca",
            "decompilation failure at 809B7CA!\n"
        ],
        "134855033": [
            "sub_809B979",
            "0x809b979",
            "decompilation failure at 809B979!\n"
        ],
        "134855296": [
            "sub_809BA80",
            "0x809ba80",
            "int __usercall sub_809BA80@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // ebx\n  int v4; // eax\n\n  v2 = 0;\n  v3 = 0;\n  while ( 1 )\n  {\n    v4 = sub_809B979();\n    if ( v4 == -1 )\n      break;\n    v3 |= v4;\n    v2 |= a1;\n  }\n  return v3;\n}\n"
        ],
        "134855329": [
            "sub_809BAA1",
            "0x809baa1",
            "decompilation failure at 809BAA1!\n"
        ],
        "134857015": [
            "sub_809C137",
            "0x809c137",
            "decompilation failure at 809C137!\n"
        ],
        "134857186": [
            "sub_809C1E2",
            "0x809c1e2",
            "decompilation failure at 809C1E2!\n"
        ],
        "134857348": [
            "sub_809C284",
            "0x809c284",
            "decompilation failure at 809C284!\n"
        ],
        "134857489": [
            "sub_809C311",
            "0x809c311",
            "int __usercall sub_809C311@<eax>(unsigned __int8 *a1@<eax>)\n{\n  int i; // edx\n  int v2; // ecx\n\n  for ( i = 0; ; i = v2 + 63 * i )\n  {\n    v2 = *a1;\n    if ( !(_BYTE)v2 )\n      break;\n    ++a1;\n  }\n  return i;\n}\n"
        ],
        "134857509": [
            "sub_809C325",
            "0x809c325",
            "char *__usercall sub_809C325@<eax>(char *result@<eax>)\n{\n  int v1; // ecx\n  char v2; // dl\n\n  v1 = dword_80DBB80;\n  while ( 1 )\n  {\n    v2 = *result;\n    if ( *result != 92 )\n      break;\n    if ( result[1] != 10 )\n      return result;\n    ++result;\n    ++*(_DWORD *)(v1 + 12);\nLABEL_7:\n    ++result;\n  }\n  if ( v2 == 32 || v2 == 9 )\n    goto LABEL_7;\n  return result;\n}\n"
        ],
        "134857548": [
            "sub_809C34C",
            "0x809c34c",
            "int __usercall sub_809C34C@<eax>(int *a1@<eax>)\n{\n  int result; // eax\n  _BYTE *v3; // ecx\n\n  result = *a1;\n  do\n    v3 = (_BYTE *)(*a1)++;\n  while ( *v3 );\n  return result;\n}\n"
        ],
        "134857567": [
            "sub_809C35F",
            "0x809c35f",
            "int sub_809C35F()\n{\n  int result; // eax\n\n  result = dword_80DBB80;\n  *(_BYTE *)(dword_80DBB80 - 3) = 1;\n  return result;\n}\n"
        ],
        "134857577": [
            "sub_809C369",
            "0x809c369",
            "_DWORD *__usercall sub_809C369@<eax>(_DWORD **a1@<eax>)\n{\n  _DWORD *v1; // edx\n\n  v1 = *a1;\n  if ( *a1 && (*v1 & 0xFF00) == 4864 )\n  {\n    *a1 = (_DWORD *)v1[3];\n    return (_DWORD *)v1[2];\n  }\n  else\n  {\n    *a1 = 0;\n  }\n  return v1;\n}\n"
        ],
        "134857618": [
            "sub_809C392",
            "0x809c392",
            "_DWORD *sub_809C392()\n{\n  _DWORD *v0; // ebx\n\n  v0 = sub_804DB2E(0x14u);\n  v0[1] = 61;\n  v0[4] = sub_804DB2E(0xF4u);\n  return v0;\n}\n"
        ],
        "134857655": [
            "sub_809C3B7",
            "0x809c3b7",
            "int __usercall sub_809C3B7@<eax>(int *a1@<eax>)\n{\n  int v2; // eax\n\n  while ( 1 )\n  {\n    v2 = *a1;\n    if ( (*a1 & 0x2000) == 0 )\n      break;\n    a1 = (int *)a1[4];\n  }\n  if ( (v2 & 2) == 0 )\n  {\n    *a1 = v2 | 2;\n    a1[4] = (int)sub_809C392();\n  }\n  return a1[4];\n}\n"
        ],
        "134857693": [
            "sub_809C3DD",
            "0x809c3dd",
            "_DWORD *__usercall sub_809C3DD@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x14u);\n  *result = a1;\n  result[1] = *(_DWORD *)(dword_80DBB80 - 36);\n  return result;\n}\n"
        ],
        "134857722": [
            "sub_809C3FA",
            "0x809c3fa",
            "_DWORD *__usercall sub_809C3FA@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  _DWORD *i; // edi\n  _DWORD *v4; // edx\n  int v5; // ebp\n  _DWORD *v6; // eax\n  int v7; // edx\n  _DWORD *result; // eax\n  unsigned int v9; // ebx\n  _DWORD *j; // edx\n\n  v2 = dword_80DBB80;\n  for ( i = 0; ; i = v4 )\n  {\n    v4 = *(_DWORD **)(v2 - 20);\n    if ( !v4 )\n      break;\n    if ( a1 - 858993459 * ((v4[1] - (int)(v4 + 4)) >> 2) <= *v4 )\n      goto LABEL_9;\n    *(_DWORD *)(v2 - 20) = v4[3];\n  }\n  v5 = a1;\n  if ( a1 < 64 )\n    v5 = 64;\n  v6 = sub_804DB2E(20 * v5 + 16);\n  *(_DWORD *)(v2 - 20) = v6;\n  *v6 = v5;\n  v6[1] = v6 + 4;\n  v6[2] = i;\n  if ( i )\n    i[3] = v6;\nLABEL_9:\n  v7 = *(_DWORD *)(v2 - 20);\n  result = *(_DWORD **)(v7 + 4);\n  v9 = (unsigned int)&result[5 * a1];\n  *(_DWORD *)(v7 + 4) = v9;\n  for ( j = result; v9 > (unsigned int)j; j += 5 )\n  {\n    *j = 0;\n    j[3] = 0;\n  }\n  return result;\n}\n"
        ],
        "134857865": [
            "sub_809C489",
            "0x809c489",
            "decompilation failure at 809C489!\n"
        ],
        "134857891": [
            "sub_809C4A3",
            "0x809c4a3",
            "decompilation failure at 809C4A3!\n"
        ],
        "134857938": [
            "sub_809C4D2",
            "0x809c4d2",
            "char *__usercall sub_809C4D2@<eax>(char *result@<eax>)\n{\n  char *v1; // esi\n  int v2; // ebx\n  int v3; // edi\n  int v4; // ebp\n  _DWORD *i; // edi\n  char *v6; // eax\n  int v7; // edx\n\n  v1 = result;\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 28);\n  if ( v3 <= (int)result )\n  {\n    *(_DWORD *)(dword_80DBB80 - 28) = result + 16;\n    v6 = (char *)sub_804DB13(*(void **)(v2 - 24), 20 * (_DWORD)(result + 16));\n    *(_DWORD *)(v2 - 24) = v6;\n    v7 = *(_DWORD *)(v2 - 28);\n    result = &v6[20 * v3];\n    while ( v7 > v3 )\n    {\n      *(_DWORD *)result = 1024;\n      *((_DWORD *)result + 3) = 0;\n      ++v3;\n      result += 20;\n    }\n  }\n  v4 = 20 * (_DWORD)v1;\n  for ( i = v1; *(_DWORD *)(v2 - 32) > (int)i; i = (_DWORD *)((char *)i + 1) )\n  {\n    result = (char *)sub_809C4A3();\n    v4 += 20;\n  }\n  *(_DWORD *)(v2 - 32) = v1;\n  return result;\n}\n"
        ],
        "134858044": [
            "sub_809C53C",
            "0x809c53c",
            "decompilation failure at 809C53C!\n"
        ],
        "134858134": [
            "sub_809C596",
            "0x809c596",
            "_DWORD *__usercall sub_809C596@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n  _DWORD *v3; // esi\n  _DWORD *v4; // eax\n  int v5; // eax\n  int v6; // edx\n  int v7; // esi\n  _DWORD *v8; // esi\n  _DWORD *v9; // eax\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD **)(dword_80DBB80 - 72);\n  if ( !*v3 )\n  {\n    v4 = sub_809C3DD(0);\n    v3[1] = v4;\n    **(_DWORD **)(v2 - 72) = v4;\n  }\n  v5 = *(_DWORD *)(v2 - 72);\n  v6 = *(_DWORD *)(v2 - 40);\n  if ( *(_DWORD *)(v5 + 8) != v6 )\n  {\n    *(_DWORD *)(v5 + 8) = v6;\n    v7 = sub_809C596();\n    *(_DWORD *)(v7 + 8) = sub_804DB46(*(const char **)(v2 - 40));\n  }\n  v8 = *(_DWORD **)(*(_DWORD *)(v2 - 72) + 4);\n  *v8 = a1;\n  v9 = sub_809C3DD(10240);\n  v8[4] = v9;\n  *(_DWORD *)(*(_DWORD *)(v2 - 72) + 4) = v9;\n  return v8;\n}\n"
        ],
        "134858238": [
            "sub_809C5FE",
            "0x809c5fe",
            "decompilation failure at 809C5FE!\n"
        ],
        "134858344": [
            "sub_809C668",
            "0x809c668",
            "decompilation failure at 809C668!\n"
        ],
        "134858489": [
            "sub_809C6F9",
            "0x809c6f9",
            "long double __usercall sub_809C6F9@<st0>(_DWORD *a1@<eax>)\n{\n  int v2; // eax\n  char *v3; // edx\n  char *v5; // [esp+4h] [ebp-Ch]\n\n  v2 = *a1;\n  if ( (v2 & 0x101) == 0 )\n  {\n    a1[1] = 0;\n    a1[2] = 0;\n    v3 = (char *)a1[3];\n    v5 = v3;\n    if ( v3 && *v3 )\n    {\n      *(double *)(a1 + 1) = sub_809C668();\n      if ( (*a1 & 0x200) != 0 && *sub_809C325(v5) )\n        *a1 &= ~0x200u;\n    }\n    else\n    {\n      BYTE1(v2) &= ~2u;\n      *a1 = v2;\n    }\n    *a1 |= 0x100u;\n  }\n  return *(double *)(a1 + 1);\n}\n"
        ],
        "134858615": [
            "sub_809C777",
            "0x809c777",
            "int __usercall sub_809C777@<eax>(int *a1@<eax>)\n{\n  int v2; // eax\n  int result; // eax\n  _BYTE *v4; // edx\n\n  sub_809C6F9(a1);\n  v2 = *a1;\n  BYTE1(v2) = BYTE1(*a1) ^ 0x40;\n  result = v2 & 0x4201;\n  if ( result )\n    return *(double *)(a1 + 1) != 0.0;\n  v4 = (_BYTE *)a1[3];\n  if ( v4 )\n    return *v4 != 0;\n  return result;\n}\n"
        ],
        "134858700": [
            "sub_809C7CC",
            "0x809c7cc",
            "int __usercall sub_809C7CC@<eax>(_DWORD *a1@<eax>)\n{\n  long double v1; // fst7\n\n  v1 = sub_809C6F9(a1);\n  if ( v1 < 0.0 )\n    return -(int)(__int64)-v1;\n  else\n    return (__int64)v1;\n}\n"
        ],
        "134858804": [
            "sub_809C834",
            "0x809c834",
            "decompilation failure at 809C834!\n"
        ],
        "134858862": [
            "sub_809C86E",
            "0x809c86e",
            "decompilation failure at 809C86E!\n"
        ],
        "134859117": [
            "sub_809C96D",
            "0x809c96d",
            "decompilation failure at 809C96D!\n"
        ],
        "134859204": [
            "sub_809C9C4",
            "0x809c9c4",
            "char __usercall sub_809C9C4@<al>(int *a1@<eax>, int a2@<ecx>)\n{\n  char *v3; // esi\n  int v4; // edi\n  char result; // al\n\n  v3 = (char *)*a1;\n  v4 = *a1 + 1;\n  *a1 = v4;\n  result = *v3;\n  if ( *v3 == 92 )\n  {\n    result = sub_80B0CB3(a2);\n    if ( result == 92 && v4 == *a1 )\n    {\n      result = v3[1];\n      if ( result )\n        *a1 = (int)(v3 + 2);\n    }\n  }\n  return result;\n}\n"
        ],
        "134859253": [
            "sub_809C9F5",
            "0x809c9f5",
            "char *__usercall sub_809C9F5@<eax>(char *a1@<eax>, int a2@<ecx>)\n{\n  char *i; // ebx\n  char v3; // al\n\n  for ( i = a1; ; ++i )\n  {\n    v3 = sub_809C9C4((int *)&a1, a2);\n    *i = v3;\n    if ( !v3 )\n      break;\n  }\n  return a1;\n}\n"
        ],
        "134859279": [
            "sub_809CA0F",
            "0x809ca0f",
            "decompilation failure at 809CA0F!\n"
        ],
        "134859398": [
            "sub_809CA86",
            "0x809ca86",
            "decompilation failure at 809CA86!\n"
        ],
        "134859421": [
            "sub_809CA9D",
            "0x809ca9d",
            "decompilation failure at 809CA9D!\n"
        ],
        "134859662": [
            "sub_809CB8E",
            "0x809cb8e",
            "// local variable allocation has failed, the output may be wrong!\nconst char *__usercall sub_809CB8E@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n  __int64 v3; // rax\n  const char *result; // eax\n  double v5; // [esp+0h] [ebp-18h]\n  int savedregs; // [esp+18h] [ebp+0h]\n  void *retaddr; // [esp+1Ch] [ebp+4h] OVERLAPPED\n\n  if ( (*(_DWORD *)a1 & 0x101) == 1 )\n  {\n    v5 = *(double *)(a1 + 4);\n    v2 = dword_80DBB80;\n    v3 = sub_809CB8E();\n    savedregs = HIDWORD(v3);\n    *(double *)&retaddr = v5;\n    sub_809CA9D((char *)v3, 0xF0u);\n    *(_DWORD *)(a1 + 12) = sub_804DB46(*(const char **)(v2 - 12));\n    *(_DWORD *)a1 |= 0x100u;\n  }\n  result = *(const char **)(a1 + 12);\n  if ( !result )\n    return &data;\n  return result;\n}\n"
        ],
        "134859785": [
            "sub_809CC09",
            "0x809cc09",
            "decompilation failure at 809CC09!\n"
        ],
        "134860305": [
            "sub_809CE11",
            "0x809ce11",
            "decompilation failure at 809CE11!\n"
        ],
        "134860476": [
            "sub_809CEBC",
            "0x809cebc",
            "int *__usercall sub_809CEBC@<eax>(int *result@<eax>, int a2@<ebx>, int a3@<ebp>, int a4@<edi>, int a5@<esi>, char a6)\n{\n  int *v6; // esi\n  int v7; // ebx\n  long double v8; // fst7\n  size_t v9; // eax\n  int v10; // esi\n  const char *v11; // [esp+8h] [ebp-4Ch]\n  const char *v12; // [esp+Ch] [ebp-48h]\n  unsigned int v13; // [esp+14h] [ebp-40h]\n  int v14; // [esp+1Ch] [ebp-38h]\n  unsigned int v15; // [esp+20h] [ebp-34h]\n  int v16; // [esp+24h] [ebp-30h]\n  int v17; // [esp+28h] [ebp-2Ch]\n  int v18; // [esp+28h] [ebp-2Ch]\n  _DWORD v19[8]; // [esp+34h] [ebp-20h] BYREF\n  void *retaddr; // [esp+54h] [ebp+0h]\n\n  if ( (*result & 0x400) == 0 )\n    return result;\n  v19[7] = a4;\n  v19[6] = retaddr;\n  v19[5] = a3;\n  v19[4] = &a6;\n  v19[3] = a5;\n  v19[2] = a2;\n  v6 = result;\n  v7 = dword_80DBB80;\n  result = *(int **)(dword_80DBB80 + 80);\n  if ( result == v6 )\n  {\n    v8 = sub_809C6F9(result);\n    sub_809C4D2((char *)(int)v8);\n    v12 = sub_809CB8E(*(_DWORD *)(v7 + 28));\n    v15 = strlen(v12);\n    v14 = 0;\n    v16 = 0;\n    v17 = 0;\n    while ( v14 < (int)v8 )\n    {\n      v11 = sub_809CB8E(*(_DWORD *)(v7 - 24) + 20 * v14);\n      v9 = strlen(v11);\n      v13 = v9;\n      if ( v17 )\n      {\n        qmemcpy((void *)(v16 + v17), v12, v15);\n        v16 += v15;\n      }\n      v17 = sub_809C489(v19, v9 + v16 + v15);\n      qmemcpy((void *)(v17 + v16), v11, v13);\n      ++v14;\n      v16 += v13;\n    }\n    if ( v17 )\n      *(_BYTE *)(v17 + v16) = 0;\n    result = (int *)sub_809D076();\n    *(_BYTE *)(v7 - 4) = 1;\n    return result;\n  }\n  if ( *(int **)(dword_80DBB80 + 52) == v6 )\n  {\n    *(_BYTE *)(dword_80DBB80 - 4) = 0;\n    return result;\n  }\n  if ( *(int **)(dword_80DBB80 + 24) == v6 )\n  {\n    sub_809CE11();\n    sub_809CB8E((int)v6);\n    return (int *)sub_809C5FE();\n  }\n  if ( *(int **)(dword_80DBB80 + 36) == v6 )\n  {\n    sub_809CB8E((int)v6);\n    return (int *)sub_809C5FE();\n  }\n  if ( *(int **)(dword_80DBB80 + 84) == v6 )\n  {\n    result = (int *)sub_809C777(v6);\n    *(_BYTE *)(v7 - 8) = (_BYTE)result;\n  }\n  else\n  {\n    v18 = (int)sub_809C6F9(result);\n    v10 = -858993459 * (((int)v6 - *(_DWORD *)(v7 - 24)) >> 2);\n    if ( v10 >= v18 )\n      v18 = v10 + 1;\n    return (int *)sub_809D156(COERCE_UNSIGNED_INT64((double)v18));\n  }\n  return result;\n}\n"
        ],
        "134860918": [
            "sub_809D076",
            "0x809d076",
            "int *__usercall sub_809D076@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ebp>, int a4@<edi>)\n{\n  char v7; // [esp+0h] [ebp-8h]\n\n  sub_809C4A3();\n  a1[3] = a2;\n  sub_809CEBC(a1, (int)a1, a3, a4, a2, v7);\n  return a1;\n}\n"
        ],
        "134860944": [
            "sub_809D090",
            "0x809d090",
            "int *__usercall sub_809D090@<eax>(int *a1@<eax>, const char *a2@<edx>, int a3@<ebp>, int a4@<edi>)\n{\n  char *v5; // eax\n\n  v5 = 0;\n  if ( a2 && *a2 )\n    v5 = sub_804DB46(a2);\n  return sub_809D076(a1, (int)v5, a3, a4);\n}\n"
        ],
        "134860975": [
            "sub_809D0AF",
            "0x809d0af",
            "int *__usercall sub_809D0AF@<eax>(int *a1@<eax>, const char *a2@<edx>, int a3@<ebp>, int a4@<edi>)\n{\n  int *result; // eax\n\n  result = sub_809D090(a1, a2, a3, a4);\n  *result |= 0x200u;\n  return result;\n}\n"
        ],
        "134860987": [
            "sub_809D0BB",
            "0x809d0bb",
            "int __usercall sub_809D0BB@<eax>(const char *a1@<eax>, int a2@<ebp>)\n{\n  char v3; // dl\n  int result; // eax\n  char *v5; // ebx\n  char *v6; // esi\n  char *v7; // ebx\n  int v8; // ecx\n  int *v9; // eax\n\n  v3 = *a1;\n  if ( (unsigned __int8)(*a1 - 48) <= 9u || (unsigned __int8)((v3 | 0x20) - 97) <= 0x19u || (result = 0, v3 == 95) )\n  {\n    v5 = strchr(a1, 61);\n    result = 0;\n    if ( v5 )\n    {\n      v6 = sub_804DB46(a1);\n      v7 = &v6[v5 - a1];\n      *v7 = 0;\n      sub_809C9F5(v7 + 1, v8);\n      v9 = (int *)sub_809C86E();\n      sub_809D0AF(v9, v7 + 1, a2, (int)(v7 + 1));\n      free(v6);\n      return 1;\n    }\n  }\n  return result;\n}\n"
        ],
        "134861102": [
            "sub_809D12E",
            "0x809d12e",
            "int *__usercall sub_809D12E@<eax>(int *a1@<eax>, signed int a2@<edx>, const char *a3@<ecx>, int a4@<ebp>)\n{\n  int *v6; // eax\n\n  sub_804D70F(a2);\n  sub_809C3B7(a1);\n  v6 = (int *)sub_809C86E();\n  return sub_809D0AF(v6, a3, a4, (int)a1);\n}\n"
        ],
        "134861142": [
            "sub_809D156",
            "0x809d156",
            "int __usercall sub_809D156@<eax>(int a1@<eax>, int a2@<esi>, float a3, double a4)\n{\n  double v6; // [esp+0h] [ebp-10h]\n  int savedregs; // [esp+10h] [ebp+0h] BYREF\n\n  v6 = a4;\n  sub_809C4A3();\n  *(_DWORD *)a1 |= 1u;\n  *(double *)(a1 + 4) = v6;\n  sub_809CEBC((int *)a1, a1, (int)&savedregs, (int)&a4, a2, SLOBYTE(v6));\n  return a1;\n}\n"
        ],
        "134861201": [
            "sub_809D191",
            "0x809d191",
            "int __usercall sub_809D191@<eax>(_DWORD *a1@<eax>, int a2@<esi>)\n{\n  long double v4; // [esp-8h] [ebp-10h]\n\n  *(double *)&v4 = sub_809C6F9(a1) + 1.0;\n  return sub_809D156((int)a1, a2, *(float *)&v4, *(double *)((char *)&v4 + 4));\n}\n"
        ],
        "134861253": [
            "sub_809D1C5",
            "0x809d1c5",
            "int __usercall sub_809D1C5@<eax>(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4@<esi>, int a5, ...)\n{\n  const char *v6; // eax\n  char v8; // [esp-4h] [ebp-10h]\n  int savedregs; // [esp+Ch] [ebp+0h] BYREF\n  va_list va; // [esp+18h] [ebp+Ch] BYREF\n\n  va_start(va, a5);\n  v8 = a3;\n  if ( a1 != a2 )\n  {\n    a4 = a2;\n    sub_809C4A3(a3);\n    *(_DWORD *)a1 |= *(_DWORD *)a4 & 0xFFFF83FD;\n    *(double *)(a1 + 4) = *(double *)(a4 + 4);\n    v6 = *(const char **)(a4 + 12);\n    if ( v6 )\n      *(_DWORD *)(a1 + 12) = sub_804DB46(v6);\n  }\n  sub_809CEBC((int *)a1, a1, (int)&savedregs, (int)va, a4, v8);\n  return a1;\n}\n"
        ],
        "134861333": [
            "sub_809D215",
            "0x809d215",
            "int __usercall sub_809D215@<eax>(const char *a1@<esi>)\n{\n  int v1; // ebx\n  int result; // eax\n  FILE *v3; // edi\n  int v4; // eax\n  int v5; // eax\n  const char *v6; // eax\n  double v7; // [esp+0h] [ebp-18h]\n  int savedregs; // [esp+18h] [ebp+0h] BYREF\n\n  v1 = dword_80DBB80;\n  if ( *(_DWORD *)(dword_80DBB80 + 112) )\n    fclose(*(FILE **)(dword_80DBB80 + 112));\n  *(_DWORD *)(v1 + 112) = 0;\n  *(_DWORD *)(v1 + 120) = 0;\n  *(_DWORD *)(v1 + 128) = 0;\n  while ( 1 )\n  {\n    v7 = sub_809C6F9((_DWORD *)*(_DWORD *)(v1 + 56));\n    if ( v7 + 1.0 >= sub_809C6F9((_DWORD *)*(_DWORD *)(v1 + 60)) )\n      break;\n    v4 = sub_809D191(*(_DWORD **)(v1 + 56), (int)a1);\n    sub_809CB8E(v4);\n    sub_809C3B7(*(int **)(v1 + 64));\n    v5 = sub_809C86E();\n    v6 = sub_809CB8E(v5);\n    a1 = v6;\n    if ( v6 && *v6 && !sub_809D0BB(v6, (int)&savedregs) )\n    {\n      v3 = (FILE *)sub_80B3D9B();\n      goto LABEL_11;\n    }\n  }\n  result = 0;\n  if ( *(_BYTE *)(v1 + 109) )\n    return result;\n  v3 = stdin;\n  a1 = \"-\";\nLABEL_11:\n  *(_BYTE *)(v1 + 109) = 1;\n  sub_809D090(*(int **)(v1 + 44), a1, (int)&savedregs, (int)v3);\n  *(_DWORD *)(v1 + 112) = v3;\n  return v1 + 112;\n}\n"
        ],
        "134861545": [
            "sub_809D2E9",
            "0x809d2e9",
            "int __usercall sub_809D2E9@<eax>(unsigned int a1@<eax>)\n{\n  int v1; // esi\n  char *v2; // ebx\n  int v3; // ecx\n  int v4; // edx\n  char *v5; // ebx\n  char *v6; // edi\n  char v7; // al\n  int v8; // edi\n  char *v9; // edi\n  _BYTE *v10; // edx\n  char v11; // al\n  _BYTE *v12; // ebx\n  char *v13; // eax\n  size_t v14; // eax\n  int v15; // eax\n  char v16; // al\n  char v17; // al\n  int v18; // eax\n  int v19; // edx\n  unsigned int v21; // [esp+0h] [ebp-30h]\n  char v22; // [esp+8h] [ebp-28h]\n  _DWORD *v23; // [esp+Ch] [ebp-24h]\n  _BYTE *v24; // [esp+10h] [ebp-20h]\n  size_t v25; // [esp+10h] [ebp-20h]\n  char *s2; // [esp+14h] [ebp-1Ch]\n  char *v28; // [esp+1Ch] [ebp-14h] BYREF\n\n  v1 = dword_80DBB80;\n  if ( *(_BYTE *)(dword_80DBB80 - 3) )\n  {\n    *(_BYTE *)(dword_80DBB80 - 3) = 0;\n  }\n  else if ( *(_BYTE *)(dword_80DBB80 + 108) )\n  {\n    *(_BYTE *)(dword_80DBB80 + 108) = 0;\n    *(_DWORD *)(v1 + 4) = *(_DWORD *)(v1 + 96);\n    *(_DWORD *)v1 = *(_DWORD *)(v1 + 100);\n  }\n  else\n  {\n    v2 = *(char **)(dword_80DBB80 - 16);\n    v21 = a1 >> 2;\n    do\n    {\n      v2 = sub_809C325(v2);\n      v4 = *(_DWORD *)(v1 + 12);\n      *(_DWORD *)(v1 - 36) = v4;\n      if ( *v2 == 35 )\n      {\n        while ( *v2 != 10 && *v2 )\n          ++v2;\n      }\n      if ( *v2 == 10 )\n        *(_DWORD *)(v1 + 12) = v4 + 1;\n      LOBYTE(v3) = *v2;\n      if ( !*v2 )\n      {\n        v8 = 0x2000000;\n        goto LABEL_64;\n      }\n      if ( (_BYTE)v3 == 34 )\n      {\n        v5 = v2 + 1;\n        *(_DWORD *)(v1 + 8) = v5;\n        v6 = v5;\n        while ( 1 )\n        {\n          v7 = *v5;\n          if ( *v5 == 34 )\n            break;\n          if ( v7 == 10 || !v7 )\n            goto LABEL_37;\n          v28 = v5;\n          *v6++ = sub_809C9C4((int *)&v28, v3);\n          v5 = v28;\n        }\n        v2 = v5 + 1;\n        *v6 = 0;\n        v8 = 0x20000000;\n      }\n      else if ( (v21 & 1) != 0 && (_BYTE)v3 == 47 )\n      {\n        v9 = v2 + 1;\n        *(_DWORD *)(v1 + 8) = v2 + 1;\n        v10 = v2 + 1;\n        while ( 1 )\n        {\n          v11 = *v9;\n          if ( *v9 == 47 )\n            break;\n          if ( !v11 || v11 == 10 )\n            goto LABEL_37;\n          *v10 = v11;\n          v12 = v10 + 1;\n          if ( v11 == 92 )\n          {\n            v24 = v10;\n            v28 = v9 + 1;\n            *v10 = sub_80B0CB3(v9 + 1);\n            if ( v9[1] == 92 )\n            {\n              v12 = v24 + 2;\n              v24[1] = 92;\n            }\n            v13 = v28;\n            if ( v28 == v9 + 1 )\n            {\n              v13 = v9 + 2;\n              *v12++ = v9[1];\n            }\n            v10 = v12;\n            v9 = v13;\n          }\n          else\n          {\n            ++v10;\n            ++v9;\n          }\n        }\n        v2 = v9 + 1;\n        *v10 = 0;\n        v8 = 4;\n      }\n      else if ( (_BYTE)v3 == 46 || (unsigned __int8)(v3 - 48) <= 9u )\n      {\n        v28 = v2;\n        *(double *)(v1 - 116) = sub_809C668();\n        v2 = v28;\n        if ( *v28 == 46 )\n          goto LABEL_37;\n        v8 = 0x40000000;\n      }\n      else\n      {\n        v23 = &unk_80B6AE0;\n        v8 = 1;\n        s2 = (char *)&unk_80D79D0;\n        while ( 1 )\n        {\n          v14 = (unsigned __int8)*s2;\n          if ( !(_BYTE)v14 )\n            break;\n          ++s2;\n          if ( (_BYTE)v14 == 0xFF )\n          {\n            v8 *= 2;\n          }\n          else\n          {\n            v25 = v14;\n            if ( (v8 & (a1 | 0x1FF8080)) != 0 )\n            {\n              v22 = v3;\n              v15 = strncmp(v2, s2, v14);\n              LOBYTE(v3) = v22;\n              if ( !v15 )\n              {\n                if ( (v8 & 0x1FF0080) == 0\n                  || (v16 = v2[v25], (unsigned __int8)(v16 - 48) > 9u)\n                  && (unsigned __int8)((v16 | 0x20) - 97) > 0x19u\n                  && v16 != 95 )\n                {\n                  *(_DWORD *)v1 = *v23;\n                  v2 += v25;\n                  goto LABEL_64;\n                }\n              }\n            }\n            ++v23;\n            s2 += v25;\n          }\n        }\n        if ( (unsigned __int8)((v3 | 0x20) - 97) > 0x19u && (_BYTE)v3 != 95 )\n          goto LABEL_37;\n        *(_DWORD *)(v1 + 8) = --v2;\n        while ( 1 )\n        {\n          v17 = *++v2;\n          if ( (unsigned __int8)(*v2 - 48) > 9u && (unsigned __int8)((*v2 | 0x20) - 97) > 0x19u && v17 != 95 )\n            break;\n          *(v2 - 1) = v17;\n        }\n        *(v2 - 1) = 0;\n        if ( (a1 & 0xC000000) != 0x4000000 )\n          v2 = sub_809C325(v2);\n        v8 = 0x10000000;\n        if ( *v2 != 40 )\n        {\n          v8 = 0x4000000;\n          if ( *v2 == 91 )\n          {\n            ++v2;\n            v8 = 0x8000000;\n          }\n        }\n      }\nLABEL_64:\n      *(_DWORD *)(v1 - 16) = v2;\n      v18 = *(_DWORD *)(v1 + 104);\n    }\n    while ( (v18 & 0xF3C0) != 0 && (v8 & 0x8000) != 0 );\n    if ( (v18 & 0x64000812) != 0 && (v8 & 0x7C380421) != 0 && (a1 & 0x3C0) != 0 )\n    {\n      *(_BYTE *)(v1 + 108) = 1;\n      *(_DWORD *)(v1 + 96) = v8;\n      *(_DWORD *)(v1 + 100) = *(_DWORD *)v1;\n      *(_DWORD *)v1 = 588190976;\n      v8 = 960;\n    }\n    *(_DWORD *)(v1 + 4) = v8;\n  }\n  v19 = *(_DWORD *)(v1 + 4);\n  *(_DWORD *)(v1 + 104) = v19;\n  if ( (v19 & a1) == 0 )\nLABEL_37:\n    sub_809CA86();\n  return v19;\n}\n"
        ],
        "134862334": [
            "sub_809D5FE",
            "0x809d5fe",
            "int __usercall sub_809D5FE@<eax>(unsigned int a1@<eax>)\n{\n  int v2; // esi\n  int v3; // eax\n  unsigned int i; // ebx\n  int v5; // eax\n  _DWORD *v6; // eax\n  _DWORD *v7; // ebp\n  int result; // eax\n  int v9; // edx\n  int v10; // [esp+0h] [ebp-10h]\n\n  v2 = dword_80DBB80;\n  v3 = *(_DWORD *)(dword_80DBB80 - 20);\n  if ( a1 < v3 + 16 || *(_DWORD *)(v3 + 4) <= a1 )\n    sub_809CA86();\n  for ( i = a1; ; i += 20 )\n  {\n    v5 = *(_DWORD *)(v2 - 20);\n    if ( *(_DWORD *)(v5 + 4) <= i )\n      break;\n    if ( (*(_DWORD *)i & 0x2002) == 2 )\n    {\n      sub_809C3B7((int *)i);\n      sub_809C53C();\n      free(*(void **)(*(_DWORD *)(i + 16) + 16));\n      free(*(void **)(i + 16));\n    }\n    if ( (*(_DWORD *)i & 0x800) != 0 )\n    {\n      v6 = *(_DWORD **)(i + 16);\n      *(_DWORD *)(i + 16) = 0;\n      while ( v6 )\n      {\n        v7 = (_DWORD *)v6[2];\n        free(v6);\n        v6 = v7;\n      }\n    }\n    sub_809C4A3(v10);\n  }\n  *(_DWORD *)(v5 + 4) = a1;\n  while ( 1 )\n  {\n    result = *(_DWORD *)(v2 - 20);\n    v9 = *(_DWORD *)(result + 8);\n    if ( !v9 || *(_DWORD *)(result + 4) != result + 16 )\n      break;\n    *(_DWORD *)(v2 - 20) = v9;\n  }\n  return result;\n}\n"
        ],
        "134862505": [
            "sub_809D6A9",
            "0x809d6a9",
            "decompilation failure at 809D6A9!\n"
        ],
        "134863163": [
            "sub_809D93B",
            "0x809d93b",
            "decompilation failure at 809D93B!\n"
        ],
        "134864007": [
            "sub_809DC87",
            "0x809dc87",
            "int sub_809DC87()\n{\n  sub_809D2E9(1u);\n  return sub_809D93B();\n}\n"
        ],
        "134864067": [
            "sub_809DCC3",
            "0x809dcc3",
            "_DWORD *sub_809DCC3()\n{\n  _DWORD *v0; // ebx\n  int v1; // eax\n  _DWORD *result; // eax\n  int v3; // eax\n  int v4; // ebx\n  unsigned int v5; // edx\n  int v6; // ebx\n  _DWORD *v7; // esi\n  _DWORD *v8; // edi\n  _DWORD *v9; // esi\n  _DWORD *v10; // esi\n  int v11; // ebx\n  _DWORD *v12; // eax\n  _DWORD *v13; // esi\n  _DWORD *v14; // eax\n  int v15; // ebx\n  _DWORD *v16; // eax\n  int v17; // edx\n\n  do\n    v1 = sub_809D2E9(0x7C3BD425u);\n  while ( (v1 & 0x8000) != 0 );\n  if ( (v1 & 0x1000) != 0 )\n  {\n    while ( 1 )\n    {\n      result = (_DWORD *)sub_809D2E9(0x7C3BF425u);\n      if ( result == (_DWORD *)0x2000 )\n        break;\n      if ( *(char *)(dword_80DBB80 + 5) >= 0 )\n      {\n        sub_809C35F();\n        sub_809DCC3();\n      }\n    }\n    return result;\n  }\n  if ( (v1 & 0x7C38C425) != 0 )\n  {\n    sub_809C35F();\n    v3 = 66048;\n    goto LABEL_40;\n  }\n  v4 = dword_80DBB80;\n  v3 = *(_DWORD *)dword_80DBB80;\n  v5 = *(_DWORD *)dword_80DBB80 & 0xFF00;\n  if ( v5 == 2304 )\n  {\n    v16 = sub_809C596(512);\n    v17 = *(_DWORD *)(v4 - 64);\nLABEL_37:\n    v16[4] = v17;\n    v3 = *(_DWORD *)v4;\n    goto LABEL_40;\n  }\n  if ( v5 > 0x900 )\n  {\n    if ( v5 == 12544 )\n    {\n      v10 = sub_809C596(512);\n      v11 = sub_809DF36();\n      v10[4] = *(_DWORD *)(v11 + 16);\n      sub_809D2E9(0x20000u);\n      result = (_DWORD *)sub_809DC87();\n      *(_DWORD *)(v11 + 8) = result;\n      return result;\n    }\n    if ( v5 <= 0x3100 )\n    {\n      if ( v5 == 12288 )\n      {\n        v7 = sub_809C596(67328);\n        v7[2] = sub_809DC87();\n        sub_809DCC3();\n        v8 = sub_809C596(512);\n        v7[3] = *(_DWORD *)(*(_DWORD *)(v4 - 72) + 4);\n        if ( sub_809D2E9(0x7C3FF425u) == 0x40000 )\n        {\n          sub_809DCC3();\n          result = *(_DWORD **)(*(_DWORD *)(v4 - 72) + 4);\n          v8[4] = result;\n          return result;\n        }\n        return (_DWORD *)sub_809C35F();\n      }\n      goto LABEL_40;\n    }\n    if ( v5 == 12800 )\n    {\n      sub_809D2E9(1u);\n      v12 = (_DWORD *)sub_809D93B();\n      v13 = v12;\n      if ( (*(_BYTE *)(v4 + 4) & 2) != 0 )\n      {\n        if ( !v12 || (*v12 & 0xFF00) != 6912 )\n          sub_809CA86();\n        v14 = sub_809C596(198144);\n        v14[2] = v13[2];\n        v14[3] = v13[3];\n        result = (_DWORD *)sub_809DF36();\n        *result = 69120;\n        result[2] = v13[2];\n      }\n      else\n      {\n        sub_809C596(66048)[2] = v12;\n        v15 = sub_809D93B();\n        sub_809D93B();\n        result = (_DWORD *)sub_809DF36();\n        result[2] = v15;\n        if ( !v15 )\n          *result = 512;\n      }\n      return result;\n    }\n    if ( v5 == 13056 )\n    {\n      v6 = sub_809DC87();\n      result = (_DWORD *)sub_809DF36();\n      result[2] = v6;\n      return result;\n    }\nLABEL_40:\n    v0 = sub_809C596(v3);\n    v0[2] = sub_809D93B();\n    result = (_DWORD *)dword_80DBB80;\n    if ( (*(_BYTE *)(dword_80DBB80 + 5) & 0x20) == 0 )\n      return result;\n    return (_DWORD *)sub_809C35F();\n  }\n  if ( v5 != 1280 )\n  {\n    if ( v5 != 2048 )\n    {\n      if ( v5 != 1024 )\n        goto LABEL_40;\n      goto LABEL_23;\n    }\n    v16 = sub_809C596(512);\n    v17 = *(_DWORD *)(v4 - 68);\n    goto LABEL_37;\n  }\nLABEL_23:\n  v9 = sub_809C596(v3);\n  result = (_DWORD *)sub_809D93B();\n  v9[2] = result;\n  if ( (*(_BYTE *)(v4 + 4) & 8) != 0 )\n  {\n    *v9 |= *(_DWORD *)v4;\n    result = (_DWORD *)sub_809D93B();\n    v9[3] = result;\n  }\n  if ( (*(_BYTE *)(v4 + 5) & 0x20) != 0 )\n    return (_DWORD *)sub_809C35F();\n  return result;\n}\n"
        ],
        "134864694": [
            "sub_809DF36",
            "0x809df36",
            "_DWORD *__usercall sub_809DF36@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // edi\n  int v3; // ebp\n  _DWORD *v4; // esi\n  _DWORD *v5; // eax\n  int v6; // eax\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 - 68);\n  v3 = *(_DWORD *)(dword_80DBB80 - 64);\n  v4 = sub_809C596(67328);\n  *(_DWORD *)(v1 - 64) = sub_809C3DD(512);\n  *(_DWORD *)(v1 - 68) = sub_809C3DD(512);\n  sub_809DCC3();\n  v5 = sub_809C596(66048);\n  v5[2] = a1;\n  v5[4] = v4;\n  *(_DWORD *)(*(_DWORD *)(v1 - 64) + 16) = v5;\n  v6 = *(_DWORD *)(*(_DWORD *)(v1 - 72) + 4);\n  v4[3] = v6;\n  *(_DWORD *)(*(_DWORD *)(v1 - 68) + 16) = v6;\n  *(_DWORD *)(v1 - 64) = v3;\n  *(_DWORD *)(v1 - 68) = v2;\n  return v4;\n}\n"
        ],
        "134864811": [
            "sub_809DFAB",
            "0x809dfab",
            "int __usercall sub_809DFAB@<eax>(int a1@<eax>)\n{\n  int v1; // ebx\n  int result; // eax\n  int v3; // eax\n  _DWORD *v4; // esi\n  int v5; // eax\n  int v6; // edx\n  _DWORD *v7; // esi\n\n  v1 = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 - 16) = a1;\n  *(_DWORD *)(v1 + 12) = 1;\n  while ( 1 )\n  {\n    result = sub_809D2E9(0x7FF8D425u);\n    if ( result == 0x2000000 )\n      return result;\n    if ( (result & 0xC000) == 0 )\n    {\n      *(_DWORD *)(v1 - 72) = v1 - 96;\n      if ( (result & 0x800000) != 0 )\n      {\n        v3 = v1 - 108;\nLABEL_8:\n        *(_DWORD *)(v1 - 72) = v3;\n        goto LABEL_20;\n      }\n      if ( (result & 0x1000000) != 0 )\n      {\n        v3 = v1 - 84;\n        goto LABEL_8;\n      }\n      if ( (result & 0x400000) != 0 )\n      {\n        sub_809D2E9(0x10000000u);\n        ++*(_DWORD *)(v1 - 16);\n        v4 = (_DWORD *)sub_809C86E();\n        v4[1] = 0;\n        *v4 = 0;\n        do\n        {\n          if ( (sub_809D2E9(0x4000002u) & 0x4000000) == 0 )\n            break;\n          v5 = sub_809C86E();\n          v6 = (*v4)++;\n          *(_DWORD *)(v5 + 16) = v6;\n        }\n        while ( (sub_809D2E9(0x102u) & 2) == 0 );\n        *(_DWORD *)(v1 - 72) = v4 + 1;\n        sub_809DCC3();\n        sub_809C53C();\n      }\n      else if ( (result & 0x7C380425) != 0 )\n      {\n        sub_809C35F();\n        v7 = sub_809C596(3328);\n        v7[2] = sub_809D93B();\n        if ( (*(_BYTE *)(v1 + 5) & 0x10) != 0 )\n        {\n          sub_809C35F();\n          sub_809DCC3();\n        }\n        else\n        {\n          sub_809C596(1024);\n        }\n        v7[3] = *(_DWORD *)(v1 - 92);\n      }\n      else\n      {\n        sub_809C35F();\nLABEL_20:\n        sub_809DCC3();\n      }\n    }\n  }\n}\n"
        ],
        "134865103": [
            "sub_809E0CF",
            "0x809e0cf",
            "decompilation failure at 809E0CF!\n"
        ],
        "134868221": [
            "sub_809ECFD",
            "0x809ecfd",
            "decompilation failure at 809ECFD!\n"
        ],
        "134868324": [
            "sub_809ED64",
            "0x809ed64",
            "decompilation failure at 809ED64!\n"
        ],
        "134868451": [
            "sub_809EDE3",
            "0x809ede3",
            "decompilation failure at 809EDE3!\n"
        ],
        "134868990": [
            "sub_809EFFE",
            "0x809effe",
            "decompilation failure at 809EFFE!\n"
        ],
        "134870485": [
            "sub_809F5D5",
            "0x809f5d5",
            "decompilation failure at 809F5D5!\n"
        ],
        "134870939": [
            "sub_809F79B",
            "0x809f79b",
            "int sub_809F79B()\n{\n  int *v0; // eax\n\n  v0 = (int *)sub_809E0CF(dword_80DBB80, dword_80DBB80 + 176);\n  return sub_809C777(v0);\n}\n"
        ],
        "134870961": [
            "sub_809F7B1",
            "0x809f7b1",
            "decompilation failure at 809F7B1!\n"
        ],
        "134871856": [
            "sub_809FB30",
            "0x809fb30",
            "decompilation failure at 809FB30!\n"
        ],
        "134872504": [
            "sub_809FDB8",
            "0x809fdb8",
            "int __cdecl sub_809FDB8(_DWORD *a1, _DWORD *a2)\n{\n  int result; // eax\n\n  result = a1[2] - a2[2];\n  if ( !result )\n    return *a1 - *a2;\n  return result;\n}\n"
        ],
        "134872525": [
            "sub_809FDCD",
            "0x809fdcd",
            "decompilation failure at 809FDCD!\n"
        ],
        "134872590": [
            "sub_809FE0E",
            "0x809fe0e",
            "int __userpurge sub_809FE0E@<eax>(int a1@<eax>, _DWORD *a2@<ecx>, int a3)\n{\n  const char *i; // esi\n  int v5; // eax\n  char **v6; // edi\n\n  for ( i = (const char *)(*a2 + a1); *i == 47; ++i )\n    ;\n  v5 = sub_80B4733(a2[2], 1030);\n  a2[3] = v5;\n  v6 = (char **)(v5 + 4 * a2[2]);\n  *v6 = sub_804DB46(i);\n  ++a2[2];\n  return 1;\n}\n"
        ],
        "134872655": [
            "sub_809FE4F",
            "0x809fe4f",
            "decompilation failure at 809FE4F!\n"
        ],
        "134872785": [
            "sub_809FED1",
            "0x809fed1",
            "decompilation failure at 809FED1!\n"
        ],
        "134872821": [
            "sub_809FEF5",
            "0x809fef5",
            "decompilation failure at 809FEF5!\n"
        ],
        "134873009": [
            "sub_809FFB1",
            "0x809ffb1",
            "void __usercall sub_809FFB1(\n        int a1@<eax>,\n        int *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        _DWORD *a8,\n        int a9,\n        int a10,\n        int a11,\n        int a12,\n        int a13,\n        int a14,\n        int a15,\n        int a16,\n        int a17,\n        int a18,\n        int a19,\n        int a20,\n        int a21,\n        int a22,\n        int a23,\n        int a24,\n        int a25,\n        int a26,\n        int a27)\n{\n  int i; // esi\n  _DWORD *v28; // edi\n  unsigned int v29; // ebx\n  __int16 v30; // ax\n  __int16 v31; // bp\n  int v32; // edx\n  int v33; // edi\n  int v34; // ecx\n  int v35; // eax\n  _DWORD *v36; // eax\n  int k; // edx\n  int v38; // ebx\n  int *v40; // [esp+80h] [ebp+4h]\n  int m; // [esp+80h] [ebp+4h]\n  int j; // [esp+88h] [ebp+Ch]\n  int v44; // [esp+88h] [ebp+Ch]\n\n  v40 = a2;\n  for ( i = 0; ; i = 1 )\n  {\n    v28 = sub_804DAFA(0x4D4u);\n    *(&a26 + i) = (int)v28;\n    *(_DWORD *)(a1 + 4) = 0;\n    *(_DWORD *)(a1 + 8) = 0;\n    fseeko64();\n    *a8 = 0;\n    *v28 = 0;\n    v28[1] = 0;\n    v29 = 100;\n    do\n    {\n      for ( j = 0; ; j = (j << 7) - (j - (v30 & 0x1FF)) )\n      {\n        v30 = sub_809FEF5();\n        v31 = v30;\n        if ( (v30 & 0x200) != 0 )\n          break;\n      }\n      v32 = (*v40)++;\n      if ( v32 == v29 )\n      {\n        v29 = (3 * v29) >> 1;\n        *(&a26 + i) = (int)sub_804DB13((void *)*(&a26 + i), 12 * v29 + 36);\n      }\n      v33 = *(&a26 + i);\n      *(_DWORD *)(v33 + 12 * *v40 + 8) = j & 0x7FFFFFFF;\n      v34 = *(_DWORD *)(a1 + 8);\n      v35 = 12 * *v40;\n      *(_DWORD *)(v33 + v35) = *(_DWORD *)(a1 + 4);\n      *(_DWORD *)(v33 + v35 + 4) = v34;\n    }\n    while ( (v31 & 0x400) == 0 );\n    if ( ++*(_QWORD *)(v33 + 12 * *v40) - *(_QWORD *)(v33 + 12 * *v40 - 12) == 1LL )\n      --*v40;\n    v36 = sub_804DAFA(8 * *v40 + 16);\n    *(_DWORD *)(a3 + 4 * i) = v36;\n    v44 = *v40;\n    for ( k = 0; v44 >= k; ++k )\n    {\n      v38 = *(_DWORD *)(v33 + 12 * k + 4);\n      v36[2 * k] = *(_DWORD *)(v33 + 12 * k);\n      v36[2 * k + 1] = v38;\n    }\n    a1 += 12;\n    ++v40;\n    if ( i == 1 )\n    {\n      for ( m = 0; *a2 > m && a2[1] > m && *(_DWORD *)(a26 + 12 * m + 20) == *(_DWORD *)(a27 + 12 * m + 20); ++m )\n        ;\n      JUMPOUT(0x80A01E3);\n    }\n  }\n}\n"
        ],
        "134874832": [
            "sub_80A06D0",
            "0x80a06d0",
            "decompilation failure at 80A06D0!\n"
        ],
        "134875211": [
            "sub_80A084B",
            "0x80a084b",
            "decompilation failure at 80A084B!\n"
        ],
        "134876540": [
            "sub_80A0D7C",
            "0x80a0d7c",
            "decompilation failure at 80A0D7C!\n"
        ],
        "134878115": [
            "sub_80A13A3",
            "0x80a13a3",
            "_DWORD *__usercall sub_80A13A3@<eax>(int *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *result; // eax\n  int v5; // edx\n  _DWORD *v6; // ecx\n\n  result = sub_804DAFA(0xCu);\n  result[2] = a2;\n  v5 = *a1;\n  if ( *a1 )\n  {\n    *result = v5;\n    v6 = *(_DWORD **)(v5 + 4);\n    result[1] = v6;\n    *v6 = result;\n    *(_DWORD *)(v5 + 4) = result;\n  }\n  else\n  {\n    result[1] = result;\n    *result = result;\n    *a1 = (int)result;\n  }\n  return result;\n}\n"
        ],
        "134878165": [
            "sub_80A13D5",
            "0x80a13d5",
            "decompilation failure at 80A13D5!\n"
        ],
        "134878252": [
            "sub_80A142C",
            "0x80a142c",
            "decompilation failure at 80A142C!\n"
        ],
        "134878376": [
            "sub_80A14A8",
            "0x80a14a8",
            "decompilation failure at 80A14A8!\n"
        ],
        "134878404": [
            "sub_80A14C4",
            "0x80a14c4",
            "decompilation failure at 80A14C4!\n"
        ],
        "134878535": [
            "sub_80A1547",
            "0x80a1547",
            "decompilation failure at 80A1547!\n"
        ],
        "134880457": [
            "sub_80A1CC9",
            "0x80a1cc9",
            "decompilation failure at 80A1CC9!\n"
        ],
        "134880580": [
            "sub_80A1D44",
            "0x80a1d44",
            "decompilation failure at 80A1D44!\n"
        ],
        "134880597": [
            "sub_80A1D55",
            "0x80a1d55",
            "decompilation failure at 80A1D55!\n"
        ],
        "134880720": [
            "sub_80A1DD0",
            "0x80a1dd0",
            "void *__usercall sub_80A1DD0@<eax>(void *a1@<eax>, int a2@<edx>)\n{\n  int v3; // ebp\n  void *v4; // esi\n  const char *i; // ebx\n\n  v3 = a2;\n  v4 = sub_804DAFA(a2 + 1);\n  for ( i = \"\\nn\\tt\\rr\"; *i; i += 2 )\n  {\n    v3 = sub_80A1D55(v3, a1);\n    a1 = v4;\n  }\n  return v4;\n}\n"
        ],
        "134880785": [
            "sub_80A1E11",
            "0x80a1e11",
            "decompilation failure at 80A1E11!\n"
        ],
        "134880996": [
            "sub_80A1EE4",
            "0x80a1ee4",
            "decompilation failure at 80A1EE4!\n"
        ],
        "134881102": [
            "sub_80A1F4E",
            "0x80a1f4e",
            "decompilation failure at 80A1F4E!\n"
        ],
        "134881212": [
            "sub_80A1FBC",
            "0x80a1fbc",
            "decompilation failure at 80A1FBC!\n"
        ],
        "134882344": [
            "sub_80A2428",
            "0x80a2428",
            "decompilation failure at 80A2428!\n"
        ],
        "134882400": [
            "sub_80A2460",
            "0x80a2460",
            "int __usercall sub_80A2460@<eax>(char a1@<al>)\n{\n  int result; // eax\n\n  if ( dword_80DB808 == dword_80DB80C )\n  {\n    dword_80DB804 = (int)sub_804DB13((void *)dword_80DB804, dword_80DB808 + 64);\n    dword_80DB80C += 64;\n  }\n  result = dword_80DB808++;\n  *(_BYTE *)(dword_80DB804 + result) = a1;\n  return result;\n}\n"
        ],
        "134882467": [
            "sub_80A24A3",
            "0x80a24a3",
            "decompilation failure at 80A24A3!\n"
        ],
        "134882658": [
            "sub_80A2562",
            "0x80a2562",
            "decompilation failure at 80A2562!\n"
        ],
        "134882708": [
            "sub_80A2594",
            "0x80a2594",
            "decompilation failure at 80A2594!\n"
        ],
        "134882955": [
            "sub_80A268B",
            "0x80a268b",
            "decompilation failure at 80A268B!\n"
        ],
        "134885126": [
            "sub_80A2F06",
            "0x80a2f06",
            "decompilation failure at 80A2F06!\n"
        ],
        "134885777": [
            "sub_80A3191",
            "0x80a3191",
            "_BYTE *sub_80A3191()\n{\n  int i; // ecx\n  _BYTE *result; // eax\n\n  for ( i = dword_80DBB80; ; *(_DWORD *)(i + 8) = result + 1 )\n  {\n    result = *(_BYTE **)(i + 8);\n    if ( *result != 32 && (*result == 10 || (unsigned __int8)(*result - 9) > 4u) )\n      break;\n    if ( (unsigned int)result >= *(_DWORD *)(i + 4) - 1 )\n      break;\n  }\n  return result;\n}\n"
        ],
        "134885825": [
            "sub_80A31C1",
            "0x80a31c1",
            "int sub_80A31C1()\n{\n  int result; // eax\n\n  result = dword_80DBB80;\n  *(_DWORD *)(dword_80DBB80 + 128) = 26;\n  *(_BYTE *)(result + 94) = 0;\n  return result;\n}\n"
        ],
        "134885845": [
            "sub_80A31D5",
            "0x80a31d5",
            "char sub_80A31D5()\n{\n  unsigned int v0; // edx\n  char result; // al\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 128);\n  if ( v0 <= 0x19 )\n    return v0 + 97;\n  result = 68;\n  if ( v0 != 26 )\n    return v0 == 27 ? 85 : 68;\n  return result;\n}\n"
        ],
        "134885886": [
            "sub_80A31FE",
            "0x80a31fe",
            "decompilation failure at 80A31FE!\n"
        ],
        "134885943": [
            "sub_80A3237",
            "0x80a3237",
            "decompilation failure at 80A3237!\n"
        ],
        "134886044": [
            "sub_80A329C",
            "0x80a329c",
            "decompilation failure at 80A329C!\n"
        ],
        "134886076": [
            "sub_80A32BC",
            "0x80a32bc",
            "char sub_80A32BC()\n{\n  int v0; // ebx\n  char result; // al\n\n  v0 = dword_80DBB80;\n  sub_804DA14(6, (struct termios *)(dword_80DBB80 + 404), 0);\n  result = *(_BYTE *)(v0 + 423);\n  *(_BYTE *)(v0 + 92) = result;\n  return result;\n}\n"
        ],
        "134886112": [
            "sub_80A32E0",
            "0x80a32e0",
            "_BOOL4 sub_80A32E0()\n{\n  int v0; // ebx\n  _BOOL4 result; // eax\n\n  v0 = dword_80DBB80;\n  result = sub_804D878(0, (int *)(dword_80DBB80 + 40), (int *)(dword_80DBB80 + 36));\n  if ( *(_DWORD *)(v0 + 36) > 0x1000u )\n    *(_DWORD *)(v0 + 36) = 4096;\n  if ( *(_DWORD *)(v0 + 40) > 0x1000u )\n    *(_DWORD *)(v0 + 40) = 4096;\n  return result;\n}\n"
        ],
        "134886166": [
            "sub_80A3316",
            "0x80a3316",
            "char sub_80A3316()\n{\n  char result; // al\n\n  result = 32;\n  memset(*(void **)(dword_80DBB80 + 76), 32, *(_DWORD *)(dword_80DBB80 + 80));\n  return result;\n}\n"
        ],
        "134886186": [
            "sub_80A332A",
            "0x80a332a",
            "decompilation failure at 80A332A!\n"
        ],
        "134886260": [
            "sub_80A3374",
            "0x80a3374",
            "decompilation failure at 80A3374!\n"
        ],
        "134886430": [
            "sub_80A341E",
            "0x80a341e",
            "char *__usercall sub_80A341E@<eax>(char *result@<eax>, int a2@<edx>, char a3@<cl>)\n{\n  char *v3; // ebp\n  int v4; // eax\n  char v5; // dl\n  int v6; // edx\n  char v7; // dl\n  int *v8; // ebx\n  int v9; // edx\n  char *retaddr; // [esp+18h] [ebp+0h]\n  char v11; // [esp+1Ch] [ebp+4h]\n\n  while ( 1 )\n  {\n    v3 = result;\n    retaddr = (char *)a2;\n    v11 = a3;\n    if ( a3 == 5 )\n      break;\n    if ( a3 == 64 )\n      return result;\n    if ( a3 != 4 )\n      goto LABEL_22;\n    if ( retaddr != (char *)1 )\n      return result;\n    result = (char *)dword_80DBB80;\n    v7 = *(_BYTE *)(dword_80DBB80 + 5108);\n    if ( v7 != 1 )\n    {\n      if ( !v7 )\n      {\nLABEL_19:\n        v6 = *((_DWORD *)result + 1278) + 1;\n        *((_DWORD *)result + 1278) = v6;\n        goto LABEL_11;\n      }\n      if ( v7 == 64 )\n      {\n        *(_BYTE *)(dword_80DBB80 + 5108) = 0;\n        *((_DWORD *)result + 1279) = v3;\n        goto LABEL_19;\n      }\nLABEL_22:\n      v8 = (int *)dword_80DBB80;\n      if ( (a3 & 0xFD) == 1 )\n      {\n        if ( *(char **)(dword_80DBB80 + 4) == &retaddr[(_DWORD)v3] )\n          --retaddr;\n        result = (char *)sub_804DB2E((size_t)(retaddr + 13));\n        qmemcpy(result + 13, v3, (unsigned int)retaddr);\n      }\n      else\n      {\n        result = (char *)sub_804DB2E(0x10u);\n      }\n      *((_DWORD *)result + 2) = retaddr;\n      v9 = *v8;\n      if ( (v11 & 0x20) != 0 )\n        *((_DWORD *)result + 1) = v8[1279] - v9;\n      else\n        *((_DWORD *)result + 1) = &v3[-v9];\n      result[12] = v11 & 0xDF;\n      *(_DWORD *)result = v8[1344];\n      v8[1344] = (int)result;\n      ++v8[5];\n      return result;\n    }\n    ((void (*)(void))sub_80A36B1)();\n    a3 = 4;\nLABEL_21:\n    a2 = 1;\n    result = v3;\n  }\n  if ( retaddr != (char *)1 )\n    return result;\n  v4 = dword_80DBB80;\n  v5 = *(_BYTE *)(dword_80DBB80 + 5108);\n  if ( v5 == 1 )\n    goto LABEL_10;\n  if ( !v5 )\n  {\n    ((void (*)(void))sub_80A36B1)();\n    a3 = 5;\n    goto LABEL_21;\n  }\n  if ( v5 != 64 )\n    goto LABEL_22;\n  *(_BYTE *)(dword_80DBB80 + 5108) = 1;\nLABEL_10:\n  *(_DWORD *)(v4 + 5116) = v3;\n  v6 = *(_DWORD *)(v4 + 5112) + 1;\n  *(_DWORD *)(v4 + 5112) = v6;\n  result = (char *)(v4 - v6);\n  result[5376] = *v3;\nLABEL_11:\n  if ( v6 == 256 )\n    return (char *)sub_80A36B1(a3);\n  return result;\n}\n"
        ],
        "134886813": [
            "sub_80A359D",
            "0x80a359d",
            "decompilation failure at 80A359D!\n"
        ],
        "134886990": [
            "sub_80A364E",
            "0x80a364e",
            "int __usercall sub_80A364E@<eax>(\n        _BYTE *a1@<eax>,\n        _BYTE *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9)\n{\n  _BYTE *v9; // ebx\n  unsigned int v10; // esi\n  _BYTE *v11; // eax\n\n  v9 = a1;\n  v10 = (unsigned int)a2;\n  if ( a1 > a2 )\n  {\n    v9 = a2;\n    v10 = (unsigned int)a1;\n  }\n  if ( a3 <= 0 )\n  {\n    v11 = v9;\n    if ( *v9 == 10 )\n      return (int)v9;\n    while ( (unsigned int)(v11 + 1) <= v10 )\n    {\n      if ( v11[1] == 10 )\n      {\n        v10 = (unsigned int)v11;\n        break;\n      }\n      ++v11;\n    }\n  }\n  sub_80A31FE(*(_DWORD *)(dword_80DBB80 + 128), v10);\n  if ( a8 == 1 )\n    return sub_80A359D(a9, v10);\n  return (int)v9;\n}\n"
        ],
        "134887089": [
            "sub_80A36B1",
            "0x80a36b1",
            "char *sub_80A36B1()\n{\n  int v0; // ebx\n  int v1; // edx\n  char *result; // eax\n\n  v0 = dword_80DBB80;\n  v1 = *(_DWORD *)(dword_80DBB80 + 5112);\n  if ( v1 > 0 )\n  {\n    result = sub_80A341E((char *)(dword_80DBB80 - v1 + 5376), v1, *(_BYTE *)(dword_80DBB80 + 5108) | 0x20);\n    *(_BYTE *)(v0 + 5108) = 64;\n    *(_DWORD *)(v0 + 5112) = 0;\n  }\n  return result;\n}\n"
        ],
        "134887151": [
            "sub_80A36EF",
            "0x80a36ef",
            "unsigned int sub_80A36EF()\n{\n  unsigned int result; // eax\n\n  sub_80A36B1();\n  result = *(_DWORD *)(dword_80DBB80 + 8);\n  if ( result > *(_DWORD *)dword_80DBB80 && *(_BYTE *)(result - 1) != 10 )\n    *(_DWORD *)(dword_80DBB80 + 8) = --result;\n  return result;\n}\n"
        ],
        "134887180": [
            "sub_80A370C",
            "0x80a370c",
            "_BYTE *sub_80A370C()\n{\n  _BYTE *result; // eax\n\n  sub_80A36B1();\n  result = *(_BYTE **)(dword_80DBB80 + 8);\n  if ( (unsigned int)result < *(_DWORD *)(dword_80DBB80 + 4) - 1 && *result != 10 )\n    *(_DWORD *)(dword_80DBB80 + 8) = ++result;\n  return result;\n}\n"
        ],
        "134887212": [
            "sub_80A372C",
            "0x80a372c",
            "decompilation failure at 80A372C!\n"
        ],
        "134887284": [
            "sub_80A3774",
            "0x80a3774",
            "decompilation failure at 80A3774!\n"
        ],
        "134887495": [
            "sub_80A3847",
            "0x80a3847",
            "decompilation failure at 80A3847!\n"
        ],
        "134887535": [
            "sub_80A386F",
            "0x80a386f",
            "decompilation failure at 80A386F!\n"
        ],
        "134887650": [
            "sub_80A38E2",
            "0x80a38e2",
            "decompilation failure at 80A38E2!\n"
        ],
        "134887896": [
            "sub_80A39D8",
            "0x80a39d8",
            "decompilation failure at 80A39D8!\n"
        ],
        "134887983": [
            "sub_80A3A2F",
            "0x80a3a2f",
            "decompilation failure at 80A3A2F!\n"
        ],
        "134888019": [
            "sub_80A3A53",
            "0x80a3a53",
            "decompilation failure at 80A3A53!\n"
        ],
        "134888122": [
            "sub_80A3ABA",
            "0x80a3aba",
            "decompilation failure at 80A3ABA!\n"
        ],
        "134888164": [
            "sub_80A3AE4",
            "0x80a3ae4",
            "_BYTE *sub_80A3AE4()\n{\n  _BYTE *result; // eax\n\n  result = (_BYTE *)sub_80A3ABA();\n  if ( (unsigned int)result < *(_DWORD *)(dword_80DBB80 + 4) - 1 && *result == 10 )\n    ++result;\n  return result;\n}\n"
        ],
        "134888190": [
            "sub_80A3AFE",
            "0x80a3afe",
            "_BYTE *__usercall sub_80A3AFE@<eax>(int a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = *(_BYTE **)dword_80DBB80;\n  while ( a1 > 1 )\n  {\n    result = sub_80A3AE4();\n    --a1;\n  }\n  return result;\n}\n"
        ],
        "134888215": [
            "sub_80A3B17",
            "0x80a3b17",
            "_BYTE *sub_80A3B17()\n{\n  int v0; // ebx\n  _BYTE *result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3AE4();\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
        ],
        "134888240": [
            "sub_80A3B30",
            "0x80a3b30",
            "int __usercall sub_80A3B30@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>)\n{\n  unsigned int v2; // ebx\n  unsigned int v3; // ebp\n  int v4; // edi\n  int v5; // esi\n  _BYTE *v6; // eax\n\n  v2 = a1;\n  if ( a2 < a1 )\n    v2 = a2;\n  v3 = sub_80A3ABA();\n  v4 = dword_80DBB80;\n  v5 = 0;\n  while ( v2 <= v3 && v2 <= *(_DWORD *)(v4 + 4) - 1 )\n  {\n    v6 = (_BYTE *)sub_80A3ABA();\n    if ( *v6 == 10 )\n      ++v5;\n    v2 = (unsigned int)(v6 + 1);\n  }\n  return v5;\n}\n"
        ],
        "134888310": [
            "sub_80A3B76",
            "0x80a3b76",
            "int sub_80A3B76()\n{\n  int v0; // esi\n  int v1; // ebx\n\n  v0 = *(_DWORD *)(dword_80DBB80 + 36);\n  v1 = 1;\n  while ( v0 != ++v1 )\n    sub_80A3AE4();\n  return sub_80A3ABA();\n}\n"
        ],
        "134888348": [
            "sub_80A3B9C",
            "0x80a3b9c",
            "int sub_80A3B9C()\n{\n  int v0; // ebx\n  int result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3ABA();\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
        ],
        "134888373": [
            "sub_80A3BB5",
            "0x80a3bb5",
            "int __usercall sub_80A3BB5@<eax>(unsigned int a1@<eax>)\n{\n  int v1; // ebx\n  int v2; // eax\n\n  v1 = *(_DWORD *)dword_80DBB80;\n  if ( *(_DWORD *)dword_80DBB80 >= a1 )\n    return a1;\n  v2 = memrchr();\n  if ( v2 )\n    return v2 + 1;\n  return v1;\n}\n"
        ],
        "134888415": [
            "sub_80A3BDF",
            "0x80a3bdf",
            "int __usercall sub_80A3BDF@<eax>(unsigned int a1@<eax>)\n{\n  unsigned int v1; // eax\n\n  v1 = sub_80A3BB5(a1);\n  if ( *(_DWORD *)dword_80DBB80 < v1 && *(_BYTE *)(v1 - 1) == 10 )\n    --v1;\n  return sub_80A3BB5(v1);\n}\n"
        ],
        "134888442": [
            "sub_80A3BFA",
            "0x80a3bfa",
            "decompilation failure at 80A3BFA!\n"
        ],
        "134888574": [
            "sub_80A3C7E",
            "0x80a3c7e",
            "int sub_80A3C7E()\n{\n  int v0; // ebx\n  int result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3BDF(*(_DWORD *)(dword_80DBB80 + 8));\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
        ],
        "134888599": [
            "sub_80A3C97",
            "0x80a3c97",
            "decompilation failure at 80A3C97!\n"
        ],
        "134888853": [
            "sub_80A3D95",
            "0x80a3d95",
            "_BYTE *__usercall sub_80A3D95@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // ebx\n  unsigned int v5; // eax\n  _BYTE *v6; // eax\n  unsigned int v7; // eax\n\n  sub_80A36B1();\n  v4 = dword_80DBB80;\n  while ( 1 )\n  {\n    v5 = *(_DWORD *)(v4 + 72);\n    if ( a1 <= 0 )\n      break;\n    if ( a2 == -1 )\n      v6 = (_BYTE *)sub_80A3BDF(v5);\n    else\n      v6 = sub_80A3AE4();\n    *(_DWORD *)(v4 + 72) = v6;\n    --a1;\n  }\n  if ( *(_DWORD *)(v4 + 8) < v5 )\n    *(_DWORD *)(v4 + 8) = v5;\n  v7 = sub_80A3B76();\n  if ( *(_DWORD *)(v4 + 8) > v7 )\n    *(_DWORD *)(v4 + 8) = sub_80A3BB5(v7);\n  return sub_80A3191();\n}\n"
        ],
        "134888935": [
            "sub_80A3DE7",
            "0x80a3de7",
            "unsigned __int8 *__usercall sub_80A3DE7@<eax>(unsigned int a1@<eax>, int a2@<edx>)\n{\n  unsigned __int8 *v3; // esi\n  int v4; // ecx\n  unsigned __int8 v5; // al\n  int v6; // ebx\n\n  v3 = (unsigned __int8 *)sub_80A3BB5(a1);\n  v4 = 0;\n  while ( v4 < a2 )\n  {\n    if ( *(_DWORD *)(dword_80DBB80 + 4) <= (unsigned int)v3 )\n      break;\n    v5 = *v3;\n    if ( *v3 == 10 )\n      break;\n    if ( v5 == 9 )\n    {\n      v6 = v4 + *(_DWORD *)(dword_80DBB80 + 84) - 1 - v4 % *(_DWORD *)(dword_80DBB80 + 84);\n    }\n    else\n    {\n      v6 = v4 + 1;\n      if ( v5 != 127 && v5 > 0x1Fu )\n        v6 = v4;\n    }\n    v4 = v6 + 1;\n    ++v3;\n  }\n  return v3;\n}\n"
        ],
        "134889019": [
            "sub_80A3E3B",
            "0x80a3e3b",
            "int sub_80A3E3B()\n{\n  int v0; // ebx\n  int result; // eax\n\n  sub_80A36B1();\n  v0 = dword_80DBB80;\n  result = sub_80A3BB5(*(_DWORD *)(dword_80DBB80 + 8));\n  *(_DWORD *)(v0 + 8) = result;\n  return result;\n}\n"
        ],
        "134889044": [
            "sub_80A3E54",
            "0x80a3e54",
            "_BOOL4 __usercall sub_80A3E54@<eax>(int a1@<eax>)\n{\n  void *retaddr; // [esp+Ch] [ebp+0h]\n\n  if ( a1 )\n    sub_804DD8F();\n  retaddr = 0;\n  return sub_80B2C0A(10 * a1, 1u) > 0;\n}\n"
        ],
        "134889101": [
            "sub_80A3E8D",
            "0x80a3e8d",
            "int sub_80A3E8D()\n{\n  sub_804DD8F();\n  return sub_804D995((const struct termios *)(dword_80DBB80 + 404));\n}\n"
        ],
        "134889121": [
            "sub_80A3EA1",
            "0x80a3ea1",
            "decompilation failure at 80A3EA1!\n"
        ],
        "134889136": [
            "sub_80A3EB0",
            "0x80a3eb0",
            "decompilation failure at 80A3EB0!\n"
        ],
        "134889209": [
            "sub_80A3EF9",
            "0x80a3ef9",
            "int __fastcall sub_80A3EF9(int a1)\n{\n  sub_80A3EB0(a1, 0);\n  return sub_80A3EA1();\n}\n"
        ],
        "134889235": [
            "sub_80A3F13",
            "0x80a3f13",
            "decompilation failure at 80A3F13!\n"
        ],
        "134889299": [
            "sub_80A3F53",
            "0x80a3f53",
            "decompilation failure at 80A3F53!\n"
        ],
        "134889365": [
            "sub_80A3F95",
            "0x80a3f95",
            "decompilation failure at 80A3F95!\n"
        ],
        "134889481": [
            "sub_80A4009",
            "0x80a4009",
            "decompilation failure at 80A4009!\n"
        ],
        "134889802": [
            "sub_80A414A",
            "0x80a414a",
            "int *__usercall sub_80A414A@<eax>(unsigned __int8 *a1@<eax>, unsigned int *a2@<edx>, int *a3@<ecx>)\n{\n  _DWORD *v3; // ebx\n  unsigned int v4; // edx\n  unsigned int v5; // edi\n  unsigned int v6; // eax\n  int v7; // esi\n  unsigned __int8 *v8; // esi\n  unsigned int i; // ebp\n  unsigned int v10; // eax\n  signed int v11; // ebp\n  signed int v12; // esi\n  signed int v13; // ecx\n  unsigned __int8 v14; // al\n  signed int v15; // edi\n  int v16; // eax\n  int v17; // ecx\n  int *result; // eax\n  unsigned __int8 *retaddr; // [esp+20h] [ebp+0h]\n\n  retaddr = (unsigned __int8 *)sub_80A3BB5((unsigned int)a1);\n  v3 = (_DWORD *)dword_80DBB80;\n  v4 = *(_DWORD *)(dword_80DBB80 + 72);\n  v5 = *(_DWORD *)(dword_80DBB80 + 36) - 1;\n  if ( v4 <= (unsigned int)retaddr )\n  {\n    v10 = sub_80A3B76();\n    if ( (unsigned int)retaddr <= v10 )\n      goto LABEL_4;\n    v6 = sub_80A3B30(v10, (unsigned int)retaddr);\n    if ( v5 >> 1 >= v6 )\n    {\n      v11 = 0;\n      v12 = v6 - 1;\n      while ( v12 > v11 )\n      {\n        v3[18] = sub_80A3AE4();\n        ++v11;\n      }\n      goto LABEL_4;\n    }\n  }\n  else\n  {\n    v6 = sub_80A3B30((unsigned int)retaddr, v4);\n  }\n  v3[18] = retaddr;\n  v7 = 0;\n  if ( v5 >> 1 < v6 )\n  {\n    while ( v7 != v5 >> 1 )\n    {\n      v3[18] = sub_80A3BDF(v3[18]);\n      ++v7;\n    }\n  }\nLABEL_4:\n  v8 = (unsigned __int8 *)v3[18];\n  for ( i = 0; v8 != retaddr && i < v5; ++i )\n    v8 = sub_80A3AE4();\n  v13 = 0;\n  while ( v8 < a1 )\n  {\n    v14 = *v8;\n    if ( *v8 == 10 )\n      break;\n    if ( v14 == 9 )\n    {\n      v15 = v13 + v3[21] - 1 - v13 % v3[21];\n    }\n    else\n    {\n      v15 = v13 + 1;\n      if ( v14 != 127 && v14 > 0x1Fu )\n        v15 = v13;\n    }\n    v13 = v15 + 1;\n    ++v8;\n  }\n  if ( v3[14] > v13 )\n    v3[14] = v13;\n  v16 = v3[10];\n  if ( v16 + v3[14] <= (unsigned int)v13 )\n    v3[14] = v13 - v16 + 1;\n  if ( a1 == retaddr && *a1 == 9 )\n    v3[14] = 0;\n  v17 = v13 - v3[14];\n  *a2 = i;\n  result = a3;\n  *a3 = v17;\n  return result;\n}\n"
        ],
        "134890099": [
            "sub_80A4273",
            "0x80a4273",
            "decompilation failure at 80A4273!\n"
        ],
        "134890680": [
            "sub_80A44B8",
            "0x80a44b8",
            "const char *__usercall sub_80A44B8@<eax>(const char *a1@<eax>)\n{\n  int v1; // esi\n  const char *v2; // edi\n  int v3; // ecx\n  signed int v4; // ebx\n  unsigned int v5; // eax\n  int v6; // edx\n\n  v1 = dword_80DBB80;\n  v2 = (const char *)(dword_80DBB80 + 820);\n  strcpy((char *)(dword_80DBB80 + 820), a1);\n  *(_DWORD *)(v1 + 64) = 0;\n  sub_80A3EF9(v3);\n  sub_80A3EA1();\n  v4 = strlen(v2);\n  while ( v4 <= 127 )\n  {\n    v5 = sub_80A3F95();\n    if ( v5 <= 0x1B )\n    {\n      v6 = 134226944;\n      if ( _bittest(&v6, v5) )\n        break;\n    }\n    if ( v5 == 8 || *(unsigned __int8 *)(v1 + 92) == v5 || v5 == 127 )\n    {\n      --v4;\n      *(_BYTE *)(v1 + v4 + 820) = 0;\n      sub_80A3EA1();\n      if ( v4 <= 0 )\n        break;\n    }\n    else if ( v5 - 1 <= 0xFE )\n    {\n      *(_BYTE *)(v1 + v4++ + 820) = v5;\n      *(_BYTE *)(v1 + v4 + 820) = 0;\n      sub_804DD98(v5);\n    }\n  }\n  sub_80A4273();\n  return v2;\n}\n"
        ],
        "134890855": [
            "sub_80A4567",
            "0x80a4567",
            "int __fastcall sub_80A4567(int a1)\n{\n  sub_80A3EB0(a1, 0);\n  sub_80A3EA1();\n  sub_80A3316();\n  *(_DWORD *)(dword_80DBB80 + 64) = 0;\n  sub_80A4273();\n  return sub_80A45D2();\n}\n"
        ],
        "134890907": [
            "sub_80A459B",
            "0x80a459b",
            "int sub_80A459B()\n{\n  int v0; // eax\n  int v1; // ecx\n\n  sub_80A3EA1();\n  sub_80A3EA1();\n  sub_80A3EA1();\n  do\n    v0 = sub_80A3F95();\n  while ( v0 != 13 && v0 != 10 );\n  return sub_80A4567(v1);\n}\n"
        ],
        "134890962": [
            "sub_80A45D2",
            "0x80a45d2",
            "int __fastcall sub_80A45D2(unsigned __int8 *a1)\n{\n  int v1; // ebx\n  int v2; // esi\n  unsigned int v3; // edi\n  int v4; // ebp\n  int v5; // ecx\n  int v6; // edi\n  unsigned int v7; // edi\n  const char *v8; // eax\n  unsigned int v9; // eax\n  unsigned int v10; // edx\n  int v11; // ecx\n  int v12; // esi\n  int v14; // [esp+0h] [ebp-24h]\n  const char *v15; // [esp+0h] [ebp-24h]\n  const char *v16; // [esp+4h] [ebp-20h]\n  int v17; // [esp+8h] [ebp-1Ch]\n\n  v1 = dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 60);\n  if ( v2 )\n  {\n    v2 = 0;\n    v10 = 0;\n  }\n  else\n  {\n    v3 = *(_DWORD *)(dword_80DBB80 + 8);\n    v4 = sub_80A3B30(*(_DWORD *)dword_80DBB80, v3);\n    v5 = *(_DWORD *)(v1 + 20);\n    if ( v5 != *(_DWORD *)(v1 + 24) )\n    {\n      v14 = *(_DWORD *)(v1 + 20);\n      *(_DWORD *)(v1 + 124) = v4 + sub_80A3B30(v3, *(_DWORD *)(v1 + 4) - 1) - 1;\n      v5 = v14;\n      *(_DWORD *)(v1 + 24) = v14;\n    }\n    v6 = *(_DWORD *)(v1 + 124);\n    if ( v6 <= 0 )\n    {\n      *(_DWORD *)(v1 + 124) = 0;\n      v4 = 0;\n      v17 = 100;\n    }\n    else\n    {\n      v17 = 100 * v4 / v6;\n    }\n    v7 = *(_DWORD *)(v1 + 40);\n    if ( v7 > 0xC7 )\n      v7 = 199;\n    v16 = &data;\n    if ( v5 )\n      v16 = \" [Modified]\";\n    v15 = &data;\n    if ( *(_BYTE *)(v1 + 17) )\n      v15 = \" [Readonly]\";\n    v8 = *(const char **)(v1 + 68);\n    if ( !v8 )\n      v8 = \"No file\";\n    v9 = snprintf(\n           (char *)(v1 + 492),\n           v7 + 1,\n           \"%c %s%s%s %d/%d %d%%\",\n           (unsigned __int8)byte_80D858A[*(_BYTE *)(v1 + 19) & 3],\n           v8,\n           v15,\n           v16,\n           v4,\n           *(_DWORD *)(v1 + 124),\n           v17);\n    a1 = (unsigned __int8 *)(v1 + 492);\n    v10 = v7;\n    if ( v7 > v9 )\n      v10 = v9;\n    while ( v1 + 492 + v10 > (unsigned int)a1 )\n      v2 += *a1++;\n  }\n  if ( *(_DWORD *)(v1 + 60) || v10 && *(_DWORD *)(v1 + 64) != v2 )\n  {\n    *(_DWORD *)(v1 + 64) = v2;\n    sub_80A3EF9((int)a1);\n    sub_80A3EA1();\n    v12 = *(_DWORD *)(v1 + 60);\n    if ( v12 )\n    {\n      if ( strlen((const char *)(v1 + 492)) - v12 + 1 > *(_DWORD *)(v1 + 40) - 1 )\n      {\n        *(_DWORD *)(v1 + 60) = 0;\n        sub_80A459B();\n      }\n      *(_DWORD *)(v1 + 60) = 0;\n    }\n    sub_80A3EB0(v11, *(_DWORD *)(v1 + 52));\n  }\n  return sub_804DD8F();\n}\n"
        ],
        "134891352": [
            "sub_80A4758",
            "0x80a4758",
            "void sub_80A4758()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  int v2; // ecx\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  sub_80A32BC();\n  *(_DWORD *)(dword_80DBB80 + 64) = 0;\n  sub_80A4567(v2);\n  signal(20, sub_80A3F13);\n  signal(18, 0);\n  *v0 = v1;\n}\n"
        ],
        "134891418": [
            "sub_80A479A",
            "0x80a479a",
            "void sub_80A479A()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  int v2; // ecx\n\n  v0 = (_DWORD *)dword_80DBB7C;\n  v1 = *(_DWORD *)dword_80DBB7C;\n  signal(28, sub_80A479A);\n  sub_80A32E0();\n  sub_80A332A();\n  sub_80A4567(v2);\n  *v0 = v1;\n}\n"
        ],
        "134891478": [
            "sub_80A47D6",
            "0x80a47d6",
            "int sub_80A47D6()\n{\n  int v1; // ecx\n  int v2; // ecx\n\n  if ( (*(_BYTE *)(dword_80DBB80 + 16) & 8) == 0 )\n    return sub_80A3EA1();\n  sub_80A3EA1();\n  sub_80A4567(v1);\n  sub_80A3E54(10);\n  sub_80A3EA1();\n  return sub_80A4567(v2);\n}\n"
        ],
        "134891549": [
            "sub_80A481D",
            "0x80a481d",
            "unsigned int __usercall sub_80A481D@<eax>(unsigned int result@<eax>)\n{\n  unsigned int *v1; // ebx\n  unsigned int v2; // edx\n  unsigned int v3; // ebx\n  unsigned int v4; // [esp+0h] [ebp-8h]\n\n  v1 = (unsigned int *)dword_80DBB80;\n  v2 = *(_DWORD *)(dword_80DBB80 + 4);\n  if ( v2 <= result && v2 > *(_DWORD *)dword_80DBB80 )\n  {\n    v4 = v2 - 1;\n    sub_80A47D6();\n    result = v4;\n  }\n  v3 = *v1;\n  if ( v3 > result )\n  {\n    sub_80A47D6();\n    return v3;\n  }\n  return result;\n}\n"
        ],
        "134891600": [
            "sub_80A4850",
            "0x80a4850",
            "int __usercall sub_80A4850@<eax>(char *a1@<eax>, unsigned __int8 a2@<dl>, int a3@<ecx>)\n{\n  char *v3; // edi\n  char *v5; // edi\n  char v6; // cl\n  int v7; // ebx\n  char v9; // cl\n  unsigned __int8 *v10; // ebp\n  int v11; // eax\n  int v12; // esi\n  const char *v13; // esi\n  size_t v14; // eax\n  unsigned int v15; // ebx\n  int v16; // eax\n  char *v17; // ebp\n  const char *v18; // esi\n  int v19; // [esp-Ah] [ebp-1Ch]\n  int v20; // [esp-6h] [ebp-18h]\n  unsigned __int8 v21; // [esp+1h] [ebp-11h]\n\n  v3 = a1;\n  v21 = a2;\n  if ( a2 == 22 )\n  {\n    v5 = &a1[sub_80A3374(a3, 1)];\n    *v5 = 94;\n    sub_80A4273();\n    *v5 = sub_80A3F95();\n    switch ( a3 )\n    {\n      case 2:\n        v6 = 2;\n        break;\n      case 3:\n        v6 = 4;\n        break;\n      case 1:\n        v6 = 0;\n        break;\n      default:\n        return (int)(v5 + 1);\n    }\n    sub_80A341E(v5, 1, v6);\n    return (int)(v5 + 1);\n  }\n  v7 = dword_80DBB80;\n  if ( a2 == 27 )\n  {\n    *(_BYTE *)(dword_80DBB80 + 19) = 0;\n    sub_80A36B1();\n    *(_DWORD *)(v7 + 32) = 0;\n    sub_80A31C1();\n    *(_DWORD *)(v7 + 64) = 0;\n    if ( *(v3 - 1) != 10 && *(_DWORD *)(v7 + 8) > *(_DWORD *)v7 )\n      --v3;\n    return (int)v3;\n  }\n  if ( a2 != 8 && *(_BYTE *)(dword_80DBB80 + 92) != a2 && a2 != 127 )\n  {\n    if ( a2 == 13 || a2 == 10 )\n    {\n      sub_80A36B1();\n      v21 = 10;\n    }\n    switch ( a3 )\n    {\n      case 2:\n        v9 = 2;\n        break;\n      case 3:\n        v9 = 4;\n        break;\n      case 1:\n        v9 = 0;\n        break;\n      default:\n        goto LABEL_28;\n    }\n    sub_80A341E(v3, 1, v9);\nLABEL_28:\n    v10 = (unsigned __int8 *)&v3[((int (*)(void))sub_80A3374)()];\n    *v10 = v21;\n    v3 = (char *)(v10 + 1);\n    if ( (*(_BYTE *)(v7 + 16) & 2) != 0 && strchr(\")]}\", v21) )\n    {\n      v11 = sub_80A3237(v20, v21);\n      if ( v11 )\n      {\n        v12 = *(_DWORD *)(v7 + 8);\n        *(_DWORD *)(v7 + 8) = v11;\n        sub_80A4273();\n        sub_80A3E54(40);\n        *(_DWORD *)(v7 + 8) = v12;\n        sub_80A4273();\n      }\n      else\n      {\n        sub_80A47D6();\n      }\n    }\n    if ( (*(_BYTE *)(v7 + 16) & 1) != 0 && v21 == 10 )\n    {\n      v13 = (const char *)sub_80A3BDF((unsigned int)v3);\n      v14 = strspn(v13, \" \\t\");\n      v15 = v14;\n      if ( v14 )\n      {\n        v16 = sub_80A3374(v19, v14);\n        v17 = &v3[v16];\n        v18 = &v13[v16];\n        sub_80A341E(&v3[v16], v15, 0);\n        qmemcpy(v17, v18, v15);\n        return (int)&v17[v15];\n      }\n    }\n    return (int)v3;\n  }\n  if ( *(_DWORD *)dword_80DBB80 < (unsigned int)a1 )\n    return sub_80A359D(3, a1 - 1);\n  return (int)v3;\n}\n"
        ],
        "134892057": [
            "sub_80A4A19",
            "0x80a4a19",
            "int __usercall sub_80A4A19@<eax>(const char *a1@<eax>)\n{\n  int v2; // edi\n  void *v3; // eax\n  int v4; // ebx\n  _DWORD *v5; // eax\n\n  v2 = dword_80DBB80;\n  free(*(void **)dword_80DBB80);\n  *(_DWORD *)(v2 + 12) = 10240;\n  v3 = sub_804DB2E(0x2800u);\n  *(_DWORD *)v2 = v3;\n  *(_DWORD *)(v2 + 4) = v3;\n  *(_DWORD *)(v2 + 8) = v3;\n  *(_DWORD *)(v2 + 72) = v3;\n  if ( *(const char **)(v2 + 68) != a1 )\n  {\n    free(*(void **)(v2 + 68));\n    *(_DWORD *)(v2 + 68) = sub_804DB46(a1);\n  }\n  v4 = sub_80A4009(1, *(_DWORD *)v2);\n  if ( v4 < 0 )\n    sub_80A4850(*(char **)v2, 0xAu, 0);\n  while ( 1 )\n  {\n    v5 = *(_DWORD **)(v2 + 5376);\n    if ( !v5 )\n      break;\n    *(_DWORD *)(v2 + 5376) = *v5;\n    free(v5);\n  }\n  *(_DWORD *)(v2 + 20) = 0;\n  *(_DWORD *)(v2 + 24) = -1;\n  memset((void *)(v2 + 248), 0, 0x70u);\n  return v4;\n}\n"
        ],
        "134892222": [
            "sub_80A4ABE",
            "0x80a4abe",
            "unsigned int __usercall sub_80A4ABE@<eax>(char *a1@<eax>)\n{\n  char *v1; // edi\n  char v2; // al\n  int v3; // esi\n  unsigned __int8 *v4; // ebx\n  char v5; // al\n  char v6; // al\n  char *v7; // eax\n  const char *v8; // eax\n  char *i; // ebp\n  char v10; // cl\n  const char *v11; // eax\n  int v12; // ecx\n  int v13; // edi\n  int v14; // eax\n  size_t v15; // eax\n  size_t v16; // eax\n  _BYTE *v17; // eax\n  int v18; // edi\n  unsigned int v19; // eax\n  unsigned int v20; // eax\n  int v21; // ebx\n  unsigned int v22; // ebp\n  int v23; // eax\n  int v24; // ebx\n  const char *v25; // ecx\n  const char *v26; // edx\n  size_t v27; // eax\n  size_t v28; // eax\n  int v29; // ecx\n  size_t v30; // eax\n  int v31; // ecx\n  unsigned __int8 v32; // dl\n  int v33; // esi\n  size_t v34; // eax\n  size_t v35; // eax\n  size_t v36; // eax\n  int v37; // eax\n  int v38; // edx\n  size_t v39; // eax\n  _BYTE *v40; // ebx\n  _BYTE *v41; // edi\n  int v42; // eax\n  int v43; // ebx\n  unsigned int v44; // edi\n  int v45; // eax\n  const char *v46; // edx\n  unsigned int v47; // eax\n  size_t v48; // eax\n  size_t v49; // eax\n  int v50; // ebp\n  char *v51; // ebx\n  int v52; // edi\n  char v53; // al\n  const char *v54; // esi\n  const char *v55; // ebx\n  const char *v56; // ecx\n  const char *v57; // edx\n  int v58; // edx\n  int v59; // ecx\n  int v60; // edi\n  char *v61; // eax\n  char *v62; // eax\n  _BYTE *v63; // ebx\n  int v64; // esi\n  int v65; // ebp\n  _BYTE *v66; // edi\n  int v67; // eax\n  int v68; // ebx\n  int v69; // eax\n  size_t v70; // eax\n  size_t v71; // eax\n  size_t v72; // eax\n  size_t v73; // eax\n  int v74; // esi\n  int v75; // eax\n  int v76; // edi\n  int v77; // eax\n  int v78; // eax\n  int v79; // edi\n  unsigned __int8 v80; // bl\n  size_t v81; // eax\n  int v82; // ebx\n  unsigned int result; // eax\n  int v84; // [esp+0h] [ebp-138h]\n  char *v85; // [esp+4h] [ebp-134h]\n  char *v86; // [esp+4h] [ebp-134h]\n  char *src; // [esp+8h] [ebp-130h]\n  unsigned __int8 srca; // [esp+8h] [ebp-130h]\n  char *srcb; // [esp+8h] [ebp-130h]\n  char v90; // [esp+Ch] [ebp-12Ch]\n  int v91; // [esp+10h] [ebp-128h]\n  int v92; // [esp+10h] [ebp-128h]\n  char *v93; // [esp+14h] [ebp-124h]\n  int v94; // [esp+14h] [ebp-124h]\n  int v95; // [esp+18h] [ebp-120h]\n  int v96; // [esp+1Ch] [ebp-11Ch]\n  int v97; // [esp+20h] [ebp-118h]\n  int v98; // [esp+24h] [ebp-114h] BYREF\n  char s; // [esp+28h] [ebp-110h] BYREF\n  char v100; // [esp+29h] [ebp-10Fh]\n  char dest[144]; // [esp+A8h] [ebp-90h] BYREF\n\n  v1 = a1;\n  v2 = *a1;\n  if ( !v2 )\n    goto LABEL_234;\n  if ( v2 == 58 )\n    ++v1;\n  v97 = -1;\n  v96 = -1;\n  v3 = dword_80DBB80;\n  v4 = *(unsigned __int8 **)dword_80DBB80;\n  v85 = (char *)(*(_DWORD *)(dword_80DBB80 + 4) - 1);\n  sub_80A3B30(*(_DWORD *)dword_80DBB80, (unsigned int)v85);\n  v93 = *(char **)(v3 + 68);\n  while ( 1 )\n  {\n    v5 = *v1;\n    if ( *v1 != 32 && v5 != 9 )\n      break;\n    ++v1;\n  }\n  if ( v5 == 37 )\n  {\n    src = v1 + 1;\n    v96 = 1;\n    v97 = sub_80A3B30((unsigned int)v4, (unsigned int)v85);\nLABEL_21:\n    while ( *src == 9 || *src == 32 )\n      ++src;\n    goto LABEL_23;\n  }\n  for ( src = (char *)sub_80A3C97(); ; ++src )\n  {\n    v6 = *src;\n    if ( *src != 32 && v6 != 9 )\n      break;\n  }\n  if ( v6 == 44 )\n  {\n    v7 = src;\n    do\n    {\n      do\n        ++v7;\n      while ( *v7 == 9 );\n    }\n    while ( *v7 == 32 );\n    src = (char *)sub_80A3C97();\n    goto LABEL_21;\n  }\nLABEL_23:\n  v8 = src;\n  for ( i = &s; ; *(i - 1) = v10 )\n  {\n    v10 = *v8;\n    if ( (*v8 & 0xDF) == 0 || (unsigned __int8)(v10 - 9) <= 4u )\n      break;\n    ++v8;\n    ++i;\n  }\n  *i = 0;\n  while ( *v8 == 32 || *v8 == 9 )\n    ++v8;\n  strcpy(dest, v8);\n  v11 = sub_804D378(&s, 33);\n  v95 = 0;\n  if ( v11 )\n  {\n    *v11 = 0;\n    v95 = 1;\n  }\n  if ( v96 >= 0 )\n  {\n    v4 = sub_80A3AFE(v96);\n    v85 = (char *)sub_80A3ABA();\n  }\n  if ( v97 >= 0 )\n  {\n    sub_80A3AFE(v97);\n    v85 = (char *)sub_80A3ABA();\n  }\n  v13 = strlen(&s);\n  if ( !v13 )\n  {\n    if ( v96 >= 0 )\n    {\n      *(_DWORD *)(v3 + 8) = sub_80A3AFE(v96);\n      sub_80A3191();\n    }\n    goto LABEL_234;\n  }\n  LOBYTE(v91) = s;\n  if ( s == 33 )\n  {\n    sub_80A3EF9(v12);\n    sub_80A3E8D();\n    v14 = system(src + 1);\n    if ( v14 )\n      printf(\"\\nshell returned %i\\n\\n\", v14);\n    sub_80A32BC();\nLABEL_108:\n    sub_80A459B();\n    goto LABEL_234;\n  }\n  if ( s == 61 && !v100 )\n  {\n    if ( v96 < 0 )\n      v96 = sub_80A3B30(*(_DWORD *)v3, *(_DWORD *)(v3 + 8));\n    sub_80A3847(\"%d\", v96);\n    goto LABEL_234;\n  }\n  v15 = v13;\n  if ( v13 > 7 )\n    v15 = 7;\n  if ( !strncmp(&s, \"delete\", v15) )\n  {\n    if ( v96 < 0 )\n    {\n      v4 = (unsigned __int8 *)sub_80A3BB5(*(_DWORD *)(v3 + 8));\n      v85 = (char *)sub_80A3ABA();\n    }\n    *(_DWORD *)(v3 + 8) = sub_80A364E(v4, v85, 1, 1, 1, (int)v85, (int)src, v96, v91);\n    sub_80A3191();\n    goto LABEL_234;\n  }\n  v16 = v13;\n  if ( v13 > 5 )\n    v16 = 5;\n  if ( !strncmp(&s, \"edit\", v16) )\n  {\n    if ( !*(_DWORD *)(v3 + 20) || v95 )\n    {\n      if ( dest[0] )\n      {\n        v93 = dest;\n      }\n      else\n      {\n        v17 = *(_BYTE **)(v3 + 68);\n        if ( !v17 || !*v17 )\n        {\n          sub_80A372C(\"No current filename\");\n          goto LABEL_234;\n        }\n      }\n      v18 = sub_80A4A19(v93);\n      v19 = *(_DWORD *)(v3 + 132);\n      if ( v19 <= 0x1B )\n      {\n        free(*(void **)(v3 + 4 * v19 + 136));\n        *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 132) + 136) = 0;\n      }\n      v20 = *(_DWORD *)(v3 + 128);\n      if ( v20 <= 0x1B )\n      {\n        free(*(void **)(v3 + 4 * v20 + 136));\n        *(_DWORD *)(v3 + 4 * *(_DWORD *)(v3 + 128) + 136) = 0;\n      }\n      v21 = *(_DWORD *)(v3 + 4);\n      v22 = *(_DWORD *)v3;\n      v23 = sub_80A3B30(*(_DWORD *)v3, v21 - 1);\n      v24 = v21 - v22;\n      v25 = &data;\n      if ( *(_BYTE *)(v3 + 17) )\n        v25 = \" [Readonly]\";\n      v26 = &data;\n      if ( v18 < 0 )\n        v26 = \" [New file]\";\n      sub_80A3847(\"'%s'%s%s %dL, %dC\", *(const char **)(v3 + 68), v26, v25, v23, v24);\n      goto LABEL_234;\n    }\n    goto LABEL_60;\n  }\n  v27 = v13;\n  if ( v13 > 5 )\n    v27 = 5;\n  if ( !strncmp(&s, \"file\", v27) )\n  {\n    if ( v97 == -1 && v96 == -1 )\n    {\n      if ( dest[0] )\n      {\n        free(*(void **)(v3 + 68));\n        *(_DWORD *)(v3 + 68) = sub_804DB46(dest);\n      }\n      else\n      {\n        *(_DWORD *)(v3 + 64) = 0;\n      }\n    }\n    else\n    {\n      sub_80A372C(\"No address allowed on this command\");\n    }\n    goto LABEL_234;\n  }\n  v28 = v13;\n  if ( v13 > 9 )\n    v28 = 9;\n  if ( !strncmp(&s, \"features\", v28) )\n  {\n    sub_80A3EF9(v29);\n    sub_80A3E8D();\n    puts(\n      \"These features are available:\\n\"\n      \"\\tPattern searches with / and ?\\n\"\n      \"\\tLast command repeat with .\\n\"\n      \"\\tLine marking with 'x\\n\"\n      \"\\tNamed buffers with \\\"x\\n\"\n      \"\\tSome colon mode commands with :\\n\"\n      \"\\tSettable options with \\\":set\\\"\\n\"\n      \"\\tSignal catching- ^C\\n\"\n      \"\\tJob suspend and resume with ^Z\\n\"\n      \"\\tAdapt to window re-sizes\");\n    sub_80A32BC();\n    sub_80A459B();\n    goto LABEL_234;\n  }\n  v30 = v13;\n  if ( v13 > 5 )\n    v30 = 5;\n  if ( !strncmp(&s, \"list\", v30) )\n  {\n    if ( v96 < 0 )\n    {\n      v4 = (unsigned __int8 *)sub_80A3BB5(*(_DWORD *)(v3 + 8));\n      v85 = (char *)sub_80A3ABA();\n    }\n    sub_80A3EF9(v31);\n    puts(\"\\r\");\n    while ( 1 )\n    {\n      if ( v4 > (unsigned __int8 *)v85 )\n        goto LABEL_108;\n      v32 = *v4;\n      if ( (*v4 & 0x80u) != 0 )\n        break;\n      if ( v32 == 10 )\n      {\n        sub_80A3EA1();\n        v33 = 0;\n        v32 = 10;\n        goto LABEL_105;\n      }\n      if ( v32 > 0x1Fu )\n        goto LABEL_101;\nLABEL_102:\n      srca = *v4;\n      sub_804DD98(94);\n      if ( srca == 127 )\n      {\n        v33 = 0;\n        v32 = 63;\n      }\n      else\n      {\n        v32 = srca + 64;\n        v33 = 0;\n      }\nLABEL_105:\n      sub_804DD98(v32);\n      if ( v33 )\n        sub_80A3EA1();\n      ++v4;\n    }\n    if ( v32 == 0x9B )\n    {\n      sub_80A3EA1();\n      v33 = 1;\n      v32 = 46;\n      goto LABEL_105;\n    }\nLABEL_101:\n    v33 = 0;\n    if ( v32 != 127 )\n      goto LABEL_105;\n    goto LABEL_102;\n  }\n  v34 = v13;\n  if ( v13 > 5 )\n    v34 = 5;\n  if ( !strncmp(&s, \"quit\", v34) )\n    goto LABEL_118;\n  v35 = v13;\n  if ( v13 > 5 )\n    v35 = 5;\n  if ( !strncmp(&s, \"next\", v35) )\n    goto LABEL_118;\n  v36 = v13;\n  if ( v13 > 5 )\n    v36 = 5;\n  if ( !strncmp(&s, \"prev\", v36) )\n  {\nLABEL_118:\n    if ( v95 )\n    {\n      if ( (_BYTE)v91 == 113 )\n      {\n        v37 = *(_DWORD *)(v3 + 28);\nLABEL_132:\n        optind = v37;\n        goto LABEL_154;\n      }\n      goto LABEL_154;\n    }\n    if ( !*(_DWORD *)(v3 + 20) )\n    {\n      v38 = *(_DWORD *)(v3 + 28) + ~optind;\n      switch ( (_BYTE)v91 )\n      {\n        case 'q':\n          if ( v38 > 0 )\n          {\n            sub_80A372C(\"%d more file(s) to edit\", *(_DWORD *)(v3 + 28) + ~optind);\n            goto LABEL_234;\n          }\n          break;\n        case 'n':\n          if ( v38 <= 0 )\n          {\n            sub_80A372C(\"No more files to edit\");\n            goto LABEL_234;\n          }\n          break;\n        case 'p':\n          if ( optind <= 0 )\n          {\n            sub_80A372C(\"No previous files to edit\");\n            goto LABEL_234;\n          }\n          v37 = optind - 2;\n          goto LABEL_132;\n      }\nLABEL_154:\n      *(_BYTE *)(v3 + 18) = 0;\n      goto LABEL_234;\n    }\nLABEL_60:\n    sub_80A372C(\"No write since last change (:%s! overrides)\", &s);\n    goto LABEL_234;\n  }\n  v39 = v13;\n  if ( v13 > 5 )\n    v39 = 5;\n  if ( !strncmp(&s, \"read\", v39) )\n  {\n    if ( dest[0] )\n    {\n      if ( v96 < 0 )\n        sub_80A3BB5(*(_DWORD *)(v3 + 8));\n      v40 = sub_80A3AE4();\n      if ( v40 == (_BYTE *)(*(_DWORD *)(v3 + 4) - 1) )\n        v40 = *(_BYTE **)(v3 + 4);\n      v41 = &v40[-*(_DWORD *)v3];\n      v42 = sub_80A4009(0, v40);\n      v43 = v42;\n      v44 = (unsigned int)&v41[*(_DWORD *)v3];\n      if ( v42 >= 0 )\n      {\n        v45 = sub_80A3B30(v44, v44 + v42 - 1);\n        v46 = &data;\n        if ( *(_BYTE *)(v3 + 17) )\n          v46 = \" [Readonly]\";\n        sub_80A3847(\"'%s'%s %dL, %dC\", dest, v46, v45, v43);\n        if ( v43 )\n        {\n          v47 = *(_DWORD *)(v3 + 8);\n          if ( v47 >= v44 )\n            *(_DWORD *)(v3 + 8) = v47 + v43;\n        }\n      }\n    }\n    else\n    {\n      sub_80A372C(\"No filename given\");\n    }\n    goto LABEL_234;\n  }\n  v48 = v13;\n  if ( v13 > 7 )\n    v48 = 7;\n  if ( !strncmp(&s, \"rewind\", v48) )\n  {\n    if ( !*(_DWORD *)(v3 + 20) || v95 )\n    {\n      optind = -1;\n      goto LABEL_154;\n    }\n    goto LABEL_60;\n  }\n  v49 = v13;\n  if ( v13 > 4 )\n    v49 = 4;\n  v50 = strncmp(&s, \"set\", v49);\n  if ( !v50 )\n  {\n    if ( dest[0] && (v51 = dest, strcasecmp(dest, \"all\")) )\n    {\n      while ( *v51 )\n      {\n        if ( !strncmp(v51, \"no\", 2u) )\n          v50 = 2;\n        sub_80A39D8(v50, \"autoindent \", \"ai\", 1);\n        sub_80A39D8(v50, \"flash \", 135069763, 8);\n        sub_80A39D8(v50, &unk_80D83A3, 135042926, 4);\n        sub_80A39D8(v50, \"showmatch \", \"sm\", 2);\n        if ( !strncmp(&v51[v50], \"tabstop=\", 8u) )\n        {\n          v98 = 0;\n          sscanf(&v51[v50 + 8], \"%u\", &v98);\n          if ( (unsigned int)(v98 - 1) <= 0x1F )\n            *(_DWORD *)(v3 + 84) = v98;\n        }\n        sub_80B2E9F();\n        v51 = (char *)sub_80B2E8C(v59, v58);\n      }\n    }\n    else\n    {\n      v52 = *(_DWORD *)(v3 + 84);\n      v53 = *(_BYTE *)(v3 + 16);\n      v54 = \"no\";\n      if ( (v53 & 2) != 0 )\n        v54 = &data;\n      v55 = \"no\";\n      if ( (v53 & 4) != 0 )\n        v55 = &data;\n      v56 = \"no\";\n      if ( (v53 & 8) != 0 )\n        v56 = &data;\n      v57 = \"no\";\n      if ( (v53 & 1) != 0 )\n        v57 = &data;\n      sub_80A372C(\"%sautoindent %sflash %signorecase %sshowmatch tabstop=%u\", v57, v56, v55, v54, v52);\n    }\n    goto LABEL_234;\n  }\n  if ( (_BYTE)v91 != 115 )\n  {\n    v70 = v13;\n    if ( v13 > 8 )\n      v70 = 8;\n    if ( !strncmp(&s, \"version\", v70) )\n    {\n      sub_80A3847((char *)\"1.29.2\");\n    }\n    else\n    {\n      v71 = v13;\n      if ( v13 > 6 )\n        v71 = 6;\n      if ( strncmp(&s, \"write\", v71) )\n      {\n        v72 = v13;\n        if ( v13 > 3 )\n          v72 = 3;\n        if ( strncmp(&s, \"wq\", v72) )\n        {\n          v73 = v13;\n          if ( v13 > 3 )\n            v73 = 3;\n          if ( strncmp(&s, \"wn\", v73) && ((_BYTE)v91 != 120 || v100) )\n          {\n            if ( v13 > 5 )\n              v13 = 5;\n            if ( !strncmp(&s, \"yank\", v13) )\n            {\n              if ( v96 < 0 )\n              {\n                v4 = (unsigned __int8 *)sub_80A3BB5(*(_DWORD *)(v3 + 8));\n                v85 = (char *)sub_80A3ABA();\n              }\n              sub_80A31FE(*(_DWORD *)(v3 + 128), v85);\n              v79 = sub_80A3B30((unsigned int)v4, (unsigned int)v85);\n              v80 = sub_80A31D5();\n              v81 = strlen(*(const char **)(v3 + 4 * *(_DWORD *)(v3 + 128) + 136));\n              sub_80A3847(\"Yank %d lines (%d chars) into [%c]\", v79, v81, v80);\n            }\n            else\n            {\n              sub_80A3774();\n            }\n            goto LABEL_234;\n          }\n        }\n      }\n      if ( dest[0] )\n        v93 = dest;\n      if ( !*(_BYTE *)(v3 + 17) || v95 )\n      {\n        if ( !*(_DWORD *)(v3 + 20) && (_BYTE)v91 == 120 )\n        {\n          v74 = 0;\n          v76 = 0;\n        }\n        else\n        {\n          v74 = v85 - (char *)v4 + 1;\n          v75 = sub_80A3A53(v85, v4);\n          v76 = v75;\n          if ( v75 < 0 )\n          {\n            if ( v75 == -1 )\n              sub_80A372C(\"'%s' %m\", v93);\n            goto LABEL_234;\n          }\n        }\n        v77 = sub_80A3B30((unsigned int)v4, (unsigned int)&v4[v76 - 1]);\n        sub_80A3847(\"'%s' %dL, %dC\", v93, v77, v76);\n        v78 = dword_80DBB80;\n        if ( v76 == v74 )\n        {\n          if ( *(unsigned __int8 **)dword_80DBB80 == v4 && *(unsigned __int8 **)(dword_80DBB80 + 4) == &v4[v76] )\n          {\n            *(_DWORD *)(dword_80DBB80 + 20) = 0;\n            *(_DWORD *)(v78 + 24) = -1;\n          }\n          if ( s == 120 || (v100 & 0xDF) == 81 || (v100 & 0xDF) == 78 )\n            *(_BYTE *)(v78 + 18) = 0;\n        }\n        goto LABEL_234;\n      }\n      sub_80A372C(\"'%s' is read only\", v93);\n    }\nLABEL_234:\n    v82 = dword_80DBB80;\n    result = sub_80A481D(*(_DWORD *)(dword_80DBB80 + 8));\n    *(_DWORD *)(v82 + 8) = result;\n    return result;\n  }\n  v86 = src + 2;\n  v60 = (unsigned __int8)src[1];\n  v61 = strchr(src + 2, v60);\n  if ( v61 )\n  {\n    v92 = v61 - v86;\n    srcb = v61 + 1;\n    *v61 = 0;\n    v62 = strchr(v61 + 1, v60);\n    if ( v62 )\n    {\n      v94 = v62 - srcb;\n      *v62 = 0;\n      v90 = v62[1];\n      v63 = (_BYTE *)sub_80A3BB5((unsigned int)v4);\n      if ( v96 < 0 )\n      {\n        v63 = (_BYTE *)sub_80A3BB5(*(_DWORD *)(v3 + 8));\n        v96 = sub_80A3B30(*(_DWORD *)v3, (unsigned int)v63);\n      }\n      v64 = v96;\n      if ( v97 < 0 )\n        v97 = v96;\n      v65 = 1;\n      while ( v97 >= v64 )\n      {\n        v66 = v63;\n        do\n        {\n          v67 = sub_80A3BFA(1, v86, 0);\n          v68 = v67;\n          if ( !v67 )\n            break;\n          sub_80A359D(v65, v67 + v92 - 1);\n          v69 = sub_80A386F(2, srcb);\n          v66 += v69;\n          if ( v90 != 103 )\n          {\n            v65 = 2;\n            break;\n          }\n          v65 = 2;\n        }\n        while ( v94 + v69 + v68 < (unsigned int)sub_80A3ABA() );\n        v63 = sub_80A3AE4();\n        ++v64;\n      }\n      goto LABEL_234;\n    }\n  }\n  sub_80A3847(\":s expression missing delimiters\");\n  return v84;\n}\n"
        ],
        "134895297": [
            "sub_80A56C1",
            "0x80a56c1",
            "decompilation failure at 80A56C1!\n"
        ],
        "134899855": [
            "sub_80A688F",
            "0x80a688f",
            "decompilation failure at 80A688F!\n"
        ],
        "134900341": [
            "sub_80A6A75",
            "0x80a6a75",
            "decompilation failure at 80A6A75!\n"
        ],
        "134901029": [
            "sub_80A6D25",
            "0x80a6d25",
            "decompilation failure at 80A6D25!\n"
        ],
        "134901321": [
            "sub_80A6E49",
            "0x80a6e49",
            "int __usercall sub_80A6E49@<eax>(_DWORD *a1@<eax>, int a2@<ecx>)\n{\n  int v4; // ebx\n  _DWORD *v5; // esi\n  int v6; // ebp\n\n  v4 = 0;\nLABEL_2:\n  v5 = (_DWORD *)*a1;\n  if ( *a1 )\n  {\n    v4 &= ~1u;\n    while ( 1 )\n    {\n      v6 = *v5;\n      if ( !*v5 )\n        break;\n      v4 |= (*(int (__fastcall **)(_DWORD, int))v6)(*v5, a2) ^ 1;\n      if ( *(_BYTE *)(v6 + 4) )\n        v4 ^= 1u;\n      ++v5;\n      if ( (v4 & 1) != 0 )\n      {\n        ++a1;\n        goto LABEL_2;\n      }\n    }\n  }\n  return v4 ^ 1;\n}\n"
        ],
        "134901406": [
            "sub_80A6E9E",
            "0x80a6e9e",
            "_BOOL4 __fastcall sub_80A6E9E(int a1, int a2)\n{\n  return (*(_DWORD *)(a2 + 16) & 0xF000) == *(_DWORD *)(a1 + 8);\n}\n"
        ],
        "134901424": [
            "sub_80A6EB0",
            "0x80a6eb0",
            "int __fastcall sub_80A6EB0(int a1, int a2)\n{\n  int result; // eax\n  int v3; // edx\n\n  result = *(_DWORD *)(a2 + 16);\n  v3 = *(_DWORD *)(a1 + 12);\n  if ( (*(_BYTE *)(a1 + 8) & 0xFB) == 43 )\n  {\n    LOBYTE(result) = (result & v3) != 0;\n  }\n  else\n  {\n    if ( *(_BYTE *)(a1 + 8) == 45 )\n      result &= v3;\n    else\n      result &= 0xFFFu;\n    LOBYTE(result) = result == v3;\n  }\n  return (unsigned __int8)result;\n}\n"
        ],
        "134901475": [
            "sub_80A6EE3",
            "0x80a6ee3",
            "_BOOL4 __fastcall sub_80A6EE3(int a1, int a2)\n{\n  return *(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 72);\n}\n"
        ],
        "134901488": [
            "sub_80A6EF0",
            "0x80a6ef0",
            "_BOOL4 __fastcall sub_80A6EF0(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 24) == *(_DWORD *)(a1 + 8);\n}\n"
        ],
        "134901501": [
            "sub_80A6EFD",
            "0x80a6efd",
            "_BOOL4 __fastcall sub_80A6EFD(int a1, int a2)\n{\n  return *(_DWORD *)(a2 + 28) == *(_DWORD *)(a1 + 8);\n}\n"
        ],
        "134901514": [
            "sub_80A6F0A",
            "0x80a6f0a",
            "int __fastcall sub_80A6F0A(int a1, int a2)\n{\n  return sub_80A6E49(*(_DWORD **)(a1 + 8), a2);\n}\n"
        ],
        "134901530": [
            "sub_80A6F1A",
            "0x80a6f1a",
            "_BOOL4 __fastcall sub_80A6F1A(int a1, int a2)\n{\n  char v2; // al\n  unsigned int v3; // edx\n  unsigned int v4; // esi\n  __int64 v5; // rcx\n  _BOOL4 result; // eax\n\n  v2 = *(_BYTE *)(a1 + 8);\n  HIDWORD(v5) = *(_DWORD *)(a2 + 44);\n  v3 = *(_DWORD *)(a2 + 48);\n  v4 = *(_DWORD *)(a1 + 12);\n  LODWORD(v5) = *(_DWORD *)(a1 + 16);\n  if ( v2 == 43 )\n  {\n    result = 1;\n    if ( __SPAIR64__(v3, HIDWORD(v5)) > __SPAIR64__(v5, v4) )\n      return result;\n    return 0;\n  }\n  if ( v2 == 45 )\n  {\n    result = 1;\n    if ( __SPAIR64__(v3, HIDWORD(v5)) < __SPAIR64__(v5, v4) )\n      return result;\n    return 0;\n  }\n  return v5 == __PAIR64__(v4, v3);\n}\n"
        ],
        "134901605": [
            "sub_80A6F65",
            "0x80a6f65",
            "int sub_80A6F65()\n{\n  return 3;\n}\n"
        ],
        "134901611": [
            "sub_80A6F6B",
            "0x80a6f6b",
            "_BYTE *__usercall sub_80A6F6B@<eax>(_BYTE *a1@<eax>)\n{\n  return &a1[((*a1 - 43) & 0xFD) == 0];\n}\n"
        ],
        "134901628": [
            "sub_80A6F7C",
            "0x80a6f7c",
            "decompilation failure at 80A6F7C!\n"
        ],
        "134901831": [
            "sub_80A7047",
            "0x80a7047",
            "decompilation failure at 80A7047!\n"
        ],
        "134901844": [
            "sub_80A7054",
            "0x80a7054",
            "_BYTE *__usercall sub_80A7054@<eax>(int a1@<eax>, size_t a2@<edx>, int a3@<ecx>)\n{\n  _BYTE *v5; // esi\n  void **v6; // ebp\n  void *v7; // eax\n  int v8; // edx\n\n  v5 = sub_804DB2E(a2);\n  v6 = (void **)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4));\n  v7 = sub_804DB13(*v6, 4 * *(_DWORD *)(a1 + 8) + 8);\n  *v6 = v7;\n  v8 = *(_DWORD *)(a1 + 8);\n  *(_DWORD *)(a1 + 8) = v8 + 1;\n  *((_DWORD *)v7 + v8) = v5;\n  *((_DWORD *)v7 + v8 + 1) = 0;\n  *(_DWORD *)v5 = a3;\n  v5[4] = *(_BYTE *)(a1 + 12);\n  *(_BYTE *)(a1 + 12) = 0;\n  return v5;\n}\n"
        ],
        "134901929": [
            "sub_80A70A9",
            "0x80a70a9",
            "decompilation failure at 80A70A9!\n"
        ],
        "134901997": [
            "sub_80A70ED",
            "0x80a70ed",
            "decompilation failure at 80A70ED!\n"
        ],
        "134902074": [
            "sub_80A713A",
            "0x80a713a",
            "decompilation failure at 80A713A!\n"
        ],
        "134902135": [
            "sub_80A7177",
            "0x80a7177",
            "decompilation failure at 80A7177!\n"
        ],
        "134902280": [
            "sub_80A7208",
            "0x80a7208",
            "decompilation failure at 80A7208!\n"
        ],
        "134902582": [
            "sub_80A7336",
            "0x80a7336",
            "decompilation failure at 80A7336!\n"
        ],
        "134902685": [
            "sub_80A739D",
            "0x80a739d",
            "decompilation failure at 80A739D!\n"
        ],
        "134902707": [
            "sub_80A73B3",
            "0x80a73b3",
            "decompilation failure at 80A73B3!\n"
        ],
        "134904016": [
            "sub_80A78D0",
            "0x80a78d0",
            "decompilation failure at 80A78D0!\n"
        ],
        "134904456": [
            "sub_80A7A88",
            "0x80a7a88",
            "decompilation failure at 80A7A88!\n"
        ],
        "134904630": [
            "sub_80A7B36",
            "0x80a7b36",
            "decompilation failure at 80A7B36!\n"
        ],
        "134905860": [
            "sub_80A8004",
            "0x80a8004",
            "decompilation failure at 80A8004!\n"
        ],
        "134906015": [
            "sub_80A809F",
            "0x80a809f",
            "decompilation failure at 80A809F!\n"
        ],
        "134906815": [
            "sub_80A83BF",
            "0x80a83bf",
            "size_t __usercall sub_80A83BF@<eax>(int a1@<eax>)\n{\n  size_t result; // eax\n\n  if ( !*((_BYTE *)&buf + 20) )\n    buf = (size_t)sub_804DB13((void *)buf, 4 * *(&buf + 5) + 1024);\n  result = (*(&buf + 5))++;\n  *(_DWORD *)(buf + 4 * result) = a1;\n  return result;\n}\n"
        ],
        "134906875": [
            "sub_80A83FB",
            "0x80a83fb",
            "decompilation failure at 80A83FB!\n"
        ],
        "134907071": [
            "sub_80A84BF",
            "0x80a84bf",
            "decompilation failure at 80A84BF!\n"
        ],
        "134907173": [
            "sub_80A8525",
            "0x80a8525",
            "decompilation failure at 80A8525!\n"
        ],
        "134907517": [
            "sub_80A867D",
            "0x80a867d",
            "decompilation failure at 80A867D!\n"
        ],
        "134907811": [
            "sub_80A87A3",
            "0x80a87a3",
            "decompilation failure at 80A87A3!\n"
        ],
        "134908480": [
            "sub_80A8A40",
            "0x80a8a40",
            "decompilation failure at 80A8A40!\n"
        ],
        "134908605": [
            "sub_80A8ABD",
            "0x80a8abd",
            "decompilation failure at 80A8ABD!\n"
        ],
        "134908839": [
            "sub_80A8BA7",
            "0x80a8ba7",
            "decompilation failure at 80A8BA7!\n"
        ],
        "134908851": [
            "sub_80A8BB3",
            "0x80a8bb3",
            "decompilation failure at 80A8BB3!\n"
        ],
        "134908944": [
            "sub_80A8C10",
            "0x80a8c10",
            "decompilation failure at 80A8C10!\n"
        ],
        "134909091": [
            "sub_80A8CA3",
            "0x80a8ca3",
            "decompilation failure at 80A8CA3!\n"
        ],
        "134909137": [
            "sub_80A8CD1",
            "0x80a8cd1",
            "int sub_80A8CD1()\n{\n  sub_804E6C8(1610766, 0);\n  return sub_804E6A5(1);\n}\n"
        ],
        "134909159": [
            "sub_80A8CE7",
            "0x80a8ce7",
            "decompilation failure at 80A8CE7!\n"
        ],
        "134909207": [
            "sub_80A8D17",
            "0x80a8d17",
            "decompilation failure at 80A8D17!\n"
        ],
        "134909292": [
            "sub_80A8D6C",
            "0x80a8d6c",
            "decompilation failure at 80A8D6C!\n"
        ],
        "134909433": [
            "sub_80A8DF9",
            "0x80a8df9",
            "decompilation failure at 80A8DF9!\n"
        ],
        "134909810": [
            "sub_80A8F72",
            "0x80a8f72",
            "decompilation failure at 80A8F72!\n"
        ],
        "134909895": [
            "sub_80A8FC7",
            "0x80a8fc7",
            "decompilation failure at 80A8FC7!\n"
        ],
        "134910188": [
            "sub_80A90EC",
            "0x80a90ec",
            "decompilation failure at 80A90EC!\n"
        ],
        "134910403": [
            "sub_80A91C3",
            "0x80a91c3",
            "decompilation failure at 80A91C3!\n"
        ],
        "134910508": [
            "sub_80A922C",
            "0x80a922c",
            "decompilation failure at 80A922C!\n"
        ],
        "134910605": [
            "sub_80A928D",
            "0x80a928d",
            "decompilation failure at 80A928D!\n"
        ],
        "134910945": [
            "sub_80A93E1",
            "0x80a93e1",
            "decompilation failure at 80A93E1!\n"
        ],
        "134911741": [
            "sub_80A96FD",
            "0x80a96fd",
            "decompilation failure at 80A96FD!\n"
        ],
        "134911751": [
            "sub_80A9707",
            "0x80a9707",
            "decompilation failure at 80A9707!\n"
        ],
        "134911805": [
            "nullsub_3",
            "0x80a973d",
            "void nullsub_3()\n{\n  ;\n}\n"
        ],
        "134911806": [
            "sub_80A973E",
            "0x80a973e",
            "decompilation failure at 80A973E!\n"
        ],
        "134912136": [
            "sub_80A9888",
            "0x80a9888",
            "int __usercall sub_80A9888@<eax>(int a1@<eax>)\n{\n  return sub_80A973E(a1, 0);\n}\n"
        ],
        "134912147": [
            "sub_80A9893",
            "0x80a9893",
            "unsigned __int32 __fastcall sub_80A9893(int a1, unsigned int a2)\n{\n  return _byteswap_ulong(a2);\n}\n"
        ],
        "134912164": [
            "sub_80A98A4",
            "0x80a98a4",
            "decompilation failure at 80A98A4!\n"
        ],
        "134912244": [
            "sub_80A98F4",
            "0x80a98f4",
            "decompilation failure at 80A98F4!\n"
        ],
        "134912282": [
            "sub_80A991A",
            "0x80a991a",
            "decompilation failure at 80A991A!\n"
        ],
        "134912394": [
            "sub_80A998A",
            "0x80a998a",
            "decompilation failure at 80A998A!\n"
        ],
        "134912412": [
            "sub_80A999C",
            "0x80a999c",
            "decompilation failure at 80A999C!\n"
        ],
        "134912439": [
            "sub_80A99B7",
            "0x80a99b7",
            "decompilation failure at 80A99B7!\n"
        ],
        "134912466": [
            "sub_80A99D2",
            "0x80a99d2",
            "decompilation failure at 80A99D2!\n"
        ],
        "134912493": [
            "sub_80A99ED",
            "0x80a99ed",
            "int sub_80A99ED()\n{\n  return *(_DWORD *)sub_80A99D2();\n}\n"
        ],
        "134912501": [
            "sub_80A99F5",
            "0x80a99f5",
            "decompilation failure at 80A99F5!\n"
        ],
        "134912518": [
            "sub_80A9A06",
            "0x80a9a06",
            "decompilation failure at 80A9A06!\n"
        ],
        "134912535": [
            "sub_80A9A17",
            "0x80a9a17",
            "_BYTE *__usercall sub_80A9A17@<eax>(unsigned int a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = (_BYTE *)sub_80A99F5();\n  if ( !result )\n    return sub_804D6F7(a1);\n  return result;\n}\n"
        ],
        "134912557": [
            "sub_80A9A2D",
            "0x80a9a2d",
            "_BYTE *__usercall sub_80A9A2D@<eax>(unsigned int a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = (_BYTE *)sub_80A9A06();\n  if ( !result )\n    return sub_804D6F7(a1);\n  return result;\n}\n"
        ],
        "134912579": [
            "sub_80A9A43",
            "0x80a9a43",
            "int sub_80A9A43()\n{\n  return *(_DWORD *)(sub_80A999C() + 8);\n}\n"
        ],
        "134912588": [
            "sub_80A9A4C",
            "0x80a9a4c",
            "int sub_80A9A4C()\n{\n  return *(_DWORD *)(sub_80A99B7() + 8);\n}\n"
        ],
        "134912597": [
            "sub_80A9A55",
            "0x80a9a55",
            "int __usercall sub_80A9A55@<eax>(const char *a1@<eax>, int (*a2)(void)@<edx>)\n{\n  int result; // eax\n\n  result = sub_804ED6C(10, a1, 0, (int)a1);\n  if ( *(_DWORD *)dword_80DBB7C )\n    return a2();\n  return result;\n}\n"
        ],
        "134912637": [
            "sub_80A9A7D",
            "0x80a9a7d",
            "int __cdecl sub_80A9A7D(char *s1, char *s2)\n{\n  return strcmp(*(const char **)s1, *(const char **)s2);\n}\n"
        ],
        "134912662": [
            "sub_80A9A96",
            "0x80a9a96",
            "decompilation failure at 80A9A96!\n"
        ],
        "134912680": [
            "sub_80A9AA8",
            "0x80a9aa8",
            "decompilation failure at 80A9AA8!\n"
        ],
        "134912757": [
            "sub_80A9AF5",
            "0x80a9af5",
            "decompilation failure at 80A9AF5!\n"
        ],
        "134912793": [
            "sub_80A9B19",
            "0x80a9b19",
            "decompilation failure at 80A9B19!\n"
        ],
        "134912915": [
            "sub_80A9B93",
            "0x80a9b93",
            "decompilation failure at 80A9B93!\n"
        ],
        "134912995": [
            "sub_80A9BE3",
            "0x80a9be3",
            "const char *__usercall sub_80A9BE3@<eax>(const char *a1@<eax>)\n{\n  const char *result; // eax\n\n  result = sub_804D378(a1, 10);\n  if ( result )\n    *result = 0;\n  return result;\n}\n"
        ],
        "134913013": [
            "sub_80A9BF5",
            "0x80a9bf5",
            "int __usercall sub_80A9BF5@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)\n{\n  if ( a2 && *a2 == 46 && ((LOBYTE(a3) = a2[1], !(_BYTE)a3) || (_BYTE)a3 == 46 && !a2[2]) )\n    return 0;\n  else\n    return sub_804D2D1(a1, a2, a3);\n}\n"
        ],
        "134913048": [
            "sub_80A9C18",
            "0x80a9c18",
            "decompilation failure at 80A9C18!\n"
        ],
        "134913143": [
            "sub_80A9C77",
            "0x80a9c77",
            "decompilation failure at 80A9C77!\n"
        ],
        "134914668": [
            "sub_80AA26C",
            "0x80aa26c",
            "decompilation failure at 80AA26C!\n"
        ],
        "134914762": [
            "sub_80AA2CA",
            "0x80aa2ca",
            "decompilation failure at 80AA2CA!\n"
        ],
        "134914841": [
            "sub_80AA319",
            "0x80aa319",
            "int __usercall sub_80AA319@<eax>(int a1@<edx>, int a2@<ecx>, int a3)\n{\n  int v4; // esi\n  int v5; // ebx\n\n  if ( !*(_BYTE *)sub_80AA26C(a2, &a3) )\n    return 2;\n  v4 = sub_80A973E(a2, a1);\n  v5 = -1;\n  if ( v4 )\n  {\n    v5 = sub_80AA2CA();\n    sub_80B030A();\n  }\n  return v5;\n}\n"
        ],
        "134914929": [
            "sub_80AA371",
            "0x80aa371",
            "int __cdecl sub_80AA371(int a1)\n{\n  return sub_80AA319(0, (int)\"Password: \", a1);\n}\n"
        ],
        "134914941": [
            "sub_80AA37D",
            "0x80aa37d",
            "_DWORD *__usercall sub_80AA37D@<eax>(_DWORD *result@<eax>, int a2@<edx>)\n{\n  int v3; // esi\n  unsigned int i; // ebx\n  unsigned int v5; // ecx\n  int v6; // edx\n  int v7; // ebp\n  int v8; // ebp\n\n  v3 = a2 == 0 ? -306674912 : 79764919;\n  if ( !result )\n    result = sub_804DAFA(0x400u);\n  for ( i = 0; i != 256; ++i )\n  {\n    v5 = i;\n    if ( a2 )\n      v5 = i << 24;\n    v6 = 8;\n    do\n    {\n      v7 = v5;\n      if ( a2 )\n      {\n        v5 *= 2;\n        if ( v7 >= 0 )\n          goto LABEL_12;\n      }\n      else\n      {\n        v8 = v5 & 1;\n        v5 >>= 1;\n        if ( !v8 )\n          goto LABEL_12;\n      }\n      v5 ^= v3;\nLABEL_12:\n      --v6;\n    }\n    while ( v6 );\n    result[i] = v5;\n  }\n  return result;\n}\n"
        ],
        "134915039": [
            "sub_80AA3DF",
            "0x80aa3df",
            "_DWORD *sub_80AA3DF()\n{\n  return sub_80AA37D(0, 0);\n}\n"
        ],
        "134915048": [
            "sub_80AA3E8",
            "0x80aa3e8",
            "_DWORD *sub_80AA3E8()\n{\n  _DWORD *result; // eax\n\n  result = sub_80AA3DF();\n  dword_80DBB98 = (int)result;\n  return result;\n}\n"
        ],
        "134915059": [
            "sub_80AA3F3",
            "0x80aa3f3",
            "decompilation failure at 80AA3F3!\n"
        ],
        "134915102": [
            "sub_80AA41E",
            "0x80aa41e",
            "decompilation failure at 80AA41E!\n"
        ],
        "134915140": [
            "sub_80AA444",
            "0x80aa444",
            "decompilation failure at 80AA444!\n"
        ],
        "134915219": [
            "sub_80AA493",
            "0x80aa493",
            "decompilation failure at 80AA493!\n"
        ],
        "134916172": [
            "sub_80AA84C",
            "0x80aa84c",
            "int __usercall sub_80AA84C@<eax>(\n        int a1@<eax>,\n        int a2,\n        int a3,\n        int a4,\n        __int16 a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10,\n        int a11,\n        __int64 a12)\n{\n  const char **v13; // eax\n  const char *v14; // esi\n  __int64 v16; // rax\n  void *retaddr; // [esp+70h] [ebp+0h] BYREF\n\n  do\n  {\n    while ( 1 )\n    {\n      v13 = *(const char ***)(a1 + 20);\n      v14 = *v13;\n      if ( !*v13 )\n        break;\n      *(_DWORD *)(a1 + 20) = v13 + 1;\n      if ( *v14 == 45 && !v14[1] || freopen64() )\n        goto LABEL_4;\n      sub_804D3F1(v14);\n      *(_BYTE *)(a1 + 56) = 1;\n    }\n    if ( *(_BYTE *)(a1 + 57) )\n      return 0;\nLABEL_4:\n    *(_BYTE *)(a1 + 57) = 1;\n    if ( *(_QWORD *)a1 )\n    {\n      if ( !v14 )\n        v14 = \"stdin\";\n      sub_804E010(0, (int)&retaddr, v14);\n      if ( (a5 & 0xF000) == 0x8000 && *(_QWORD *)a1 >= a12 )\n      {\n        *(_QWORD *)a1 -= a12;\n        *(_QWORD *)(a1 + 44) += a12;\n      }\n      else\n      {\n        if ( fseeko64() )\n          sub_804D3FF(v14);\n        v16 = *(_QWORD *)(a1 + 44) + *(_QWORD *)a1;\n        *(_QWORD *)(a1 + 44) = v16;\n        *(_QWORD *)(a1 + 28) = v16;\n        *(_DWORD *)a1 = 0;\n        *(_DWORD *)(a1 + 4) = 0;\n      }\n    }\n  }\n  while ( *(_QWORD *)a1 );\n  return 1;\n}\n"
        ],
        "134916441": [
            "sub_80AA959",
            "0x80aa959",
            "decompilation failure at 80AA959!\n"
        ],
        "134916716": [
            "sub_80AAA6C",
            "0x80aaa6c",
            "_DWORD *sub_80AAA6C()\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0x44u);\n  result[2] = -1;\n  *((_BYTE *)result + 12) = 2;\n  *((_BYTE *)result + 58) = 1;\n  return result;\n}\n"
        ],
        "134916742": [
            "sub_80AAA86",
            "0x80aaa86",
            "decompilation failure at 80AAA86!\n"
        ],
        "134918127": [
            "sub_80AAFEF",
            "0x80aafef",
            "decompilation failure at 80AAFEF!\n"
        ],
        "134918440": [
            "sub_80AB128",
            "0x80ab128",
            "char *__usercall sub_80AB128@<eax>(char *result@<eax>)\n{\n  char v1; // dl\n\n  v1 = *result;\n  if ( *result == 95 )\n  {\nLABEL_3:\n    while ( 1 )\n    {\n      v1 = *++result;\n      if ( !*result )\n        break;\n      if ( v1 != 95 && (unsigned __int8)(v1 - 48) > 9u )\n        goto LABEL_2;\n    }\n  }\n  else\n  {\nLABEL_2:\n    if ( (unsigned __int8)((v1 | 0x20) - 97) <= 0x19u )\n      goto LABEL_3;\n  }\n  return result;\n}\n"
        ],
        "134918481": [
            "sub_80AB151",
            "0x80ab151",
            "decompilation failure at 80AB151!\n"
        ],
        "134918543": [
            "sub_80AB18F",
            "0x80ab18f",
            "decompilation failure at 80AB18F!\n"
        ],
        "134918636": [
            "sub_80AB1EC",
            "0x80ab1ec",
            "decompilation failure at 80AB1EC!\n"
        ],
        "134918680": [
            "sub_80AB218",
            "0x80ab218",
            "decompilation failure at 80AB218!\n"
        ],
        "134918727": [
            "sub_80AB247",
            "0x80ab247",
            "decompilation failure at 80AB247!\n"
        ],
        "134918981": [
            "sub_80AB345",
            "0x80ab345",
            "void __noreturn sub_80AB345()\n{\n  int retaddr; // [esp+4h] [ebp+0h]\n\n  retaddr = 2147479552;\n  ((void (__noreturn *)(void))loc_80AB26B)();\n}\n"
        ],
        "134919001": [
            "sub_80AB359",
            "0x80ab359",
            "void __fastcall __noreturn sub_80AB359(int a1)\n{\n  int retaddr; // [esp+4h] [ebp+0h]\n\n  if ( !a1 )\n    retaddr = 2147479552;\n  ((void (__noreturn *)(void))loc_80AB26B)();\n}\n"
        ],
        "134919029": [
            "sub_80AB375",
            "0x80ab375",
            "decompilation failure at 80AB375!\n"
        ],
        "134919315": [
            "sub_80AB493",
            "0x80ab493",
            "decompilation failure at 80AB493!\n"
        ],
        "134919538": [
            "sub_80AB572",
            "0x80ab572",
            "decompilation failure at 80AB572!\n"
        ],
        "134919586": [
            "sub_80AB5A2",
            "0x80ab5a2",
            "decompilation failure at 80AB5A2!\n"
        ],
        "134919794": [
            "sub_80AB672",
            "0x80ab672",
            "decompilation failure at 80AB672!\n"
        ],
        "134919891": [
            "sub_80AB6D3",
            "0x80ab6d3",
            "decompilation failure at 80AB6D3!\n"
        ],
        "134920060": [
            "sub_80AB77C",
            "0x80ab77c",
            "decompilation failure at 80AB77C!\n"
        ],
        "134920105": [
            "sub_80AB7A9",
            "0x80ab7a9",
            "decompilation failure at 80AB7A9!\n"
        ],
        "134920272": [
            "sub_80AB850",
            "0x80ab850",
            "decompilation failure at 80AB850!\n"
        ],
        "134920282": [
            "sub_80AB85A",
            "0x80ab85a",
            "int __fastcall sub_80AB85A(int a1)\n{\n  int result; // eax\n  char *v2; // edx\n  char *v3; // edx\n  char *retaddr; // [esp+4h] [ebp+0h] BYREF\n\n  result = sub_80AB7A9(a1, &retaddr);\n  v2 = retaddr;\n  if ( retaddr )\n  {\n    --retaddr;\n    v3 = &v2[result - 1];\n    if ( *v3 == 10 )\n      *v3 = 0;\n  }\n  return result;\n}\n"
        ],
        "134920313": [
            "sub_80AB879",
            "0x80ab879",
            "decompilation failure at 80AB879!\n"
        ],
        "134920375": [
            "sub_80AB8B7",
            "0x80ab8b7",
            "decompilation failure at 80AB8B7!\n"
        ],
        "134920595": [
            "sub_80AB993",
            "0x80ab993",
            "decompilation failure at 80AB993!\n"
        ],
        "134921900": [
            "sub_80ABEAC",
            "0x80abeac",
            "int sub_80ABEAC(int a1, int a2, ...)\n{\n  va_list va; // [esp+Ch] [ebp+Ch] BYREF\n\n  va_start(va, a2);\n  return sub_80AB993(0, a2, (char *)va);\n}\n"
        ],
        "134921922": [
            "sub_80ABEC2",
            "0x80abec2",
            "int sub_80ABEC2(int a1, int a2, int a3, ...)\n{\n  va_list va; // [esp+10h] [ebp+10h] BYREF\n\n  va_start(va, a3);\n  return sub_80AB993(a3, a2, (char *)va);\n}\n"
        ],
        "134921946": [
            "sub_80ABEDA",
            "0x80abeda",
            "const char *__usercall sub_80ABEDA@<eax>(const char **a1@<eax>)\n{\n  const char *result; // eax\n  size_t v3; // eax\n  _BYTE *v4; // esi\n\n  while ( 1 )\n  {\n    result = *++a1;\n    if ( !*a1 )\n      break;\n    if ( *result != 45 )\n    {\n      v3 = strlen(*a1);\n      v4 = sub_804DAFA(v3 + 2);\n      *v4 = 45;\n      strcpy(v4 + 1, *a1);\n      *a1 = v4;\n    }\n  }\n  return result;\n}\n"
        ],
        "134922004": [
            "sub_80ABF14",
            "0x80abf14",
            "_DWORD *__usercall sub_80ABF14@<eax>(_DWORD *result@<eax>)\n{\n  int v1; // edx\n  int v2; // ecx\n  int i; // edi\n  int v4; // esi\n  int v5; // ebx\n  int j; // edi\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int k; // ebx\n  int v11; // esi\n  int v12; // esi\n  int m; // edi\n  int v14; // ebx\n  int v15; // ebx\n  int v16; // ebx\n  int v17; // [esp+0h] [ebp-28h]\n  int v18; // [esp+4h] [ebp-24h]\n  int v19; // [esp+Ch] [ebp-1Ch]\n  int v20; // [esp+10h] [ebp-18h]\n  int v21; // [esp+14h] [ebp-14h]\n\n  v19 = result[20];\n  v20 = result[21];\n  v21 = result[22];\n  v1 = v21;\n  v18 = v20;\n  v2 = v19;\n  v17 = result[19];\n  for ( i = 0; i != 16; i += 4 )\n  {\n    v4 = __ROL4__(result[i] + dword_80B6DA0[i] + (v1 ^ v2 & (v1 ^ v18)) + v17, 7);\n    v17 = v2 + v4;\n    v1 = v2 + v4 + __ROL4__((v18 ^ (v2 + v4) & (v2 ^ v18)) + result[i + 1] + dword_80B6DA4[i] + v1, 12);\n    v5 = __ROR4__(v18 + result[i + 2] + dword_80B6DA8[i] + (v2 ^ v1 & (v2 ^ (v2 + v4))), 15);\n    v18 = v5 + v1;\n    v2 = v5 + v1 + __ROR4__((v17 ^ (v5 + v1) & (v1 ^ v17)) + result[i + 3] + dword_80B6DAC[i] + v2, 10);\n  }\n  for ( j = 0; j != 16; j += 4 )\n  {\n    v7 = __ROL4__(v17 + result[(unsigned __int8)byte_80D8F0D[j]] + dword_80B6DE0[j] + (v18 ^ v1 & (v2 ^ v18)), 5);\n    v17 = v7 + v2;\n    v8 = __ROL4__(result[(unsigned __int8)byte_80D8F0E[j]] + dword_80B6DE4[j] + v1 + (v2 ^ v18 & (v2 ^ (v7 + v2))), 9);\n    v1 = v8 + v17;\n    v9 = __ROL4__(\n           result[(unsigned __int8)byte_80D8F0F[j]] + dword_80B6DE8[j] + v18 + (v17 ^ v2 & ((v8 + v17) ^ v17)),\n           14);\n    v18 = v9 + v1;\n    v2 = __ROR4__(result[(unsigned __int8)byte_80D8F10[j]] + dword_80B6DEC[j] + v2 + (v1 ^ v17 & (v1 ^ (v9 + v1))), 12)\n       + v9\n       + v1;\n  }\n  for ( k = 0; k != 16; k += 4 )\n  {\n    v11 = __ROL4__(v17 + result[(unsigned __int8)byte_80D8F1D[k]] + dword_80B6E20[k] + (v1 ^ v2 ^ v18), 4);\n    v17 = v2 + v11;\n    v1 = v2\n       + v11\n       + __ROL4__(((v2 + v11) ^ v2 ^ v18) + result[(unsigned __int8)byte_80D8F1E[k]] + dword_80B6E24[k] + v1, 11);\n    v12 = __ROL4__(result[(unsigned __int8)byte_80D8F1F[k]] + dword_80B6E28[k] + v18 + (v1 ^ v2 ^ (v2 + v11)), 16);\n    v18 = v1 + v12;\n    v2 = v1\n       + v12\n       + __ROR4__(result[(unsigned __int8)byte_80D8F20[k]] + dword_80B6E2C[k] + v2 + ((v1 + v12) ^ v1 ^ v17), 9);\n  }\n  for ( m = 0; m != 16; m += 4 )\n  {\n    v14 = __ROL4__(v17 + result[(unsigned __int8)byte_80D8F2D[m]] + dword_80B6E60[m] + (v18 ^ (v2 | ~v1)), 6);\n    v17 = v14 + v2;\n    v15 = __ROL4__(result[(unsigned __int8)byte_80D8F2E[m]] + dword_80B6E64[m] + v1 + (v2 ^ ((v14 + v2) | ~v18)), 10);\n    v1 = v15 + v17;\n    v16 = __ROL4__(result[(unsigned __int8)byte_80D8F2F[m]] + dword_80B6E68[m] + v18 + (v17 ^ ((v15 + v17) | ~v2)), 15);\n    v18 = v1 + v16;\n    v2 = __ROR4__(result[(unsigned __int8)byte_80D8F30[m]] + dword_80B6E6C[m] + v2 + (v1 ^ ((v1 + v16) | ~v17)), 11)\n       + v1\n       + v16;\n  }\n  result[19] += v17;\n  result[20] = v19 + v2;\n  result[21] = v18 + v20;\n  result[22] = v21 + v1;\n  return result;\n}\n"
        ],
        "134922751": [
            "sub_80AC1FF",
            "0x80ac1ff",
            "int __usercall sub_80AC1FF@<eax>(int result@<eax>)\n{\n  int j; // edx\n  int v2; // ecx\n  int v3; // ebx\n  _DWORD *v4; // edx\n  int v5; // edi\n  int v6; // ecx\n  unsigned __int64 v7; // rt0\n  int v8; // edi\n  int v9; // esi\n  int k; // edx\n  unsigned __int64 *v11; // ebx\n  int v12; // ecx\n  int v13; // edi\n  int v14; // esi\n  int v15; // ecx\n  int v16; // esi\n  int v17; // edi\n  unsigned int m; // edx\n  int v19; // ecx\n  int v20; // esi\n  int v21; // edi\n  unsigned __int64 v22; // [esp+4h] [ebp-7Ch]\n  int v23; // [esp+Ch] [ebp-74h]\n  int v24; // [esp+Ch] [ebp-74h]\n  int v25; // [esp+10h] [ebp-70h]\n  int v26; // [esp+14h] [ebp-6Ch]\n  unsigned __int64 v27; // [esp+14h] [ebp-6Ch]\n  int i; // [esp+1Ch] [ebp-64h]\n  int v29[24]; // [esp+20h] [ebp-60h]\n\n  for ( i = 0; i != 24; ++i )\n  {\n    for ( j = 0; j != 5; ++j )\n    {\n      v2 = *(_DWORD *)(result + 8 * j + 160) ^ *(_DWORD *)(result + 8 * j + 120) ^ *(_DWORD *)(result + 8 * j + 80) ^ *(_DWORD *)(result + 8 * j + 40) ^ *(_DWORD *)(result + 8 * j);\n      v3 = *(_DWORD *)(result + 8 * j + 164) ^ *(_DWORD *)(result + 8 * j + 124) ^ *(_DWORD *)(result + 8 * j + 84) ^ *(_DWORD *)(result + 8 * j + 44) ^ *(_DWORD *)(result + 8 * j + 4);\n      v29[2 * j] = v2;\n      v29[2 * j + 1] = v3;\n      v29[2 * j + 10] = v2;\n      v29[2 * j + 11] = v3;\n    }\n    v4 = (_DWORD *)result;\n    v26 = 0;\n    do\n    {\n      v5 = v29[2 * v26 + 8];\n      v23 = v29[2 * v26++ + 9];\n      HIDWORD(v7) = v29[2 * v26];\n      LODWORD(v7) = v29[2 * v26 + 1];\n      v6 = v7 >> 31;\n      HIDWORD(v7) = v7;\n      LODWORD(v7) = v29[2 * v26];\n      v8 = v6 ^ v5;\n      v9 = (v7 >> 31) ^ v23;\n      *v4 ^= v8;\n      v4[1] ^= v9;\n      v4[10] ^= v8;\n      v4[11] ^= v9;\n      v4[20] ^= v8;\n      v4[21] ^= v9;\n      v4[30] ^= v8;\n      v4[31] ^= v9;\n      v4[40] ^= v8;\n      v4[41] ^= v9;\n      v4 += 2;\n    }\n    while ( v26 != 5 );\n    v27 = *(_QWORD *)(result + 8);\n    for ( k = 0; k != 24; ++k )\n    {\n      v11 = (unsigned __int64 *)(result + 8 * (unsigned __int8)byte_80B84A8[k]);\n      v22 = *v11;\n      v12 = (unsigned __int8)byte_80B8490[k];\n      v13 = v27 << v12 >> 32;\n      v14 = (_DWORD)v27 << v12;\n      if ( (v12 & 0x20) != 0 )\n      {\n        v13 = (_DWORD)v27 << v12;\n        v14 = 0;\n      }\n      v24 = v14;\n      v25 = v13;\n      v15 = -v12 & 0x3F;\n      v16 = v27 >> v15;\n      v17 = HIDWORD(v27) >> v15;\n      if ( (v15 & 0x20) != 0 )\n      {\n        v16 = HIDWORD(v27) >> v15;\n        v17 = 0;\n      }\n      *(_DWORD *)v11 = v16 | v24;\n      *((_DWORD *)v11 + 1) = v17 | v25;\n      v27 = v22;\n    }\n    for ( m = 0; m <= 0x28; m += 9 )\n    {\n      while ( 1 )\n      {\n        v19 = *(_DWORD *)(result + 4 * m);\n        v20 = *(_DWORD *)(result + 4 * m + 8);\n        *(_DWORD *)(result + 4 * m) = v19 ^ *(_DWORD *)(result + 4 * m + 16) & ~v20;\n        *(_DWORD *)(result + 4 * m + 8) = v20 ^ *(_DWORD *)(result + 4 * m + 24) & ~*(_DWORD *)(result + 4 * m + 16);\n        v21 = *(_DWORD *)(result + 4 * m + 32);\n        *(_DWORD *)(result + 4 * m + 16) ^= v21 & ~*(_DWORD *)(result + 4 * m + 24);\n        *(_DWORD *)(result + 4 * m + 24) ^= v19 & ~v21;\n        *(_DWORD *)(result + 4 * m + 32) = v21 ^ v20 & ~v19;\n        if ( (((_BYTE)m + 1) & 1) == 0 )\n          break;\n        ++m;\n      }\n    }\n    *(_DWORD *)result ^= (unsigned __int16)word_80B6D60[i] | (372775680 << i) & 0x80000000;\n    *(_DWORD *)(result + 4) ^= (856153344 << i) & 0x80000000;\n  }\n  return result;\n}\n"
        ],
        "134923253": [
            "sub_80AC3F5",
            "0x80ac3f5",
            "int __usercall sub_80AC3F5@<eax>(int a1@<eax>, int a2@<edx>)\n{\n  int v4; // eax\n  int v5; // edi\n  unsigned int v6; // esi\n  __int64 v7; // rax\n  int result; // eax\n\n  v4 = *(_DWORD *)(a1 + 68) & 0x3F;\n  v5 = v4 + 1;\n  *(_BYTE *)(a1 + v4) = 0x80;\n  do\n  {\n    v6 = 64 - v5;\n    memset((void *)(a1 + v5), 0, 64 - v5);\n    if ( (unsigned int)(64 - v5) > 7 )\n    {\n      v7 = 8LL * *(_QWORD *)(a1 + 68);\n      if ( a2 )\n        LODWORD(v7) = sub_80A9893(0, HIDWORD(v7));\n      *(_QWORD *)(a1 + 56) = v7;\n    }\n    result = (*(int (**)(void))(a1 + 64))();\n    v5 = 0;\n  }\n  while ( v6 <= 7 );\n  return result;\n}\n"
        ],
        "134923342": [
            "sub_80AC44E",
            "0x80ac44e",
            "unsigned __int64 __usercall sub_80AC44E@<edx:eax>(_QWORD *a1@<eax>, int a2@<ecx>)\n{\n  _QWORD *v3; // esi\n  int i; // ebx\n  int v5; // edx\n  int *v6; // esi\n  unsigned int v7; // edx\n  unsigned __int64 v8; // rt0\n  int v9; // esi\n  __int64 v10; // rax\n  unsigned __int64 v11; // rax\n  unsigned __int64 result; // rax\n  __int64 v13; // [esp+8h] [ebp-308h]\n  __int64 v14; // [esp+20h] [ebp-2F0h]\n  __int64 v15; // [esp+28h] [ebp-2E8h]\n  unsigned __int64 v16; // [esp+30h] [ebp-2E0h]\n  unsigned __int64 v17; // [esp+38h] [ebp-2D8h]\n  unsigned __int64 v18; // [esp+40h] [ebp-2D0h]\n  int v19; // [esp+48h] [ebp-2C8h]\n  unsigned __int64 v20; // [esp+48h] [ebp-2C8h]\n  unsigned __int64 v21; // [esp+50h] [ebp-2C0h]\n  unsigned __int64 v22; // [esp+58h] [ebp-2B8h]\n  unsigned __int64 v23; // [esp+60h] [ebp-2B0h]\n  unsigned __int64 v24; // [esp+68h] [ebp-2A8h]\n  unsigned __int64 v25; // [esp+70h] [ebp-2A0h]\n  unsigned __int64 v26; // [esp+78h] [ebp-298h]\n  int v27[128]; // [esp+80h] [ebp-290h] BYREF\n  char v28; // [esp+280h] [ebp-90h] BYREF\n\n  v25 = a1[2];\n  v24 = a1[3];\n  v23 = a1[4];\n  v18 = a1[5];\n  v26 = a1[6];\n  v22 = a1[7];\n  v21 = a1[8];\n  v17 = a1[9];\n  v3 = a1 + 10;\n  for ( i = 0; i != 16; ++i )\n  {\n    v27[2 * i] = sub_80A9893(a2, HIDWORD(v3[i]));\n    v27[2 * i + 1] = v5;\n  }\n  v6 = v27;\n  do\n  {\n    v7 = v6[29];\n    v19 = v6[28];\n    LODWORD(v15) = (__PAIR64__(v7, v19) >> 6) ^ (__PAIR64__(v19, v7) >> 29) ^ (__PAIR64__(v7, v19) >> 19);\n    HIDWORD(v15) = (v7 >> 6) ^ (__PAIR64__(v7, v19) >> 29) ^ (__PAIR64__(v19, v7) >> 19);\n    LODWORD(v8) = v6[3];\n    HIDWORD(v8) = v6[2];\n    LODWORD(v14) = (*((_QWORD *)v6 + 1) >> 7) ^ (*((_QWORD *)v6 + 1) >> 8) ^ (*((_QWORD *)v6 + 1) >> 1);\n    HIDWORD(v14) = ((unsigned int)v8 >> 7) ^ (v8 >> 8) ^ (v8 >> 1);\n    *((_QWORD *)v6 + 16) = v14 + v15 + *((_QWORD *)v6 + 9) + *(_QWORD *)v6;\n    v6 += 2;\n  }\n  while ( &v28 != (char *)v6 );\n  v9 = 0;\n  while ( 1 )\n  {\n    LODWORD(v10) = v27[v9];\n    HIDWORD(v10) = v27[v9 + 1];\n    v20 = v17\n        + (v22 & v26 ^ v21 & ~v26)\n        + __PAIR64__(\n            (v26 >> 9) ^ (__PAIR64__(v26, HIDWORD(v26)) >> 18) ^ (__PAIR64__(v26, HIDWORD(v26)) >> 14),\n            (__PAIR64__(v26, HIDWORD(v26)) >> 9) ^ (v26 >> 18) ^ (v26 >> 14))\n        + __PAIR64__(dword_80B6F24[v9], dword_80B6F20[v9])\n        + v10;\n    LODWORD(v13) = (__PAIR64__(v25, HIDWORD(v25)) >> 7) ^ (v25 >> 28) ^ (__PAIR64__(v25, HIDWORD(v25)) >> 2);\n    HIDWORD(v13) = (v25 >> 7) ^ (__PAIR64__(v25, HIDWORD(v25)) >> 28) ^ (v25 >> 2);\n    v16 = v20 + v18;\n    v11 = v20 + (v23 & v24 ^ v25 & (v23 ^ v24)) + v13;\n    v9 += 2;\n    v18 = v23;\n    v17 = v21;\n    if ( v9 == 160 )\n      break;\n    v21 = v22;\n    v22 = v26;\n    v26 = v16;\n    v23 = v24;\n    v24 = v25;\n    v25 = v11;\n  }\n  a1[2] += v11;\n  a1[3] += v25;\n  a1[4] += v24;\n  a1[5] += v23;\n  a1[6] += v16;\n  a1[7] += v26;\n  result = v22;\n  a1[8] += v22;\n  a1[9] += v21;\n  return result;\n}\n"
        ],
        "134924757": [
            "sub_80AC9D5",
            "0x80ac9d5",
            "_DWORD *__usercall sub_80AC9D5@<eax>(_DWORD *result@<eax>)\n{\n  int i; // edx\n  unsigned __int32 v2; // ecx\n  int v3; // ebx\n  int v4; // edx\n  int v5; // esi\n  int j; // edi\n  int v7; // ecx\n  int v8; // ebp\n  int v9; // ecx\n  int v10; // [esp+0h] [ebp-C0h]\n  int v11; // [esp+4h] [ebp-BCh]\n  int v12; // [esp+8h] [ebp-B8h]\n  int v13; // [esp+Ch] [ebp-B4h]\n  int v14; // [esp+10h] [ebp-B0h]\n  int v15; // [esp+14h] [ebp-ACh]\n  int v16; // [esp+18h] [ebp-A8h]\n  int v17; // [esp+1Ch] [ebp-A4h]\n  int v18; // [esp+20h] [ebp-A0h]\n  int v19; // [esp+24h] [ebp-9Ch]\n  int v20; // [esp+28h] [ebp-98h]\n  int v21; // [esp+2Ch] [ebp-94h]\n  int v22[36]; // [esp+30h] [ebp-90h]\n\n  for ( i = 0; i != 16; ++i )\n  {\n    v2 = _byteswap_ulong(result[i]);\n    v22[i + 16] = v2;\n    v22[i] = v2;\n  }\n  v16 = result[19];\n  v17 = result[20];\n  v18 = result[21];\n  v19 = result[22];\n  v20 = result[23];\n  v3 = v20;\n  v13 = v19;\n  v4 = v18;\n  v12 = v17;\n  v11 = v16;\n  v5 = 0;\n  for ( j = 0; j != 4; ++j )\n  {\n    v21 = dword_80B84C0[j];\n    v15 = v3;\n    v3 = v13;\n    v13 = v4;\n    v10 = v12;\n    v12 = v11;\n    v14 = 19;\n    while ( 1 )\n    {\n      v7 = v3 ^ v4;\n      v8 = v22[v5];\n      if ( j )\n      {\n        v9 = v10 ^ v7;\n        if ( j == 2 )\n          v9 = v10 & v4 | v3 & (v4 | v10);\nLABEL_10:\n        v8 = __ROL4__(v22[v5 + 2] ^ v22[v5 + 8] ^ v22[v5 + 13] ^ v8, 1);\n        v22[v5 + 16] = v8;\n        v22[v5] = v8;\n        goto LABEL_11;\n      }\n      v9 = v3 ^ v10 & v7;\n      if ( v14 <= 3 )\n        goto LABEL_10;\nLABEL_11:\n      v11 = v15 + v8 + v9 + v21 + __ROL4__(v11, 5);\n      v4 = __ROR4__(v10, 2);\n      v5 = ((_BYTE)v5 + 1) & 0xF;\n      --v14;\n      v10 = v12;\n      v15 = v3;\n      if ( v14 == -1 )\n        break;\n      v3 = v13;\n      v13 = v4;\n      v12 = v11;\n    }\n  }\n  result[19] = v11 + v16;\n  result[20] = v17 + v12;\n  result[21] = v18 + v4;\n  result[22] = v19 + v13;\n  result[23] = v20 + v3;\n  return result;\n}\n"
        ],
        "134925113": [
            "sub_80ACB39",
            "0x80acb39",
            "_DWORD *__usercall sub_80ACB39@<eax>(_DWORD *result@<eax>)\n{\n  int i; // edx\n  int *v2; // edx\n  int v3; // ecx\n  int v4; // ebx\n  int v5; // ebp\n  int v6; // edx\n  int v7; // esi\n  int v8; // edi\n  int v9; // [esp+0h] [ebp-148h]\n  int v10; // [esp+4h] [ebp-144h]\n  int v11; // [esp+8h] [ebp-140h]\n  int v12; // [esp+Ch] [ebp-13Ch]\n  int v13; // [esp+14h] [ebp-134h]\n  int v14; // [esp+18h] [ebp-130h]\n  int v15; // [esp+1Ch] [ebp-12Ch]\n  int v16; // [esp+20h] [ebp-128h]\n  int v17; // [esp+24h] [ebp-124h]\n  int v18; // [esp+28h] [ebp-120h]\n  int v19; // [esp+2Ch] [ebp-11Ch]\n  int v20; // [esp+30h] [ebp-118h]\n  int v21; // [esp+34h] [ebp-114h]\n  int v22[48]; // [esp+38h] [ebp-110h] BYREF\n  char v23; // [esp+F8h] [ebp-50h] BYREF\n\n  for ( i = 0; i != 16; ++i )\n    v22[i] = _byteswap_ulong(result[i]);\n  v2 = v22;\n  do\n  {\n    v2[16] = (((unsigned int)v2[1] >> 3) ^ __ROL4__(v2[1], 14) ^ __ROR4__(v2[1], 7))\n           + v2[9]\n           + *v2\n           + (((unsigned int)v2[14] >> 10) ^ __ROL4__(v2[14], 13) ^ __ROL4__(v2[14], 15));\n    ++v2;\n  }\n  while ( &v23 != (char *)v2 );\n  v13 = result[20];\n  v14 = result[21];\n  v15 = result[22];\n  v16 = result[23];\n  v17 = result[24];\n  v18 = result[25];\n  v19 = result[26];\n  v21 = v19;\n  v12 = v18;\n  v11 = v17;\n  v3 = v16;\n  v20 = v15;\n  v10 = v14;\n  v9 = v13;\n  v4 = result[19];\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = v21\n       + v22[v5]\n       + dword_80B6F24[2 * v5]\n       + (__ROL4__(v3, 7) ^ __ROR4__(v3, 6) ^ __ROR4__(v3, 11))\n       + (v3 & v11 ^ v12 & ~v3);\n    v7 = v6 + v20;\n    v8 = v6 + (__ROL4__(v4, 10) ^ __ROR4__(v4, 13) ^ __ROR4__(v4, 2)) + (v10 & v9 ^ v4 & (v10 ^ v9));\n    ++v5;\n    v20 = v10;\n    v21 = v12;\n    if ( v5 == 64 )\n      break;\n    v12 = v11;\n    v11 = v3;\n    v3 = v7;\n    v10 = v9;\n    v9 = v4;\n    v4 = v8;\n  }\n  result[19] += v8;\n  result[20] = v13 + v4;\n  result[21] = v9 + v14;\n  result[22] = v10 + v15;\n  result[23] = v16 + v7;\n  result[24] = v17 + v3;\n  result[25] = v11 + v18;\n  result[26] = v12 + v19;\n  return result;\n}\n"
        ],
        "134925555": [
            "sub_80ACCF3",
            "0x80accf3",
            "_DWORD *__usercall sub_80ACCF3@<eax>(_DWORD *result@<eax>)\n{\n  result[19] = 1732584193;\n  result[20] = -271733879;\n  result[21] = -1732584194;\n  result[22] = 271733878;\n  result[17] = 0;\n  result[18] = 0;\n  result[16] = sub_80ABF14;\n  return result;\n}\n"
        ],
        "134925605": [
            "sub_80ACD25",
            "0x80acd25",
            "unsigned int __usercall sub_80ACD25@<eax>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)\n{\n  int v5; // edx\n  unsigned int v6; // ebp\n  unsigned int v8; // [esp+0h] [ebp-14h]\n\n  v8 = a3;\n  v5 = *(_DWORD *)(a1 + 68) & 0x3F;\n  *(_QWORD *)(a1 + 68) += a3;\n  while ( 1 )\n  {\n    v6 = 64 - v5;\n    if ( 64 - v5 > v8 )\n      v6 = v8;\n    qmemcpy((void *)(a1 + v5), a2, v6);\n    a2 += v6;\n    v8 -= v6;\n    if ( v5 + v6 != 64 )\n      break;\n    (*(void (**)(void))(a1 + 64))();\n    v5 = 0;\n  }\n  return v8;\n}\n"
        ],
        "134925689": [
            "sub_80ACD79",
            "0x80acd79",
            "int __usercall sub_80ACD79@<eax>(int a1@<eax>, void *a2@<edx>)\n{\n  sub_80AC3F5(a1, 0);\n  qmemcpy(a2, (const void *)(a1 + 76), 0x10u);\n  return 16;\n}\n"
        ],
        "134925724": [
            "sub_80ACD9C",
            "0x80acd9c",
            "_DWORD *__usercall sub_80ACD9C@<eax>(_DWORD *result@<eax>)\n{\n  result[19] = 1732584193;\n  result[20] = -271733879;\n  result[21] = -1732584194;\n  result[22] = 271733878;\n  result[23] = -1009589776;\n  result[17] = 0;\n  result[18] = 0;\n  result[16] = sub_80AC9D5;\n  return result;\n}\n"
        ],
        "134925781": [
            "sub_80ACDD5",
            "0x80acdd5",
            "int __usercall sub_80ACDD5@<eax>(int result@<eax>)\n{\n  qmemcpy((void *)(result + 68), &dword_80B6EE0, 0x28u);\n  *(_DWORD *)(result + 64) = sub_80ACB39;\n  return result;\n}\n"
        ],
        "134925810": [
            "sub_80ACDF2",
            "0x80acdf2",
            "int __usercall sub_80ACDF2@<eax>(int result@<eax>)\n{\n  unsigned int i; // edx\n  __int64 v2; // rcx\n\n  for ( i = 0; i != 40; i += 4 )\n  {\n    HIDWORD(v2) = dword_80B6EE0[i / 4];\n    LODWORD(v2) = 0;\n    *(_QWORD *)(result + 2 * i) = (unsigned int)dword_80B6EA0[i / 4] + v2;\n  }\n  return result;\n}\n"
        ],
        "134925865": [
            "sub_80ACE29",
            "0x80ace29",
            "int __usercall sub_80ACE29@<eax>(unsigned __int64 *a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned __int64 v5; // rax\n  unsigned int v6; // eax\n  int result; // eax\n  int v8; // [esp+0h] [ebp-18h]\n  unsigned int v9; // [esp+4h] [ebp-14h]\n\n  v9 = a3;\n  v8 = *(_DWORD *)a1 & 0x7F;\n  v5 = *a1 + a3;\n  *a1 = v5;\n  if ( a3 > v5 )\n    ++a1[1];\n  while ( 1 )\n  {\n    v6 = v9;\n    if ( v9 > 128 - v8 )\n      v6 = 128 - v8;\n    qmemcpy((char *)a1 + v8 + 80, a2, v6);\n    a2 += v6;\n    v9 -= v6;\n    result = v8 + v6 - 128;\n    if ( result )\n      break;\n    sub_80AC44E(a1, 0);\n    v8 = 0;\n  }\n  return result;\n}\n"
        ],
        "134925994": [
            "sub_80ACEAA",
            "0x80aceaa",
            "unsigned int __usercall sub_80ACEAA@<eax>(int a1@<eax>, void *a2@<edx>)\n{\n  int v4; // eax\n  int v5; // edx\n  unsigned int result; // eax\n\n  sub_80AC3F5(a1, 1);\n  v4 = 3 * (*(_DWORD *)(a1 + 64) != (_DWORD)sub_80AC9D5) + 5;\n  v5 = 0;\n  do\n  {\n    *(_DWORD *)(a1 + 4 * v5 + 76) = _byteswap_ulong(*(_DWORD *)(a1 + 4 * v5 + 76));\n    ++v5;\n  }\n  while ( v4 != v5 );\n  result = 4 * v4;\n  qmemcpy(a2, (const void *)(a1 + 76), result);\n  return result;\n}\n"
        ],
        "134926060": [
            "sub_80ACEEC",
            "0x80aceec",
            "int __usercall sub_80ACEEC@<eax>(int a1@<eax>, void *a2@<edx>)\n{\n  int v4; // eax\n  int v5; // edx\n  unsigned int v6; // ebp\n  int v7; // ecx\n  int v8; // edx\n  int v9; // edx\n  int v10; // ecx\n  int i; // ebp\n  int v12; // edx\n\n  v4 = *(_DWORD *)a1 & 0x7F;\n  v5 = v4 + 1;\n  *(_BYTE *)(a1 + v4 + 80) = 0x80;\n  do\n  {\n    v6 = 128 - v5;\n    memset((void *)(a1 + v5 + 80), 0, 128 - v5);\n    v7 = 0;\n    if ( (unsigned int)(128 - v5) > 0xF )\n    {\n      *(_DWORD *)(a1 + 200) = sub_80A9893(0, *(_QWORD *)a1 >> 29);\n      *(_DWORD *)(a1 + 204) = v8;\n      *(_DWORD *)(a1 + 192) = sub_80A9893(*(_DWORD *)(a1 + 4) >> 29, *(_QWORD *)(a1 + 8) >> 29);\n      *(_DWORD *)(a1 + 196) = v9;\n    }\n    sub_80AC44E((_QWORD *)a1, v7);\n    v5 = 0;\n  }\n  while ( v6 <= 0xF );\n  for ( i = 0; i != 8; ++i )\n  {\n    *(_DWORD *)(a1 + 8 * i + 16) = sub_80A9893(v10, *(_DWORD *)(a1 + 8 * i + 20));\n    *(_DWORD *)(a1 + 8 * i + 20) = v12;\n  }\n  qmemcpy(a2, (const void *)(a1 + 16), 0x40u);\n  return 64;\n}\n"
        ],
        "134926257": [
            "sub_80ACFB1",
            "0x80acfb1",
            "int __usercall sub_80ACFB1@<eax>(_DWORD *a1@<eax>)\n{\n  int result; // eax\n\n  result = 0;\n  memset(a1, 0, 0xCCu);\n  a1[51] = 72;\n  return result;\n}\n"
        ],
        "134926283": [
            "sub_80ACFCB",
            "0x80acfcb",
            "int __usercall sub_80ACFCB@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>)\n{\n  int i; // eax\n  unsigned int v7; // ecx\n  int v8; // ebp\n  int v10; // [esp+0h] [ebp-14h]\n\n  for ( i = *(_DWORD *)(a1 + 200); ; i = 0 )\n  {\n    v7 = a3;\n    if ( a3 > *(_DWORD *)(a1 + 204) - i )\n      v7 = *(_DWORD *)(a1 + 204) - i;\n    a3 -= v7;\n    v10 = i + v7;\n    v8 = a2 - i;\n    while ( i != v10 )\n    {\n      *(_BYTE *)(a1 + i) ^= *(_BYTE *)(v8 + i);\n      ++i;\n    }\n    a2 += v7;\n    if ( *(_DWORD *)(a1 + 204) != i )\n      break;\n    sub_80AC1FF(a1);\n  }\n  *(_DWORD *)(a1 + 200) = i;\n  return v10;\n}\n"
        ],
        "134926376": [
            "sub_80AD028",
            "0x80ad028",
            "int __usercall sub_80AD028@<eax>(_DWORD *a1@<eax>, void *a2@<edx>)\n{\n  *((_BYTE *)a1 + a1[50]) ^= 6u;\n  *((_BYTE *)a1 + a1[51] - 1) += 0x80;\n  sub_80AC1FF((int)a1);\n  qmemcpy(a2, a1, 0x40u);\n  return 64;\n}\n"
        ],
        "134926430": [
            "sub_80AD05E",
            "0x80ad05e",
            "void __noreturn sub_80AD05E(char *a1, ...)\n{\n  int *v1; // eax\n  const char *v2; // eax\n  va_list va; // [esp+8h] [ebp+8h] BYREF\n\n  va_start(va, a1);\n  v1 = __h_errno_location();\n  v2 = hstrerror(*v1);\n  sub_804D40A(a1, va, v2);\n  sub_804D604();\n}\n"
        ],
        "134926462": [
            "sub_80AD07E",
            "0x80ad07e",
            "int __userpurge sub_80AD07E@<eax>(unsigned __int64 a1@<edx:eax>, unsigned int a2@<ecx>, unsigned int a3)\n{\n  int v3; // esi\n  __int64 v4; // rax\n  int v5; // edx\n  int v6; // ecx\n  char *v7; // edi\n  unsigned __int8 *v8; // esi\n  unsigned int v9; // ebx\n\n  if ( a1 )\n  {\n    if ( a2 > 1 )\n    {\n      v3 = a2 * HIDWORD(a1);\n      a1 = a2 * (unsigned __int64)(unsigned int)a1;\n      HIDWORD(a1) += v3;\n    }\n    if ( a3 )\n    {\n      v4 = sub_80B4B88((a3 >> 1) + (unsigned int)a1, ((a3 >> 1) + a1) >> 32, a3, 0);\n      sub_804DDBF(\"%llu\", v4);\n      return sub_80A9707(v6, v5);\n    }\n    v7 = \"%llu\";\n    v8 = (unsigned __int8 *)&unk_80D8F5A;\n    v9 = 0;\n    while ( a1 > 0x3FF )\n    {\n      ++v8;\n      v9 = (10 * (a1 & 0x3FF) + 512) >> 10;\n      a1 >>= 10;\n      v7 = \"%llu.%u%c\";\n    }\n    if ( v9 == 10 )\n    {\n      ++a1;\n      v9 = 0;\n      if ( !a2 )\n      {\nLABEL_15:\n        v7 = \"%llu%*c\";\n        v9 = 1;\n      }\n    }\n    else if ( !a2 )\n    {\n      if ( v9 > 4 )\n        ++a1;\n      goto LABEL_15;\n    }\n    sub_804DDBF(v7, a1, v9, *v8);\n    return sub_80A9707(v6, v5);\n  }\n  return 135052877;\n}\n"
        ],
        "134926674": [
            "sub_80AD152",
            "0x80ad152",
            "char *__userpurge sub_80AD152@<eax>(\n        __int64 a1@<edx:eax>,\n        char *a2@<ecx>,\n        int a3,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10)\n{\n  unsigned int v10; // edi\n  int v11; // esi\n  unsigned int v12; // ebp\n  unsigned int v13; // ebx\n  unsigned int v14; // ebp\n  char v15; // al\n  char *v16; // esi\n  char v17; // al\n  char v18; // al\n  char v19; // al\n  char v20; // al\n  char *v21; // edi\n  char v22; // al\n  char v23; // al\n  char *v24; // ebx\n  unsigned int retaddr; // [esp+1Ch] [ebp+0h]\n  unsigned int v27; // [esp+20h] [ebp+4h]\n\n  v10 = a1;\n  if ( HIDWORD(a1) || (v11 = 0, (unsigned int)a1 > 0x1869F) )\n  {\n    v10 = 10 * a1;\n    v12 = (unsigned __int64)(10 * a1) >> 32;\n    v11 = 0;\n    do\n    {\n      v10 = __PAIR64__(v12, v10) >> 10;\n      v12 >>= 10;\n      ++v11;\n    }\n    while ( __PAIR64__(v12, v10) > 0x1869F );\n  }\n  v13 = v10;\n  retaddr = v10 / 0xA;\n  v14 = v10 % 0xA;\n  v27 = v10 / 0x64;\n  if ( v11 )\n  {\n    if ( retaddr <= 0x63 )\n    {\n      v23 = byte_80D8F4F[v27];\n      *a2 = v23;\n      v24 = \"0123456789\";\n      if ( v23 == 32 )\n        v24 = byte_80D8F4F;\n      a2[1] = v24[retaddr % 0xA];\n      a2[2] = 46;\n    }\n    else\n    {\n      v20 = byte_80D8F4F[v10 / 0x2710];\n      *a2 = v20;\n      v21 = \"0123456789\";\n      if ( v20 == 32 )\n        v21 = byte_80D8F4F;\n      v22 = v21[v13 / 0x3E8 % 0xA];\n      a2[1] = v22;\n      if ( v22 != 32 )\n        v21 = \"0123456789\";\n      v14 = retaddr % 0xA;\n      a2[2] = v21[v27 % 0xA];\n    }\n    a2[3] = a0123456789[v14];\n    v19 = *(_BYTE *)(a10 + v11);\n  }\n  else\n  {\n    v15 = byte_80D8F4F[v10 / 0x2710];\n    *a2 = v15;\n    v16 = \"0123456789\";\n    if ( v15 == 32 )\n      v16 = byte_80D8F4F;\n    v17 = v16[v10 / 0x3E8 % 0xA];\n    a2[1] = v17;\n    if ( v17 != 32 )\n      v16 = \"0123456789\";\n    v18 = v16[v27 % 0xA];\n    a2[2] = v18;\n    if ( v18 != 32 )\n      v16 = \"0123456789\";\n    a2[3] = v16[retaddr % 0xA];\n    v19 = a0123456789[v10 % 0xA];\n  }\n  a2[4] = v19;\n  return a2 + 5;\n}\n"
        ],
        "134927098": [
            "sub_80AD2FA",
            "0x80ad2fa",
            "char *__userpurge sub_80AD2FA@<eax>(\n        unsigned int a1@<eax>,\n        unsigned int a2@<edx>,\n        char *a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10)\n{\n  int v10; // edi\n  unsigned __int64 v11; // kr00_8\n  unsigned __int64 v12; // kr08_8\n  unsigned int v13; // eax\n  unsigned int v14; // esi\n  unsigned int v15; // ebx\n  char v16; // al\n  char *v17; // edi\n  char v18; // al\n  char v19; // al\n  char v20; // al\n  char *v21; // ebp\n  unsigned int v24; // [esp+1Ch] [ebp+4h]\n\n  if ( a2 || (v10 = 0, a1 > 0x270F) )\n  {\n    v11 = 10 * __PAIR64__(a2, a1);\n    v24 = HIDWORD(v11);\n    a1 = v11;\n    v10 = 0;\n    do\n    {\n      v12 = __PAIR64__(v24, a1) >> 10;\n      v24 = HIDWORD(v12);\n      a1 = v12;\n      ++v10;\n    }\n    while ( __PAIR64__(v24, a1) > 0x270F );\n  }\n  v13 = a1 / 0xA;\n  v14 = a1 / 0xA;\n  v15 = a1 % 0xA;\n  if ( v10 )\n  {\n    if ( v13 <= 9 )\n    {\n      *a3 = a0123456789[v13];\n      a3[1] = 46;\n    }\n    else\n    {\n      v20 = byte_80D8F4F[a1 / 0x3E8];\n      *a3 = v20;\n      v21 = byte_80D8F4F;\n      if ( v20 != 32 )\n        v21 = \"0123456789\";\n      v15 = v14 % 0xA;\n      a3[1] = v21[a1 / 0x64 % 0xA];\n    }\n    a3[2] = a0123456789[v15];\n    v19 = *(_BYTE *)(a10 + v10);\n  }\n  else\n  {\n    v16 = byte_80D8F4F[a1 / 0x3E8];\n    *a3 = v16;\n    v17 = byte_80D8F4F;\n    if ( v16 != 32 )\n      v17 = \"0123456789\";\n    v18 = v17[a1 / 0x64 % 0xA];\n    a3[1] = v18;\n    if ( v18 != 32 )\n      v17 = \"0123456789\";\n    a3[2] = v17[v14 % 0xA];\n    v19 = a0123456789[a1 % 0xA];\n  }\n  a3[3] = v19;\n  return a3 + 4;\n}\n"
        ],
        "134927439": [
            "sub_80AD44F",
            "0x80ad44f",
            "int __usercall sub_80AD44F@<eax>(unsigned __int8 *a1@<eax>, _WORD *a2@<edx>)\n{\n  _WORD *v2; // ebp\n  int v3; // ebx\n  char v4; // cl\n  int v5; // edi\n  unsigned __int8 v6; // si\n  unsigned __int8 v7; // dl\n  void *retaddr; // [esp+18h] [ebp+0h]\n  unsigned __int8 *v10; // [esp+1Ch] [ebp+4h]\n\n  *a2 = 1;\n  v2 = a2 + 1;\n  v3 = 0;\nLABEL_2:\n  v10 = a1 + 2;\n  v4 = 0;\n  v5 = 0;\n  while ( 1 )\n  {\n    v6 = *a1;\n    v7 = *a1 - 48;\n    if ( v7 > 9u )\n      break;\nLABEL_10:\n    ++a1;\n    v4 = v7 + 16 * v4;\n    v5 = 1;\n    if ( a1 == v10 )\n    {\nLABEL_11:\n      *((_BYTE *)v2 + v3) = v4;\n      if ( v3 == 5 )\n        return *a1;\n      if ( *a1 == 58 )\n        ++a1;\n      ++v3;\n      goto LABEL_2;\n    }\n  }\n  HIBYTE(retaddr) = v6 | 0x20;\n  if ( (unsigned __int8)((v6 | 0x20) - 97) <= 5u )\n  {\n    v7 = HIBYTE(retaddr) - 87;\n    goto LABEL_10;\n  }\n  if ( v5 && (v6 == 58 || !v6) )\n    goto LABEL_11;\n  return -1;\n}\n"
        ],
        "134927572": [
            "sub_80AD4D4",
            "0x80ad4d4",
            "unsigned int __usercall sub_80AD4D4@<eax>(unsigned __int8 *a1@<eax>, int a2@<edx>)\n{\n  unsigned int v2; // ecx\n\n  v2 = 0;\n  while ( a2 > 1 )\n  {\n    a1 += 2;\n    v2 += *((unsigned __int16 *)a1 - 1);\n    a2 -= 2;\n  }\n  if ( a2 == 1 )\n    v2 += *a1;\n  return ~(HIWORD(v2) + (unsigned __int16)v2 + ((unsigned int)(HIWORD(v2) + (unsigned __int16)v2) >> 16));\n}\n"
        ],
        "134927622": [
            "sub_80AD506",
            "0x80ad506",
            "decompilation failure at 80AD506!\n"
        ],
        "134927722": [
            "sub_80AD56A",
            "0x80ad56a",
            "decompilation failure at 80AD56A!\n"
        ],
        "134927936": [
            "sub_80AD640",
            "0x80ad640",
            "decompilation failure at 80AD640!\n"
        ],
        "134928054": [
            "sub_80AD6B6",
            "0x80ad6b6",
            "char *__usercall sub_80AD6B6@<eax>(int a1@<eax>, __int16 a2@<dx>, int a3@<ecx>, int a4)\n{\n  const char *v5; // eax\n\n  if ( *(_WORD *)a1 == 10 )\n  {\n    if ( (a2 & 0x7FFF) != 0 )\n    {\n      return (char *)sub_80B46B6(a3, a2);\n    }\n    else if ( *(_DWORD *)(a1 + 8) || *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 20) )\n    {\n      return (char *)sub_80B46A2(a4);\n    }\n    else\n    {\n      v5 = \"default\";\n      if ( (a2 & 0x8000) == 0 )\n        v5 = \"   *\" + 3;\n      return sub_804DB46(v5);\n    }\n  }\n  else\n  {\n    *(_DWORD *)dword_80DBB7C = 97;\n    return 0;\n  }\n}\n"
        ],
        "134928137": [
            "sub_80AD709",
            "0x80ad709",
            "int __usercall sub_80AD709@<eax>(_DWORD *a1@<eax>)\n{\n  unsigned int v2; // ebx\n  int v3; // esi\n  int result; // eax\n\n  if ( !dword_80DB73C )\n    return 0;\n  v2 = a1[22];\n  v3 = a1[23];\n  for ( result = *((_DWORD *)dword_80DB73C + v2 % 0x137); result; result = *(_DWORD *)(result + 16) )\n  {\n    if ( v3 == *(_DWORD *)(result + 4)\n      && v2 == *(_DWORD *)result\n      && *(_DWORD *)(result + 12) == a1[1]\n      && *(_DWORD *)(result + 8) == *a1\n      && *(_BYTE *)(result + 20) == ((a1[4] & 0xF000) == 0x4000) )\n    {\n      result += 21;\n      return result;\n    }\n  }\n  return result;\n}\n"
        ],
        "134928241": [
            "sub_80AD771",
            "0x80ad771",
            "decompilation failure at 80AD771!\n"
        ],
        "134928380": [
            "sub_80AD7FC",
            "0x80ad7fc",
            "decompilation failure at 80AD7FC!\n"
        ],
        "134928446": [
            "sub_80AD83E",
            "0x80ad83e",
            "decompilation failure at 80AD83E!\n"
        ],
        "134928502": [
            "sub_80AD876",
            "0x80ad876",
            "int __usercall sub_80AD876@<eax>(unsigned __int64 a1@<edx:eax>)\n{\n  int v1; // ecx\n  int v2; // ebp\n  int v3; // ebx\n\n  v1 = 62;\n  v2 = 0;\n  do\n  {\n    v3 = 2 * v2;\n    v2 = 2 * v2 + 1;\n    if ( (unsigned int)v2 * (unsigned __int64)(unsigned int)v2 > a1 >> v1 )\n      v2 = v3;\n    v1 -= 2;\n  }\n  while ( v1 != -2 );\n  return v2;\n}\n"
        ],
        "134928589": [
            "sub_80AD8CD",
            "0x80ad8cd",
            "int __usercall sub_80AD8CD@<eax>(char a1@<al>)\n{\n  return (unsigned __int8)(a1 - 48) <= 9u || (unsigned __int8)((a1 | 0x20) - 97) <= 0x19u || a1 == 95;\n}\n"
        ],
        "134928632": [
            "sub_80AD8F8",
            "0x80ad8f8",
            "decompilation failure at 80AD8F8!\n"
        ],
        "134928662": [
            "sub_80AD916",
            "0x80ad916",
            "decompilation failure at 80AD916!\n"
        ],
        "134929221": [
            "sub_80ADB45",
            "0x80adb45",
            "int sub_80ADB45()\n{\n  return sub_804DD98(7);\n}\n"
        ],
        "134929231": [
            "sub_80ADB4F",
            "0x80adb4f",
            "decompilation failure at 80ADB4F!\n"
        ],
        "134929375": [
            "sub_80ADBDF",
            "0x80adbdf",
            "int sub_80ADBDF()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  int result; // eax\n  unsigned __int8 v3; // al\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  while ( 1 )\n  {\n    result = v0[5];\n    if ( !result )\n      break;\n    v3 = *(_BYTE *)(v1 + result - 1) - 9;\n    if ( v3 != 23 && v3 > 4u )\n    {\n      while ( 1 )\n      {\n        result = v0[5];\n        if ( !result )\n          break;\n        LOBYTE(result) = *(_BYTE *)(v1 + result - 1);\n        result -= 9;\n        if ( (_BYTE)result == 23 || (unsigned __int8)result <= 4u )\n          break;\n        sub_80ADB4F();\n      }\n      return result;\n    }\n    sub_80ADB4F();\n  }\n  return result;\n}\n"
        ],
        "134929457": [
            "sub_80ADC31",
            "0x80adc31",
            "decompilation failure at 80ADC31!\n"
        ],
        "134929508": [
            "sub_80ADC64",
            "0x80adc64",
            "int sub_80ADC64()\n{\n  void *v0; // esi\n  int v1; // ebx\n\n  v0 = dword_80DBBA0;\n  v1 = **(_DWORD **)dword_80DBBA0 & 1;\n  if ( v1 && *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 16) )\n  {\n    sub_80ADC31();\n    --*(_DWORD *)(*(_DWORD *)v0 + 16);\n  }\n  else\n  {\n    sub_80ADB45();\n    return 0;\n  }\n  return v1;\n}\n"
        ],
        "134929555": [
            "sub_80ADC93",
            "0x80adc93",
            "int sub_80ADC93()\n{\n  void *v0; // ebx\n  int result; // eax\n\n  v0 = dword_80DBBA0;\n  if ( (**(_BYTE **)dword_80DBBA0 & 1) != 0\n    && *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 16) < *(_DWORD *)(*(_DWORD *)dword_80DBBA0 + 12) )\n  {\n    sub_80ADC31();\n    result = *(_DWORD *)(*(_DWORD *)v0 + 16) + 1;\n    *(_DWORD *)(*(_DWORD *)v0 + 16) = result;\n  }\n  else\n  {\n    sub_80ADB45();\n    return 0;\n  }\n  return result;\n}\n"
        ],
        "134929602": [
            "sub_80ADCC2",
            "0x80adcc2",
            "decompilation failure at 80ADCC2!\n"
        ],
        "134929656": [
            "sub_80ADCF8",
            "0x80adcf8",
            "decompilation failure at 80ADCF8!\n"
        ],
        "134929707": [
            "sub_80ADD2B",
            "0x80add2b",
            "decompilation failure at 80ADD2B!\n"
        ],
        "134929940": [
            "sub_80ADE14",
            "0x80ade14",
            "decompilation failure at 80ADE14!\n"
        ],
        "134930100": [
            "sub_80ADEB4",
            "0x80adeb4",
            "decompilation failure at 80ADEB4!\n"
        ],
        "134930203": [
            "sub_80ADF1B",
            "0x80adf1b",
            "decompilation failure at 80ADF1B!\n"
        ],
        "134930260": [
            "sub_80ADF54",
            "0x80adf54",
            "decompilation failure at 80ADF54!\n"
        ],
        "134931079": [
            "sub_80AE287",
            "0x80ae287",
            "decompilation failure at 80AE287!\n"
        ],
        "134931160": [
            "sub_80AE2D8",
            "0x80ae2d8",
            "void *sub_80AE2D8()\n{\n  void *result; // eax\n\n  result = dword_80DBBA0;\n  if ( *((_DWORD *)dword_80DBBA0 + 5) < *((_DWORD *)dword_80DBBA0 + 6) )\n    return (void *)sub_80AE287();\n  return result;\n}\n"
        ],
        "134931179": [
            "sub_80AE2EB",
            "0x80ae2eb",
            "decompilation failure at 80AE2EB!\n"
        ],
        "134931348": [
            "sub_80AE394",
            "0x80ae394",
            "_BYTE *__usercall sub_80AE394@<eax>(_BYTE *result@<eax>)\n{\n  _BYTE *v1; // edi\n  _DWORD *v2; // ebx\n  int v3; // esi\n  unsigned int v4; // edx\n  unsigned __int8 v5; // dl\n\n  v1 = result;\n  v2 = dword_80DBBA0;\n  v3 = *((_DWORD *)dword_80DBBA0 + 8);\n  while ( 1 )\n  {\n    v4 = v2[5];\n    if ( v4 >= v2[6] )\n      break;\n    v5 = *(_BYTE *)(v3 + v4) - 9;\n    if ( v5 == 23 || v5 <= 4u )\n      break;\n    result = sub_80AE2D8();\n  }\n  if ( v1 )\n  {\n    while ( 1 )\n    {\n      result = (_BYTE *)v2[5];\n      if ( (unsigned int)result >= v2[6] )\n        break;\n      LOBYTE(result) = result[v3];\n      result -= 9;\n      if ( (_BYTE)result != 23 && (unsigned __int8)result > 4u )\n        break;\n      sub_80AE2D8();\n    }\n  }\n  return result;\n}\n"
        ],
        "134931430": [
            "sub_80AE3E6",
            "0x80ae3e6",
            "decompilation failure at 80AE3E6!\n"
        ],
        "134931590": [
            "sub_80AE486",
            "0x80ae486",
            "unsigned int sub_80AE486()\n{\n  _DWORD *v0; // ebx\n  int v1; // esi\n  unsigned int v2; // eax\n  unsigned __int8 v3; // al\n  unsigned int v4; // edx\n  unsigned int result; // eax\n\n  v0 = dword_80DBBA0;\n  v1 = *((_DWORD *)dword_80DBBA0 + 8);\n  do\n  {\n    sub_80AE2D8();\n    v2 = v0[5];\n    if ( v2 >= v0[6] )\n      break;\n    v3 = *(_BYTE *)(v1 + v2) - 9;\n  }\n  while ( v3 == 23 || v3 <= 4u );\n  while ( 1 )\n  {\n    v4 = v0[5];\n    result = v0[6] - 1;\n    if ( v4 >= result )\n      break;\n    LOBYTE(result) = *(_BYTE *)(v1 + v4 + 1);\n    result -= 9;\n    if ( (_BYTE)result == 23 || (unsigned __int8)result <= 4u )\n      break;\n    sub_80AE2D8();\n  }\n  return result;\n}\n"
        ],
        "134931664": [
            "sub_80AE4D0",
            "0x80ae4d0",
            "decompilation failure at 80AE4D0!\n"
        ],
        "134931754": [
            "sub_80AE52A",
            "0x80ae52a",
            "void *sub_80AE52A()\n{\n  void *result; // eax\n\n  while ( 1 )\n  {\n    result = dword_80DBBA0;\n    if ( *((_DWORD *)dword_80DBBA0 + 5) >= *((_DWORD *)dword_80DBBA0 + 6) )\n      break;\n    sub_80AE287();\n  }\n  return result;\n}\n"
        ],
        "134931775": [
            "sub_80AE53F",
            "0x80ae53f",
            "void *sub_80AE53F()\n{\n  void *result; // eax\n\n  sub_80AE52A();\n  result = dword_80DBBA0;\n  if ( !*((_DWORD *)dword_80DBBA0 + 5) || *((_DWORD *)dword_80DBBA0 + 2) )\n    return (void *)sub_804DD98(10);\n  return result;\n}\n"
        ],
        "134931808": [
            "sub_80AE560",
            "0x80ae560",
            "decompilation failure at 80AE560!\n"
        ],
        "134931874": [
            "sub_80AE5A2",
            "0x80ae5a2",
            "int __fastcall sub_80AE5A2(int a1, int a2)\n{\n  int v2; // esi\n  _DWORD *v3; // ecx\n\n  v2 = sub_804D986(0, a2);\n  v3 = dword_80DBBA0;\n  *((_DWORD *)dword_80DBBA0 + 1) = v2;\n  return sub_80AE560(0, v3[6] - v3[5]);\n}\n"
        ],
        "134931929": [
            "sub_80AE5D9",
            "0x80ae5d9",
            "decompilation failure at 80AE5D9!\n"
        ],
        "134931974": [
            "sub_80AE606",
            "0x80ae606",
            "decompilation failure at 80AE606!\n"
        ],
        "134932098": [
            "sub_80AE682",
            "0x80ae682",
            "void *sub_80AE682()\n{\n  void *result; // eax\n\n  result = dword_80DBBA0;\n  if ( *((_DWORD *)dword_80DBBA0 + 5) )\n  {\n    sub_80ADB4F();\n    return (void *)sub_80AE606();\n  }\n  return result;\n}\n"
        ],
        "134932127": [
            "sub_80AE69F",
            "0x80ae69f",
            "decompilation failure at 80AE69F!\n"
        ],
        "134932158": [
            "sub_80AE6BE",
            "0x80ae6be",
            "decompilation failure at 80AE6BE!\n"
        ],
        "134932245": [
            "sub_80AE715",
            "0x80ae715",
            "decompilation failure at 80AE715!\n"
        ],
        "134932876": [
            "sub_80AE98C",
            "0x80ae98c",
            "decompilation failure at 80AE98C!\n"
        ],
        "134932917": [
            "sub_80AE9B5",
            "0x80ae9b5",
            "decompilation failure at 80AE9B5!\n"
        ],
        "134933781": [
            "sub_80AED15",
            "0x80aed15",
            "_DWORD *__usercall sub_80AED15@<eax>(int a1@<eax>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DB2E(0xFC0u);\n  *result = a1;\n  result[1] = -1;\n  result[5] = 999;\n  return result;\n}\n"
        ],
        "134933812": [
            "sub_80AED34",
            "0x80aed34",
            "decompilation failure at 80AED34!\n"
        ],
        "134933852": [
            "sub_80AED5C",
            "0x80aed5c",
            "decompilation failure at 80AED5C!\n"
        ],
        "134937283": [
            "sub_80AFAC3",
            "0x80afac3",
            "_DWORD *__usercall sub_80AFAC3@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *result; // eax\n\n  result = sub_804DAFA(8u);\n  result[1] = a2;\n  *result = *a1;\n  *a1 = result;\n  return result;\n}\n"
        ],
        "134937311": [
            "sub_80AFADF",
            "0x80afadf",
            "_DWORD *__usercall sub_80AFADF@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  _DWORD *result; // eax\n\n  while ( *a1 )\n    a1 = (_DWORD *)*a1;\n  result = sub_804DB2E(8u);\n  *a1 = result;\n  result[1] = a2;\n  return result;\n}\n"
        ],
        "134937345": [
            "sub_80AFB01",
            "0x80afb01",
            "decompilation failure at 80AFB01!\n"
        ],
        "134937374": [
            "sub_80AFB1E",
            "0x80afb1e",
            "_DWORD *__usercall sub_80AFB1E@<eax>(_DWORD *result@<eax>, _DWORD *a2@<edx>)\n{\n  if ( a2 )\n  {\n    while ( *result )\n    {\n      if ( (_DWORD *)*result == a2 )\n      {\n        *result = *a2;\n        return result;\n      }\n      result = (_DWORD *)*result;\n    }\n  }\n  return result;\n}\n"
        ],
        "134937398": [
            "sub_80AFB36",
            "0x80afb36",
            "int __usercall sub_80AFB36@<eax>(int a1@<eax>, void (__cdecl *a2)(int)@<edx>)\n{\n  int v3; // eax\n  int v5; // [esp+0h] [ebp-8h]\n\n  v5 = a1;\n  while ( v5 )\n  {\n    v3 = sub_80AFB01(v5);\n    if ( a2 )\n      a2(v3);\n  }\n  return 0;\n}\n"
        ],
        "134937431": [
            "sub_80AFB57",
            "0x80afb57",
            "int __usercall sub_80AFB57@<eax>(int a1@<eax>)\n{\n  unsigned __int64 v1; // rax\n  unsigned int v2; // ecx\n\n  HIDWORD(v1) = a1;\n  LODWORD(v1) = 0;\n  while ( HIDWORD(v1) )\n  {\n    v2 = *(_DWORD *)HIDWORD(v1);\n    *(_DWORD *)HIDWORD(v1) = v1;\n    v1 = __PAIR64__(v2, HIDWORD(v1));\n  }\n  return v1;\n}\n"
        ],
        "134937450": [
            "sub_80AFB6A",
            "0x80afb6a",
            "int **__usercall sub_80AFB6A@<eax>(int **a1@<eax>, const char *a2@<edx>)\n{\n  while ( a1 && strcmp((const char *)a1[1], a2) )\n    a1 = (int **)*a1;\n  return a1;\n}\n"
        ],
        "134937484": [
            "sub_80AFB8C",
            "0x80afb8c",
            "int __usercall sub_80AFB8C@<eax>(time_t a1@<eax>, struct utsname *a2@<edx>)\n{\n  int result; // eax\n  FILE *v5; // esi\n  char *IO_write_base; // eax\n  int v7; // eax\n  struct utsname *p_s; // edx\n  char *v9; // eax\n  int v10; // eax\n  bool v11; // zf\n  struct tm *v12; // eax\n  time_t v13; // [esp-4h] [ebp-29Ch]\n  int v14; // [esp-4h] [ebp-29Ch]\n  time_t v15; // [esp+0h] [ebp-298h] BYREF\n  char s; // [esp+5h] [ebp-293h] BYREF\n  __int16 v17; // [esp+6h] [ebp-292h]\n  struct utsname name; // [esp+106h] [ebp-192h] BYREF\n\n  time(&v15);\n  uname(&name);\n  puts(\"\\r\");\n  result = sub_80B3D37();\n  v5 = (FILE *)result;\n  if ( result )\n  {\n    while ( 1 )\n    {\n      IO_write_base = v5->_IO_write_base;\n      if ( IO_write_base >= v5->_IO_write_end )\n      {\n        v7 = __fgetc_unlocked(v5);\n        if ( v7 == -1 )\n        {\n          fclose(v5);\n          sub_804DD8F();\n          return v14;\n        }\n      }\n      else\n      {\n        v5->_IO_write_base = IO_write_base + 1;\n        v7 = (unsigned __int8)*IO_write_base;\n      }\n      s = v7;\n      LOBYTE(v17) = 0;\n      if ( v7 == 10 )\n      {\n        v17 = 13;\nLABEL_35:\n        p_s = (struct utsname *)&s;\n        goto LABEL_37;\n      }\n      if ( v7 == 92 || (p_s = (struct utsname *)&s, v7 == 37) )\n      {\n        v9 = v5->_IO_write_base;\n        if ( v9 >= v5->_IO_write_end )\n        {\n          v10 = __fgetc_unlocked(v5);\n        }\n        else\n        {\n          v5->_IO_write_base = v9 + 1;\n          v10 = (unsigned __int8)*v9;\n        }\n        p_s = (struct utsname *)name.machine;\n        if ( v10 != 109 )\n        {\n          if ( v10 > 109 )\n          {\n            p_s = (struct utsname *)name.release;\n            if ( v10 == 114 )\n              goto LABEL_37;\n            if ( v10 <= 114 )\n            {\n              if ( v10 == 110 )\n              {\nLABEL_31:\n                p_s = (struct utsname *)name.nodename;\n                goto LABEL_37;\n              }\n              v11 = v10 == 111;\n              goto LABEL_25;\n            }\n            if ( v10 == 116 )\n            {\n              sub_804EB80(&v15, 0x101u, &s, a1);\n              goto LABEL_35;\n            }\n            if ( v10 >= 116 )\n            {\n              p_s = (struct utsname *)name.version;\n              if ( v10 == 118 )\n                goto LABEL_37;\nLABEL_34:\n              s = v10;\n              goto LABEL_35;\n            }\n          }\n          else if ( v10 != 83 )\n          {\n            if ( v10 > 83 )\n            {\n              if ( v10 == 104 )\n                goto LABEL_31;\n              p_s = a2;\n              if ( v10 == 108 )\n                goto LABEL_37;\n              if ( v10 == 100 )\n              {\n                v12 = localtime(&v15);\n                strftime(&s, 0x101u, \"%A, %d %B %Y\", v12);\n                p_s = (struct utsname *)&s;\n                goto LABEL_37;\n              }\n            }\n            else\n            {\n              if ( v10 == 68 )\n                goto LABEL_32;\n              v11 = v10 == 79;\nLABEL_25:\n              if ( v11 )\n              {\nLABEL_32:\n                p_s = (struct utsname *)name.__domainname;\n                goto LABEL_37;\n              }\n            }\n            goto LABEL_34;\n          }\n          p_s = &name;\n        }\n      }\nLABEL_37:\n      fputs_unlocked(p_s, stdout);\n      a1 = v13;\n    }\n  }\n  return result;\n}\n"
        ],
        "134937888": [
            "sub_80AFD20",
            "0x80afd20",
            "void sub_80AFD20()\n{\n  void *v0; // ebx\n\n  v0 = (void *)sub_80B2BD8();\n  fputs_unlocked(v0, stdout);\n  fputs_unlocked(\" login: \", stdout);\n  sub_804DD8F();\n  free(v0);\n}\n"
        ],
        "134937940": [
            "sub_80AFD54",
            "0x80afd54",
            "int sub_80AFD54()\n{\n  __uid_t v0; // ebx\n  __uid_t v1; // eax\n  int v2; // edx\n  const char *v3; // ebx\n\n  v0 = getuid();\n  v1 = geteuid();\n  v2 = 0;\n  if ( v0 != v1 )\n  {\n    v3 = \"ENV\";\n    do\n    {\n      unsetenv(v3);\n      v3 += strlen(v3) + 1;\n    }\n    while ( *v3 );\n    putenv(\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\");\n    return 1;\n  }\n  return v2;\n}\n"
        ],
        "134938007": [
            "sub_80AFD97",
            "0x80afd97",
            "char *__usercall sub_80AFD97@<eax>(int a1@<eax>)\n{\n  int v1; // eax\n  char *v2; // ebx\n  int v3; // esi\n  _QWORD v5[7]; // [esp+0h] [ebp-F0h] BYREF\n  char v6[184]; // [esp+38h] [ebp-B8h] BYREF\n\n  v1 = open64(a1);\n  v2 = 0;\n  if ( v1 >= 0 )\n  {\n    v3 = v1;\n    v2 = 0;\n    if ( !ioctl(v1, 0x4C05u, v5) )\n      v2 = sub_804DDBF(\"%llu %s\", v5[3], v6);\n    close(v3);\n  }\n  return v2;\n}\n"
        ],
        "134938100": [
            "sub_80AFDF4",
            "0x80afdf4",
            "decompilation failure at 80AFDF4!\n"
        ],
        "134938152": [
            "sub_80AFE28",
            "0x80afe28",
            "decompilation failure at 80AFE28!\n"
        ],
        "134938809": [
            "sub_80B00B9",
            "0x80b00b9",
            "decompilation failure at 80B00B9!\n"
        ],
        "134939168": [
            "sub_80B0220",
            "0x80b0220",
            "decompilation failure at 80B0220!\n"
        ],
        "134939186": [
            "sub_80B0232",
            "0x80b0232",
            "decompilation failure at 80B0232!\n"
        ],
        "134939274": [
            "sub_80B028A",
            "0x80b028a",
            "char *__usercall sub_80B028A@<eax>(int a1@<eax>)\n{\n  int v1; // edi\n  int v2; // ecx\n  char *v3; // ebx\n  char v4; // si\n  int i; // edx\n\n  byte_80DB740 = byte_80D90DC[(unsigned __int16)a1 >> 12];\n  v1 = 256;\n  v2 = 0;\n  v3 = &byte_80DB740;\n  do\n  {\n    v4 = 0;\n    for ( i = 0; i != 3; ++i )\n    {\n      v3[i + 1] = 45;\n      if ( (v1 & a1) != 0 )\n      {\n        v3[i + 1] = byte_80D90D5[i];\n        v4 = i;\n      }\n      v1 >>= 1;\n    }\n    v3 += 3;\n    if ( ((4096 >> ++v2) & a1) != 0 )\n      *v3 = byte_80D90D8[(v4 & 2) + (v2 == 3)];\n  }\n  while ( v2 != 3 );\n  return &byte_80DB740;\n}\n"
        ],
        "134939402": [
            "sub_80B030A",
            "0x80b030a",
            "_BYTE *__usercall sub_80B030A@<eax>(_BYTE *result@<eax>)\n{\n  if ( result )\n  {\n    while ( *result )\n      *result++ = 0;\n  }\n  return result;\n}\n"
        ],
        "134939420": [
            "sub_80B031C",
            "0x80b031c",
            "_BOOL4 sub_80B031C()\n{\n  void *retaddr; // [esp+8h] [ebp+0h]\n\n  return ((int (*)(void))strcasestr)() || strcasestr(retaddr, retaddr) != 0;\n}\n"
        ],
        "134939466": [
            "sub_80B034A",
            "0x80b034a",
            "decompilation failure at 80B034A!\n"
        ],
        "134939565": [
            "sub_80B03AD",
            "0x80b03ad",
            "decompilation failure at 80B03AD!\n"
        ],
        "134939921": [
            "sub_80B0511",
            "0x80b0511",
            "_DWORD *__fastcall sub_80B0511(int a1, int (__fastcall *a2)(int, _DWORD))\n{\n  int v2; // eax\n  int v3; // ebx\n  _DWORD *result; // eax\n\n  v2 = a2(a1, a2);\n  if ( !v2 )\n    return 0;\n  v3 = v2;\n  result = sub_804DB2E(0x1Cu);\n  *result = v3;\n  return result;\n}\n"
        ],
        "134939948": [
            "sub_80B052C",
            "0x80b052c",
            "_DWORD *__fastcall sub_80B052C(int a1)\n{\n  return sub_80B0511(a1, (int (__fastcall *)(int, _DWORD))sub_80B3D76);\n}\n"
        ],
        "134939958": [
            "sub_80B0536",
            "0x80b0536",
            "decompilation failure at 80B0536!\n"
        ],
        "134940000": [
            "sub_80B0560",
            "0x80b0560",
            "decompilation failure at 80B0560!\n"
        ],
        "134940591": [
            "sub_80B07AF",
            "0x80b07af",
            "decompilation failure at 80B07AF!\n"
        ],
        "134941000": [
            "sub_80B0948",
            "0x80b0948",
            "char *__usercall sub_80B0948@<eax>(char *a1@<eax>, int a2@<edx>)\n{\n  char *result; // eax\n  char *v4; // ebx\n  char *i; // edi\n  char v6; // cl\n  unsigned int v7; // ecx\n  int v8; // ecx\n  unsigned int v9; // esi\n  unsigned int v10; // ecx\n  int v11; // esi\n  unsigned int v12; // ecx\n  char *retaddr; // [esp+1Ch] [ebp+0h]\n  int v14; // [esp+20h] [ebp+4h]\n\n  result = a1 + 1;\n  v4 = result;\n  for ( i = a1; ; i = retaddr )\n  {\n    retaddr = i + 1;\n    v6 = *i;\n    if ( !*i )\n    {\n      *(v4 - 1) = 0;\n      return a1;\n    }\n    if ( v6 == 43 && !a2 )\n    {\n      *(v4 - 1) = 32;\n      goto LABEL_18;\n    }\n    if ( v6 != 37 )\n    {\n      *(v4 - 1) = v6;\n      goto LABEL_18;\n    }\n    v7 = (unsigned __int8)i[1] - 48;\n    if ( v7 > 9 )\n    {\n      v8 = (unsigned __int8)i[1] | 0x20;\n      v9 = v8 - 97;\n      v7 = v8 - 87;\n      if ( v9 > 5 )\n        break;\n    }\n    v14 = 16 * v7;\n    v10 = (unsigned __int8)i[2] - 48;\n    if ( v10 > 9 )\n    {\n      v11 = (unsigned __int8)i[2] | 0x20;\n      v10 = -1;\n      if ( (unsigned int)(v11 - 97) <= 5 )\n        v10 = v11 - 87;\n    }\n    v12 = v14 | v10;\n    if ( v12 > 0xFF )\n      break;\n    if ( a2 && (v12 == 47 || !v12) )\n      return result;\n    *(v4 - 1) = v12;\n    retaddr = i + 3;\nLABEL_18:\n    ++v4;\n  }\n  if ( !a2 )\n  {\n    *(v4 - 1) = 37;\n    goto LABEL_18;\n  }\n  return 0;\n}\n"
        ],
        "134941219": [
            "sub_80B0A23",
            "0x80b0a23",
            "decompilation failure at 80B0A23!\n"
        ],
        "134941228": [
            "sub_80B0A2C",
            "0x80b0a2c",
            "decompilation failure at 80B0A2C!\n"
        ],
        "134941367": [
            "sub_80B0AB7",
            "0x80b0ab7",
            "decompilation failure at 80B0AB7!\n"
        ],
        "134941449": [
            "sub_80B0B09",
            "0x80b0b09",
            "decompilation failure at 80B0B09!\n"
        ],
        "134941468": [
            "sub_80B0B1C",
            "0x80b0b1c",
            "decompilation failure at 80B0B1C!\n"
        ],
        "134941586": [
            "sub_80B0B92",
            "0x80b0b92",
            "decompilation failure at 80B0B92!\n"
        ],
        "134941717": [
            "sub_80B0C15",
            "0x80b0c15",
            "unsigned int __usercall sub_80B0C15@<eax>(unsigned int result@<eax>, int a2@<edx>, char a3@<cl>)\n{\n  if ( result == 9 )\n  {\n    if ( (a3 & 2) == 0 )\n      goto LABEL_13;\n    goto LABEL_9;\n  }\n  if ( result != 10 )\n  {\n    if ( result > 0x7F )\n    {\n      result -= 128;\n      *(_WORD *)a2 = 11597;\n      a2 += 2;\n    }\nLABEL_9:\n    if ( result <= 0x1F || result == 127 )\n    {\n      *(_BYTE *)a2 = 94;\n      result ^= 0x40u;\n      goto LABEL_12;\n    }\n    goto LABEL_13;\n  }\n  if ( (a3 & 1) != 0 )\n  {\n    *(_BYTE *)a2 = 36;\nLABEL_12:\n    ++a2;\n  }\nLABEL_13:\n  *(_BYTE *)a2 = result;\n  *(_BYTE *)(a2 + 1) = 0;\n  return result;\n}\n"
        ],
        "134941784": [
            "sub_80B0C58",
            "0x80b0c58",
            "int __usercall sub_80B0C58@<eax>(int *a1@<eax>, const char *a2@<edx>)\n{\n  int result; // eax\n  const char *i; // ebx\n  int v5; // ebx\n  int *v6; // ebx\n  char *v7; // eax\n  int v8; // ecx\n  _BYTE *j; // edx\n\n  result = (int)a2;\n  for ( i = a2; ; ++i )\n  {\n    if ( !*i )\n    {\n      if ( a1 )\n      {\n        v5 = i - a2;\n        *a1 = v5;\n        a1[1] = v5;\n        a1[2] = v5;\n      }\n      return result;\n    }\n    if ( (unsigned __int8)(*i - 32) > 0x5Eu )\n      break;\n  }\n  v6 = a1;\n  v7 = sub_804DB46(a2);\n  for ( j = v7; ; ++j )\n  {\n    LOBYTE(v8) = *j;\n    if ( !*j )\n      break;\n    v8 -= 32;\n    if ( (unsigned __int8)v8 > 0x5Eu )\n      *j = 63;\n  }\n  if ( v6 )\n  {\n    j -= (int)v7;\n    *v6 = (int)j;\n    v6[1] = (int)j;\n    v6[2] = (int)j;\n  }\n  return sub_80A9707(v8, j);\n}\n"
        ],
        "134941875": [
            "sub_80B0CB3",
            "0x80b0cb3",
            "int __usercall sub_80B0CB3@<eax>(_BYTE **a1@<eax>)\n{\n  _BYTE *v1; // edx\n  unsigned int v2; // edi\n  int v3; // ecx\n  unsigned int v4; // ebx\n  unsigned __int8 v5; // al\n  unsigned int v6; // ebp\n  int v7; // esi\n  const char *v8; // ecx\n  void *retaddr; // [esp+18h] [ebp+0h]\n\n  v1 = *a1;\n  if ( **a1 == 120 )\n  {\n    ++v1;\n    v2 = 16;\n    v3 = 1;\n  }\n  else\n  {\n    v2 = 8;\n    v3 = 0;\n  }\n  v4 = 0;\n  while ( 1 )\n  {\n    HIBYTE(retaddr) = *v1;\n    v5 = *v1 | 0x20;\n    v6 = v5 - 48;\n    if ( v6 > 9 )\n      v6 = v5 - 87;\n    if ( v6 >= v2 )\n      break;\n    if ( v6 + v2 * v4 > 0xFF )\n      goto LABEL_14;\n    ++v1;\n    ++v3;\n    v4 = v6 + v2 * v4;\n    if ( v3 == 3 )\n      goto LABEL_20;\n  }\n  if ( v2 != 16 )\n  {\nLABEL_14:\n    if ( !v3 )\n    {\n      v8 = \"abefnrtv\\\\\";\n      while ( HIBYTE(retaddr) != *v8 )\n      {\n        if ( !*++v8 )\n          goto LABEL_19;\n      }\n      ++v1;\nLABEL_19:\n      v4 = *((unsigned __int8 *)v8 + 10);\n    }\n    goto LABEL_20;\n  }\n  v7 = 92;\n  if ( v3 == 1 )\n    return v7;\nLABEL_20:\n  *a1 = v1;\n  return v4;\n}\n"
        ],
        "134942035": [
            "sub_80B0D53",
            "0x80b0d53",
            "_BYTE *__usercall sub_80B0D53@<eax>(_BYTE *a1@<eax>, char *a2@<edx>, char *a3)\n{\n  char *v4; // eax\n  char v5; // dl\n  char v6; // al\n\n  a3 = a2;\n  while ( 1 )\n  {\n    v4 = a3++;\n    v5 = *v4;\n    v6 = v5;\n    if ( v5 == 92 )\n    {\n      v6 = sub_80B0CB3(&a3);\n      v5 = 92;\n    }\n    *a1 = v6;\n    if ( !v5 )\n      break;\n    ++a1;\n  }\n  return a1;\n}\n"
        ],
        "134942098": [
            "sub_80B0D92",
            "0x80b0d92",
            "int __usercall sub_80B0D92@<eax>(int *a1@<eax>, int a2@<edx>, void (*a3)(void)@<ecx>)\n{\n  int v4; // ebx\n  int v5; // eax\n  int i; // ebp\n  _DWORD *v7; // edi\n  int v11; // eax\n  int v12; // ebx\n\n  v4 = a1[1];\n  v5 = *a1;\n  for ( i = 0; v4 > i; ++i )\n  {\n    v7 = (_DWORD *)(v5 + 32 * i);\n    if ( *v7 == a2 )\n      return (int)(v7 + 1);\n  }\n  a1[1] = v4 + 1;\n  v11 = sub_80B4733(v4, 8194);\n  *a1 = v11;\n  v12 = 32 * v4;\n  *(_DWORD *)(v11 + v12) = a2;\n  a3();\n  sub_80B2C4E(28);\n  return v12 + *a1 + 4;\n}\n"
        ],
        "134942199": [
            "sub_80B0DF7",
            "0x80b0df7",
            "decompilation failure at 80B0DF7!\n"
        ],
        "134942264": [
            "sub_80B0E38",
            "0x80b0e38",
            "decompilation failure at 80B0E38!\n"
        ],
        "134942329": [
            "sub_80B0E79",
            "0x80b0e79",
            "int __usercall sub_80B0E79@<eax>(int a1@<eax>)\n{\n  return sub_80B0D92((int *)&dword_80DB754, a1, (void (*)(void))sub_80A9A17);\n}\n"
        ],
        "134942346": [
            "sub_80B0E8A",
            "0x80b0e8a",
            "int __usercall sub_80B0E8A@<eax>(int a1@<eax>)\n{\n  return sub_80B0D92((int *)&dword_80DB74C, a1, (void (*)(void))sub_80A9A2D);\n}\n"
        ],
        "134942363": [
            "sub_80B0E9B",
            "0x80b0e9b",
            "decompilation failure at 80B0E9B!\n"
        ],
        "134942400": [
            "sub_80B0EC0",
            "0x80b0ec0",
            "decompilation failure at 80B0EC0!\n"
        ],
        "134943046": [
            "sub_80B1146",
            "0x80b1146",
            "decompilation failure at 80B1146!\n"
        ],
        "134943292": [
            "sub_80B123C",
            "0x80b123c",
            "int __usercall sub_80B123C@<eax>(_DWORD *a1@<eax>, int a2@<edx>)\n{\n  int result; // eax\n\n  a1[4] = a2;\n  result = sub_804EC4A();\n  a1[3] = result;\n  a1[1] = result;\n  a1[2] = result;\n  *a1 = 0;\n  return result;\n}\n"
        ],
        "134943320": [
            "sub_80B1258",
            "0x80b1258",
            "decompilation failure at 80B1258!\n"
        ],
        "134943909": [
            "sub_80B14A5",
            "0x80b14a5",
            "int __usercall sub_80B14A5@<eax>(char a1@<al>)\n{\n  int v1; // edx\n  int result; // eax\n\n  v1 = a1 & 0x3F;\n  if ( (a1 & 0x3F) == 0 )\n    return 46;\n  result = 47;\n  if ( v1 != 1 )\n  {\n    if ( v1 > 11 )\n    {\n      result = v1 + 59;\n      if ( v1 <= 37 )\n        return v1 + 53;\n    }\n    else\n    {\n      return v1 + 46;\n    }\n  }\n  return result;\n}\n"
        ],
        "134943953": [
            "sub_80B14D1",
            "0x80b14d1",
            "int __usercall sub_80B14D1@<eax>(unsigned __int8 a1@<al>)\n{\n  int result; // eax\n\n  if ( a1 > 0x7Au )\n    return 0;\n  if ( a1 > 0x60u )\n    return a1 - 59;\n  result = 0;\n  if ( a1 <= 0x5Au )\n  {\n    if ( a1 <= 0x40u )\n    {\n      if ( (unsigned __int8)(a1 - 46) <= 0xBu )\n        return a1 - 46;\n    }\n    else\n    {\n      return a1 - 53;\n    }\n  }\n  return result;\n}\n"
        ],
        "134944007": [
            "sub_80B1507",
            "0x80b1507",
            "int __fastcall sub_80B1507(int a1, unsigned int a2)\n{\n  char v3; // al\n  _BYTE *v4; // ecx\n  char v5; // al\n  int v6; // ecx\n  char v7; // al\n  int v8; // ecx\n  int result; // eax\n  int v10; // ecx\n\n  v3 = sub_80B14A5(a2 >> 18);\n  *v4 = v3;\n  v5 = sub_80B14A5(a2 >> 12);\n  *(_BYTE *)(v6 + 1) = v5;\n  v7 = sub_80B14A5(a2 >> 6);\n  *(_BYTE *)(v8 + 2) = v7;\n  result = sub_80B14A5(a2);\n  *(_BYTE *)(v10 + 3) = result;\n  return result;\n}\n"
        ],
        "134944062": [
            "sub_80B153E",
            "0x80b153e",
            "unsigned __int8 *__usercall sub_80B153E@<eax>(\n        int *a1@<eax>,\n        unsigned __int8 *a2@<edx>,\n        char *a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9,\n        int a10,\n        int a11,\n        unsigned int a12,\n        unsigned int a13,\n        int a14,\n        int a15,\n        int a16,\n        int a17,\n        int a18,\n        unsigned __int8 *a19)\n{\n  unsigned int *i; // eax\n  char v21; // di\n  unsigned __int32 v22; // edx\n  unsigned __int32 v23; // eax\n  int *v24; // ebp\n  int *v25; // edi\n  char *v26; // esi\n  char *v27; // ecx\n  int j; // edi\n  int *v29; // ebp\n  char *v30; // esi\n  char *v31; // ecx\n  int v32; // esi\n  int v33; // eax\n  unsigned __int8 v34; // dl\n  int v35; // ecx\n  unsigned int v36; // esi\n  int v37; // edx\n  int v38; // edi\n  unsigned int v39; // edx\n  unsigned int v40; // eax\n  int v41; // esi\n  int v42; // ebp\n  unsigned int v43; // ebp\n  int *v44; // ebp\n  int *v45; // edi\n  int *v46; // esi\n  int v47; // ecx\n  int *v48; // edx\n  unsigned int v49; // ebx\n  unsigned int v50; // ebp\n  int v51; // ecx\n  int v52; // ecx\n  unsigned __int8 *result; // eax\n  char *v55; // [esp+40h] [ebp+4h]\n  char v56; // [esp+40h] [ebp+4h]\n  unsigned __int8 v57; // [esp+40h] [ebp+4h]\n  char *v58; // [esp+40h] [ebp+4h]\n  unsigned int v59; // [esp+44h] [ebp+8h]\n  unsigned int v60; // [esp+44h] [ebp+8h]\n  int *v61; // [esp+44h] [ebp+8h]\n  char *v62; // [esp+48h] [ebp+Ch]\n  unsigned int v63; // [esp+48h] [ebp+Ch]\n  unsigned int v64; // [esp+48h] [ebp+Ch]\n  char *v65; // [esp+48h] [ebp+Ch]\n  char *v66; // [esp+4Ch] [ebp+10h]\n  int v67; // [esp+58h] [ebp+1Ch]\n\n  for ( i = &a12; (char *)i - (char *)&a12 != 8; i = (unsigned int *)((char *)i + 1) )\n  {\n    v21 = *a3;\n    *(_BYTE *)i = 2 * *a3;\n    if ( 2 * v21 )\n      ++a3;\n  }\n  v22 = _byteswap_ulong(a12);\n  v23 = _byteswap_ulong(a13);\n  v24 = &a1[v22 >> 25];\n  v55 = (char *)a1 + ((v22 >> 15) & 0x1FC);\n  v66 = (char *)a1 + ((v22 >> 7) & 0x1FC);\n  v62 = (char *)a1 + ((2 * (_WORD)v22) & 0x1FC);\n  v25 = &a1[v23 >> 25];\n  v26 = (char *)a1 + ((v23 >> 15) & 0x1FC);\n  v27 = (char *)a1 + ((v23 >> 7) & 0x1FC);\n  v59 = *(int *)((char *)a1 + ((2 * (_WORD)v23) & 0x1FC) + 20256) | *((_DWORD *)v27 + 4936) | *((_DWORD *)v26 + 4808) | *((_DWORD *)v62 + 4552) | *((_DWORD *)v66 + 4424) | *((_DWORD *)v55 + 4296) | v25[4680] | v24[4168];\n  v63 = *(int *)((char *)a1 + ((2 * (_WORD)v23) & 0x1FC) + 24352) | *((_DWORD *)v27 + 5960) | *((_DWORD *)v26 + 5832) | *((_DWORD *)v62 + 5576) | *((_DWORD *)v66 + 5448) | *((_DWORD *)v55 + 5320) | v25[5704] | v24[5192];\n  v56 = 0;\n  for ( j = 0; j != 16; ++j )\n  {\n    v56 += byte_80B8500[j];\n    v29 = &a1[((v59 >> (28 - v56)) | (v59 << v56)) & 0x7F];\n    v30 = (char *)a1 + ((((v63 >> (28 - v56)) | (v63 << v56)) >> 19) & 0x1FC);\n    v31 = (char *)a1 + ((((v63 >> (28 - v56)) | (v63 << v56)) >> 12) & 0x1FC);\n    a1[j + 40] = *(int *)((char *)a1 + ((((v63 >> (28 - v56)) | (v63 << v56)) >> 5) & 0x1FC) + 27936) | *((_DWORD *)v31 + 6856) | *((_DWORD *)v30 + 6728) | *(int *)((char *)a1 + ((((v59 >> (28 - v56)) | (v59 << v56)) >> 5) & 0x1FC) + 25888) | *(int *)((char *)a1 + ((((v59 >> (28 - v56)) | (v59 << v56)) >> 12) & 0x1FC) + 25376) | *(int *)((char *)a1 + ((((v59 >> (28 - v56)) | (v59 << v56)) >> 19) & 0x1FC) + 24864) | a1[(((v63 >> (28 - v56)) | (v63 << v56)) & 0x7F) + 7112] | v29[6600];\n    a1[j + 56] = *(int *)((char *)a1 + ((((v63 >> (28 - v56)) | (v63 << v56)) >> 5) & 0x1FC) + 32032) | *((_DWORD *)v31 + 7880) | *((_DWORD *)v30 + 7752) | *(int *)((char *)a1 + ((((v59 >> (28 - v56)) | (v59 << v56)) >> 5) & 0x1FC) + 29984) | *(int *)((char *)a1 + ((((v59 >> (28 - v56)) | (v59 << v56)) >> 12) & 0x1FC) + 29472) | *(int *)((char *)a1 + ((((v59 >> (28 - v56)) | (v59 << v56)) >> 19) & 0x1FC) + 28960) | a1[(((v63 >> (28 - v56)) | (v63 << v56)) & 0x7F) + 8136] | v29[7624];\n  }\n  v32 = sub_80B14D1(a19[1]);\n  v57 = *a19;\n  v33 = (v32 << 6) | sub_80B14D1(*a19);\n  v34 = v57;\n  *a2 = v57;\n  if ( a19[1] )\n    v34 = a19[1];\n  a2[1] = v34;\n  a1[1] = 0;\n  v35 = 24;\n  v36 = 0x800000;\n  v37 = 1;\n  do\n  {\n    if ( (v37 & v33) != 0 )\n      a1[1] |= v36;\n    v37 *= 2;\n    v36 >>= 1;\n    --v35;\n  }\n  while ( v35 );\n  v67 = 25;\n  v39 = 0;\n  v40 = 0;\n  do\n  {\n    v64 = v40;\n    v41 = 0;\n    while ( 1 )\n    {\n      v42 = a1[1] & (((2 * (_BYTE)v39) & 0x3E | (8 * (_WORD)v39) & 0xFC0 | (v39 >> 31) | (v39 << 7) & 0xFC0000 | (32 * v39) & 0x3F000) ^ ((v39 >> 15) & 0x3F | (v39 >> 13) & 0xFC0 | (v39 >> 11) & 0x3F000 | (v39 >> 9) & 0x7C0000 | (v39 << 23) & 0x800000));\n      v60 = v42 ^ a1[v41 + 40] ^ ((v39 >> 15) & 0x3F | (v39 >> 13) & 0xFC0 | (v39 >> 11) & 0x3F000 | (v39 >> 9) & 0x7C0000 | (v39 << 23) & 0x800000);\n      v43 = a1[v41 + 56] ^ ((2 * (_BYTE)v39) & 0x3E | (8 * (_WORD)v39) & 0xFC0 | (v39 >> 31) | (v39 << 7) & 0xFC0000 | (32 * v39) & 0x3F000) ^ v42;\n      v38 = *a1;\n      v40 = v64 ^ (a1[*(unsigned __int8 *)(v38 + (v43 & 0xFFF) + 12352) + 9032] | a1[*(unsigned __int8 *)(v38 + (v43 >> 12) + 8256)\n                                                                                   + 8776] | a1[*(unsigned __int8 *)(v38 + (v60 & 0xFFF) + 4160)\n                                                                                              + 8520] | a1[*(unsigned __int8 *)(v38 + (v60 >> 12) + 64) + 8264]);\n      ++v41;\n      v64 = v39;\n      if ( v41 == 16 )\n        break;\n      v39 = v40;\n    }\n    --v67;\n  }\n  while ( v67 );\n  v44 = &a1[HIBYTE(v40)];\n  v65 = (char *)a1 + ((v40 >> 14) & 0x3FC);\n  v61 = &a1[BYTE1(v40)];\n  v45 = &a1[(unsigned __int8)v40];\n  v46 = &a1[HIBYTE(v39)];\n  v58 = (char *)a1 + ((v39 >> 14) & 0x3FC);\n  v47 = (int)&a1[BYTE1(v39)];\n  v48 = &a1[(unsigned __int8)v39];\n  v49 = *(_DWORD *)(v47 + 6432) | *((_DWORD *)v58 + 1352) | v61[584] | *((_DWORD *)v65 + 328) | v48[1864] | v46[1096] | v45[840] | v44[72];\n  v50 = *(_DWORD *)(v47 + 14624) | *((_DWORD *)v58 + 3400) | v61[2632] | *((_DWORD *)v65 + 2376) | v48[3912] | v46[3144] | v45[2888] | v44[2120];\n  sub_80B1507(v47, v49 >> 8);\n  sub_80B1507(v51, (v49 << 16) | HIWORD(v50));\n  sub_80B1507(v52, v50 << 8);\n  result = a2;\n  a2[13] = 0;\n  return result;\n}\n"
        ],
        "134945387": [
            "sub_80B1A6B",
            "0x80b1a6b",
            "decompilation failure at 80B1A6B!\n"
        ],
        "134946004": [
            "sub_80B1CD4",
            "0x80b1cd4",
            "int __usercall sub_80B1CD4@<eax>(_BYTE *a1@<eax>, int a2@<edx>)\n{\n  __pid_t v4; // edi\n  int v5; // ecx\n  int v6; // ebx\n  _BYTE *v7; // edi\n  unsigned int v8; // ecx\n\n  v4 = getpid();\n  v5 = v4 + sub_804EBDE();\n  v6 = 2 * a2;\n  v7 = a1;\n  do\n  {\n    *v7 = sub_80B14A5((unsigned int)(1664525 * v5 + 1013904223) >> 16);\n    v7 += 2;\n    *(v7 - 1) = sub_80B14A5(v8 >> 22);\n  }\n  while ( v7 != &a1[v6] );\n  a1[v6] = 0;\n  return v5;\n}\n"
        ],
        "134946089": [
            "sub_80B1D29",
            "0x80b1d29",
            "_BYTE *__usercall sub_80B1D29@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>)\n{\n  char v3; // al\n  int v4; // edx\n\n  v3 = *a2 | 0x20;\n  v4 = 1;\n  if ( v3 != 100 )\n  {\n    *(_WORD *)a1 = 12580;\n    a1[2] = 36;\n    a1 += 3;\n    v4 = 4;\n  }\n  sub_80B1CD4(a1, v4);\n  return a1;\n}\n"
        ],
        "134946134": [
            "sub_80B1D56",
            "0x80b1d56",
            "decompilation failure at 80B1D56!\n"
        ],
        "134947020": [
            "sub_80B20CC",
            "0x80b20cc",
            "decompilation failure at 80B20CC!\n"
        ],
        "134947609": [
            "sub_80B2319",
            "0x80b2319",
            "ssize_t __usercall sub_80B2319@<eax>(size_t nbytes@<ecx>, void *buf@<edx>, void *a3@<eax>)\n{\n  ssize_t result; // eax\n  void *retaddr; // [esp+14h] [ebp+0h]\n\n  while ( 1 )\n  {\n    result = sub_804E5BC(nbytes, buf, (int)a3);\n    if ( result >= 0 || *(_DWORD *)dword_80DBB7C != 11 )\n      break;\n    retaddr = a3;\n    sub_80B2C0A(-1, 1u);\n  }\n  return result;\n}\n"
        ],
        "134947681": [
            "sub_80B2361",
            "0x80b2361",
            "decompilation failure at 80B2361!\n"
        ],
        "134947842": [
            "sub_80B2402",
            "0x80b2402",
            "decompilation failure at 80B2402!\n"
        ],
        "134948039": [
            "sub_80B24C7",
            "0x80b24c7",
            "decompilation failure at 80B24C7!\n"
        ],
        "134948086": [
            "sub_80B24F6",
            "0x80b24f6",
            "decompilation failure at 80B24F6!\n"
        ],
        "134948115": [
            "sub_80B2513",
            "0x80b2513",
            "char sub_80B2513()\n{\n  void *retaddr; // [esp+2h] [ebp+0h] BYREF\n\n  sub_80B24F6(1, (char *)&retaddr + 3);\n  return HIBYTE(retaddr);\n}\n"
        ],
        "134948136": [
            "sub_80B2528",
            "0x80b2528",
            "decompilation failure at 80B2528!\n"
        ],
        "134948161": [
            "sub_80B2541",
            "0x80b2541",
            "int __stdcall sub_80B2541(int a1)\n{\n  return 1;\n}\n"
        ],
        "134948169": [
            "sub_80B2549",
            "0x80b2549",
            "decompilation failure at 80B2549!\n"
        ],
        "134948617": [
            "sub_80B2709",
            "0x80b2709",
            "decompilation failure at 80B2709!\n"
        ],
        "134949160": [
            "sub_80B2928",
            "0x80b2928",
            "decompilation failure at 80B2928!\n"
        ],
        "134949205": [
            "sub_80B2955",
            "0x80b2955",
            "decompilation failure at 80B2955!\n"
        ],
        "134949356": [
            "sub_80B29EC",
            "0x80b29ec",
            "decompilation failure at 80B29EC!\n"
        ],
        "134949442": [
            "sub_80B2A42",
            "0x80b2a42",
            "decompilation failure at 80B2A42!\n"
        ],
        "134949575": [
            "sub_80B2AC7",
            "0x80b2ac7",
            "decompilation failure at 80B2AC7!\n"
        ],
        "134949623": [
            "sub_80B2AF7",
            "0x80b2af7",
            "decompilation failure at 80B2AF7!\n"
        ],
        "134949712": [
            "sub_80B2B50",
            "0x80b2b50",
            "decompilation failure at 80B2B50!\n"
        ],
        "134949848": [
            "sub_80B2BD8",
            "0x80b2bd8",
            "decompilation failure at 80B2BD8!\n"
        ],
        "134949898": [
            "sub_80B2C0A",
            "0x80b2c0a",
            "decompilation failure at 80B2C0A!\n"
        ],
        "134949966": [
            "sub_80B2C4E",
            "0x80b2c4e",
            "decompilation failure at 80B2C4E!\n"
        ],
        "134949993": [
            "sub_80B2C69",
            "0x80b2c69",
            "decompilation failure at 80B2C69!\n"
        ],
        "134950014": [
            "sub_80B2C7E",
            "0x80b2c7e",
            "decompilation failure at 80B2C7E!\n"
        ],
        "134950113": [
            "sub_80B2CE1",
            "0x80b2ce1",
            "decompilation failure at 80B2CE1!\n"
        ],
        "134950332": [
            "sub_80B2DBC",
            "0x80b2dbc",
            "_BYTE *__usercall sub_80B2DBC@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *v1; // esi\n  _BYTE *v2; // edx\n  _BYTE *v3; // ecx\n  char v4; // bl\n  _BYTE *v5; // edi\n  char v6; // al\n  char v7; // al\n\n  v1 = a1;\n  v2 = a1;\n  do\n  {\n    v3 = a1;\n    v4 = *a1;\n    v5 = a1 + 1;\n    if ( *v2 != 47 )\n      goto LABEL_13;\n    if ( v4 == 47 )\n      goto LABEL_14;\n    if ( v4 != 46 )\n    {\nLABEL_13:\n      *++v2 = v4;\n      goto LABEL_14;\n    }\n    v6 = a1[1];\n    if ( v6 && v6 != 47 )\n    {\n      if ( v6 != 46 )\n        goto LABEL_13;\n      v7 = v3[2];\n      if ( v7 )\n      {\n        if ( v7 != 47 )\n          goto LABEL_13;\n      }\n      v3 = v5;\n      if ( v2 > v1 )\n      {\n        do\n          --v2;\n        while ( *v2 != 47 );\n        v3 = v5;\n      }\n    }\nLABEL_14:\n    a1 = v3 + 1;\n  }\n  while ( v3[1] );\n  if ( v2 == v1 || *v2 != 47 )\n    ++v2;\n  *v2 = 0;\n  return v2;\n}\n"
        ],
        "134950435": [
            "sub_80B2E23",
            "0x80b2e23",
            "decompilation failure at 80B2E23!\n"
        ],
        "134950490": [
            "sub_80B2E5A",
            "0x80b2e5a",
            "decompilation failure at 80B2E5A!\n"
        ],
        "134950540": [
            "sub_80B2E8C",
            "0x80b2e8c",
            "_BYTE *__usercall sub_80B2E8C@<eax>(_BYTE *result@<eax>)\n{\n  while ( *result == 32 || (unsigned __int8)(*result - 9) <= 4u )\n    ++result;\n  return result;\n}\n"
        ],
        "134950559": [
            "sub_80B2E9F",
            "0x80b2e9f",
            "_BYTE *__usercall sub_80B2E9F@<eax>(_BYTE *result@<eax>)\n{\n  while ( (*result & 0xDF) != 0 && (unsigned __int8)(*result - 9) > 4u )\n    ++result;\n  return result;\n}\n"
        ],
        "134950578": [
            "sub_80B2EB2",
            "0x80b2eb2",
            "_BYTE *__usercall sub_80B2EB2@<eax>(_BYTE *a1@<eax>)\n{\n  _BYTE *result; // eax\n\n  result = sub_804D210(a1, \"/dev/\");\n  if ( !result )\n    return a1;\n  return result;\n}\n"
        ],
        "134950599": [
            "sub_80B2EC7",
            "0x80b2ec7",
            "int __usercall sub_80B2EC7@<eax>(int a1@<eax>)\n{\n  int v1; // edx\n  int result; // eax\n\n  v1 = 0;\n  while ( (unsigned __int16)word_80B7400[2 * v1] != a1 )\n  {\n    if ( ++v1 == 31 )\n      return 0;\n  }\n  result = (unsigned __int16)word_80B7402[2 * v1];\n  if ( (result & 0x8000u) != 0 )\n    return 200 * (result & 0x7FFF);\n  return result;\n}\n"
        ],
        "134950650": [
            "sub_80B2EFA",
            "0x80b2efa",
            "int __usercall sub_80B2EFA@<eax>(int a1@<eax>)\n{\n  int v2; // ebx\n  int v3; // esi\n\n  v2 = 0;\n  while ( 1 )\n  {\n    v3 = (unsigned __int16)word_80B7400[2 * v2];\n    if ( sub_80B2EC7(v3) == a1 )\n      break;\n    if ( ++v2 == 31 )\n      return -1;\n  }\n  return v3;\n}\n"
        ],
        "134950691": [
            "sub_80B2F23",
            "0x80b2f23",
            "decompilation failure at 80B2F23!\n"
        ],
        "134950723": [
            "sub_80B2F43",
            "0x80b2f43",
            "decompilation failure at 80B2F43!\n"
        ],
        "134950744": [
            "sub_80B2F58",
            "0x80b2f58",
            "decompilation failure at 80B2F58!\n"
        ],
        "134950753": [
            "sub_80B2F61",
            "0x80b2f61",
            "decompilation failure at 80B2F61!\n"
        ],
        "134950837": [
            "sub_80B2FB5",
            "0x80b2fb5",
            "decompilation failure at 80B2FB5!\n"
        ],
        "134951129": [
            "sub_80B30D9",
            "0x80b30d9",
            "char *__usercall sub_80B30D9@<eax>(unsigned int a1@<eax>)\n{\n  if ( a1 <= 0x20 && aExit_0[7 * a1] )\n    return &aExit_0[7 * a1];\n  else\n    return sub_804D70F(a1);\n}\n"
        ],
        "134951160": [
            "sub_80B30F8",
            "0x80b30f8",
            "decompilation failure at 80B30F8!\n"
        ],
        "134951227": [
            "sub_80B313B",
            "0x80b313b",
            "decompilation failure at 80B313B!\n"
        ],
        "134951266": [
            "sub_80B3162",
            "0x80b3162",
            "decompilation failure at 80B3162!\n"
        ],
        "134951395": [
            "sub_80B31E3",
            "0x80b31e3",
            "int sub_80B31E3()\n{\n  sub_80B4242(8, 0);\n  return sub_80B4242(49, 41);\n}\n"
        ],
        "134951428": [
            "sub_80B3204",
            "0x80b3204",
            "decompilation failure at 80B3204!\n"
        ],
        "134951656": [
            "sub_80B32E8",
            "0x80b32e8",
            "decompilation failure at 80B32E8!\n"
        ],
        "134951845": [
            "sub_80B33A5",
            "0x80b33a5",
            "decompilation failure at 80B33A5!\n"
        ],
        "134952731": [
            "sub_80B371B",
            "0x80b371b",
            "decompilation failure at 80B371B!\n"
        ],
        "134952775": [
            "sub_80B3747",
            "0x80b3747",
            "decompilation failure at 80B3747!\n"
        ],
        "134953010": [
            "sub_80B3832",
            "0x80b3832",
            "decompilation failure at 80B3832!\n"
        ],
        "134953287": [
            "sub_80B3947",
            "0x80b3947",
            "decompilation failure at 80B3947!\n"
        ],
        "134953304": [
            "sub_80B3958",
            "0x80b3958",
            "unsigned int __userpurge sub_80B3958@<eax>(\n        _BYTE *a1@<eax>,\n        _BYTE *a2@<edx>,\n        int a3@<ecx>,\n        int a4,\n        int a5,\n        int a6,\n        int a7,\n        int a8,\n        int a9)\n{\n  unsigned int v9; // esi\n  int i; // ebx\n  unsigned int retaddr; // [esp+14h] [ebp+0h]\n\n  while ( a3 > 0 )\n  {\n    a3 -= 3;\n    if ( a3 == -2 )\n    {\n      v9 = 0;\n      retaddr = 0;\n    }\n    else\n    {\n      retaddr = (unsigned __int8)a2[1];\n      v9 = 0;\n      if ( a3 != -1 )\n        v9 = (unsigned __int8)a2[2];\n    }\n    *a1 = *(_BYTE *)(a9 + (*a2 >> 2));\n    a1[1] = *(_BYTE *)(a9 + ((16 * *a2) & 0x30) + (retaddr >> 4));\n    a1[2] = *(_BYTE *)(a9 + ((4 * (_BYTE)retaddr) & 0x3C) + (v9 >> 6));\n    a1 += 4;\n    *(a1 - 1) = *(_BYTE *)(a9 + (v9 & 0x3F));\n    a2 += 3;\n  }\n  *a1 = 0;\n  for ( i = 0; a3 != i; --i )\n    a1[i - 1] = *(_BYTE *)(a9 + 64);\n  return retaddr;\n}\n"
        ],
        "134953457": [
            "sub_80B39F1",
            "0x80b39f1",
            "decompilation failure at 80B39F1!\n"
        ],
        "134953647": [
            "sub_80B3AAF",
            "0x80b3aaf",
            "decompilation failure at 80B3AAF!\n"
        ],
        "134953890": [
            "sub_80B3BA2",
            "0x80b3ba2",
            "decompilation failure at 80B3BA2!\n"
        ],
        "134953987": [
            "sub_80B3C03",
            "0x80b3c03",
            "int __fastcall sub_80B3C03(int a1, int a2)\n{\n  __pid_t v2; // eax\n  int v3; // ecx\n\n  v2 = sub_80B3BA2(a1, a2);\n  return sub_804DA6B(v2, v3);\n}\n"
        ],
        "134953997": [
            "sub_80B3C0D",
            "0x80b3c0d",
            "decompilation failure at 80B3C0D!\n"
        ],
        "134954203": [
            "sub_80B3CDB",
            "0x80b3cdb",
            "int sub_80B3CDB()\n{\n  return sub_80B3C0D();\n}\n"
        ],
        "134954213": [
            "sub_80B3CE5",
            "0x80b3ce5",
            "decompilation failure at 80B3CE5!\n"
        ],
        "134954264": [
            "sub_80B3D18",
            "0x80b3d18",
            "decompilation failure at 80B3D18!\n"
        ],
        "134954295": [
            "sub_80B3D37",
            "0x80b3d37",
            "decompilation failure at 80B3D37!\n"
        ],
        "134954309": [
            "sub_80B3D45",
            "0x80b3d45",
            "int __usercall sub_80B3D45@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBA5(a1, 135102078);\n}\n"
        ],
        "134954319": [
            "sub_80B3D4F",
            "0x80b3d4f",
            "decompilation failure at 80B3D4F!\n"
        ],
        "134954333": [
            "sub_80B3D5D",
            "0x80b3d5d",
            "int __usercall sub_80B3D5D@<eax>(const char *a1@<eax>)\n{\n  return sub_804DBA5(a1, 135057992);\n}\n"
        ],
        "134954343": [
            "sub_80B3D67",
            "0x80b3d67",
            "decompilation failure at 80B3D67!\n"
        ],
        "134954350": [
            "sub_80B3D6E",
            "0x80b3d6e",
            "decompilation failure at 80B3D6E!\n"
        ],
        "134954358": [
            "sub_80B3D76",
            "0x80b3d76",
            "FILE *__usercall sub_80B3D76@<eax>(char *a1@<eax>, int a2@<ecx>)\n{\n  if ( a1 == \"standard input\" || *a1 == 45 && !a1[1] )\n    return stdin;\n  else\n    return (FILE *)sub_80B3D18(a2, 135102078);\n}\n"
        ],
        "134954395": [
            "sub_80B3D9B",
            "0x80b3d9b",
            "FILE *__usercall sub_80B3D9B@<eax>(char *a1@<eax>, int a2@<ecx>)\n{\n  FILE *result; // eax\n\n  result = sub_80B3D76(a1, a2);\n  if ( !result )\n    sub_804D604();\n  return result;\n}\n"
        ],
        "134954410": [
            "sub_80B3DAA",
            "0x80b3daa",
            "int __usercall sub_80B3DAA@<eax>(int a1@<eax>)\n{\n  if ( (char *)a1 == \"standard input\" || *(_BYTE *)a1 == 45 && !*(_BYTE *)(a1 + 1) )\n    return 0;\n  else\n    return sub_804DC14((const char *)a1);\n}\n"
        ],
        "134954438": [
            "sub_80B3DC6",
            "0x80b3dc6",
            "int __usercall sub_80B3DC6@<eax>(int a1@<eax>)\n{\n  int result; // eax\n\n  result = sub_80B3DAA(a1);\n  if ( result < 0 )\n    sub_804D604();\n  return result;\n}\n"
        ],
        "134954453": [
            "sub_80B3DD5",
            "0x80b3dd5",
            "decompilation failure at 80B3DD5!\n"
        ],
        "134954782": [
            "sub_80B3F1E",
            "0x80b3f1e",
            "decompilation failure at 80B3F1E!\n"
        ],
        "134954814": [
            "sub_80B3F3E",
            "0x80b3f3e",
            "decompilation failure at 80B3F3E!\n"
        ],
        "134954837": [
            "sub_80B3F55",
            "0x80b3f55",
            "decompilation failure at 80B3F55!\n"
        ],
        "134954861": [
            "sub_80B3F6D",
            "0x80b3f6d",
            "decompilation failure at 80B3F6D!\n"
        ],
        "134954894": [
            "sub_80B3F8E",
            "0x80b3f8e",
            "decompilation failure at 80B3F8E!\n"
        ],
        "134954922": [
            "sub_80B3FAA",
            "0x80b3faa",
            "int __fastcall sub_80B3FAA(int a1)\n{\n  return sub_80B3F8E(a1, 0);\n}\n"
        ],
        "134954935": [
            "sub_80B3FB7",
            "0x80b3fb7",
            "decompilation failure at 80B3FB7!\n"
        ],
        "134955155": [
            "sub_80B4093",
            "0x80b4093",
            "decompilation failure at 80B4093!\n"
        ],
        "134955169": [
            "sub_80B40A1",
            "0x80b40a1",
            "decompilation failure at 80B40A1!\n"
        ],
        "134955180": [
            "sub_80B40AC",
            "0x80b40ac",
            "decompilation failure at 80B40AC!\n"
        ],
        "134955192": [
            "sub_80B40B8",
            "0x80b40b8",
            "decompilation failure at 80B40B8!\n"
        ],
        "134955212": [
            "sub_80B40CC",
            "0x80b40cc",
            "decompilation failure at 80B40CC!\n"
        ],
        "134955228": [
            "sub_80B40DC",
            "0x80b40dc",
            "decompilation failure at 80B40DC!\n"
        ],
        "134955244": [
            "sub_80B40EC",
            "0x80b40ec",
            "int __fastcall sub_80B40EC(int a1)\n{\n  return sub_80B40DC(a1, 0);\n}\n"
        ],
        "134955251": [
            "sub_80B40F3",
            "0x80b40f3",
            "decompilation failure at 80B40F3!\n"
        ],
        "134955360": [
            "sub_80B4160",
            "0x80b4160",
            "decompilation failure at 80B4160!\n"
        ],
        "134955376": [
            "sub_80B4170",
            "0x80b4170",
            "decompilation failure at 80B4170!\n"
        ],
        "134955399": [
            "sub_80B4187",
            "0x80b4187",
            "int sub_80B4187()\n{\n  return sub_80B40CC(0x7FFFFFFF, 0);\n}\n"
        ],
        "134955411": [
            "sub_80B4193",
            "0x80b4193",
            "int sub_80B4193()\n{\n  return sub_80B40CC(0xFFFF, 0);\n}\n"
        ],
        "134955424": [
            "sub_80B41A0",
            "0x80b41a0",
            "decompilation failure at 80B41A0!\n"
        ],
        "134955563": [
            "sub_80B422B",
            "0x80b422b",
            "decompilation failure at 80B422B!\n"
        ],
        "134955586": [
            "sub_80B4242",
            "0x80b4242",
            "decompilation failure at 80B4242!\n"
        ],
        "134955594": [
            "sub_80B424A",
            "0x80b424a",
            "decompilation failure at 80B424A!\n"
        ],
        "134955608": [
            "sub_80B4258",
            "0x80b4258",
            "int __fastcall sub_80B4258(int a1, int a2)\n{\n  return sub_80B424A(1, a2);\n}\n"
        ],
        "134955618": [
            "sub_80B4262",
            "0x80b4262",
            "int __fastcall sub_80B4262(int a1)\n{\n  return sub_80B4258(a1, 2);\n}\n"
        ],
        "134955628": [
            "sub_80B426C",
            "0x80b426c",
            "int __fastcall sub_80B426C(int a1)\n{\n  return sub_80B4258(a1, 6);\n}\n"
        ],
        "134955638": [
            "sub_80B4276",
            "0x80b4276",
            "int __fastcall sub_80B4276(int a1)\n{\n  return sub_80B4258(a1, 9);\n}\n"
        ],
        "134955648": [
            "sub_80B4280",
            "0x80b4280",
            "decompilation failure at 80B4280!\n"
        ],
        "134955715": [
            "sub_80B42C3",
            "0x80b42c3",
            "decompilation failure at 80B42C3!\n"
        ],
        "134955775": [
            "sub_80B42FF",
            "0x80b42ff",
            "decompilation failure at 80B42FF!\n"
        ],
        "134955870": [
            "sub_80B435E",
            "0x80b435e",
            "_WORD *__usercall sub_80B435E@<eax>(_WORD *result@<eax>, __int16 a2@<dx>)\n{\n  if ( *result == 10 || *result == 2 )\n    result[1] = a2;\n  return result;\n}\n"
        ],
        "134955890": [
            "sub_80B4372",
            "0x80b4372",
            "decompilation failure at 80B4372!\n"
        ],
        "134956442": [
            "sub_80B459A",
            "0x80b459a",
            "decompilation failure at 80B459A!\n"
        ],
        "134956454": [
            "sub_80B45A6",
            "0x80b45a6",
            "decompilation failure at 80B45A6!\n"
        ],
        "134956466": [
            "sub_80B45B2",
            "0x80b45b2",
            "decompilation failure at 80B45B2!\n"
        ],
        "134956477": [
            "sub_80B45BD",
            "0x80b45bd",
            "decompilation failure at 80B45BD!\n"
        ],
        "134956488": [
            "sub_80B45C8",
            "0x80b45c8",
            "decompilation failure at 80B45C8!\n"
        ],
        "134956499": [
            "sub_80B45D3",
            "0x80b45d3",
            "decompilation failure at 80B45D3!\n"
        ],
        "134956613": [
            "sub_80B4645",
            "0x80b4645",
            "decompilation failure at 80B4645!\n"
        ],
        "134956669": [
            "sub_80B467D",
            "0x80b467d",
            "int __usercall sub_80B467D@<eax>(int a1@<eax>)\n{\n  int v2; // esi\n\n  v2 = sub_804DF99(0, 1, *(unsigned __int16 *)(a1 + 4));\n  sub_80B42C3(*(_DWORD *)a1, (struct sockaddr *)(a1 + 4));\n  return v2;\n}\n"
        ],
        "134956706": [
            "sub_80B46A2",
            "0x80b46a2",
            "int __fastcall sub_80B46A2(int a1)\n{\n  return sub_80B41A0(a1, 2);\n}\n"
        ],
        "134956716": [
            "sub_80B46AC",
            "0x80b46ac",
            "int __fastcall sub_80B46AC(int a1)\n{\n  return sub_80B41A0(a1, 1);\n}\n"
        ],
        "134956726": [
            "sub_80B46B6",
            "0x80b46b6",
            "int __fastcall sub_80B46B6(int a1)\n{\n  return sub_80B41A0(a1, 3);\n}\n"
        ],
        "134956736": [
            "sub_80B46C0",
            "0x80b46c0",
            "decompilation failure at 80B46C0!\n"
        ],
        "134956824": [
            "sub_80B4718",
            "0x80b4718",
            "decompilation failure at 80B4718!\n"
        ],
        "134956851": [
            "sub_80B4733",
            "0x80b4733",
            "char *__usercall sub_80B4733@<eax>(char *a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)\n{\n  char *v3; // ebx\n  int v5; // esi\n  unsigned int v6; // ebp\n\n  v3 = a1;\n  v5 = 1 << a2;\n  if ( (a3 & ((1 << a2) - 1)) == 0 )\n  {\n    v6 = a2 >> 8;\n    v3 = (char *)sub_804DB13(a1, (a2 >> 8) * (v5 + a3 + 1));\n    memset(&v3[v6 * a3], 0, v6 * (v5 + 1));\n  }\n  return v3;\n}\n"
        ],
        "134956922": [
            "sub_80B477A",
            "0x80b477a",
            "decompilation failure at 80B477A!\n"
        ],
        "134956986": [
            "sub_80B47BA",
            "0x80b47ba",
            "decompilation failure at 80B47BA!\n"
        ],
        "134957012": [
            "sub_80B47D4",
            "0x80b47d4",
            "decompilation failure at 80B47D4!\n"
        ],
        "134957021": [
            "sub_80B47DD",
            "0x80b47dd",
            "decompilation failure at 80B47DD!\n"
        ],
        "134957246": [
            "sub_80B48BE",
            "0x80b48be",
            "decompilation failure at 80B48BE!\n"
        ],
        "134957357": [
            "sub_80B492D",
            "0x80b492d",
            "__int64 __cdecl sub_80B492D(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n  unsigned int v3; // edi\n  unsigned int v4; // esi\n  unsigned int v5; // ebx\n  unsigned __int64 v6; // kr08_8\n  int v7; // eax\n  int v8; // ebx\n  unsigned int v9; // eax\n  bool v10; // cf\n  int v11; // edx\n  unsigned __int64 v12; // rtt\n  unsigned int v13; // esi\n  int v14; // edi\n  unsigned __int64 v15; // rax\n  __int64 result; // rax\n  unsigned int v17; // [esp+Ch] [ebp-2Ch]\n  int v18; // [esp+14h] [ebp-24h]\n  char v19; // [esp+1Ch] [ebp-1Ch]\n\n  v18 = 0;\n  v2 = a1;\n  v3 = HIDWORD(a2);\n  v4 = a2;\n  if ( a1 < 0 )\n  {\n    v18 = -1;\n    v2 = -a1;\n  }\n  if ( a2 < 0 )\n  {\n    v4 = -(int)a2;\n    v18 = ~v18;\n    v3 = (unsigned __int64)-a2 >> 32;\n  }\n  v5 = v4;\n  v6 = v2;\n  if ( !v3 )\n  {\n    if ( v4 <= HIDWORD(v2) )\n    {\n      if ( !v4 )\n        v5 = 1 / 0u;\n      v3 = HIDWORD(v2) / v5;\n      v7 = __PAIR64__(HIDWORD(v2) % v5, v2) / v5;\n    }\n    else\n    {\n      v7 = v2 / v4;\n    }\n    v8 = v7;\n    goto LABEL_24;\n  }\n  if ( v3 > HIDWORD(v2) )\n  {\n    v3 = 0;\nLABEL_22:\n    v8 = 0;\n    goto LABEL_24;\n  }\n  _BitScanReverse(&v9, v3);\n  v19 = v9 ^ 0x1F;\n  if ( v9 == 0x1F )\n  {\n    v10 = v3 < HIDWORD(v2);\n    v3 = 0;\n    if ( v10 || v4 <= (unsigned int)v6 )\n    {\n      v8 = 1;\n      goto LABEL_24;\n    }\n    goto LABEL_22;\n  }\n  v11 = (v3 << v19) | (v4 >> (32 - v19));\n  v17 = v4 << v19;\n  LODWORD(v12) = (HIDWORD(v6) << v19) | ((unsigned int)v6 >> (32 - v19));\n  HIDWORD(v12) = HIDWORD(v6) >> (32 - v19);\n  v13 = v12 % (unsigned int)v11;\n  v14 = v12 / (unsigned int)v11;\n  v8 = v14;\n  v15 = v17 * (unsigned __int64)(unsigned int)v14;\n  if ( v13 < HIDWORD(v15) || (_DWORD)v6 << v19 < v17 * v14 && v13 == HIDWORD(v15) )\n    v8 = v14 - 1;\n  v3 = 0;\nLABEL_24:\n  result = __PAIR64__(v3, v8);\n  if ( v18 )\n    return -__SPAIR64__(v3, v8);\n  return result;\n}\n"
        ],
        "134957642": [
            "sub_80B4A4A",
            "0x80b4a4a",
            "int __cdecl sub_80B4A4A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rax\n  unsigned int v3; // esi\n  int v4; // ebx\n  unsigned __int64 v5; // kr00_8\n  unsigned __int64 v6; // rax\n  unsigned __int64 v7; // kr08_8\n  unsigned __int64 v8; // rtt\n  unsigned __int64 v9; // rdi\n  unsigned __int64 v10; // rax\n  unsigned int v11; // ecx\n  unsigned int v12; // ebx\n  __int64 v13; // rax\n  unsigned __int64 v14; // rdi\n  __int64 v16; // [esp+4h] [ebp-34h]\n  int v17; // [esp+Ch] [ebp-2Ch]\n  __int64 v18; // [esp+10h] [ebp-28h]\n  unsigned int v19; // [esp+1Ch] [ebp-1Ch]\n\n  v17 = 0;\n  v18 = a1;\n  v2 = a2;\n  if ( a1 < 0 )\n  {\n    v17 = -1;\n    v18 = -a1;\n  }\n  if ( a2 < 0 )\n    v2 = -a2;\n  v3 = v2;\n  v5 = v18;\n  v4 = HIDWORD(v5);\n  LODWORD(v2) = v5;\n  v19 = v18;\n  if ( !HIDWORD(v2) )\n  {\n    HIDWORD(v2) = HIDWORD(v18);\n    if ( v3 <= HIDWORD(v18) )\n    {\n      if ( !v3 )\n        v3 = 1 / 0u;\n      HIDWORD(v2) = HIDWORD(v18) % v3;\n      LODWORD(v2) = v18;\n    }\n    v6 = v2 % v3;\n    goto LABEL_22;\n  }\n  if ( HIDWORD(v2) > HIDWORD(v18) )\n  {\n    LODWORD(v6) = v18;\nLABEL_18:\n    HIDWORD(v6) = v4;\n    goto LABEL_22;\n  }\n  _BitScanReverse((unsigned int *)&v2, HIDWORD(v2));\n  LOBYTE(v18) = v2 ^ 0x1F;\n  if ( (unsigned int)v2 == 0x1F )\n  {\n    if ( HIDWORD(v2) < HIDWORD(v18) || v3 <= v19 )\n    {\n      v7 = __PAIR64__(HIDWORD(v18), v19) - __PAIR64__(HIDWORD(v2), v3);\n      v4 = HIDWORD(v7);\n      v19 = v7;\n    }\n    LODWORD(v6) = v19;\n    goto LABEL_18;\n  }\n  LODWORD(v16) = v3 << v18;\n  HIDWORD(v16) = (HIDWORD(v2) << v18) | (v3 >> (32 - v18));\n  LODWORD(v8) = (HIDWORD(v18) << v18) | (v19 >> (32 - v18));\n  HIDWORD(v8) = HIDWORD(v18) >> (32 - v18);\n  HIDWORD(v9) = v8 % HIDWORD(v16);\n  LODWORD(v9) = v19 << v18;\n  v10 = (unsigned int)v16 * (unsigned __int64)(unsigned int)(v8 / HIDWORD(v16));\n  v11 = HIDWORD(v10);\n  v12 = v10;\n  if ( v9 < v10 )\n  {\n    v13 = v10 - v16;\n    v11 = HIDWORD(v13);\n    v12 = v13;\n  }\n  v14 = v9 - __PAIR64__(v11, v12);\n  LODWORD(v6) = ((unsigned int)v14 >> v18) | (HIDWORD(v14) << (32 - v18));\n  HIDWORD(v6) = HIDWORD(v14) >> v18;\nLABEL_22:\n  if ( v17 )\n    return -(__int64)v6;\n  return v6;\n}\n"
        ],
        "134957960": [
            "sub_80B4B88",
            "0x80b4b88",
            "unsigned int __cdecl sub_80B4B88(unsigned __int64 a1, unsigned int a2, unsigned int a3)\n{\n  unsigned int v4; // ebx\n  unsigned int v5; // ebx\n  unsigned int v6; // eax\n  unsigned __int64 v7; // rtt\n  unsigned int v8; // esi\n  unsigned int v9; // edi\n  unsigned __int64 v10; // rax\n  int v12; // [esp+4h] [ebp-24h]\n  char v13; // [esp+Ch] [ebp-1Ch]\n\n  if ( !a3 )\n  {\n    if ( a2 > HIDWORD(a1) )\n      return a1 / a2;\n    v4 = a2;\n    if ( !a2 )\n      v4 = 1 / 0u;\n    return __PAIR64__(HIDWORD(a1) % v4, a1) / v4;\n  }\n  if ( a3 > HIDWORD(a1) )\n    return 0;\n  _BitScanReverse(&v6, a3);\n  v13 = v6 ^ 0x1F;\n  if ( v6 == 0x1F )\n    return a3 < HIDWORD(a1) || a2 <= (unsigned int)a1;\n  v12 = (a3 << v13) | (a2 >> (32 - v13));\n  LODWORD(v7) = (HIDWORD(a1) << v13) | ((unsigned int)a1 >> (32 - v13));\n  HIDWORD(v7) = HIDWORD(a1) >> (32 - v13);\n  v8 = v7 % (unsigned int)v12;\n  v9 = v7 / (unsigned int)v12;\n  v5 = v9;\n  v10 = (a2 << v13) * (unsigned __int64)v9;\n  if ( v8 < HIDWORD(v10) || (_DWORD)a1 << v13 < (a2 << v13) * v9 && v8 == HIDWORD(v10) )\n    return v9 - 1;\n  return v5;\n}\n"
        ],
        "134958199": [
            "sub_80B4C77",
            "0x80b4c77",
            "int __cdecl sub_80B4C77(unsigned __int64 a1, __int64 a2)\n{\n  int result; // eax\n  unsigned int v4; // ecx\n  unsigned __int64 v5; // rtt\n  unsigned int v6; // ecx\n  unsigned __int64 v7; // rtt\n  unsigned __int64 v8; // rcx\n  unsigned __int64 v9; // rax\n  unsigned int v10; // edi\n  unsigned int v11; // esi\n  __int64 v12; // rax\n  __int64 v13; // [esp+0h] [ebp-28h]\n  char v14; // [esp+Ch] [ebp-1Ch]\n\n  result = a1;\n  if ( HIDWORD(a2) )\n  {\n    if ( HIDWORD(a2) <= HIDWORD(a1) )\n    {\n      _BitScanReverse(&v6, HIDWORD(a2));\n      v14 = v6 ^ 0x1F;\n      if ( v6 != 0x1F )\n      {\n        LODWORD(v13) = (_DWORD)a2 << v14;\n        HIDWORD(v13) = (HIDWORD(a2) << v14) | ((unsigned int)a2 >> (32 - v14));\n        LODWORD(v7) = (HIDWORD(a1) << v14) | ((unsigned int)a1 >> (32 - v14));\n        HIDWORD(v7) = HIDWORD(a1) >> (32 - v14);\n        HIDWORD(v8) = v7 % HIDWORD(v13);\n        LODWORD(v8) = (_DWORD)a1 << v14;\n        v9 = (unsigned int)((_DWORD)a2 << v14) * (unsigned __int64)(unsigned int)(v7 / HIDWORD(v13));\n        v10 = HIDWORD(v9);\n        v11 = v9;\n        if ( v8 < v9 )\n        {\n          v12 = v9 - v13;\n          v10 = HIDWORD(v12);\n          v11 = v12;\n        }\n        return (((unsigned int)v8 - v11) >> v14) | ((v8 - __PAIR64__(v10, v11)) >> 32 << (32 - v14));\n      }\n      else if ( HIDWORD(a2) < HIDWORD(a1) || (unsigned int)a2 <= (unsigned int)a1 )\n      {\n        return a1 - a2;\n      }\n    }\n  }\n  else\n  {\n    if ( (unsigned int)a2 > HIDWORD(a1) )\n      return a1 % (unsigned int)a2;\n    v4 = a2;\n    if ( !(_DWORD)a2 )\n      v4 = 1 / 0u;\n    LODWORD(v5) = a1;\n    HIDWORD(v5) = HIDWORD(a1) % v4;\n    return v5 % v4;\n  }\n  return result;\n}\n"
        ],
        "134958447": [
            "sub_80B4D6F",
            "0x80b4d6f",
            "int __cdecl sub_80B4D6F(unsigned __int64 a1, __int64 a2, _DWORD *a3)\n{\n  unsigned int v3; // esi\n  unsigned __int64 v4; // rax\n  int v5; // eax\n  int v6; // edx\n  unsigned __int64 v7; // rt2\n  int v8; // esi\n  unsigned int v9; // esi\n  unsigned __int64 v10; // rtt\n  int v11; // ecx\n  unsigned __int64 v12; // rax\n  unsigned int v13; // ebx\n  unsigned int v14; // edi\n  unsigned __int64 v15; // rax\n  unsigned int v17; // [esp+8h] [ebp-30h]\n  unsigned int v18; // [esp+14h] [ebp-24h]\n  unsigned int v19; // [esp+18h] [ebp-20h]\n  char v20; // [esp+1Ch] [ebp-1Ch]\n\n  v3 = a2;\n  v4 = a1;\n  if ( HIDWORD(a2) )\n  {\n    if ( HIDWORD(a2) <= HIDWORD(a1) )\n    {\n      _BitScanReverse(&v9, HIDWORD(a2));\n      v20 = v9 ^ 0x1F;\n      if ( v9 != 0x1F )\n      {\n        v18 = (HIDWORD(a2) << v20) | ((unsigned int)a2 >> (32 - v20));\n        v17 = (_DWORD)a1 << v20;\n        LODWORD(v10) = (HIDWORD(a1) << v20) | ((unsigned int)a1 >> (32 - v20));\n        HIDWORD(v10) = HIDWORD(a1) >> (32 - v20);\n        v19 = v10 % v18;\n        v11 = v10 / v18;\n        v8 = v11;\n        v12 = (unsigned int)((_DWORD)a2 << v20) * (unsigned __int64)(unsigned int)v11;\n        v14 = HIDWORD(v12);\n        v13 = v12;\n        if ( __PAIR64__(v19, (_DWORD)a1 << v20) < v12 )\n        {\n          v15 = v12 - __PAIR64__(v18, (_DWORD)a2 << v20);\n          v8 = v11 - 1;\n          v14 = HIDWORD(v15);\n          v13 = v15;\n        }\n        if ( a3 )\n        {\n          *a3 = ((v17 - v13) >> v20) | ((__PAIR64__(v19, v17) - __PAIR64__(v14, v13)) >> 32 << (32 - v20));\n          a3[1] = (unsigned int)((__PAIR64__(v19, v17) - __PAIR64__(v14, v13)) >> 32) >> v20;\n        }\n      }\n      else\n      {\n        if ( HIDWORD(a2) < HIDWORD(a1) || (v8 = 0, (unsigned int)a2 <= (unsigned int)a1) )\n        {\n          v8 = 1;\n          v4 = a1 - a2;\n        }\n        if ( a3 )\n          *(_QWORD *)a3 = v4;\n      }\n    }\n    else\n    {\n      if ( a3 )\n        *(_QWORD *)a3 = a1;\n      return 0;\n    }\n  }\n  else\n  {\n    if ( (unsigned int)a2 <= HIDWORD(a1) )\n    {\n      if ( !(_DWORD)a2 )\n        v3 = 1 / 0u;\n      HIDWORD(v4) = HIDWORD(a1) % v3;\n      LODWORD(v4) = a1;\n    }\n    v7 = v4 % v3;\n    v5 = v4 / v3;\n    v6 = v7;\n    v8 = v5;\n    if ( a3 )\n    {\n      *a3 = v6;\n      a3[1] = 0;\n    }\n  }\n  return v8;\n}\n"
        ],
        "134958817": [
            "sub_80B4EE1",
            "0x80b4ee1",
            "void *sub_80B4EE1()\n{\n  void (**i)(void); // ebx\n  void *retaddr; // [esp+8h] [ebp+4h]\n\n  for ( i = (void (**)(void))&dword_80DAF40; *i != (void (*)(void))-1; --i )\n    (*i)();\n  return retaddr;\n}\n"
        ]
    },
    "strings": {
        "134512948": [
            "/lib/ld-uClibc.so.0",
            [
                4294967295
            ]
        ],
        "134521049": [
            "libc.so.0",
            []
        ],
        "134521059": [
            "stpcpy",
            [
                4294967295
            ]
        ],
        "134521066": [
            "strcpy",
            [
                4294967295
            ]
        ],
        "134521073": [
            "chroot",
            [
                4294967295
            ]
        ],
        "134521080": [
            "setrlimit64",
            [
                4294967295
            ]
        ],
        "134521092": [
            "unsetenv",
            [
                4294967295
            ]
        ],
        "134521101": [
            "mkstemp64",
            [
                4294967295
            ]
        ],
        "134521111": [
            "waitpid",
            [
                4294967295
            ]
        ],
        "134521119": [
            "ioctl",
            [
                4294967295
            ]
        ],
        "134521125": [
            "pututxline",
            [
                4294967295
            ]
        ],
        "134521136": [
            "getgid",
            [
                4294967295
            ]
        ],
        "134521143": [
            "popen",
            [
                4294967295
            ]
        ],
        "134521149": [
            "sysconf",
            [
                4294967295
            ]
        ],
        "134521157": [
            "vsprintf",
            [
                4294967295
            ]
        ],
        "134521166": [
            "getspnam_r",
            [
                4294967295
            ]
        ],
        "134521177": [
            "cfgetospeed",
            [
                4294967295
            ]
        ],
        "134521194": [
            "connect",
            [
                4294967295
            ]
        ],
        "134521202": [
            "ungetc",
            [
                4294967295
            ]
        ],
        "134521209": [
            "tcgetsid",
            [
                4294967295
            ]
        ],
        "134521218": [
            "utimes",
            [
                4294967295
            ]
        ],
        "134521225": [
            "shmctl",
            [
                4294967295
            ]
        ],
        "134521232": [
            "memrchr",
            [
                4294967295
            ]
        ],
        "134521240": [
            "geteuid",
            [
                4294967295
            ]
        ],
        "134521248": [
            "lsetxattr",
            [
                4294967295
            ]
        ],
        "134521258": [
            "inet_pton",
            [
                4294967295
            ]
        ],
        "134521268": [
            "memmove",
            [
                4294967295
            ]
        ],
        "134521276": [
            "pclose",
            [
                4294967295
            ]
        ],
        "134521283": [
            "getopt_long",
            [
                4294967295
            ]
        ],
        "134521295": [
            "syscall",
            [
                4294967295
            ]
        ],
        "134521303": [
            "munmap",
            [
                4294967295
            ]
        ],
        "134521310": [
            "fileno_unlocked",
            [
                4294967295
            ]
        ],
        "134521326": [
            "sched_getparam",
            [
                4294967295
            ]
        ],
        "134521341": [
            "mknod",
            [
                4294967295
            ]
        ],
        "134521347": [
            "ftello64",
            [
                4294967295
            ]
        ],
        "134521356": [
            "posix_fallocate64",
            [
                4294967295
            ]
        ],
        "134521374": [
            "getgrgid",
            [
                4294967295
            ]
        ],
        "134521383": [
            "statfs64",
            [
                4294967295
            ]
        ],
        "134521392": [
            "getenv",
            [
                4294967295
            ]
        ],
        "134521399": [
            "fchmod",
            [
                4294967295
            ]
        ],
        "134521406": [
            "getegid",
            [
                4294967295
            ]
        ],
        "134521414": [
            "setutxent",
            [
                4294967295
            ]
        ],
        "134521424": [
            "setpriority",
            [
                4294967295
            ]
        ],
        "134521436": [
            "getpriority",
            [
                4294967295
            ]
        ],
        "134521448": [
            "personality",
            [
                4294967295
            ]
        ],
        "134521460": [
            "__ns_parserr",
            [
                4294967295
            ]
        ],
        "134521473": [
            "getresuid",
            [
                4294967295
            ]
        ],
        "134521483": [
            "bsearch",
            [
                4294967295
            ]
        ],
        "134521491": [
            "usleep",
            [
                4294967295
            ]
        ],
        "134521498": [
            "execve",
            [
                4294967295
            ]
        ],
        "134521505": [
            "semget",
            [
                4294967295
            ]
        ],
        "134521512": [
            "getpid",
            [
                4294967295
            ]
        ],
        "134521519": [
            "getpagesize",
            [
                4294967295
            ]
        ],
        "134521531": [
            "lremovexattr",
            [
                4294967295
            ]
        ],
        "134521544": [
            "updwtmpx",
            [
                4294967295
            ]
        ],
        "134521553": [
            "qsort",
            [
                4294967295
            ]
        ],
        "134521559": [
            "fchown",
            [
                4294967295
            ]
        ],
        "134521566": [
            "fscanf",
            [
                4294967295
            ]
        ],
        "134521573": [
            "dirname",
            [
                4294967295
            ]
        ],
        "134521581": [
            "fcntl64",
            [
                4294967295
            ]
        ],
        "134521589": [
            "getrlimit64",
            [
                4294967295
            ]
        ],
        "134521601": [
            "prctl",
            [
                4294967295
            ]
        ],
        "134521607": [
            "fchdir",
            [
                4294967295
            ]
        ],
        "134521614": [
            "gnu_dev_major",
            [
                4294967295
            ]
        ],
        "134521628": [
            "setvbuf",
            [
                4294967295
            ]
        ],
        "134521636": [
            "execl",
            [
                4294967295
            ]
        ],
        "134521642": [
            "readlink",
            [
                4294967295
            ]
        ],
        "134521656": [
            "tcflush",
            [
                4294967295
            ]
        ],
        "134521664": [
            "execle",
            [
                4294967295
            ]
        ],
        "134521671": [
            "getuid",
            [
                4294967295
            ]
        ],
        "134521678": [
            "tcsendbreak",
            [
                4294967295
            ]
        ],
        "134521690": [
            "semctl",
            [
                4294967295
            ]
        ],
        "134521697": [
            "system",
            [
                4294967295
            ]
        ],
        "134521704": [
            "hasmntopt",
            [
                4294967295
            ]
        ],
        "134521714": [
            "malloc",
            [
                4294967295
            ]
        ],
        "134521721": [
            "isatty",
            [
                4294967295
            ]
        ],
        "134521728": [
            "cfgetispeed",
            [
                4294967295
            ]
        ],
        "134521740": [
            "siglongjmp",
            [
                4294967295
            ]
        ],
        "134521751": [
            "optarg",
            [
                4294967295
            ]
        ],
        "134521758": [
            "sched_setscheduler",
            [
                4294967295
            ]
        ],
        "134521777": [
            "sysinfo",
            [
                4294967295
            ]
        ],
        "134521785": [
            "strtoll",
            [
                4294967295
            ]
        ],
        "134521793": [
            "vsnprintf",
            [
                4294967295
            ]
        ],
        "134521803": [
            "recvfrom",
            [
                4294967295
            ]
        ],
        "134521812": [
            "tcdrain",
            [
                4294967295
            ]
        ],
        "134521820": [
            "pivot_root",
            [
                4294967295
            ]
        ],
        "134521831": [
            "strtoul",
            [
                4294967295
            ]
        ],
        "134521839": [
            "sched_getscheduler",
            [
                4294967295
            ]
        ],
        "134521858": [
            "endutxent",
            [
                4294967295
            ]
        ],
        "134521868": [
            "mktemp",
            [
                4294967295
            ]
        ],
        "134521875": [
            "settimeofday",
            [
                4294967295
            ]
        ],
        "134521888": [
            "opterr",
            [
                4294967295
            ]
        ],
        "134521895": [
            "rmdir",
            [
                4294967295
            ]
        ],
        "134521901": [
            "socket",
            [
                4294967295
            ]
        ],
        "134521908": [
            "select",
            [
                4294967295
            ]
        ],
        "134521915": [
            "lchown",
            [
                4294967295
            ]
        ],
        "134521922": [
            "setgroups",
            [
                4294967295
            ]
        ],
        "134521932": [
            "mempcpy",
            [
                4294967295
            ]
        ],
        "134521940": [
            "fflush",
            [
                4294967295
            ]
        ],
        "134521947": [
            "realpath",
            [
                4294967295
            ]
        ],
        "134521956": [
            "putenv",
            [
                4294967295
            ]
        ],
        "134521963": [
            "sigaddset",
            [
                4294967295
            ]
        ],
        "134521973": [
            "gnu_dev_minor",
            [
                4294967295
            ]
        ],
        "134521987": [
            "clearenv",
            [
                4294967295
            ]
        ],
        "134521996": [
            "strncasecmp",
            [
                4294967295
            ]
        ],
        "134522008": [
            "setpgid",
            [
                4294967295
            ]
        ],
        "134522016": [
            "freeaddrinfo",
            [
                4294967295
            ]
        ],
        "134522029": [
            "__fgetc_unlocked",
            [
                4294967295
            ]
        ],
        "134522046": [
            "utmpxname",
            [
                4294967295
            ]
        ],
        "134522056": [
            "gmtime_r",
            [
                4294967295
            ]
        ],
        "134522065": [
            "getnameinfo",
            [
                4294967295
            ]
        ],
        "134522077": [
            "fstat64",
            [
                4294967295
            ]
        ],
        "134522085": [
            "alarm",
            [
                4294967295
            ]
        ],
        "134522091": [
            "mlock",
            [
                4294967295
            ]
        ],
        "134522097": [
            "strtol",
            [
                4294967295
            ]
        ],
        "134522104": [
            "__sigsetjmp",
            [
                4294967295
            ]
        ],
        "134522121": [
            "ether_hostton",
            [
                4294967295
            ]
        ],
        "134522135": [
            "__ns_get16",
            [
                4294967295
            ]
        ],
        "134522146": [
            "strnlen",
            [
                4294967295
            ]
        ],
        "134522154": [
            "__res_mkquery",
            [
                4294967295
            ]
        ],
        "134522168": [
            "capget",
            [
                4294967295
            ]
        ],
        "134522175": [
            "uname",
            [
                4294967295
            ]
        ],
        "134522181": [
            "accept",
            [
                4294967295
            ]
        ],
        "134522188": [
            "cfsetispeed",
            [
                4294967295
            ]
        ],
        "134522200": [
            "rename",
            [
                4294967295
            ]
        ],
        "134522207": [
            "strrchr",
            [
                4294967295
            ]
        ],
        "134522215": [
            "nanosleep",
            [
                4294967295
            ]
        ],
        "134522225": [
            "strtod",
            [
                4294967295
            ]
        ],
        "134522232": [
            "statvfs64",
            [
                4294967295
            ]
        ],
        "134522247": [
            "fdatasync",
            [
                4294967295
            ]
        ],
        "134522262": [
            "fputs_unlocked",
            [
                4294967295
            ]
        ],
        "134522277": [
            "ctime",
            [
                4294967295
            ]
        ],
        "134522283": [
            "strcat",
            [
                4294967295
            ]
        ],
        "134522295": [
            "getmntent_r",
            [
                4294967295
            ]
        ],
        "134522307": [
            "inet_addr",
            [
                4294967295
            ]
        ],
        "134522317": [
            "vprintf",
            [
                4294967295
            ]
        ],
        "134522325": [
            "umount2",
            [
                4294967295
            ]
        ],
        "134522333": [
            "mkfifo",
            [
                4294967295
            ]
        ],
        "134522340": [
            "if_nametoindex",
            [
                4294967295
            ]
        ],
        "134522355": [
            "reboot",
            [
                4294967295
            ]
        ],
        "134522362": [
            "initgroups",
            [
                4294967295
            ]
        ],
        "134522373": [
            "setsockopt",
            [
                4294967295
            ]
        ],
        "134522384": [
            "endgrent",
            [
                4294967295
            ]
        ],
        "134522393": [
            "wait3",
            [
                4294967295
            ]
        ],
        "134522399": [
            "shmget",
            [
                4294967295
            ]
        ],
        "134522406": [
            "cfsetospeed",
            [
                4294967295
            ]
        ],
        "134522418": [
            "optind",
            [
                4294967295
            ]
        ],
        "134522425": [
            "memchr",
            [
                4294967295
            ]
        ],
        "134522432": [
            "swapoff",
            [
                4294967295
            ]
        ],
        "134522440": [
            "__stdin",
            [
                4294967295
            ]
        ],
        "134522448": [
            "umask",
            [
                4294967295
            ]
        ],
        "134522454": [
            "dprintf",
            [
                4294967295
            ]
        ],
        "134522462": [
            "mktime",
            [
                4294967295
            ]
        ],
        "134522469": [
            "timezone",
            [
                4294967295
            ]
        ],
        "134522478": [
            "strcasestr",
            [
                4294967295
            ]
        ],
        "134522489": [
            "strstr",
            [
                4294967295
            ]
        ],
        "134522496": [
            "getutxent",
            [
                4294967295
            ]
        ],
        "134522506": [
            "flock",
            [
                4294967295
            ]
        ],
        "134522512": [
            "setgid",
            [
                4294967295
            ]
        ],
        "134522519": [
            "openlog",
            [
                4294967295
            ]
        ],
        "134522527": [
            "pread64",
            [
                4294967295
            ]
        ],
        "134522535": [
            "sendmsg",
            [
                4294967295
            ]
        ],
        "134522543": [
            "closelog",
            [
                4294967295
            ]
        ],
        "134522552": [
            "strncmp",
            [
                4294967295
            ]
        ],
        "134522560": [
            "getusershell",
            [
                4294967295
            ]
        ],
        "134522573": [
            "sethostname",
            [
                4294967295
            ]
        ],
        "134522585": [
            "__cmsg_nxthdr",
            [
                4294967295
            ]
        ],
        "134522599": [
            "strncpy",
            [
                4294967295
            ]
        ],
        "134522607": [
            "unlink",
            [
                4294967295
            ]
        ],
        "134522614": [
            "freopen64",
            [
                4294967295
            ]
        ],
        "134522624": [
            "strcasecmp",
            [
                4294967295
            ]
        ],
        "134522635": [
            "sendto",
            [
                4294967295
            ]
        ],
        "134522642": [
            "sched_get_priority_max",
            [
                4294967295
            ]
        ],
        "134522665": [
            "__ns_get32",
            [
                4294967295
            ]
        ],
        "134522676": [
            "realloc",
            [
                4294967295
            ]
        ],
        "134522684": [
            "readdir64",
            [
                4294967295
            ]
        ],
        "134522694": [
            "strtok",
            [
                4294967295
            ]
        ],
        "134522701": [
            "memcmp",
            [
                4294967295
            ]
        ],
        "134522708": [
            "listen",
            [
                4294967295
            ]
        ],
        "134522715": [
            "sched_get_priority_min",
            [
                4294967295
            ]
        ],
        "134522738": [
            "fdopen",
            [
                4294967295
            ]
        ],
        "134522745": [
            "sscanf",
            [
                4294967295
            ]
        ],
        "134522752": [
            "execv",
            [
                4294967295
            ]
        ],
        "134522758": [
            "setmntent",
            [
                4294967295
            ]
        ],
        "134522768": [
            "lstat64",
            [
                4294967295
            ]
        ],
        "134522776": [
            "execlp",
            [
                4294967295
            ]
        ],
        "134522783": [
            "sigaction",
            [
                4294967295
            ]
        ],
        "134522793": [
            "__ns_name_uncompress",
            [
                4294967295
            ]
        ],
        "134522814": [
            "endmntent",
            [
                4294967295
            ]
        ],
        "134522824": [
            "killpg",
            [
                4294967295
            ]
        ],
        "134522831": [
            "fread",
            [
                4294967295
            ]
        ],
        "134522837": [
            "ttyname_r",
            [
                4294967295
            ]
        ],
        "134522847": [
            "__uClibc_main",
            [
                4294967295
            ]
        ],
        "134522861": [
            "getlogin_r",
            [
                4294967295
            ]
        ],
        "134522872": [
            "strdup",
            [
                4294967295
            ]
        ],
        "134522879": [
            "inet_aton",
            [
                4294967295
            ]
        ],
        "134522889": [
            "strtoull",
            [
                4294967295
            ]
        ],
        "134522898": [
            "regcomp",
            [
                4294967295
            ]
        ],
        "134522906": [
            "symlink",
            [
                4294967295
            ]
        ],
        "134522914": [
            "gettimeofday",
            [
                4294967295
            ]
        ],
        "134522927": [
            "getopt",
            [
                4294967295
            ]
        ],
        "134522934": [
            "localtime",
            [
                4294967295
            ]
        ],
        "134522944": [
            "fnmatch",
            [
                4294967295
            ]
        ],
        "134522952": [
            "cfmakeraw",
            [
                4294967295
            ]
        ],
        "134522962": [
            "srand",
            [
                4294967295
            ]
        ],
        "134522968": [
            "clearerr",
            [
                4294967295
            ]
        ],
        "134522977": [
            "mallopt",
            [
                4294967295
            ]
        ],
        "134522985": [
            "fclose",
            [
                4294967295
            ]
        ],
        "134522992": [
            "inet_ntoa",
            [
                4294967295
            ]
        ],
        "134523002": [
            "getppid",
            [
                4294967295
            ]
        ],
        "134523010": [
            "tcgetattr",
            [
                4294967295
            ]
        ],
        "134523020": [
            "getservbyport",
            [
                4294967295
            ]
        ],
        "134523034": [
            "regexec",
            [
                4294967295
            ]
        ],
        "134523042": [
            "opendir",
            [
                4294967295
            ]
        ],
        "134523050": [
            "getgroups",
            [
                4294967295
            ]
        ],
        "134523060": [
            "__ns_initparse",
            [
                4294967295
            ]
        ],
        "134523075": [
            "msgctl",
            [
                4294967295
            ]
        ],
        "134523087": [
            "sigtimedwait",
            [
                4294967295
            ]
        ],
        "134523100": [
            "getgrouplist",
            [
                4294967295
            ]
        ],
        "134523113": [
            "syslog",
            [
                4294967295
            ]
        ],
        "134523120": [
            "seteuid",
            [
                4294967295
            ]
        ],
        "134523128": [
            "getopt_long_only",
            [
                4294967295
            ]
        ],
        "134523145": [
            "mount",
            [
                4294967295
            ]
        ],
        "134523151": [
            "strcmp",
            [
                4294967295
            ]
        ],
        "134523158": [
            "getpwuid",
            [
                4294967295
            ]
        ],
        "134523167": [
            "__h_errno_location",
            [
                4294967295
            ]
        ],
        "134523186": [
            "swapon",
            [
                4294967295
            ]
        ],
        "134523193": [
            "getcwd",
            [
                4294967295
            ]
        ],
        "134523200": [
            "gethostbyname",
            [
                4294967295
            ]
        ],
        "134523214": [
            "strsignal",
            [
                4294967295
            ]
        ],
        "134523224": [
            "getpwnam",
            [
                4294967295
            ]
        ],
        "134523233": [
            "getservbyname",
            [
                4294967295
            ]
        ],
        "134523247": [
            "ether_aton_r",
            [
                4294967295
            ]
        ],
        "134523260": [
            "strcspn",
            [
                4294967295
            ]
        ],
        "134523268": [
            "cfsetspeed",
            [
                4294967295
            ]
        ],
        "134523279": [
            "regerror",
            [
                4294967295
            ]
        ],
        "134523288": [
            "stderr",
            [
                4294967295
            ]
        ],
        "134523295": [
            "mmap64",
            [
                4294967295
            ]
        ],
        "134523302": [
            "vfork",
            [
                4294967295
            ]
        ],
        "134523308": [
            "sched_getaffinity",
            [
                4294967295
            ]
        ],
        "134523326": [
            "strsep",
            [
                4294967295
            ]
        ],
        "134523333": [
            "fsync",
            [
                4294967295
            ]
        ],
        "134523339": [
            "hstrerror",
            [
                4294967295
            ]
        ],
        "134523349": [
            "localtime_r",
            [
                4294967295
            ]
        ],
        "134523361": [
            "getaddrinfo",
            [
                4294967295
            ]
        ],
        "134523373": [
            "strftime",
            [
                4294967295
            ]
        ],
        "134523382": [
            "sendfile64",
            [
                4294967295
            ]
        ],
        "134523393": [
            "mkdtemp",
            [
                4294967295
            ]
        ],
        "134523401": [
            "getmntent",
            [
                4294967295
            ]
        ],
        "134523411": [
            "fwrite",
            [
                4294967295
            ]
        ],
        "134523418": [
            "access",
            [
                4294967295
            ]
        ],
        "134523425": [
            "__stdout",
            [
                4294967295
            ]
        ],
        "134523434": [
            "strptime",
            [
                4294967295
            ]
        ],
        "134523443": [
            "tcgetpgrp",
            [
                4294967295
            ]
        ],
        "134523453": [
            "__errno_location",
            [
                4294967295
            ]
        ],
        "134523470": [
            "stime",
            [
                4294967295
            ]
        ],
        "134523476": [
            "klogctl",
            [
                4294967295
            ]
        ],
        "134523484": [
            "sigdelset",
            [
                4294967295
            ]
        ],
        "134523494": [
            "setbuf",
            [
                4294967295
            ]
        ],
        "134523501": [
            "inet_ntop",
            [
                4294967295
            ]
        ],
        "134523511": [
            "getresgid",
            [
                4294967295
            ]
        ],
        "134523521": [
            "getgrnam",
            [
                4294967295
            ]
        ],
        "134523530": [
            "gnu_dev_makedev",
            [
                4294967295
            ]
        ],
        "134523551": [
            "_setjmp",
            [
                4294967295
            ]
        ],
        "134523559": [
            "fgets_unlocked",
            [
                4294967295
            ]
        ],
        "134523574": [
            "getline",
            [
                4294967295
            ]
        ],
        "134523582": [
            "_exit",
            [
                4294967295
            ]
        ],
        "134523588": [
            "strverscmp",
            [
                4294967295
            ]
        ],
        "134523599": [
            "getpwent",
            [
                4294967295
            ]
        ],
        "134523608": [
            "strspn",
            [
                4294967295
            ]
        ],
        "134523615": [
            "munlock",
            [
                4294967295
            ]
        ],
        "134523623": [
            "strlen",
            [
                4294967295
            ]
        ],
        "134523630": [
            "lseek64",
            [
                4294967295
            ]
        ],
        "134523638": [
            "atoll",
            [
                4294967295
            ]
        ],
        "134523644": [
            "regfree",
            [
                4294967295
            ]
        ],
        "134523652": [
            "strchr",
            [
                4294967295
            ]
        ],
        "134523659": [
            "fputs",
            [
                4294967295
            ]
        ],
        "134523665": [
            "execvp",
            [
                4294967295
            ]
        ],
        "134523672": [
            "setsid",
            [
                4294967295
            ]
        ],
        "134523679": [
            "setegid",
            [
                4294967295
            ]
        ],
        "134523687": [
            "capset",
            [
                4294967295
            ]
        ],
        "134523694": [
            "closedir",
            [
                4294967295
            ]
        ],
        "134523703": [
            "vasprintf",
            [
                4294967295
            ]
        ],
        "134523713": [
            "recvmsg",
            [
                4294967295
            ]
        ],
        "134523721": [
            "strchrnul",
            [
                4294967295
            ]
        ],
        "134523731": [
            "tzset",
            [
                4294967295
            ]
        ],
        "134523737": [
            "sched_yield",
            [
                4294967295
            ]
        ],
        "134523749": [
            "setuid",
            [
                4294967295
            ]
        ],
        "134523756": [
            "gethostid",
            [
                4294967295
            ]
        ],
        "134523766": [
            "fseeko64",
            [
                4294967295
            ]
        ],
        "134523775": [
            "tcsetattr",
            [
                4294967295
            ]
        ],
        "134523785": [
            "mkdir",
            [
                4294967295
            ]
        ],
        "134523791": [
            "msgget",
            [
                4294967295
            ]
        ],
        "134523798": [
            "vfprintf",
            [
                4294967295
            ]
        ],
        "134523807": [
            "strpbrk",
            [
                4294967295
            ]
        ],
        "134523815": [
            "tcsetpgrp",
            [
                4294967295
            ]
        ],
        "134523825": [
            "sigsuspend",
            [
                4294967295
            ]
        ],
        "134523836": [
            "raise",
            [
                4294967295
            ]
        ],
        "134523842": [
            "sigprocmask",
            [
                4294967295
            ]
        ],
        "134523854": [
            "__fputc_unlocked",
            [
                4294967295
            ]
        ],
        "134523871": [
            "getsockname",
            [
                4294967295
            ]
        ],
        "134523883": [
            "fopen64",
            [
                4294967295
            ]
        ],
        "134523891": [
            "ftruncate64",
            [
                4294967295
            ]
        ],
        "134523903": [
            "__environ",
            [
                4294967295
            ]
        ],
        "134523913": [
            "_edata",
            [
                4294967295
            ]
        ],
        "134523920": [
            "__bss_start",
            [
                4294967295
            ]
        ],
        "134961039": [
            "\bdiscard",
            []
        ],
        "134961055": [
            "\bchargen",
            []
        ],
        "134961071": [
            "\btime",
            []
        ],
        "134961087": [
            "\bdaytime",
            []
        ],
        "134961761": [
            "CNAME",
            []
        ],
        "134962173": [
            "(!)1*!,\u00073",
            []
        ],
        "134962262": [
            "group",
            []
        ],
        "134962301": [
            "\bargs",
            []
        ],
        "134963278": [
            "\r\b\b\nl",
            []
        ],
        "134963302": [
            "\r\b\t\nv",
            []
        ],
        "134963316": [
            "h?\r\b\r",
            []
        ],
        "134963712": [
            "SCHED_OTHER",
            []
        ],
        "134963724": [
            "SCHED_FIFO",
            []
        ],
        "134963736": [
            "SCHED_RR",
            []
        ],
        "134963748": [
            "SCHED_BATCH",
            []
        ],
        "134963772": [
            "SCHED_IDLE",
            []
        ],
        "134963874": [
            "accel",
            []
        ],
        "134963885": [
            "hsync",
            []
        ],
        "134963896": [
            "vsync",
            []
        ],
        "134963906": [
            "\u0007laced",
            []
        ],
        "134963917": [
            "\bdouble",
            []
        ],
        "134963928": [
            "\tshow",
            []
        ],
        "134963961": [
            "\u000bxres",
            []
        ],
        "134963972": [
            "dyres",
            []
        ],
        "134963983": [
            "evxres",
            []
        ],
        "134963994": [
            "fvyres",
            []
        ],
        "134964005": [
            "gdepth",
            []
        ],
        "134964016": [
            "hmatch",
            []
        ],
        "134964027": [
            "igeometry",
            []
        ],
        "134964039": [
            "pixclock",
            []
        ],
        "134964049": [
            "jleft",
            []
        ],
        "134964060": [
            "kright",
            []
        ],
        "134964071": [
            "lupper",
            []
        ],
        "134964082": [
            "mlower",
            []
        ],
        "134964093": [
            "nhslen",
            []
        ],
        "134964104": [
            "ovslen",
            []
        ],
        "134964115": [
            "ptimings",
            []
        ],
        "134964127": [
            "csync",
            []
        ],
        "134964137": [
            "qgsync",
            []
        ],
        "134964148": [
            "rextsync",
            []
        ],
        "134964159": [
            "sbcast",
            []
        ],
        "134964170": [
            "trgba",
            []
        ],
        "134964181": [
            "ustep",
            []
        ],
        "134964192": [
            "vmove",
            []
        ],
        "134964640": [
            "/etc/filesystems",
            [
                134750929
            ]
        ],
        "134964658": [
            "/proc/filesystems",
            []
        ],
        "134964896": [
            "0000000",
            [
                134775172
            ]
        ],
        "134964904": [
            "0000000",
            []
        ],
        "134964912": [
            "0000000",
            []
        ],
        "134964920": [
            "00000000000",
            []
        ],
        "134964932": [
            "00000000000",
            []
        ],
        "134964960": [
            " %%%u%s",
            []
        ],
        "134964969": [
            " %%0%u%s",
            []
        ],
        "134964978": [
            " %%%u%s",
            []
        ],
        "134964987": [
            " %%0%u%s",
            []
        ],
        "134966145": [
            " \u0007%+&",
            []
        ],
        "134967085": [
            "D7q/;M",
            []
        ],
        "134967338": [
            "&\\8!\u001b.",
            []
        ],
        "134967466": [
            "AQ\bl7",
            []
        ],
        "134967974": [
            "\t:Ar(",
            []
        ],
        "134968159": [
            "(3-!0,1'8\"5.*2$",
            []
        ],
        "134968208": [
            ";3+#\u001b",
            []
        ],
        "134968216": [
            "<4,$?7/'",
            []
        ],
        "134968227": [
            "\u0007>6.&",
            []
        ],
        "134968280": [
            "@80( ",
            []
        ],
        "134968287": [
            "\b91)!",
            []
        ],
        "134968296": [
            ";3+#\u001b",
            []
        ],
        "134971182": [
            "   @@@",
            []
        ],
        "134972518": [
            "!CgE#",
            []
        ],
        "134972996": [
            " multi-call binary.\n",
            [
                134532546,
                134532882
            ]
        ],
        "134973017": [
            "\nNo help available.\n\n",
            [
                134532546
            ]
        ],
        "134973039": [
            "\nUsage: ",
            [
                134532546
            ]
        ],
        "134973048": [
            "--help",
            [
                134532882,
                134532684
            ]
        ],
        "134973055": [
            "must be suid to work properly",
            [
                134532684
            ]
        ],
        "134973085": [
            "busybox",
            [
                134532882,
                134625655,
                134533551
            ]
        ],
        "134973093": [
            "BusyBox is copyrighted by many authors between 1998-2015.\nLicensed under GPLv2. See source distribution for detailed\ncopyright notices.\n\nUsage: busybox [function [arguments]...]\n   or: busybox --list[-full]\n   or: busybox --install [-s] [DIR]\n   or: function [arguments]...\n\n\tBusyBox is a multi-call binary that combines many common Unix\n\tutilities into a single executable.  Most people will create a\n\tlink to busybox for each function they wish to use and BusyBox\n\twill act like whatever it was invoked as.\n\nCurrently defined functions:\n",
            [
                134532882
            ]
        ],
        "134973636": [
            "--list",
            [
                134532882
            ]
        ],
        "134973643": [
            "--install",
            [
                134532882
            ]
        ],
        "134973653": [
            "'%s' is not an absolute path",
            [
                134532882
            ]
        ],
        "134973685": [
            ": applet not found\n",
            [
                134532882
            ]
        ],
        "134973709": [
            "/sbin/",
            [
                4294967295
            ]
        ],
        "134973716": [
            "/usr/bin",
            [
                4294967295
            ]
        ],
        "134973730": [
            "[-g GID] [-S] GROUP\n\nAdd a group\n\n\t-g GID\tGroup id\n\t-S\tCreate a system group",
            []
        ],
        "134973807": [
            "[OPTIONS] USER [GROUP]\n\nCreate new user, or add USER to GROUP\n\n\t-h DIR\t\tHome directory\n\t-g GECOS\tGECOS field\n\t-s SHELL\tLogin shell\n\t-G GRP\t\tGroup\n\t-S\t\tCreate a system user\n\t-D\t\tDon't assign a password\n\t-H\t\tDon't create home directory\n\t-u UID\t\tUser id\n\t-k SKEL\t\tSkeleton directory (/etc/skel)",
            []
        ],
        "134974099": [
            "[-o] [-v] [-p] [-t] [-x] ARCHIVE FILES\n\nExtract or list FILES from an ar archive\n\n\t-o\tPreserve original dates\n\t-p\tExtract to stdout\n\t-t\tList\n\t-x\tExtract\n\t-v\tVerbose",
            []
        ],
        "134974264": [
            "\n\nPrint system architecture",
            []
        ],
        "134974292": [
            "\n[-vn]\t[-H HWTYPE] [-i IF] -a [HOSTNAME]\n[-v]\t\t    [-i IF] -d HOSTNAME [pub]\n[-v]\t[-H HWTYPE] [-i IF] -s HOSTNAME HWADDR [temp]\n[-v]\t[-H HWTYPE] [-i IF] -s HOSTNAME HWADDR [netmask MASK] pub\n[-v]\t[-H HWTYPE] [-i IF] -Ds HOSTNAME IFACE [netmask MASK] pub\n\nManipulate ARP cache\n\n\t-a\t\tDisplay (all) hosts\n\t-d\t\tDelete ARP entry\n\t-s\t\tSet new entry\n\t-v\t\tVerbose\n\t-n\t\tDon't resolve names\n\t-i IF\t\tNetwork interface\n\t-D\t\tRead HWADDR from IFACE\n\t-A,-p AF\tProtocol family\n\t-H HWTYPE\tHardware address type",
            []
        ],
        "134974786": [
            "[-fqbDUA] [-c CNT] [-w TIMEOUT] [-I IFACE] [-s SRC_IP] DST_IP\n\nSend ARP requests/replies\n\n\t-f\t\tQuit on first ARP reply\n\t-q\t\tQuiet\n\t-b\t\tKeep broadcasting, don't go unicast\n\t-D\t\tExit with 1 if DST_IP replies\n\t-U\t\tUnsolicited ARP mode, update your neighbors\n\t-A\t\tARP answer mode, update your neighbors\n\t-c N\t\tStop after sending N ARP requests\n\t-w TIMEOUT\tSeconds to wait for ARP reply\n\t-I IFACE\tInterface to use (default eth0)\n\t-s SRC_IP\tSender IP address\n\tDST_IP\t\tTarget IP address",
            []
        ],
        "134975266": [
            "[-/+OPTIONS] [-/+o OPT]... [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS] / -s [ARGS]]\n\nUnix shell interpreter",
            []
        ],
        "134975371": [
            "[OPTIONS] [AWK_PROGRAM] [FILE]...\n\n\t-v VAR=VAL\tSet variable\n\t-F SEP\t\tUse SEP as field separator\n\t-f FILE\t\tRead program from FILE\n\t-e AWK_PROGRAM",
            []
        ],
        "134975516": [
            "FILE [SUFFIX]\n\nStrip directory path and .SUFFIX from FILE",
            []
        ],
        "134975574": [
            "[BLOCKDEV]...\n\nPrint UUIDs of all filesystems",
            []
        ],
        "134975620": [
            "[-cfk] [FILE]...\n\nDecompress FILEs (or stdin)\n\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files",
            []
        ],
        "134975718": [
            "[FILE]...\n\nDecompress to stdout",
            []
        ],
        "134975750": [
            "[-nbvteA] [FILE]...\n\nPrint FILEs to stdout\n\n\t-n\tNumber output lines\n\t-b\tNumber nonempty lines\n\t-v\tShow nonprinting characters as ^x or M-x\n\t-t\t...and tabs as ^I\n\t-e\t...and end lines with $\n\t-A\tSame as -vte",
            []
        ],
        "134975956": [
            "[-R] [-v VERSION] [-+=AacDdijsStTu] FILE...\n\nChange ext2 file attributes\n\n\t-R\tRecurse\n\t-v VER\tSet version/generation number\nModifiers:\n\t-,+,=\tRemove/add/set attributes\nAttributes:\n\tA\tDon't track atime\n\ta\tAppend mode only\n\tc\tEnable compress\n\tD\tWrite dir contents synchronously\n\td\tDon't backup with dump\n\ti\tCannot be modified (immutable)\n\tj\tWrite all data to journal first\n\ts\tZero disk storage when deleted\n\tS\tWrite synchronously\n\tt\tDisable tail-merging of partial blocks with other files\n\tu\tAllow file to be undeleted",
            []
        ],
        "134976473": [
            "[-RhLHPcvf]... GROUP FILE...\n\nChange the group membership of each FILE to GROUP\n\n\t-R\tRecurse\n\t-h\tAffect symlinks instead of symlink targets\n\t-L\tTraverse all symlinks to directories\n\t-H\tTraverse symlinks on command line only\n\t-P\tDon't traverse symlinks (default)\n\t-c\tList changed files\n\t-v\tVerbose\n\t-f\tHide errors",
            []
        ],
        "134976786": [
            "[-Rcvf] MODE[,MODE]... FILE...\n\nEach MODE is one or more of the letters ugoa, one of the\nsymbols +-= and one or more of the letters rwxst\n\n\t-R\tRecurse\n\t-c\tList changed files\n\t-v\tList all files\n\t-f\tHide errors",
            []
        ],
        "134976995": [
            "[-RhLHPcvf]... USER[:[GRP]] FILE...\n\nChange the owner and/or group of each FILE to USER and/or GRP\n\n\t-R\tRecurse\n\t-h\tAffect symlinks instead of symlink targets\n\t-L\tTraverse all symlinks to directories\n\t-H\tTraverse symlinks on command line only\n\t-P\tDon't traverse symlinks (default)\n\t-c\tList changed files\n\t-v\tList all files\n\t-f\tHide errors",
            []
        ],
        "134977334": [
            "NEWROOT [PROG ARGS]\n\nRun PROG with root directory set to NEWROOT",
            []
        ],
        "134977399": [
            "[-prfombi] [PRIO] [PID | PROG ARGS]\n\nChange scheduling priority and class for a process\n\n\t-p\tOperate on PID\n\t-r\tSet SCHED_RR class\n\t-f\tSet SCHED_FIFO class\n\t-o\tSet SCHED_OTHER class\n\t-b\tSet SCHED_BATCH class\n\t-i\tSet SCHED_IDLE class\n\t-m\tShow min/max priorities",
            []
        ],
        "134977660": [
            "N\n\nChange the foreground virtual terminal to /dev/ttyN",
            []
        ],
        "134977715": [
            "FILE...\n\nCalculate the CRC32 checksums of FILEs",
            []
        ],
        "134977763": [
            "\n\nClear screen",
            []
        ],
        "134977778": [
            "[-l] [-s] FILE1 [FILE2 [SKIP1 [SKIP2]]]\n\nCompare FILE1 with FILE2 (or stdin)\n\n\t-l\tWrite the byte numbers (decimal) and values (octal)\n\t\tfor all differing bytes\n\t-s\tQuiet",
            []
        ],
        "134977948": [
            "[OPTIONS] SOURCE... DEST\n\nCopy SOURCE(s) to DEST\n\n\t-a\tSame as -dpR\n\t-R,-r\tRecurse\n\t-d,-P\tPreserve symlinks (default if -R)\n\t-L\tFollow all symlinks\n\t-H\tFollow symlinks on command line\n\t-p\tPreserve file attributes if possible\n\t-f\tOverwrite\n\t-i\tPrompt before overwrite\n\t-l,-s\tCreate (sym)links\n\t-T\tTreat DEST as a normal file\n\t-u\tCopy only newer files",
            []
        ],
        "134978297": [
            "[-dmvu] [-F FILE] [-R USER[:GRP]] [-ti] [EXTR_FILE]...\n\nExtract (-i) or list (-t) files from a cpio archive\n\nMain operation mode:\n\t-t\tList\n\t-i\tExtract EXTR_FILEs (or all)\nOptions:\n\t-d\tMake leading directories\n\t-m\tPreserve mtime\n\t-v\tVerbose\n\t-u\tOverwrite\n\t-F FILE\tInput (-t,-i,-p) or output (-o) file\n\t-R USER[:GRP]\tSet owner of created files",
            []
        ],
        "134978639": [
            "-fbS -l N -L LOGFILE -c DIR\n\n\t-f\tForeground\n\t-b\tBackground (default)\n\t-S\tLog to syslog (default)\n\t-l N\tSet log level. Most verbose 0, default 8\n\t-L FILE\tLog to FILE\n\t-c DIR\tCron dir. Default:/var/spool/cron/crontabs",
            []
        ],
        "134978855": [
            "[-c DIR] [-u USER] [-ler]|[FILE]\n\n\t-c\tCrontab directory\n\t-u\tUser\n\t-l\tList crontab\n\t-e\tEdit crontab\n\t-r\tDelete crontab\n\tFILE\tReplace crontab by FILE ('-': stdin)",
            []
        ],
        "134979016": [
            "[OPTIONS] [FILE]...\n\nPrint selected fields from each input FILE to stdout\n\n\t-b LIST\tOutput only bytes from LIST\n\t-c LIST\tOutput only characters from LIST\n\t-d CHAR\tUse CHAR instead of tab as the field delimiter\n\t-s\tOutput only the lines containing delimiter\n\t-f N\tPrint only these fields\n\t-n\tIgnored",
            []
        ],
        "134979315": [
            "[OPTIONS] [+FMT] [TIME]\n\nDisplay time (using +FMT), or set time\n\n\t[-s,--set] TIME\tSet time to TIME\n\t-u,--utc\tWork in UTC (don't convert to local time)\n\t-R,--rfc-2822\tOutput RFC-2822 compliant date string\n\t-I[SPEC]\tOutput ISO-8601 compliant date string\n\t\t\tSPEC='date' (default) for date only,\n\t\t\t'hours', 'minutes', or 'seconds' for date and\n\t\t\ttime to the indicated precision\n\t-r,--reference FILE\tDisplay last modification time of FILE\n\t-d,--date TIME\tDisplay TIME, not 'now'\n\t-D FMT\t\tUse FMT for -d TIME conversion\n\nRecognized TIME formats:\n\thh:mm[:ss]\n\t[YYYY.]MM.DD-hh:mm[:ss]\n\tYYYY-MM-DD hh:mm[:ss]\n\t[[[[[YY]YY]MM]DD]hh]mm[.ss]\n\t'date TIME' form accepts MMDDhhmm[[YY]YY][.ss] instead",
            []
        ],
        "134980002": [
            "EXPRESSION...\n\nTiny RPN calculator. Operations:\n+, add, -, sub, *, mul, /, div, %, mod, and, or, not, xor,\np - print top of the stack (without popping),\nf - print entire stack,\no - pop the value and set output radix (must be 10, 16, 8 or 2).\nExamples: 'dc 2 2 add p' -> 4, 'dc 8 8 mul 2 2 + / p' -> 16",
            []
        ],
        "134980304": [
            "[if=FILE] [of=FILE] [ibs=N] [obs=N] [bs=N] [count=N] [skip=N]\n\t[seek=N] [conv=notrunc|noerror|sync|fsync] [iflag=skip_bytes|fullblock]\n\nCopy a file with converting and formatting\n\n\tif=FILE\t\tRead from FILE instead of stdin\n\tof=FILE\t\tWrite to FILE instead of stdout\n\tbs=N\t\tRead and write N bytes at a time\n\tibs=N\t\tRead N bytes at a time\n\tobs=N\t\tWrite N bytes at a time\n\tcount=N\t\tCopy only N input blocks\n\tskip=N\t\tSkip N input blocks\n\tseek=N\t\tSkip N output blocks\n\tconv=notrunc\tDon't truncate output file\n\tconv=noerror\tContinue after read errors\n\tconv=sync\tPad blocks with zeros\n\tconv=fsync\tPhysically write data out before finishing\n\tconv=swab\tSwap every pair of bytes\n\tiflag=skip_bytes\tskip=N is in bytes\n\tiflag=fullblock\tRead full blocks\n\tstatus=noxfer\tSuppress rate output\n\tstatus=none\tSuppress all output\n\nN may be suffixed by c (1), w (2), b (512), kB (1000), k (1024), MB, M, GB, G",
            []
        ],
        "134981190": [
            "[N]\n\nDeallocate unused virtual terminal /dev/ttyN",
            []
        ],
        "134981240": [
            "GROUP\n\nDelete group GROUP from the system",
            []
        ],
        "134981282": [
            "[--remove-home] USER\n\nDelete USER from the system",
            []
        ],
        "134981332": [
            "ADDRESS [WIDTH [VALUE]]\n\nRead/write from physical address\n\n\tADDRESS\tAddress to act upon\n\tWIDTH\tWidth (8/16/...)\n\tVALUE\tData to be written",
            []
        ],
        "134981470": [
            "[-PkmhT] [FILESYSTEM]...\n\nPrint filesystem usage statistics\n\n\t-P\tPOSIX output format\n\t-k\t1024-byte blocks (default)\n\t-m\t1M-byte blocks\n\t-h\tHuman readable (e.g. 1K 243M 2G)\n\t-T\tPrint filesystem type",
            []
        ],
        "134981668": [
            "[-abBdiNqrTstw] [-L LABEL] [-S FILE] [-U LINES] FILE1 FILE2\n\nCompare files line by line and output the differences between them.\nThis implementation supports unified diffs only.\n\n\t-a\tTreat all files as text\n\t-b\tIgnore changes in the amount of whitespace\n\t-B\tIgnore changes whose lines are all blank\n\t-d\tTry hard to find a smaller set of changes\n\t-i\tIgnore case differences\n\t-L\tUse LABEL instead of the filename in the unified header\n\t-N\tTreat absent files as empty\n\t-q\tOutput only whether files differ\n\t-r\tRecurse\n\t-S\tStart with FILE when comparing directories\n\t-T\tMake tabs line up by prefixing a tab when necessary\n\t-s\tReport when two files are the same\n\t-t\tExpand tabs to spaces in output\n\t-U\tOutput LINES lines of context\n\t-w\tIgnore all whitespace",
            []
        ],
        "134982420": [
            "FILENAME\n\nStrip non-directory suffix from FILENAME",
            []
        ],
        "134982471": [
            "[-c] [-n LEVEL] [-s SIZE]\n\nPrint or control the kernel ring buffer\n\n\t-c\t\tClear ring buffer after printing\n\t-n LEVEL\tSet console logging level\n\t-s SIZE\t\tBuffer size\n\t-r\t\tPrint raw message buffer",
            []
        ],
        "134982665": [
            "[-dvs] [-c CONFFILE] [-t TTL_SEC] [-p PORT] [-i ADDR]\n\nSmall static DNS server daemon\n\n\t-c FILE\tConfig file\n\t-t SEC\tTTL\n\t-p PORT\tListen on PORT\n\t-i ADDR\tListen on ADDR\n\t-d\tDaemonize\n\t-v\tVerbose\n\t-s\tSend successful replies only. Use this if you want\n\t\tto use /etc/resolv.conf with two nameserver lines:\n\t\t\tnameserver DNSD_SERVER\n\t\t\tnameserver NORMAL_DNS_SERVER",
            []
        ],
        "134983027": [
            "[-ud] [FILE]\n\nConvert FILE in-place from DOS to Unix format.\nWhen no file is given, use stdin/stdout.\n\n\t-u\tdos2unix\n\t-d\tunix2dos",
            []
        ],
        "134983156": [
            "[-aHLdclsxhmk] [FILE]...\n\nSummarize disk space used for each FILE and/or directory\n\n\t-a\tShow file sizes too\n\t-L\tFollow all symlinks\n\t-H\tFollow symlinks on command line\n\t-d N\tLimit output to directories (and files with -a) of depth < N\n\t-c\tShow grand total\n\t-l\tCount sizes many times if hard linked\n\t-s\tDisplay only a total for each argument\n\t-x\tSkip directories on different filesystems\n\t-h\tSizes in human readable format (e.g., 1K 243M 2G)\n\t-m\tSizes in megabytes\n\t-k\tSizes in kilobytes (default)",
            []
        ],
        "134983653": [
            "> keymap\n\nPrint a binary keyboard translation table to stdout",
            []
        ],
        "134983715": [
            "[-neE] [ARG]...\n\nPrint the specified ARGs to stdout\n\n\t-n\tSuppress trailing newline\n\t-e\tInterpret backslash escapes (i.e., \\t=tab)\n\t-E\tDon't interpret backslash escapes (default)",
            []
        ],
        "134983895": [
            "[-t] [-T] [DEVICE]\n\nEject DEVICE or default /dev/cdrom\n\n\t-t\tClose tray\n\t-T\tOpen/close tray (toggle)",
            []
        ],
        "134983995": [
            "[-iu] [-] [name=value]... [PROG ARGS]\n\nPrint the current environment or run PROG after setting up\nthe specified environment\n\n\t-, -i\tStart with an empty environment\n\t-u\tRemove variable from the environment",
            []
        ],
        "134984200": [
            "[-b] [-i IFACE] [-p aa:bb:cc:dd[:ee:ff]/a.b.c.d] MAC\n\nSend a magic packet to wake up sleeping machines.\nMAC must be a station address (00:11:22:33:44:55) or\na hostname with a known 'ethers' entry.\n\n\t-b\t\tBroadcast the packet\n\t-i IFACE\tInterface to use (default eth0)\n\t-p PASSWORD\tAppend four or six byte PASSWORD to the packet",
            []
        ],
        "134984526": [
            "EXPRESSION\n\nPrint the value of EXPRESSION to stdout\n\nEXPRESSION may be:\n\tARG1 | ARG2\tARG1 if it is neither null nor 0, otherwise ARG2\n\tARG1 & ARG2\tARG1 if neither argument is null or 0, otherwise 0\n\tARG1 < ARG2\t1 if ARG1 is less than ARG2, else 0. Similarly:\n\tARG1 <= ARG2\n\tARG1 = ARG2\n\tARG1 != ARG2\n\tARG1 >= ARG2\n\tARG1 > ARG2\n\tARG1 + ARG2\tSum of ARG1 and ARG2. Similarly:\n\tARG1 - ARG2\n\tARG1 * ARG2\n\tARG1 / ARG2\n\tARG1 % ARG2\n\tSTRING : REGEXP\t\tAnchored pattern match of REGEXP in STRING\n\tmatch STRING REGEXP\tSame as STRING : REGEXP\n\tsubstr STRING POS LENGTH Substring of STRING, POS counted from 1\n\tindex STRING CHARS\tIndex in STRING where any CHARS is found, or 0\n\tlength STRING\t\tLength of STRING\n\tquote TOKEN\t\tInterpret TOKEN as a string, even if\n\t\t\t\tit is a keyword like 'match' or an\n\t\t\t\toperator like '/'\n\t(EXPRESSION)\t\tValue of EXPRESSION\n\nBeware that many operators need to be escaped or quoted for shells.\nComparisons are arithmetic if both ARGs are numbers, else\nlexicographical. Pattern matches return the string matched between\n\\( and \\) or null; if \\( and \\) are not used, they return the number\nof characters matched or 0.",
            []
        ],
        "134985661": [
            "[NUMBER]...\n\nPrint prime factors",
            []
        ],
        "134985694": [
            "[-o OFS] -l LEN FILE\n\nPreallocate space for FILE\n\n\t-o OFS\tOffset of range\n\t-l LEN\tLength of range",
            []
        ],
        "134985794": [
            "[OPTIONS] [MODE]\n\nShow and modify frame buffer settings",
            []
        ],
        "134985850": [
            "DEVICE\n\nForce floppy disk drive to detect disk change",
            []
        ],
        "134985904": [
            "[-n] DEVICE\n\nFormat floppy disk\n\n\t-n\tDon't verify after format",
            []
        ],
        "134985967": [
            "[-ul] [-C CYLINDERS] [-H HEADS] [-S SECTORS] [-b SSZ] DISK\n\nChange partition table\n\n\t-u\t\tStart and End are in sectors (instead of cylinders)\n\t-l\t\tShow partition table for each DISK, then exit\n\t-b 2048\t\t(for certain MO disks) use 2048-byte sectors\n\t-C CYLINDERS\tSet number of cylinders/heads/sectors\n\t-H HEADS\tTypically 255\n\t-S SECTORS\tTypically 63",
            []
        ],
        "134986317": [
            "[-HL] [PATH]... [OPTIONS] [ACTIONS]\n\nSearch for files and perform actions on them.\nFirst failed action stops processing of current file.\nDefaults: PATH is current directory, action is '-print'\n\n\t-L,-follow\tFollow symlinks\n\t-H\t\t...on command line only\n\t-xdev\t\tDon't descend directories on other filesystems\n\t-maxdepth N\tDescend at most N levels. -maxdepth 0 applies\n\t\t\tactions to command line arguments only\n\t-mindepth N\tDon't act on first N levels\n\t-depth\t\tAct on directory *after* traversing it\n\nActions:\n\t( ACTIONS )\tGroup actions for -o / -a\n\t! ACT\t\tInvert ACT's success/failure\n\tACT1 [-a] ACT2\tIf ACT1 fails, stop, else do ACT2\n\tACT1 -o ACT2\tIf ACT1 succeeds, stop, else do ACT2\n\t\t\tNote: -a has higher priority than -o\n\t-name PATTERN\tMatch file name (w/o directory name) to PATTERN\n\t-iname PATTERN\tCase insensitive -name\n\t-path PATTERN\tMatch path to PATTERN\n\t-ipath PATTERN\tCase insensitive -path\n\t-regex PATTERN\tMatch path to regex PATTERN\n\t-type X\t\tFile type is X (one of: f,d,l,b,c,s,p)\n\t-perm MASK\tAt least one mask bit (+MASK), all bits (-MASK),\n\t\t\tor exactly MASK bits are set in file's mode\n\t-mtime DAYS\tmtime is greater than (+N), less than (-N),\n\t\t\tor exactly N days in the past\n\t-mmin MINS\tmtime is greater than (+N), less than (-N),\n\t\t\tor exactly N minutes in the past\n\t-newer FILE\tmtime is more recent than FILE's\n\t-user NAME/ID\tFile is owned by given user\n\t-group NAME/ID\tFile is owned by given group\n\t-size N[bck]\tFile size is N (c:bytes,k:kbytes,b:512 bytes(def.))\n\t\t\t+/-N: file size is bigger/smaller than N\n\t-prune\t\tIf current file is directory, don't descend into it\nIf none of the following actions is specified, -print is assumed\n\t-print\t\tPrint file name\n\t-print0\t\tPrint file name, NUL terminated\n\t-exec CMD ARG ;\tRun CMD with all instances of {} replaced by\n\t\t\tfile name. Fails if CMD exits with nonzero\n\t-exec CMD ARG + Run CMD with {} replaced by list of file names",
            []
        ],
        "134988210": [
            "[-sxun] FD|{FILE [-c] PROG ARGS}\n\n[Un]lock file descriptor, or lock FILE, run PROG\n\n\t-s\tShared lock\n\t-x\tExclusive lock (default)\n\t-u\tUnlock FD\n\t-n\tFail rather than wait",
            []
        ],
        "134988379": [
            "[-bs] [-w WIDTH] [FILE]...\n\nWrap input lines in each FILE (or stdin), writing to stdout\n\n\t-b\tCount bytes rather than columns\n\t-s\tBreak at spaces\n\t-w\tUse WIDTH columns instead of 80",
            []
        ],
        "134988560": [
            "[-b/k/m/g]\n\nDisplay the amount of free and used system memory",
            []
        ],
        "134988622": [
            "DEVICE\n\nFree all memory used by the specified ramdisk",
            []
        ],
        "134988676": [
            "[-ANPRTV] [-t FSTYPE] [FS_OPTS] [BLOCKDEV]...\n\nCheck and repair filesystems\n\n\t-A\tWalk /etc/fstab and check all filesystems\n\t-N\tDon't execute, just show what would be done\n\t-P\tWith -A, check filesystems in parallel\n\t-R\tWith -A, skip the root filesystem\n\t-T\tDon't show title on startup\n\t-V\tVerbose\n\t-t TYPE\tList of filesystem types to check",
            []
        ],
        "134989015": [
            "--[un]freeze MOUNTPOINT\n\nFlush and halt writes to MOUNTPOINT",
            []
        ],
        "134989076": [
            "[OPTIONS] MOUNTPOINT\n\n\t-o,--offset OFFSET\tOffset in bytes to discard from\n\t-l,--length LEN\t\tBytes to discard\n\t-m,--minimum MIN\tMinimum extent length\n\t-v,--verbose\t\tPrint number of discarded bytes",
            []
        ],
        "134989272": [
            "[OPTIONS] FILE or PORT/PROTO\n\nFind processes which use FILEs or PORTs\n\n\t-m\tFind processes which use same fs as FILEs\n\t-4,-6\tSearch only IPv4/IPv6 space\n\t-s\tDon't display PIDs\n\t-k\tKill found processes\n\t-SIGNAL\tSignal to send (default: KILL)",
            []
        ],
        "134989512": [
            "[OPTIONS] [--] OPTSTRING PARAMS\n\n\t-a\t\tAllow long options starting with single -\n\t-l LOPT[,...]\tLong options to recognize\n\t-n PROGNAME\tThe name under which errors are reported\n\t-o OPTSTRING\tShort options to recognize\n\t-q\t\tNo error messages on unrecognized options\n\t-Q\t\tNo normal output\n\t-s SHELL\tSet shell quoting conventions\n\t-T\t\tVersion test (exits with 4)\n\t-u\t\tDon't quote output\n\nExample:\n\nO=`getopt -l bb: -- ab:c:: \"$@\"` || exit 1\neval set -- \"$O\"\nwhile true; do\n\tcase \"$1\" in\n\t-a)\techo A; shift;;\n\t-b|--bb) echo \"B:'$2'\"; shift 2;;\n\t-c)\tcase \"$2\" in\n\t\t\"\")\techo C; shift 2;;\n\t\t*)\techo \"C:'$2'\"; shift 2;;\n\t\tesac;;\n\t--)\tshift; break;;\n\t*)\techo Error; exit 1;;\n\tesac\ndone",
            []
        ],
        "134990187": [
            "[OPTIONS] BAUD_RATE[,BAUD_RATE]... TTY [TERMTYPE]\n\nOpen TTY, prompt for login name, then invoke /bin/login\n\n\t-h\t\tEnable hardware RTS/CTS flow control\n\t-L\t\tSet CLOCAL (ignore Carrier Detect state)\n\t-m\t\tGet baud rate from modem's CONNECT status message\n\t-n\t\tDon't prompt for login name\n\t-w\t\tWait for CR or LF before sending /etc/issue\n\t-i\t\tDon't display /etc/issue\n\t-f ISSUE_FILE\tDisplay ISSUE_FILE instead of /etc/issue\n\t-l LOGIN\tInvoke LOGIN instead of /bin/login\n\t-t SEC\t\tTerminate after SEC if no login name is read\n\t-I INITSTR\tSend INITSTR before anything else\n\t-H HOST\t\tLog HOST into the utmp file as the hostname\n\nBAUD_RATE of 0 leaves it unchanged",
            []
        ],
        "134990841": [
            "[-HhnlLoqvsriwFE] [-m N] [-A/B/C N] PATTERN/-e PATTERN.../-f FILE [FILE]...\n\nSearch for PATTERN in FILEs (or stdin)\n\n\t-H\tAdd 'filename:' prefix\n\t-h\tDo not add 'filename:' prefix\n\t-n\tAdd 'line_no:' prefix\n\t-l\tShow only names of files that match\n\t-L\tShow only names of files that don't match\n\t-c\tShow only count of matching lines\n\t-o\tShow only the matching part of line\n\t-q\tQuiet. Return 0 if PATTERN is found, 1 otherwise\n\t-v\tSelect non-matching lines\n\t-s\tSuppress open and read errors\n\t-r\tRecurse\n\t-i\tIgnore case\n\t-w\tMatch whole words only\n\t-x\tMatch whole lines only\n\t-F\tPATTERN is a literal (not regexp)\n\t-E\tPATTERN is an extended regexp\n\t-m N\tMatch up to N times per file\n\t-A N\tPrint N lines of trailing context\n\t-B N\tPrint N lines of leading context\n\t-C N\tSame as '-A N -B N'\n\t-e PTRN\tPattern to match\n\t-f FILE\tRead pattern from file",
            []
        ],
        "134991678": [
            "[-cfkt] [FILE]...\n\nDecompress FILEs (or stdin)\n\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files\n\t-t\tTest file integrity",
            []
        ],
        "134991801": [
            "[-cfkdt] [FILE]...\n\nCompress FILEs (or stdin)\n\n\t-d\tDecompress\n\t-t\tTest file integrity\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files",
            []
        ],
        "134991938": [
            "[-d DELAY] [-n] [-f] [-w]\n\nHalt the system\n\n\t-d SEC\tDelay interval\n\t-n\tDo not sync\n\t-f\tForce (don't go through init)\n\t-w\tOnly write a wtmp record",
            []
        ],
        "134992084": [
            "[OPTIONS] [DEVICE]\n\n\t-a\tGet/set fs readahead\n\t-A\tSet drive read-lookahead flag (0/1)\n\t-b\tGet/set bus state (0 == off, 1 == on, 2 == tristate)\n\t-B\tSet Advanced Power Management setting (1-255)\n\t-c\tGet/set IDE 32-bit IO setting\n\t-C\tCheck IDE power mode status\n\t-D\tEnable/disable drive defect-mgmt\n\t-f\tFlush buffer cache for device on exit\n\t-g\tDisplay drive geometry\n\t-h\tDisplay terse usage information\n\t-i\tDisplay drive identification\n\t-I\tDetailed/current information directly from drive\n\t-k\tGet/set keep_settings_over_reset flag (0/1)\n\t-K\tSet drive keep_features_over_reset flag (0/1)\n\t-L\tSet drive doorlock (0/1) (removable harddisks only)\n\t-m\tGet/set multiple sector count\n\t-n\tGet/set ignore-write-errors flag (0/1)\n\t-p\tSet PIO mode on IDE interface chipset (0,1,2,3,4,...)\n\t-P\tSet drive prefetch count\n\t-Q\tGet/set DMA tagged-queuing depth (if supported)\n\t-r\tGet/set readonly flag (DANGEROUS to set)\n\t-S\tSet standby (spindown) timeout\n\t-t\tPerform device read timings\n\t-T\tPerform cache read timings\n\t-u\tGet/set unmaskirq flag (0/1)\n\t-v\tDefaults; same as -mcudkrag for IDE drives\n\t-V\tDisplay program version and exit immediately\n\t-W\tSet drive write-caching flag (0/1) (DANGEROUS)\n\t-X\tSet IDE xfer mode (DANGEROUS)\n\t-y\tPut IDE drive in standby mode\n\t-Y\tPut IDE drive to sleep\n\t-Z\tDisable Seagate auto-powersaving mode\n\t-z\tReread partition table",
            []
        ],
        "134993427": [
            "[OPTIONS] [FILE]...\n\nPrint first 10 lines of each FILE (or stdin) to stdout.\nWith more than one FILE, precede each with a filename header.\n\n\t-n N[kbm]\tPrint first N lines\n\t-n -N[kbm]\tPrint all except N last lines\n\t-c [-]N[kbm]\tPrint first N bytes\n\t-q\t\tNever print headers\n\t-v\t\tAlways print headers\n\nN may be suffixed by k (x1024), b (x512), or m (x1024^2).",
            []
        ],
        "134993784": [
            "[-bcCdefnosvx] [FILE]...\n\nDisplay FILEs (or stdin) in a user specified format\n\n\t-b\t\t1-byte octal display\n\t-c\t\t1-byte character display\n\t-d\t\t2-byte decimal display\n\t-o\t\t2-byte octal display\n\t-x\t\t2-byte hex display\n\t-C\t\thex+ASCII 16 bytes per line\n\t-v\t\tShow all (no dup folding)\n\t-e FORMAT_STR\tExample: '16/1 \"%02x|\"\"\\n\"'\n\t-f FORMAT_FILE\n\t-n LENGTH\tShow only first LENGTH bytes\n\t-s OFFSET\tSkip OFFSET bytes",
            []
        ],
        "134994189": [
            "FILE\n\nEdit FILE in hexadecimal",
            []
        ],
        "134994220": [
            "\n\nPrint out a unique 32-bit identifier for the machine",
            []
        ],
        "134994275": [
            "[OPTIONS] [HOSTNAME | -F FILE]\n\nGet or set hostname or DNS domain name\n\n\t-s\tShort\n\t-i\tAddresses for the hostname\n\t-d\tDNS domain name\n\t-f\tFully qualified domain name\n\t-F FILE\tUse FILE's content as hostname",
            []
        ],
        "134994480": [
            "[-r|--show] [-s|--hctosys] [-w|--systohc] [--systz] [--localtime] [-u|--utc] [-f|--rtc FILE]\n\nQuery and set hardware clock (RTC)\n\n\t-r\tShow hardware clock time\n\t-s\tSet system time from hardware clock\n\t-w\tSet hardware clock from system time\n\t--systz\tSet in-kernel timezone, correct system time\n\t\tif hardware clock is in local time\n\t-u\tAssume hardware clock is kept in UTC\n\t--localtime\tAssume hardware clock is kept in local time\n\t-f FILE\tUse specified device (e.g. /dev/rtc2)",
            []
        ],
        "134994954": [
            "-l | -F I2CBUS | [-ya] [-q|-r] I2CBUS [FIRST LAST]\n\nDetect I2C chips\n\n\t-l\tList installed buses\n\t-F BUS#\tList functionalities on this bus\n\t-y\tDisable interactive mode\n\t-a\tForce scanning of non-regular addresses\n\t-q\tUse smbus quick write commands for probing (default)\n\t-r\tUse smbus read byte commands for probing\n\tFIRST and LAST limit probing range",
            []
        ],
        "134995302": [
            "[-fy] [-r FIRST-LAST] BUS ADDR [MODE]\n\nExamine I2C registers\n\n\tI2CBUS\tI2C bus number\n\tADDRESS\t0x03-0x77\nMODE is:\n\tb\tByte (default)\n\tw\tWord\n\tW\tWord on even register addresses\n\ti\tI2C block\n\ts\tSMBus block\n\tc\tConsecutive byte\n\tAppend p for SMBus PEC\n\n\t-f\tForce access\n\t-y\tDisable interactive mode\n\t-r\tLimit the number of registers being accessed",
            []
        ],
        "134995644": [
            "[-fy] BUS CHIP-ADDRESS [DATA-ADDRESS [MODE]]\n\nRead from I2C/SMBus chip registers\n\n\tI2CBUS\tI2C bus number\n\tADDRESS\t0x03-0x77\nMODE is:\n\tb\tRead byte data (default)\n\tw\tRead word data\n\tc\tWrite byte/read byte\n\tAppend p for SMBus PEC\n\n\t-f\tForce access\n\t-y\tDisable interactive mode",
            []
        ],
        "134995918": [
            "[-fy] [-m MASK] BUS CHIP-ADDRESS DATA-ADDRESS [VALUE] ... [MODE]\n\nSet I2C registers\n\n\tI2CBUS\tI2C bus number\n\tADDRESS\t0x03-0x77\nMODE is:\n\tc\tByte, no value\n\tb\tByte data (default)\n\tw\tWord data\n\ti\tI2C block data\n\ts\tSMBus block data\n\tAppend p for SMBus PEC\n\n\t-f\tForce access\n\t-y\tDisable interactive mode\n\t-r\tRead back and compare the result\n\t-m MASK\tMask specifying which bits to write",
            []
        ],
        "134996299": [
            "[OPTIONS] [USER]\n\nPrint information about USER or the current user\n\n\t-u\tUser ID\n\t-g\tGroup ID\n\t-G\tSupplementary group IDs\n\t-n\tPrint names instead of numbers\n\t-r\tPrint real ID instead of effective ID",
            []
        ],
        "134996497": [
            "[-a] interface [address]\n\nConfigure a network interface\n\n\t[add ADDRESS[/PREFIXLEN]]\n\t[del ADDRESS[/PREFIXLEN]]\n\t[[-]broadcast [ADDRESS]] [[-]pointopoint [ADDRESS]]\n\t[netmask ADDRESS] [dstaddr ADDRESS]\n\t[outfill NN] [keepalive NN]\n\t[hw ether|infiniband ADDRESS] [metric NN] [mtu NN]\n\t[[-]trailers] [[-]arp] [[-]allmulti]\n\t[multicast] [[-]promisc] [txqueuelen NN] [[-]dynamic]\n\t[mem_start NN] [io_addr NN] [irq NN]\n\t[up|down] ...",
            []
        ],
        "134996925": [
            "[-anmvf] [-i FILE] IFACE...\n\n\t-a\tDeconfigure all interfaces\n\t-i FILE\tUse FILE for interface definitions\n\t-n\tPrint out what would happen, but don't do it\n\t\t(note: doesn't disable mappings)\n\t-m\tDon't run any mappings\n\t-v\tPrint out what would happen before doing it\n\t-f\tForce deconfiguration",
            []
        ],
        "134997214": [
            "[-anmvf] [-i FILE] IFACE...\n\n\t-a\tConfigure all interfaces\n\t-i FILE\tUse FILE instead of /etc/network/interfaces\n\t-n\tPrint out what would happen, but don't do it\n\t\t(note: doesn't disable mappings)\n\t-m\tDon't run any mappings\n\t-v\tPrint out what would happen before doing it\n\t-f\tForce configuration",
            []
        ],
        "134997508": [
            "[-fe] [-q N] [-R N] [CONFFILE]\n\nListen for network connections and launch programs\n\n\t-f\tRun in foreground\n\t-e\tLog to stderr\n\t-q N\tSocket listen queue (default 128)\n\t-R N\tPause services after N connects/min\n\t\t(default 0 - disabled)\n\tDefault CONFFILE is /etc/inetd.conf",
            []
        ],
        "134997776": [
            "\n\nInit is the first process started during boot. It never exits.\nIt (re)spawns children according to /etc/inittab.",
            []
        ],
        "134997891": [
            "FILE [SYMBOL=VALUE]...\n\nLoad kernel module",
            []
        ],
        "134997934": [
            "[-cdDsp] [-o USER] [-g GRP] [-m MODE] [-t DIR] [SOURCE]... DEST\n\nCopy files and set attributes\n\n\t-c\tJust copy (default)\n\t-d\tCreate directories\n\t-D\tCreate leading target directories\n\t-s\tStrip symbol table\n\t-p\tPreserve date\n\t-o USER\tSet ownership\n\t-g GRP\tSet group ownership\n\t-m MODE\tSet permissions\n\t-t DIR\tInstall to DIR",
            []
        ],
        "134998255": [
            "[OPTIONS] address|route|link|tunnel|neigh|rule [COMMAND]\n\nOPTIONS := -f[amily] inet|inet6|link | -o[neline]\nCOMMAND :=\nip addr add|del IFADDR dev IFACE | show|flush [dev IFACE] [to PREFIX]\nip route list|flush|add|del|change|append|replace|test ROUTE\nip link set IFACE [up|down] [arp on|off] [multicast on|off]\n\t[promisc on|off] [mtu NUM] [name NAME] [qlen NUM] [address MAC]\n\t[master IFACE | nomaster]\nip tunnel add|change|del|show [NAME]\n\t[mode ipip|gre|sit]\n\t[remote ADDR] [local ADDR] [ttl TTL]\nip neigh show|flush [to PREFIX] [dev DEV] [nud STATE]\nip rule [list] | add|del SELECTOR ACTION",
            []
        ],
        "134998848": [
            "add|del IFADDR dev IFACE | show|flush [dev IFACE] [to PREFIX]\n\nipaddr add|change|replace|delete dev IFACE IFADDR\n\tIFADDR := PREFIX | ADDR peer PREFIX [broadcast ADDR|+|-]\n\t\t[anycast ADDR] [label STRING] [scope SCOPE]\n\tPREFIX := ADDR[/MASK]\n\tSCOPE := [host|link|global|NUMBER]\nipaddr show|flush [dev IFACE] [scope SCOPE] [to PREFIX] [label PATTERN]",
            []
        ],
        "134999196": [
            "[-MQS key] [-mqs id]\n\nUpper-case options MQS remove an object by shmkey value.\nLower-case options remove an object by shmid value.\n\n\t-mM\tRemove memory segment after last detach\n\t-qQ\tRemove message queue\n\t-sS\tRemove semaphore",
            []
        ],
        "134999421": [
            "[[-smq] -i SHMID] | [[-asmq] [-tcplu]]\n\n\t-i ID\tShow specific resource\nResource specification:\n\t-m\tShared memory segments\n\t-q\tMessage queues\n\t-s\tSemaphore arrays\n\t-a\tAll (default)\nOutput format:\n\t-t\tTime\n\t-c\tCreator\n\t-p\tPid\n\t-l\tLimits\n\t-u\tSummary",
            []
        ],
        "134999667": [
            "set IFACE [up|down] [arp on|off] [multicast on|off]\n\t[promisc on|off] [mtu NUM] [name NAME] [qlen NUM] [address MAC]\n\t[master IFACE | nomaster]\niplink add [link IFACE] IFACE [address MAC] type TYPE [ARGS]\niplink delete IFACE type TYPE [ARGS]\n\tTYPE ARGS := vlan VLANARGS | vrf table NUM\n\tVLANARGS := id VLANID [protocol 802.1q|802.1ad] [reorder_hdr on|off]\n\t\t[gvrp on|off] [mvrp on|off] [loose_binding on|off]\niplink show [IFACE]",
            []
        ],
        "135000096": [
            "show|flush [to PREFIX] [dev DEV] [nud STATE]",
            []
        ],
        "135000141": [
            "list|flush|add|del|change|append|replace|test ROUTE\n\niproute list|flush SELECTOR\n\tSELECTOR := [root PREFIX] [match PREFIX] [proto RTPROTO]\n\tPREFIX := default|ADDR[/MASK]\niproute get ADDR [from ADDR iif IFACE]\n\t[oif IFACE] [tos TOS]\niproute add|del|change|append|replace|test ROUTE\n\tROUTE := NODE_SPEC [INFO_SPEC]\n\tNODE_SPEC := PREFIX [table TABLE_ID] [proto RTPROTO] [scope SCOPE] [metric METRIC]\n\tINFO_SPEC := NH OPTIONS\n\tNH := [via [inet|inet6] ADDR] [dev IFACE] [src ADDR] [onlink]\n\tOPTIONS := [mtu [lock] NUM] [advmss [lock] NUM]",
            []
        ],
        "135000675": [
            "[list] | add|del SELECTOR ACTION\n\n\tSELECTOR := [from PREFIX] [to PREFIX] [tos TOS] [fwmark FWMARK]\n\t\t\t[dev IFACE] [pref NUMBER]\n\tACTION := [table TABLE_ID] [nat ADDR]\n\t\t\t[prohibit|reject|unreachable]\n\t\t\t[realms [SRCREALM/]DSTREALM]\n\tTABLE_ID := [local|main|default|NUMBER]",
            []
        ],
        "135000948": [
            "add|change|del|show [NAME]\n\t[mode ipip|gre|sit]\n\t[remote ADDR] [local ADDR] [ttl TTL]\n\niptunnel add|change|del|show [NAME]\n\t[mode ipip|gre|sit] [remote ADDR] [local ADDR]\n\t[[i|o]seq] [[i|o]key KEY] [[i|o]csum]\n\t[ttl TTL] [tos TOS] [[no]pmtudisc] [dev PHYS_DEV]",
            []
        ],
        "135001209": [
            "[-l] [-SIG] PID...\n\nSend a signal (default: TERM) to given PIDs\n\n\t-l\tList all signal names and numbers",
            []
        ],
        "135001312": [
            "[-l] [-q] [-SIG] PROCESS_NAME...\n\nSend a signal (default: TERM) to given processes\n\n\t-l\tList all signal names and numbers\n\t-q\tDon't complain if no processes were killed",
            []
        ],
        "135001481": [
            "[-l] [-SIG] [-o PID]...\n\nSend a signal (default: TERM) to all processes outside current session\n\n\t-l\tList all signal names and numbers\n\t-o PID\tDon't signal this PID",
            []
        ],
        "135001646": [
            "[-c N] [-n]\n\nKernel logger\n\n\t-c N\tPrint to console messages more urgent than prio N (1-8)\n\t-n\tRun in foreground",
            []
        ],
        "135001758": [
            "\n\nShow listing of the last users that logged into the system",
            []
        ],
        "135001819": [
            "[-EFIMmNSh~] [FILE]...\n\nView FILE (or stdin) one screenful at a time\n\n\t-E\tQuit once the end of a file is reached\n\t-F\tQuit if entire file fits on first screen\n\t-I\tIgnore case in all searches\n\t-M,-m\tDisplay status line with line numbers\n\t\tand percentage through the file\n\t-N\tPrefix line number to each line\n\t-S\tTruncate long lines\n\t-~\tSuppress ~s displayed past EOF",
            []
        ],
        "135002183": [
            "FILE LINK\n\nCreate hard LINK to FILE",
            []
        ],
        "135002225": [
            "[OPTIONS] TARGET... LINK|DIR\n\nCreate a link LINK or DIR/TARGET to the specified TARGET(s)\n\n\t-s\tMake symlinks instead of hardlinks\n\t-f\tRemove existing destinations\n\t-n\tDon't dereference symlinks - treat like normal file\n\t-b\tMake a backup of the target (if exists) before link operation\n\t-S suf\tUse suffix instead of ~ when making backup files\n\t-T\t2nd arg must be a DIR\n\t-v\tVerbose",
            []
        ],
        "135002605": [
            "< font\n\nLoad a console font from stdin",
            []
        ],
        "135002644": [
            "< keymap\n\nLoad a binary keyboard translation table from stdin",
            []
        ],
        "135002706": [
            "[OPTIONS] [MESSAGE]\n\nWrite MESSAGE (or stdin) to syslog\n\n\t-s\tLog to stderr as well as the system log\n\t-t TAG\tLog using the specified tag (defaults to user name)\n\t-p PRIO\tPriority (numeric or facility.level pair)",
            []
        ],
        "135002918": [
            "[-p] [-h HOST] [[-f] USER]\n\nBegin a new session on the system\n\n\t-f\tDon't authenticate (user already authenticated)\n\t-h HOST\tHost user came from (for network logins)\n\t-p\tPreserve environment",
            []
        ],
        "135003108": [
            "\n\nPrint the name of the current user",
            []
        ],
        "135003145": [
            "[-r] [-o OFS] {-f|LOOPDEV} FILE - associate loop devices\n\tlosetup -d LOOPDEV - disassociate\n\tlosetup -a - show status\n\tlosetup -f - show next free loop device\n\n\t-o OFS\tStart OFS bytes into FILE\n\t-r\tRead-only\n\t-f\tShow/use next free loop device",
            []
        ],
        "135003388": [
            "[-1AaCxdLHRFplinshrSXvctu] [-w WIDTH] [FILE]...\n\nList directory contents\n\n\t-1\tOne column output\n\t-a\tInclude entries which start with .\n\t-A\tLike -a, but exclude . and ..\n\t-x\tList by lines\n\t-d\tList directory entries instead of contents\n\t-L\tFollow symlinks\n\t-H\tFollow symlinks on command line\n\t-R\tRecurse\n\t-p\tAppend / to dir entries\n\t-F\tAppend indicator (one of */=@|) to entries\n\t-l\tLong listing format\n\t-i\tList inode numbers\n\t-n\tList numeric UIDs and GIDs instead of names\n\t-s\tList allocated blocks\n\t-lc\tList ctime\n\t-lu\tList atime\n\t--full-time\tList full date and time\n\t-h\tHuman readable sizes (1K 243M 2G)\n\t--group-directories-first\n\t-S\tSort by size\n\t-X\tSort by extension\n\t-v\tSort by version\n\t-t\tSort by mtime\n\t-tc\tSort by ctime\n\t-tu\tSort by atime\n\t-r\tReverse sort order\n\t-w N\tFormat N columns wide\n\t--color[={always,never,auto}]\tControl coloring",
            []
        ],
        "135004234": [
            "[-Radlv] [FILE]...\n\nList ext2 file attributes\n\n\t-R\tRecurse\n\t-a\tDon't hide entries starting with .\n\t-d\tList directory entries instead of contents\n\t-l\tList long flag names\n\t-v\tList version/generation number",
            []
        ],
        "135004439": [
            "\n\nList loaded kernel modules",
            []
        ],
        "135004468": [
            "\n\nShow all open files",
            []
        ],
        "135004490": [
            "[-mk]\n\nList all PCI devices\n\n\t-m\tParsable output\n\t-k\tShow driver",
            []
        ],
        "135004559": [
            "[FILE]...\n\nDecompress to stdout",
            []
        ],
        "135004591": [
            "-d [-cfk] [FILE]...\n\nDecompress FILE (or stdin)\n\n\t-d\tDecompress\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files",
            []
        ],
        "135004706": [
            "[-vF] [FILE]...\n\n\t-v\tVerbose\n\t-F\tDon't verify checksum",
            []
        ],
        "135004761": [
            "[-d device_table] rootdir\n\nCreate a range of special files as specified in a device table.\nDevice table entries take the form of:\n<name> <type> <mode> <uid> <gid> <major> <minor> <start> <inc> <count>\nWhere name is the file name, type can be one of:\n\tf\tRegular file\n\td\tDirectory\n\tc\tCharacter device\n\tb\tBlock device\n\tp\tFifo (named pipe)\nuid is the user id for the target file, gid is the group id for the\ntarget file. The rest of the entries (major, minor, etc) apply to\nto device special files. A '-' may be used for blank entries.",
            []
        ],
        "135005293": [
            "[-c[sw]] [FILE]...\n\nPrint or check MD5 checksums\n\n\t-c\tCheck sums against list in FILEs\n\t-s\tDon't output anything, status code shows success\n\t-w\tWarn about improperly formatted checksum lines",
            []
        ],
        "135005484": [
            "[-s]\n\nmdev -s is to be run during boot to scan /sys and populate /dev.\n\nBare mdev is a kernel hotplug helper. To activate it:\n\techo /sbin/mdev >/proc/sys/kernel/hotplug\n\nIt uses /etc/mdev.conf with lines\n\t[-][ENV=regex;]...DEVNAME UID:GID PERM [>|=PATH]|[!] [@|$|*PROG]\nwhere DEVNAME is device name regex, @major,minor[-minor2], or\nenvironment variable regex. A common use of the latter is\nto load modules for hotplugged devices:\n\t$MODALIAS=.* 0:0 660 @modprobe \"$MODALIAS\"\n\nIf /dev/mdev.seq file exists, mdev will wait for its value\nto match $SEQNUM variable. This prevents plug/unplug races.\nTo activate this feature, create empty /dev/mdev.seq at boot.\n\nIf /dev/mdev.log file exists, debug log will be appended to it.",
            []
        ],
        "135006205": [
            "[y|n]\n\nControl write access to your terminal\n\ty\tAllow write access to your terminal\n\tn\tDisallow write access to your terminal",
            []
        ],
        "135006331": [
            "[-d DELAY] [-t TIMEOUT] [-s SPEED] [-X] TTY\n\nCopy bytes for stdin to TTY and from TTY to stdout\n\n\t-d\tWait up to DELAY ms for TTY output before sending every\n\t\tnext byte to it\n\t-t\tExit if both stdin and TTY are silent for TIMEOUT ms\n\t-s\tSet serial line to SPEED\n\t-X\tDisable special meaning of NUL and Ctrl-X from stdin",
            []
        ],
        "135006649": [
            "[OPTIONS] DIRECTORY...\n\nCreate DIRECTORY\n\n\t-m MODE\tMode\n\t-p\tNo error if exists; make parent directories as needed",
            []
        ],
        "135006763": [
            "[-v] [-n LABEL] BLOCKDEV [KBYTES]\n\nMake a FAT32 filesystem\n\n\t-v\tVerbose\n\t-n LBL\tVolume label",
            []
        ],
        "135006856": [
            "[-Fn] [-b BLK_SIZE] [-i INODE_RATIO] [-I INODE_SIZE] [-m RESERVED_PERCENT] [-L LABEL] BLOCKDEV [KBYTES]\n\n\t-b BLK_SIZE\tBlock size, bytes\n\t-F\t\tForce\n\t-i RATIO\tMax number of files is filesystem_size / RATIO\n\t-I BYTES\tInode size (min 128)\n\t-L LBL\t\tVolume label\n\t-m PERCENT\tPercent of blocks to reserve for admin\n\t-n\t\tDry run",
            []
        ],
        "135007177": [
            "[-m MODE] NAME\n\nCreate named pipe\n\n\t-m MODE\tMode (default a=rw)",
            []
        ],
        "135007241": [
            "[-m MODE] NAME TYPE [MAJOR MINOR]\n\nCreate a special file (block, character, or pipe)\n\n\t-m MODE\tCreation mode (default a=rw)\nTYPE:\n\tb\tBlock device\n\tc or u\tCharacter device\n\tp\tNamed pipe (MAJOR MINOR must be omitted)",
            []
        ],
        "135007456": [
            "[OPTIONS] [PASSWORD] [SALT]\n\nPrint crypt(3) hashed PASSWORD\n\n\t-P,--password-fd N\tRead password from fd N\n\t-m,--method TYPE\tdes,md5 (default md5)\n\t-S,--salt SALT",
            []
        ],
        "135007617": [
            "[-L LBL] BLOCKDEV [KBYTES]\n\nPrepare BLOCKDEV to be used as swap partition\n\n\t-L LBL\tLabel",
            []
        ],
        "135007706": [
            "[-dt] [-p DIR] [TEMPLATE]\n\nCreate a temporary file with name based on TEMPLATE and print its name.\nTEMPLATE must end with XXXXXX (e.g. [/dir/]nameXXXXXX).\nWithout TEMPLATE, -t tmp.XXXXXX is assumed.\n\n\t-d\tMake directory, not file\n\t-q\tFail silently on errors\n\t-t\tPrepend base directory name to TEMPLATE\n\t-p DIR\tUse DIR as a base directory (implies -t)\n\t-u\tDo not create anything; print a name\n\nBase directory is: -p DIR, else $TMPDIR, else /tmp",
            []
        ],
        "135008149": [
            "[-alrqvsD] MODULE [SYMBOL=VALUE]...\n\n\t-a\tLoad multiple MODULEs\n\t-l\tList (MODULE is a pattern)\n\t-r\tRemove MODULE (stacks) or do autoclean\n\t-q\tQuiet\n\t-v\tVerbose\n\t-s\tLog to syslog\n\t-D\tShow dependencies",
            []
        ],
        "135008348": [
            "[FILE]...\n\nView FILE (or stdin) one screenful at a time",
            []
        ],
        "135008404": [
            "[OPTIONS] [-o OPT] DEVICE NODE\n\nMount a filesystem. Filesystem autodetection requires /proc.\n\n\t-a\t\tMount all filesystems in fstab\n\t-r\t\tRead-only mount\n\t-t FSTYPE[,...]\tFilesystem type(s)\n\t-T FILE\t\tRead FILE instead of /etc/fstab\n\t-O OPT\t\tMount only filesystems with option OPT (-a only)\n-o OPT:\n\tloop\t\tIgnored (loop devices are autodetected)\n\t[a]sync\t\tWrites are [a]synchronous\n\t[no]atime\tDisable/enable updates to inode access times\n\t[no]diratime\tDisable/enable atime updates to directories\n\t[no]relatime\tDisable/enable atime updates relative to modification time\n\t[no]dev\t\t(Dis)allow use of special device files\n\t[no]exec\t(Dis)allow use of executable files\n\t[no]suid\t(Dis)allow set-user-id-root programs\n\t[r]shared\tConvert [recursively] to a shared subtree\n\t[r]slave\tConvert [recursively] to a slave subtree\n\t[r]private\tConvert [recursively] to a private subtree\n\t[un]bindable\tMake mount point [un]able to be bind mounted\n\t[r]bind\t\tBind a file or directory [recursively] to another location\n\tmove\t\tRelocate an existing mount point\n\tremount\t\tRemount a mounted filesystem, changing flags\n\tro\t\tSame as -r\n\nThere are filesystem-specific -o flags.",
            []
        ],
        "135009549": [
            "[-q] <[-dn] DIR | -x DEVICE>\n\nCheck if the directory is a mountpoint\n\n\t-q\tQuiet\n\t-d\tPrint major/minor device number of the filesystem\n\t-n\tPrint device name of the filesystem\n\t-x\tPrint major/minor device number of the blockdevice",
            []
        ],
        "135009778": [
            "[-f device] opcode value\n\nControl magnetic tape drive operation\n\nAvailable Opcodes:\n\nbsf bsfm bsr bss datacompression drvbuffer eof eom erase\nfsf fsfm fsr fss load lock mkpart nop offline ras1 ras2\nras3 reset retension rewind rewoffline seek setblk setdensity\nsetpart tell unload unlock weof wset",
            []
        ],
        "135010075": [
            "[-fin] SOURCE DEST\nor: mv [-fin] SOURCE... DIRECTORY\n\nRename SOURCE to DEST, or move SOURCE(s) to DIRECTORY\n\n\t-f\tDon't prompt before overwriting\n\t-i\tInteractive, prompt before overwrite\n\t-n\tDon't overwrite an existing file",
            []
        ],
        "135010298": [
            "[-s] [-c FILE] [IFNAME HWADDR]...\n\nRename network interface while it in the down state.\nThe device with address HWADDR is renamed to IFACE.\n\n\t-c FILE\tConfiguration file (default: /etc/mactab)\n\t-s\tLog to syslog",
            []
        ],
        "135010508": [
            "[-ral] [-tuwx] [-en]\n\nDisplay networking information\n\n\t-r\tRouting table\n\t-a\tAll sockets\n\t-l\tListening sockets\n\t\tElse: connected sockets\n\t-t\tTCP sockets\n\t-u\tUDP sockets\n\t-w\tRaw sockets\n\t-x\tUnix sockets\n\t\tElse: all socket types\n\t-e\tOther/more information\n\t-n\tDon't resolve names",
            []
        ],
        "135010785": [
            "[-n ADJUST] [PROG ARGS]\n\nChange scheduling priority, run PROG\n\n\t-n ADJUST\tAdjust priority by ADJUST",
            []
        ],
        "135010885": [
            "[OPTIONS] [FILE]...\n\nWrite FILEs to standard output with line numbers added\n\n\t-b STYLE\tWhich lines to number - a: all, t: nonempty, n: none\n\t-i N\t\tLine number increment\n\t-s STRING\tUse STRING as line number separator\n\t-v N\t\tStart from N\n\t-w N\t\tWidth of line numbers",
            []
        ],
        "135011150": [
            "PROG ARGS\n\nRun PROG immune to hangups, with output to a non-tty",
            []
        ],
        "135011214": [
            "\n\nPrint number of CPUs",
            []
        ],
        "135011237": [
            "[-type=QUERY_TYPE] [-debug] HOST [DNS_SERVER]\n\nQuery DNS about HOST\n\nQUERY_TYPE: soa,ns,a,aaaa,cname,mx,txt,ptr,any",
            []
        ],
        "135011353": [
            "DIR...\n\nRemove DIRs",
            []
        ],
        "135011373": [
            "[-abcdfhilovxs] [-t TYPE] [-A RADIX] [-N SIZE] [-j SKIP] [-S MINSTR] [-w WIDTH] [FILE]...\n\nPrint FILEs (or stdin) unambiguously, as octal bytes by default",
            []
        ],
        "135011528": [
            "[-c N] [-sw] [PROG ARGS]\n\nStart PROG on a new virtual terminal\n\n\t-c N\tUse specified VT\n\t-s\tSwitch to the VT\n\t-w\tWait for PROG to exit",
            []
        ],
        "135011662": [
            "DEVICE...\n\nAsk kernel to rescan partition table",
            []
        ],
        "135011710": [
            "[OPTIONS] [USER]\n\nChange USER's password (default: current user)\n\n\t-a ALG\tdes,md5 (default md5)\n\t-d\tSet password to ''\n\t-l\tLock (disable) account\n\t-u\tUnlock (enable) account",
            []
        ],
        "135011884": [
            "[OPTIONS] [FILE]...\n\nPaste lines from each input file, separated with tab\n\n\t-d LIST\tUse delimiters from LIST, not tab\n\t-s      Serial: one file at a time",
            []
        ],
        "135012038": [
            "[OPTIONS] [ORIGFILE [PATCHFILE]]\n\n\t-p N\tStrip N leading components from file names\n\t-i DIFF\tRead DIFF instead of stdin\n\t-R\tReverse patch\n\t-N\tIgnore already applied patches\n\t-E\tRemove output files if they become empty\n\t--dry-run\tDon't actually change files",
            []
        ],
        "135012294": [
            "[OPTIONS] [NAME]...\n\nList PIDs of all processes with names that match NAMEs\n\n\t-s\tShow only one PID\n\t-o PID\tOmit given pid\n\t\tUse %PPID to omit pid of pidof's parent",
            []
        ],
        "135012458": [
            "[OPTIONS] HOST\n\nSend ICMP ECHO_REQUEST packets to network hosts\n\n\t-c CNT\t\tSend only CNT pings\n\t-s SIZE\t\tSend SIZE data bytes in packets (default 56)\n\t-A\t\tPing as soon as reply is recevied\n\t-t TTL\t\tSet TTL\n\t-I IFACE/IP\tSource interface or IP address\n\t-W SEC\t\tSeconds to wait for the first response (default 10)\n\t\t\t(after all -c CNT packets are sent)\n\t-w SEC\t\tSeconds until ping exits (default:infinite)\n\t\t\t(can exit earlier with -c CNT)\n\t-q\t\tQuiet, only display output at start\n\t\t\tand when finished\n\t-p HEXBYTE\tPattern to use for payload",
            []
        ],
        "135012997": [
            "NEW_ROOT PUT_OLD\n\nMove the current root file system to PUT_OLD and make NEW_ROOT\nthe new root file system",
            []
        ],
        "135013103": [
            "[-d DELAY] [-n] [-f]\n\nHalt and shut off power\n\n\t-d SEC\tDelay interval\n\t-n\tDo not sync\n\t-f\tForce (don't go through init)",
            []
        ],
        "135013223": [
            "[VARIABLE]...\n\nPrint environment VARIABLEs.\nIf no VARIABLE specified, print all.",
            []
        ],
        "135013304": [
            "FORMAT [ARG]...\n\nFormat and print ARG(s) according to FORMAT (a-la C printf)",
            []
        ],
        "135013381": [
            "[-o COL1,COL2=HEADER]\n\nShow list of processes\n\n\t-o COL1,COL2=HEADER\tSelect columns for display",
            []
        ],
        "135013476": [
            "\n\nPrint the full filename of the current working directory",
            []
        ],
        "135013535": [
            "[-s/-p] HOST\n\nSet and print time from HOST using RFC 868\n\n\t-s\tOnly set system time\n\t-p\tOnly print time",
            []
        ],
        "135013638": [
            "[-fnv] FILE\n\nDisplay the value of a symlink\n\n\t-f\tCanonicalize by following all symlinks\n\t-n\tDon't add newline\n\t-v\tVerbose",
            []
        ],
        "135013760": [
            "[OPTIONS]\n\n\t-m mapfile\t(Default: /boot/System.map)\n\t-p profile\t(Default: /proc/profile)\n\t-M NUM\t\tSet the profiling multiplier to NUM\n\t-i\t\tPrint only info about the sampling step\n\t-v\t\tVerbose\n\t-a\t\tPrint all symbols, even if count is 0\n\t-b\t\tPrint individual histogram-bin counts\n\t-s\t\tPrint individual counters within functions\n\t-r\t\tReset all the counters (root only)\n\t-n\t\tDisable byte order auto-detection",
            []
        ],
        "135014164": [
            "FILE...\n\nReturn the absolute pathnames of given FILE",
            []
        ],
        "135014217": [
            "[-d DELAY] [-n] [-f]\n\nReboot the system\n\n\t-d SEC\tDelay interval\n\t-n\tDo not sync\n\t-f\tForce (don't go through init)",
            []
        ],
        "135014331": [
            "[-n] PRIORITY [[-p | -g | -u] ID...]...\n\nChange scheduling priority of a running process\n\n\t-n\tAdd PRIORITY to current nice value\n\t\tWithout -n, nice value is set to PRIORITY\n\t-p\tProcess ids (default)\n\t-g\tProcess group ids\n\t-u\tProcess user names",
            []
        ],
        "135014575": [
            "\n\nReset the screen",
            []
        ],
        "135014594": [
            "\n\nResize the screen",
            []
        ],
        "135014614": [
            "BLOCKDEV [OFFSET]\n\nRestore system state from 'suspend-to-disk' data in BLOCKDEV",
            []
        ],
        "135014694": [
            "[-irf] FILE...\n\nRemove (unlink) FILEs\n\n\t-i\tAlways prompt before removing\n\t-f\tNever prompt\n\t-R,-r\tRecurse",
            []
        ],
        "135014799": [
            "[OPTIONS] DIRECTORY...\n\nRemove DIRECTORY if it is empty\n\n\t-p\tInclude parents\n\t--ignore-fail-on-non-empty",
            []
        ],
        "135014904": [
            "[-wfa] [MODULE]...\n\nUnload kernel modules\n\n\t-w\tWait until the module is no longer used\n\t-f\tForce unload\n\t-a\tRemove all unused modules (recursively)",
            []
        ],
        "135015052": [
            "[{add|del|delete}]\n\nEdit kernel routing tables\n\n\t-n\tDon't resolve names\n\t-e\tDisplay other/more information\n\t-A inet{6}\tSelect address family",
            []
        ],
        "135015193": [
            "[-d CAP,CAP...] [-n] [-c CONSOLE_DEV] NEW_ROOT NEW_INIT [ARGS]\n\nFree initramfs and switch to another root fs:\nchroot to NEW_ROOT, delete all in /, move NEW_ROOT to /,\nexecute NEW_INIT. PID must be 1. NEW_ROOT must be a mountpoint.\n\n\t-c DEV\tReopen stdio to DEV after switch\n\t-d CAPS\tDrop capabilities\n\t-n\tDry run",
            []
        ],
        "135015505": [
            "[-a ARG]... [-u UMASK] [--reverse] [--test] [--exit-on-error] DIRECTORY\n\nRun a bunch of scripts in DIRECTORY\n\n\t-a ARG\t\tPass ARG as argument to scripts\n\t-u UMASK\tSet UMASK before running scripts\n\t--reverse\tReverse execution order\n\t--test\t\tDry run\n\t--exit-on-error\tExit if a script exits with non-zero",
            []
        ],
        "135015805": [
            "[FILE]\n\nFind the current and previous system runlevel\n\nIf no utmp FILE exists or if no runlevel record can be found,\nprint \"unknown\"",
            []
        ],
        "135015938": [
            "[-i[SFX]] [-nrE] [-f FILE]... [-e CMD]... [FILE]...\nor: sed [-i[SFX]] [-nrE] CMD [FILE]...\n\n\t-e CMD\tAdd CMD to sed commands to be executed\n\t-f FILE\tAdd FILE contents to sed commands to be executed\n\t-i[SFX]\tEdit files in-place (otherwise sends to stdout)\n\t\tOptionally back files up, appending SFX\n\t-n\tSuppress automatic printing of pattern space\n\t-r,-E\tUse extended regex syntax\n\nIf no -e or -f, the first non-option argument is the sed command string.\nRemaining arguments are input files (stdin if none).",
            []
        ],
        "135016443": [
            "[-w] [-s SEP] [FIRST [INC]] LAST\n\nPrint numbers from FIRST to LAST, in steps of INC.\nFIRST, INC default to 1.\n\n\t-w\tPad to last with leading zeros\n\t-s SEP\tString separator",
            []
        ],
        "135016614": [
            "PERSONALITY [-R] PROG ARGS\n\nPERSONALITY may be:\n\tlinux32\tSet 32bit uname emulation\n\tlinux64\tSet 64bit uname emulation\n\n\t-R\tDisable address space randomization",
            []
        ],
        "135016773": [
            "[-r] [DEVICE]\n\nMake writes to /dev/console appear on DEVICE (default: /dev/tty).\nDoes not redirect kernel log output or reads from /dev/console.\n\n\t-r\tReset: writes to /dev/console go to kernel log tty(s)",
            []
        ],
        "135016977": [
            "[-h] -n|-x ATTR [-v VALUE] FILE...\n\nSet extended attributes\n\n\t-h\t\tDo not follow symlinks\n\t-x ATTR\t\tRemove attribute ATTR\n\t-n ATTR\t\tSet attribute ATTR to VALUE\n\t-v VALUE\t(default: empty)",
            []
        ],
        "135017163": [
            "{ SCANCODE KEYCODE }...\n\nModify kernel's scancode-to-keycode map,\nallowing unusual keyboards to generate usable keycodes.\n\nSCANCODE is either xx or e0xx (hexadecimal), KEYCODE is decimal.",
            []
        ],
        "135017351": [
            "[N]\n\nPin kernel output to VT console N. Default:0 (do not pin)",
            []
        ],
        "135017414": [
            "[OPTIONS] PROG [ARGS]\n\nRun PROG with different privilege settings\n\n-d,--dump\t\tShow current capabilities\n--nnp,--no-new-privs\tIgnore setuid/setgid bits and file capabilities\n--inh-caps CAP,CAP\tSet inheritable capabilities\n--ambient-caps CAP,CAP\tSet ambient capabilities",
            []
        ],
        "135017683": [
            "[-abGvz] { DEVICE [PARAMETER [ARG]]... | -g DEVICE... }\n\nPrint or set serial port parameters\n\n\t-a\tPrint all\n\t-b\tPrint summary\n\t-G\tPrint as setserial PARAMETERs\n\t-v\tVerbose\n\t-z\tZero out serial flags before setting\n\t-g\tAll args are device names\n\nPARAMETERs: (* = takes ARG, ^ = can be turned off by preceding ^)\n\t*port, *irq, *divisor, *uart, *baud_base, *close_delay, *closing_wait,\n\t^fourport, ^auto_irq, ^skip_test, ^sak, ^session_lockout, ^pgrp_lockout,\n\t^callout_nohup, ^split_termios, ^hup_notify, ^low_latency, autoconfig,\n\tspd_normal, spd_hi, spd_vhi, spd_shi, spd_warp, spd_cust\nARG for uart:\n\tunknown, 8250, 16450, 16550, 16550A, Cirrus, 16650, 16650V2, 16750,\n\t16950, 16954, 16654, 16850, RSA, NS16550A, XSCALE, RM9000, OCTEON, AR7,\n\tU6_16550A",
            []
        ],
        "135018436": [
            "[-c] PROG ARGS\n\nRun PROG in a new session. PROG will have no controlling terminal\nand will not be affected by keyboard signals (^C etc).\n\n\t-c\tSet controlling terminal to stdin",
            []
        ],
        "135018612": [
            "[-/+OPTIONS] [-/+o OPT]... [-c 'SCRIPT' [ARG0 [ARGS]] / FILE [ARGS] / -s [ARGS]]\n\nUnix shell interpreter",
            []
        ],
        "135018717": [
            "[-c[sw]] [FILE]...\n\nPrint or check SHA1 checksums\n\n\t-c\tCheck sums against list in FILEs\n\t-s\tDon't output anything, status code shows success\n\t-w\tWarn about improperly formatted checksum lines",
            []
        ],
        "135018909": [
            "[-c[sw]] [FILE]...\n\nPrint or check SHA256 checksums\n\n\t-c\tCheck sums against list in FILEs\n\t-s\tDon't output anything, status code shows success\n\t-w\tWarn about improperly formatted checksum lines",
            []
        ],
        "135019103": [
            "[-c[sw]] [-a BITS] [FILE]...\n\nPrint or check SHA3 checksums\n\n\t-c\tCheck sums against list in FILEs\n\t-s\tDon't output anything, status code shows success\n\t-w\tWarn about improperly formatted checksum lines\n\t-a BITS\t224 (default), 256, 384, 512",
            []
        ],
        "135019343": [
            "[-c[sw]] [FILE]...\n\nPrint or check SHA512 checksums\n\n\t-c\tCheck sums against list in FILEs\n\t-s\tDon't output anything, status code shows success\n\t-w\tWarn about improperly formatted checksum lines",
            []
        ],
        "135019537": [
            "FILE...\n\nOverwrite/delete FILEs\n\n\t-f\tChmod to ensure writability\n\t-n N\tOverwrite N times (default 3)\n\t-z\tFinal overwrite with zeros\n\t-u\tRemove file",
            []
        ],
        "135019685": [
            "[N]...\n\nPause for a time equal to the total of the args given, where each arg can\nhave an optional suffix of (s)econds, (m)inutes, (h)ours, or (d)ays",
            []
        ],
        "135019835": [
            "[-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...\n\nSort lines of text\n\n\t-o FILE\tOutput to FILE\n\t-c\tCheck whether input is sorted\n\t-b\tIgnore leading blanks\n\t-f\tIgnore case\n\t-i\tIgnore unprintable characters\n\t-d\tDictionary order (blank or alphanumeric only)\n\t-n\tSort numbers\n\t-g\tGeneral numerical sort\n\t-M\tSort month\n\t-t CHAR\tField separator\n\t-k N[,M] Sort by Nth field\n\t-r\tReverse sort order\n\t-s\tStable (don't sort ties alphabetically)\n\t-u\tSuppress duplicate lines\n\t-z\tLines are terminated by NUL, not newline",
            []
        ],
        "135020388": [
            "[OPTIONS] [-S|-K] ... [-- ARGS...]\n\nSearch for matching processes, and then\n-K: stop all matching processes\n-S: start a process unless a matching process is found\n\nProcess matching:\n\t-u USERNAME|UID\tMatch only this user's processes\n\t-n NAME\t\tMatch processes with NAME\n\t\t\tin comm field in /proc/PID/stat\n\t-x EXECUTABLE\tMatch processes with this command\n\t\t\tcommand in /proc/PID/cmdline\n\t-p FILE\t\tMatch a process with PID from FILE\n\tAll specified conditions must match\n-S only:\n\t-x EXECUTABLE\tProgram to run\n\t-a NAME\t\tZeroth argument\n\t-b\t\tBackground\n\t-N N\t\tChange nice level\n\t-c USER[:[GRP]]\tChange user/group\n\t-m\t\tWrite PID to pidfile specified by -p\n-K only:\n\t-s SIG\t\tSignal to send\n\t-t\t\tMatch only, exit with 0 if found\nOther:\n\t-o\t\tExit with status 0 if nothing is done\n\t-v\t\tVerbose\n\t-q\t\tQuiet",
            []
        ],
        "135021182": [
            "[-fo] [-t o/d/x] [-n LEN] [FILE]...\n\nDisplay printable strings in a binary file\n\n\t-f\t\tPrecede strings with filenames\n\t-o\t\tPrecede strings with octal offsets\n\t-t o/d/x\tPrecede strings with offsets in base 8/10/16\n\t-n LEN\t\tAt least LEN characters form a string (default 4)",
            []
        ],
        "135021453": [
            "[-a|g] [-F DEVICE] [SETTING]...\n\nWithout arguments, prints baud rate, line discipline,\nand deviations from stty sane\n\n\t-F DEVICE\tOpen device instead of stdin\n\t-a\t\tPrint all current settings in human-readable form\n\t-g\t\tPrint in stty-readable form\n\t[SETTING]\tSee manpage",
            []
        ],
        "135021722": [
            "[-lmp] [-] [-s SH] [USER [SCRIPT ARGS / -c 'CMD' ARG0 ARGS]]\n\nRun shell under USER (by default, root)\n\n\t-,-l\tClear environment, go to home dir, run shell as login shell\n\t-p,-m\tDo not set new $HOME, $SHELL, $USER, $LOGNAME\n\t-c CMD\tCommand to pass to 'sh -c'\n\t-s SH\tShell to use instead of user's default",
            []
        ],
        "135022025": [
            "[-t N] [TTY]\n\nSingle user login\n\n\t-t N\tTimeout",
            []
        ],
        "135022072": [
            "[-udopchaitkx] SERVICE_DIR...\n\nControl services monitored by runsv supervisor\n\n\t-u\tIf service is not running, start it; restart if it stops\n\t-d\tIf service is running, send TERM+CONT signals; do not restart it\n\t-o\tOnce: if service is not running, start it; do not restart it\n\t-pchaitk Send STOP, CONT, HUP, ALRM, INT, TERM, KILL signal to service\n\t-x\tExit: runsv will exit as soon as the service is down",
            []
        ],
        "135022475": [
            "SERVICE_DIR\n\nCheck whether runsv supervisor is running.\nExit code is 0 if it does, 100 if it does not,\n111 (with error message) if SERVICE_DIR does not exist.",
            []
        ],
        "135022634": [
            "[-a] [DEVICE]\n\nStop swapping on DEVICE\n\n\t-a\tStop swapping on all swap devices",
            []
        ],
        "135022712": [
            "[-a] [-e] [DEVICE]\n\nStart swapping on DEVICE\n\n\t-a\tStart swapping on all swap devices\n\t-e\tSilently skip devices that do not exist",
            []
        ],
        "135022841": [
            "[-c CONSOLE_DEV] NEW_ROOT NEW_INIT [ARGS]\n\nFree initramfs and switch to another root fs:\nchroot to NEW_ROOT, delete all in /, move NEW_ROOT to /,\nexecute NEW_INIT. PID must be 1. NEW_ROOT must be a mountpoint.\n\n\t-c DEV\tReopen stdio to DEV after switch",
            []
        ],
        "135023093": [
            "\n\nWrite all buffered blocks to disk",
            []
        ],
        "135023129": [
            "-p [-enq] [FILE...] / [-enqaw] [KEY[=VALUE]]...\n\nShow/set kernel parameters\n\n\t-p\tSet values from FILEs (default /etc/sysctl.conf)\n\t-e\tDon't warn about unknown keys\n\t-n\tDon't show key names\n\t-q      Quiet\n\t-a\tShow all values\n\t-w\tSet values",
            []
        ],
        "135023368": [
            "[OPTIONS]\n\nSystem logging utility\n(this version of syslogd ignores /etc/syslog.conf)\n\n\t-n\t\tRun in foreground\n\t-R HOST[:PORT]\tLog to HOST:PORT (default PORT:514)\n\t-L\t\tLog locally and via network (default is network only if -R)\n\t-O FILE\t\tLog to FILE (default: /var/log/messages, stdout if -)\n\t-s SIZE\t\tMax size (KB) before rotation (default 200KB, 0=off)\n\t-b N\t\tN rotated logs to keep (default 1, max 99, 0=purge)\n\t-l N\t\tLog only messages more urgent than prio N (1-8)\n\t-S\t\tSmaller output",
            []
        ],
        "135023855": [
            "[OPTIONS] [FILE]...\n\nPrint last 10 lines of each FILE (or stdin) to stdout.\nWith more than one FILE, precede each with a filename header.\n\n\t-f\t\tPrint data as file grows\n\t-c [+]N[kbm]\tPrint last N bytes\n\t-n N[kbm]\tPrint last N lines\n\t-n +N[kbm]\tStart on Nth line and print the rest\n\t-q\t\tNever print headers\n\t-s SECONDS\tWait SECONDS between reads with -f\n\t-v\t\tAlways print headers\n\t-F\t\tSame as -f, but keep retrying\n\nN may be suffixed by k (x1024), b (x512), or m (x1024^2).",
            []
        ],
        "135024328": [
            "c|x|t [-hvokO] [-f TARFILE] [-C DIR] [-T FILE] [-X FILE] [--exclude PATTERN]... [FILE]...\n\nCreate, extract, or list files from a tar file\n\n\tc\tCreate\n\tx\tExtract\n\tt\tList\n\t-f FILE\tName of TARFILE ('-' for stdin/out)\n\t-C DIR\tChange to DIR before operation\n\t-v\tVerbose\n\t-O\tExtract to stdout\n\t-o\tDon't restore user:group\n\t-k\tDon't replace existing files\n\t-h\tFollow symlinks\n\t-T FILE\tFile with names to include\n\t-X FILE\tFile with glob patterns to exclude\n\t--exclude PATTERN\tGlob pattern to exclude",
            []
        ],
        "135024819": [
            "OBJECT CMD [dev STRING]\n\nOBJECT: qdisc|class|filter\nCMD: add|del|change|replace|show\n\nqdisc [handle QHANDLE] [root|ingress|parent CLASSID]\n\t[[QDISC_KIND] [help|OPTIONS]]\n\tQDISC_KIND := [p|b]fifo|tbf|prio|cbq|red|etc.\nqdisc show [dev STRING] [ingress]\nclass [classid CLASSID] [root|parent CLASSID]\n\t[[QDISC_KIND] [help|OPTIONS] ]\nclass show [ dev STRING ] [root|parent CLASSID]\nfilter [pref PRIO] [protocol PROTO]\n\t[root|classid CLASSID] [handle FILTERID]\n\t[[FILTER_TYPE] [help|OPTIONS]]\nfilter show [dev STRING] [root|parent CLASSID]",
            []
        ],
        "135025353": [
            "[-ai] [FILE]...\n\nCopy stdin to each FILE, and also to stdout\n\n\t-a\tAppend to the given FILEs, don't overwrite\n\t-i\tIgnore interrupt signals (SIGINT)",
            []
        ],
        "135025500": [
            "[-a] [-l USER] HOST [PORT]\n\nConnect to telnet server\n\n\t-a\tAutomatic login with $USER variable\n\t-l USER\tAutomatic login as USER",
            []
        ],
        "135025629": [
            "[OPTIONS] HOST [PORT]\n\nTransfer a file from/to tftp server\n\n\t-l FILE\tLocal FILE\n\t-r FILE\tRemote FILE\n\t-g\tGet file\n\t-p\tPut file\n\t-b SIZE\tTransfer blocks of SIZE octets",
            []
        ],
        "135025796": [
            "[-vpa] [-o FILE] PROG ARGS\n\nRun PROG, display resource usage when it exits\n\n\t-v\tVerbose\n\t-p\tPOSIX output format\n\t-f FMT\tCustom format\n\t-o FILE\tWrite result to FILE\n\t-a\tAppend (else overwrite)",
            []
        ],
        "135025988": [
            "[-b] [-nCOUNT] [-dSECONDS]\n\nProvide a view of process activity in real time.\nRead the status of all processes from /proc each SECONDS\nand display a screenful of them.\nKeys:\n\tN/M/P/T: sort by pid/mem/cpu/time\n\tR: reverse sort\n\tQ,^C: exit\n\nOptions:\n\t-b\tBatch mode\n\t-n N\tExit after N iterations\n\t-d N\tDelay between updates",
            []
        ],
        "135026308": [
            "[-c] [-d DATE] [-t DATE] [-r FILE] FILE...\n\nUpdate the last-modified date on the given FILE[s]\n\n\t-c\tDon't create files\n\t-d DT\tDate/time to use\n\t-t DT\tDate/time to use\n\t-r FILE\tUse FILE's date/time",
            []
        ],
        "135026505": [
            "[-cds] STRING1 [STRING2]\n\nTranslate, squeeze, or delete characters from stdin, writing to stdout\n\n\t-c\tTake complement of STRING1\n\t-d\tDelete input characters coded STRING1\n\t-s\tSqueeze multiple output characters of STRING2 into one character",
            []
        ],
        "135026745": [
            "[-FIlnrv] [-f 1ST_TTL] [-m MAXTTL] [-q PROBES] [-p PORT]\n\t[-t TOS] [-w WAIT_SEC] [-s SRC_IP] [-i IFACE]\n\t[-z PAUSE_MSEC] HOST [BYTES]\n\nTrace the route to HOST\n\n\t-F\tSet don't fragment bit\n\t-l\tDisplay TTL value of the returned packet\n\t-n\tPrint numeric addresses\n\t-r\tBypass routing tables, send directly to HOST\n\t-f N\tFirst number of hops (default 1)\n\t-m N\tMax number of hops\n\t-q N\tNumber of probes per hop (default 3)\n\t-p N\tBase UDP port number used in probes\n\t\t(default 33434)\n\t-s IP\tSource address\n\t-i IFACE Source interface\n\t-t N\tType-of-service in probe packets (default 0)\n\t-w SEC\tTime to wait for a response (default 3)\n\t-g IP\tLoose source route gateway (8 max)",
            []
        ],
        "135027413": [
            "[-c] -s SIZE FILE...\n\nTruncate FILEs to the given size\n\n\t-c\tDo not create files\n\t-s SIZE\tTruncate to SIZE",
            []
        ],
        "135027519": [
            "\n\nPrint file name of stdin's terminal\n\n\t-s\tPrint nothing, only return exit status",
            []
        ],
        "135027601": [
            "UBI_DEVICE OLD_VOLNAME NEW_VOLNAME [OLD2 NEW2]...\n\nRename UBI volumes on UBI_DEVICE",
            []
        ],
        "135027685": [
            "[-fbqRB] [-a[MSEC]] [-t N] [-T SEC] [-A SEC/-n]\n\t[-i IFACE] [-s PROG] [-p PIDFILE]\n\t[-oC] [-r IP] [-V VENDOR] [-F NAME] [-x OPT:VAL]... [-O OPT]...\n\n\t-i IFACE\tInterface to use (default eth0)\n\t-s PROG\t\tRun PROG at DHCP events (default /usr/share/udhcpc/default.script)\n\t-p FILE\t\tCreate pidfile\n\t-B\t\tRequest broadcast replies\n\t-t N\t\tSend up to N discover packets (default 3)\n\t-T SEC\t\tPause between packets (default 3)\n\t-A SEC\t\tWait if lease is not obtained (default 20)\n\t-n\t\tExit if lease is not obtained\n\t-q\t\tExit after obtaining lease\n\t-R\t\tRelease IP on exit\n\t-f\t\tRun in foreground\n\t-b\t\tBackground if lease is not obtained\n\t-S\t\tLog to syslog too\n\t-a[MSEC]\tValidate offered address with ARP ping\n\t-r IP\t\tRequest this IP address\n\t-o\t\tDon't request any options (unless -O is given)\n\t-O OPT\t\tRequest option OPT from server (cumulative)\n\t-x OPT:VAL\tInclude option OPT in sent packets (cumulative)\n\t\t\tExamples of string, numeric, and hex byte opts:\n\t\t\t-x hostname:bbox - option 12\n\t\t\t-x lease:3600 - option 51 (lease time)\n\t\t\t-x 0x3d:0100BEEFC0FFEE - option 61 (client id)\n\t\t\t-x 14:'\"dumpfile\"' - option 14 (shell-quoted)\n\t-F NAME\t\tAsk server to update DNS mapping for NAME\n\t-V VENDOR\tVendor identifier (default 'udhcp VERSION')\n\t-C\t\tDon't send MAC as client identifier\nSignals:\n\tUSR1\tRenew lease\n\tUSR2\tRelease lease",
            []
        ],
        "135028996": [
            "[PROG [ARGS]]\n\nuevent runs PROG for every netlink notification.\nPROG's environment contains data passed from the kernel.\nTypical usage (daemon for dynamic device node creation):\n\t# uevent mdev & mdev -s",
            []
        ],
        "135029199": [
            "[OPTIONS] FILESYSTEM|DIRECTORY\n\nUnmount file systems\n\n\t-a\tUnmount all file systems\n\t-r\tTry to remount devices as read-only if mount is busy\n\t-l\tLazy umount (detach filesystem)\n\t-f\tForce umount (i.e., unreachable NFS server)\n\t-d\tFree loop device if it has been used\n\t-t FSTYPE[,...]\tUnmount only these filesystem type(s)",
            []
        ],
        "135029519": [
            "[-amnrspvio]\n\nPrint system information\n\n\t-a\tPrint all\n\t-m\tThe machine (hardware) type\n\t-n\tHostname\n\t-r\tKernel release\n\t-s\tKernel name (default)\n\t-p\tProcessor type\n\t-v\tKernel version\n\t-i\tThe hardware platform\n\t-o\tOS name",
            []
        ],
        "135029739": [
            "[-cdu][-f,s,w N] [INPUT [OUTPUT]]\n\nDiscard duplicate lines\n\n\t-c\tPrefix lines by the number of occurrences\n\t-d\tOnly print duplicate lines\n\t-u\tOnly print unique lines\n\t-i\tIgnore case\n\t-f N\tSkip first N fields\n\t-s N\tSkip first N chars (after any skipped fields)\n\t-w N\tCompare N characters in line",
            []
        ],
        "135030033": [
            "[-ud] [FILE]\n\nConvert FILE in-place from Unix to DOS format.\nWhen no file is given, use stdin/stdout.\n\n\t-u\tdos2unix\n\t-d\tunix2dos",
            []
        ],
        "135030162": [
            "FILE\n\nDelete FILE by calling unlink()",
            []
        ],
        "135030200": [
            "[-cfk] [FILE]...\n\nDecompress FILE (or stdin)\n\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files",
            []
        ],
        "135030297": [
            "[-cfUvF] [FILE]...\n\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-U\tDelete input files\n\t-v\tVerbose\n\t-F\tDon't verify checksum",
            []
        ],
        "135030408": [
            "[-cfk] [FILE]...\n\nDecompress FILE (or stdin)\n\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files",
            []
        ],
        "135030505": [
            "[-lnojpq] FILE[.zip] [FILE]... [-x FILE...] [-d DIR]\n\nExtract FILEs from ZIP archive\n\n\t-l\tList contents (with -q for short form)\n\t-n\tNever overwrite files (default: ask)\n\t-o\tOverwrite\n\t-j\tDo not restore paths\n\t-p\tPrint to stdout\n\t-q\tQuiet\n\t-x FILE\tExclude FILEs\n\t-d DIR\tExtract into DIR",
            []
        ],
        "135030792": [
            "\n\nDisplay the time since the last boot",
            []
        ],
        "135030831": [
            "N\n\nPause for N microseconds",
            []
        ],
        "135030859": [
            "[-o OUTFILE] [INFILE]\n\nUudecode a file\nFinds OUTFILE in uuencoded source unless -o is given",
            []
        ],
        "135030951": [
            "[-m] [FILE] STORED_FILENAME\n\nUuencode FILE (or stdin) to stdout\n\n\t-m\tUse base64 encoding per RFC1521",
            []
        ],
        "135031052": [
            "COMMAND [OPTIONS]\n\nCreate and remove virtual ethernet devices\n\n\tadd\t\tIFACE VLAN_ID\n\trem\t\tVLAN_NAME\n\tset_flag\tIFACE 0|1 VLAN_QOS\n\tset_egress_map\tVLAN_NAME SKB_PRIO VLAN_QOS\n\tset_ingress_map\tVLAN_NAME SKB_PRIO VLAN_QOS\n\tset_name_type\tNAME_TYPE",
            []
        ],
        "135031294": [
            "[OPTIONS] [FILE]...\n\nEdit FILE\n\n\t-c CMD\tInitial command to run ($EXINIT also available)\n\t-R\tRead-only\n\t-H\tList available features",
            []
        ],
        "135031424": [
            "[-a]\n\nLock a virtual terminal. A password is required to unlock.\n\n\t-a\tLock all VTs",
            []
        ],
        "135031507": [
            "\n\nShow who is logged on",
            []
        ],
        "135031531": [
            "[-n SEC] [-t] PROG ARGS\n\nRun PROG periodically\n\n\t-n\tLoop period in seconds (default 2)\n\t-t\tDon't print header",
            []
        ],
        "135031641": [
            "[-t N[ms]] [-T N[ms]] [-F] DEV\n\nPeriodically write to watchdog device DEV\n\n\t-T N\tReboot after N seconds if not reset (default 60)\n\t-t N\tReset every N seconds (default 30)\n\t-F\tRun in foreground\n\nUse 500ms to specify period in milliseconds",
            []
        ],
        "135031879": [
            "[-clwL] [FILE]...\n\nCount lines, words, and bytes for each FILE (or stdin)\n\n\t-c\tCount bytes\n\t-l\tCount newlines\n\t-w\tCount words\n\t-L\tPrint longest line length",
            []
        ],
        "135032035": [
            "[-c|--continue] [--spider] [-q|--quiet] [-O|--output-document FILE]\n\t[--header 'header: value'] [-Y|--proxy on/off] [-P DIR]\n\t[-S|--server-response] [-U|--user-agent AGENT] [-T SEC] URL...\n\nRetrieve files via HTTP or FTP\n\n\t--spider\tOnly check URL existence: $? is 0 if exists\n\t-c\t\tContinue retrieval of aborted transfer\n\t-q\t\tQuiet\n\t-P DIR\t\tSave to DIR (default .)\n\t-S    \t\tShow server response\n\t-T SEC\t\tNetwork read timeout is SEC seconds\n\t-O FILE\t\tSave to FILE ('-' for stdout)\n\t-U STR\t\tUse STR for User-Agent header\n\t-Y on/off\tUse proxy",
            []
        ],
        "135032574": [
            "[COMMAND]...\n\nLocate a COMMAND",
            []
        ],
        "135032605": [
            "[-a]\n\nShow who is logged on\n\n\t-a\tShow all\n\t-H\tPrint column headers",
            []
        ],
        "135032672": [
            "\n\nPrint the user name associated with the current effective user id",
            []
        ],
        "135032740": [
            "[OPTIONS] [PROG ARGS]\n\nRun PROG on every item given by stdin\n\n\t-r\tDon't run command if input is empty\n\t-0\tInput is separated by NUL characters\n\t-a FILE\tRead from FILE instead of stdin\n\t-t\tPrint the command on stderr before execution\n\t-e[STR]\tSTR stops input processing\n\t-n N\tPass no more than N args to PROG\n\t-s N\tPass command line of no more than N bytes\n\t-I STR\tReplace STR within PROG ARGS with input line\n\t-P N\tRun up to N PROGs in parallel\n\t-x\tExit if size is exceeded",
            []
        ],
        "135033214": [
            "[OPTIONS] [FILE]\n\nHex dump FILE (or stdin)\n\n\t-g N\t\tBytes per group\n\t-c N\t\tBytes per line\n\t-p\t\tShow only hex bytes, assumes -c30\n\t-l LENGTH\tShow only first LENGTH bytes\n\t-s OFFSET\tSkip OFFSET bytes",
            []
        ],
        "135033411": [
            "-d [-cfk] [FILE]...\n\nDecompress FILE (or stdin)\n\n\t-d\tDecompress\n\t-c\tWrite to stdout\n\t-f\tForce\n\t-k\tKeep input files",
            []
        ],
        "135033526": [
            "[FILE]...\n\nDecompress to stdout",
            []
        ],
        "135033558": [
            "[STRING]\n\nRepeatedly output a line with STRING, or 'y'",
            []
        ],
        "135033613": [
            "[FILE]...\n\nDecompress to stdout",
            []
        ],
        "135033659": [
            "A311D",
            []
        ],
        "135033670": [
            "343AA",
            []
        ],
        "135033683": [
            "\"33!DD#\"$2\"3\"\"",
            []
        ],
        "135033707": [
            "233322",
            []
        ],
        "135033722": [
            "331C3",
            []
        ],
        "135033737": [
            "!\"!1!3",
            []
        ],
        "135033744": [
            "113312",
            []
        ],
        "135033751": [
            "2#\"!2!3331",
            []
        ],
        "135033772": [
            "3!33333",
            []
        ],
        "135033852": [
            "addgroup",
            []
        ],
        "135033861": [
            "adduser",
            []
        ],
        "135033881": [
            "arping",
            []
        ],
        "135033896": [
            "basename",
            []
        ],
        "135033905": [
            "blkid",
            []
        ],
        "135033911": [
            "bunzip2",
            []
        ],
        "135033919": [
            "bzcat",
            []
        ],
        "135033929": [
            "chattr",
            []
        ],
        "135033936": [
            "chgrp",
            []
        ],
        "135033942": [
            "chmod",
            []
        ],
        "135033948": [
            "chown",
            []
        ],
        "135033954": [
            "chroot",
            []
        ],
        "135033971": [
            "cksum",
            []
        ],
        "135033977": [
            "clear",
            []
        ],
        "135033995": [
            "crond",
            []
        ],
        "135034001": [
            "crontab",
            []
        ],
        "135034024": [
            "deallocvt",
            []
        ],
        "135034034": [
            "delgroup",
            []
        ],
        "135034043": [
            "deluser",
            []
        ],
        "135034051": [
            "devmem",
            []
        ],
        "135034066": [
            "dirname",
            []
        ],
        "135034074": [
            "dmesg",
            []
        ],
        "135034085": [
            "dnsdomainname",
            []
        ],
        "135034099": [
            "dos2unix",
            []
        ],
        "135034111": [
            "dumpkmap",
            []
        ],
        "135034125": [
            "egrep",
            []
        ],
        "135034131": [
            "eject",
            []
        ],
        "135034141": [
            "ether-wake",
            []
        ],
        "135034157": [
            "factor",
            []
        ],
        "135034164": [
            "fallocate",
            []
        ],
        "135034174": [
            "false",
            []
        ],
        "135034180": [
            "fbset",
            []
        ],
        "135034186": [
            "fdflush",
            []
        ],
        "135034194": [
            "fdformat",
            []
        ],
        "135034203": [
            "fdisk",
            []
        ],
        "135034209": [
            "fgrep",
            []
        ],
        "135034220": [
            "flock",
            []
        ],
        "135034236": [
            "freeramdisk",
            []
        ],
        "135034253": [
            "fsfreeze",
            []
        ],
        "135034262": [
            "fstrim",
            []
        ],
        "135034269": [
            "fuser",
            []
        ],
        "135034275": [
            "getopt",
            []
        ],
        "135034282": [
            "getty",
            []
        ],
        "135034293": [
            "gunzip",
            []
        ],
        "135034310": [
            "hdparm",
            []
        ],
        "135034322": [
            "hexdump",
            []
        ],
        "135034330": [
            "hexedit",
            []
        ],
        "135034338": [
            "hostid",
            []
        ],
        "135034345": [
            "hostname",
            []
        ],
        "135034354": [
            "hwclock",
            []
        ],
        "135034362": [
            "i2cdetect",
            []
        ],
        "135034372": [
            "i2cdump",
            []
        ],
        "135034380": [
            "i2cget",
            []
        ],
        "135034387": [
            "i2cset",
            []
        ],
        "135034397": [
            "ifconfig",
            []
        ],
        "135034406": [
            "ifdown",
            []
        ],
        "135034418": [
            "inetd",
            []
        ],
        "135034429": [
            "insmod",
            []
        ],
        "135034436": [
            "install",
            []
        ],
        "135034447": [
            "ipaddr",
            []
        ],
        "135034454": [
            "ipcrm",
            []
        ],
        "135034465": [
            "iplink",
            []
        ],
        "135034472": [
            "ipneigh",
            []
        ],
        "135034480": [
            "iproute",
            []
        ],
        "135034488": [
            "iprule",
            []
        ],
        "135034495": [
            "iptunnel",
            []
        ],
        "135034509": [
            "killall",
            []
        ],
        "135034517": [
            "killall5",
            []
        ],
        "135034526": [
            "klogd",
            []
        ],
        "135034547": [
            "linux32",
            []
        ],
        "135034555": [
            "linux64",
            []
        ],
        "135034563": [
            "linuxrc",
            []
        ],
        "135034574": [
            "loadfont",
            []
        ],
        "135034583": [
            "loadkmap",
            []
        ],
        "135034592": [
            "logger",
            []
        ],
        "135034599": [
            "login",
            []
        ],
        "135034605": [
            "logname",
            []
        ],
        "135034613": [
            "losetup",
            []
        ],
        "135034624": [
            "lsattr",
            []
        ],
        "135034631": [
            "lsmod",
            []
        ],
        "135034642": [
            "lspci",
            []
        ],
        "135034648": [
            "lsscsi",
            []
        ],
        "135034655": [
            "lsusb",
            []
        ],
        "135034661": [
            "lzcat",
            []
        ],
        "135034672": [
            "lzopcat",
            []
        ],
        "135034680": [
            "makedevs",
            []
        ],
        "135034689": [
            "md5sum",
            []
        ],
        "135034706": [
            "microcom",
            []
        ],
        "135034715": [
            "mkdir",
            []
        ],
        "135034721": [
            "mkdosfs",
            []
        ],
        "135034729": [
            "mke2fs",
            []
        ],
        "135034736": [
            "mkfifo",
            []
        ],
        "135034743": [
            "mknod",
            []
        ],
        "135034749": [
            "mkpasswd",
            []
        ],
        "135034758": [
            "mkswap",
            []
        ],
        "135034765": [
            "mktemp",
            []
        ],
        "135034772": [
            "modprobe",
            []
        ],
        "135034786": [
            "mount",
            []
        ],
        "135034792": [
            "mountpoint",
            []
        ],
        "135034809": [
            "nameif",
            []
        ],
        "135034816": [
            "netstat",
            []
        ],
        "135034832": [
            "nohup",
            []
        ],
        "135034838": [
            "nproc",
            []
        ],
        "135034844": [
            "nslookup",
            []
        ],
        "135034861": [
            "openvt",
            []
        ],
        "135034868": [
            "partprobe",
            []
        ],
        "135034878": [
            "passwd",
            []
        ],
        "135034885": [
            "paste",
            []
        ],
        "135034891": [
            "patch",
            []
        ],
        "135034897": [
            "pidof",
            []
        ],
        "135034908": [
            "pipe_progress",
            []
        ],
        "135034922": [
            "pivot_root",
            []
        ],
        "135034933": [
            "poweroff",
            []
        ],
        "135034942": [
            "printenv",
            []
        ],
        "135034951": [
            "printf",
            []
        ],
        "135034965": [
            "rdate",
            []
        ],
        "135034971": [
            "readlink",
            []
        ],
        "135034980": [
            "readprofile",
            []
        ],
        "135034992": [
            "realpath",
            []
        ],
        "135035001": [
            "reboot",
            []
        ],
        "135035008": [
            "renice",
            []
        ],
        "135035015": [
            "reset",
            []
        ],
        "135035021": [
            "resize",
            []
        ],
        "135035028": [
            "resume",
            []
        ],
        "135035038": [
            "rmdir",
            []
        ],
        "135035044": [
            "rmmod",
            []
        ],
        "135035050": [
            "route",
            []
        ],
        "135035056": [
            "run-init",
            []
        ],
        "135035065": [
            "run-parts",
            []
        ],
        "135035075": [
            "runlevel",
            []
        ],
        "135035092": [
            "setarch",
            []
        ],
        "135035100": [
            "setconsole",
            []
        ],
        "135035111": [
            "setfattr",
            []
        ],
        "135035120": [
            "setkeycodes",
            []
        ],
        "135035132": [
            "setlogcons",
            []
        ],
        "135035143": [
            "setpriv",
            []
        ],
        "135035151": [
            "setserial",
            []
        ],
        "135035161": [
            "setsid",
            []
        ],
        "135035171": [
            "sha1sum",
            []
        ],
        "135035179": [
            "sha256sum",
            []
        ],
        "135035189": [
            "sha3sum",
            []
        ],
        "135035197": [
            "sha512sum",
            []
        ],
        "135035207": [
            "shred",
            []
        ],
        "135035213": [
            "sleep",
            []
        ],
        "135035224": [
            "start-stop-daemon",
            []
        ],
        "135035242": [
            "strings",
            []
        ],
        "135035258": [
            "sulogin",
            []
        ],
        "135035275": [
            "swapoff",
            []
        ],
        "135035283": [
            "swapon",
            []
        ],
        "135035290": [
            "switch_root",
            []
        ],
        "135035307": [
            "sysctl",
            []
        ],
        "135035314": [
            "syslogd",
            []
        ],
        "135035338": [
            "telnet",
            []
        ],
        "135035364": [
            "touch",
            []
        ],
        "135035373": [
            "traceroute",
            []
        ],
        "135035389": [
            "truncate",
            []
        ],
        "135035402": [
            "ubirename",
            []
        ],
        "135035412": [
            "udhcpc",
            []
        ],
        "135035419": [
            "uevent",
            []
        ],
        "135035426": [
            "umount",
            []
        ],
        "135035433": [
            "uname",
            []
        ],
        "135035444": [
            "unix2dos",
            []
        ],
        "135035453": [
            "unlink",
            []
        ],
        "135035460": [
            "unlzma",
            []
        ],
        "135035467": [
            "unlzop",
            []
        ],
        "135035479": [
            "unzip",
            []
        ],
        "135035485": [
            "uptime",
            []
        ],
        "135035492": [
            "usleep",
            []
        ],
        "135035499": [
            "uudecode",
            []
        ],
        "135035508": [
            "uuencode",
            []
        ],
        "135035517": [
            "vconfig",
            []
        ],
        "135035528": [
            "vlock",
            []
        ],
        "135035536": [
            "watch",
            []
        ],
        "135035542": [
            "watchdog",
            []
        ],
        "135035559": [
            "which",
            []
        ],
        "135035569": [
            "whoami",
            []
        ],
        "135035576": [
            "xargs",
            []
        ],
        "135035589": [
            "xzcat",
            []
        ],
        "135035605": [
            "/var/log/wtmp",
            [
                134908480,
                134953010,
                134952775,
                134740143
            ]
        ],
        "135035619": [
            "PATH=",
            [
                134910945,
                134937940
            ]
        ],
        "135035624": [
            "/sbin:/usr/sbin:",
            [
                134950113,
                134852043
            ]
        ],
        "135035640": [
            "/bin:/usr/bin",
            [
                134708664,
                134950113,
                4294967295
            ]
        ],
        "135035654": [
            "-/bin/sh",
            [
                134909433,
                134910945
            ]
        ],
        "135035663": [
            "/proc/self/exe",
            [
                134684858,
                134532882
            ]
        ],
        "135035679": [
            "123456789ABCDEF",
            []
        ],
        "135035695": [
            "standard output",
            [
                134536576,
                134810574,
                134918727
            ]
        ],
        "135035711": [
            "standard input",
            [
                134843008,
                134885126,
                134829800,
                134828937,
                134954410,
                134841389,
                134810574,
                134840176,
                134882708,
                134807989,
                134848886,
                134954358,
                134580218,
                134573020,
                134817855
            ]
        ],
        "135035726": [
            "invalid argument '%s' to '%s'",
            [
                134635242,
                134810574,
                134650960,
                134902707,
                134810325
            ]
        ],
        "135035756": [
            "%s requires an argument",
            [
                134633890,
                134885126,
                134635242,
                134579024,
                134840176,
                134902707,
                134631317,
                134710171,
                134639324
            ]
        ],
        "135035780": [
            "you must be root",
            [
                134752064,
                134550347,
                134621773
            ]
        ],
        "135035797": [
            "permission denied (are you root?)",
            [
                134750816,
                134540837,
                134542278,
                134612104,
                134750929,
                134541208
            ]
        ],
        "135035831": [
            "can't create raw socket",
            [
                134612104,
                134658017
            ]
        ],
        "135035855": [
            "(unknown)",
            [
                134930260
            ]
        ],
        "135035865": [
            "invalid date '%s'",
            [
                134809595,
                134540132,
                134539261
            ]
        ],
        "135035883": [
            "out of memory",
            [
                134535881,
                134535891,
                134676422,
                134682147
            ]
        ],
        "135035897": [
            "BusyBox v1.29.2 (2024-11-01 02:03:16 UTC)",
            [
                134532546,
                134532882,
                134715303
            ]
        ],
        "135035939": [
            "/dev/tty",
            [
                134574328,
                134806442,
                134542701,
                134677775,
                134546963,
                134749652,
                134535288,
                4294967295
            ]
        ],
        "135035948": [
            "LINES",
            [
                134535288
            ]
        ],
        "135035954": [
            "COLUMNS",
            [
                134535288
            ]
        ],
        "135035962": [
            "waitpid",
            [
                134535852
            ]
        ],
        "135035970": [
            "can't open '%s'",
            [
                134733056,
                134536130,
                134759394,
                134536101,
                134549256,
                134536171,
                134671243,
                134596473,
                134726513,
                134728632,
                134537049,
                134537086,
                134565567
            ]
        ],
        "135035986": [
            "can't remove file '%s'",
            [
                134536232
            ]
        ],
        "135036009": [
            "can't move '%s' to '%s'",
            [
                134536259
            ]
        ],
        "135036033": [
            "can't create pipe",
            [
                134536293
            ]
        ],
        "135036051": [
            "can't duplicate file descriptor",
            [
                134536315
            ]
        ],
        "135036083": [
            "short write",
            [
                134536365
            ]
        ],
        "135036095": [
            "write error",
            [
                134538016,
                134611811,
                134882467,
                134620197,
                134828937,
                134536365,
                134813978
            ]
        ],
        "135036107": [
            "close failed",
            [
                134536435
            ]
        ],
        "135036120": [
            "lseek(%llu)",
            [
                134536457
            ]
        ],
        "135036132": [
            "lseek",
            [
                134536457
            ]
        ],
        "135036138": [
            "can't create temp file '%s'",
            [
                134536532
            ]
        ],
        "135036166": [
            "%s: I/O error",
            [
                134595309,
                134536559
            ]
        ],
        "135036180": [
            "setgid",
            [
                134536798,
                4294967295
            ]
        ],
        "135036187": [
            "setuid",
            [
                134536820,
                4294967295
            ]
        ],
        "135036194": [
            "setegid",
            [
                134536842
            ]
        ],
        "135036202": [
            "seteuid",
            [
                134536864
            ]
        ],
        "135036210": [
            "can't change directory to '%s'",
            [
                134548025,
                134536964,
                134950113
            ]
        ],
        "135036241": [
            "fchdir",
            [
                134536991
            ]
        ],
        "135036248": [
            "can't change root directory to '%s'",
            [
                134537013
            ]
        ],
        "135036284": [
            "sendto",
            [
                134656745,
                134537165
            ]
        ],
        "135036291": [
            "can't stat '%s'",
            [
                134849895,
                134948617,
                134777484,
                134537203,
                134913143
            ]
        ],
        "135036307": [
            "/dev/urandom",
            [
                134537473,
                134835234
            ]
        ],
        "135036326": [
            "not a symlink",
            [
                134537825
            ]
        ],
        "135036340": [
            "%s: cannot read link: %s",
            [
                134537825
            ]
        ],
        "135036365": [
            "short read",
            [
                134798509,
                134753743,
                134740143,
                134948086,
                134797560,
                134538522
            ]
        ],
        "135036376": [
            "clock_gettime(MONOTONIC) failed",
            [
                134539230
            ]
        ],
        "135036411": [
            "%u.%u-%u:%u%c",
            [
                134539261
            ]
        ],
        "135036425": [
            "%u-%u-%u ",
            [
                134539261
            ]
        ],
        "135036434": [
            "%u:%u%c",
            [
                134539261
            ]
        ],
        "135036442": [
            "%b %d %T %Y",
            [
                134539261
            ]
        ],
        "135036454": [
            "%u-%u-%u ",
            [
                134539261
            ]
        ],
        "135036468": [
            "%u-%u-%u%c",
            [
                134539261
            ]
        ],
        "135036491": [
            "%2u%c",
            [
                134539261
            ]
        ],
        "135036497": [
            "%4u%2u%2u%2u%2u%c",
            [
                134539261
            ]
        ],
        "135036515": [
            "%Y-%m-%d ",
            [
                134540207
            ]
        ],
        "135036524": [
            "%H:%M:%S",
            [
                134540160
            ]
        ],
        "135036533": [
            "%s '%s' in use",
            [
                134541208,
                134540837
            ]
        ],
        "135036548": [
            "no %cids left",
            [
                134541208,
                134540837
            ]
        ],
        "135036562": [
            "x:%u:",
            [
                134540837
            ]
        ],
        "135036568": [
            "/etc/group",
            [
                134540837,
                134542278
            ]
        ],
        "135036583": [
            "/etc/gshadow",
            [
                134540837,
                134542278
            ]
        ],
        "135036601": [
            "-1:?2",
            []
        ],
        "135036612": [
            "gsystem",
            []
        ],
        "135036623": [
            "addgroup",
            [
                134541109
            ]
        ],
        "135036632": [
            "--gid",
            [
                134541109
            ]
        ],
        "135036638": [
            "/etc/skel",
            [
                134541208
            ]
        ],
        "135036648": [
            "Linux User,,,",
            [
                134541208
            ]
        ],
        "135036662": [
            "/home/%s",
            [
                134541208
            ]
        ],
        "135036671": [
            "nogroup",
            [
                134541208
            ]
        ],
        "135036679": [
            "/bin/false",
            [
                134541208
            ]
        ],
        "135036695": [
            "x:%u:%u:%s:%s:%s",
            [
                134541208
            ]
        ],
        "135036712": [
            "/etc/passwd",
            [
                134541208,
                134545245,
                134542278
            ]
        ],
        "135036724": [
            "!:%u:0:99999:7:::",
            [
                134541208
            ]
        ],
        "135036742": [
            "/etc/shadow",
            [
                134541208,
                134545245,
                134542278
            ]
        ],
        "135036754": [
            "chown",
            [
                134541208,
                4294967295
            ]
        ],
        "135036763": [
            "can't execute passwd, you must set password manually",
            [
                134541208
            ]
        ],
        "135036816": [
            "^h:g:s:G:DSHu:k:",
            [
                134541208
            ]
        ],
        "135036833": [
            "-1:?2:SD",
            []
        ],
        "135036848": [
            "hgecos",
            []
        ],
        "135036856": [
            "gshell",
            []
        ],
        "135036864": [
            "singroup",
            []
        ],
        "135036874": [
            "Gdisabled-password",
            []
        ],
        "135036894": [
            "Dempty-password",
            []
        ],
        "135036911": [
            "Dsystem",
            []
        ],
        "135036920": [
            "Sno-create-home",
            []
        ],
        "135036943": [
            "uskel",
            []
        ],
        "135036956": [
            "Password: ",
            [
                134542064,
                134914929
            ]
        ],
        "135036967": [
            "^sP:+S:m:a:",
            [
                134542064
            ]
        ],
        "135036982": [
            "stdin",
            [
                134542064
            ]
        ],
        "135036989": [
            "spassword-fd",
            []
        ],
        "135037003": [
            "Psalt",
            []
        ],
        "135037010": [
            "Smethod",
            []
        ],
        "135037021": [
            "'%s' still has '%s' as their primary group!",
            [
                134542278
            ]
        ],
        "135037065": [
            "remove-home",
            [
                134542278
            ]
        ],
        "135037080": [
            "tcsetattr",
            [
                134542581
            ]
        ],
        "135037090": [
            "/bin/login",
            [
                134542701
            ]
        ],
        "135037101": [
            "/etc/issue",
            [
                134542701
            ]
        ],
        "135037112": [
            "bad speed: %s",
            [
                134542701
            ]
        ],
        "135037126": [
            "too many alternate speeds",
            [
                134542701
            ]
        ],
        "135037152": [
            "setsid",
            [
                134542701
            ]
        ],
        "135037159": [
            "/dev/%s",
            [
                134852264,
                134728989,
                134542701
            ]
        ],
        "135037167": [
            "stdin is not open for read/write",
            [
                134542701
            ]
        ],
        "135037200": [
            "getty: %s",
            [
                134542701
            ]
        ],
        "135037210": [
            "TIOCSCTTY",
            [
                134542701
            ]
        ],
        "135037220": [
            "tcsetpgrp",
            [
                134542701
            ]
        ],
        "135037230": [
            "tcgetattr",
            [
                134542701
            ]
        ],
        "135037240": [
            "LOGIN",
            [
                134542701,
                134740143
            ]
        ],
        "135037250": [
            "can't execute '%s'",
            [
                134780933,
                134550215,
                134601161,
                134851051,
                134918636,
                134542701,
                134758285,
                134850351,
                134949712
            ]
        ],
        "135037269": [
            "^I:LH:f:hil:mt:+wn",
            [
                134542701
            ]
        ],
        "135037291": [
            "\r\nLogin timed out after %u seconds\r\n",
            [
                134544238
            ]
        ],
        "135037328": [
            "f:h:p",
            [
                134544292
            ]
        ],
        "135037334": [
            "-f is for root only",
            [
                134544292
            ]
        ],
        "135037354": [
            "UNKNOWN",
            [
                134753221,
                134608289,
                134544292,
                134607124
            ]
        ],
        "135037362": [
            " on '%s' from '%s'",
            [
                134544292
            ]
        ],
        "135037381": [
            " on '%s'",
            [
                134544292
            ]
        ],
        "135037390": [
            "Login incorrect",
            [
                134546659,
                134544292
            ]
        ],
        "135037406": [
            "invalid password for '%s'%s",
            [
                134544292
            ]
        ],
        "135037434": [
            "/etc/nologin",
            [
                134544292
            ]
        ],
        "135037447": [
            "\r\nSystem closed for routine maintenance\r",
            [
                134544292
            ]
        ],
        "135037488": [
            ".hushlogin",
            [
                134544292
            ]
        ],
        "135037499": [
            "/etc/motd",
            [
                134544292
            ]
        ],
        "135037509": [
            "root login%s",
            [
                134544292
            ]
        ],
        "135037522": [
            "a:lud",
            [
                134545245
            ]
        ],
        "135037528": [
            "%s can't change password for %s",
            [
                134545245
            ]
        ],
        "135037560": [
            "no record of %s in %s, using %s",
            [
                134545245
            ]
        ],
        "135037592": [
            "can't change locked password for %s",
            [
                134545245
            ]
        ],
        "135037628": [
            "Changing password for %s\n",
            [
                134545245
            ]
        ],
        "135037654": [
            "Old password: ",
            [
                134545245
            ]
        ],
        "135037669": [
            "incorrect password for %s",
            [
                134545245
            ]
        ],
        "135037695": [
            "Incorrect password",
            [
                134546963,
                134545245
            ]
        ],
        "135037714": [
            "New password: ",
            [
                134545245
            ]
        ],
        "135037729": [
            "Retype password: ",
            [
                134545245
            ]
        ],
        "135037747": [
            "Passwords don't match",
            [
                134545245
            ]
        ],
        "135037769": [
            "password for %s is unchanged",
            [
                134545245
            ]
        ],
        "135037802": [
            "can't update password file %s",
            [
                134545245
            ]
        ],
        "135037832": [
            "password for %s changed by %s",
            [
                134545245
            ]
        ],
        "135037862": [
            "password for %s is already %slocked",
            [
                134545245
            ]
        ],
        "135037903": [
            "mplc:s:",
            [
                134546164
            ]
        ],
        "135037911": [
            "%c %s %s:%s",
            [
                134546164
            ]
        ],
        "135037923": [
            "incorrect password",
            [
                134546164
            ]
        ],
        "135037945": [
            "using restricted shell",
            [
                134546164
            ]
        ],
        "135037972": [
            "no password entry for root",
            [
                134546659
            ]
        ],
        "135037999": [
            "Give root password for system maintenance\n(or type Control-D for normal startup):",
            [
                134546659
            ]
        ],
        "135038081": [
            "normal startup",
            [
                134546659
            ]
        ],
        "135038096": [
            "starting shell for system maintenance",
            [
                134546659
            ]
        ],
        "135038136": [
            "SHELL",
            [
                134548025,
                134920313,
                134546164,
                134950113
            ]
        ],
        "135038142": [
            "sushell",
            [
                134546659
            ]
        ],
        "135038150": [
            "VT_GETMODE",
            [
                134546963
            ]
        ],
        "135038161": [
            "Virtual console%s locked by %s.\n",
            [
                134546963
            ]
        ],
        "135038200": [
            "user %s: parse error at %s",
            [
                134547566
            ]
        ],
        "135038227": [
            "can't get uid for %s",
            [
                134548025
            ]
        ],
        "135038248": [
            "LOGNAME",
            [
                134548025,
                134950113
            ]
        ],
        "135038266": [
            "child running %s",
            [
                134548025
            ]
        ],
        "135038283": [
            "/var/spool/cron",
            [
                134548025
            ]
        ],
        "135038299": [
            "can't execute '%s' for user %s",
            [
                134548025
            ]
        ],
        "135038330": [
            "USER %s pid %3d cmd %s",
            [
                134548341
            ]
        ],
        "135038353": [
            "ignoring file '%s' (no such user)",
            [
                134548440,
                134548460
            ]
        ],
        "135038387": [
            "user %s: too many lines",
            [
                134548460
            ]
        ],
        "135038415": [
            "user:%s entry:%s",
            [
                134548460
            ]
        ],
        "135038432": [
            "MAILTO=",
            [
                134548460
            ]
        ],
        "135038440": [
            "SHELL=",
            [
                134548460
            ]
        ],
        "135038447": [
            "cron.update",
            [
                134549256,
                134549386,
                134550347
            ]
        ],
        "135038459": [
            "/var/spool/cron/crontabs",
            [
                134549386,
                134550347
            ]
        ],
        "135038484": [
            "crond (busybox 1.29.2) started, log level %d",
            [
                134549386
            ]
        ],
        "135038529": [
            "/crond.reboot",
            [
                134549386
            ]
        ],
        "135038543": [
            "wakeup dt=%ld",
            [
                134549386
            ]
        ],
        "135038557": [
            "time disparity of %ld minutes detected",
            [
                134549386
            ]
        ],
        "135038596": [
            "file %s:",
            [
                134549386
            ]
        ],
        "135038605": [
            " line %s",
            [
                134549386
            ]
        ],
        "135038614": [
            " job: %d %s",
            [
                134549386
            ]
        ],
        "135038626": [
            "user %s: process already running: %s",
            [
                134549386
            ]
        ],
        "135038663": [
            "^l:L:fbSc:",
            [
                134549386
            ]
        ],
        "135038674": [
            "f-b:b-f:S-L:L-S:l+",
            []
        ],
        "135038693": [
            "yearly",
            [
                4294967295
            ]
        ],
        "135038700": [
            "annually",
            [
                4294967295
            ]
        ],
        "135038709": [
            "monthly",
            [
                4294967295
            ]
        ],
        "135038717": [
            "weekly",
            [
                4294967295
            ]
        ],
        "135038724": [
            "daily",
            [
                4294967295
            ]
        ],
        "135038730": [
            "midnight",
            [
                4294967295
            ]
        ],
        "135038739": [
            "hourly",
            [
                4294967295
            ]
        ],
        "135038746": [
            "janfebmaraprmayjunjulaugsepoctnovdec",
            [
                134548460
            ]
        ],
        "135038783": [
            "sunmontuewedthufrisat",
            [
                134548460
            ]
        ],
        "135038805": [
            "VISUAL",
            [
                134550215
            ]
        ],
        "135038812": [
            "EDITOR",
            [
                134550215
            ]
        ],
        "135038819": [
            "%s.%u",
            [
                134550347
            ]
        ],
        "135038825": [
            "%s.new",
            [
                134550347
            ]
        ],
        "135038832": [
            "can't create %s/%s",
            [
                134550347
            ]
        ],
        "135038851": [
            "can't append to %s/%s",
            [
                134550347
            ]
        ],
        "135038873": [
            "^u:c:lerd",
            [
                134550347
            ]
        ],
        "135038883": [
            "?1:dr",
            []
        ],
        "135038889": [
            "stack underflow",
            [
                4294967295,
                134550911
            ]
        ],
        "135038905": [
            "stack overflow",
            [
                134550960
            ]
        ],
        "135038920": [
            "syntax error at '%s'",
            [
                134552384
            ]
        ],
        "135038941": [
            "error, base %u is not supported",
            [
                4294967295
            ]
        ],
        "135038977": [
            "%llx\n",
            [
                134552627
            ]
        ],
        "135038983": [
            "%llo\n",
            [
                134552627
            ]
        ],
        "135038994": [
            "/dev/mem",
            [
                134553185
            ]
        ],
        "135039008": [
            "bad width",
            [
                134553185
            ]
        ],
        "135039018": [
            "0x%0*llX\n",
            [
                134553185
            ]
        ],
        "135039038": [
            "\t%-20s",
            [
                134553796
            ]
        ],
        "135039045": [
            "*%cdma%u ",
            [
                134553895
            ]
        ],
        "135039055": [
            " (on)",
            [
                134554008,
                134559882,
                134559923
            ]
        ],
        "135039061": [
            " (off)",
            [
                134554008,
                134559882,
                134559923
            ]
        ],
        "135039068": [
            " %s\t= %2lu",
            [
                134554008
            ]
        ],
        "135039079": [
            "unknown",
            [
                134554049,
                134847240,
                134578505,
                134559923,
                134644979,
                134649077,
                4294967295
            ]
        ],
        "135039092": [
            "\n\tLikely used CD-ROM ATAPI-1",
            [
                134554049
            ]
        ],
        "135039125": [
            "<=10ms with INTRQ",
            [
                134554049
            ]
        ],
        "135039148": [
            "12 bytes",
            [
                134554049
            ]
        ],
        "135039157": [
            "16 bytes",
            [
                134554049
            ]
        ],
        "135039170": [
            "(may be)",
            [
                134554049
            ]
        ],
        "135039179": [
            "single port, single-sector",
            [
                134554049
            ]
        ],
        "135039206": [
            " with read caching ability",
            [
                134554049
            ]
        ],
        "135039233": [
            "dual port, multi-sector",
            [
                134554049
            ]
        ],
        "135039257": [
            "standard",
            [
                134554049
            ]
        ],
        "135039266": [
            "vendor",
            [
                134554049,
                134576324
            ]
        ],
        "135039286": [
            "maximum",
            [
                134554049
            ]
        ],
        "135039299": [
            " determined by the jumper",
            [
                134554049
            ]
        ],
        "135039325": [
            " determined by CSEL",
            [
                134554049
            ]
        ],
        "135039345": [
            "above",
            [
                134554049
            ]
        ],
        "135039351": [
            "below",
            [
                134554049
            ]
        ],
        "135039357": [
            " and required by some commands",
            [
                134554049
            ]
        ],
        "135039388": [
            "disabled",
            [
                134554049,
                134559923,
                134558382
            ]
        ],
        "135039397": [
            "CompactFlash ",
            [
                134554049
            ]
        ],
        "135039410": [
            "ATA device, with ",
            [
                134554049
            ]
        ],
        "135039428": [
            "ATAPI %s, with ",
            [
                134554049
            ]
        ],
        "135039444": [
            "unknown device type",
            [
                134554049
            ]
        ],
        "135039464": [
            "%sremovable media\n",
            [
                134554049
            ]
        ],
        "135039483": [
            "powers-up in standby; SET FEATURES subcmd spins-up.",
            [
                134554049
            ]
        ],
        "135039535": [
            "\n\tWARNING: ID response incomplete.\n\tFollowing data may be incorrect.\n",
            [
                134554049
            ]
        ],
        "135039605": [
            "Model Number:",
            [
                134554049
            ]
        ],
        "135039619": [
            "Serial Number:",
            [
                134554049
            ]
        ],
        "135039634": [
            "Firmware Revision:",
            [
                134554049
            ]
        ],
        "135039653": [
            "Media Serial Num:",
            [
                134554049
            ]
        ],
        "135039671": [
            "Media Manufacturer:",
            [
                134554049
            ]
        ],
        "135039691": [
            "Standards:",
            [
                134554049
            ]
        ],
        "135039702": [
            "\n\tUsed: %s ",
            [
                134554049
            ]
        ],
        "135039714": [
            "\n\tSupported: ",
            [
                134554049
            ]
        ],
        "135039728": [
            "\n\tLikely used: %u\n",
            [
                134554049
            ]
        ],
        "135039747": [
            "& some of %u\n",
            [
                134554049
            ]
        ],
        "135039761": [
            "\n\tUsed: ATAPI for CD-ROMs, SFF-8020i, r2.5",
            [
                134554049
            ]
        ],
        "135039804": [
            "\n\tSupported: CD-ROM ATAPI",
            [
                134554049
            ]
        ],
        "135039835": [
            "Configuration:",
            [
                134554049
            ]
        ],
        "135039850": [
            "\tDRQ response: %s\n\tPacket size: ",
            [
                134554049
            ]
        ],
        "135039883": [
            "\tCHS addressing not supported",
            [
                134554049
            ]
        ],
        "135039913": [
            "\tLogical\t\tmax\tcurrent\n\tcylinders\t%u\t%u\n\theads\t\t%u\t%u\n\tsectors/track\t%u\t%u\n\t--\n",
            [
                134554049
            ]
        ],
        "135039992": [
            "\tbytes/track: %u\tbytes/sector: %u\n",
            [
                134554049
            ]
        ],
        "135040027": [
            "\tCHS current addressable sectors:%11u\n",
            [
                134554049
            ]
        ],
        "135040066": [
            "\tLBA    user addressable sectors:%11u\n",
            [
                134554049
            ]
        ],
        "135040105": [
            "\tLBA48  user addressable sectors:%11llu\n",
            [
                134554049
            ]
        ],
        "135040146": [
            "\tdevice size with M = 1024*1024: %11llu MBytes\n",
            [
                134554049
            ]
        ],
        "135040194": [
            "\tdevice size with M = 1000*1000: %11llu MBytes ",
            [
                134554049
            ]
        ],
        "135040242": [
            "(%llu GB)\n",
            [
                134554049
            ]
        ],
        "135040253": [
            "Capabilities:\n\t",
            [
                134554049
            ]
        ],
        "135040269": [
            "Cmd queuing, ",
            [
                134554049
            ]
        ],
        "135040283": [
            "Cmd overlap, ",
            [
                134554049
            ]
        ],
        "135040297": [
            "LBA, ",
            [
                134554049
            ]
        ],
        "135040303": [
            "IORDY%s(can%s be disabled)\n",
            [
                134554049
            ]
        ],
        "135040331": [
            "no IORDY",
            [
                134554049
            ]
        ],
        "135040340": [
            "\tBuffer type: %04x: %s%s\n",
            [
                134554049
            ]
        ],
        "135040366": [
            "\tBuffer size: %.1fkB\n",
            [
                134554049
            ]
        ],
        "135040388": [
            "\tbytes avail on r/w long: %u\n",
            [
                134554049
            ]
        ],
        "135040418": [
            "\tQueue depth: %u\n",
            [
                134554049
            ]
        ],
        "135040436": [
            "\tCan%s perform double-word IO\n",
            [
                134554049
            ]
        ],
        "135040467": [
            "\tStandby timer values: spec'd by %s",
            [
                134554049
            ]
        ],
        "135040503": [
            ", %s device specific minimum\n",
            [
                134554049
            ]
        ],
        "135040533": [
            "\tR/W multiple sector transfer: ",
            [
                134554049
            ]
        ],
        "135040565": [
            "Max = %u\tCurrent = ",
            [
                134554049
            ]
        ],
        "135040585": [
            "\tAdvancedPM level: ",
            [
                134554049
            ]
        ],
        "135040605": [
            "%u (0x%x)\n",
            [
                134554049
            ]
        ],
        "135040616": [
            "unknown setting (0x%04x)\n",
            [
                134554049
            ]
        ],
        "135040642": [
            "\tRecommended acoustic management value: %u, current value: %u\n",
            [
                134554049
            ]
        ],
        "135040705": [
            "\tATA sw reset required",
            [
                134554049
            ]
        ],
        "135040728": [
            "\tOverlap support:",
            [
                134554049
            ]
        ],
        "135040746": [
            " %uus to release bus.",
            [
                134554049
            ]
        ],
        "135040768": [
            " %uus to clear BSY after SERVICE cmd.",
            [
                134554049
            ]
        ],
        "135040806": [
            "\tDMA: ",
            [
                134554049
            ]
        ],
        "135040813": [
            " sdma%u\n",
            [
                134554049
            ]
        ],
        "135040826": [
            "\t\tInterleaved DMA support",
            [
                134554049
            ]
        ],
        "135040852": [
            "\t\tCycle time:",
            [
                134554049
            ]
        ],
        "135040866": [
            " min=%uns",
            [
                134554049
            ]
        ],
        "135040876": [
            " recommended=%uns",
            [
                134554049
            ]
        ],
        "135040894": [
            "\tPIO: ",
            [
                134554049
            ]
        ],
        "135040901": [
            "pio%d ",
            [
                134554049
            ]
        ],
        "135040908": [
            " no flow control=%uns",
            [
                134554049
            ]
        ],
        "135040930": [
            "  IORDY flow control=%uns",
            [
                134554049
            ]
        ],
        "135040956": [
            "Commands/features:\n\tEnabled\tSupported:",
            [
                134554049
            ]
        ],
        "135040995": [
            "\t%s supported\n",
            [
                134554049
            ]
        ],
        "135041010": [
            "Security:",
            [
                134554049
            ]
        ],
        "135041020": [
            "\tMaster password revision code = %u\n",
            [
                134554049
            ]
        ],
        "135041057": [
            "\tSecurity level %s\n",
            [
                134554049
            ]
        ],
        "135041077": [
            "%umin for %sSECURITY ERASE UNIT. ",
            [
                134554049
            ]
        ],
        "135041111": [
            "ENHANCED ",
            [
                134554049
            ]
        ],
        "135041121": [
            "HW reset results:\n\tCBLID- %s Vih\n\tDevice num = %i%s\n",
            [
                134554049
            ]
        ],
        "135041174": [
            "CFA power mode 1:\n\t%s%s\n",
            [
                134554049
            ]
        ],
        "135041199": [
            "\tMaximum current = %uma\n",
            [
                134554049
            ]
        ],
        "135041224": [
            "Checksum: %scorrect\n",
            [
                134554049
            ]
        ],
        "135041245": [
            "bad char: '%c' 0x%02x",
            [
                134558242
            ]
        ],
        "135041271": [
            "on/off",
            [
                134558382
            ]
        ],
        "135041278": [
            "\n Model=%.40s, FwRev=%.8s, SerialNo=%.20s\n Config={",
            [
                134558382
            ]
        ],
        "135041330": [
            " }\n RawCHS=%u/%u/%u, TrkSize=%u, SectSize=%u, ECCbytes=%u\n BuffType=(%u) %s, BuffSize=%ukB, MaxMultSect=%u",
            [
                134558382
            ]
        ],
        "135041437": [
            ", MultSect=",
            [
                134558382
            ]
        ],
        "135041454": [
            " (maybe):",
            [
                134558382
            ]
        ],
        "135041464": [
            " CurCHS=%u/%u/%u, CurSects=%lu, LBA=%s",
            [
                134558382
            ]
        ],
        "135041503": [
            ", LBAsects=%u",
            [
                134558382
            ]
        ],
        "135041517": [
            "\n IORDY=%s",
            [
                134558382
            ]
        ],
        "135041528": [
            ", tPIO={min:%u,w/IORDY:%u}",
            [
                134558382
            ]
        ],
        "135041555": [
            ", tDMA={min:%u,rec:%u}",
            [
                134558382
            ]
        ],
        "135041578": [
            "\n PIO modes:  ",
            [
                134558382
            ]
        ],
        "135041593": [
            "pio0 ",
            [
                134558382
            ]
        ],
        "135041599": [
            "pio1 ",
            [
                134558382
            ]
        ],
        "135041605": [
            "pio2 ",
            [
                134558382
            ]
        ],
        "135041611": [
            "\n DMA modes:  ",
            [
                134558382
            ]
        ],
        "135041626": [
            "\n UDMA modes: ",
            [
                134558382
            ]
        ],
        "135041641": [
            "\n AdvancedPM=%s",
            [
                134558382
            ]
        ],
        "135041657": [
            ": disabled (255)",
            [
                134558382
            ]
        ],
        "135041674": [
            ": unknown setting",
            [
                134558382
            ]
        ],
        "135041692": [
            ": mode=0x%02X (%u)",
            [
                134558382
            ]
        ],
        "135041711": [
            " WriteCache=%s",
            [
                134558382
            ]
        ],
        "135041726": [
            "\n Drive conforms to: %s: ",
            [
                134558382
            ]
        ],
        "135041752": [
            " ATA/ATAPI-%u",
            [
                134558382
            ]
        ],
        "135041766": [
            "\n\n * current active mode\n",
            [
                134558382
            ]
        ],
        "135041794": [
            "sdma0 ",
            []
        ],
        "135041803": [
            "sdma1 ",
            []
        ],
        "135041812": [
            "sdma2 ",
            []
        ],
        "135041821": [
            "sdma? ",
            []
        ],
        "135041831": [
            "mdma0 ",
            []
        ],
        "135041840": [
            "mdma1 ",
            []
        ],
        "135041849": [
            "mdma2 ",
            []
        ],
        "135041858": [
            "mdma? ",
            []
        ],
        "135041868": [
            "udma3 ",
            []
        ],
        "135041877": [
            "udma4 ",
            []
        ],
        "135041886": [
            "udma5 ",
            []
        ],
        "135041895": [
            "udma6 ",
            []
        ],
        "135041904": [
            "udma7 ",
            []
        ],
        "135041914": [
            "udma0 ",
            []
        ],
        "135041923": [
            "udma1 ",
            []
        ],
        "135041932": [
            "udma2 ",
            []
        ],
        "135041940": [
            "pio3 ",
            [
                4294967295
            ]
        ],
        "135041946": [
            "pio4 ",
            []
        ],
        "135041952": [
            "pio? ",
            []
        ],
        "135041959": [
            "BLKFLSBUF",
            [
                134559335
            ]
        ],
        "135041969": [
            "HDIO_DRIVE_CMD",
            [
                134559825,
                134559923,
                134559335
            ]
        ],
        "135041984": [
            "mlock",
            [
                134559414
            ]
        ],
        "135041990": [
            "Timing buffer-cache reads: ",
            [
                134559414
            ]
        ],
        "135042018": [
            "Timing buffered disk reads:",
            [
                134559414
            ]
        ],
        "135042046": [
            "BLKGETSIZE",
            [
                134559923,
                134559414
            ]
        ],
        "135042057": [
            "%5u MB in %u.%02u seconds = %u kB/s\n",
            [
                134559414
            ]
        ],
        "135042094": [
            " setting %s to %lu",
            [
                134559882
            ]
        ],
        "135042113": [
            "sleeping",
            [
                134559923
            ]
        ],
        "135042122": [
            "standby",
            [
                134559923
            ]
        ],
        "135042130": [
            "active/idle",
            [
                134559923
            ]
        ],
        "135042142": [
            "\n%s:\n",
            [
                134857186,
                134559923
            ]
        ],
        "135042148": [
            "fs readahead",
            [
                134559923
            ]
        ],
        "135042161": [
            " setting %s to %lu\n",
            [
                134559923
            ]
        ],
        "135042181": [
            "BLKRASET",
            [
                134559923
            ]
        ],
        "135042190": [
            " attempting to ",
            [
                134559923
            ]
        ],
        "135042206": [
            "auto-tune PIO mode",
            [
                134559923
            ]
        ],
        "135042225": [
            "set PIO mode to %d\n",
            [
                134559923
            ]
        ],
        "135042245": [
            "set MDMA mode to %d\n",
            [
                134559923
            ]
        ],
        "135042266": [
            "set UDMA mode to %d\n",
            [
                134559923
            ]
        ],
        "135042287": [
            "HDIO_SET_PIO_MODE",
            [
                134559923
            ]
        ],
        "135042305": [
            "32-bit IO_support flag",
            [
                134559923
            ]
        ],
        "135042328": [
            "HDIO_SET_32BIT",
            [
                134559923
            ]
        ],
        "135042343": [
            "multcount",
            [
                134559923
            ]
        ],
        "135042353": [
            "HDIO_SET_MULTCOUNT",
            [
                134559923
            ]
        ],
        "135042372": [
            "BLKROSET",
            [
                134559923
            ]
        ],
        "135042381": [
            "unmaskirq",
            [
                134559923
            ]
        ],
        "135042391": [
            "HDIO_SET_UNMASKINTR",
            [
                134559923
            ]
        ],
        "135042411": [
            "DMA queue_depth",
            [
                134559923
            ]
        ],
        "135042427": [
            "HDIO_SET_QDMA",
            [
                134559923
            ]
        ],
        "135042441": [
            "nowerr",
            [
                134559923
            ]
        ],
        "135042448": [
            "HDIO_SET_NOWERR",
            [
                134559923
            ]
        ],
        "135042464": [
            "keep_settings",
            [
                134559923
            ]
        ],
        "135042478": [
            "HDIO_SET_KEEPSETTINGS",
            [
                134559923
            ]
        ],
        "135042500": [
            "drive doorlock",
            [
                134559923
            ]
        ],
        "135042515": [
            "drive keep features",
            [
                134559923
            ]
        ],
        "135042535": [
            "drive defect-mgmt",
            [
                134559923
            ]
        ],
        "135042553": [
            "drive prefetch",
            [
                134559923
            ]
        ],
        "135042568": [
            "xfermode",
            [
                134559923
            ]
        ],
        "135042577": [
            "default PIO mode",
            [
                134559923
            ]
        ],
        "135042594": [
            "default PIO mode, disable IORDY",
            [
                134559923
            ]
        ],
        "135042626": [
            "PIO flow control mode%u",
            [
                134559923
            ]
        ],
        "135042650": [
            "singleword DMA mode%u",
            [
                134559923
            ]
        ],
        "135042672": [
            "multiword DMA mode%u",
            [
                134559923
            ]
        ],
        "135042693": [
            "UltraDMA mode%u",
            [
                134559923
            ]
        ],
        "135042709": [
            "drive read-lookahead",
            [
                134559923
            ]
        ],
        "135042730": [
            " setting APM level to %s 0x%02lX (%ld)\n",
            [
                134559923
            ]
        ],
        "135042770": [
            "drive write-caching",
            [
                134559923
            ]
        ],
        "135042790": [
            " issuing standby command",
            [
                134559923
            ]
        ],
        "135042815": [
            " issuing sleep command",
            [
                134559923
            ]
        ],
        "135042838": [
            " disabling Seagate auto powersaving mode",
            [
                134559923
            ]
        ],
        "135042879": [
            "%u minutes %u seconds",
            [
                134559923
            ]
        ],
        "135042901": [
            "%u.%c hours",
            [
                134559923
            ]
        ],
        "135042913": [
            "vendor-specific",
            [
                134559923
            ]
        ],
        "135042929": [
            "reserved",
            [
                134559923
            ]
        ],
        "135042938": [
            "HDIO_GET_MULTCOUNT",
            [
                134559923
            ]
        ],
        "135042957": [
            "ioctl %#x failed",
            [
                134559923
            ]
        ],
        "135042974": [
            " %s\t= %2ld",
            [
                134559923
            ]
        ],
        "135042985": [
            "HDIO_GET_32BIT",
            [
                134559923
            ]
        ],
        "135043000": [
            " IO_support\t=%3ld (",
            [
                134559923
            ]
        ],
        "135043020": [
            "default 16-bit)",
            [
                134559923
            ]
        ],
        "135043036": [
            "32-bit)",
            [
                134559923
            ]
        ],
        "135043044": [
            "32-bit w/sync)",
            [
                134559923
            ]
        ],
        "135043059": [
            "Request-Queue-Bypass)",
            [
                134559923
            ]
        ],
        "135043086": [
            "HDIO_GET_UNMASKINTR",
            [
                134559923
            ]
        ],
        "135043106": [
            "HDIO_GET_QDMA",
            [
                134559923
            ]
        ],
        "135043120": [
            "HDIO_GET_KEEPSETTINGS",
            [
                134559923
            ]
        ],
        "135043142": [
            "keepsettings",
            [
                134559923
            ]
        ],
        "135043155": [
            "HDIO_GET_NOWERR",
            [
                134559923
            ]
        ],
        "135043171": [
            "BLKROGET",
            [
                134559923
            ]
        ],
        "135043180": [
            "BLKRAGET",
            [
                134559923
            ]
        ],
        "135043189": [
            "HDIO_GETGEO",
            [
                134559923
            ]
        ],
        "135043201": [
            " geometry\t= %u/%u/%u, sectors = %ld, start = %ld\n",
            [
                134559923
            ]
        ],
        "135043251": [
            " drive state is:  %s\n",
            [
                134559923
            ]
        ],
        "135043273": [
            " no identification info available",
            [
                134559923
            ]
        ],
        "135043307": [
            "HDIO_GET_IDENTITY",
            [
                134559923
            ]
        ],
        "135043325": [
            "BLKRRPART",
            [
                134559923
            ]
        ],
        "135043335": [
            "gfu::n::p:r::m::c::k::a::B:tTiIS:D:P:X:K:A:L:W:CyYzZQ:",
            [
                134562667
            ]
        ],
        "135043430": [
            "sdma0sdma1sdma2sdma3sdma4sdma5sdma6sdma7mdma0mdma1mdma2mdma3mdma4mdma5mdma6mdma7udma0udma1udma2udma3udma4udma5udma6udma7",
            []
        ],
        "135043566": [
            " !\"#$%&'@ABCDEFG",
            []
        ],
        "135043582": [
            "unknown",
            [
                134558382
            ]
        ],
        "135043590": [
            "1Sect",
            []
        ],
        "135043596": [
            "DualPort",
            []
        ],
        "135043605": [
            "DualPortCache",
            []
        ],
        "135043765": [
            "supported",
            [
                134554049
            ]
        ],
        "135043775": [
            "enabled",
            []
        ],
        "135043783": [
            "locked",
            []
        ],
        "135043790": [
            "frozen",
            []
        ],
        "135043797": [
            "expired: security count",
            []
        ],
        "135043821": [
            "supported: enhanced erase",
            []
        ],
        "135044727": [
            "Unspecified",
            [
                134554049,
                134558382
            ]
        ],
        "135044739": [
            "ATA-1 X3T9.2 781D prior to rev.4",
            []
        ],
        "135044772": [
            "ATA-1 published, ANSI X3.221-1994",
            []
        ],
        "135044806": [
            "ATA-1 X3T9.2 781D rev.4",
            []
        ],
        "135044830": [
            "ATA-2 published, ANSI X3.279-1996",
            []
        ],
        "135044864": [
            "ATA-2 X3T10 948D prior to rev.2k",
            []
        ],
        "135044897": [
            "ATA-3 X3T10 2008D rev.1",
            []
        ],
        "135044921": [
            "ATA-2 X3T10 948D rev.2k",
            []
        ],
        "135044945": [
            "ATA-3 X3T10 2008D rev.0",
            []
        ],
        "135044969": [
            "ATA-2 X3T10 948D rev.3",
            []
        ],
        "135044992": [
            "ATA-3 published, ANSI X3.298-199x",
            []
        ],
        "135045026": [
            "ATA-3 X3T10 2008D rev.6",
            []
        ],
        "135045050": [
            "ATA-3 X3T13 2008D rev.7 and 7a",
            []
        ],
        "135045081": [
            "ATA/ATAPI-4 X3T13 1153D rev.6",
            []
        ],
        "135045111": [
            "ATA/ATAPI-4 T13 1153D rev.13",
            []
        ],
        "135045140": [
            "ATA/ATAPI-4 X3T13 1153D rev.7",
            []
        ],
        "135045170": [
            "ATA/ATAPI-4 T13 1153D rev.18",
            []
        ],
        "135045199": [
            "ATA/ATAPI-4 T13 1153D rev.15",
            []
        ],
        "135045228": [
            "ATA/ATAPI-4 published, ANSI INCITS 317-1998",
            []
        ],
        "135045272": [
            "ATA/ATAPI-5 T13 1321D rev.3",
            []
        ],
        "135045300": [
            "ATA/ATAPI-4 T13 1153D rev.14",
            []
        ],
        "135045329": [
            "ATA/ATAPI-5 T13 1321D rev.1",
            []
        ],
        "135045357": [
            "ATA/ATAPI-5 published, ANSI INCITS 340-2000",
            []
        ],
        "135045401": [
            "ATA/ATAPI-4 T13 1153D rev.17",
            []
        ],
        "135045430": [
            "ATA/ATAPI-6 T13 1410D rev.0",
            []
        ],
        "135045458": [
            "ATA/ATAPI-6 T13 1410D rev.3a",
            []
        ],
        "135045487": [
            "ATA/ATAPI-7 T13 1532D rev.1",
            []
        ],
        "135045515": [
            "ATA/ATAPI-6 T13 1410D rev.2",
            []
        ],
        "135045543": [
            "ATA/ATAPI-6 T13 1410D rev.1",
            []
        ],
        "135045571": [
            "ATA/ATAPI-7 published, ANSI INCITS 397-2005",
            []
        ],
        "135045615": [
            "ATA/ATAPI-7 T13 1532D rev.0",
            []
        ],
        "135045643": [
            "reserved",
            []
        ],
        "135045652": [
            "reserved",
            []
        ],
        "135045661": [
            "ATA/ATAPI-7 T13 1532D rev.4a",
            []
        ],
        "135045690": [
            "ATA/ATAPI-6 published, ANSI INCITS 361-2002",
            []
        ],
        "135045734": [
            "reserved",
            []
        ],
        "135045743": [
            "reserved",
            [
                134554049
            ]
        ],
        "135045752": [
            "hard sectored",
            []
        ],
        "135045766": [
            "soft sectored",
            []
        ],
        "135045780": [
            "not MFM encoded ",
            []
        ],
        "135045797": [
            "head switch time > 15us",
            []
        ],
        "135045821": [
            "spindle motor control option",
            []
        ],
        "135045850": [
            "fixed drive",
            []
        ],
        "135045862": [
            "removable drive",
            []
        ],
        "135045878": [
            "disk xfer rate <= 5Mbs",
            []
        ],
        "135045901": [
            "disk xfer rate > 5Mbs, <= 10Mbs",
            []
        ],
        "135045933": [
            "disk xfer rate > 5Mbs",
            []
        ],
        "135045955": [
            "rotational speed tol.",
            []
        ],
        "135045977": [
            "data strobe offset option",
            []
        ],
        "135046003": [
            "track offset option",
            []
        ],
        "135046023": [
            "format speed tolerance gap reqd",
            []
        ],
        "135046055": [
            "ATAPI",
            []
        ],
        "135046061": [
            "Direct-access device",
            [
                134554049
            ]
        ],
        "135046082": [
            "Sequential-access device",
            []
        ],
        "135046107": [
            "Printer",
            []
        ],
        "135046115": [
            "Processor",
            []
        ],
        "135046125": [
            "Write-once device",
            []
        ],
        "135046143": [
            "CD-ROM",
            []
        ],
        "135046150": [
            "Scanner",
            []
        ],
        "135046158": [
            "Optical memory",
            []
        ],
        "135046173": [
            "Medium changer",
            []
        ],
        "135046188": [
            "Communications device",
            []
        ],
        "135046210": [
            "ACS-IT8 device",
            []
        ],
        "135046225": [
            "ACS-IT8 device",
            []
        ],
        "135046240": [
            "Array controller",
            []
        ],
        "135046257": [
            "Enclosure services",
            []
        ],
        "135046276": [
            "Reduced block command device",
            []
        ],
        "135046305": [
            "Optical card reader/writer",
            []
        ],
        "135046333": [
            "%08llx ",
            [
                134563448
            ]
        ],
        "135046341": [
            "%s\r%.*s",
            [
                134563665
            ]
        ],
        "135046349": [
            "\u001b[H\u001b[J",
            [
                134563744,
                134667977,
                134804266,
                134933852
            ]
        ],
        "135046356": [
            "\u001b[%u;%uH",
            [
                134563744,
                134572249,
                134889136,
                134573534
            ]
        ],
        "135046365": [
            "\u001b[?1049l",
            [
                134563939,
                134901029
            ]
        ],
        "135046379": [
            "\u001b[?1049h",
            [
                134564393,
                134901029
            ]
        ],
        "135046388": [
            "\u001b[46D",
            [
                134564393
            ]
        ],
        "135046398": [
            "\u001b[46C",
            [
                134564393
            ]
        ],
        "135046416": [
            "\u001b[999;1H\u001b[K",
            [
                134564393
            ]
        ],
        "135046428": [
            "Go to (dec,0Xhex,0oct): ",
            [
                134564393
            ]
        ],
        "135046453": [
            "/dev/i2c-%d",
            [
                134565567
            ]
        ],
        "135046465": [
            "warning: adapter does not support PEC",
            [
                134565647
            ]
        ],
        "135046503": [
            "adapter has no %s capability",
            [
                134565647
            ]
        ],
        "135046532": [
            "SMBus receive byte",
            [
                134569792,
                134565686
            ]
        ],
        "135046551": [
            "SMBus send byte",
            [
                134567088,
                134565686
            ]
        ],
        "135046567": [
            "SMBus read byte",
            [
                134565686
            ]
        ],
        "135046583": [
            "SMBus read word",
            [
                134565686
            ]
        ],
        "135046599": [
            "SMBus block read",
            [
                134565686
            ]
        ],
        "135046616": [
            "I2C block read",
            [
                134565686
            ]
        ],
        "135046631": [
            "can't get adapter functionality matrix",
            [
                134567088,
                134569792,
                134565686,
                134566175
            ]
        ],
        "135046670": [
            "internal error",
            [
                134773827,
                134565686
            ]
        ],
        "135046685": [
            "can't set address to 0x%02x",
            [
                134569792,
                134565855
            ]
        ],
        "135046713": [
            "Continue? [y/N] ",
            [
                134565887
            ]
        ],
        "135046730": [
            "WARNING! This program can confuse your I2C bus",
            [
                134569792,
                134565925
            ]
        ],
        "135046777": [
            "this is I2C not smbus - using PEC on I2C devices may result in data loss, ",
            [
                134565925
            ]
        ],
        "135046851": [
            "aborting",
            [
                134565887
            ]
        ],
        "135046860": [
            "WARNING! May interpret a write byte command with PEC as a write byte data command",
            [
                134565925
            ]
        ],
        "135046942": [
            "PEC checking ",
            [
                134565925
            ]
        ],
        "135046955": [
            "enabled",
            [
                134554049,
                134558382
            ]
        ],
        "135046963": [
            "/sys/class/i2c-dev",
            [
                134566175
            ]
        ],
        "135046982": [
            "%s/%s/name",
            [
                134566175
            ]
        ],
        "135046993": [
            "%s/%s/device/name",
            [
                134566175
            ]
        ],
        "135047016": [
            "%s/%s/device/%s/name",
            [
                134566175
            ]
        ],
        "135047041": [
            "i2c-%d\t%-10s\t%-32s\t%s\n",
            [
                134566175
            ]
        ],
        "135047068": [
            "-2:?4",
            []
        ],
        "135047074": [
            "^fym:r",
            [
                134567088
            ]
        ],
        "135047084": [
            "^fyr:",
            [
                134568282
            ]
        ],
        "135047090": [
            "-2:?3",
            []
        ],
        "135047096": [
            "^yaqrFl",
            [
                134569792
            ]
        ],
        "135047104": [
            "q--r:r--q:?3",
            []
        ],
        "135047117": [
            "invalid mode",
            [
                134567088,
                134568282,
                134566686
            ]
        ],
        "135047130": [
            "can't set PEC",
            [
                134567088,
                134568282,
                134566686
            ]
        ],
        "135047144": [
            "warning - write failed",
            [
                134566686
            ]
        ],
        "135047167": [
            "read failed",
            [
                134566686
            ]
        ],
        "135047179": [
            "I2C block write",
            [
                134567088
            ]
        ],
        "135047195": [
            "SMBus write byte",
            [
                134567088
            ]
        ],
        "135047212": [
            "SMBus block write",
            [
                134567088
            ]
        ],
        "135047230": [
            "SMBus write word",
            [
                134567088
            ]
        ],
        "135047247": [
            "PEC not supported for I2C block writes",
            [
                134567088
            ]
        ],
        "135047286": [
            "mask not supported for block writes",
            [
                134567088
            ]
        ],
        "135047322": [
            "can't read old value",
            [
                134567088
            ]
        ],
        "135047343": [
            "old value 0x%0*x, write mask 0x%0*x, will write 0x%0*x to register 0x%02x",
            [
                134567088
            ]
        ],
        "135047417": [
            "Warning - readback failed",
            [
                134567088
            ]
        ],
        "135047443": [
            "Warning - data mismatch - wrote 0x%0*x, read back ",
            [
                134567088
            ]
        ],
        "135047493": [
            "0x%0*x\n",
            [
                134566686
            ]
        ],
        "135047501": [
            "Value 0x%0*x written, readback matched\n",
            [
                134567088
            ]
        ],
        "135047541": [
            "pec not supported for -W and -i",
            [
                134568282
            ]
        ],
        "135047573": [
            "invalid range",
            [
                134568282
            ]
        ],
        "135047587": [
            "range not compatible with selected mode",
            [
                134568282
            ]
        ],
        "135047627": [
            "block read failed: %d",
            [
                134568282
            ]
        ],
        "135047649": [
            "write start address",
            [
                134568282
            ]
        ],
        "135047669": [
            "     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f    0123456789abcdef",
            [
                134568282
            ]
        ],
        "135047741": [
            "%02x: ",
            [
                134569792,
                134568282
            ]
        ],
        "135047748": [
            "     0,8  1,9  2,a  3,b  4,c  5,d  6,e  7,f",
            [
                134568282
            ]
        ],
        "135047792": [
            "XXXX ",
            [
                134568282
            ]
        ],
        "135047798": [
            "%04x ",
            [
                134568282
            ]
        ],
        "135047804": [
            "Functionalities implemented by bus #%d\n",
            [
                134569792
            ]
        ],
        "135047844": [
            "%-32s %s\n",
            [
                134569792
            ]
        ],
        "135047854": [
            "detection commands",
            [
                134569792
            ]
        ],
        "135047873": [
            "bus doesn't support %s",
            [
                134569792
            ]
        ],
        "135047896": [
            "SMBus quick write",
            [
                134569792
            ]
        ],
        "135047914": [
            "warning: can't use %s command, will skip some addresses",
            [
                134569792
            ]
        ],
        "135047970": [
            "     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f",
            [
                134569792
            ]
        ],
        "135048030": [
            "SMBus quick command",
            []
        ],
        "135048050": [
            "SMBus process call",
            []
        ],
        "135048069": [
            "SMBus block process c",
            []
        ],
        "135048094": [
            "SMBus PEC",
            []
        ],
        "135048104": [
            "dummy",
            [
                4294967295
            ]
        ],
        "135048110": [
            "Dummy bus",
            [
                4294967295
            ]
        ],
        "135048124": [
            "ISA bus",
            [
                4294967295
            ]
        ],
        "135048136": [
            "I2C adapter",
            [
                4294967295
            ]
        ],
        "135048148": [
            "smbus",
            [
                4294967295
            ]
        ],
        "135048154": [
            "SMBus adapter",
            [
                4294967295
            ]
        ],
        "135048168": [
            "\u001b[%u;0H\u001b[K",
            [
                134570637
            ]
        ],
        "135048179": [
            "/proc/self/fd/0",
            [
                134571703
            ]
        ],
        "135048195": [
            "\u001b[7m%s",
            [
                134571886
            ]
        ],
        "135048202": [
            " (file %i of %i)",
            [
                134571886
            ]
        ],
        "135048219": [
            " lines %i-%i",
            [
                134571886
            ]
        ],
        "135048236": [
            " (END)",
            [
                134571886
            ]
        ],
        "135048243": [
            " - next: %s",
            [
                134571886
            ]
        ],
        "135048255": [
            " %i%%",
            [
                134571886
            ]
        ],
        "135048261": [
            "\u001b[7m%s (file %i of %i)\u001b[m",
            [
                134572138
            ]
        ],
        "135048287": [
            "\u001b[7m%s\u001b[m",
            [
                134572249,
                134572138
            ]
        ],
        "135048302": [
            "%s%.*s",
            [
                134572249
            ]
        ],
        "135048308": [
            "\u001b[7m%.*s\u001b[m",
            [
                134665720,
                134570724
            ]
        ],
        "135048320": [
            "No next file",
            [
                134573184
            ]
        ],
        "135048333": [
            "No previous file",
            [
                134573184
            ]
        ],
        "135048350": [
            "No matches found",
            [
                134573439
            ]
        ],
        "135048367": [
            "Examine: ",
            [
                134573960
            ]
        ],
        "135048377": [
            "Cannot read this file",
            [
                134573960
            ]
        ],
        "135048399": [
            "Error opening log file",
            [
                134574328
            ]
        ],
        "135048427": [
            "EMmN~IFSs",
            [
                134574328
            ]
        ],
        "135048437": [
            "Log file: ",
            [
                134574328
            ]
        ],
        "135048448": [
            "No bracket in top line",
            [
                134574328
            ]
        ],
        "135048471": [
            "No matching bracket found",
            [
                134574328
            ]
        ],
        "135048497": [
            "No bracket in bottom line",
            [
                134574328
            ]
        ],
        "135048531": [
            "ABCDEFGHI@KLMNOPQRSTUVWXYZ[\\]^_",
            []
        ],
        "135048596": [
            "model",
            [
                134576324
            ]
        ],
        "135048602": [
            "[%s]\t",
            [
                134576324
            ]
        ],
        "135048608": [
            "(%s)\t",
            [
                134576324
            ]
        ],
        "135048618": [
            "%s\t%s\t%s\n",
            [
                134576324
            ]
        ],
        "135048638": [
            "printer",
            []
        ],
        "135048646": [
            "process",
            []
        ],
        "135048660": [
            "scanner",
            []
        ],
        "135048668": [
            "optical",
            []
        ],
        "135048676": [
            "mediumx",
            []
        ],
        "135048684": [
            "comms",
            []
        ],
        "135048692": [
            "storage",
            []
        ],
        "135048700": [
            "enclosu",
            []
        ],
        "135048708": [
            "sim dsk",
            []
        ],
        "135048716": [
            "opti rd",
            []
        ],
        "135048724": [
            "bridge",
            []
        ],
        "135048755": [
            "no dev",
            []
        ],
        "135048762": [
            "/sys/bus/scsi/devices",
            [
                134576324
            ]
        ],
        "135048784": [
            "rootdir=%s\ntable=",
            [
                134576621
            ]
        ],
        "135048802": [
            "<stdin>",
            [
                134576621
            ]
        ],
        "135048810": [
            "%*s%n %c %o %40s %40s %u %u %u %u %u",
            [
                134576621
            ]
        ],
        "135048847": [
            "invalid line %d: '%s'",
            [
                134576621
            ]
        ],
        "135048869": [
            "line %d: can't chown %s",
            [
                134576621
            ]
        ],
        "135048893": [
            "line %d: can't chmod %s",
            [
                134576621
            ]
        ],
        "135048917": [
            "line %d: regular file '%s' does not exist",
            [
                134576621
            ]
        ],
        "135048959": [
            "line %d: unsupported file type %c",
            [
                134576621
            ]
        ],
        "135048998": [
            "line %d: can't create node %s",
            [
                134576621
            ]
        ],
        "135049035": [
            "^Xs:+d:+t:+",
            [
                134577490
            ]
        ],
        "135049050": [
            "/var/lock/LCK..%s",
            [
                134577490
            ]
        ],
        "135049068": [
            "can't create '%s'",
            [
                134951845,
                134577490,
                134913143,
                134913048,
                134742074
            ]
        ],
        "135049091": [
            "can't tcsetattr for %s",
            [
                134577490
            ]
        ],
        "135049114": [
            "/dev/tape",
            [
                134578180
            ]
        ],
        "135049127": [
            "unrecognized opcode %s",
            [
                134578180
            ]
        ],
        "135049150": [
            "At block %d\n",
            [
                134578180
            ]
        ],
        "135049180": [
            "datacompression",
            []
        ],
        "135049200": [
            "erase",
            []
        ],
        "135049233": [
            "mkpart",
            []
        ],
        "135049244": [
            "offline",
            []
        ],
        "135049252": [
            "rewoffline",
            []
        ],
        "135049278": [
            "reset",
            []
        ],
        "135049284": [
            "retension",
            []
        ],
        "135049294": [
            "rewind",
            []
        ],
        "135049306": [
            "setblk",
            []
        ],
        "135049313": [
            "setdensity",
            []
        ],
        "135049324": [
            "drvbuffer",
            []
        ],
        "135049334": [
            "setpart",
            []
        ],
        "135049352": [
            "unload",
            []
        ],
        "135049359": [
            "unlock",
            []
        ],
        "135049376": [
            "%c %c\n",
            [
                134578505
            ]
        ],
        "135049383": [
            "^hx:n:v:",
            [
                134578618
            ]
        ],
        "135049392": [
            "-1:x:n:n--x:x--nv:v--x",
            []
        ],
        "135049415": [
            "can't set serial info",
            [
                134578870
            ]
        ],
        "135049437": [
            "can't autoconfigure port",
            [
                134578870
            ]
        ],
        "135049462": [
            "can't get serial info",
            [
                134578870
            ]
        ],
        "135049484": [
            "undefined",
            [
                134579024
            ]
        ],
        "135049494": [
            ", Flags: ",
            [
                134579024
            ]
        ],
        "135049504": [
            "\tFlags: ",
            [
                134579024
            ]
        ],
        "135049513": [
            "invalid flag: %s",
            [
                134579024
            ]
        ],
        "135049530": [
            "can't invert %s",
            [
                134579024
            ]
        ],
        "135049546": [
            "illegal UART type: %s",
            [
                134579024
            ]
        ],
        "135049568": [
            "infinite",
            [
                134579024
            ]
        ],
        "135049577": [
            "%s, UART: %s, Port: 0x%.4x, IRQ: %d",
            [
                134579024
            ]
        ],
        "135049613": [
            "%s at 0x%.4x (irq = %d) is a %s",
            [
                134579024
            ]
        ],
        "135049645": [
            "%s uart %s port 0x%.4x irq %d baud_base %d",
            [
                134579024
            ]
        ],
        "135049688": [
            "%s, Line %d, UART: %s, Port: 0x%.4x, IRQ: %d\n",
            [
                134579024
            ]
        ],
        "135049734": [
            "\tBaud_base: %d, close_delay: %u, divisor: %d\n",
            [
                134579024
            ]
        ],
        "135049780": [
            "\tclosing_wait: ",
            [
                134579024
            ]
        ],
        "135049796": [
            "^bGavzgq",
            [
                134579024
            ]
        ],
        "135049805": [
            "-1:b-aG:G-ab:a-bG",
            []
        ],
        "135049823": [
            "spd_normal",
            [
                134579024
            ]
        ],
        "135049834": [
            "spd_hi",
            []
        ],
        "135049841": [
            "spd_vhi",
            []
        ],
        "135049849": [
            "spd_shi",
            []
        ],
        "135049857": [
            "spd_warp",
            []
        ],
        "135049866": [
            "spd_cust",
            []
        ],
        "135049879": [
            "fourport",
            []
        ],
        "135049888": [
            "hup_notify",
            []
        ],
        "135049899": [
            "skip_test",
            []
        ],
        "135049909": [
            "auto_irq",
            []
        ],
        "135049918": [
            "split_termios",
            []
        ],
        "135049932": [
            "session_lockout",
            []
        ],
        "135049948": [
            "pgrp_lockout",
            []
        ],
        "135049961": [
            "callout_nohup",
            []
        ],
        "135049975": [
            "low_latency",
            []
        ],
        "135049996": [
            "divisor",
            []
        ],
        "135050009": [
            "baud_base",
            []
        ],
        "135050019": [
            "close_delay",
            []
        ],
        "135050031": [
            "closing_wait",
            []
        ],
        "135050044": [
            "autoconfig",
            []
        ],
        "135050056": [
            "unknown",
            [
                134579024
            ]
        ],
        "135050069": [
            "16450",
            []
        ],
        "135050075": [
            "16550",
            []
        ],
        "135050081": [
            "16550A",
            []
        ],
        "135050088": [
            "Cirrus",
            []
        ],
        "135050095": [
            "16650",
            []
        ],
        "135050101": [
            "16650V2",
            []
        ],
        "135050109": [
            "16750",
            []
        ],
        "135050115": [
            "16950",
            []
        ],
        "135050121": [
            "16954",
            []
        ],
        "135050127": [
            "16654",
            []
        ],
        "135050133": [
            "16850",
            []
        ],
        "135050143": [
            "NS16550A",
            []
        ],
        "135050152": [
            "XSCALE",
            []
        ],
        "135050159": [
            "RM9000",
            []
        ],
        "135050166": [
            "OCTEON",
            []
        ],
        "135050177": [
            "U6_16550A",
            []
        ],
        "135050188": [
            "{%s}: ",
            [
                134580218
            ]
        ],
        "135050195": [
            "afon:t:",
            [
                134580218
            ]
        ],
        "135050203": [
            "%%7ll%s ",
            [
                134580218
            ]
        ],
        "135050212": [
            "Command terminated by signal %u\n",
            [
                134580877
            ]
        ],
        "135050245": [
            "Command exited with non-zero status %u\n",
            [
                134580877
            ]
        ],
        "135050288": [
            "%uh %um %02us",
            [
                134580877
            ]
        ],
        "135050302": [
            "%um %u.%02us",
            [
                134580877
            ]
        ],
        "135050324": [
            "%u.%02u",
            [
                134580877
            ]
        ],
        "135050332": [
            "^+vpao:f:",
            [
                134580877
            ]
        ],
        "135050345": [
            "\tCommand being timed: \"%C\"\n\tUser time (seconds): %U\n\tSystem time (seconds): %S\n\tPercent of CPU this job got: %P\n\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\n\tAverage shared text size (kbytes): %X\n\tAverage unshared data size (kbytes): %D\n\tAverage stack size (kbytes): %p\n\tAverage total size (kbytes): %K\n\tMaximum resident set size (kbytes): %M\n\tAverage resident set size (kbytes): %t\n\tMajor (requiring I/O) page faults: %F\n\tMinor (reclaiming a frame) page faults: %R\n\tVoluntary context switches: %w\n\tInvoluntary context switches: %c\n\tSwaps: %W\n\tFile system inputs: %I\n\tFile system outputs: %O\n\tSocket messages sent: %s\n\tSocket messages received: %r\n\tSignals delivered: %k\n\tPage size (bytes): %Z\n\tExit status: %x",
            [
                134580877
            ]
        ],
        "135051060": [
            "real %e\nuser %U\nsys %S",
            [
                134580877
            ]
        ],
        "135051083": [
            "real\t%E\nuser\t%u\nsys\t%T",
            [
                134580877
            ]
        ],
        "135051106": [
            "too many renames requested",
            [
                134581964
            ]
        ],
        "135051133": [
            "new name '%s' is too long",
            [
                134581964
            ]
        ],
        "135051159": [
            "UBI_IOCRNVOL",
            [
                134581964
            ]
        ],
        "135051172": [
            "^Ft:T:",
            [
                134582201
            ]
        ],
        "135051182": [
            "WDIOC_SETOPTIONS",
            [
                134582201
            ]
        ],
        "135051199": [
            "WDIOC_SETTIMEOUT",
            [
                134582201
            ]
        ],
        "135051216": [
            "Vcan't insert '%s': %s",
            [
                134582164
            ]
        ],
        "135051239": [
            "/proc/modules",
            [
                134582545,
                134584238
            ]
        ],
        "135051253": [
            "Module",
            [
                134582545
            ]
        ],
        "135051260": [
            "%-24sSize  Used by",
            [
                134582545
            ]
        ],
        "135051279": [
            "/proc/sys/kernel/tainted",
            [
                134582545
            ]
        ],
        "135051304": [
            "    Tainted: %c%c%c\n",
            [
                134582545
            ]
        ],
        "135051325": [
            "    Not tainted",
            [
                134582545
            ]
        ],
        "135051341": [
            "%-19s %8s %2s %s\n",
            [
                134582545
            ]
        ],
        "135051359": [
            "symbol:",
            [
                134583102
            ]
        ],
        "135051367": [
            "options",
            [
                134583177
            ]
        ],
        "135051375": [
            "include",
            [
                134583177
            ]
        ],
        "135051383": [
            "module %s is builtin",
            [
                134583602
            ]
        ],
        "135051404": [
            "module %s not found in ",
            [
                134583602
            ]
        ],
        "135051427": [
            "modules.dep",
            [
                134582864,
                134584238
            ]
        ],
        "135051439": [
            "insmod %s/%s/%s %s\n",
            [
                134583602
            ]
        ],
        "135051459": [
            "insmod %s/%s/%s\n",
            [
                134583602
            ]
        ],
        "135051476": [
            "can't unload module '%s'",
            [
                134583602,
                134585670
            ]
        ],
        "135051501": [
            "/proc/cmdline",
            [
                134583602
            ]
        ],
        "135051515": [
            "/lib/modules",
            [
                134583602,
                134584238
            ]
        ],
        "135051528": [
            "can't load module %s (%s): %s",
            [
                134583602
            ]
        ],
        "135051558": [
            "^vqsalrDb",
            [
                134584238
            ]
        ],
        "135051568": [
            "q-v:v-q:l--arD:r--alD:a--lr:D--rl",
            []
        ],
        "135051602": [
            "modules.builtin",
            [
                134584238
            ]
        ],
        "135051618": [
            "/etc/modprobe.conf",
            [
                134584238
            ]
        ],
        "135051637": [
            "/etc/modprobe.d",
            [
                134584238
            ]
        ],
        "135051653": [
            "modules.symbols",
            [
                134584238
            ]
        ],
        "135051669": [
            "modules.",
            [
                134584238
            ]
        ],
        "135051677": [
            "alias",
            [
                134583177,
                134682509
            ]
        ],
        "135051683": [
            "show-depends",
            [
                134584238
            ]
        ],
        "135051699": [
            "%.*s%s ",
            [
                134585243
            ]
        ],
        "135051707": [
            "%.*s\"%s\" ",
            [
                134585243
            ]
        ],
        "135051717": [
            "no such module",
            [
                134585596
            ]
        ],
        "135051732": [
            "invalid module format",
            [
                134585596
            ]
        ],
        "135051754": [
            "unknown symbol in module, or unknown parameter",
            [
                134585596
            ]
        ],
        "135051801": [
            "module has wrong symbol version",
            [
                134585596
            ]
        ],
        "135051833": [
            "kernel does not support requested operation",
            [
                134585596
            ]
        ],
        "135051882": [
            "rmmod",
            [
                134585670
            ]
        ],
        "135051888": [
            "/proc/net/arp",
            [
                134585831
            ]
        ],
        "135051902": [
            "%s 0x%x 0x%x %s %s %s\n",
            [
                134585831
            ]
        ],
        "135051925": [
            "ether",
            [
                4294967295,
                134586475,
                134585831
            ]
        ],
        "135051931": [
            "%s (%s) at ",
            [
                134585831
            ]
        ],
        "135051946": [
            "<incomplete> ",
            [
                134585831
            ]
        ],
        "135051960": [
            "%s [%s] ",
            [
                134585831
            ]
        ],
        "135051969": [
            "netmask %s ",
            [
                134585831
            ]
        ],
        "135051981": [
            "No match found in %u entries\n",
            [
                134585831
            ]
        ],
        "135052016": [
            "A:p:H:t:i:adnDsv",
            [
                134586475
            ]
        ],
        "135052033": [
            "address family",
            [
                134586475
            ]
        ],
        "135052048": [
            "%s: unknown %s",
            [
                134586475
            ]
        ],
        "135052063": [
            "hardware type",
            [
                134586475
            ]
        ],
        "135052077": [
            "%s: kernel only supports 'inet'",
            [
                134586475
            ]
        ],
        "135052109": [
            "%s: %s without ARP support",
            [
                134586475
            ]
        ],
        "135052136": [
            "need host name",
            [
                134586475
            ]
        ],
        "135052151": [
            "need hardware address",
            [
                134586475
            ]
        ],
        "135052173": [
            "can't get HW-Address for '%s'",
            [
                134586475
            ]
        ],
        "135052203": [
            "protocol type mismatch",
            [
                134586475
            ]
        ],
        "135052226": [
            "invalid hardware address",
            [
                134586475
            ]
        ],
        "135052251": [
            "feature ATF_DONTPUB is not supported",
            [
                134586475
            ]
        ],
        "135052288": [
            "feature ATF_MAGIC is not supported",
            [
                134586475
            ]
        ],
        "135052323": [
            "255.255.255.255",
            [
                134586475
            ]
        ],
        "135052339": [
            "SIOCSARP",
            [
                134586475
            ]
        ],
        "135052348": [
            "No ARP entry for %s\n",
            [
                134586475
            ]
        ],
        "135052369": [
            "SIOCDARP(priv)",
            [
                134586475
            ]
        ],
        "135052384": [
            "SIOCDARP(pub)",
            [
                134586475
            ]
        ],
        "135052407": [
            "TRAIL",
            []
        ],
        "135052428": [
            "trail",
            []
        ],
        "135052434": [
            "dontpub",
            []
        ],
        "135052451": [
            "netmask",
            []
        ],
        "135052460": [
            "Sent %u probe(s) (%u broadcast(s))\nReceived %u response(s) (%u request(s), %u broadcast(s))\n",
            [
                134587705
            ]
        ],
        "135052557": [
            "Broad",
            [
                134588071
            ]
        ],
        "135052568": [
            "interface %s %%s",
            [
                134588071
            ]
        ],
        "135052585": [
            "SIOCGIFFLAGS",
            [
                134591745,
                134633890,
                134588071
            ]
        ],
        "135052598": [
            "is down",
            [
                134588071
            ]
        ],
        "135052606": [
            "is not ARPable",
            [
                134588071
            ]
        ],
        "135052621": [
            "invalid source address %s",
            [
                134588071
            ]
        ],
        "135052647": [
            "SO_DONTROUTE",
            [
                134588071
            ]
        ],
        "135052660": [
            "setsockopt(%s)",
            [
                134621773,
                134588071
            ]
        ],
        "135052675": [
            "no IP address configured",
            [
                134588071
            ]
        ],
        "135052700": [
            "is not ARPable (no ll address)",
            [
                134588071
            ]
        ],
        "135052731": [
            "ARPING %s",
            [
                134588071
            ]
        ],
        "135052741": [
            " from %s %s\n",
            [
                134588071
            ]
        ],
        "135052754": [
            "recvfrom",
            [
                134612104,
                134588071
            ]
        ],
        "135052763": [
            "%scast re%s from %s [%02x:%02x:%02x:%02x:%02x:%02x]",
            [
                134588071
            ]
        ],
        "135052815": [
            " %u.%03ums\n",
            [
                134588071
            ]
        ],
        "135052827": [
            " UNSOLICITED?",
            [
                134588071
            ]
        ],
        "135052841": [
            "^UDAqfbc:+w:I:s:",
            [
                134588071
            ]
        ],
        "135052858": [
            "=1:Df:AU",
            []
        ],
        "135052867": [
            "opcode != 0",
            [
                134589622
            ]
        ],
        "135052879": [
            "class != 1",
            [
                134589622
            ]
        ],
        "135052890": [
            "type is !REQ_A and !REQ_PTR",
            [
                134589622
            ]
        ],
        "135052918": [
            "name is not found",
            [
                134589622
            ]
        ],
        "135052936": [
            "dropping query",
            [
                134589622
            ]
        ],
        "135052951": [
            "sending error reply",
            [
                134589622
            ]
        ],
        "135052971": [
            "/etc/dnsd.",
            [
                134589622
            ]
        ],
        "135052986": [
            "vsi:c:t:p:d",
            [
                134589622
            ]
        ],
        "135052998": [
            "error at line %u, skipping",
            [
                134589622
            ]
        ],
        "135053025": [
            "name:%s, ip:%s",
            [
                134589622
            ]
        ],
        "135053040": [
            ".%u.%u.%u.%u",
            [
                134589622
            ]
        ],
        "135053053": [
            "accepting UDP packets on %s",
            [
                134589622
            ]
        ],
        "135053081": [
            "packet size %d, ignored",
            [
                134589622
            ]
        ],
        "135053105": [
            "got UDP packet",
            [
                134589622
            ]
        ],
        "135053120": [
            "packet has 0 queries, ignored",
            [
                134589622
            ]
        ],
        "135053150": [
            "response packet, ignored",
            [
                134589622
            ]
        ],
        "135053175": [
            "returning positive reply",
            [
                134589622
            ]
        ],
        "135053200": [
            "%s, %s",
            [
                134589622
            ]
        ],
        "135053207": [
            "%2x:%2x:%2x:%2x:%2x:%2x",
            [
                134590791
            ]
        ],
        "135053231": [
            "can't read Wake-On-LAN pass",
            [
                134590791
            ]
        ],
        "135053259": [
            "SIOCGIFHWADDR on %s failed",
            [
                134590791
            ]
        ],
        "135053286": [
            "SO_BROADCAST",
            [
                134657861,
                134590791
            ]
        ],
        "135053299": [
            "SIOCGIFINDEX",
            [
                134591745,
                134633890,
                134613799,
                134590791,
                134657642,
                134643707
            ]
        ],
        "135053312": [
            "^bi:p:",
            [
                134590791
            ]
        ],
        "135053322": [
            "sethostname",
            [
                134591392
            ]
        ],
        "135053334": [
            "dfisF:v",
            [
                134591486
            ]
        ],
        "135053342": [
            "domain",
            [
                134591486
            ]
        ],
        "135053350": [
            "dfqdn",
            []
        ],
        "135053357": [
            "ffile",
            []
        ],
        "135053366": [
            "bad: '%s'",
            [
                134591745
            ]
        ],
        "135053376": [
            "default",
            [
                134650240,
                134591745,
                134650561,
                134927622,
                134613799,
                134927722,
                134649167,
                134614289,
                134928054
            ]
        ],
        "135053384": [
            "invalid hw-addr %s",
            [
                134591745
            ]
        ],
        "135053403": [
            "SIOCGIFMAP",
            [
                134591745
            ]
        ],
        "135053414": [
            "SIOC%s",
            [
                134591745
            ]
        ],
        "135053421": [
            "SIOCSIFFLAGS",
            [
                134591745,
                134633890
            ]
        ],
        "135053434": [
            "ether",
            [
                134591745
            ]
        ],
        "135053440": [
            "infiniband",
            []
        ],
        "135053452": [
            "metric",
            [
                134640501,
                4294967295
            ]
        ],
        "135053463": [
            "txqueuelen",
            []
        ],
        "135053474": [
            "dstaddr",
            []
        ],
        "135053482": [
            "netmask",
            [
                134593835
            ]
        ],
        "135053493": [
            "pointopoint",
            []
        ],
        "135053505": [
            "keepalive",
            []
        ],
        "135053515": [
            "outfill",
            []
        ],
        "135053527": [
            "start",
            [
                134593410,
                134669739
            ]
        ],
        "135053533": [
            "io_addr",
            []
        ],
        "135053541": [
            "trailers",
            []
        ],
        "135053550": [
            "promisc",
            [
                134633890
            ]
        ],
        "135053558": [
            "multicast",
            [
                134649720,
                134633890
            ]
        ],
        "135053568": [
            "allmulti",
            []
        ],
        "135053577": [
            "dynamic",
            []
        ],
        "135053585": [
            "SIFMETRIC",
            [
                4294967295
            ]
        ],
        "135053595": [
            "SIFDSTADDR",
            []
        ],
        "135053606": [
            "SIFNETMASK",
            []
        ],
        "135053617": [
            "SIFBRDADDR",
            []
        ],
        "135053628": [
            "SKEEPALIVE",
            []
        ],
        "135053639": [
            "SOUTFILL",
            []
        ],
        "135053648": [
            "SIFMAP",
            []
        ],
        "135053655": [
            "SIFADDR",
            [
                4294967295
            ]
        ],
        "135053663": [
            "DIFADDR",
            []
        ],
        "135053671": [
            "run-parts /etc/network/if-%s.d",
            [
                134592829
            ]
        ],
        "135053705": [
            "%s=%s",
            [
                134547978,
                134593005,
                134744050,
                134596473,
                134742074
            ]
        ],
        "135053711": [
            "IFACE",
            [
                134593005
            ]
        ],
        "135053717": [
            "ADDRFAM",
            [
                134593005
            ]
        ],
        "135053725": [
            "METHOD",
            [
                134593005
            ]
        ],
        "135053732": [
            "PHASE",
            [
                134593005
            ]
        ],
        "135053738": [
            "pre-down",
            [
                134593291,
                134595309
            ]
        ],
        "135053747": [
            "post-down",
            [
                134593291
            ]
        ],
        "135053757": [
            "pre-up",
            [
                134593410
            ]
        ],
        "135053764": [
            "post-up",
            [
                134593410,
                134595309
            ]
        ],
        "135053772": [
            "iface",
            [
                134593656,
                134595309
            ]
        ],
        "135053778": [
            "hwaddress",
            [
                134593835
            ]
        ],
        "135053788": [
            "bnmask",
            [
                134593835
            ]
        ],
        "135053795": [
            "ip link set %iface% ",
            [
                134594915,
                4294967295
            ]
        ],
        "135053820": [
            "ip addr add ::1 dev %iface%",
            [
                4294967295
            ]
        ],
        "135053848": [
            "ip link set %iface% up",
            [
                4294967295
            ]
        ],
        "135053871": [
            "ip addr add %address%/%netmask% dev %iface%[[ label %label%]]",
            [
                4294967295
            ]
        ],
        "135053933": [
            "ip link set[[ mtu %mtu%]][[ addr %hwaddress%]] %iface% up",
            [
                4294967295
            ]
        ],
        "135053991": [
            "[[ip route add ::/0 via %gateway% dev %iface%]][[ metric %metric%]]",
            [
                4294967295
            ]
        ],
        "135054059": [
            "ip tunnel del %iface%",
            [
                4294967295
            ]
        ],
        "135054081": [
            "ip tunnel add %iface% mode sit remote %endpoint%[[ local %local%]][[ ttl %ttl%]]",
            [
                4294967295
            ]
        ],
        "135054162": [
            "ip addr add %address%/%netmask% dev %iface%",
            [
                4294967295
            ]
        ],
        "135054206": [
            "[[ip route add ::/0 via %gateway% dev %iface%]]",
            [
                4294967295
            ]
        ],
        "135054254": [
            "ip addr flush dev %iface%",
            [
                4294967295
            ]
        ],
        "135054280": [
            "ip addr add 127.0.0.1/8 dev %iface%",
            [
                4294967295
            ]
        ],
        "135054316": [
            "ip link set[[ addr %hwaddress%]] %iface% up",
            [
                4294967295
            ]
        ],
        "135054360": [
            "udhcpc -R -n -p /var/run/udhcpc.%iface%.pid -i %iface%[[ -x hostname:%hostname%]][[ -c %client%]][[ -s %script%]][[ %udhcpc_opts%]]",
            [
                4294967295
            ]
        ],
        "135054492": [
            "bootpc[[ --bootfile %bootfile%]] --dev %iface%[[ --server %server%]][[ --hwaddr %hwaddr%]] --returniffail --serverbcast",
            [
                4294967295
            ]
        ],
        "135054612": [
            "ip addr add %address%/%bnmask%[[ broadcast %broadcast%]] dev %iface%[[ peer %pointopoint%]][[ label %label%]]",
            [
                4294967295
            ]
        ],
        "135054722": [
            "[[ip route add default via %gateway% dev %iface%[[ metric %metric%]]]]",
            [
                4294967295
            ]
        ],
        "135054793": [
            "poff[[ %provider%]]",
            [
                4294967295
            ]
        ],
        "135054813": [
            "pon[[ %provider%]]",
            [
                4294967295
            ]
        ],
        "135054832": [
            "start-stop-daemon --stop -x wvdial -p /var/run/wvdial.%iface% -s",
            [
                4294967295
            ]
        ],
        "135054899": [
            "start-stop-daemon --start -x wvdial -p /var/run/wvdial.%iface% -b -m --[[ %provider%]]",
            [
                4294967295
            ]
        ],
        "135054986": [
            "ip addr flush dev %iface%[[ label %label%]]",
            [
                134594915
            ]
        ],
        "135055030": [
            "test -f /var/run/udhcpc.%iface%.pid && kill `cat /var/run/udhcpc.%iface%.pid` 2>",
            [
                4294967295
            ]
        ],
        "135055110": [
            "/dev/null",
            [
                134878535,
                134875211,
                134542701,
                134953997,
                134721788,
                134826485,
                134684246,
                134876540,
                134764284
            ]
        ],
        "135055120": [
            "/var/run/ifstate",
            [
                134596473,
                134595228
            ]
        ],
        "135055137": [
            "mapping",
            [
                134595309
            ]
        ],
        "135055145": [
            "too few parameters for line \"%s\"",
            [
                134595309
            ]
        ],
        "135055178": [
            "too many parameters \"%s\"",
            [
                134595309
            ]
        ],
        "135055203": [
            "unknown address type \"%s\"",
            [
                134595309
            ]
        ],
        "135055229": [
            "unknown method \"%s\"",
            [
                134595309
            ]
        ],
        "135055249": [
            "interface declared auto twice \"%s\"",
            [
                134595309
            ]
        ],
        "135055284": [
            "option with empty value \"%s\"",
            [
                134595309
            ]
        ],
        "135055313": [
            "duplicate option \"%s\"",
            [
                134595309
            ]
        ],
        "135055335": [
            "duplicate script in mapping \"%s\"",
            [
                134595309
            ]
        ],
        "135055368": [
            "misplaced option \"%s\"",
            [
                134595309
            ]
        ],
        "135055390": [
            "/etc/network/interfaces",
            [
                134596473
            ]
        ],
        "135055414": [
            "anvfmi:",
            [
                134596473
            ]
        ],
        "135055422": [
            "interface %s already configured",
            [
                134596473
            ]
        ],
        "135055454": [
            "interface %s not configured",
            [
                134596473
            ]
        ],
        "135055482": [
            "Running mapping script %s",
            [
                134596473
            ]
        ],
        "135055507": [
            " on %s\n",
            [
                134585831
            ]
        ],
        "135055515": [
            "don't have all variables for %s/%s",
            [
                134596473
            ]
        ],
        "135055550": [
            "ignoring unknown interface %s",
            [
                134596473
            ]
        ],
        "135055580": [
            "/var/run/ifstate.new",
            [
                134596473
            ]
        ],
        "135055601": [
            "manual",
            []
        ],
        "135055608": [
            "wvdial",
            []
        ],
        "135055619": [
            "static",
            [
                4294967295
            ]
        ],
        "135055626": [
            "bootp",
            []
        ],
        "135055637": [
            "loopback",
            []
        ],
        "135055646": [
            "v4tunnel",
            []
        ],
        "135055663": [
            "pre-up",
            []
        ],
        "135055670": [
            "post-down",
            []
        ],
        "135055681": [
            "can't extend file limit, max = %d",
            [
                134597766
            ]
        ],
        "135055715": [
            "setrlimit",
            [
                134601161,
                134597766
            ]
        ],
        "135055725": [
            "%s: exit status %u",
            [
                134598070,
                134850351
            ]
        ],
        "135055744": [
            "%s: exit signal %u",
            [
                134598070
            ]
        ],
        "135055763": [
            "%.24s\r\n",
            [
                4294967295
            ]
        ],
        "135055771": [
            "%s/%s: ",
            [
                134598797
            ]
        ],
        "135055783": [
            "parse error on line %u, line is ignored",
            [
                134599395
            ]
        ],
        "135055828": [
            "no support for rpc services",
            [
                134599395
            ]
        ],
        "135055856": [
            "internal",
            [
                134599395
            ]
        ],
        "135055865": [
            "unknown internal service %s",
            [
                134599395
            ]
        ],
        "135055893": [
            "stream",
            [
                134599395
            ]
        ],
        "135055900": [
            "dgram",
            []
        ],
        "135055910": [
            "seqpacket",
            []
        ],
        "135055925": [
            "%s/%s: unknown service",
            [
                134600315
            ]
        ],
        "135055948": [
            "%s/%s: unknown host '%s'",
            [
                134600315
            ]
        ],
        "135055973": [
            "/etc/inetd.conf",
            [
                134601161
            ]
        ],
        "135055989": [
            "R:+feq:+",
            [
                134601161
            ]
        ],
        "135055998": [
            "non-root must specify config file",
            [
                134601161
            ]
        ],
        "135056032": [
            "select",
            [
                134601161
            ]
        ],
        "135056039": [
            "accept (for %s)",
            [
                134601161
            ]
        ],
        "135056055": [
            "%s/%s: too many connections, pausing",
            [
                134601161
            ]
        ],
        "135056092": [
            "%s: no such %s",
            [
                134601161
            ]
        ],
        "135056107": [
            "non-root must run services as himself",
            [
                134601161
            ]
        ],
        "135056151": [
            "%02X-",
            [
                134603064
            ]
        ],
        "135056157": [
            "[NONE SET]",
            [
                134603162,
                134603131,
                4294967295
            ]
        ],
        "135056168": [
            "%02X:%02X:%02X:%02X:%02X:%02X",
            [
                4294967295
            ]
        ],
        "135056198": [
            "compressed",
            [
                134603371
            ]
        ],
        "135056209": [
            "Device not found",
            [
                134603933
            ]
        ],
        "135056226": [
            "%s: error fetching interface information: %s",
            [
                134603933
            ]
        ],
        "135056271": [
            "X bytes:%llu (%llu.%u %sB)%s",
            [
                134604557
            ]
        ],
        "135056300": [
            "%-9s Link encap:%s  ",
            [
                134604780
            ]
        ],
        "135056321": [
            "HWaddr %s  ",
            [
                134604780
            ]
        ],
        "135056333": [
            "Media:%s",
            [
                134604780
            ]
        ],
        "135056342": [
            "(auto)",
            [
                134604780
            ]
        ],
        "135056349": [
            "          %s addr:%s ",
            [
                134604780
            ]
        ],
        "135056371": [
            " P-t-P:%s ",
            [
                134604780
            ]
        ],
        "135056382": [
            " Bcast:%s ",
            [
                134604780
            ]
        ],
        "135056393": [
            " Mask:%s\n",
            [
                134604780
            ]
        ],
        "135056403": [
            "/proc/net/if_inet6",
            [
                134604780
            ]
        ],
        "135056422": [
            "%s:%s:%s:%s:%s:%s:%s:%s",
            [
                134604780
            ]
        ],
        "135056446": [
            "          inet6 addr: %s/%d",
            [
                134604780
            ]
        ],
        "135056474": [
            " Scope:",
            [
                134604780
            ]
        ],
        "135056482": [
            "Global",
            [
                134604780
            ]
        ],
        "135056494": [
            "Compat",
            [
                134604780
            ]
        ],
        "135056506": [
            "Unknown",
            [
                134721331,
                134604780
            ]
        ],
        "135056514": [
            "%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n",
            [
                134604780
            ]
        ],
        "135056570": [
            "     ",
            [
                134568282
            ]
        ],
        "135056576": [
            "[NO FLAGS] ",
            [
                134604780
            ]
        ],
        "135056588": [
            " MTU:%d  Metric:%d",
            [
                134604780
            ]
        ],
        "135056607": [
            "RX packets:%llu errors:%lu dropped:%lu overruns:%lu frame:%lu\n",
            [
                134604780
            ]
        ],
        "135056670": [
            "             compressed:%lu\n",
            [
                134604780
            ]
        ],
        "135056699": [
            "TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\n",
            [
                134604780
            ]
        ],
        "135056764": [
            "          collisions:%lu ",
            [
                134604780
            ]
        ],
        "135056790": [
            "compressed:%lu ",
            [
                134604780
            ]
        ],
        "135056806": [
            "txqueuelen:%d ",
            [
                134604780
            ]
        ],
        "135056821": [
            "\n          R",
            [
                134604780
            ]
        ],
        "135056838": [
            "Interrupt:%d ",
            [
                134604780
            ]
        ],
        "135056852": [
            "Base address:0x%lx ",
            [
                134604780
            ]
        ],
        "135056872": [
            "Memory:%lx-%lx ",
            [
                134604780
            ]
        ],
        "135056888": [
            "DMA chan:%x ",
            [
                134604780
            ]
        ],
        "135056901": [
            "SIOCGIFCONF",
            [
                134606084
            ]
        ],
        "135056916": [
            "BROADCAST",
            []
        ],
        "135056926": [
            "DEBUG",
            []
        ],
        "135056932": [
            "LOOPBACK",
            []
        ],
        "135056941": [
            "POINTOPOINT",
            []
        ],
        "135056953": [
            "NOTRAILERS",
            []
        ],
        "135056964": [
            "RUNNING",
            []
        ],
        "135056972": [
            "NOARP",
            []
        ],
        "135056978": [
            "PROMISC",
            []
        ],
        "135056986": [
            "ALLMULTI",
            []
        ],
        "135056995": [
            "SLAVE",
            []
        ],
        "135057001": [
            "MASTER",
            []
        ],
        "135057008": [
            "MULTICAST",
            []
        ],
        "135057034": [
            "10base2",
            [
                4294967295
            ]
        ],
        "135057042": [
            "10baseT",
            [
                4294967295
            ]
        ],
        "135057054": [
            "100baseT",
            [
                4294967295
            ]
        ],
        "135057063": [
            "100baseTX",
            [
                4294967295
            ]
        ],
        "135057073": [
            "100baseFX",
            [
                4294967295
            ]
        ],
        "135057083": [
            "infiniband",
            [
                4294967295
            ]
        ],
        "135057094": [
            "InfiniBand",
            [
                4294967295
            ]
        ],
        "135057105": [
            "IPv6-in-IPv4",
            [
                4294967295
            ]
        ],
        "135057118": [
            "Point-to-Point Protocol",
            [
                4294967295
            ]
        ],
        "135057142": [
            "Ethernet",
            [
                4294967295
            ]
        ],
        "135057156": [
            "Local Loopback",
            [
                4294967295
            ]
        ],
        "135057171": [
            "unspec",
            [
                4294967295,
                134649167
            ]
        ],
        "135057178": [
            "UNSPEC",
            [
                4294967295
            ]
        ],
        "135057185": [
            "%n%llu%u%u%u%u%n%n%n%llu%u%u%u%u%u",
            [
                4294967295
            ]
        ],
        "135057220": [
            "%llu%llu%u%u%u%u%n%n%llu%llu%u%u%u%u%u",
            [
                4294967295
            ]
        ],
        "135057259": [
            "%llu%llu%u%u%u%u%u%u%llu%llu%u%u%u%u%u%u",
            [
                4294967295
            ]
        ],
        "135057305": [
            "DARPA Internet",
            [
                4294967295
            ]
        ],
        "135057320": [
            "address",
            [
                134606475
            ]
        ],
        "135057328": [
            "route",
            []
        ],
        "135057341": [
            "tunnel",
            []
        ],
        "135057358": [
            "neigh",
            []
        ],
        "135057365": [
            "interface name '%s' too long",
            [
                134606524
            ]
        ],
        "135057399": [
            "can't parse %s",
            [
                134606524
            ]
        ],
        "135057414": [
            "/etc/mactab",
            [
                134606666
            ]
        ],
        "135057430": [
            "can't change ifname %s to %s",
            [
                134606666
            ]
        ],
        "135057469": [
            "CONNECTED",
            [
                134607124
            ]
        ],
        "135057479": [
            "DISCONNECTING",
            [
                134607124
            ]
        ],
        "135057493": [
            "LISTENING",
            [
                134607124
            ]
        ],
        "135057503": [
            "%*p: %lX %lX %lX %X %X %lu %n",
            [
                134607124
            ]
        ],
        "135057547": [
            "%-5s %-6lu %-11s %-10s %-13s %6lu ",
            [
                134607124
            ]
        ],
        "135057582": [
            "%08X%08X%08X%08X",
            [
                134607559
            ]
        ],
        "135057599": [
            "%s   %6lu %6lu %-23s %-23s %-12s",
            [
                134607761
            ]
        ],
        "135057632": [
            "%s: bogus data on line %d",
            [
                134607924
            ]
        ],
        "135057658": [
            "%*d: %32[0-9A-Fa-f]:%X %32[0-9A-Fa-f]:%X %X %lX:%lX %*X:%*X %*X %d %*d %lu ",
            [
                134608019
            ]
        ],
        "135057737": [
            "ESTABLISHED",
            [
                134608289,
                4294967295
            ]
        ],
        "135057749": [
            "laentuwxr",
            [
                134608503
            ]
        ],
        "135057759": [
            "Active Internet connections ",
            [
                134608503
            ]
        ],
        "135057788": [
            "(servers and established)",
            [
                134608503
            ]
        ],
        "135057814": [
            "(only servers)",
            [
                134608503
            ]
        ],
        "135057829": [
            "(w/o servers)",
            [
                134608503
            ]
        ],
        "135057843": [
            "Foreign Address",
            [
                134608503
            ]
        ],
        "135057859": [
            "Local Address",
            [
                134608503
            ]
        ],
        "135057873": [
            "\nProto Recv-Q Send-Q %-23s %-23s State       %s\n",
            [
                134608503
            ]
        ],
        "135057922": [
            "/proc/net/tcp",
            [
                134608503
            ]
        ],
        "135057936": [
            "/proc/net/tcp6",
            [
                134608503
            ]
        ],
        "135057951": [
            "/proc/net/udp",
            [
                134608503
            ]
        ],
        "135057965": [
            "/proc/net/udp6",
            [
                134608503
            ]
        ],
        "135057980": [
            "/proc/net/raw",
            [
                134608503
            ]
        ],
        "135057994": [
            "/proc/net/raw6",
            [
                134608503
            ]
        ],
        "135058009": [
            "Active UNIX domain sockets ",
            [
                134608503
            ]
        ],
        "135058037": [
            "\nProto RefCnt Flags       Type       State         I-Node %sPath\n",
            [
                134608503
            ]
        ],
        "135058103": [
            "/proc/net/",
            [
                134608503
            ]
        ],
        "135058118": [
            "STREAM",
            [
                4294967295
            ]
        ],
        "135058125": [
            "DGRAM",
            [
                4294967295
            ]
        ],
        "135058142": [
            "PACKET",
            [
                134656745
            ]
        ],
        "135058149": [
            "SYN_SENT",
            [
                4294967295
            ]
        ],
        "135058158": [
            "SYN_RECV",
            [
                4294967295
            ]
        ],
        "135058167": [
            "FIN_WAIT1",
            [
                4294967295
            ]
        ],
        "135058177": [
            "FIN_WAIT2",
            [
                4294967295
            ]
        ],
        "135058187": [
            "TIME_WAIT",
            [
                4294967295
            ]
        ],
        "135058197": [
            "CLOSE",
            [
                4294967295
            ]
        ],
        "135058203": [
            "CLOSE_WAIT",
            [
                4294967295
            ]
        ],
        "135058214": [
            "LAST_ACK",
            [
                4294967295
            ]
        ],
        "135058223": [
            "LISTEN",
            [
                4294967295
            ]
        ],
        "135058230": [
            "CLOSING",
            [
                4294967295
            ]
        ],
        "135058238": [
            "%s\tname = %s\n",
            [
                134609063
            ]
        ],
        "135058252": [
            "%s\tcanonical name = %s\n",
            [
                134609063
            ]
        ],
        "135058276": [
            "%s\tnameserver = %s\n",
            [
                134609063
            ]
        ],
        "135058296": [
            "write to '%s'",
            [
                134609063
            ]
        ],
        "135058310": [
            "Server:\t",
            [
                134609063
            ]
        ],
        "135058323": [
            "Address:\t%s\n\n",
            [
                134609063
            ]
        ],
        "135058337": [
            "Query #%d completed in %ums:\n",
            [
                134609063
            ]
        ],
        "135058367": [
            "** server can't find %s: %s\n",
            [
                134609063
            ]
        ],
        "135058396": [
            "Non-authoritative answer:\n",
            [
                134609063
            ]
        ],
        "135058423": [
            "Name:\t%s\nAddress: %s\n",
            [
                134609063
            ]
        ],
        "135058445": [
            "MX record too short\n",
            [
                134609063
            ]
        ],
        "135058466": [
            "%s\tmail exchanger = %d %s\n",
            [
                134609063
            ]
        ],
        "135058493": [
            "%s\ttext = \"%s\"\n",
            [
                134609063
            ]
        ],
        "135058509": [
            "\torigin = %s\n",
            [
                134609063
            ]
        ],
        "135058523": [
            "\tmail addr = %s\n",
            [
                134609063
            ]
        ],
        "135058540": [
            "\tserial = %lu\n",
            [
                134609063
            ]
        ],
        "135058555": [
            "\trefresh = %lu\n",
            [
                134609063
            ]
        ],
        "135058571": [
            "\tretry = %lu\n",
            [
                134609063
            ]
        ],
        "135058585": [
            "\texpire = %lu\n",
            [
                134609063
            ]
        ],
        "135058600": [
            "\tminimum = %lu\n",
            [
                134609063
            ]
        ],
        "135058616": [
            "*** Can't find %s: Parse error\n",
            [
                134609063
            ]
        ],
        "135058653": [
            "querytype",
            []
        ],
        "135058668": [
            "retry",
            []
        ],
        "135058674": [
            "debug",
            []
        ],
        "135058682": [
            "timeout",
            []
        ],
        "135058691": [
            "invalid query type \"%s\"",
            [
                134610720
            ]
        ],
        "135058715": [
            "ip6.arpa",
            [
                134610720
            ]
        ],
        "135058724": [
            "%u.%u.%u.%u.in-addr.arpa",
            [
                134610720
            ]
        ],
        "135058749": [
            "/etc/resolv.conf",
            [
                134610720
            ]
        ],
        "135058766": [
            "nameserver",
            [
                134610720
            ]
        ],
        "135058777": [
            "127.0.0.1",
            [
                134610720
            ]
        ],
        "135058787": [
            ";; connection timed out; no servers could be reached\n\n",
            [
                134610720
            ]
        ],
        "135058842": [
            "*** Can't find %s: No answer\n",
            [
                134610720
            ]
        ],
        "135058872": [
            "NOERROR",
            [
                4294967295
            ]
        ],
        "135058880": [
            "FORMERR",
            [
                4294967295
            ]
        ],
        "135058888": [
            "SERVFAIL",
            [
                4294967295
            ]
        ],
        "135058897": [
            "NXDOMAIN",
            [
                4294967295
            ]
        ],
        "135058906": [
            "NOTIMP",
            [
                4294967295
            ]
        ],
        "135058913": [
            "REFUSED",
            [
                4294967295
            ]
        ],
        "135058921": [
            "YXDOMAIN",
            [
                4294967295
            ]
        ],
        "135058930": [
            "YXRRSET",
            [
                4294967295
            ]
        ],
        "135058938": [
            "NXRRSET",
            [
                4294967295
            ]
        ],
        "135058946": [
            "NOTAUTH",
            [
                4294967295
            ]
        ],
        "135058954": [
            "NOTZONE",
            [
                4294967295
            ]
        ],
        "135058974": [
            "\n--- %s ping statistics ---\n%lu packets transmitted, %lu packets received, ",
            [
                134611583
            ]
        ],
        "135059050": [
            "%lu duplicates, ",
            [
                134611583
            ]
        ],
        "135059067": [
            "%lu%% packet loss\n",
            [
                134611583
            ]
        ],
        "135059086": [
            "round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\n",
            [
                134611583
            ]
        ],
        "135059139": [
            " (DUP!)",
            [
                134612104
            ]
        ],
        "135059147": [
            "unknown ICMP ",
            [
                134612104,
                4294967295
            ]
        ],
        "135059165": [
            "PING %s (%s)",
            [
                134612104
            ]
        ],
        "135059178": [
            ": %d data bytes\n",
            [
                134612104
            ]
        ],
        "135059195": [
            "can't set multicast source interface",
            [
                134612104,
                134621773
            ]
        ],
        "135059232": [
            "%d bytes from %s: seq=%u ttl=%d",
            [
                134612104
            ]
        ],
        "135059264": [
            " time=%u.%03u ms",
            [
                134612104
            ]
        ],
        "135059281": [
            "warning: got ICMP %d (%s)",
            [
                134612104
            ]
        ],
        "135059307": [
            "^qvAc:+s:t:+w:+W:+I:np:4",
            [
                134612104
            ]
        ],
        "135059332": [
            "=1:q--v:v--q",
            []
        ],
        "135059345": [
            "Echo Reply",
            [
                4294967295
            ]
        ],
        "135059356": [
            "Destination Unreachable",
            [
                4294967295
            ]
        ],
        "135059380": [
            "Source Quench",
            [
                4294967295
            ]
        ],
        "135059394": [
            "Redirect (change route)",
            [
                4294967295
            ]
        ],
        "135059418": [
            "Echo Request",
            [
                4294967295
            ]
        ],
        "135059431": [
            "Time Exceeded",
            [
                4294967295
            ]
        ],
        "135059445": [
            "Parameter Problem",
            [
                4294967295
            ]
        ],
        "135059463": [
            "Timestamp Request",
            [
                4294967295
            ]
        ],
        "135059481": [
            "Timestamp Reply",
            [
                4294967295
            ]
        ],
        "135059497": [
            "Information Request",
            [
                4294967295
            ]
        ],
        "135059517": [
            "Information Reply",
            [
                4294967295
            ]
        ],
        "135059535": [
            "Address Mask Re",
            [
                4294967295
            ]
        ],
        "135059550": [
            "quest",
            [
                134588071
            ]
        ],
        "135059556": [
            "Address Mask Reply",
            [
                4294967295
            ]
        ],
        "135059575": [
            "/proc/net/ipv6_route",
            [
                134613382
            ]
        ],
        "135059596": [
            "Next Hop",
            [
                134613382
            ]
        ],
        "135059605": [
            "Destination",
            [
                134613382
            ]
        ],
        "135059617": [
            "Kernel IPv6 routing table\n%-44s%-40sFlags Metric Ref    Use Iface\n",
            [
                134613382
            ]
        ],
        "135059684": [
            "%32s%x%*s%x%32s%x%x%x%x%s\n",
            [
                134613382
            ]
        ],
        "135059711": [
            "%-43s %-39s %-5s %-6d %-2d %7d %-8s\n",
            [
                134613382
            ]
        ],
        "135059748": [
            "resolving %s",
            [
                134614289,
                134613799
            ]
        ],
        "135059761": [
            "SIOCADDRT",
            [
                134614289,
                134613799
            ]
        ],
        "135059771": [
            "SIOCDELRT",
            [
                134614289,
                134613799
            ]
        ],
        "135059781": [
            "gateway %s is a NETWORK",
            [
                134614289
            ]
        ],
        "135059805": [
            "netmask %.8x and host route conflict",
            [
                134614289
            ]
        ],
        "135059842": [
            "bogus netmask %s",
            [
                134614289
            ]
        ],
        "135059859": [
            "netmask and route address conflict",
            [
                134614289
            ]
        ],
        "135059894": [
            "  MSS Window  irtt",
            [
                134615047
            ]
        ],
        "135059913": [
            "Metric Ref    Use",
            [
                134615047
            ]
        ],
        "135059931": [
            "/proc/net/route",
            [
                134615047
            ]
        ],
        "135059947": [
            "Kernel IP routing table\nDestination     Gateway         Genmask         Flags %s Iface\n",
            [
                134615047
            ]
        ],
        "135060035": [
            "%*[^\n]\n",
            [
                134615047
            ]
        ],
        "135060043": [
            "%63s%lx%lx%X%d%d%d%lx%d%d%d\n",
            [
                134615047
            ]
        ],
        "135060072": [
            "%-15.15s %-15.15s %-16s%-6s",
            [
                134615047
            ]
        ],
        "135060100": [
            "%5d %-5d %6d %s\n",
            [
                134615047
            ]
        ],
        "135060117": [
            "%-6d %-2d %7d %s\n",
            [
                134615047
            ]
        ],
        "135060140": [
            "-host",
            [
                134615447
            ]
        ],
        "135060173": [
            "GHRDMDAC!n",
            []
        ],
        "135060186": [
            "metric",
            []
        ],
        "135060195": [
            "netmask",
            []
        ],
        "135060210": [
            "gateway",
            []
        ],
        "135060226": [
            "window",
            []
        ],
        "135060248": [
            "device",
            []
        ],
        "135060255": [
            "\t reject",
            []
        ],
        "135060276": [
            "\u000b#reinstate",
            []
        ],
        "135060297": [
            "#host",
            []
        ],
        "135060307": [
            "%x:%x",
            [
                134615688
            ]
        ],
        "135060318": [
            "CBQ: too short %s opt",
            [
                134615761
            ]
        ],
        "135060353": [
            "CBQ: too short overlimit strategy %u/%u",
            [
                134615761
            ]
        ],
        "135060393": [
            "%.0fMbit",
            [
                134615761
            ]
        ],
        "135060402": [
            "%.0fKbit",
            [
                134615761
            ]
        ],
        "135060411": [
            "%.0fbit",
            [
                134615761
            ]
        ],
        "135060419": [
            "rate %s ",
            [
                134615761
            ]
        ],
        "135060428": [
            "bounded",
            [
                134615761
            ]
        ],
        "135060436": [
            "isolated",
            [
                134615761
            ]
        ],
        "135060445": [
            "prio %u",
            [
                134615761
            ]
        ],
        "135060453": [
            "prio no-transmit",
            [
                134615761
            ]
        ],
        "135060470": [
            "deleted ",
            [
                134616272,
                134616741
            ]
        ],
        "135060479": [
            "qdisc %s %x: ",
            [
                134616272
            ]
        ],
        "135060493": [
            "root ",
            [
                134616272,
                134616741
            ]
        ],
        "135060499": [
            "parent %s ",
            [
                134616272,
                134616741
            ]
        ],
        "135060510": [
            "refcnt %d ",
            [
                134616272
            ]
        ],
        "135060521": [
            "bands %u priomap ",
            [
                134616272
            ]
        ],
        "135060539": [
            " multiqueue: o%s ",
            [
                134616272
            ]
        ],
        "135060557": [
            "class %s %s",
            [
                134616741
            ]
        ],
        "135060569": [
            "leaf %x ",
            [
                134616741
            ]
        ],
        "135060578": [
            "qdisc",
            [
                134617090
            ]
        ],
        "135060584": [
            "parent",
            [
                134617090
            ]
        ],
        "135060591": [
            "protocol",
            [
                134617090,
                134639324
            ]
        ],
        "135060600": [
            "can't send dump request",
            [
                134617090,
                134639324,
                134635242
            ]
        ],
        "135060624": [
            "pfifo_fast",
            [
                134616741
            ]
        ],
        "135060640": [
            "pfifo_fast",
            [
                134616272
            ]
        ],
        "135060665": [
            "parent",
            []
        ],
        "135060672": [
            "qdisc",
            []
        ],
        "135060678": [
            "handle",
            []
        ],
        "135060685": [
            "classid",
            []
        ],
        "135060693": [
            "preference",
            []
        ],
        "135060704": [
            "priority",
            []
        ],
        "135060713": [
            "protocol",
            []
        ],
        "135060727": [
            "delete",
            []
        ],
        "135060734": [
            "change",
            []
        ],
        "135060746": [
            "replace",
            []
        ],
        "135060765": [
            "qdisc",
            [
                134617090
            ]
        ],
        "135060771": [
            "class",
            []
        ],
        "135060777": [
            "filter",
            []
        ],
        "135060785": [
            "\r\nEntering %s mode\r\nEscape character is '^%c'.\r\n",
            [
                134618213
            ]
        ],
        "135060834": [
            "\r\nConsole escape. Commands are:\r\n\n l\tgo to line mode\r\n c\tgo to character mode\r\n z\tsuspend telnet\r\n e\texit telnet\r\n",
            [
                134618300
            ]
        ],
        "135060949": [
            "continuing...\r\n",
            [
                134618300
            ]
        ],
        "135060969": [
            "Connection closed by foreign host\r\n",
            [
                134618670
            ]
        ],
        "135061005": [
            "bad blocksize '%s'",
            [
                134620140
            ]
        ],
        "135061024": [
            "remote filename is too long",
            [
                134620197
            ]
        ],
        "135061052": [
            "octet",
            [
                134620197
            ]
        ],
        "135061058": [
            "blksize",
            [
                134620197
            ]
        ],
        "135061066": [
            "tsize",
            [
                134620197
            ]
        ],
        "135061072": [
            "server error: (%u) %s",
            [
                134620197
            ]
        ],
        "135061094": [
            "falling back to blocksize 512",
            [
                134620197
            ]
        ],
        "135061124": [
            "^gpl:r:b:",
            [
                134620197
            ]
        ],
        "135061134": [
            "g:p:g--p:p--g:",
            []
        ],
        "135061270": [
            "^FIlnrdvxt:i:m:p:q:s:w:z:f:4",
            [
                134621773
            ]
        ],
        "135061299": [
            "-1:x-x",
            []
        ],
        "135061306": [
            "SO_SNDBUF",
            [
                134621773
            ]
        ],
        "135061320": [
            "setsockopt(%s) %d",
            [
                134621773
            ]
        ],
        "135061338": [
            "traceroute to %s (%s)",
            [
                134621773
            ]
        ],
        "135061360": [
            ", %d hops max, %d byte packets\n",
            [
                134621773
            ]
        ],
        "135061400": [
            "sent %d octets, ret=%d",
            [
                134621773
            ]
        ],
        "135061423": [
            "  %s (%s)",
            [
                134621773
            ]
        ],
        "135061433": [
            "  %u.%03u ms",
            [
                134621773
            ]
        ],
        "135061446": [
            " (%d)",
            [
                134621773
            ]
        ],
        "135061467": [
            " !F-%d",
            [
                134621773
            ]
        ],
        "135061502": [
            " !<%d>",
            [
                134621773
            ]
        ],
        "135061509": [
            "ioctl error for %s",
            [
                134623848
            ]
        ],
        "135061621": [
            "set_name_type",
            []
        ],
        "135061638": [
            "set_flag",
            []
        ],
        "135061650": [
            "set_egress_map",
            []
        ],
        "135061668": [
            "set_ingress_map",
            []
        ],
        "135061684": [
            "download timed out",
            [
                134624064,
                134625028
            ]
        ],
        "135061706": [
            "error getting response",
            [
                134624217
            ]
        ],
        "135061729": [
            "restart failed",
            [
                134624350
            ]
        ],
        "135061748": [
            "not an http or ftp url: %s",
            [
                134624395
            ]
        ],
        "135061775": [
            "bad header line: %s",
            [
                134624684
            ]
        ],
        "135061795": [
            "bad chunk length '%s'",
            [
                134625028
            ]
        ],
        "135061817": [
            "%s%s\r\n",
            [
                134625522
            ]
        ],
        "135061824": [
            "--> %s%s\n\n",
            [
                134625522
            ]
        ],
        "135061835": [
            "ftp_proxy",
            [
                134625655
            ]
        ],
        "135061845": [
            "http_proxy",
            [
                134625655
            ]
        ],
        "135061861": [
            "anonymous",
            [
                134625655
            ]
        ],
        "135061876": [
            "index.html",
            [
                134625655
            ]
        ],
        "135061887": [
            "Connecting to %s (%s)\n",
            [
                134625655
            ]
        ],
        "135061910": [
            "GET %s://%s/%s HTTP/1.1\r\n",
            [
                134625655
            ]
        ],
        "135061936": [
            "%s /%s HTTP/1.1\r\n",
            [
                134625655
            ]
        ],
        "135061954": [
            "Host: %s\r\n",
            [
                134625655
            ]
        ],
        "135061965": [
            "User-Agent: ",
            [
                134625655
            ]
        ],
        "135061982": [
            "Connection: close\r\n",
            [
                134625655
            ]
        ],
        "135062002": [
            "Proxy-",
            [
                134625655
            ]
        ],
        "135062008": [
            "Authorization: Basic %s\r\n",
            [
                134625655
            ]
        ],
        "135062034": [
            "Range: bytes=%llu-\r\n",
            [
                134625655
            ]
        ],
        "135062055": [
            "Content-Type: application/x-www-form-urlencoded\r\nContent-Length: %u\r\n",
            [
                134625655
            ]
        ],
        "135062129": [
            "server returned error: %s",
            [
                134625655
            ]
        ],
        "135062155": [
            "content-length %s is garbage",
            [
                134625655
            ]
        ],
        "135062184": [
            "chunked",
            [
                134625655
            ]
        ],
        "135062192": [
            "transfer encoding '%s' is not supported",
            [
                134625655
            ]
        ],
        "135062232": [
            "too many redirections",
            [
                134625655
            ]
        ],
        "135062254": [
            "USER ",
            [
                134625655
            ]
        ],
        "135062260": [
            "PASS ",
            [
                134625655
            ]
        ],
        "135062266": [
            "ftp login: %s",
            [
                134625655
            ]
        ],
        "135062280": [
            "TYPE I",
            [
                134625655
            ]
        ],
        "135062287": [
            "SIZE ",
            [
                134625655
            ]
        ],
        "135062293": [
            "bad SIZE value '%s'",
            [
                134625655
            ]
        ],
        "135062323": [
            "bad response to %s: %s",
            [
                134625655
            ]
        ],
        "135062346": [
            "REST ",
            [
                134625655
            ]
        ],
        "135062356": [
            "RETR ",
            [
                134625655
            ]
        ],
        "135062367": [
            "ftp error: %s",
            [
                134625655
            ]
        ],
        "135062381": [
            "^cqSO:P:Y:U:T:+t:n::",
            [
                134625655
            ]
        ],
        "135062409": [
            "content-length",
            [
                134625655
            ]
        ],
        "135062424": [
            "transfer-encoding",
            []
        ],
        "135062442": [
            "location",
            []
        ],
        "135062452": [
            "continue",
            [
                134625655
            ]
        ],
        "135062462": [
            "cquiet",
            []
        ],
        "135062470": [
            "qserver-response",
            []
        ],
        "135062488": [
            "Soutput-document",
            []
        ],
        "135062506": [
            "Odirectory-prefix",
            []
        ],
        "135062525": [
            "Pproxy",
            []
        ],
        "135062533": [
            "Yuser-agent",
            []
        ],
        "135062546": [
            "Utimeout",
            []
        ],
        "135062556": [
            "Ttries",
            []
        ],
        "135062564": [
            "theader",
            []
        ],
        "135062574": [
            "post-data",
            []
        ],
        "135062586": [
            "spider",
            []
        ],
        "135062595": [
            "no-check-certificate",
            []
        ],
        "135062618": [
            "passive-ftp",
            []
        ],
        "135062632": [
            "no-cache",
            []
        ],
        "135062643": [
            "no-verbose",
            []
        ],
        "135062656": [
            "no-clobber",
            []
        ],
        "135062669": [
            "no-host-directories",
            []
        ],
        "135062691": [
            "no-parent",
            []
        ],
        "135062704": [
            "Host:",
            [
                134625655
            ]
        ],
        "135062710": [
            "User-Agent:",
            []
        ],
        "135062722": [
            "Range:",
            []
        ],
        "135062729": [
            "Authorization:",
            []
        ],
        "135062744": [
            "Proxy-Authorization:",
            []
        ],
        "135062783": [
            "inet6",
            []
        ],
        "135062795": [
            "oneline",
            [
                134628117
            ]
        ],
        "135062803": [
            "family",
            []
        ],
        "135062817": [
            "can't send flush request",
            [
                134636874,
                134635188,
                134628351
            ]
        ],
        "135062842": [
            "Deleted ",
            [
                134636928,
                134629433,
                134628405
            ]
        ],
        "135062851": [
            "%u: %s",
            [
                134628405
            ]
        ],
        "135062858": [
            "    inet ",
            [
                134628405
            ]
        ],
        "135062868": [
            "    inet6 ",
            [
                134628405
            ]
        ],
        "135062879": [
            "    family %d ",
            [
                134628405
            ]
        ],
        "135062894": [
            " peer %s/%d ",
            [
                134628405
            ]
        ],
        "135062907": [
            "brd %s ",
            [
                134628405
            ]
        ],
        "135062915": [
            "any %s ",
            [
                134628405
            ]
        ],
        "135062923": [
            "scope %s ",
            [
                134636928,
                134628405
            ]
        ],
        "135062933": [
            "secondary ",
            [
                134628405
            ]
        ],
        "135062944": [
            "tentative ",
            [
                134628405
            ]
        ],
        "135062955": [
            "deprecated ",
            [
                134628405
            ]
        ],
        "135062967": [
            "dynamic ",
            [
                134628405
            ]
        ],
        "135062976": [
            "flags ",
            [
                134628405
            ]
        ],
        "135062982": [
            "%02x ",
            [
                134569792,
                134568282
            ]
        ],
        "135062988": [
            "valid_lft forever",
            [
                134628405
            ]
        ],
        "135063006": [
            "valid_lft %dsec",
            [
                134628405
            ]
        ],
        "135063022": [
            " preferred_lft forever",
            [
                134628405
            ]
        ],
        "135063045": [
            " preferred_lft %dsec",
            [
                134628405
            ]
        ],
        "135063066": [
            "     ",
            [
                134628405
            ]
        ],
        "135063076": [
            "nil ifname",
            [
                134629433
            ]
        ],
        "135063087": [
            "%d: %s",
            [
                134629433
            ]
        ],
        "135063094": [
            "@NONE: ",
            [
                134629433
            ]
        ],
        "135063102": [
            "@%s: ",
            [
                134629433
            ]
        ],
        "135063108": [
            "NO-CARRIER,",
            [
                134629433
            ]
        ],
        "135063120": [
            ",M-DOWN",
            [
                134629433
            ]
        ],
        "135063128": [
            "mtu %u ",
            [
                134629433
            ]
        ],
        "135063136": [
            "qdisc %s ",
            [
                134629433
            ]
        ],
        "135063146": [
            "master %s ",
            [
                134629433
            ]
        ],
        "135063157": [
            "SIOCGIFTXQLEN",
            [
                134629433
            ]
        ],
        "135063171": [
            "qlen %d",
            [
                134629433
            ]
        ],
        "135063179": [
            "%c    link/%s ",
            [
                134629433
            ]
        ],
        "135063194": [
            " peer ",
            [
                134629433
            ]
        ],
        "135063201": [
            " brd ",
            [
                134629433
            ]
        ],
        "135063207": [
            "scope",
            [
                134639324,
                134630220,
                134631317
            ]
        ],
        "135063213": [
            "need \"dev IFACE\"",
            [
                134630220
            ]
        ],
        "135063230": [
            "\"dev\" (%s) must match \"label\" (%s)",
            [
                134630220
            ]
        ],
        "135063265": [
            "broadcast can be set only for IPv4 addresses",
            [
                134630220
            ]
        ],
        "135063310": [
            "can't flush link addresses",
            [
                134631317
            ]
        ],
        "135063342": [
            "remote",
            []
        ],
        "135063349": [
            "broadcast",
            [
                134630220
            ]
        ],
        "135063363": [
            "anycast",
            [
                134630220
            ]
        ],
        "135063371": [
            "scope",
            []
        ],
        "135063381": [
            "label",
            []
        ],
        "135063387": [
            "local",
            []
        ],
        "135063398": [
            "change",
            []
        ],
        "135063409": [
            "replace",
            []
        ],
        "135063417": [
            "delete",
            []
        ],
        "135063438": [
            "flush",
            []
        ],
        "135063445": [
            "LOOPBACK",
            [
                134629433
            ]
        ],
        "135063454": [
            "BROADCAST",
            []
        ],
        "135063464": [
            "POINTOPOINT",
            []
        ],
        "135063476": [
            "MULTICAST",
            []
        ],
        "135063486": [
            "NOARP",
            []
        ],
        "135063495": [
            "LOWER_UP",
            []
        ],
        "135063508": [
            "scope",
            []
        ],
        "135063517": [
            "label",
            []
        ],
        "135063528": [
            "type ",
            [
                134632747
            ]
        ],
        "135063538": [
            "unknown VLAN encapsulation protocol '%s'",
            [
                134632747
            ]
        ],
        "135063579": [
            "argument of \"%s\" must be \"on\" or \"off\"",
            [
                134633890,
                134632747
            ]
        ],
        "135063618": [
            "type vrf",
            [
                134632747
            ]
        ],
        "135063640": [
            "\"dev\"",
            [
                134633890
            ]
        ],
        "135063646": [
            "wrong address (%s) length: expected %d bytes",
            [
                134633890
            ]
        ],
        "135063691": [
            "SIOCSIFHWADDR",
            [
                134633890
            ]
        ],
        "135063705": [
            "SIOCSIFNAME",
            [
                134633890
            ]
        ],
        "135063717": [
            "SIOCSIFTXQLEN",
            [
                134633890
            ]
        ],
        "135063731": [
            "SIOCSIFMTU",
            [
                134633890
            ]
        ],
        "135063764": [
            "multicast",
            []
        ],
        "135063778": [
            "promisc",
            []
        ],
        "135063786": [
            "address",
            []
        ],
        "135063794": [
            "master",
            []
        ],
        "135063801": [
            "nomaster",
            []
        ],
        "135063815": [
            "802.1q",
            [
                134632747
            ]
        ],
        "135063822": [
            "802.1ad",
            []
        ],
        "135063834": [
            "protocol",
            []
        ],
        "135063843": [
            "reorder_hdr",
            []
        ],
        "135063865": [
            "loose_binding",
            []
        ],
        "135063899": [
            "address",
            []
        ],
        "135063912": [
            "delete",
            []
        ],
        "135063938": [
            "\"ip neigh flush\"",
            [
                134635242
            ]
        ],
        "135063955": [
            "nud state",
            [
                134635242
            ]
        ],
        "135063965": [
            "can't find device '%s'",
            [
                134635242,
                134648618
            ]
        ],
        "135063988": [
            "flush terminated",
            [
                134635242
            ]
        ],
        "135064005": [
            "Nothing to ",
            [
                134635242
            ]
        ],
        "135064016": [
            "flush",
            [
                134631317
            ]
        ],
        "135064022": [
            "*** Flush is complete after %d round(s) ***\n",
            [
                134635242
            ]
        ],
        "135064067": [
            "\n*** Round %d, deleting %d entries ***\n",
            [
                134635242
            ]
        ],
        "135064107": [
            "*** Flush not complete bailing out after %d rounds",
            [
                134635242
            ]
        ],
        "135064158": [
            "dump terminated",
            [
                134646705,
                134635242
            ]
        ],
        "135064174": [
            "not RTM_NEWNEIGH: %08x %08x %08x",
            [
                134635922
            ]
        ],
        "135064207": [
            "BUG: ",
            [
                134635922
            ]
        ],
        "135064212": [
            "wrong nlmsg len %d",
            [
                134636928,
                134628405
            ]
        ],
        "135064231": [
            "lladdr %s",
            [
                134635922
            ]
        ],
        "135064241": [
            " router",
            [
                134635922
            ]
        ],
        "135064249": [
            " proxy",
            [
                134635922
            ]
        ],
        "135064256": [
            " ref %d",
            [
                134635922
            ]
        ],
        "135064264": [
            " used %d/%d/%d",
            [
                134635922
            ]
        ],
        "135064279": [
            " probes %u",
            [
                134635922
            ]
        ],
        "135064290": [
            "%cINCOMPLETE",
            [
                134635922
            ]
        ],
        "135064303": [
            "%cREACHABLE",
            [
                134635922
            ]
        ],
        "135064315": [
            "%cSTALE",
            [
                134635922
            ]
        ],
        "135064323": [
            "%cDELAY",
            [
                134635922
            ]
        ],
        "135064331": [
            "%cPROBE",
            [
                134635922
            ]
        ],
        "135064339": [
            "%cFAILED",
            [
                134635922
            ]
        ],
        "135064348": [
            "%cNOARP",
            [
                134635922
            ]
        ],
        "135064356": [
            "%cPERMANENT",
            [
                134635922
            ]
        ],
        "135064377": [
            "permanent",
            [
                134635242
            ]
        ],
        "135064387": [
            "reachable",
            []
        ],
        "135064397": [
            "noarp",
            []
        ],
        "135064408": [
            "stale",
            []
        ],
        "135064414": [
            "incomplete",
            []
        ],
        "135064425": [
            "delay",
            []
        ],
        "135064431": [
            "probe",
            []
        ],
        "135064437": [
            "failed",
            []
        ],
        "135064462": [
            "flush",
            []
        ],
        "135064469": [
            "Not a route: %08x %08x %08x\n",
            [
                134636928
            ]
        ],
        "135064498": [
            "default ",
            [
                134636928
            ]
        ],
        "135064507": [
            "from ",
            [
                134636928
            ]
        ],
        "135064512": [
            "%s/%u ",
            [
                134636928
            ]
        ],
        "135064519": [
            "from %s ",
            [
                134636928
            ]
        ],
        "135064528": [
            "from 0/%u ",
            [
                134636928
            ]
        ],
        "135064539": [
            "via %s ",
            [
                134636928
            ]
        ],
        "135064547": [
            "table %s ",
            [
                134636928
            ]
        ],
        "135064557": [
            " src %s ",
            [
                134636928
            ]
        ],
        "135064566": [
            " metric %d ",
            [
                134636928
            ]
        ],
        "135064578": [
            "dead ",
            [
                134636928
            ]
        ],
        "135064584": [
            "onlink ",
            [
                134636928
            ]
        ],
        "135064592": [
            "pervasive ",
            [
                134636928
            ]
        ],
        "135064603": [
            "notify ",
            [
                134636928
            ]
        ],
        "135064611": [
            "%c    cache ",
            [
                134636928
            ]
        ],
        "135064624": [
            " expires %dsec",
            [
                134636928
            ]
        ],
        "135064639": [
            " iif %s",
            [
                134636928
            ]
        ],
        "135064647": [
            "need at least destination address",
            [
                134638522
            ]
        ],
        "135064681": [
            "not a route?",
            [
                134638522
            ]
        ],
        "135064694": [
            "wrong len %d",
            [
                134638522
            ]
        ],
        "135064707": [
            "can't connect the route",
            [
                134638522
            ]
        ],
        "135064731": [
            "\"ip route flush\"",
            [
                134639324
            ]
        ],
        "135064748": [
            "can't flush routing cache",
            [
                134639324
            ]
        ],
        "135064786": [
            "advmss",
            [
                134640501
            ]
        ],
        "135064793": [
            "scope",
            [
                134640501
            ]
        ],
        "135064799": [
            "protocol",
            [
                134640501
            ]
        ],
        "135064808": [
            "table",
            [
                134640501
            ]
        ],
        "135064825": [
            "metric",
            []
        ],
        "135064832": [
            "onlink",
            []
        ],
        "135064840": [
            "/proc/sys/net/ipv4/route/flush",
            [
                134639324
            ]
        ],
        "135064871": [
            "protocol",
            [
                134639324
            ]
        ],
        "135064896": [
            "table",
            []
        ],
        "135064902": [
            "cache",
            []
        ],
        "135064916": [
            "scope",
            []
        ],
        "135064931": [
            "match",
            []
        ],
        "135064937": [
            "exact",
            []
        ],
        "135064966": [
            "notify",
            []
        ],
        "135064973": [
            "connected",
            []
        ],
        "135064993": [
            "append",
            []
        ],
        "135065000": [
            "change",
            []
        ],
        "135065011": [
            "delete",
            []
        ],
        "135065032": [
            "prepend",
            []
        ],
        "135065040": [
            "replace",
            []
        ],
        "135065053": [
            "flush",
            []
        ],
        "135065060": [
            "table ID",
            [
                134641833
            ]
        ],
        "135065074": [
            "from ",
            [
                134642663
            ]
        ],
        "135065080": [
            "%s/%u",
            [
                134642663
            ]
        ],
        "135065091": [
            "to %s/%u ",
            [
                134642663
            ]
        ],
        "135065110": [
            "tos %s ",
            [
                134642663
            ]
        ],
        "135065118": [
            "fwmark %#x ",
            [
                134642663
            ]
        ],
        "135065130": [
            "iif %s ",
            [
                134642663
            ]
        ],
        "135065138": [
            "lookup %s ",
            [
                134642663
            ]
        ],
        "135065149": [
            "%s %d ",
            [
                134642663
            ]
        ],
        "135065156": [
            "realms %s/",
            [
                134642663
            ]
        ],
        "135065171": [
            "to %s ",
            [
                134642663
            ]
        ],
        "135065178": [
            "masquerade",
            [
                134642663
            ]
        ],
        "135065193": [
            "delete",
            []
        ],
        "135065219": [
            "preference",
            [
                134641833
            ]
        ],
        "135065230": [
            "order",
            []
        ],
        "135065236": [
            "priority",
            []
        ],
        "135065249": [
            "fwmark",
            [
                134641833
            ]
        ],
        "135065256": [
            "realms",
            [
                134641833
            ]
        ],
        "135065263": [
            "table",
            []
        ],
        "135065269": [
            "lookup",
            []
        ],
        "135065276": [
            "suppress_prefixlength",
            [
                134641833,
                134642663
            ]
        ],
        "135065298": [
            "suppress_ifgroup",
            [
                134641833,
                134642663
            ]
        ],
        "135065327": [
            "map-to",
            []
        ],
        "135065345": [
            "SIOCGETTUNNEL",
            [
                134643446
            ]
        ],
        "135065359": [
            "SIOCCHGTUNNEL",
            [
                134643520
            ]
        ],
        "135065373": [
            "SIOCADDTUNNEL",
            [
                134643520
            ]
        ],
        "135065387": [
            "SIOCDELTUNNEL",
            [
                134643632
            ]
        ],
        "135065401": [
            "you managed to ask for more than one",
            [
                134643707
            ]
        ],
        "135065438": [
            "%s tunnel mode",
            [
                134643707
            ]
        ],
        "135065453": [
            "can't guess",
            [
                134643707
            ]
        ],
        "135065484": [
            "keys are not allowed with ipip and sit",
            [
                134643707
            ]
        ],
        "135065523": [
            "broadcast tunnel requires a source address",
            [
                134643707
            ]
        ],
        "135065566": [
            "ttl != 0 and noptmudisc are incompatible",
            [
                134644877
            ]
        ],
        "135065607": [
            "tunl0",
            [
                134646089,
                134644877
            ]
        ],
        "135065623": [
            "can't determine tunnel mode (ipip, gre or sit)",
            [
                134644877
            ]
        ],
        "135065679": [
            "%s: %s/ip  remote %s  local %s ",
            [
                134644979
            ]
        ],
        "135065711": [
            "SIOCGIFNAME",
            [
                134644979
            ]
        ],
        "135065724": [
            "dev %s ",
            [
                134616272,
                134635922,
                134636928,
                134616741
            ]
        ],
        "135065732": [
            " ttl %d ",
            [
                134644979
            ]
        ],
        "135065741": [
            " ttl inherit ",
            [
                134644979
            ]
        ],
        "135065760": [
            " inherit",
            [
                134644979
            ]
        ],
        "135065769": [
            "%c%s ",
            [
                134644979
            ]
        ],
        "135065775": [
            " nopmtudisc",
            [
                134644979
            ]
        ],
        "135065787": [
            " key %s",
            [
                134644979
            ]
        ],
        "135065795": [
            " ikey %s ",
            [
                134644979
            ]
        ],
        "135065805": [
            " okey %s ",
            [
                134644979
            ]
        ],
        "135065815": [
            "%c  Drop packets out of sequence.\n",
            [
                134644979
            ]
        ],
        "135065850": [
            "%c  Checksum in received packet is required.",
            [
                134644979
            ]
        ],
        "135065895": [
            "%c  Sequence packets on output.",
            [
                134644979
            ]
        ],
        "135065927": [
            "%c  Checksum output packets.",
            [
                134644979
            ]
        ],
        "135065956": [
            "wrong format of ",
            [
                134645533
            ]
        ],
        "135065972": [
            "/proc/net/dev",
            [
                134606666,
                134603371,
                134645533
            ]
        ],
        "135065986": [
            "%lu%lu%lu%lu%lu%lu%lu%*d%lu%lu%lu%lu%lu%lu%lu",
            [
                134645533
            ]
        ],
        "135066032": [
            "SIOCGIFHWADDR",
            [
                134657642,
                134645533
            ]
        ],
        "135066046": [
            "can't get type of [%s]",
            [
                134645533
            ]
        ],
        "135066079": [
            "ip/ip",
            []
        ],
        "135066089": [
            "gre/ip",
            []
        ],
        "135066100": [
            "ipv6/ip",
            []
        ],
        "135066141": [
            "icsum",
            []
        ],
        "135066147": [
            "ocsum",
            []
        ],
        "135066153": [
            "nopmtudisc",
            []
        ],
        "135066164": [
            "pmtudisc",
            []
        ],
        "135066173": [
            "remote",
            []
        ],
        "135066184": [
            "local",
            []
        ],
        "135066198": [
            "inherit",
            []
        ],
        "135066210": [
            "dsfield",
            []
        ],
        "135066228": [
            "change",
            []
        ],
        "135066235": [
            "delete",
            []
        ],
        "135066257": [
            "OVERRUN",
            [
                134647105,
                134646705
            ]
        ],
        "135066265": [
            "EOF on netlink",
            [
                134647105,
                134646705
            ]
        ],
        "135066280": [
            "sender address length == %d",
            [
                134647105,
                134646705
            ]
        ],
        "135066308": [
            "ERROR truncated",
            [
                134647105,
                134646705
            ]
        ],
        "135066324": [
            "RTNETLINK answers",
            [
                134647105,
                134646705
            ]
        ],
        "135066342": [
            "message truncated",
            [
                134647105,
                134646705
            ]
        ],
        "135066360": [
            "remnant of size %d!",
            [
                134647105,
                134646705
            ]
        ],
        "135066380": [
            "can't talk to rtnetlink",
            [
                134647105
            ]
        ],
        "135066404": [
            "truncated message",
            [
                134647105
            ]
        ],
        "135066422": [
            "malformed message: len=%d!",
            [
                134647105
            ]
        ],
        "135066449": [
            "unexpected reply!",
            [
                134647105
            ]
        ],
        "135066467": [
            "deficit %d, rta_len=%d!",
            [
                134647838
            ]
        ],
        "135066497": [
            "\"%s\" is invalid lladdr",
            [
                134648081
            ]
        ],
        "135066534": [
            "pupat",
            []
        ],
        "135066555": [
            "ieeepup",
            []
        ],
        "135066563": [
            "ieeepupat",
            []
        ],
        "135066577": [
            "dna_dl",
            []
        ],
        "135066584": [
            "dna_rc",
            []
        ],
        "135066591": [
            "dna_rt",
            []
        ],
        "135066621": [
            "atalk",
            []
        ],
        "135066641": [
            "ppp_disc",
            []
        ],
        "135066650": [
            "ppp_ses",
            []
        ],
        "135066658": [
            "atmmpoa",
            []
        ],
        "135066666": [
            "atmfate",
            []
        ],
        "135066674": [
            "802_3",
            []
        ],
        "135066689": [
            "802_2",
            []
        ],
        "135066700": [
            "ddcmp",
            []
        ],
        "135066706": [
            "wan_ppp",
            []
        ],
        "135066714": [
            "ppp_mp",
            []
        ],
        "135066721": [
            "localtalk",
            []
        ],
        "135066731": [
            "ppptalk",
            []
        ],
        "135066739": [
            "tr_802_2",
            []
        ],
        "135066748": [
            "mobitex",
            []
        ],
        "135066756": [
            "control",
            []
        ],
        "135066769": [
            "econet",
            []
        ],
        "135066776": [
            "802.1Q",
            []
        ],
        "135066794": [
            "generic",
            [
                134648785
            ]
        ],
        "135066802": [
            "loopback",
            []
        ],
        "135066811": [
            "ether",
            []
        ],
        "135066817": [
            "infiniband",
            []
        ],
        "135066828": [
            "ieee802",
            []
        ],
        "135066839": [
            "ieee802.11",
            []
        ],
        "135066850": [
            "ieee1394",
            []
        ],
        "135066869": [
            "cslip",
            []
        ],
        "135066875": [
            "slip6",
            []
        ],
        "135066881": [
            "cslip6",
            []
        ],
        "135066897": [
            "tunnel6",
            []
        ],
        "135066919": [
            "/etc/iproute2/rt_%s",
            [
                134648853
            ]
        ],
        "135066939": [
            "database %s is corrupted at line %d",
            [
                134648853
            ]
        ],
        "135066975": [
            "global",
            [
                134648992
            ]
        ],
        "135066982": [
            "nowhere",
            [
                134648992
            ]
        ],
        "135066995": [
            "scopes",
            [
                134648992
            ]
        ],
        "135067002": [
            "realms",
            [
                134649077
            ]
        ],
        "135067009": [
            "dsfield",
            [
                134649122
            ]
        ],
        "135067022": [
            "tables",
            [
                134649167
            ]
        ],
        "135067029": [
            "protos",
            [
                134649363
            ]
        ],
        "135067036": [
            "redirect",
            [
                4294967295
            ]
        ],
        "135067045": [
            "kernel",
            [
                4294967295,
                134715303
            ]
        ],
        "135067052": [
            "gated",
            [
                4294967295
            ]
        ],
        "135067062": [
            "zebra",
            [
                4294967295
            ]
        ],
        "135067073": [
            "unicast",
            [
                134649720
            ]
        ],
        "135067081": [
            "anycast",
            [
                134649720
            ]
        ],
        "135067089": [
            "blackhole",
            [
                134649720
            ]
        ],
        "135067099": [
            "unreachable",
            [
                134649720
            ]
        ],
        "135067111": [
            "prohibit",
            [
                134649720
            ]
        ],
        "135067120": [
            "throw",
            [
                134649720
            ]
        ],
        "135067130": [
            "xresolve",
            [
                134649720
            ]
        ],
        "135067139": [
            "local",
            [
                134649809
            ]
        ],
        "135067149": [
            "broadcast",
            []
        ],
        "135067163": [
            "anycast",
            []
        ],
        "135067171": [
            "multicast",
            []
        ],
        "135067181": [
            "prohibit",
            []
        ],
        "135067190": [
            "unreachable",
            []
        ],
        "135067202": [
            "blackhole",
            []
        ],
        "135067212": [
            "xresolve",
            []
        ],
        "135067221": [
            "unicast",
            []
        ],
        "135067229": [
            "throw",
            []
        ],
        "135067236": [
            "/proc/net/psched",
            [
                134650127
            ]
        ],
        "135067253": [
            "%*08x%*08x%08x%08x",
            [
                134650127
            ]
        ],
        "135067272": [
            "\"%s\" may be inet %s, but it is not allowed in this context",
            [
                134650561,
                134650503
            ]
        ],
        "135067331": [
            "an %s %s is expected rather than \"%s\"",
            [
                134650561,
                134650884,
                134650503
            ]
        ],
        "135067369": [
            "prefix",
            [
                134650561
            ]
        ],
        "135067379": [
            "command line is not complete, try \"help\"",
            [
                134650938
            ]
        ],
        "135067420": [
            "duplicate \"%s\": \"%s\" is the second value",
            [
                134651092
            ]
        ],
        "135067461": [
            "either \"%s\" is duplicate, or \"%s\" is garbage",
            [
                134651104
            ]
        ],
        "135067510": [
            "discover",
            [
                134651651
            ]
        ],
        "135067519": [
            "sending %s",
            [
                134651651,
                134654021,
                134651843
            ]
        ],
        "135067530": [
            "sending select for %s",
            [
                134651739
            ]
        ],
        "135067552": [
            "decline",
            [
                134651843
            ]
        ],
        "135067560": [
            "sending renew to %s",
            [
                134651930
            ]
        ],
        "135067580": [
            "packet with bad magic, ignoring",
            [
                134652036,
                134656670
            ]
        ],
        "135067612": [
            "%s%u.%u.%u.%u",
            [
                134652445
            ]
        ],
        "135067630": [
            "interface=%s",
            [
                134653311
            ]
        ],
        "135067643": [
            "siaddr=",
            [
                134653311
            ]
        ],
        "135067651": [
            "boot_file=%.128s",
            [
                134653311
            ]
        ],
        "135067668": [
            "sname=%.64s",
            [
                134653311
            ]
        ],
        "135067680": [
            "mask=%u",
            [
                134653311
            ]
        ],
        "135067688": [
            "opt%u=",
            [
                134653311
            ]
        ],
        "135067695": [
            "release",
            [
                134654021
            ]
        ],
        "135067703": [
            "unicasting a release of %s to %s",
            [
                134654123
            ]
        ],
        "135067736": [
            "entering released state",
            [
                134654123
            ]
        ],
        "135067760": [
            "deconfig",
            [
                134654235,
                134654123
            ]
        ],
        "135067769": [
            "bound",
            [
                134654235
            ]
        ],
        "135067780": [
            "/usr/share/udhcpc/default.",
            [
                134654235
            ]
        ],
        "135067806": [
            "script",
            [
                134595309
            ]
        ],
        "135067813": [
            "udhcp 1.29.2",
            [
                134654235
            ]
        ],
        "135067826": [
            "option -h NAME is deprecated, use -x hostname:NAME",
            [
                134654235
            ]
        ],
        "135067877": [
            "started, v1.29.2",
            [
                134654235
            ]
        ],
        "135067899": [
            "leasefail",
            [
                134654235
            ]
        ],
        "135067909": [
            "no lease, forking to background",
            [
                134654235
            ]
        ],
        "135067941": [
            "no lease, failing",
            [
                134654235
            ]
        ],
        "135067959": [
            "lease lost, entering init state",
            [
                134654235
            ]
        ],
        "135067991": [
            "performing DHCP renew",
            [
                134654235
            ]
        ],
        "135068013": [
            "SIGTERM",
            [
                134654235
            ]
        ],
        "135068021": [
            "received %s",
            [
                134654235
            ]
        ],
        "135068033": [
            "read error: %m, reopening ",
            [
                134654235
            ]
        ],
        "135068059": [
            "socket",
            [
                134537113,
                134598797
            ]
        ],
        "135068066": [
            "no message type option, ignoring packet",
            [
                134654235
            ]
        ],
        "135068106": [
            "no server ID, using ",
            [
                134654235
            ]
        ],
        "135068126": [
            "0.0.0.0",
            [
                134589622
            ]
        ],
        "135068134": [
            "no lease time with ACK, using 1 hour lease",
            [
                134654235
            ]
        ],
        "135068177": [
            "offered address is in use (got ARP reply), declining",
            [
                134654235
            ]
        ],
        "135068230": [
            "lease of %s obtained, lease time %u",
            [
                134654235
            ]
        ],
        "135068266": [
            "DHCP NAK",
            [
                134654235
            ]
        ],
        "135068279": [
            "^CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fBba::v",
            [
                134654235
            ]
        ],
        "135068338": [
            "clientid-none",
            [
                134654235
            ]
        ],
        "135068353": [
            "Cvendorclass",
            []
        ],
        "135068367": [
            "Vhostname",
            []
        ],
        "135068378": [
            "Hfqdn",
            []
        ],
        "135068385": [
            "Finterface",
            []
        ],
        "135068403": [
            "npidfile",
            []
        ],
        "135068413": [
            "pquit",
            []
        ],
        "135068420": [
            "qrelease",
            []
        ],
        "135068430": [
            "Rrequest",
            []
        ],
        "135068440": [
            "rscript",
            []
        ],
        "135068449": [
            "stimeout",
            []
        ],
        "135068459": [
            "Tretries",
            []
        ],
        "135068469": [
            "ttryagain",
            []
        ],
        "135068480": [
            "Asyslog",
            []
        ],
        "135068489": [
            "Srequest-option",
            []
        ],
        "135068506": [
            "Ono-default-options",
            []
        ],
        "135068527": [
            "oforeground",
            []
        ],
        "135068540": [
            "fbackground",
            []
        ],
        "135068553": [
            "bbroadcast",
            []
        ],
        "135068565": [
            "Barping",
            []
        ],
        "135068576": [
            "bind(%s)",
            [
                134656745,
                134657149
            ]
        ],
        "135068585": [
            "socket(%s)",
            [
                134656745,
                134657149
            ]
        ],
        "135068596": [
            "connect",
            [
                134657149
            ]
        ],
        "135068608": [
            "can't send signal",
            [
                134657426
            ]
        ],
        "135068626": [
            "is interface %s up and configured?",
            [
                134657642
            ]
        ],
        "135068661": [
            "can't enable bcast on raw socket",
            [
                134658017
            ]
        ],
        "135068694": [
            "unknown option '%s', known options: %s",
            [
                134658420
            ]
        ],
        "135068733": [
            "bad packet, malformed option field",
            [
                134658512
            ]
        ],
        "135068768": [
            "option 0x%02x did not fit into the packet",
            [
                134658703
            ]
        ],
        "135068810": [
            "can't add option 0x%02x",
            [
                134658782
            ]
        ],
        "135068834": [
            "malformed hex string '%s'",
            [
                134658906
            ]
        ],
        "135068869": [
            ", \t/-",
            [
                134659247
            ]
        ],
        "135068875": [
            "%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s",
            [
                134659828
            ]
        ],
        "135068927": [
            "subnet",
            [
                134654235,
                134653311
            ]
        ],
        "135068934": [
            "timezone",
            []
        ],
        "135068943": [
            "router",
            []
        ],
        "135068954": [
            "lprsrv",
            []
        ],
        "135068961": [
            "hostname",
            []
        ],
        "135068970": [
            "bootsize",
            []
        ],
        "135068979": [
            "domain",
            []
        ],
        "135068986": [
            "swapsrv",
            []
        ],
        "135068994": [
            "rootpath",
            []
        ],
        "135069003": [
            "ipttl",
            []
        ],
        "135069013": [
            "broadcast",
            []
        ],
        "135069023": [
            "routes",
            []
        ],
        "135069030": [
            "nisdomain",
            []
        ],
        "135069040": [
            "nissrv",
            []
        ],
        "135069047": [
            "ntpsrv",
            []
        ],
        "135069059": [
            "lease",
            []
        ],
        "135069065": [
            "serverid",
            []
        ],
        "135069074": [
            "message",
            []
        ],
        "135069087": [
            "bootfile",
            []
        ],
        "135069096": [
            "staticroutes",
            []
        ],
        "135069109": [
            "vlanid",
            []
        ],
        "135069116": [
            "vlanpriority",
            []
        ],
        "135069129": [
            "pxeconffile",
            []
        ],
        "135069141": [
            "pxepathprefix",
            []
        ],
        "135069155": [
            "ip6rd",
            []
        ],
        "135069161": [
            "msstaticroutes",
            []
        ],
        "135069182": [
            "/proc/meminfo",
            [
                134908605,
                134659902
            ]
        ],
        "135069196": [
            "Cached: %lu %*s\n",
            [
                134659902
            ]
        ],
        "135069213": [
            "buffers",
            [
                134659980
            ]
        ],
        "135069221": [
            "shared",
            [
                134659980
            ]
        ],
        "135069233": [
            "total",
            [
                134753936,
                134659980,
                134848886,
                134813687
            ]
        ],
        "135069239": [
            "       %11s%11s%11s%11s%11s%11s\nMem:   ",
            [
                134659980
            ]
        ],
        "135069279": [
            "%11llu%11llu%11llu%11llu%11llu%11llu\n",
            [
                134659980
            ]
        ],
        "135069317": [
            "-/+ buffers/cache:",
            [
                134659980
            ]
        ],
        "135069336": [
            "Swap:  ",
            [
                134659980
            ]
        ],
        "135069344": [
            "%*d: %64[0-9A-Fa-f]:%x %*x:%*x %*x %*x:%*x %*x:%*x %*x %*d %*d %llu",
            [
                134660673
            ]
        ],
        "135069412": [
            "%*s %*s %*s %x:%x %llu",
            [
                134660673
            ]
        ],
        "135069435": [
            "kill pid %s",
            [
                134661034
            ]
        ],
        "135069478": [
            "^mks64",
            [
                134661413
            ]
        ],
        "135069488": [
            "/proc/net/",
            [
                134661413
            ]
        ],
        "135069499": [
            "%u/%4s",
            [
                134661413
            ]
        ],
        "135069506": [
            "unknown signal '%s'",
            [
                134661697
            ]
        ],
        "135069526": [
            "bad signal name '%s'",
            [
                134661697
            ]
        ],
        "135069547": [
            "bad option '%s'",
            [
                134661697
            ]
        ],
        "135069563": [
            "invalid number '%s'",
            [
                134661697,
                134954935,
                134755859,
                134954453,
                134714871,
                134832472,
                134832410
            ]
        ],
        "135069583": [
            "you need to specify whom to kill",
            [
                134661697
            ]
        ],
        "135069616": [
            "%s: no process killed",
            [
                134661697
            ]
        ],
        "135069638": [
            "can't kill pid %d",
            [
                134661697
            ]
        ],
        "135069656": [
            "/proc/%u/fd/",
            [
                134662590
            ]
        ],
        "135069671": [
            "\t%s\t%s\n",
            [
                134554049
            ]
        ],
        "135069684": [
            "%PPID",
            [
                134662767
            ]
        ],
        "135069694": [
            "%.6s,",
            [
                134663154
            ]
        ],
        "135069700": [
            "bad -o argument '%s', supported arguments: %s",
            [
                134663154
            ]
        ],
        "135069746": [
            " mgtpezy",
            [
                134665720,
                4294967295
            ]
        ],
        "135069755": [
            "Zo:*aAdefl",
            [
                134663695
            ]
        ],
        "135069766": [
            "pid,user,args",
            [
                134663695
            ]
        ],
        "135069780": [
            "%-*s ",
            [
                134663695
            ]
        ],
        "135069790": [
            "GROUP",
            []
        ],
        "135069826": [
            "error: malformed setting '%s'",
            [
                134664193
            ]
        ],
        "135069856": [
            "error: '%s' is an unknown key",
            [
                134664193
            ]
        ],
        "135069886": [
            "error %sing key '%s'",
            [
                134664193
            ]
        ],
        "135069907": [
            "%s = ",
            [
                134664193
            ]
        ],
        "135069913": [
            "error reading key '%s'",
            [
                134664193
            ]
        ],
        "135069936": [
            "error: '%s' must be of the form name=value",
            [
                134664193
            ]
        ],
        "135069979": [
            "+neAapwq",
            [
                134664901
            ]
        ],
        "135069988": [
            "/etc/sysctl.conf",
            [
                134664901
            ]
        ],
        "135070005": [
            "/proc/sys",
            [
                134664901
            ]
        ],
        "135070019": [
            "/proc/",
            [
                134665474
            ]
        ],
        "135070030": [
            "can't read '%s'",
            [
                134752064,
                134665474,
                134948136,
                134889481,
                134854005,
                134824184
            ]
        ],
        "135070046": [
            "\u001b[H\u001b[J%s\n",
            [
                134665720
            ]
        ],
        "135070056": [
            "Mem: %luK used, %luK free, %luK shrd, %luK buff, %luK ",
            [
                134665720
            ]
        ],
        "135070110": [
            "cached",
            [
                134659980
            ]
        ],
        "135070117": [
            "CPU:%4u%% usr%4u%% sys%4u%% nic%4u%% idle%4u%% io%4u%% irq%4u%% sirq",
            [
                134665720
            ]
        ],
        "135070186": [
            "Load average: ",
            [
                134665720
            ]
        ],
        "135070201": [
            "loadavg",
            [
                134665720
            ]
        ],
        "135070209": [
            "  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND",
            [
                134665720
            ]
        ],
        "135070259": [
            "\n%5u%6u %-8.8s %s  %.5s%4u%%%4u%% ",
            [
                134665720
            ]
        ],
        "135070294": [
            "d:n:b",
            [
                134667095
            ]
        ],
        "135070300": [
            "no process info in ",
            [
                134667095
            ]
        ],
        "135070319": [
            "/proc",
            [
                134942400,
                134851051,
                134661413,
                134667095
            ]
        ],
        "135070325": [
            "MemTotal",
            [
                134665720
            ]
        ],
        "135070334": [
            "MemFree",
            []
        ],
        "135070342": [
            "MemShared",
            []
        ],
        "135070352": [
            "Shmem",
            []
        ],
        "135070358": [
            "Buffers",
            []
        ],
        "135070366": [
            "Cached",
            []
        ],
        "135070373": [
            "SwapTotal",
            []
        ],
        "135070383": [
            "SwapFree",
            []
        ],
        "135070392": [
            "Dirty",
            []
        ],
        "135070398": [
            "Writeback",
            []
        ],
        "135070408": [
            "AnonPages",
            []
        ],
        "135070418": [
            "Mapped",
            []
        ],
        "135070431": [
            "cpu %llu %llu %llu %llu %llu %llu %llu %llu",
            [
                134665297
            ]
        ],
        "135070475": [
            " %02u:%02u:%02u up ",
            [
                134667725
            ]
        ],
        "135070495": [
            "%u day%s, ",
            [
                134667725
            ]
        ],
        "135070506": [
            "%2u:%02u",
            [
                134667725
            ]
        ],
        "135070515": [
            "%u min",
            [
                134667725
            ]
        ],
        "135070522": [
            ",  load average: %u.%02u, %u.%02u, %u.%02u\n",
            [
                134667725
            ]
        ],
        "135070566": [
            "^+dtn:+",
            [
                134667977
            ]
        ],
        "135070577": [
            "Every %us: %-*s",
            [
                134667977
            ]
        ],
        "135070593": [
            "%s%s%s: %s",
            [
                134668177
            ]
        ],
        "135070604": [
            "warning: ",
            [
                134668251
            ]
        ],
        "135070614": [
            "fail: ",
            [
                134668269
            ]
        ],
        "135070621": [
            "warning: can't stat %s/down",
            [
                134668287
            ]
        ],
        "135070649": [
            "down: ",
            [
                134668287
            ]
        ],
        "135070656": [
            "run: ",
            [
                134668287
            ]
        ],
        "135070662": [
            "finish: ",
            [
                134668287
            ]
        ],
        "135070671": [
            "(pid %d) ",
            [
                134668287
            ]
        ],
        "135070685": [
            ", normally down",
            [
                134668287
            ]
        ],
        "135070701": [
            ", paused",
            [
                134668287
            ]
        ],
        "135070710": [
            ", want down",
            [
                134668287
            ]
        ],
        "135070722": [
            ", got ",
            [
                134668287
            ]
        ],
        "135070733": [
            ", normally up",
            [
                134668287
            ]
        ],
        "135070747": [
            ", want up",
            [
                134668287
            ]
        ],
        "135070757": [
            "warning: can't stat %s/check",
            [
                134668610
            ]
        ],
        "135070788": [
            "check",
            [
                134668610,
                134669739
            ]
        ],
        "135070794": [
            "warning: can't %s child %s/check",
            [
                134668610
            ]
        ],
        "135070827": [
            "wait for",
            [
                134668610
            ]
        ],
        "135070836": [
            "fatal: can't %s",
            [
                134668768
            ]
        ],
        "135070852": [
            "runsv not running",
            [
                134669541,
                134668789
            ]
        ],
        "135070875": [
            "can't open ",
            [
                134668789
            ]
        ],
        "135070886": [
            "supervise/ok",
            [
                134671243,
                134668789
            ]
        ],
        "135070899": [
            "can't open supervise/status",
            [
                134668789
            ]
        ],
        "135070927": [
            "can't read ",
            [
                134668789
            ]
        ],
        "135070938": [
            "supervise/status",
            [
                134668789
            ]
        ],
        "135070955": [
            "can't read supervise/status: bad format",
            [
                134668789
            ]
        ],
        "135070995": [
            "can't change directory",
            [
                134668996
            ]
        ],
        "135071018": [
            "can't open ",
            [
                134669541
            ]
        ],
        "135071029": [
            "supervise/control",
            [
                134669541
            ]
        ],
        "135071047": [
            "can't write to supervise/control",
            [
                134669541
            ]
        ],
        "135071080": [
            "udopchaitkx",
            [
                134669739
            ]
        ],
        "135071092": [
            "SVDIR",
            [
                134669739
            ]
        ],
        "135071098": [
            "SVWAIT",
            [
                134669739
            ]
        ],
        "135071105": [
            "open current directory",
            [
                134669739
            ]
        ],
        "135071131": [
            "try-restart",
            [
                134669739
            ]
        ],
        "135071147": [
            "force-",
            [
                134669739
            ]
        ],
        "135071153": [
            "reload",
            [
                134669739
            ]
        ],
        "135071160": [
            "force-",
            [
                134669739
            ]
        ],
        "135071166": [
            "restart",
            [
                134669739
            ]
        ],
        "135071174": [
            "force-",
            [
                134669739
            ]
        ],
        "135071180": [
            "shutdown",
            [
                134908480,
                134669739
            ]
        ],
        "135071189": [
            "force-",
            [
                134669739
            ]
        ],
        "135071200": [
            "can't change to service directory",
            [
                134669739
            ]
        ],
        "135071234": [
            "change to original directory",
            [
                134669739
            ]
        ],
        "135071263": [
            "kill: ",
            [
                134669739
            ]
        ],
        "135071270": [
            "timeout: ",
            [
                134669739
            ]
        ],
        "135071280": [
            "^w:+v",
            [
                134669739
            ]
        ],
        "135071289": [
            "line %d: ",
            [
                134675136
            ]
        ],
        "135071299": [
            "%.*s: is read only",
            [
                134675323
            ]
        ],
        "135071318": [
            "%.*s: bad variable ",
            [
                134675682
            ]
        ],
        "135071342": [
            "Illegal number: %s",
            [
                134677680,
                134675981
            ]
        ],
        "135071361": [
            "%d: %m",
            [
                134676240,
                134677601,
                134676635,
                134701254
            ]
        ],
        "135071368": [
            "can't set tty process group: %m",
            [
                134676398
            ]
        ],
        "135071400": [
            "can't open '%s'",
            [
                134676635,
                134684246
            ]
        ],
        "135071420": [
            "syntax error: %s",
            [
                134676850
            ]
        ],
        "135071437": [
            "illegal option -%c",
            [
                134676850
            ]
        ],
        "135071456": [
            "no arg for -%c option",
            [
                134676850
            ]
        ],
        "135071481": [
            "%s: %s not found\n",
            [
                134682509,
                4294967295
            ]
        ],
        "135071499": [
            "No current job",
            [
                134677321
            ]
        ],
        "135071514": [
            "No previous job",
            [
                134677321
            ]
        ],
        "135071530": [
            "%s: ambiguous",
            [
                134677321
            ]
        ],
        "135071544": [
            "%s: no such job",
            [
                134677321
            ]
        ],
        "135071560": [
            "job %s not created under job control",
            [
                134677321
            ]
        ],
        "135071597": [
            "can't access tty; job control turned off",
            [
                134677775
            ]
        ],
        "135071638": [
            "not in a function",
            [
                134678488
            ]
        ],
        "135071656": [
            "OLDPWD",
            [
                134678533,
                4294967295
            ]
        ],
        "135071663": [
            "illegal option %co %s",
            [
                134678740
            ]
        ],
        "135071685": [
            "%-16s%s\n",
            [
                134678740
            ]
        ],
        "135071694": [
            "set %co %s\n",
            [
                134678740
            ]
        ],
        "135071706": [
            "illegal option %c%c",
            [
                134678740
            ]
        ],
        "135071726": [
            "Built-in commands:\n------------------\n",
            [
                134679401
            ]
        ],
        "135071765": [
            "You have stopped jobs.\n",
            [
                134679535
            ]
        ],
        "135071789": [
            "Done(%d)",
            [
                134679832
            ]
        ],
        "135071798": [
            " (core dumped)",
            [
                134679832
            ]
        ],
        "135071813": [
            "[%d]   ",
            [
                134680700
            ]
        ],
        "135071821": [
            "Running",
            [
                134680700
            ]
        ],
        "135071829": [
            "\n%*c%d ",
            [
                134680700
            ]
        ],
        "135071837": [
            "%s%*c%s%s",
            [
                134680700
            ]
        ],
        "135071847": [
            "%04o\n",
            [
                4294967295
            ]
        ],
        "135071853": [
            "illegal mode: %s",
            [
                4294967295
            ]
        ],
        "135071870": [
            "expression expected",
            [
                134681838
            ]
        ],
        "135071890": [
            "%s=%s\n",
            [
                134682479
            ]
        ],
        "135071905": [
            "$(...)",
            [
                134683485
            ]
        ],
        "135071926": [
            "trap -- ",
            [
                4294967295
            ]
        ],
        "135071934": [
            "%s %s\n",
            [
                134753221,
                134715983
            ]
        ],
        "135071941": [
            "%s: invalid signal specification",
            [
                4294967295
            ]
        ],
        "135071974": [
            "%um%u.%03us%c",
            [
                134685226
            ]
        ],
        "135071988": [
            "%s%s%.*s%s\n",
            [
                134685322
            ]
        ],
        "135072011": [
            "unexpected %s",
            [
                134686556
            ]
        ],
        "135072025": [
            " (expecting %s)",
            [
                134686556
            ]
        ],
        "135072051": [
            "while ",
            [
                134686941
            ]
        ],
        "135072058": [
            "until ",
            [
                134686941
            ]
        ],
        "135072070": [
            "; done",
            [
                134686941
            ]
        ],
        "135072077": [
            "() { ... }",
            [
                134686941
            ]
        ],
        "135072088": [
            "<<...",
            [
                134686941
            ]
        ],
        "135072119": [
            "; then ",
            [
                134686941
            ]
        ],
        "135072127": [
            "; else ",
            [
                134686941
            ]
        ],
        "135072135": [
            "; do ",
            [
                134686941
            ]
        ],
        "135072155": [
            "can't fork: %m",
            [
                134687572
            ]
        ],
        "135072170": [
            "[%d] ",
            [
                4294967295
            ]
        ],
        "135072176": [
            " | %s",
            [
                4294967295
            ]
        ],
        "135072182": [
            "PS1=\\w \\$ ",
            [
                134688608
            ]
        ],
        "135072193": [
            "SHLVL",
            [
                134688608
            ]
        ],
        "135072199": [
            "HOSTNAME",
            [
                134688608
            ]
        ],
        "135072208": [
            "p:u:rt:n:sd:",
            [
                134689626
            ]
        ],
        "135072225": [
            "usage: getopts optstring var [arg]",
            [
                134689856
            ]
        ],
        "135072260": [
            "OPTARG",
            [
                134689856
            ]
        ],
        "135072267": [
            "OPTERR",
            [
                134689856
            ]
        ],
        "135072274": [
            "Illegal option -%c\n",
            [
                134689856
            ]
        ],
        "135072294": [
            "No arg for -%c option\n",
            [
                134689856
            ]
        ],
        "135072317": [
            "OPTIND",
            [
                134689856
            ]
        ],
        "135072331": [
            "can't cd to %s: %m",
            [
                4294967295
            ]
        ],
        "135072350": [
            "TMOUT",
            [
                134691154
            ]
        ],
        "135072359": [
            "\u0007timed out waiting for input: auto-logout",
            [
                134691154
            ]
        ],
        "135072401": [
            "missing '))'",
            [
                134692670
            ]
        ],
        "135072414": [
            "unterminated quoted string",
            [
                134692670
            ]
        ],
        "135072441": [
            "missing '}'",
            [
                134692670
            ]
        ],
        "135072453": [
            "EOF in backquote substitution",
            [
                134692670
            ]
        ],
        "135072483": [
            "can't create pipe: %m",
            [
                134708019,
                134701254,
                134697230
            ]
        ],
        "135072505": [
            "parameter not set",
            [
                134699681,
                134698395
            ]
        ],
        "135072523": [
            " or null",
            [
                134698395
            ]
        ],
        "135072532": [
            "%.*s: ",
            [
                134699681,
                134698395
            ]
        ],
        "135072543": [
            "bad substitution",
            [
                134699681
            ]
        ],
        "135072560": [
            "nonexistent directory",
            [
                134701254
            ]
        ],
        "135072582": [
            "can't create ",
            [
                134701254
            ]
        ],
        "135072595": [
            "%s: %s",
            [
                134773827,
                134706667,
                134753743,
                134687860,
                134843316,
                134687831
            ]
        ],
        "135072602": [
            "no such file",
            [
                134701254
            ]
        ],
        "135072615": [
            "can't open %s: %s",
            [
                134701254
            ]
        ],
        "135072633": [
            "redir error",
            [
                134702472
            ]
        ],
        "135072645": [
            "bad fd number",
            [
                134702472
            ]
        ],
        "135072659": [
            "\nUse \"exit\" to leave shell.\n",
            [
                134703636
            ]
        ],
        "135072688": [
            "%s: not found",
            [
                4294967295
            ]
        ],
        "135072705": [
            "bad for loop variable",
            [
                134704287
            ]
        ],
        "135072727": [
            "bad function name",
            [
                134704287
            ]
        ],
        "135072745": [
            "%builtin",
            [
                134706667
            ]
        ],
        "135072759": [
            "%s not defined in %s",
            [
                134706667
            ]
        ],
        "135072780": [
            "command_not_found_handle",
            [
                134706667
            ]
        ],
        "135072805": [
            " is a shell keyword",
            [
                134707562
            ]
        ],
        "135072825": [
            "special ",
            [
                134707562
            ]
        ],
        "135072834": [
            "alias ",
            [
                134707562
            ]
        ],
        "135072841": [
            " is an alias for %s",
            [
                134707562
            ]
        ],
        "135072861": [
            " is %s",
            [
                134707562
            ]
        ],
        "135072868": [
            " is a shell function",
            [
                134707562
            ]
        ],
        "135072889": [
            " is a %sshell ",
            [
                134707562
            ]
        ],
        "135072903": [
            "builtin",
            [
                134706667,
                4294967295
            ]
        ],
        "135072911": [
            ": not found\n",
            [
                134707562
            ]
        ],
        "135072928": [
            "BASH_XTRACEFD",
            [
                134708664
            ]
        ],
        "135072942": [
            "%s%.*s%s",
            [
                134708664
            ]
        ],
        "135072953": [
            "LINENO=",
            [
                134710171
            ]
        ],
        "135072961": [
            "/etc/profile",
            [
                134710171
            ]
        ],
        "135072974": [
            "$HOME/.profile",
            [
                134710171
            ]
        ],
        "135072993": [
            "HISTFILE",
            [
                134710171
            ]
        ],
        "135073002": [
            ".ash_history",
            [
                134710171
            ]
        ],
        "135073030": [
            "pipefail",
            []
        ],
        "135073055": [
            "nrbtfavx\\01234567",
            [
                134692670
            ]
        ],
        "135073098": [
            "\t\n !\"$&'()*-:;<=>?[\\]`|}~",
            [
                134672123
            ]
        ],
        "135073124": [
            "}-+?=",
            [
                134692670
            ]
        ],
        "135073149": [
            "\n()&|;",
            [
                134691732
            ]
        ],
        "135073169": [
            "6alias",
            [
                4294967295
            ]
        ],
        "135073180": [
            "3break",
            [
                4294967295
            ]
        ],
        "135073191": [
            "0chdir",
            [
                4294967295
            ]
        ],
        "135073198": [
            "2command",
            [
                4294967295
            ]
        ],
        "135073207": [
            "3continue",
            [
                4294967295
            ]
        ],
        "135073223": [
            "3eval",
            [
                4294967295
            ]
        ],
        "135073229": [
            "3exec",
            [
                4294967295
            ]
        ],
        "135073235": [
            "3exit",
            [
                4294967295
            ]
        ],
        "135073241": [
            "7export",
            [
                4294967295
            ]
        ],
        "135073249": [
            "2false",
            [
                4294967295
            ]
        ],
        "135073260": [
            "2getopts",
            [
                4294967295
            ]
        ],
        "135073269": [
            "0hash",
            [
                4294967295
            ]
        ],
        "135073275": [
            "0help",
            [
                4294967295
            ]
        ],
        "135073281": [
            "0history",
            [
                4294967295
            ]
        ],
        "135073296": [
            "2kill",
            [
                4294967295
            ]
        ],
        "135073308": [
            "local",
            [
                134649720,
                134630220,
                134649167
            ]
        ],
        "135073314": [
            "2printf",
            [
                4294967295
            ]
        ],
        "135073327": [
            "2read",
            [
                4294967295
            ]
        ],
        "135073334": [
            "readonly",
            [
                134559923
            ]
        ],
        "135073343": [
            "3return",
            [
                4294967295
            ]
        ],
        "135073356": [
            "3shift",
            [
                4294967295
            ]
        ],
        "135073364": [
            "source",
            [
                134595309
            ]
        ],
        "135073371": [
            "2test",
            [
                4294967295
            ]
        ],
        "135073378": [
            "times",
            [
                134913143
            ]
        ],
        "135073396": [
            "0type",
            [
                4294967295
            ]
        ],
        "135073402": [
            "0ulimit",
            [
                4294967295
            ]
        ],
        "135073410": [
            "2umask",
            [
                4294967295
            ]
        ],
        "135073418": [
            "unalias",
            [
                4294967295
            ]
        ],
        "135073426": [
            "3unset",
            [
                4294967295
            ]
        ],
        "135073439": [
            "newline",
            [
                4294967295
            ]
        ],
        "135073447": [
            "redirection",
            [
                4294967295
            ]
        ],
        "135073493": [
            "until",
            [
                4294967295
            ]
        ],
        "135073499": [
            "while",
            [
                4294967295
            ]
        ],
        "135073505": [
            "PS1=$ ",
            []
        ],
        "135073512": [
            "PS2=> ",
            []
        ],
        "135073519": [
            "PS4=+ ",
            []
        ],
        "135073526": [
            "RANDOM",
            []
        ],
        "135073533": [
            "eerrexit",
            [
                4294967295
            ]
        ],
        "135073542": [
            "fnoglob",
            [
                4294967295
            ]
        ],
        "135073550": [
            "Iignoreeof",
            [
                4294967295
            ]
        ],
        "135073561": [
            "iinteractive",
            [
                4294967295
            ]
        ],
        "135073574": [
            "mmonitor",
            [
                4294967295
            ]
        ],
        "135073583": [
            "nnoexec",
            [
                4294967295
            ]
        ],
        "135073591": [
            "sstdin",
            [
                4294967295
            ]
        ],
        "135073598": [
            "xxtrace",
            [
                4294967295
            ]
        ],
        "135073606": [
            "vverbose",
            [
                4294967295
            ]
        ],
        "135073615": [
            "Cnoclobber",
            [
                4294967295
            ]
        ],
        "135073626": [
            "aallexport",
            [
                4294967295
            ]
        ],
        "135073637": [
            "bnotify",
            [
                4294967295
            ]
        ],
        "135073645": [
            "unounset",
            [
                4294967295
            ]
        ],
        "135073688": [
            "arithmetic syntax error",
            [
                134711232,
                134712402
            ]
        ],
        "135073712": [
            "exponent less than 0",
            [
                134711232
            ]
        ],
        "135073733": [
            "divide by zero",
            [
                134711232
            ]
        ],
        "135073748": [
            "malformed ?: operator",
            [
                134711232
            ]
        ],
        "135073770": [
            "expression recursion loop detected",
            [
                134713091
            ]
        ],
        "135073946": [
            "unlimited",
            [
                134714871,
                134713399
            ]
        ],
        "135073956": [
            "invalid file descriptor",
            [
                134713549
            ]
        ],
        "135073980": [
            "invalid ",
            [
                134713549
            ]
        ],
        "135073988": [
            "timeout",
            [
                134620197
            ]
        ],
        "135073996": [
            "invalid count",
            [
                134713549
            ]
        ],
        "135074010": [
            "read: '%s': not a valid identifier",
            [
                134713549
            ]
        ],
        "135074045": [
            "REPLY",
            [
                134713549
            ]
        ],
        "135074051": [
            "-%c: %-30s ",
            [
                134714871
            ]
        ],
        "135074063": [
            "error setting limit",
            [
                134714871
            ]
        ],
        "135074083": [
            "-HSaf::t::d::s::c::m::l::p::n::v::w::e::r::",
            [
                134714871
            ]
        ],
        "135074127": [
            "cpu time (seconds)",
            []
        ],
        "135074146": [
            "data seg size (kb)",
            []
        ],
        "135074165": [
            "stack size (kb)",
            []
        ],
        "135074181": [
            "core ",
            []
        ],
        "135074186": [
            "file size (blocks)",
            [
                4294967295
            ]
        ],
        "135074205": [
            "resident set size (kb)",
            []
        ],
        "135074228": [
            "locked memory (kb)",
            []
        ],
        "135074247": [
            "file descriptors",
            []
        ],
        "135074264": [
            "address space (kb)",
            []
        ],
        "135074283": [
            "scheduling priority",
            []
        ],
        "135074303": [
            "real-time ",
            []
        ],
        "135074313": [
            "priority",
            [
                134617090,
                134717542
            ]
        ],
        "135074322": [
            "OPTIND=1",
            [
                134688608
            ]
        ],
        "135074343": [
            "klogd started: %s",
            [
                134715303
            ]
        ],
        "135074361": [
            "klogctl(2) error",
            [
                134715303
            ]
        ],
        "135074378": [
            "klogd: exiting",
            [
                134715303
            ]
        ],
        "135074402": [
            "%s %.64s %s %s\n",
            [
                134715983
            ]
        ],
        "135074418": [
            "/dev/console",
            [
                134806442,
                4294967295,
                134805764,
                134715983
            ]
        ],
        "135074431": [
            "%s.%d",
            [
                134715983
            ]
        ],
        "135074437": [
            "%s.%s",
            [
                134764268,
                134715983
            ]
        ],
        "135074443": [
            "^m:nO:l:Ss:b:R:*L",
            [
                134716698
            ]
        ],
        "135074464": [
            "syslogd started: BusyBox v1.29.2",
            [
                134716698
            ]
        ],
        "135074497": [
            "syslogd exiting",
            [
                134716698
            ]
        ],
        "135074513": [
            "p:st:",
            [
                134717542
            ]
        ],
        "135074519": [
            "facility",
            [
                134717542
            ]
        ],
        "135074528": [
            "unknown %s name: %s",
            [
                134717542
            ]
        ],
        "135074548": [
            "/var/log/",
            [
                4294967295
            ]
        ],
        "135074557": [
            "messages",
            [
                134736925
            ]
        ],
        "135074571": [
            "authpriv",
            []
        ],
        "135074580": [
            "daemon",
            []
        ],
        "135074615": [
            "security",
            []
        ],
        "135074624": [
            "syslog",
            [
                4294967295
            ]
        ],
        "135074636": [
            "local0",
            []
        ],
        "135074643": [
            "local1",
            []
        ],
        "135074650": [
            "local2",
            []
        ],
        "135074657": [
            "local3",
            []
        ],
        "135074664": [
            "local4",
            []
        ],
        "135074671": [
            "local5",
            []
        ],
        "135074678": [
            "local6",
            []
        ],
        "135074685": [
            "local7",
            []
        ],
        "135074692": [
            "alert",
            [
                4294967295
            ]
        ],
        "135074703": [
            "debug",
            []
        ],
        "135074709": [
            "emerg",
            []
        ],
        "135074715": [
            "notice",
            []
        ],
        "135074722": [
            "panic",
            []
        ],
        "135074733": [
            "warning",
            []
        ],
        "135074741": [
            "%s min/max priority\t: %u/%u\n",
            [
                134717976
            ]
        ],
        "135074770": [
            "%s not supported\n",
            [
                134717976
            ]
        ],
        "135074788": [
            "current",
            [
                134718036
            ]
        ],
        "135074800": [
            "^+mprfobi",
            [
                134718036
            ]
        ],
        "135074810": [
            "r--fobi:f--robi:o--rfbi:b--rfoi:i--rfob",
            []
        ],
        "135074850": [
            "can't %cet pid %d's policy",
            [
                134718036
            ]
        ],
        "135074877": [
            "pid %d's %s scheduling policy: %s\n",
            [
                134718036
            ]
        ],
        "135074912": [
            "can't get pid %d's attributes",
            [
                134718036
            ]
        ],
        "135074942": [
            "pid %d's %s scheduling priority: %d\n",
            [
                134718036
            ]
        ],
        "135074979": [
            "cs:+n:+r",
            [
                134718439
            ]
        ],
        "135074988": [
            "klogctl",
            [
                134718439
            ]
        ],
        "135074996": [
            "/dev/cdrom",
            [
                134718742
            ]
        ],
        "135075011": [
            "?1:t--T:T--t",
            []
        ],
        "135075024": [
            "fallocate '%s'",
            [
                134718865
            ]
        ],
        "135075039": [
            "^l:o:",
            [
                134718865
            ]
        ],
        "135075048": [
            "\nmode \"%ux%u-%u\"\n\t# D: %.3f MHz, H: %.3f kHz, V: %.3f Hz\n\tgeometry %u %u %u %u %u\n\ttimings %u %u %u %u %u %u %u\n\taccel %s\n\trgba %u/%u,%u/%u,%u/%u,%u/%u\nendmode\n\n",
            [
                134719069
            ]
        ],
        "135075210": [
            "/etc/fb.modes",
            [
                134719481
            ]
        ],
        "135075224": [
            "/dev/fb0",
            [
                134719481
            ]
        ],
        "135075233": [
            "FBIOGET_VSCREENINFO",
            [
                134719481
            ]
        ],
        "135075258": [
            "unknown video mode '%s'",
            [
                134719481
            ]
        ],
        "135075282": [
            "endmode",
            [
                134719481
            ]
        ],
        "135075290": [
            "%d %d ",
            [
                134719481
            ]
        ],
        "135075296": [
            "%d %d %d %d %d",
            [
                134719481
            ]
        ],
        "135075311": [
            "%d/%d,%d/%d,%d/%d,%d/%d",
            [
                134719481
            ]
        ],
        "135075335": [
            "FBIOPUT_VSCREENINFO",
            [
                134719481
            ]
        ],
        "135075355": [
            "geometry",
            [
                134719481
            ]
        ],
        "135075364": [
            "timings",
            []
        ],
        "135075372": [
            "interlaced",
            []
        ],
        "135075383": [
            "double",
            []
        ],
        "135075390": [
            "vsync",
            []
        ],
        "135075396": [
            "hsync",
            []
        ],
        "135075402": [
            "csync",
            []
        ],
        "135075408": [
            "extsync",
            []
        ],
        "135075422": [
            "Double",
            [
                134720860
            ]
        ],
        "135075429": [
            "Single",
            [
                134720860
            ]
        ],
        "135075436": [
            "%s: not a block device",
            [
                134745708,
                134720860,
                134753221
            ]
        ],
        "135075459": [
            "FDGETPRM",
            [
                134720860
            ]
        ],
        "135075468": [
            "%s-sided, %u tracks, %u sec/track. Total capacity %d kB\n",
            [
                134720860
            ]
        ],
        "135075525": [
            "Formatting... ",
            [
                134720860
            ]
        ],
        "135075540": [
            "FDFMTBEG",
            [
                134720860
            ]
        ],
        "135075549": [
            "FDFMTTRK",
            [
                134720860
            ]
        ],
        "135075558": [
            "%3d\b\b\b",
            [
                134720860
            ]
        ],
        "135075565": [
            "FDFMTEND",
            [
                134720860
            ]
        ],
        "135075574": [
            "Verifying... ",
            [
                134720860
            ]
        ],
        "135075588": [
            "problem reading cylinder %d, expected %d, read %d",
            [
                134720860
            ]
        ],
        "135075638": [
            "bad data in cyl %d\nContinuing... ",
            [
                134720860
            ]
        ],
        "135075678": [
            "Disk %s: %llu %cB, %llu bytes, %u sectors\n%u cylinders, %u heads, %u sectors/track\nUnits: %s of %u * %u = %u bytes\n\n",
            [
                134721810
            ]
        ],
        "135075795": [
            "\nThe number of cylinders for this disk is set to %u.\nThere is nothing wrong with that, but this is larger than 1024,\nand could in certain setups cause problems with:\n1) software that runs at boot time (e.g., old versions of LILO)\n2) booting and partitioning software from other OSs\n   (e.g., DOS FDISK, OS/2 FDISK)\n",
            [
                134722006
            ]
        ],
        "135076111": [
            "Unknown value(s) for:",
            [
                134722048
            ]
        ],
        "135076133": [
            " (settable in the extra functions menu)",
            [
                134722048
            ]
        ],
        "135076173": [
            "Command Action",
            [
                134722155,
                134730630
            ]
        ],
        "135076188": [
            "o\tcreate a new empty DOS partition table",
            [
                134722155
            ]
        ],
        "135076229": [
            "p\tprint the partition table",
            [
                134722155,
                134730630
            ]
        ],
        "135076257": [
            "q\tquit without saving changes",
            [
                134722155,
                134730630
            ]
        ],
        "135076287": [
            "s\tcreate a new empty Sun disklabel",
            [
                134722155
            ]
        ],
        "135076322": [
            "a\ttoggle a bootable flag",
            [
                134722155
            ]
        ],
        "135076347": [
            "b\tedit bsd disklabel",
            [
                134722155
            ]
        ],
        "135076368": [
            "c\ttoggle the dos compatibility flag",
            [
                134722155
            ]
        ],
        "135076404": [
            "d\tdelete a partition",
            [
                134722155
            ]
        ],
        "135076425": [
            "l\tlist known partition types",
            [
                134722155
            ]
        ],
        "135076454": [
            "n\tadd a new partition",
            [
                134722155
            ]
        ],
        "135076476": [
            "t\tchange a partition's system id",
            [
                134722155
            ]
        ],
        "135076509": [
            "u\tchange display/entry units",
            [
                134722155
            ]
        ],
        "135076538": [
            "v\tverify the partition table",
            [
                134722155,
                134730630
            ]
        ],
        "135076567": [
            "w\twrite table to disk and exit",
            [
                134722155,
                134730630
            ]
        ],
        "135076598": [
            "x\textra functionality (experts only)",
            [
                134722155
            ]
        ],
        "135076635": [
            "can't seek on %s",
            [
                134722416
            ]
        ],
        "135076652": [
            "can't read",
            [
                134726513,
                134722460
            ]
        ],
        "135076662": [
            " from %s",
            [
                134612104,
                134621773
            ]
        ],
        "135076671": [
            "%u,%u,%u",
            [
                134723002
            ]
        ],
        "135076680": [
            "The partition table has been altered.",
            [
                134723072
            ]
        ],
        "135076718": [
            "Calling ioctl() to re-read partition table",
            [
                134723072
            ]
        ],
        "135076761": [
            "WARNING: rereading partition table failed, kernel still uses old ",
            [
                134723072
            ]
        ],
        "135076826": [
            "table",
            [
                134632747,
                134639324
            ]
        ],
        "135076832": [
            "%c%2x %-22.22s",
            [
                134723270
            ]
        ],
        "135076847": [
            "%s (%u-%u, default %u): ",
            [
                134723418
            ]
        ],
        "135076872": [
            "%s (%u-%u): ",
            [
                134723418
            ]
        ],
        "135076885": [
            "Using default value %u\n",
            [
                134723418
            ]
        ],
        "135076909": [
            "Value is out of range",
            [
                134723418
            ]
        ],
        "135076931": [
            "Partition number",
            [
                134723830
            ]
        ],
        "135076948": [
            "Warning: partition %u has empty type\n",
            [
                134723830
            ]
        ],
        "135076986": [
            "Selected partition %u\n",
            [
                134723904,
                134724019
            ]
        ],
        "135077009": [
            "No partition is defined yet!",
            [
                134723904
            ]
        ],
        "135077038": [
            "All primary partitions have been defined already!",
            [
                134724019
            ]
        ],
        "135077088": [
            "Partition %u has different physical/logical start (non-Linux?):\n",
            [
                134724121
            ]
        ],
        "135077153": [
            "     phys=(%u,%u,%u) ",
            [
                134724121
            ]
        ],
        "135077175": [
            "logical=(%u,%u,%u)\n",
            [
                134724121
            ]
        ],
        "135077195": [
            "Partition %u has different physical/logical end:\n",
            [
                134724121
            ]
        ],
        "135077245": [
            "\nDisk %s: %u heads, %u sectors, %u cylinders\n\n",
            [
                134724520
            ]
        ],
        "135077292": [
            "Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID",
            [
                134724520
            ]
        ],
        "135077349": [
            "%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\n",
            [
                134724520
            ]
        ],
        "135077390": [
            "Warning: bad start-of-data in partition %u\n",
            [
                134724750
            ]
        ],
        "135077434": [
            "Partition %u contains sector 0\n",
            [
                134724750
            ]
        ],
        "135077466": [
            "Partition %u: head %u greater than maximum %u\n",
            [
                134724750
            ]
        ],
        "135077513": [
            "Partition %u: sector %u greater than maximum %u\n",
            [
                134724750
            ]
        ],
        "135077562": [
            "Partition %u: cylinder %u greater than maximum %u\n",
            [
                134724750
            ]
        ],
        "135077613": [
            "Partition %u: previous sectors %u disagrees with total %u\n",
            [
                134724750
            ]
        ],
        "135077672": [
            "Warning: partition %u overlaps partition %u\n",
            [
                134724750
            ]
        ],
        "135077717": [
            "Warning: partition %u is empty\n",
            [
                134724750
            ]
        ],
        "135077749": [
            "Logical partition %u not entirely in partition %u\n",
            [
                134724750
            ]
        ],
        "135077800": [
            "Total allocated sectors %u greater than CHS size %u\n",
            [
                134724750
            ]
        ],
        "135077853": [
            "%u unallocated sectors\n",
            [
                134724750
            ]
        ],
        "135077882": [
            " KMGTPEZY",
            [
                134725462
            ]
        ],
        "135077892": [
            "Disk %s: %llu sectors, %s\n",
            [
                134725462
            ]
        ],
        "135077919": [
            "Logical sector size: %u\n",
            [
                134725462
            ]
        ],
        "135077944": [
            "Disk identifier (GUID): ",
            [
                134725462
            ]
        ],
        "135077969": [
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            [
                134762570,
                134725462
            ]
        ],
        "135078038": [
            "\nPartition table holds up to %u entries\n",
            [
                134725462
            ]
        ],
        "135078079": [
            "First usable sector is %llu, last usable sector is %llu\n\n",
            [
                134725462
            ]
        ],
        "135078137": [
            "Number  Start (sector)    End (sector)  Size Name",
            [
                134725462
            ]
        ],
        "135078187": [
            "%6u %15llu %15llu %s ",
            [
                134725462
            ]
        ],
        "135078209": [
            "Device",
            [
                134725462
            ]
        ],
        "135078216": [
            "%-*s Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n",
            [
                134725462
            ]
        ],
        "135078298": [
            "%*.*s%s%-2u",
            [
                134725462
            ]
        ],
        "135078310": [
            "%s%s %-11s %-11s %10u %10u %10u %s %2x %s\n",
            [
                134725462
            ]
        ],
        "135078353": [
            "\nPartition table entries are not in disk order",
            [
                134725462
            ]
        ],
        "135078400": [
            "'%s' is opened for read only\n",
            [
                134726513
            ]
        ],
        "135078430": [
            "Note: sector size is %u (not 512)\n",
            [
                134726513
            ]
        ],
        "135078465": [
            "device has more than 2^32 sectors, can't use all of them",
            [
                134726513
            ]
        ],
        "135078522": [
            "\nwarning: GPT header CRC is invalid\n",
            [
                134726513
            ]
        ],
        "135078559": [
            "\nwarning: unable to parse GPT disklabel\n",
            [
                134726513
            ]
        ],
        "135078600": [
            "\nwarning: GPT array CRC is invalid\n",
            [
                134726513
            ]
        ],
        "135078636": [
            "Found valid GPT with protective MBR; using GPT\n",
            [
                134726513
            ]
        ],
        "135078684": [
            "Device contains neither a valid DOS partition table, nor Sun, SGI, OSF or GPT disklabel",
            [
                134726513
            ]
        ],
        "135078772": [
            "Ignoring extra extended partition %u\n",
            [
                134726513
            ]
        ],
        "135078810": [
            "Bad offset in primary extended partition",
            [
                134726513
            ]
        ],
        "135078851": [
            "Warning: deleting partitions after %u\n",
            [
                134726513
            ]
        ],
        "135078890": [
            "Warning: extra link pointer in partition table %u\n",
            [
                134726513
            ]
        ],
        "135078941": [
            "Warning: ignoring extra data in partition table %u\n",
            [
                134726513
            ]
        ],
        "135078993": [
            "Omitting empty partition (%u)\n",
            [
                134726513
            ]
        ],
        "135079024": [
            "Warning: invalid flag 0x%02x,0x%02x of partition table %u will be corrected by w(rite)\n",
            [
                134726513
            ]
        ],
        "135079112": [
            "DOS disklabel",
            [
                134728526
            ]
        ],
        "135079126": [
            "/dev/hd",
            [
                134728632
            ]
        ],
        "135079134": [
            "/proc/ide/%s/media",
            [
                134728632
            ]
        ],
        "135079153": [
            "Disk %s doesn't contain a valid partition table\n",
            [
                134728632
            ]
        ],
        "135079202": [
            "/proc/partitions",
            [
                134728989
            ]
        ],
        "135079219": [
            " %u %u %u %[^\n ]",
            [
                134728989
            ]
        ],
        "135079236": [
            "cylinder",
            [
                134729213
            ]
        ],
        "135079245": [
            "First %s",
            [
                134729213
            ]
        ],
        "135079254": [
            "Sector %u is already allocated\n",
            [
                134729213
            ]
        ],
        "135079286": [
            "No free sectors available",
            [
                134729213
            ]
        ],
        "135079312": [
            "Last %s or +size{,K,M,G,T}",
            [
                134729213
            ]
        ],
        "135079339": [
            "l   logical (5 or over)",
            [
                134730630
            ]
        ],
        "135079363": [
            "e   extended",
            [
                134730630
            ]
        ],
        "135079376": [
            "b:+C:+H:+lS:+u",
            [
                134730630
            ]
        ],
        "135079391": [
            "Command (m for help): ",
            [
                134730630
            ]
        ],
        "135079414": [
            "WARNING: Partition %u is an extended partition\n",
            [
                134730630
            ]
        ],
        "135079462": [
            "%c: unknown command\n",
            [
                134730630
            ]
        ],
        "135079483": [
            "DOS Compatibility flag is %sset\n",
            [
                134730630
            ]
        ],
        "135079521": [
            "The maximum number of partitions has been created",
            [
                134730630
            ]
        ],
        "135079571": [
            "You must delete some partition and add an extended partition first",
            [
                134730630
            ]
        ],
        "135079638": [
            "Partition type\n   p   primary partition (1-4)\n ",
            [
                134730630
            ]
        ],
        "135079685": [
            "  %s\n",
            [
                134624684,
                134625655
            ]
        ],
        "135079691": [
            "Invalid partition number for type '%c'\n",
            [
                134730630
            ]
        ],
        "135079731": [
            "Partition %u does not exist yet!\n",
            [
                134730630
            ]
        ],
        "135079765": [
            "Hex code (type L to list codes): ",
            [
                134730630
            ]
        ],
        "135079799": [
            "Type 0 means free space to many systems\n(but not to Linux). Having partitions of\ntype 0 is probably unwise.",
            [
                134730630
            ]
        ],
        "135079907": [
            "You cannot change a partition into an extended one or vice versa",
            [
                134730630
            ]
        ],
        "135079972": [
            "Changed system type of partition %u to %x (%s)\n",
            [
                134730630
            ]
        ],
        "135080020": [
            "Changing display/entry units to %s\n",
            [
                134730630
            ]
        ],
        "135080056": [
            "Expert command (m for help): ",
            [
                134730630
            ]
        ],
        "135080086": [
            "Partition %u has no data area\n",
            [
                134730630
            ]
        ],
        "135080117": [
            "New beginning of data",
            [
                134730630
            ]
        ],
        "135080139": [
            "Recalculate C/H/S values? (Y/N): ",
            [
                134730630
            ]
        ],
        "135080173": [
            "Number of",
            [
                134730630
            ]
        ],
        "135080183": [
            "cylinders",
            [
                134721810,
                134730630
            ]
        ],
        "135080193": [
            "Device: %s\n",
            [
                134730630
            ]
        ],
        "135080205": [
            "0x%03X:",
            [
                134730630
            ]
        ],
        "135080213": [
            " %02X",
            [
                134730630
            ]
        ],
        "135080219": [
            "Ordering is already correct\n",
            [
                134730630
            ]
        ],
        "135080248": [
            "Number of",
            [
                134730630
            ]
        ],
        "135080257": [
            " heads",
            [
                134722048
            ]
        ],
        "135080264": [
            "Number of",
            [
                134730630
            ]
        ],
        "135080274": [
            "sectors",
            [
                134721810,
                134730630
            ]
        ],
        "135080282": [
            "Warning: setting sector offset for DOS compatibility",
            [
                134730630
            ]
        ],
        "135080335": [
            "b\tmove beginning of data in a partition",
            [
                134730630
            ]
        ],
        "135080375": [
            "c\tchange number of cylinders",
            [
                134730630
            ]
        ],
        "135080404": [
            "d\tprint the raw data in the partition table",
            [
                134730630
            ]
        ],
        "135080448": [
            "e\tlist extended partitions",
            [
                134730630
            ]
        ],
        "135080475": [
            "f\tfix partition order",
            [
                134730630
            ]
        ],
        "135080497": [
            "h\tchange number of heads",
            [
                134730630
            ]
        ],
        "135080522": [
            "r\treturn to main menu",
            [
                134730630
            ]
        ],
        "135080544": [
            "s\tchange number of sectors/track",
            [
                134730630
            ]
        ],
        "135080578": [
            "Empty",
            []
        ],
        "135080585": [
            "FAT12",
            []
        ],
        "135080592": [
            "FAT16 <32M",
            []
        ],
        "135080604": [
            "Extended",
            []
        ],
        "135080614": [
            "FAT16",
            []
        ],
        "135080620": [
            "\u0007HPFS/",
            [
                4294967295
            ]
        ],
        "135080631": [
            "\nOS/2 Boot Manager",
            [
                4294967295
            ]
        ],
        "135080650": [
            "\u000bWin95 FAT32",
            [
                4294967295
            ]
        ],
        "135080664": [
            "Win95 FAT32 (LBA)",
            []
        ],
        "135080683": [
            "Win95 FAT16 (LBA)",
            []
        ],
        "135080702": [
            "Win95 Ext'd (LBA)",
            []
        ],
        "135080721": [
            "Hidden FAT12",
            []
        ],
        "135080735": [
            "Compaq diagnostics",
            []
        ],
        "135080755": [
            "Hidden FAT16 <32M",
            []
        ],
        "135080774": [
            "Hidden FAT16",
            []
        ],
        "135080788": [
            "Hidden HPFS/NTFS",
            []
        ],
        "135080805": [
            "\u001bHidden Win95 FAT32",
            [
                4294967295
            ]
        ],
        "135080826": [
            "Hidden W95 FAT32 (LBA)",
            []
        ],
        "135080850": [
            "Hidden W95 FAT16 (LBA)",
            []
        ],
        "135080873": [
            "<Part.Magic recovery",
            [
                4294967295
            ]
        ],
        "135080894": [
            "APPC PReP Boot",
            [
                4294967295
            ]
        ],
        "135080914": [
            "cGNU HURD or SysV",
            [
                4294967295
            ]
        ],
        "135080933": [
            "Old Minix",
            []
        ],
        "135080944": [
            "Minix / old Linux",
            []
        ],
        "135080963": [
            "Linux swap",
            []
        ],
        "135080975": [
            "Linux",
            []
        ],
        "135080982": [
            "OS/2 hidden C: drive",
            []
        ],
        "135081004": [
            "Linux extended",
            []
        ],
        "135081020": [
            "NTFS volume ",
            []
        ],
        "135081037": [
            "NTFS volume set",
            []
        ],
        "135081054": [
            "Linux LVM",
            []
        ],
        "135081065": [
            "BSD/OS",
            []
        ],
        "135081073": [
            "Thinkpad hibernation",
            []
        ],
        "135081095": [
            "FreeBSD",
            []
        ],
        "135081104": [
            "OpenBSD",
            []
        ],
        "135081113": [
            "Darwin UFS",
            []
        ],
        "135081125": [
            "NetBSD",
            []
        ],
        "135081133": [
            "Darwin boot",
            []
        ],
        "135081146": [
            "BSDI fs",
            []
        ],
        "135081155": [
            "BSDI ",
            []
        ],
        "135081166": [
            "Solaris boot",
            []
        ],
        "135081180": [
            "BeOS fs",
            []
        ],
        "135081189": [
            "EFI GPT",
            []
        ],
        "135081198": [
            "EFI (FAT-12/16/32)",
            []
        ],
        "135081218": [
            "Linux/PA-RISC ",
            []
        ],
        "135081238": [
            "DOS secondary",
            []
        ],
        "135081253": [
            "Linux raid autodetect",
            []
        ],
        "135081275": [
            "Partition %u is already defined, delete it before re-adding\n",
            [
                134729213
            ]
        ],
        "135081336": [
            "Building a new %s. Changes will remain in memory only,\nuntil you decide to write them. After that the previous content\nwon't be recoverable.\n\n",
            [
                134728526
            ]
        ],
        "135081479": [
            "^+sxnu",
            [
                134733056
            ]
        ],
        "135081489": [
            "-command",
            [
                134733056
            ]
        ],
        "135081498": [
            "-c takes only one argument",
            [
                134733056
            ]
        ],
        "135081525": [
            "shared",
            [
                134733056
            ]
        ],
        "135081533": [
            "sexclusive",
            []
        ],
        "135081545": [
            "xunlock",
            []
        ],
        "135081554": [
            "unonblock",
            []
        ],
        "135081567": [
            "freeze",
            [
                134733432
            ]
        ],
        "135081576": [
            "unfreeze",
            []
        ],
        "135081607": [
            "(opts & 1) ? FIFREEZE : FITHAW",
            [
                134733432
            ]
        ],
        "135081638": [
            "^o:l:m:v",
            [
                134733504
            ]
        ],
        "135081650": [
            "FITRIM",
            [
                134733504
            ]
        ],
        "135081657": [
            "%s: %llu bytes trimmed\n",
            [
                134733504
            ]
        ],
        "135081681": [
            "offset",
            [
                134733504
            ]
        ],
        "135081689": [
            "olength",
            []
        ],
        "135081698": [
            "lminimum",
            []
        ],
        "135081708": [
            "mverbose",
            []
        ],
        "135081720": [
            " --%s",
            [
                134733894
            ]
        ],
        "135081730": [
            "GETOPT_COMPATIBLE",
            [
                134734246
            ]
        ],
        "135081748": [
            "missing optstring argument",
            [
                134734246
            ]
        ],
        "135081778": [
            "+o:n:qQs:Tual:*",
            [
                134734246
            ]
        ],
        "135081799": [
            "empty long option specified",
            [
                134734246
            ]
        ],
        "135081832": [
            "unknown shell '%s', assuming ",
            [
                134734246
            ]
        ],
        "135081866": [
            "options",
            [
                134734246
            ]
        ],
        "135081875": [
            "olongoptions",
            []
        ],
        "135081889": [
            "lquiet",
            []
        ],
        "135081897": [
            "qquiet-output",
            []
        ],
        "135081912": [
            "Qshell",
            []
        ],
        "135081920": [
            "stest",
            []
        ],
        "135081927": [
            "Tunquoted",
            []
        ],
        "135081938": [
            "ualternative",
            []
        ],
        "135081952": [
            "aname",
            []
        ],
        "135081961": [
            "\"%08.8_Ax\n\"",
            [
                134734843
            ]
        ],
        "135081973": [
            "\"%08.8_ax  \"8/1 \"%02x \"\"  \"8/1 \"%02x \"",
            [
                134734843
            ]
        ],
        "135082012": [
            "\"  |\"16/1 \"%_p\"\"|\n\"",
            [
                134734843
            ]
        ],
        "135082032": [
            "\"%07.7_ax \"8/2 \"%04x \"\"\n\"",
            [
                134734843
            ]
        ],
        "135082058": [
            "bcdoxCe:f:n:s:v",
            [
                134734843
            ]
        ],
        "135082074": [
            "\"%07.7_Ax\n\"",
            [
                134734843
            ]
        ],
        "135082086": [
            "\"%07.7_ax \"16/1 \"%03o \"\"\n\"",
            [
                4294967295
            ]
        ],
        "135082113": [
            "\"%07.7_ax \"16/1 \"%3_c \"\"\n\"",
            [
                4294967295
            ]
        ],
        "135082140": [
            "\"%07.7_ax \"8/2 \"  %05u \"\"\n\"",
            [
                4294967295
            ]
        ],
        "135082168": [
            "\"%07.7_ax \"8/2 \" %06o \"\"\n\"",
            [
                4294967295
            ]
        ],
        "135082195": [
            "\"%07.7_ax \"8/2 \"   %04x \"\"\n\"",
            [
                4294967295
            ]
        ],
        "135082224": [
            "^l:s:apg:+c:+",
            [
                134735225
            ]
        ],
        "135082241": [
            "\"%08.8_ax: \"",
            [
                134735225
            ]
        ],
        "135082254": [
            "%u/1 \"%%02x\"",
            [
                134735225
            ]
        ],
        "135082267": [
            "%u/1 \"%%02x \"",
            [
                134735225
            ]
        ],
        "135082281": [
            "/1 \"%02x\"",
            [
                134735225
            ]
        ],
        "135082291": [
            "\"  \"%u/1 \"%%_p\"\"\n\"",
            [
                134735225
            ]
        ],
        "135082310": [
            "^lurswtf:",
            [
                134735632
            ]
        ],
        "135082320": [
            "r--wst:w--rst:s--wrt:t--rsw:l--u:u--l",
            []
        ],
        "135082358": [
            "settimeofday",
            [
                134735632
            ]
        ],
        "135082371": [
            "RTC_SET_TIME",
            [
                134735632
            ]
        ],
        "135082384": [
            "%s  0.000000 seconds\n",
            [
                134735632
            ]
        ],
        "135082406": [
            "localtime",
            [
                134735632
            ]
        ],
        "135082423": [
            "ushow",
            []
        ],
        "135082430": [
            "rhctosys",
            []
        ],
        "135082440": [
            "ssystohc",
            []
        ],
        "135082450": [
            "wsystz",
            []
        ],
        "135082466": [
            "permission denied",
            [
                134736060
            ]
        ],
        "135082488": [
            "already removed",
            [
                134736060
            ]
        ],
        "135082504": [
            "invalid",
            [
                134736060
            ]
        ],
        "135082512": [
            "unknown error in",
            [
                134736060
            ]
        ],
        "135082529": [
            "invalid id: %s",
            [
                134736060
            ]
        ],
        "135082544": [
            "can't remove id %s",
            [
                134736060
            ]
        ],
        "135082563": [
            "resource(s) deleted",
            [
                134736060
            ]
        ],
        "135082583": [
            "illegal key (%s)",
            [
                134736060
            ]
        ],
        "135082600": [
            "%s %s (%s)",
            [
                134736060
            ]
        ],
        "135082611": [
            "q:m:s:Q:M:S:",
            [
                134736060
            ]
        ],
        "135082624": [
            "%-10d %-10o",
            [
                134736749
            ]
        ],
        "135082636": [
            " %-10s",
            [
                134812027,
                134736749
            ]
        ],
        "135082643": [
            "Not set",
            [
                134739216,
                134738580,
                134737716,
                134736925
            ]
        ],
        "135082651": [
            "message queues",
            [
                134736925
            ]
        ],
        "135082666": [
            "kernel not configured for %s\n",
            [
                134738580,
                134737716,
                134736925
            ]
        ],
        "135082696": [
            "s: Limits",
            [
                134736925
            ]
        ],
        "135082706": [
            "------ Message%s --------\n",
            [
                134736925
            ]
        ],
        "135082733": [
            "max queues system wide = %d\nmax size of message (bytes) = %d\ndefault max size of queue (bytes) = %d\n",
            [
                134736925
            ]
        ],
        "135082834": [
            "s: Status",
            [
                134736925
            ]
        ],
        "135082844": [
            "allocated queues = %d\nused headers = %d\nused space = %d bytes\n",
            [
                134736925
            ]
        ],
        "135082907": [
            " Queues: Creators/Owners",
            [
                134736925
            ]
        ],
        "135082942": [
            "perms",
            [
                134738580,
                134737716,
                134736925
            ]
        ],
        "135082948": [
            "msqid",
            [
                134736925
            ]
        ],
        "135082954": [
            "%-10s %-10s %-10s %-10s %-10s %-10s\n",
            [
                134738580,
                134737716,
                134736925
            ]
        ],
        "135082991": [
            " Queues Send/Recv/Change Times",
            [
                134736925
            ]
        ],
        "135083032": [
            "%-8s %-10s %-20s %-20s %-20s\n",
            [
                134736925
            ]
        ],
        "135083062": [
            " Queues PIDs",
            [
                134736925
            ]
        ],
        "135083075": [
            "lrpid",
            [
                134736925
            ]
        ],
        "135083081": [
            "lspid",
            [
                134736925
            ]
        ],
        "135083087": [
            " Queues",
            [
                134736925
            ]
        ],
        "135083095": [
            "used-bytes",
            [
                134736925
            ]
        ],
        "135083106": [
            "%-10s %-10s %-10s %-10s %-12s %-12s\n",
            [
                134736925
            ]
        ],
        "135083143": [
            "%-8d %-10.10s",
            [
                134738580,
                134736925
            ]
        ],
        "135083157": [
            "%-8d %-10d",
            [
                134738580,
                134736925
            ]
        ],
        "135083168": [
            " %-20.16s",
            [
                134737716,
                134736925
            ]
        ],
        "135083178": [
            " %-20.16s\n",
            [
                134737716,
                134736925
            ]
        ],
        "135083189": [
            "  %5d     %5d\n",
            [
                134736925
            ]
        ],
        "135083204": [
            "0x%08x ",
            [
                134738580,
                134737716,
                134736925
            ]
        ],
        "135083212": [
            "%-10d %-10.10s",
            [
                134737716,
                134736925
            ]
        ],
        "135083227": [
            "%-10d",
            [
                134737716,
                134736925
            ]
        ],
        "135083232": [
            " %-10d",
            [
                134736749
            ]
        ],
        "135083239": [
            " %-10o %-12ld %-12ld\n",
            [
                134736925
            ]
        ],
        "135083266": [
            "shared memory",
            [
                134737716
            ]
        ],
        "135083280": [
            "------ Shared Memory %s --------\n",
            [
                134738580,
                134737716
            ]
        ],
        "135083314": [
            "max number of segments = %lu\nmax seg size (kbytes) = %lu\nmax total shared memory (pages) = %lu\nmin seg size (bytes) = %lu\n",
            [
                134737716
            ]
        ],
        "135083437": [
            "segments allocated %d\npages allocated %lu\npages resident  %lu\npages swapped   %lu\nSwap performance: %lu attempts\t%lu successes\n",
            [
                134737716
            ]
        ],
        "135083565": [
            "Segment Creators/Owners",
            [
                134737716
            ]
        ],
        "135083589": [
            "shmid",
            [
                134738580,
                134737716
            ]
        ],
        "135083595": [
            "Attach/Detach/Change Times",
            [
                134737716
            ]
        ],
        "135083622": [
            "detached",
            [
                134737716
            ]
        ],
        "135083631": [
            "attached",
            [
                134737716
            ]
        ],
        "135083640": [
            "%-10s %-10s %-20s %-20s %-20s\n",
            [
                134737716
            ]
        ],
        "135083671": [
            "Creator/Last-op",
            [
                134737716
            ]
        ],
        "135083697": [
            "Segments",
            [
                134737716
            ]
        ],
        "135083706": [
            "nattch",
            [
                134737716
            ]
        ],
        "135083713": [
            "%-10s %-10s %-10s %-10s %-10s %-10s %-12s\n",
            [
                134737716
            ]
        ],
        "135083756": [
            " %-10o %-10lu %-10ld %-6s %-6s\n",
            [
                134737716
            ]
        ],
        "135083788": [
            "semaphores",
            [
                134738580
            ]
        ],
        "135083799": [
            "------ Semaphore %s --------\n",
            [
                134738580
            ]
        ],
        "135083829": [
            "max number of arrays = %d\nmax semaphores per array = %d\nmax semaphores system wide = %d\nmax ops per semop call = %d\nsemaphore max value = %d\n",
            [
                134738580
            ]
        ],
        "135083971": [
            "used arrays = %d\nallocated semaphores = %d\n",
            [
                134738580
            ]
        ],
        "135084015": [
            "Arrays Creators/Owners",
            [
                134738580
            ]
        ],
        "135084038": [
            "semid",
            [
                134738580
            ]
        ],
        "135084044": [
            "Operation/Change Times",
            [
                134738580
            ]
        ],
        "135084067": [
            "last-",
            [
                134738580
            ]
        ],
        "135084072": [
            "changed",
            [
                134737716
            ]
        ],
        "135084080": [
            "last-op",
            [
                134738580
            ]
        ],
        "135084088": [
            "%-8s %-10s %-26.24s %-26.24s\n",
            [
                134738580
            ]
        ],
        "135084118": [
            "Arrays",
            [
                134738580
            ]
        ],
        "135084125": [
            "nsems",
            [
                134738580
            ]
        ],
        "135084131": [
            "  %-26.24s",
            [
                134738580
            ]
        ],
        "135084142": [
            "%-10d %-10.9s",
            [
                134738580
            ]
        ],
        "135084156": [
            "%-10d %-9d",
            [
                134738580
            ]
        ],
        "135084167": [
            " %-10o %-10ld\n",
            [
                134738580
            ]
        ],
        "135084182": [
            "i:aqsmtcplu",
            [
                134739216
            ]
        ],
        "135084194": [
            "shmctl",
            [
                134739216
            ]
        ],
        "135084201": [
            "\nShared memory Segment shmid=%d\nuid=%d\tgid=%d\tcuid=%d\tcgid=%d\nmode=%#o\taccess_perms=%#o\nbytes=%ld\tlpid=%d\tcpid=%d\tnattch=%ld\n",
            [
                134739216
            ]
        ],
        "135084327": [
            "att_time=%-26.24s\n",
            [
                134739216
            ]
        ],
        "135084346": [
            "det_time=%-26.24s\n",
            [
                134739216
            ]
        ],
        "135084365": [
            "change_time=%-26.24s\n\n",
            [
                134739216
            ]
        ],
        "135084388": [
            "semctl",
            [
                134739216
            ]
        ],
        "135084395": [
            "\nSemaphore Array semid=%d\nuid=%d\t gid=%d\t cuid=%d\t cgid=%d\nmode=%#o, access_perms=%#o\nnsems = %ld\notime =",
            [
                134739216
            ]
        ],
        "135084500": [
            " %-26.24s\n",
            [
                134738580
            ]
        ],
        "135084511": [
            "zcount",
            [
                134739216
            ]
        ],
        "135084518": [
            "ncount",
            [
                134739216
            ]
        ],
        "135084525": [
            "semnum",
            [
                134739216
            ]
        ],
        "135084532": [
            "ctime = %-26.24s\n",
            [
                134739216
            ]
        ],
        "135084549": [
            "%-10s ",
            [
                134738580
            ]
        ],
        "135084555": [
            "%-10s %-10s %-10s",
            [
                134737716,
                134736925
            ]
        ],
        "135084572": [
            " %-10s\n",
            [
                134736749
            ]
        ],
        "135084580": [
            "%-10u %-10d %-10d",
            [
                134739216
            ]
        ],
        "135084597": [
            " %-10d",
            [
                134737716
            ]
        ],
        "135084603": [
            " %-10d\n",
            [
                134736749
            ]
        ],
        "135084611": [
            "msgctl",
            [
                134739216
            ]
        ],
        "135084618": [
            "\nMessage Queue msqid=%d\nuid=%d\tgid=%d\tcuid=%d\tcgid=%d\tmode=%#o\ncbytes=%ld\tqbytes=%ld\tqnum=%ld\tlspid=%d\tlrpid=%d\n",
            [
                134739216
            ]
        ],
        "135084731": [
            "send_time=%-26.24s\n",
            [
                134739216
            ]
        ],
        "135084751": [
            "rcv_time=%-26.24s\n",
            [
                134739216
            ]
        ],
        "135084770": [
            "%-10s %-14s %-18s %-12.12s %s\n",
            [
                134740143
            ]
        ],
        "135084801": [
            "system boot",
            [
                134740143
            ]
        ],
        "135084813": [
            "%-10s %-14s %-18s %-12.12s\n",
            [
                134740143
            ]
        ],
        "135084841": [
            "runlevel",
            [
                134740143
            ]
        ],
        "135084850": [
            "reboot",
            []
        ],
        "135084857": [
            "shutdown",
            []
        ],
        "135084874": [
            "^do:far",
            [
                134740623
            ]
        ],
        "135084882": [
            "?2:d--ofar:a--ofr",
            []
        ],
        "135084900": [
            "/dev/loop%u",
            [
                134938152,
                134740623
            ]
        ],
        "135084912": [
            "no free loop devices",
            [
                134740623
            ]
        ],
        "135084933": [
            "/uevent",
            [
                134741561,
                134742074,
                134741035
            ]
        ],
        "135084941": [
            "DRIVER",
            [
                134741035
            ]
        ],
        "135084948": [
            "PCI_CLASS",
            [
                134741035
            ]
        ],
        "135084958": [
            "PCI_ID",
            [
                134741035
            ]
        ],
        "135084965": [
            "PCI_SUBSYS_ID",
            [
                134741035
            ]
        ],
        "135084979": [
            "PCI_SLOT_NAME",
            [
                134741035
            ]
        ],
        "135084993": [
            "%s \"Class %04x\" \"%04x\" \"%04x\" \"%04x\" \"%04x\"",
            [
                134741035
            ]
        ],
        "135085037": [
            "%s Class %04x: %04x:%04x",
            [
                134741035
            ]
        ],
        "135085071": [
            "/sys/bus/pci/devices",
            [
                134741516
            ]
        ],
        "135085092": [
            "DEVTYPE",
            [
                134741561
            ]
        ],
        "135085100": [
            "PRODUCT",
            [
                134741561
            ]
        ],
        "135085108": [
            "BUSNUM",
            [
                134741561
            ]
        ],
        "135085115": [
            "DEVNUM",
            [
                134741561
            ]
        ],
        "135085126": [
            "Bus %s Device %s: ID %04x:%04x\n",
            [
                134741561
            ]
        ],
        "135085158": [
            "/sys/bus/usb/devices",
            [
                134741858
            ]
        ],
        "135085179": [
            "dev %u,%u",
            [
                134742074
            ]
        ],
        "135085189": [
            "\nDEVNAME=",
            [
                134742074
            ]
        ],
        "135085199": [
            "/block/",
            [
                134742074
            ]
        ],
        "135085207": [
            "block",
            [
                134742074
            ]
        ],
        "135085213": [
            "@%u,%u-%u",
            [
                134742074
            ]
        ],
        "135085223": [
            "bad @maj,min on line %d",
            [
                134742074
            ]
        ],
        "135085247": [
            "bad $envvar=regex on line %d",
            [
                134742074
            ]
        ],
        "135085276": [
            "unknown user/group '%s' on line %d",
            [
                134742074
            ]
        ],
        "135085319": [
            "bad line %u",
            [
                134742074
            ]
        ],
        "135085331": [
            "rule matched, line %d",
            [
                134742074
            ]
        ],
        "135085353": [
            "mknod %s (%d,%d) %o ",
            [
                134742074
            ]
        ],
        "135085373": [
            "%u:%u",
            [
                134541208,
                134742074,
                134852264
            ]
        ],
        "135085379": [
            "symlink: %s",
            [
                134742074
            ]
        ],
        "135085396": [
            "can't run '%s'",
            [
                134742074
            ]
        ],
        "135085411": [
            "unlink: %s",
            [
                134742074
            ]
        ],
        "135085422": [
            "/subsystem",
            [
                134744050
            ]
        ],
        "135085433": [
            "SUBSYSTEM",
            [
                134744050,
                134744362
            ]
        ],
        "135085443": [
            ".%06u",
            [
                134744301
            ]
        ],
        "135085454": [
            "/etc/mdev.conf",
            [
                134744362
            ]
        ],
        "135085469": [
            "ACTION=add",
            [
                134744362
            ]
        ],
        "135085480": [
            "/sys/dev",
            [
                134744362
            ]
        ],
        "135085489": [
            "DEVNAME",
            [
                134744362
            ]
        ],
        "135085497": [
            "ACTION",
            [
                134744362
            ]
        ],
        "135085504": [
            "DEVPATH",
            [
                134744362
            ]
        ],
        "135085512": [
            "FIRMWARE",
            [
                134744362
            ]
        ],
        "135085521": [
            "SEQNUM",
            [
                134744362
            ]
        ],
        "135085528": [
            "mdev.log",
            [
                134744362
            ]
        ],
        "135085537": [
            "%s[%s]",
            [
                134744362
            ]
        ],
        "135085544": [
            "mdev.seq",
            [
                134744362
            ]
        ],
        "135085553": [
            "first seq written",
            [
                134744362
            ]
        ],
        "135085571": [
            "%s mdev.seq='%s', need '%u'",
            [
                134744362
            ]
        ],
        "135085599": [
            "%s mdev.seq='%s'",
            [
                134744362
            ]
        ],
        "135085616": [
            "%s ACTION:%s SUBSYSTEM:%s DEVNAME:%s DEVPATH:",
            [
                134744362
            ]
        ],
        "135085661": [
            "%s%s%s",
            [
                134533841,
                134865103
            ]
        ],
        "135085668": [
            "/sys%s",
            [
                134744362
            ]
        ],
        "135085675": [
            "%s exiting",
            [
                134744362
            ]
        ],
        "135085695": [
            "remove",
            []
        ],
        "135085713": [
            "not a tty",
            [
                134745408,
                134847158
            ]
        ],
        "135085728": [
            "\nSuperblock backups stored on blocks:\n\t%u",
            [
                134745708
            ]
        ],
        "135085770": [
            "cl:b:+f:i:+I:+J:G:N:m:+o:g:L:M:O:r:E:T:U:jnqvFS",
            [
                134745708
            ]
        ],
        "135085818": [
            "can't format mounted filesystem",
            [
                134745708
            ]
        ],
        "135085850": [
            "blocksize %u is bad",
            [
                134745708
            ]
        ],
        "135085870": [
            "-%c is bad",
            [
                134745708
            ]
        ],
        "135085881": [
            "block count doesn't fit in 32 bits",
            [
                134745708
            ]
        ],
        "135085916": [
            "need >= 60 blocks",
            [
                134745708
            ]
        ],
        "135085934": [
            "warning: %u blocks unused\n\n",
            [
                134745708
            ]
        ],
        "135085962": [
            "Filesystem label=%s\nOS type: Linux\nBlock size=%u (log=%u)\nFragment size=%u (log=%u)\n%u inodes, %u blocks\n%u blocks (%u%%) reserved for the super user\nFirst data block=%u\nMaximum filesystem blocks=%u\n%u block groups\n%u blocks per group, %u fragments per group\n%u inodes per ",
            [
                134745708
            ]
        ],
        "135086235": [
            "group",
            [
                134541208,
                134601161,
                134540837
            ]
        ],
        "135086241": [
            "lost+found",
            [
                134745708
            ]
        ],
        "135086252": [
            "image size must be specified",
            [
                134747929
            ]
        ],
        "135086281": [
            "BLKSSZGET",
            [
                134747929
            ]
        ],
        "135086291": [
            "for this device sector size is %u",
            [
                134747929
            ]
        ],
        "135086325": [
            "the image is too small for FAT32",
            [
                134747929
            ]
        ],
        "135086358": [
            "can't make FAT32 with >128 sectors/cluster",
            [
                134747929
            ]
        ],
        "135086401": [
            "Device '%s':\nheads:%u, sectors/track:%u, bytes/sector:%u\nmedia descriptor:%02x\ntotal sectors:%llu, clusters:%u, sectors/cluster:%u\nFATs:2, sectors/FAT:%u\nvolumeID:%08x, label:'%s'\n",
            [
                134747929
            ]
        ],
        "135086585": [
            "mkdosfs",
            []
        ],
        "135086593": [
            "^Ab:cCf:F:h:Ii:l:m:n:r:R:s:S:v",
            [
                134747929
            ]
        ],
        "135086656": [
            "This is not a bootable disk\r\n",
            []
        ],
        "135086686": [
            "Setting up swapspace version 1, size = %llu bytes\n",
            [
                134749342
            ]
        ],
        "135086744": [
            "SWAPSPACE2dflsu",
            [
                134749342
            ]
        ],
        "135086760": [
            "--More-- ",
            [
                134749652
            ]
        ],
        "135086770": [
            "(%u%% of %llu bytes)",
            [
                134749652
            ]
        ],
        "135086791": [
            "\r%*s\r",
            [
                134749652
            ]
        ],
        "135086797": [
            "(Enter:next line Space:next page Q:quit R:show the rest)",
            [
                134749652
            ]
        ],
        "135086854": [
            "%s,%.*s",
            [
                134750636
            ]
        ],
        "135086862": [
            "%s is write-protected, mounting read-only",
            [
                134750816
            ]
        ],
        "135086904": [
            "unc=\\\\%s\\%.*s,prefixpath=%s",
            [
                134750929
            ]
        ],
        "135086932": [
            "unc=\\\\%s\\%.*s",
            [
                134750929
            ]
        ],
        "135086959": [
            "ip=%s",
            [
                134750929
            ]
        ],
        "135086969": [
            "%s%saddr=%s",
            [
                134750929
            ]
        ],
        "135086981": [
            "can't setup loop device",
            [
                134750929
            ]
        ],
        "135087005": [
            "nodev",
            [
                134750929
            ]
        ],
        "135087011": [
            "mounting %s on %s failed",
            [
                134750929
            ]
        ],
        "135087036": [
            "/etc/fstab",
            [
                134752064,
                134855329,
                134757684
            ]
        ],
        "135087050": [
            "/proc/mounts",
            [
                134752064,
                134759394,
                134812027,
                134919029
            ]
        ],
        "135087063": [
            "no %s",
            [
                134752064
            ]
        ],
        "135087069": [
            "%s on %s type %s (%s)\n",
            [
                134752064
            ]
        ],
        "135087092": [
            "can't find %s in %s",
            [
                134752064
            ]
        ],
        "135087112": [
            "^o:*t:rwanfvsiO:T:",
            [
                134752064
            ]
        ],
        "135087139": [
            "defaults",
            []
        ],
        "135087148": [
            "noauto",
            []
        ],
        "135087168": [
            "users",
            []
        ],
        "135087174": [
            "nofail",
            []
        ],
        "135087181": [
            "_netdev",
            []
        ],
        "135087189": [
            "comment=",
            []
        ],
        "135087198": [
            "nosuid",
            []
        ],
        "135087214": [
            "nodev",
            []
        ],
        "135087225": [
            "noexec",
            []
        ],
        "135087237": [
            "dirsync",
            []
        ],
        "135087245": [
            "async",
            []
        ],
        "135087251": [
            "atime",
            []
        ],
        "135087257": [
            "noatime",
            []
        ],
        "135087265": [
            "diratime",
            []
        ],
        "135087274": [
            "nodiratime",
            []
        ],
        "135087290": [
            "nomand",
            []
        ],
        "135087297": [
            "relatime",
            []
        ],
        "135087306": [
            "norelatime",
            []
        ],
        "135087317": [
            "strictatime",
            []
        ],
        "135087334": [
            "rbind",
            []
        ],
        "135087340": [
            "union",
            []
        ],
        "135087356": [
            "make-shared",
            []
        ],
        "135087368": [
            "make-slave",
            []
        ],
        "135087379": [
            "make-private",
            []
        ],
        "135087392": [
            "make-unbindable",
            []
        ],
        "135087408": [
            "make-rshared",
            []
        ],
        "135087421": [
            "make-rslave",
            []
        ],
        "135087433": [
            "make-rprivate",
            []
        ],
        "135087447": [
            "make-runbindable",
            []
        ],
        "135087470": [
            "remount",
            []
        ],
        "135087479": [
            "%s/..",
            [
                134753221
            ]
        ],
        "135087485": [
            "%s is %sa mountpoint\n",
            [
                134753221
            ]
        ],
        "135087507": [
            "^qdxn",
            [
                134753221
            ]
        ],
        "135087516": [
            "timeout connecting to time server",
            [
                134753733
            ]
        ],
        "135087557": [
            "current time matches remote time",
            [
                134753743
            ]
        ],
        "135087590": [
            "can't set time of day",
            [
                134753743
            ]
        ],
        "135087612": [
            "/proc/profile",
            [
                134753936
            ]
        ],
        "135087626": [
            "/boot/System.map",
            [
                134753936
            ]
        ],
        "135087643": [
            "M:+m:p:nabsirv",
            [
                134753936
            ]
        ],
        "135087658": [
            "assuming reversed byte order, use -n to force native byte order",
            [
                134753936
            ]
        ],
        "135087722": [
            "Sampling_step: %u\n",
            [
                134753936
            ]
        ],
        "135087741": [
            "%llx %s %s",
            [
                134753936
            ]
        ],
        "135087752": [
            "%s(%i): wrong map line",
            [
                134753936
            ]
        ],
        "135087775": [
            "_stext",
            [
                134753936
            ]
        ],
        "135087782": [
            "can't find \"_stext\" in %s",
            [
                134753936
            ]
        ],
        "135087808": [
            "%6u *unknown*\n",
            [
                134753936
            ]
        ],
        "135087823": [
            "profile address out of range. Wrong map file?",
            [
                134753936
            ]
        ],
        "135087869": [
            "\t%llx\t%u\n",
            [
                134753936
            ]
        ],
        "135087879": [
            "  total\t\t\t\t%u\n",
            [
                134753936
            ]
        ],
        "135087894": [
            "%016llx %-40s %6u %8.4f\n",
            [
                134753936
            ]
        ],
        "135087919": [
            "%6u %-40s %8.4f\n",
            [
                134753936
            ]
        ],
        "135087936": [
            "\t%#llx\t%s+%#llx\t%u\n",
            [
                134753936
            ]
        ],
        "135087956": [
            "%016x %-40s %6u %8.4f\n",
            [
                134753936
            ]
        ],
        "135087979": [
            "unknown user %s",
            [
                134755859,
                134912412
            ]
        ],
        "135087995": [
            "%cetpriority",
            [
                134755859
            ]
        ],
        "135088018": [
            "personality(0x%lx)",
            [
                134756205
            ]
        ],
        "135088037": [
            "invalid capability '%s'",
            [
                134756385,
                134756356
            ]
        ],
        "135088068": [
            "GET_NO_NEW_PRIVS",
            [
                134756385
            ]
        ],
        "135088085": [
            "prctl: %s",
            [
                134756385,
                134758285
            ]
        ],
        "135088096": [
            "uid: %u\n",
            [
                134756385
            ]
        ],
        "135088106": [
            "gid: %u\n",
            [
                134756385
            ]
        ],
        "135088115": [
            "Supplementary groups: ",
            [
                134756385
            ]
        ],
        "135088138": [
            "[none]",
            [
                134756385
            ]
        ],
        "135088145": [
            "\nno_new_privs: %d\n",
            [
                134756385
            ]
        ],
        "135088164": [
            "Inheritable capabilities: ",
            [
                134756385
            ]
        ],
        "135088191": [
            "\nindex: %u u32s: %u capability: %u\n",
            [
                134756385
            ]
        ],
        "135088227": [
            "unsupported capability",
            [
                134756385
            ]
        ],
        "135088250": [
            "\nAmbient capabilities: ",
            [
                134756385
            ]
        ],
        "135088274": [
            "CAP_AMBIENT_IS_SET",
            [
                134756385
            ]
        ],
        "135088293": [
            "\nCapability bounding set: ",
            [
                134756385
            ]
        ],
        "135088320": [
            "SET_NO_NEW_PRIVS",
            [
                134756385
            ]
        ],
        "135088337": [
            "capset",
            [
                134756385,
                134758285
            ]
        ],
        "135088344": [
            "cap_ambient_raise",
            [
                134756385
            ]
        ],
        "135088362": [
            "cap_ambient_lower",
            [
                134756385
            ]
        ],
        "135088393": [
            "no-new-privs",
            []
        ],
        "135088408": [
            "inh-caps",
            []
        ],
        "135088419": [
            "ambient-caps",
            []
        ],
        "135088442": [
            "%s: file has holes",
            [
                134757412
            ]
        ],
        "135088464": [
            "/proc/swaps",
            [
                134757684
            ]
        ],
        "135088483": [
            "can't parse file '%s'",
            [
                134757949
            ]
        ],
        "135088513": [
            "^+c:d:n",
            [
                134758285
            ]
        ],
        "135088524": [
            "/proc/sys/kernel/usermodehelper/bset",
            [
                134758285
            ]
        ],
        "135088561": [
            "/proc/sys/kernel/usermodehelper/inheritable",
            [
                134758285
            ]
        ],
        "135088608": [
            "CAPBSET_READ",
            [
                134756385
            ]
        ],
        "135088621": [
            "PR_CAPBSET_DROP",
            [
                134758285
            ]
        ],
        "135088637": [
            "dropped capability: %s",
            [
                134758285
            ]
        ],
        "135088660": [
            "/init",
            [
                134758285
            ]
        ],
        "135088666": [
            "'%s' is not a regular file",
            [
                134889481,
                134758285
            ]
        ],
        "135088693": [
            "root filesystem is not ramfs/tmpfs",
            [
                134758285
            ]
        ],
        "135088728": [
            "error moving ",
            [
                134758285
            ]
        ],
        "135088746": [
            "%s busy - remounted read-only",
            [
                134759394
            ]
        ],
        "135088776": [
            "can't remount %s read-only",
            [
                134759394
            ]
        ],
        "135088803": [
            "fldnrat:cvi",
            [
                134759394
            ]
        ],
        "135088815": [
            "can't unmount %s",
            [
                134759394
            ]
        ],
        "135088832": [
            " LABEL=\"%s\"",
            [
                134760033
            ]
        ],
        "135088844": [
            " UUID=\"%s\"",
            [
                134760033
            ]
        ],
        "135088859": [
            "UUID=",
            [
                134760574
            ]
        ],
        "135088865": [
            "LABEL=",
            [
                134760574
            ]
        ],
        "135088872": [
            "EXFAT   ",
            [
                134760806
            ]
        ],
        "135088881": [
            "MSWIN",
            [
                134761344
            ]
        ],
        "135088887": [
            "FAT32   ",
            [
                134761344
            ]
        ],
        "135088896": [
            "FAT16   ",
            [
                134761344
            ]
        ],
        "135088905": [
            "MSDOS",
            [
                134761344
            ]
        ],
        "135088911": [
            "FAT12   ",
            [
                134761344
            ]
        ],
        "135088920": [
            "NO NAME    ",
            [
                134761344
            ]
        ],
        "135088932": [
            "%02X%02X-%02X%02X",
            [
                134762570
            ]
        ],
        "135088950": [
            "%02X%02X%02X%02X%02X%02X%02X%02X",
            [
                134762570
            ]
        ],
        "135088983": [
            "%s %u/%u%7llu %s %s\n",
            [
                134763254
            ]
        ],
        "135089004": [
            "'%s' is bigger than ar can ",
            [
                134763327
            ]
        ],
        "135089031": [
            "handle",
            [
                134617090
            ]
        ],
        "135089038": [
            "%-16.16s%-12lu%-6u%-6u%-8o%-10llu`\n",
            [
                134763327
            ]
        ],
        "135089074": [
            "!<arch>\n",
            [
                134763561
            ]
        ],
        "135089083": [
            "%.15s/",
            [
                134763561
            ]
        ],
        "135089090": [
            "^vocptxr",
            [
                134763561
            ]
        ],
        "135089099": [
            "-1:p:t:x:r",
            []
        ],
        "135089114": [
            "%s: unknown suffix - ignored",
            [
                134764284
            ]
        ],
        "135089143": [
            "compressed data not read from terminal, use -f to force it",
            [
                134764284
            ]
        ],
        "135089202": [
            "%s: %u%% - replaced with ",
            [
                134764284
            ]
        ],
        "135089227": [
            "%.*s\n",
            [
                134663695
            ]
        ],
        "135089233": [
            "cfkvqdtn",
            [
                134764921
            ]
        ],
        "135089242": [
            "cfkvqdt",
            [
                134765058,
                134765141,
                134764991
            ]
        ],
        "135089262": [
            "stdout",
            [
                134764921
            ]
        ],
        "135089270": [
            "cto-stdout",
            []
        ],
        "135089282": [
            "cforce",
            []
        ],
        "135089290": [
            "ftest",
            []
        ],
        "135089297": [
            "tno-name",
            []
        ],
        "135089309": [
            "extract",
            [
                134765223
            ]
        ],
        "135089318": [
            "ilist",
            []
        ],
        "135089325": [
            "towner",
            []
        ],
        "135089333": [
            "Rverbose",
            []
        ],
        "135089343": [
            "vquiet",
            []
        ],
        "135089352": [
            "to-stdout",
            []
        ],
        "135089365": [
            "it0uvdmLF:R:",
            [
                134765223
            ]
        ],
        "135089378": [
            "%llu blocks\n",
            [
                134765223
            ]
        ],
        "135089391": [
            "cfkvqdtn123456789",
            [
                134770860
            ]
        ],
        "135089463": [
            "\u0007\u0007\b\b\t\t\n\n\u000b\u000b",
            []
        ],
        "135089506": [
            "%s.out",
            [
                134771168
            ]
        ],
        "135089513": [
            "%s.lzo",
            [
                134771168
            ]
        ],
        "135089520": [
            "this file is a split lzop file",
            [
                134771363
            ]
        ],
        "135089551": [
            "corrupted data",
            [
                134771363,
                134787972,
                134795024,
                134787251,
                134788732
            ]
        ],
        "135089566": [
            "checksum error",
            [
                134771363
            ]
        ],
        "135089581": [
            "bad magic number",
            [
                134771904
            ]
        ],
        "135089598": [
            "header_error %d",
            [
                134771904
            ]
        ],
        "135089614": [
            "compression",
            [
                134773827
            ]
        ],
        "135089626": [
            "optimization",
            [
                134773827
            ]
        ],
        "135089639": [
            "high compression not compiled in",
            [
                134774380
            ]
        ],
        "135089672": [
            "cfUvqdt123456789CFk",
            [
                134774665
            ]
        ],
        "135089701": [
            "can't stat tar file",
            [
                134774879
            ]
        ],
        "135089721": [
            "error exit delayed from previous errors",
            [
                134774879
            ]
        ],
        "135089761": [
            "%0*llo",
            [
                134775004
            ]
        ],
        "135089768": [
            "ustar  ",
            [
                134775066
            ]
        ],
        "135089776": [
            "././@Long",
            [
                134775172
            ]
        ],
        "135089790": [
            "%s: unknown file type",
            [
                134775381
            ]
        ],
        "135089812": [
            "%s: socket ignored",
            [
                134776220
            ]
        ],
        "135089831": [
            "%s: file is the archive; skipping",
            [
                134776220
            ]
        ],
        "135089865": [
            "--version",
            [
                134776706,
                134885126
            ]
        ],
        "135089875": [
            "tar (busybox) 1.29.2",
            [
                134776706
            ]
        ],
        "135089896": [
            "TAR_FILETYPE=f",
            [
                134776706
            ]
        ],
        "135089911": [
            "empty archive",
            [
                134776706
            ]
        ],
        "135089925": [
            "%s: not found in archive",
            [
                134776706
            ]
        ],
        "135089950": [
            "^txC:f:OopvkchT:*X:*",
            [
                134776706
            ]
        ],
        "135089973": [
            "tt:vv:",
            []
        ],
        "135089980": [
            "::c:t:x:c--tx:t--cx:x--ct:",
            []
        ],
        "135090015": [
            "textract",
            []
        ],
        "135090025": [
            "xdirectory",
            []
        ],
        "135090037": [
            "Cfile",
            []
        ],
        "135090044": [
            "fto-stdout",
            []
        ],
        "135090056": [
            "Ono-same-owner",
            []
        ],
        "135090072": [
            "osame-permissions",
            []
        ],
        "135090091": [
            "pverbose",
            []
        ],
        "135090101": [
            "vkeep-old",
            []
        ],
        "135090112": [
            "kcreate",
            []
        ],
        "135090121": [
            "cdereference",
            []
        ],
        "135090135": [
            "hfiles-from",
            []
        ],
        "135090148": [
            "Texclude-from",
            []
        ],
        "135090163": [
            "Xstrip-components",
            []
        ],
        "135090183": [
            "no-recursion",
            []
        ],
        "135090198": [
            "to-command",
            []
        ],
        "135090211": [
            "numeric-owner",
            []
        ],
        "135090227": [
            "no-same-permissions",
            []
        ],
        "135090249": [
            "overwrite",
            []
        ],
        "135090261": [
            "exclude",
            []
        ],
        "135090272": [
            "can't read standard input",
            [
                134777631
            ]
        ],
        "135090298": [
            " Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----",
            [
                134777672
            ]
        ],
        "135090424": [
            "  Length      Date    Time    Name\n---------  ---------- -----   ----",
            [
                134777672
            ]
        ],
        "135090494": [
            "-d:lnopqxjv",
            [
                134777672
            ]
        ],
        "135090506": [
            "can't open %s[.zip]",
            [
                134777672
            ]
        ],
        "135090526": [
            "Archive:  %s\n",
            [
                134777672
            ]
        ],
        "135090540": [
            "invalid zip magic %08X",
            [
                134777672
            ]
        ],
        "135090563": [
            "8 (streaming)",
            [
                134777672
            ]
        ],
        "135090577": [
            "zip flag %s is not supported",
            [
                134777672
            ]
        ],
        "135090606": [
            "1 (encryption)",
            [
                134777672
            ]
        ],
        "135090621": [
            "bad archive",
            [
                134777672
            ]
        ],
        "135090633": [
            "%02u-%02u-%04u %02u:%02u",
            [
                134777672
            ]
        ],
        "135090658": [
            "%9u  %s   %s\n",
            [
                134777672
            ]
        ],
        "135090676": [
            "Stored",
            [
                134777672
            ]
        ],
        "135090683": [
            "Defl:N",
            [
                134777672
            ]
        ],
        "135090690": [
            "%8u  %s%9u%4u%% %s %08x  %s\n",
            [
                134777672
            ]
        ],
        "135090719": [
            "   creating: %s\n",
            [
                134777672
            ]
        ],
        "135090736": [
            "'%s' exists but is not a %s",
            [
                134777672
            ]
        ],
        "135090764": [
            "replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: ",
            [
                134777672
            ]
        ],
        "135090815": [
            "  inflating: %s\n",
            [
                134777672
            ]
        ],
        "135090832": [
            "compressed symlink is not supported",
            [
                134777672
            ]
        ],
        "135090868": [
            "inflate error",
            [
                134777672
            ]
        ],
        "135090882": [
            "crc error",
            [
                134777672,
                134787972
            ]
        ],
        "135090892": [
            "unsupported method %u",
            [
                134777672
            ]
        ],
        "135090914": [
            "new name: ",
            [
                134777672
            ]
        ],
        "135090925": [
            "error: invalid response [%c]\n",
            [
                134777672
            ]
        ],
        "135090955": [
            " --------%21s-------\n%9lu%21s%u files\n",
            [
                134777672
            ]
        ],
        "135090994": [
            "--------          ------- ----%28s----\n%8lu%17lu%4u%%%28s%u files\n",
            [
                134777672
            ]
        ],
        "135091076": [
            "can't remove old file %s",
            [
                134777672,
                134780178
            ]
        ],
        "135091101": [
            "can't stat old file",
            [
                134780178
            ]
        ],
        "135091121": [
            "%s not created: newer or same age file exists",
            [
                134780178
            ]
        ],
        "135091167": [
            "can't make dir %s",
            [
                134780178
            ]
        ],
        "135091185": [
            "unrecognized file type",
            [
                134780178
            ]
        ],
        "135091208": [
            "TAR_%s=%lo",
            [
                134780933
            ]
        ],
        "135091219": [
            "TAR_%s=%s",
            [
                134780933
            ]
        ],
        "135091229": [
            "REALNAME",
            [
                134780933
            ]
        ],
        "135091238": [
            "TAR_%s=%llu",
            [
                134780933
            ]
        ],
        "135091254": [
            "'%s' returned status %d",
            [
                134780933
            ]
        ],
        "135091278": [
            "'%s' terminated by signal %d",
            [
                134907517,
                134780933
            ]
        ],
        "135091307": [
            "bunzip",
            [
                134783481
            ]
        ],
        "135091313": [
            " error %d",
            [
                134636928
            ]
        ],
        "135091323": [
            "CRC error",
            [
                134783481
            ]
        ],
        "135091333": [
            "unexpected end of file",
            [
                134784994
            ]
        ],
        "135091356": [
            "incorrect length",
            [
                134787972
            ]
        ],
        "135091408": [
            "\u0007\u0007\b\b\t\t\n\n\u000b\u000b",
            []
        ],
        "135091453": [
            "unexpected EOF",
            [
                134788548
            ]
        ],
        "135091468": [
            "bad lzma header",
            [
                134788732
            ]
        ],
        "135091493": [
            "07070",
            [
                134797560
            ]
        ],
        "135091499": [
            "unsupported cpio format, use newc or crc",
            [
                134797560
            ]
        ],
        "135091540": [
            "%8x%8x%8x%8x%8x%8x%8x%*16c%8x%8x%8x",
            [
                134797560
            ]
        ],
        "135091576": [
            "damaged cpio file",
            [
                134797560
            ]
        ],
        "135091594": [
            "corrupted octal value in tar header",
            [
                134798408
            ]
        ],
        "135091630": [
            "ustar",
            [
                134798509
            ]
        ],
        "135091636": [
            "invalid tar magic",
            [
                134798509
            ]
        ],
        "135091654": [
            "invalid tar header checksum",
            [
                134798509
            ]
        ],
        "135091682": [
            "malformed extended header, skipped",
            [
                134798509
            ]
        ],
        "135091721": [
            "path=",
            [
                134798509
            ]
        ],
        "135091727": [
            "warning: skipping header '%c'",
            [
                134798509
            ]
        ],
        "135091757": [
            "unknown typeflag: 0x%x",
            [
                134798509
            ]
        ],
        "135091780": [
            "%s %u/%u %9llu %4u-%02u-%02u %02u:%02u:%02u %s",
            [
                134799981
            ]
        ],
        "135091827": [
            " -> %s",
            [
                134799981
            ]
        ],
        "135091834": [
            "invalid magic",
            [
                134803027
            ]
        ],
        "135091848": [
            "buffer %u too small",
            [
                134803100
            ]
        ],
        "135091868": [
            "seek failure",
            [
                134803257
            ]
        ],
        "135091881": [
            "!<arch>",
            [
                134803348
            ]
        ],
        "135091889": [
            "invalid ar magic",
            [
                134803348
            ]
        ],
        "135091911": [
            "removing leading '%.*s' from member names",
            [
                134803423
            ]
        ],
        "135091953": [
            "%c%s%c%s",
            [
                134803524
            ]
        ],
        "135091966": [
            "can't create %slink '%s' to '%s'",
            [
                134913143,
                134803524,
                134803630,
                134820135
            ]
        ],
        "135092004": [
            "TRAILER!!!",
            [
                134797560
            ]
        ],
        "135092015": [
            "invalid ar header",
            [
                134803835,
                134803806
            ]
        ],
        "135092033": [
            "long filenames not supported",
            [
                134803835
            ]
        ],
        "135092065": [
            "VT_DISALLOCATE",
            [
                134805764,
                134804286
            ]
        ],
        "135092080": [
            "bkeymap",
            [
                134804356
            ]
        ],
        "135092101": [
            "ioctl(KDGKBENT{%d,%d}) failed",
            [
                134804356
            ]
        ],
        "135092136": [
            "error reading input font",
            [
                134804510
            ]
        ],
        "135092161": [
            "unsupported psf file mode",
            [
                134804510
            ]
        ],
        "135092187": [
            "unsupported psf file version",
            [
                134804510
            ]
        ],
        "135092216": [
            "input file: bad length or unsupported font type",
            [
                134804510
            ]
        ],
        "135092264": [
            "input file: ",
            [
                134804510
            ]
        ],
        "135092276": [
            "bad length",
            [
                134777672
            ]
        ],
        "135092287": [
            "bad character size %dx%d",
            [
                134804510
            ]
        ],
        "135092312": [
            "KDFONTOP",
            [
                134804510
            ]
        ],
        "135092321": [
            "unicode sequences not implemented",
            [
                134804510
            ]
        ],
        "135092355": [
            "illegal UTF-8 ",
            [
                134804510
            ]
        ],
        "135092369": [
            "character",
            [
                134618213
            ]
        ],
        "135092379": [
            "PIO_UNIMAPCLR",
            [
                134804510
            ]
        ],
        "135092393": [
            "PIO_UNIMAP",
            [
                134804510
            ]
        ],
        "135092404": [
            "bkeymap",
            [
                134805529
            ]
        ],
        "135092412": [
            "not a valid binary keymap",
            [
                134805529
            ]
        ],
        "135092438": [
            "+c:wslfv",
            [
                134805764
            ]
        ],
        "135092447": [
            "can't find open VT",
            [
                134805764
            ]
        ],
        "135092466": [
            "/dev/tty%d",
            [
                134805764
            ]
        ],
        "135092477": [
            "VT_GETSTATE",
            [
                134805764
            ]
        ],
        "135092489": [
            "\u001bc\u001b(B\u001b[m\u001b[J\u001b[?25h",
            [
                134806162
            ]
        ],
        "135092517": [
            "\u001b7\u001b[r\u001b[999;999H\u001b[6n",
            [
                134806230
            ]
        ],
        "135092537": [
            "\u001b[%hu;%huR",
            [
                134806230
            ]
        ],
        "135092551": [
            "COLUMNS=%d;LINES=%d;export COLUMNS LINES;\n",
            [
                134806230
            ]
        ],
        "135092594": [
            "TIOCCONS",
            [
                134806442
            ]
        ],
        "135092609": [
            "can't set SCANCODE %x to KEYCODE %d",
            [
                134806515
            ]
        ],
        "135092645": [
            "/dev/tty%u",
            [
                134806649
            ]
        ],
        "135092656": [
            "TIOCLINUX",
            [
                134806649
            ]
        ],
        "135092666": [
            "^etvAnbu",
            [
                134806875
            ]
        ],
        "135092680": [
            "%6u  ",
            [
                134806875
            ]
        ],
        "135092686": [
            "invalid mode '%s'",
            [
                134902707,
                134825037,
                134807351
            ]
        ],
        "135092704": [
            "mode of '%s' changed to %04o (%s)\n",
            [
                134807351
            ]
        ],
        "135092739": [
            "-Rvcf",
            [
                134807521
            ]
        ],
        "135092745": [
            "^Rvcf",
            [
                134807521
            ]
        ],
        "135092754": [
            "changed ownership of '%s' to ",
            [
                134807663
            ]
        ],
        "135092783": [
            "%u:%u\n",
            [
                134753221
            ]
        ],
        "135092790": [
            "^RhvcfLHP",
            [
                134807786
            ]
        ],
        "135092803": [
            "%u %llu %s\n",
            [
                134807989
            ]
        ],
        "135092815": [
            "%u %llu\n",
            [
                134807989
            ]
        ],
        "135092824": [
            "^pdRfilsLHarPvuT",
            [
                134808265
            ]
        ],
        "135092841": [
            "-2:l--s:s--l:Pd:rRd:Rd:apdR",
            []
        ],
        "135092869": [
            "'%s' is a directory",
            [
                134820200,
                134808265,
                134948617
            ]
        ],
        "135092889": [
            "too many arguments",
            [
                134829800,
                134808265
            ]
        ],
        "135092908": [
            "^b:c:f:d:sn",
            [
                134808604
            ]
        ],
        "135092920": [
            "b--bcf:c--bcf:f--bcf",
            []
        ],
        "135092941": [
            "expected a list of bytes, characters, or fields",
            [
                134808604
            ]
        ],
        "135092989": [
            "the delimiter must be a single character",
            [
                134808604
            ]
        ],
        "135093030": [
            "suppressing non-delimited lines makes sense%s",
            [
                134808604
            ]
        ],
        "135093076": [
            "a delimiter may be specified%s",
            [
                134808604
            ]
        ],
        "135093107": [
            "missing list of positions",
            [
                134808604
            ]
        ],
        "135093133": [
            " only when operating on fields",
            [
                134808604
            ]
        ],
        "135093164": [
            "%a %b %e %H:%M:%S %Z %Y",
            [
                134809595
            ]
        ],
        "135093188": [
            "%Y.%m.%d-%H:%M:%S",
            [
                134809595
            ]
        ],
        "135093206": [
            "TZ=UTC0",
            [
                134809595,
                134949623
            ]
        ],
        "135093214": [
            "0123456789",
            [
                134926674,
                134809595,
                134927098
            ]
        ],
        "135093225": [
            "can't set ",
            [
                134809595
            ]
        ],
        "135093240": [
            "%Y-%m-%dT%H:%M:%S",
            [
                134809595
            ]
        ],
        "135093258": [
            "%a, %d %b %Y %H:%M:%S ",
            [
                134809595
            ]
        ],
        "135093284": [
            "^Rs:ud:r:I::D:",
            [
                134809595
            ]
        ],
        "135093299": [
            "d--s:s--d:R--I:I--R",
            []
        ],
        "135093324": [
            "hours",
            []
        ],
        "135093330": [
            "minutes",
            []
        ],
        "135093338": [
            "seconds",
            []
        ],
        "135093347": [
            "rfc-822",
            [
                134809595
            ]
        ],
        "135093356": [
            "Rrfc-2822",
            []
        ],
        "135093379": [
            "udate",
            []
        ],
        "135093386": [
            "dreference",
            []
        ],
        "135093400": [
            "writing '%s'",
            [
                134810415
            ]
        ],
        "135093413": [
            "%llu+%llu records in\n%llu+%llu records out\n",
            [
                134810506
            ]
        ],
        "135093462": [
            "iflag",
            [
                134810574
            ]
        ],
        "135093468": [
            "can't swab %lu byte buffer",
            [
                134810574
            ]
        ],
        "135093500": [
            "noxfer",
            []
        ],
        "135093508": [
            "skip_bytes",
            [
                134810574
            ]
        ],
        "135093519": [
            "fullblock",
            []
        ],
        "135093530": [
            "notrunc",
            [
                134810574
            ]
        ],
        "135093543": [
            "noerror",
            []
        ],
        "135093551": [
            "fsync",
            []
        ],
        "135093566": [
            "count",
            []
        ],
        "135093588": [
            "status",
            []
        ],
        "135093608": [
            "iflag",
            []
        ],
        "135093615": [
            "     Size",
            [
                134812027
            ]
        ],
        "135093625": [
            "Capacity",
            [
                134812027
            ]
        ],
        "135093639": [
            "Type       ",
            [
                134812027
            ]
        ],
        "135093651": [
            "POSIXLY_CORRECT",
            [
                134812027,
                134813687
            ]
        ],
        "135093667": [
            "%s-blocks",
            [
                134812027
            ]
        ],
        "135093677": [
            "Filesystem           %s%-15sUsed Available %s Mounted on\n",
            [
                134812027
            ]
        ],
        "135093735": [
            "%s: can't find mount point",
            [
                134812027
            ]
        ],
        "135093762": [
            "rootfs",
            [
                134812027,
                134919029
            ]
        ],
        "135093770": [
            "%-20s",
            [
                134812027
            ]
        ],
        "135093776": [
            "\n%-30s",
            [
                134812027
            ]
        ],
        "135093783": [
            " %9s ",
            [
                134812027
            ]
        ],
        "135093789": [
            "%9s %3u%% %s\n",
            [
                134812027
            ]
        ],
        "135093803": [
            "^kPThm",
            [
                134812027
            ]
        ],
        "135093810": [
            "k-m:m-k",
            []
        ],
        "135093822": [
            "u--d:d--u",
            []
        ],
        "135093832": [
            "%sXXXXXX",
            [
                134812825,
                134885126,
                134878535
            ]
        ],
        "135093841": [
            "^aHkLsxd:+lchm",
            [
                134813687
            ]
        ],
        "135093856": [
            "h-km:k-hm:m-hk:H-L:L-H:s-d:d-s",
            []
        ],
        "135093887": [
            "ignore-environment",
            [
                134814290
            ]
        ],
        "135093907": [
            "iunset",
            []
        ],
        "135093917": [
            "+iu:*",
            [
                134814290
            ]
        ],
        "135093923": [
            "putenv",
            [
                134814290
            ]
        ],
        "135093930": [
            "non-numeric argument",
            [
                134814679
            ]
        ],
        "135093951": [
            "division by zero",
            [
                134814679
            ]
        ],
        "135093968": [
            "warning: '%s': using '^' as the first character\nof a basic regular expression is not portable; it is ignored",
            [
                134814961
            ]
        ],
        "135094086": [
            "too few arguments",
            [
                134816692
            ]
        ],
        "135094104": [
            "%lld\n",
            [
                134816692
            ]
        ],
        "135094110": [
            "quote",
            [
                134816079
            ]
        ],
        "135094116": [
            "length",
            []
        ],
        "135094123": [
            "match",
            []
        ],
        "135094129": [
            "index",
            []
        ],
        "135094135": [
            "substr",
            []
        ],
        "135094143": [
            "%llu:",
            [
                134817070
            ]
        ],
        "135094163": [
            "==> %s <==\n",
            [
                134841389,
                134817855
            ]
        ],
        "135094175": [
            "count is too big: %lu",
            [
                134817855
            ]
        ],
        "135094197": [
            "n:c:qv",
            [
                134817855
            ]
        ],
        "135094204": [
            "unknown ID %u",
            [
                134818918
            ]
        ],
        "135094218": [
            " groups=",
            [
                134818966
            ]
        ],
        "135094227": [
            " gid=",
            [
                134818966
            ]
        ],
        "135094240": [
            " egid=",
            [
                134818966
            ]
        ],
        "135094247": [
            "can't get groups",
            [
                134818966
            ]
        ],
        "135094264": [
            "^rnugG",
            [
                134818966
            ]
        ],
        "135094271": [
            "?1:u--g:g--u:G--u:u--G:g--G:G--g:r?ugG:n?ugG",
            []
        ],
        "135094316": [
            "^cvbDdpsg:m:o:t:",
            [
                134819445
            ]
        ],
        "135094333": [
            "t--d:d--t:s--d:d--s",
            []
        ],
        "135094353": [
            "strip",
            [
                134819445
            ]
        ],
        "135094362": [
            "permissions",
            [
                134819445,
                134913143
            ]
        ],
        "135094374": [
            "can't change %s of %s",
            [
                134819445
            ]
        ],
        "135094396": [
            "ownership",
            [
                134819445,
                134913143
            ]
        ],
        "135094406": [
            "verbose",
            [
                134819445
            ]
        ],
        "135094415": [
            "vdirectory",
            []
        ],
        "135094427": [
            "dpreserve-timestamps",
            []
        ],
        "135094449": [
            "pstrip",
            []
        ],
        "135094457": [
            "sgroup",
            []
        ],
        "135094465": [
            "gmode",
            []
        ],
        "135094472": [
            "mowner",
            []
        ],
        "135094480": [
            "otarget-directory",
            []
        ],
        "135094506": [
            "-T accepts 2 args max",
            [
                134820200
            ]
        ],
        "135094528": [
            "'%s' -> '%s'\n",
            [
                134820200,
                134825632,
                134913143
            ]
        ],
        "135094542": [
            "^sfnbS:vT",
            [
                134820200
            ]
        ],
        "135094555": [
            "getlogin",
            [
                134820720
            ]
        ],
        "135094582": [
            "##%\"%##",
            []
        ],
        "135094590": [
            "%$%#%% ",
            []
        ],
        "135094615": [
            "^Cadi1lgnsxAkFpRQctuSXrvLHhT:w:",
            [
                134823633
            ]
        ],
        "135094647": [
            "nl:gl:",
            []
        ],
        "135094654": [
            "l:t-S:S-t:H-L:L-H:C-xl:x-Cl:l-xC:C-1:1-C:x-1:1-x:c-u:u-c:w+",
            []
        ],
        "135094714": [
            "%7llu ",
            [
                134821777
            ]
        ],
        "135094721": [
            "%6llu ",
            [
                134821777
            ]
        ],
        "135094728": [
            "%-10s ",
            [
                134821777
            ]
        ],
        "135094735": [
            "%4lu ",
            [
                134821777
            ]
        ],
        "135094741": [
            "%-8u ",
            [
                134821777
            ]
        ],
        "135094746": [
            "%-8u ",
            [
                134821777
            ]
        ],
        "135094752": [
            "%-8.8s ",
            [
                134821777
            ]
        ],
        "135094759": [
            "%-8.8s ",
            [
                134821777
            ]
        ],
        "135094767": [
            "%4u, %3u ",
            [
                134821777
            ]
        ],
        "135094782": [
            "%9llu ",
            [
                134821777
            ]
        ],
        "135094789": [
            "%Y-%m-%d %H:%M:%S %z",
            [
                134821777
            ]
        ],
        "135094810": [
            "%.12s ",
            [
                134821777
            ]
        ],
        "135094817": [
            "%.7s%6s",
            [
                134821777
            ]
        ],
        "135094825": [
            "\u001b[%u;%um",
            [
                134821777
            ]
        ],
        "135094839": [
            "total ",
            [
                134823113
            ]
        ],
        "135094845": [
            "%llu\n",
            [
                134552627,
                134713399
            ]
        ],
        "135094851": [
            "LS_COLORS",
            [
                134823633
            ]
        ],
        "135094861": [
            "full-time",
            [
                134823633
            ]
        ],
        "135094873": [
            "group-directories-first",
            []
        ],
        "135094899": [
            "color",
            []
        ],
        "135094908": [
            "always",
            [
                134823633
            ]
        ],
        "135094919": [
            "force",
            []
        ],
        "135094934": [
            "if-tty",
            []
        ],
        "135094942": [
            "bad -a%u",
            [
                134824184
            ]
        ],
        "135094951": [
            "^scwbta:+",
            [
                134824562
            ]
        ],
        "135094961": [
            "s?c:w?c",
            []
        ],
        "135094969": [
            "^scwbt",
            [
                134824562
            ]
        ],
        "135094976": [
            "s?c:w?c",
            []
        ],
        "135094984": [
            "%s: OK\n",
            [
                134824562
            ]
        ],
        "135094992": [
            "%s: FAILED\n",
            [
                134824562
            ]
        ],
        "135095004": [
            "WARNING: %d of %d computed checksums did NOT match",
            [
                134824562
            ]
        ],
        "135095055": [
            "%s: no checksum lines found",
            [
                134824562
            ]
        ],
        "135095083": [
            "%s  %s\n",
            [
                134824562
            ]
        ],
        "135095097": [
            "mparents",
            []
        ],
        "135095107": [
            "pverbose",
            []
        ],
        "135095132": [
            "TMPDIR",
            [
                134825446
            ]
        ],
        "135095144": [
            "tmp.XXXXXX",
            [
                134825446
            ]
        ],
        "135095155": [
            "^dqtp:u",
            [
                134825446
            ]
        ],
        "135095166": [
            "interactive",
            [
                134825632
            ]
        ],
        "135095179": [
            "iforce",
            []
        ],
        "135095187": [
            "fno-clobber",
            []
        ],
        "135095200": [
            "nverbose",
            []
        ],
        "135095212": [
            "^finv",
            [
                134825632
            ]
        ],
        "135095218": [
            "-2:f-in:i-fn:n-fi",
            []
        ],
        "135095236": [
            "mv: overwrite '%s'? ",
            [
                134825632
            ]
        ],
        "135095257": [
            "can't rename '%s'",
            [
                134825632
            ]
        ],
        "135095275": [
            "can't remove '%s'",
            [
                134825632,
                134948617
            ]
        ],
        "135095293": [
            "can't overwrite %sdirectory with %sdirectory",
            [
                134825632
            ]
        ],
        "135095338": [
            "setpriority(%d)",
            [
                134826138,
                134851051
            ]
        ],
        "135095354": [
            "pw:+s:v:+i:+b:",
            [
                134826292
            ]
        ],
        "135095369": [
            "body-numbering",
            [
                134826292
            ]
        ],
        "135095385": [
            "bline-increment",
            []
        ],
        "135095402": [
            "ino-renumber",
            []
        ],
        "135095416": [
            "pnumber-separator",
            []
        ],
        "135095435": [
            "sstarting-line-number",
            []
        ],
        "135095458": [
            "vnumber-width",
            []
        ],
        "135095475": [
            "nohup.out",
            [
                134826485
            ]
        ],
        "135095485": [
            "appending output to %s",
            [
                134826485
            ]
        ],
        "135095565": [
            "integral",
            [
                134828004
            ]
        ],
        "135095574": [
            "invalid type string '%s'; %u-byte %s type is not supported",
            [
                134828004
            ]
        ],
        "135095633": [
            "floating point",
            [
                134828004
            ]
        ],
        "135095648": [
            " %%%d.%de",
            [
                134828004
            ]
        ],
        "135095658": [
            " %%%d.%dLe",
            [
                134828004
            ]
        ],
        "135095669": [
            "invalid character '%c' in type string '%s'",
            [
                134828004
            ]
        ],
        "135095716": [
            "read error",
            [
                134538016,
                134625028,
                134620197,
                134613382,
                134615047,
                134542701,
                134841389,
                134785167,
                134795024,
                134570869,
                134846456,
                134848569,
                134720860
            ]
        ],
        "135095727": [
            "can't skip past end of combined input",
            [
                134829033
            ]
        ],
        "135095769": [
            "%0nllxc",
            [
                134829800
            ]
        ],
        "135095777": [
            "A:N:abcdfhij:lot:*vxsS:w:+:",
            [
                134829800
            ]
        ],
        "135095805": [
            "bad output address radix '%c' (must be [doxn])",
            [
                134829800
            ]
        ],
        "135095873": [
            "invalid second argument '%s'",
            [
                134829800
            ]
        ],
        "135095902": [
            "the last two arguments must be offsets",
            [
                134829800
            ]
        ],
        "135095941": [
            "SKIP + SIZE is too large",
            [
                134829800
            ]
        ],
        "135095966": [
            "warning: invalid width %u; using %d instead",
            [
                134829800
            ]
        ],
        "135096011": [
            "ulsohstxetxeotenqackbel bs ht nl vt ff cr so sidledc1dc2dc3dc4naksynetbcan emsubesc fs gs rs us sp",
            []
        ],
        "135096137": [
            "skip-bytes",
            [
                134829800
            ]
        ],
        "135096149": [
            "jaddress-radix",
            []
        ],
        "135096165": [
            "Aread-bytes",
            []
        ],
        "135096178": [
            "Nformat",
            []
        ],
        "135096187": [
            "toutput-duplicates",
            []
        ],
        "135096207": [
            "vstrings",
            []
        ],
        "135096217": [
            "Swidth",
            []
        ],
        "135096225": [
            "wtraditional",
            []
        ],
        "135096335": [
            " #&)+d:s",
            []
        ],
        "135096344": [
            "-d '' is not supported",
            [
                134831819
            ]
        ],
        "135096370": [
            "usage: printf FORMAT [ARGUMENT...]",
            [
                134833116
            ]
        ],
        "135096414": [
            "invalid format",
            [
                134824562
            ]
        ],
        "135096429": [
            "diouxXfeEgGcs",
            [
                134833116
            ]
        ],
        "135096443": [
            "^fnvsq",
            [
                134834276
            ]
        ],
        "135096453": [
            "^fiRrv",
            [
                134834468
            ]
        ],
        "135096460": [
            "f-i:i-f",
            []
        ],
        "135096468": [
            "can't remove '.' or '..'",
            [
                134834468
            ]
        ],
        "135096493": [
            "parents",
            [
                134834624
            ]
        ],
        "135096502": [
            "pignore-fail-on-non-empty",
            []
        ],
        "135096530": [
            "verbose",
            []
        ],
        "135096541": [
            "rmdir: removing directory, ",
            [
                134834624
            ]
        ],
        "135096568": [
            "'%s'\n",
            [
                134576621
            ]
        ],
        "135096579": [
            "%s%0*.*f",
            [
                134834788
            ]
        ],
        "135096588": [
            "fuzn:+vx",
            [
                134835234
            ]
        ],
        "135096597": [
            "/dev/zero",
            [
                134835234
            ]
        ],
        "135096607": [
            "0123456789.",
            [
                134835583
            ]
        ],
        "135096619": [
            "bad field specification",
            [
                134835985
            ]
        ],
        "135096643": [
            "unknown sort type",
            [
                134836537,
                134837317
            ]
        ],
        "135096664": [
            "bad -t parameter",
            [
                134837317
            ]
        ],
        "135096681": [
            "unknown key option",
            [
                134837317
            ]
        ],
        "135096700": [
            "Check line %u\n",
            [
                134837317
            ]
        ],
        "135096720": [
            "^ngMucszbrdfimS:T:o:k:*t:",
            [
                134837317
            ]
        ],
        "135096746": [
            "o--o:t--t",
            []
        ],
        "135096756": [
            "%lx:%lx:%lx:%lx",
            [
                134838856
            ]
        ],
        "135096775": [
            "undef",
            [
                134839150
            ]
        ],
        "135096784": [
            "%s: no size information for this device",
            []
        ],
        "135096824": [
            "%lu %lu\n",
            [
                134839393
            ]
        ],
        "135096833": [
            "ispeed %lu baud; ospeed %lu baud;",
            []
        ],
        "135096876": [
            "speed %lu baud;",
            []
        ],
        "135096892": [
            "rows %u; columns %u;",
            [
                134839291
            ]
        ],
        "135096913": [
            "%u %u\n",
            [
                134839291
            ]
        ],
        "135096920": [
            "line = %u;\n",
            [
                134839472
            ]
        ],
        "135096932": [
            "<undef>",
            [
                134839472
            ]
        ],
        "135096940": [
            "%s = %s;",
            [
                134839472
            ]
        ],
        "135096949": [
            "min = %u; time = %u;",
            [
                134839472
            ]
        ],
        "135096970": [
            "%lx:%lx:%lx:%lx%n",
            [
                134839835
            ]
        ],
        "135096988": [
            ":%x%n",
            [
                134839835
            ]
        ],
        "135096994": [
            "only one device may be specified",
            [
                134840176
            ]
        ],
        "135097030": [
            "invalid argument '%s'",
            [
                134840176
            ]
        ],
        "135097052": [
            "-a and -g are mutually exclusive",
            [
                134840176
            ]
        ],
        "135097085": [
            "modes may not be set when -a or -g is ",
            [
                134840176
            ]
        ],
        "135097128": [
            "%s: cannot perform all requested operations",
            [
                134840176
            ]
        ],
        "135097187": [
            "columns",
            []
        ],
        "135097200": [
            "speed",
            []
        ],
        "135097206": [
            "ispeed",
            []
        ],
        "135097213": [
            "ospeed",
            []
        ],
        "135097235": [
            "erase",
            []
        ],
        "135097259": [
            "swtch",
            []
        ],
        "135097265": [
            "start",
            []
        ],
        "135097281": [
            "rprnt",
            []
        ],
        "135097287": [
            "werase",
            []
        ],
        "135097294": [
            "lnext",
            []
        ],
        "135097300": [
            "flush",
            []
        ],
        "135097316": [
            "evenp",
            [
                134839472,
                134839095
            ]
        ],
        "135097322": [
            "parity",
            []
        ],
        "135097345": [
            "cooked",
            []
        ],
        "135097356": [
            "pass8",
            []
        ],
        "135097362": [
            "litout",
            []
        ],
        "135097369": [
            "cbreak",
            []
        ],
        "135097384": [
            "decctlq",
            []
        ],
        "135097397": [
            "lcase",
            []
        ],
        "135097403": [
            "LCASE",
            []
        ],
        "135097409": [
            "parenb",
            []
        ],
        "135097416": [
            "parodd",
            []
        ],
        "135097423": [
            "cmspar",
            []
        ],
        "135097446": [
            "hupcl",
            []
        ],
        "135097456": [
            "cstopb",
            []
        ],
        "135097463": [
            "cread",
            []
        ],
        "135097469": [
            "clocal",
            []
        ],
        "135097476": [
            "crtscts",
            []
        ],
        "135097484": [
            "ignbrk",
            []
        ],
        "135097491": [
            "brkint",
            []
        ],
        "135097498": [
            "ignpar",
            []
        ],
        "135097505": [
            "parmrk",
            []
        ],
        "135097512": [
            "inpck",
            []
        ],
        "135097518": [
            "istrip",
            []
        ],
        "135097525": [
            "inlcr",
            []
        ],
        "135097531": [
            "igncr",
            []
        ],
        "135097537": [
            "icrnl",
            []
        ],
        "135097548": [
            "ixoff",
            []
        ],
        "135097554": [
            "tandem",
            []
        ],
        "135097561": [
            "iuclc",
            []
        ],
        "135097567": [
            "ixany",
            []
        ],
        "135097573": [
            "imaxbel",
            []
        ],
        "135097581": [
            "iutf8",
            []
        ],
        "135097587": [
            "opost",
            []
        ],
        "135097593": [
            "olcuc",
            []
        ],
        "135097599": [
            "ocrnl",
            []
        ],
        "135097605": [
            "onlcr",
            []
        ],
        "135097611": [
            "onocr",
            []
        ],
        "135097617": [
            "onlret",
            []
        ],
        "135097624": [
            "ofill",
            []
        ],
        "135097630": [
            "ofdel",
            []
        ],
        "135097709": [
            "icanon",
            []
        ],
        "135097716": [
            "iexten",
            []
        ],
        "135097728": [
            "echoe",
            []
        ],
        "135097734": [
            "crterase",
            []
        ],
        "135097743": [
            "echok",
            []
        ],
        "135097749": [
            "echonl",
            []
        ],
        "135097756": [
            "noflsh",
            []
        ],
        "135097763": [
            "xcase",
            []
        ],
        "135097769": [
            "tostop",
            []
        ],
        "135097776": [
            "echoprt",
            []
        ],
        "135097784": [
            "prterase",
            []
        ],
        "135097793": [
            "echoctl",
            []
        ],
        "135097801": [
            "ctlecho",
            []
        ],
        "135097809": [
            "echoke",
            []
        ],
        "135097816": [
            "crtkill",
            []
        ],
        "135097824": [
            "flusho",
            []
        ],
        "135097832": [
            "appeared",
            [
                134841389
            ]
        ],
        "135097841": [
            "been replaced",
            [
                134841389
            ]
        ],
        "135097855": [
            "no files",
            [
                134841389
            ]
        ],
        "135097864": [
            "%s has %s; following end of new file",
            [
                134841389
            ]
        ],
        "135097901": [
            "%s has become inaccessible",
            [
                134841389
            ]
        ],
        "135097928": [
            "^fc:n:qs:+vF",
            [
                134841389
            ]
        ],
        "135097948": [
            "bad number",
            [
                134843371
            ]
        ],
        "135097959": [
            "argument expected",
            [
                134844038,
                134843534
            ]
        ],
        "135097977": [
            "closing paren expected",
            [
                134844038
            ]
        ],
        "135098000": [
            "missing ]",
            [
                134844968
            ]
        ],
        "135098010": [
            "missing ]]",
            [
                134844968
            ]
        ],
        "135098021": [
            "%s: unknown operand",
            [
                134844968
            ]
        ],
        "135098167": [
            "cr:d:t:fma",
            [
                134845378
            ]
        ],
        "135098178": [
            "no-create",
            [
                134845378
            ]
        ],
        "135098189": [
            "creference",
            []
        ],
        "135098201": [
            "rdate",
            []
        ],
        "135098210": [
            "^+Ccds",
            [
                134846456
            ]
        ],
        "135098220": [
            "STRING2 cannot be empty",
            [
                134846456
            ]
        ],
        "135098244": [
            "alpha:]",
            [
                134845777
            ]
        ],
        "135098252": [
            "alnum:]",
            []
        ],
        "135098260": [
            "digit:]",
            []
        ],
        "135098268": [
            "lower:]",
            []
        ],
        "135098276": [
            "upper:]",
            []
        ],
        "135098284": [
            "space:]",
            []
        ],
        "135098292": [
            "blank:]",
            []
        ],
        "135098300": [
            "punct:]",
            []
        ],
        "135098308": [
            "cntrl:]",
            []
        ],
        "135098316": [
            "xdigit:]",
            []
        ],
        "135098336": [
            "%s: open",
            [
                134846950
            ]
        ],
        "135098345": [
            "%s: truncate",
            [
                134846950
            ]
        ],
        "135098358": [
            "snrvmpioa",
            [
                134847240
            ]
        ],
        "135098368": [
            "GNU/Linux",
            [
                134847240
            ]
        ],
        "135098383": [
            "akernel-name",
            []
        ],
        "135098397": [
            "snodename",
            []
        ],
        "135098408": [
            "nkernel-release",
            []
        ],
        "135098425": [
            "rrelease",
            []
        ],
        "135098435": [
            "rkernel-version",
            []
        ],
        "135098452": [
            "vmachine",
            []
        ],
        "135098462": [
            "mprocessor",
            []
        ],
        "135098474": [
            "phardware-platform",
            []
        ],
        "135098494": [
            "ioperating-system",
            []
        ],
        "135098515": [
            "cduf:+s:+w:+i",
            [
                134847496
            ]
        ],
        "135098529": [
            "%7lu ",
            [
                134847496
            ]
        ],
        "135098540": [
            "short file",
            [
                134847963
            ]
        ],
        "135098558": [
            "begin-base64 ",
            [
                134848269
            ]
        ],
        "135098572": [
            "begin ",
            [
                134848269
            ]
        ],
        "135098579": [
            "no 'begin' ",
            [
                134848269
            ]
        ],
        "135098595": [
            "-base64",
            [
                134848569
            ]
        ],
        "135098603": [
            "\n`\nend\n",
            [
                134848569
            ]
        ],
        "135098611": [
            "\n====\n",
            [
                134848569
            ]
        ],
        "135098618": [
            "begin%s %o %s",
            [
                134848569
            ]
        ],
        "135098635": [
            "-1:?2",
            []
        ],
        "135098646": [
            "lwmcL",
            [
                134848886
            ]
        ],
        "135098664": [
            "USER\t\tTTY\t\tIDLE\tTIME\t\t ",
            [
                134849400
            ]
        ],
        "135098692": [
            "/dev/",
            [
                134849400,
                134909433,
                134950578,
                134852264
            ]
        ],
        "135098698": [
            "%02d:%02d",
            [
                134849400
            ]
        ],
        "135098712": [
            "%-15.*s %-15.*s %-7s %-16.16s %.*s\n",
            [
                134849400
            ]
        ],
        "135098751": [
            "^a:*u:",
            [
                134850351
            ]
        ],
        "135098766": [
            "aumask",
            []
        ],
        "135098774": [
            "ureverse",
            []
        ],
        "135098792": [
            "exit-on-error",
            []
        ],
        "135098809": [
            "/proc/%u/exe",
            [
                134850661
            ]
        ],
        "135098822": [
            "/proc/%u/stat",
            [
                134850661
            ]
        ],
        "135098836": [
            "/proc/%u",
            [
                134850661
            ]
        ],
        "135098845": [
            "^KSbqtma:n:s:u:c:x:p:ovN:R:",
            [
                134851051
            ]
        ],
        "135098873": [
            "K:S:K--S:S--K:m?p:K?xpun:S?xaq-v",
            []
        ],
        "135098906": [
            "open pidfile %s",
            [
                134851051
            ]
        ],
        "135098922": [
            "nothing in /proc - not mounted?",
            [
                134851051
            ]
        ],
        "135098954": [
            "process in pidfile '%s'",
            [
                134851051
            ]
        ],
        "135098978": [
            "process(es) owned by '%s'",
            [
                134851051
            ]
        ],
        "135099004": [
            "internal error, please report",
            [
                134851051
            ]
        ],
        "135099034": [
            "no %s found; none killed\n",
            [
                134851051
            ]
        ],
        "135099060": [
            "warning: killing process %u",
            [
                134851051
            ]
        ],
        "135099088": [
            "stopped %s (pid",
            [
                134851051
            ]
        ],
        "135099104": [
            "%s is already running\n%u\n",
            [
                134851051
            ]
        ],
        "135099136": [
            "Kstart",
            []
        ],
        "135099144": [
            "Sbackground",
            []
        ],
        "135099157": [
            "bquiet",
            []
        ],
        "135099165": [
            "qtest",
            []
        ],
        "135099172": [
            "tmake-pidfile",
            []
        ],
        "135099187": [
            "moknodo",
            []
        ],
        "135099196": [
            "overbose",
            []
        ],
        "135099206": [
            "vnicelevel",
            []
        ],
        "135099218": [
            "Nstartas",
            []
        ],
        "135099228": [
            "aname",
            []
        ],
        "135099235": [
            "nsignal",
            []
        ],
        "135099244": [
            "suser",
            []
        ],
        "135099251": [
            "uchuid",
            []
        ],
        "135099259": [
            "cexec",
            []
        ],
        "135099266": [
            "xpidfile",
            []
        ],
        "135099276": [
            "pretry",
            []
        ],
        "135099292": [
            "/sys/class/block/%s",
            [
                134852264
            ]
        ],
        "135099316": [
            "invalid resume device: %s",
            [
                134852264
            ]
        ],
        "135099342": [
            "/sys/power/resume",
            [
                134852264
            ]
        ],
        "135099360": [
            "%u:%u:%llu",
            [
                134852264
            ]
        ],
        "135099371": [
            "stat %s",
            [
                134852722,
                134857186,
                134857348
            ]
        ],
        "135099379": [
            "setting version on %s",
            [
                134852722
            ]
        ],
        "135099401": [
            "reading flags on %s",
            [
                134852722
            ]
        ],
        "135099421": [
            "setting flags on %s",
            [
                134852722
            ]
        ],
        "135099441": [
            "= is incompatible with - and +",
            [
                134853030
            ]
        ],
        "135099472": [
            "can't set and unset a flag",
            [
                134853030
            ]
        ],
        "135099499": [
            "must use '-v', =, - or +",
            [
                134853030
            ]
        ],
        "135099524": [
            "Indexed_directory",
            [
                134853618
            ]
        ],
        "135099542": [
            "Secure_Deletion",
            []
        ],
        "135099558": [
            "Undelete",
            []
        ],
        "135099567": [
            "Synchronous_Updates",
            []
        ],
        "135099587": [
            "Synchronous_Directory_Updates",
            []
        ],
        "135099617": [
            "Immutable",
            []
        ],
        "135099627": [
            "Append_Only",
            []
        ],
        "135099639": [
            "No_Dump",
            []
        ],
        "135099647": [
            "No_Atime",
            []
        ],
        "135099656": [
            "Compression_Requested",
            []
        ],
        "135099678": [
            "Journaled_Data",
            []
        ],
        "135099693": [
            "No_Tailmerging",
            []
        ],
        "135099708": [
            "Top_of_Directory_Hierarchies",
            []
        ],
        "135099739": [
            "suSDiadAcjtT",
            [
                134853030
            ]
        ],
        "135099756": [
            "from fstab",
            [
                134854602
            ]
        ],
        "135099767": [
            "using filesystem type '%s' %s\n",
            [
                134854602
            ]
        ],
        "135099798": [
            "opts=",
            [
                134855329,
                134854602
            ]
        ],
        "135099804": [
            "from -t",
            [
                134854602
            ]
        ],
        "135099812": [
            "(default)",
            [
                134854602
            ]
        ],
        "135099822": [
            "fsck.%s",
            [
                134854602
            ]
        ],
        "135099830": [
            "[%s (%d) -- %s]",
            [
                134854602
            ]
        ],
        "135099846": [
            "wait: no more children",
            [
                134855033
            ]
        ],
        "135099869": [
            "Warning: %s %s terminated by signal %u\n",
            [
                134855033
            ]
        ],
        "135099909": [
            "Finished with %s (exit status %u)\n",
            [
                134855033
            ]
        ],
        "135099944": [
            "either all or none of the filesystem types passed to -t must be prefixed with 'no' or '!'",
            [
                134855329
            ]
        ],
        "135100034": [
            "FSCK_FORCE_ALL_PARALLEL",
            [
                134855329
            ]
        ],
        "135100058": [
            "FSCK_MAX_INST",
            [
                134855329
            ]
        ],
        "135100072": [
            "fsck (busybox 1.29.2)",
            [
                134855329
            ]
        ],
        "135100094": [
            "FSTAB_FILE",
            [
                134855329
            ]
        ],
        "135100105": [
            "Checking all filesystems",
            [
                134855329
            ]
        ],
        "135100130": [
            "/dev/md",
            [
                134855329
            ]
        ],
        "135100138": [
            "--waiting-- (pass %d)\n",
            [
                134855329
            ]
        ],
        "135100161": [
            "----------------------------------",
            [
                134855329
            ]
        ],
        "135100196": [
            "ignore",
            [
                134854199
            ]
        ],
        "135100203": [
            "iso9660",
            []
        ],
        "135100228": [
            "tmpfs",
            []
        ],
        "135100234": [
            "devpts",
            []
        ],
        "135100242": [
            "%5lu ",
            [
                134857015
            ]
        ],
        "135100248": [
            "%-28s ",
            [
                134857015
            ]
        ],
        "135100255": [
            "reading %s",
            [
                134857015
            ]
        ],
        "135100266": [
            "Radlv",
            [
                134857348
            ]
        ],
        "135100272": [
            "%u %u %u %u %u %u %d",
            [
                134859279
            ]
        ],
        "135100293": [
            "%s:%i: %s",
            [
                134859398
            ]
        ],
        "135100303": [
            "diouxX",
            [
                134859421
            ]
        ],
        "135100310": [
            "eEfgG",
            [
                134915219,
                134859421
            ]
        ],
        "135100316": [
            "Empty sequence",
            [
                134863163
            ]
        ],
        "135100331": [
            "popen",
            [
                134865103
            ]
        ],
        "135100337": [
            "%a %b %d %H:%M:%S %Z %Y",
            [
                134868990
            ]
        ],
        "135100361": [
            "RSTART",
            [
                134868990
            ]
        ],
        "135100368": [
            "RLENGTH",
            [
                134868990
            ]
        ],
        "135100376": [
            "%*x formats are ",
            [
                134870485
            ]
        ],
        "135100392": [
            "not supported",
            [
                134554049
            ]
        ],
        "135100406": [
            "/dev/",
            [
                134870961
            ]
        ],
        "135100411": [
            "stdin",
            [
                134745408,
                134577490,
                134916172
            ]
        ],
        "135100417": [
            "/dev/stdout",
            [
                134870961
            ]
        ],
        "135100429": [
            "/dev/stderr",
            [
                134870961
            ]
        ],
        "135100441": [
            "+F:v:*f:*e:*W:",
            [
                134870961
            ]
        ],
        "135100456": [
            "warning: option -W is ignored",
            [
                134870961
            ]
        ],
        "135100486": [
            "cmd. line",
            [
                134870961
            ]
        ],
        "135100500": [
            "Access to negative field",
            [
                134865103
            ]
        ],
        "135100525": [
            "Math support is not compiled in",
            [
                134868990,
                134865103
            ]
        ],
        "135100557": [
            "Call to undefined function",
            [
                134865103
            ]
        ],
        "135100584": [
            "Possible syntax error",
            [
                134865103
            ]
        ],
        "135100606": [
            "Not an array",
            [
                134865103
            ]
        ],
        "135100619": [
            "Too few arguments for builtin",
            [
                134868990
            ]
        ],
        "135100649": [
            "Invalid format specifier",
            [
                134859421
            ]
        ],
        "135100674": [
            "Division by zero",
            [
                134865103
            ]
        ],
        "135100691": [
            "Unexpected token",
            [
                134861545,
                134864067
            ]
        ],
        "135100708": [
            "Unexpected end of string",
            [
                134861545
            ]
        ],
        "135100733": [
            "Internal error",
            [
                134862334
            ]
        ],
        "135100773": [
            "CONVFMT",
            [
                134870961
            ]
        ],
        "135100805": [
            "FILENAME",
            []
        ],
        "135100814": [
            "SUBSEP",
            []
        ],
        "135100823": [
            "*ARGIND",
            []
        ],
        "135100841": [
            "ERRNO",
            []
        ],
        "135100857": [
            "*IGNORECASE",
            []
        ],
        "135100869": [
            "*ENVIRON",
            []
        ],
        "135101027": [
            "break\bcontinue",
            []
        ],
        "135101042": [
            "delete",
            []
        ],
        "135101049": [
            "print",
            []
        ],
        "135101055": [
            "printf",
            []
        ],
        "135101062": [
            "next\bnextfile",
            []
        ],
        "135101076": [
            "return",
            []
        ],
        "135101089": [
            "while",
            []
        ],
        "135101106": [
            "compl",
            []
        ],
        "135101112": [
            "lshift",
            []
        ],
        "135101122": [
            "rshift",
            []
        ],
        "135101133": [
            "close",
            []
        ],
        "135101139": [
            "system",
            []
        ],
        "135101146": [
            "fflush",
            []
        ],
        "135101153": [
            "atan2",
            []
        ],
        "135101189": [
            "srand",
            []
        ],
        "135101195": [
            "gensub",
            []
        ],
        "135101207": [
            "index",
            []
        ],
        "135101213": [
            "match",
            []
        ],
        "135101219": [
            "split\u0007sprintf",
            []
        ],
        "135101237": [
            "substr\u0007systime\bstrftime",
            []
        ],
        "135101261": [
            "mktime\u0007tolower\u0007toupper",
            []
        ],
        "135101285": [
            "length",
            []
        ],
        "135101292": [
            "\u0007getline",
            []
        ],
        "135101302": [
            "func\bfunction",
            []
        ],
        "135101317": [
            "BEGIN",
            []
        ],
        "135101332": [
            "-1:?4:l--s:s--l",
            []
        ],
        "135101348": [
            "%.0s%.0s%llu %3o %3o\n",
            [
                134871856
            ]
        ],
        "135101370": [
            "%s %s differ: char %llu, line %u\n",
            [
                134871856
            ]
        ],
        "135101404": [
            "cmp: EOF on %s\n",
            [
                134871856
            ]
        ],
        "135101420": [
            "Files %s and %s differ\n",
            [
                134872525
            ]
        ],
        "135101444": [
            "Files %s and %s are identical\n",
            [
                134872525
            ]
        ],
        "135101475": [
            "\n\\ No newline at end of file",
            [
                134874832
            ]
        ],
        "135101504": [
            "--- %s\n",
            [
                134875211
            ]
        ],
        "135101512": [
            "+++ %s\n",
            [
                134875211
            ]
        ],
        "135101520": [
            " %c%d",
            [
                134875211
            ]
        ],
        "135101534": [
            "/tmp/difXXXXXX",
            [
                134875211
            ]
        ],
        "135101549": [
            "^abdiL:*NqrsS:tTU:+wupBE",
            [
                134876540
            ]
        ],
        "135101577": [
            "can't compare stdin to a ",
            [
                134876540
            ]
        ],
        "135101602": [
            "directory",
            [
                134777672,
                134876540
            ]
        ],
        "135101612": [
            "Only in %s: %s\n",
            [
                134876540
            ]
        ],
        "135101628": [
            "Common subdirectories: %s and %s\n",
            [
                134876540
            ]
        ],
        "135101662": [
            "File %s is not a regular file or directory and was skipped\n",
            [
                134876540
            ]
        ],
        "135101722": [
            "File %s is a %s while file %s is a %s\n",
            [
                134876540
            ]
        ],
        "135101761": [
            "Hunk %d FAILED %ld/%ld.\n",
            [
                134878404
            ]
        ],
        "135101786": [
            "Rup:i:NEfg",
            [
                134878535
            ]
        ],
        "135101797": [
            "Possibly reversed hunk %d at %ld\n",
            [
                134878535
            ]
        ],
        "135101846": [
            "Really? %s",
            [
                134878535
            ]
        ],
        "135101857": [
            "MISSING_",
            [
                134878535
            ]
        ],
        "135101865": [
            "FILENAME",
            [
                134780933
            ]
        ],
        "135101874": [
            "removing %s\n",
            [
                134878535
            ]
        ],
        "135101887": [
            "patching file %s\n",
            [
                134878535
            ]
        ],
        "135101905": [
            "creating %s\n",
            [
                134878535
            ]
        ],
        "135101921": [
            "reverse",
            [
                134878535
            ]
        ],
        "135101930": [
            "Runified",
            []
        ],
        "135101940": [
            "ustrip",
            []
        ],
        "135101948": [
            "pinput",
            []
        ],
        "135101956": [
            "iforward",
            []
        ],
        "135101966": [
            "Nremove-empty-files",
            []
        ],
        "135101987": [
            "Eforce",
            []
        ],
        "135102001": [
            "gdry-run",
            []
        ],
        "135102012": [
            "backup-if-mismatch",
            []
        ],
        "135102033": [
            "no-backup-if-mismatch",
            []
        ],
        "135102058": [
            "unmatched '%c'",
            [
                134880457
            ]
        ],
        "135102073": [
            "\nn\tt\rr",
            [
                134880720
            ]
        ],
        "135102080": [
            "no previous regexp",
            [
                134880785,
                134882955
            ]
        ],
        "135102099": [
            "bad format in substitution expression",
            [
                134880996
            ]
        ],
        "135102137": [
            "empty filename",
            [
                134881102
            ]
        ],
        "135102152": [
            "%s\n%s",
            [
                134881212
            ]
        ],
        "135102161": [
            "no address after comma",
            [
                134881212
            ]
        ],
        "135102184": [
            "missing command",
            [
                134881212
            ]
        ],
        "135102200": [
            "bad option in substitution expression",
            [
                134881212
            ]
        ],
        "135102238": [
            "command '%c' uses only one address",
            [
                134881212
            ]
        ],
        "135102273": [
            "unsupported command %c",
            [
                134881212
            ]
        ],
        "135102296": [
            "unterminated {",
            [
                134882955
            ]
        ],
        "135102311": [
            "can't find label for jump to '%s'",
            [
                134882955
            ]
        ],
        "135102345": [
            "This is not GNU sed version 4.0",
            [
                134885126
            ]
        ],
        "135102377": [
            "^i::rEne:*f:*",
            [
                134885126
            ]
        ],
        "135102394": [
            "saicrw:btTydDgGhHlnNpPqx={}",
            [
                134881212
            ]
        ],
        "135102422": [
            "in-place",
            [
                134885126
            ]
        ],
        "135102432": [
            "iregexp-extended",
            []
        ],
        "135102450": [
            "rquiet",
            []
        ],
        "135102458": [
            "nsilent",
            []
        ],
        "135102467": [
            "nexpression",
            []
        ],
        "135102480": [
            "efile",
            []
        ],
        "135102489": [
            "; \n\r\t\u000b",
            [
                134881212
            ]
        ],
        "135102496": [
            "()[]{}",
            [
                134895297,
                134885943
            ]
        ],
        "135102508": [
            "(NULL)",
            [
                134887284
            ]
        ],
        "135102515": [
            "'%s' is not implemented",
            [
                134887284
            ]
        ],
        "135102539": [
            "Put %d lines (%d chars) from [%c]",
            [
                134887535
            ]
        ],
        "135102573": [
            "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~",
            [
                134895297,
                134887650,
                134931430,
                134931179,
                134899855,
                134931664,
                134930100,
                134929940
            ]
        ],
        "135102606": [
            "No current filename",
            [
                134888019,
                134892222
            ]
        ],
        "135102631": [
            "can't read user input",
            [
                134889299
            ]
        ],
        "135102653": [
            "last_modifying_cmd overrun",
            [
                134889365
            ]
        ],
        "135102680": [
            "'%s' %m",
            [
                134889481,
                134892222
            ]
        ],
        "135102688": [
            "[Hit return to continue]",
            [
                134890907
            ]
        ],
        "135102713": [
            " [Modified]",
            [
                134890962
            ]
        ],
        "135102725": [
            " [Readonly]",
            [
                134890962,
                134892222
            ]
        ],
        "135102737": [
            "No file",
            [
                134890962
            ]
        ],
        "135102745": [
            "%c %s%s%s %d/%d %d%%",
            [
                134890962
            ]
        ],
        "135102772": [
            " [New file]",
            [
                134892222
            ]
        ],
        "135102784": [
            "\nshell returned %i\n\n",
            [
                134892222
            ]
        ],
        "135102805": [
            "delete",
            [
                134892222
            ]
        ],
        "135102812": [
            "No write since last change (:%s! overrides)",
            [
                134892222
            ]
        ],
        "135102856": [
            "'%s'%s%s %dL, %dC",
            [
                134892222
            ]
        ],
        "135102874": [
            "No address allowed on this command",
            [
                134892222
            ]
        ],
        "135102909": [
            "These features are available:\n\tPattern searches with / and ?\n\tLast command repeat with .\n\tLine marking with 'x\n\tNamed buffers with \"x\n\tSome colon mode commands with :\n\tSettable options with \":set\"\n\tSignal catching- ^C\n\tJob suspend and resume with ^Z\n\tAdapt to window re-sizes",
            [
                134901029,
                134892222
            ]
        ],
        "135103203": [
            "%d more file(s) to ",
            [
                134892222
            ]
        ],
        "135103227": [
            "No more files to edit",
            [
                134892222
            ]
        ],
        "135103249": [
            "No previous files to edit",
            [
                134892222
            ]
        ],
        "135103275": [
            "No filename given",
            [
                134892222
            ]
        ],
        "135103293": [
            "'%s'%s %dL, %dC",
            [
                134892222
            ]
        ],
        "135103309": [
            "rewind",
            [
                134892222
            ]
        ],
        "135103316": [
            "%sautoindent %sflash %signorecase %sshowmatch tabstop=%u",
            [
                134892222
            ]
        ],
        "135103373": [
            "autoindent ",
            [
                134892222
            ]
        ],
        "135103388": [
            "flash ",
            [
                134892222
            ]
        ],
        "135103395": [
            "ignore",
            [
                134892222
            ]
        ],
        "135103401": [
            "case ",
            [
                134686941
            ]
        ],
        "135103407": [
            "showmatch ",
            [
                134892222
            ]
        ],
        "135103421": [
            "tabstop=",
            [
                134892222
            ]
        ],
        "135103430": [
            "'%s' is read only",
            [
                134895297,
                134892222
            ]
        ],
        "135103448": [
            "'%s' %dL, %dC",
            [
                134892222
            ]
        ],
        "135103467": [
            "Yank %d lines (%d chars) into [%c]",
            [
                134892222
            ]
        ],
        "135103502": [
            ":s expression missing delimiters",
            [
                134892222
            ]
        ],
        "135103535": [
            "search hit BOTTOM, continuing at TOP",
            [
                134895297
            ]
        ],
        "135103572": [
            "search hit TOP, continuing at BOTTOM",
            [
                134895297
            ]
        ],
        "135103609": [
            "Pattern not found",
            [
                134895297
            ]
        ],
        "135103627": [
            "Nothing in register %c",
            [
                134895297
            ]
        ],
        "135103650": [
            "Already at oldest ",
            [
                134895297
            ]
        ],
        "135103668": [
            "change",
            [
                134736925
            ]
        ],
        "135103675": [
            "restored",
            [
                134895297
            ]
        ],
        "135103684": [
            "Undo [%d] %s %d chars at position %d",
            [
                134895297
            ]
        ],
        "135103721": [
            "Write error: %m",
            [
                134895297
            ]
        ],
        "135103740": [
            "^0bBeEft%$ lh\b",
            [
                134895297
            ]
        ],
        "135103756": [
            "cdykjHL+-{}\r\n",
            [
                134895297
            ]
        ],
        "135103770": [
            "Change",
            [
                134895297
            ]
        ],
        "135103777": [
            "Delete",
            [
                134895297
            ]
        ],
        "135103789": [
            "%s %d lines (%d chars) using [%c]",
            [
                134895297
            ]
        ],
        "135103823": [
            "cdy><",
            [
                134899855
            ]
        ],
        "135103829": [
            "^%$0bBeEfth\b",
            [
                134899855
            ]
        ],
        "135103848": [
            "L+j}\r\n",
            [
                134899855
            ]
        ],
        "135103855": [
            "^0bBh\b",
            [
                134899855
            ]
        ],
        "135103868": [
            "EXINIT",
            [
                134901029
            ]
        ],
        "135103875": [
            "hCRHc:",
            [
                134901029
            ]
        ],
        "135103887": [
            "cCdDJoOpPrRxX<>~",
            [
                134895297,
                134900341
            ]
        ],
        "135103904": [
            "-exec",
            [
                134902707
            ]
        ],
        "135103910": [
            "only one '{}' allowed for -exec +",
            [
                134902707
            ]
        ],
        "135103944": [
            "unpaired '('",
            [
                134902707
            ]
        ],
        "135103957": [
            "-type",
            [
                134902707
            ]
        ],
        "135103963": [
            "unrecognized: %s",
            [
                134902707
            ]
        ],
        "135103985": [
            "-follow",
            [
                134902707
            ]
        ],
        "135103993": [
            "-xdev",
            []
        ],
        "135103999": [
            "-depth",
            []
        ],
        "135104028": [
            "-print",
            []
        ],
        "135104035": [
            "-print0",
            []
        ],
        "135104043": [
            "-prune",
            []
        ],
        "135104050": [
            "-exec",
            []
        ],
        "135104058": [
            "-name",
            []
        ],
        "135104064": [
            "-iname",
            []
        ],
        "135104071": [
            "-path",
            []
        ],
        "135104077": [
            "-wholename",
            []
        ],
        "135104088": [
            "-ipath",
            []
        ],
        "135104095": [
            "-regex",
            []
        ],
        "135104102": [
            "-type",
            []
        ],
        "135104108": [
            "-perm",
            []
        ],
        "135104114": [
            "-mtime",
            []
        ],
        "135104121": [
            "-mmin",
            []
        ],
        "135104127": [
            "-newer",
            []
        ],
        "135104134": [
            "-user",
            []
        ],
        "135104140": [
            "-group",
            []
        ],
        "135104147": [
            "-size",
            []
        ],
        "135104153": [
            "-mindepth",
            []
        ],
        "135104163": [
            "-maxdepth",
            []
        ],
        "135104179": [
            "^lnqvscFiHhe:*f:*Lorm:+wxA:+B:+C:+EaI",
            [
                134906015
            ]
        ],
        "135104217": [
            "H-h:C-AB",
            []
        ],
        "135104226": [
            "(standard input)",
            [
                134906015
            ]
        ],
        "135104243": [
            "single",
            [
                134910945,
                134907173
            ]
        ],
        "135104250": [
            "double",
            [
                134907173
            ]
        ],
        "135104257": [
            "unmatched %s quote",
            [
                134907173
            ]
        ],
        "135104276": [
            "%s: exited with status 255; aborting",
            [
                134907517
            ]
        ],
        "135104313": [
            "+trn:s:e::E:x0I:i::P:+a:",
            [
                134907811
            ]
        ],
        "135104338": [
            "can't fit single argument within argument list size limit",
            [
                134907811
            ]
        ],
        "135104396": [
            "argument ",
            [
                134907811
            ]
        ],
        "135104405": [
            "line too long",
            [
                134847963
            ]
        ],
        "135104419": [
            "no-run-if-empty",
            [
                134907811
            ]
        ],
        "135104442": [
            "d:+nfwi",
            [
                134908605
            ]
        ],
        "135104450": [
            "linuxrc",
            [
                134908605
            ]
        ],
        "135104461": [
            "/etc/init.d/rcS",
            [
                134909433
            ]
        ],
        "135104477": [
            "/dev/tty2",
            [
                134909433
            ]
        ],
        "135104487": [
            "/dev/tty3",
            [
                134909433
            ]
        ],
        "135104497": [
            "/dev/tty4",
            [
                134909433
            ]
        ],
        "135104507": [
            "umount -a -r",
            [
                134909433
            ]
        ],
        "135104520": [
            "swapoff -a",
            [
                134909433
            ]
        ],
        "135104531": [
            "Bad inittab entry at line %d",
            [
                134909433
            ]
        ],
        "135104563": [
            "can't open %s: %m",
            [
                134909810
            ]
        ],
        "135104582": [
            "/bin/sh",
            [
                134756205,
                134909895
            ]
        ],
        "135104590": [
            "~`!$^&*()=|\\{}[];\"'<>?",
            [
                134909895
            ]
        ],
        "135104613": [
            "exec %s",
            [
                134909895
            ]
        ],
        "135104621": [
            "can't run '%s': %m",
            [
                134909895
            ]
        ],
        "135104640": [
            "can't fork",
            [
                134910188
            ]
        ],
        "135104651": [
            "starting pid %u, tty '%s': ",
            [
                134910188
            ]
        ],
        "135104683": [
            "The system is going down NOW!",
            [
                134910508
            ]
        ],
        "135104713": [
            "Sent SIG%s to all processes",
            [
                134910508
            ]
        ],
        "135104751": [
            "poweroff",
            [
                134910605
            ]
        ],
        "135104760": [
            "reloading ",
            [
                134910605
            ]
        ],
        "135104770": [
            "/etc/inittab",
            [
                134909433
            ]
        ],
        "135104783": [
            "Requesting system %s",
            [
                134910605
            ]
        ],
        "135104807": [
            "must be run as PID 1",
            [
                134910945
            ]
        ],
        "135104828": [
            "CONSOLE",
            [
                134910945
            ]
        ],
        "135104836": [
            "TERM=vt102",
            [
                134910945
            ]
        ],
        "135104847": [
            "TERM=",
            [
                134910945
            ]
        ],
        "135104852": [
            "linux",
            [
                134910945,
                134756205
            ]
        ],
        "135104858": [
            "HOME=/",
            [
                134910945
            ]
        ],
        "135104865": [
            "SHELL=/bin/sh",
            [
                134910945
            ]
        ],
        "135104879": [
            "USER=root",
            [
                134910945
            ]
        ],
        "135104889": [
            "RUNLEVEL",
            [
                134910945
            ]
        ],
        "135104898": [
            "process '%s' (pid %d) exited. Scheduling for restart.",
            [
                134910945
            ]
        ],
        "135104952": [
            "\nPlease press Enter to activate this console. ",
            [
                134910188
            ]
        ],
        "135104999": [
            "sysinit",
            [
                134909433
            ]
        ],
        "135105017": [
            "respawn",
            []
        ],
        "135105025": [
            "askfirst",
            []
        ],
        "135105034": [
            "ctrlaltdel",
            []
        ],
        "135105045": [
            "shutdown",
            []
        ],
        "135105054": [
            "restart",
            []
        ],
        "135105063": [
            "getgroups",
            [
                134912282
            ]
        ],
        "135105073": [
            "unknown group %s",
            [
                134912439
            ]
        ],
        "135105090": [
            "unknown uid %u",
            [
                134912466
            ]
        ],
        "135105105": [
            "unknown capability '%s'",
            [
                134912680
            ]
        ],
        "135105131": [
            "cap_%u",
            [
                134912680
            ]
        ],
        "135105138": [
            "capget",
            [
                134912793
            ]
        ],
        "135105145": [
            "unsupported capability version",
            [
                134912793
            ]
        ],
        "135105179": [
            "dac_override",
            [
                4294967295
            ]
        ],
        "135105192": [
            "dac_read_search",
            [
                4294967295
            ]
        ],
        "135105208": [
            "fowner",
            [
                4294967295
            ]
        ],
        "135105215": [
            "fsetid",
            [
                4294967295
            ]
        ],
        "135105222": [
            "setpcap",
            [
                4294967295
            ]
        ],
        "135105230": [
            "linux_immutable",
            [
                4294967295
            ]
        ],
        "135105246": [
            "net_bind_service",
            [
                4294967295
            ]
        ],
        "135105267": [
            "broadcast",
            [
                134649720
            ]
        ],
        "135105277": [
            "net_admin",
            [
                4294967295
            ]
        ],
        "135105287": [
            "net_raw",
            [
                4294967295
            ]
        ],
        "135105308": [
            "owner",
            [
                134738580,
                134737716,
                134736925
            ]
        ],
        "135105314": [
            "sys_module",
            [
                4294967295
            ]
        ],
        "135105325": [
            "sys_rawio",
            [
                4294967295
            ]
        ],
        "135105335": [
            "sys_chroot",
            [
                4294967295
            ]
        ],
        "135105346": [
            "sys_ptrace",
            [
                4294967295
            ]
        ],
        "135105357": [
            "sys_pacct",
            [
                4294967295
            ]
        ],
        "135105367": [
            "sys_admin",
            [
                4294967295
            ]
        ],
        "135105377": [
            "sys_boot",
            [
                4294967295
            ]
        ],
        "135105386": [
            "sys_nice",
            [
                4294967295
            ]
        ],
        "135105395": [
            "sys_resource",
            [
                4294967295
            ]
        ],
        "135105408": [
            "sys_time",
            [
                4294967295
            ]
        ],
        "135105417": [
            "sys_tty_config",
            [
                4294967295
            ]
        ],
        "135105432": [
            "mknod",
            [
                4294967295
            ]
        ],
        "135105438": [
            "audit_write",
            [
                4294967295
            ]
        ],
        "135105450": [
            "audit_control",
            [
                4294967295
            ]
        ],
        "135105464": [
            "setfcap",
            [
                4294967295
            ]
        ],
        "135105472": [
            "mac_override",
            [
                4294967295
            ]
        ],
        "135105485": [
            "mac_admin",
            [
                4294967295
            ]
        ],
        "135105495": [
            "wake_alarm",
            [
                4294967295
            ]
        ],
        "135105506": [
            "block_susp",
            [
                4294967295
            ]
        ],
        "135105520": [
            "audit_read",
            [
                4294967295
            ]
        ],
        "135105531": [
            "can't set groups",
            [
                134912915
            ]
        ],
        "135105548": [
            "%s: overwrite '%s'? ",
            [
                134913048
            ]
        ],
        "135105569": [
            "'%s' and '%s' are the same file",
            [
                134913143
            ]
        ],
        "135105601": [
            "recursion detected, ",
            [
                134913143
            ]
        ],
        "135105621": [
            "omitting directory '%s'",
            [
                134913143
            ]
        ],
        "135105645": [
            "target '%s' is not a directory",
            [
                134913143
            ]
        ],
        "135105676": [
            "can't create directory '%s'",
            [
                134913143
            ]
        ],
        "135105704": [
            "can't preserve %s of '%s'",
            [
                134913143
            ]
        ],
        "135105730": [
            "can't create link '%s'",
            [
                134913143
            ]
        ],
        "135105753": [
            "error writing to '%s'",
            [
                134913143
            ]
        ],
        "135105775": [
            "unrecognized file '%s' with mode %x",
            [
                134913143
            ]
        ],
        "135105821": [
            "bad byte count for conversion character %s",
            [
                134915219
            ]
        ],
        "135105864": [
            "%%s needs precision or byte count",
            [
                134915219
            ]
        ],
        "135105898": [
            "bad conversion character %%%s",
            [
                134915219
            ]
        ],
        "135105928": [
            "byte count with multiple conversion characters",
            [
                134915219
            ]
        ],
        "135105975": [
            " -0+#",
            [
                134916742
            ]
        ],
        "135105986": [
            "bad format {%s}",
            [
                134918127
            ]
        ],
        "135106162": [
            "diouxX",
            [
                134915219
            ]
        ],
        "135106176": [
            "\b\b\b\b\b",
            []
        ],
        "135106181": [
            "cdiouxXeEfgG",
            [
                134916441
            ]
        ],
        "135106194": [
            ".#-+ 0123456789",
            [
                134915219
            ]
        ],
        "135106210": [
            "can't open ",
            [
                134919891
            ]
        ],
        "135106221": [
            "console",
            [
                134910945
            ]
        ],
        "135106229": [
            "VT_ACTIVATE",
            [
                134920060
            ]
        ],
        "135106241": [
            "VT_WAITACTIVE",
            [
                134920060
            ]
        ],
        "135106255": [
            "/dev/tty0",
            [
                4294967295
            ]
        ],
        "135106265": [
            "image size is too big",
            [
                134920375
            ]
        ],
        "135106287": [
            "image is too small",
            [
                134920375
            ]
        ],
        "135106306": [
            "NO OPT %c!",
            [
                134920595
            ]
        ],
        "135106365": [
            "%llu%*c",
            [
                134926462
            ]
        ],
        "135106373": [
            "%llu.%u%c",
            [
                134926462
            ]
        ],
        "135106384": [
            "123456789",
            []
        ],
        "135106395": [
            "KMGTPEZY",
            []
        ],
        "135106403": [
            "getaddrinfo: %s: %d",
            [
                134927936
            ]
        ],
        "135106423": [
            "\u001b[%uD",
            [
                134929231
            ]
        ],
        "135106429": [
            "\r\u001b[%uA",
            [
                134929231
            ]
        ],
        "135106436": [
            "\u001b[%uC",
            [
                134929231
            ]
        ],
        "135106442": [
            " `\"#$%^&*()=+{}[]:;'|\\<>",
            [
                134932917,
                134932158
            ]
        ],
        "135106467": [
            "%s%-*s",
            [
                134932917
            ]
        ],
        "135106474": [
            "%4d %s\n",
            [
                134933812
            ]
        ],
        "135106482": [
            "(reverse-i-search)'%s': ",
            [
                134933852
            ]
        ],
        "135106507": [
            "%s.%u.new",
            [
                134933852
            ]
        ],
        "135106518": [
            " login: ",
            [
                134937888
            ]
        ],
        "135106531": [
            "BASH_ENV",
            []
        ],
        "135106549": [
            "SHELL",
            []
        ],
        "135106555": [
            "LD_LIBRARY_PATH",
            []
        ],
        "135106571": [
            "LD_PRELOAD",
            []
        ],
        "135106582": [
            "LD_TRACE_LOADED_OBJECTS",
            []
        ],
        "135106606": [
            "LD_BIND_NOW",
            []
        ],
        "135106618": [
            "LD_AOUT_LIBRARY_PATH",
            []
        ],
        "135106639": [
            "LD_AOUT_PRELOAD",
            []
        ],
        "135106655": [
            "LD_NOWARN",
            []
        ],
        "135106665": [
            "LD_KEEPDIR",
            []
        ],
        "135106677": [
            "%A, %d %B %Y",
            [
                134937484
            ]
        ],
        "135106690": [
            "%llu %s",
            [
                134938007
            ]
        ],
        "135106698": [
            "set permissions of",
            [
                134938809
            ]
        ],
        "135106717": [
            "create",
            [
                134938809
            ]
        ],
        "135106724": [
            "created directory: '%s'\n",
            [
                134938809
            ]
        ],
        "135106749": [
            "can't %s directory '%s'",
            [
                134938809
            ]
        ],
        "135106781": [
            "pc?d?b?-?l?s???",
            []
        ],
        "135106796": [
            "similar to old password",
            [
                134939565
            ]
        ],
        "135106820": [
            "too weak",
            [
                134939565
            ]
        ],
        "135106829": [
            "too many similar characters",
            [
                134939565
            ]
        ],
        "135106857": [
            "similar to hostname",
            [
                134939565
            ]
        ],
        "135106877": [
            "similar to gecos",
            [
                134939565
            ]
        ],
        "135106894": [
            "similar to username",
            [
                134939565
            ]
        ],
        "135106914": [
            "too short",
            [
                134939565
            ]
        ],
        "135106924": [
            "Bad password: %s\n",
            [
                134939565
            ]
        ],
        "135106942": [
            "bad line %u: %d tokens found, %d needed",
            [
                134940000
            ]
        ],
        "135106982": [
            "rwxXst",
            [
                134940591
            ]
        ],
        "135106994": [
            "%*u%s%s\n",
            [
                134941468
            ]
        ],
        "135107006": [
            "abefnrtv\\",
            [
                134941875
            ]
        ],
        "135107020": [
            "\n\r\t\u000b\\\\",
            []
        ],
        "135107026": [
            "/proc/%u/",
            [
                134942400
            ]
        ],
        "135107036": [
            "%c %u %u %u %d %*s %*s %*s %*s %*s %*s %lu %lu %*s %*s %*s %ld %*s %*s %lu %lu %lu ",
            [
                134942400
            ]
        ],
        "135107120": [
            "/proc/%u/cmdline",
            [
                134943046
            ]
        ],
        "135107137": [
            " kMGTPEZY",
            [
                134943320
            ]
        ],
        "135107147": [
            "\r%-20.20s ",
            []
        ],
        "135107158": [
            "%3u%% ",
            [
                134943320
            ]
        ],
        "135107165": [
            "|%s| ",
            [
                134943320
            ]
        ],
        "135107171": [
            "  - stalled -",
            [
                134943320
            ]
        ],
        "135107185": [
            " --:--:-- ETA",
            [
                134943320
            ]
        ],
        "135107199": [
            "%3u:%02u:%02u ETA",
            [
                134943320
            ]
        ],
        "135107320": [
            "%s: descend into directory '%s'? ",
            [
                134948617
            ]
        ],
        "135107354": [
            "can't close '%s'",
            [
                134948617
            ]
        ],
        "135107371": [
            "%s: remove directory '%s'? ",
            [
                134948617
            ]
        ],
        "135107399": [
            "removed directory: '%s'\n",
            [
                134948617
            ]
        ],
        "135107424": [
            "%s: remove '%s'? ",
            [
                134948617
            ]
        ],
        "135107442": [
            "removed '%s'\n",
            [
                134948617
            ]
        ],
        "135107456": [
            "/var/lib/hwclock/adjtime",
            [
                134949356
            ]
        ],
        "135107485": [
            "/dev/rtc",
            [
                134949442
            ]
        ],
        "135107494": [
            "/dev/rtc0",
            []
        ],
        "135107504": [
            "/dev/misc/rtc",
            []
        ],
        "135107519": [
            "RTC_RD_",
            [
                134949575
            ]
        ],
        "135107534": [
            "/etc/securetty",
            [
                134950014
            ]
        ],
        "135107553": [
            "RTMIN",
            [
                134950837
            ]
        ],
        "135107559": [
            "RTMAX",
            [
                134951160,
                134950837
            ]
        ],
        "135107565": [
            "%2u) %s\n",
            [
                134951160
            ]
        ],
        "135107686": [
            "STKFLT",
            []
        ],
        "135107756": [
            "VTALRM",
            []
        ],
        "135107770": [
            "WINCH",
            []
        ],
        "135107798": [
            "RTMIN",
            []
        ],
        "135107805": [
            "/dev/ubi%u",
            [
                134951227
            ]
        ],
        "135107816": [
            "not an UBI device: '%s'",
            [
                134951227
            ]
        ],
        "135107840": [
            "/sys/class/ubi/ubi%u_%u/name",
            [
                134951266
            ]
        ],
        "135107869": [
            "volume '%s' ",
            [
                134951266
            ]
        ],
        "135107881": [
            "not found",
            [
                134706667,
                134687860,
                134588071
            ]
        ],
        "135107895": [
            "warning: can't create backup copy '%s'",
            [
                134951845
            ]
        ],
        "135107934": [
            "warning: can't lock '%s'",
            [
                134951845
            ]
        ],
        "135107959": [
            "%s%s:%u%s\n",
            [
                134951845
            ]
        ],
        "135107970": [
            "%s%s%s\n",
            [
                134951845
            ]
        ],
        "135107978": [
            "/var/run/utmp",
            [
                134952731
            ]
        ],
        "135107997": [
            "truncated base64 input",
            [
                134953647
            ]
        ],
        "135108021": [
            "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`",
            []
        ],
        "135108085": [
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            [
                134848569,
                134624164,
                134953457
            ]
        ],
        "135108151": [
            "ignoring all arguments",
            [
                134954213
            ]
        ],
        "135108174": [
            "number %s is not in %llu..%llu range",
            [
                134954453,
                134954935
            ]
        ],
        "135108211": [
            "number %s is not in %lld..%lld range",
            [
                134955251
            ]
        ],
        "135108248": [
            "[%s]:%s",
            [
                134955424
            ]
        ],
        "135108256": [
            "can't bind to interface %s",
            [
                134955648
            ]
        ],
        "135108283": [
            "can't connect to remote ",
            [
                134955715
            ]
        ],
        "135108312": [
            "bad address '%s'",
            [
                134955890
            ]
        ],
        "135108329": [
            "bad port spec '%s'",
            [
                134955890
            ]
        ],
        "135108348": [
            "getcwd",
            [
                134956736
            ]
        ],
        "135108355": [
            "bad regex '%s': %s",
            [
                134956986
            ]
        ],
        "135108374": [
            "unknown user/group %s",
            [
                134957246
            ]
        ],
        "135108511": [
            ";*2$\",",
            []
        ]
    },
    "imported_function": {
        "134526736": "sub_804B710",
        "134526752": ".longjmp",
        "134526768": ".stpcpy",
        "134526784": ".chroot",
        "134526800": ".strcpy",
        "134526816": ".setrlimit64",
        "134526832": ".unsetenv",
        "134526848": ".mkstemp64",
        "134526864": ".waitpid",
        "134526880": ".ioctl",
        "134526896": ".pututxline",
        "134526912": ".getgid",
        "134526928": ".popen",
        "134526944": ".sysconf",
        "134526960": ".printf",
        "134526976": ".vsprintf",
        "134526992": ".getspnam_r",
        "134527008": ".cfgetospeed",
        "134527024": ".recv",
        "134527040": ".connect",
        "134527056": ".ungetc",
        "134527072": ".tcgetsid",
        "134527088": ".utimes",
        "134527104": ".shmctl",
        "134527120": ".strerror",
        "134527136": ".memrchr",
        "134527152": ".geteuid",
        "134527168": ".lsetxattr",
        "134527184": ".inet_pton",
        "134527200": ".stat64",
        "134527216": ".memmove",
        "134527232": ".pclose",
        "134527248": ".getopt_long",
        "134527264": ".snprintf",
        "134527280": ".syscall",
        "134527296": ".munmap",
        "134527312": ".fileno_unlocked",
        "134527328": ".sched_getparam",
        "134527344": ".mknod",
        "134527360": ".ftello64",
        "134527376": ".posix_fallocate64",
        "134527392": ".getgrgid",
        "134527408": ".times",
        "134527424": ".statfs64",
        "134527440": ".getenv",
        "134527456": ".fchmod",
        "134527472": ".getegid",
        "134527488": ".setutxent",
        "134527504": ".setpriority",
        "134527520": ".getpriority",
        "134527536": ".personality",
        "134527552": ".__ns_parserr",
        "134527568": ".getresuid",
        "134527584": ".bsearch",
        "134527600": ".usleep",
        "134527616": ".execve",
        "134527632": ".semget",
        "134527648": ".getpagesize",
        "134527664": ".getpid",
        "134527680": ".lremovexattr",
        "134527696": ".updwtmpx",
        "134527712": ".qsort",
        "134527728": ".fchown",
        "134527744": ".fscanf",
        "134527760": ".dirname",
        "134527776": ".fcntl64",
        "134527792": ".getrlimit64",
        "134527808": ".removexattr",
        "134527824": ".prctl",
        "134527840": ".fchdir",
        "134527856": ".gnu_dev_major",
        "134527872": ".setvbuf",
        "134527888": ".execl",
        "134527904": ".readlink",
        "134527920": ".puts",
        "134527936": ".dup2",
        "134527952": ".tcflush",
        "134527968": ".execle",
        "134527984": ".getuid",
        "134528000": ".tcsendbreak",
        "134528016": ".semctl",
        "134528032": ".system",
        "134528048": ".hasmntopt",
        "134528064": ".malloc",
        "134528080": ".isatty",
        "134528096": ".cfgetispeed",
        "134528112": ".siglongjmp",
        "134528128": ".sleep",
        "134528144": ".sched_setscheduler",
        "134528160": ".sysinfo",
        "134528176": ".strtoll",
        "134528192": ".vsnprintf",
        "134528208": ".recvfrom",
        "134528224": ".tcdrain",
        "134528240": ".pivot_root",
        "134528256": ".strtoul",
        "134528272": ".sched_getscheduler",
        "134528288": ".endutxent",
        "134528304": ".mktemp",
        "134528320": ".settimeofday",
        "134528336": ".rmdir",
        "134528352": ".socket",
        "134528368": ".select",
        "134528384": ".lchown",
        "134528400": ".setgroups",
        "134528416": ".mempcpy",
        "134528432": ".fflush",
        "134528448": ".realpath",
        "134528464": ".putenv",
        "134528480": ".sigaddset",
        "134528496": ".gnu_dev_minor",
        "134528512": ".clearenv",
        "134528528": ".chown",
        "134528544": ".strncasecmp",
        "134528560": ".setpgid",
        "134528576": ".freeaddrinfo",
        "134528592": ".__fgetc_unlocked",
        "134528608": ".utmpxname",
        "134528624": ".gmtime_r",
        "134528640": ".chmod",
        "134528656": ".getnameinfo",
        "134528672": ".fstat64",
        "134528688": ".alarm",
        "134528704": ".mlock",
        "134528720": ".strtol",
        "134528736": ".__sigsetjmp",
        "134528752": ".pipe",
        "134528768": ".__ns_get16",
        "134528784": ".ether_hostton",
        "134528800": ".getpgrp",
        "134528816": ".strnlen",
        "134528832": ".__res_mkquery",
        "134528848": ".capget",
        "134528864": ".uname",
        "134528880": ".accept",
        "134528896": ".cfsetispeed",
        "134528912": ".rename",
        "134528928": ".strrchr",
        "134528944": ".nanosleep",
        "134528960": ".strtod",
        "134528976": ".statvfs64",
        "134528992": ".write",
        "134529008": ".atof",
        "134529024": ".fdatasync",
        "134529040": ".fprintf",
        "134529056": ".kill",
        "134529072": ".fputs_unlocked",
        "134529088": ".ctime",
        "134529104": ".strcat",
        "134529120": ".bind",
        "134529136": ".getmntent_r",
        "134529152": ".inet_addr",
        "134529168": ".vprintf",
        "134529184": ".umount2",
        "134529200": ".mkfifo",
        "134529216": ".if_nametoindex",
        "134529232": ".reboot",
        "134529248": ".chdir",
        "134529264": ".initgroups",
        "134529280": ".endgrent",
        "134529296": ".setsockopt",
        "134529312": ".wait3",
        "134529328": ".shmget",
        "134529344": ".cfsetospeed",
        "134529360": ".memchr",
        "134529376": ".swapoff",
        "134529392": ".wait",
        "134529408": ".umask",
        "134529424": ".dprintf",
        "134529440": ".mktime",
        "134529456": ".strcasestr",
        "134529472": ".strstr",
        "134529488": ".getutxent",
        "134529504": ".rand",
        "134529520": ".flock",
        "134529536": ".setgid",
        "134529552": ".signal",
        "134529568": ".read",
        "134529584": ".openlog",
        "134529600": ".pread64",
        "134529616": ".sendmsg",
        "134529632": ".closelog",
        "134529648": ".strncmp",
        "134529664": ".getusershell",
        "134529680": ".sethostname",
        "134529696": ".__cmsg_nxthdr",
        "134529712": ".setpgrp",
        "134529728": ".strncpy",
        "134529744": ".unlink",
        "134529760": ".sync",
        "134529776": ".setenv",
        "134529792": ".freopen64",
        "134529808": ".strcasecmp",
        "134529824": ".sendto",
        "134529840": ".sched_get_priority_max",
        "134529856": ".__ns_get32",
        "134529872": ".realloc",
        "134529888": ".readdir64",
        "134529904": ".strtok",
        "134529920": ".memcmp",
        "134529936": ".listen",
        "134529952": ".sched_get_priority_min",
        "134529968": ".fdopen",
        "134529984": ".fork",
        "134530000": ".sscanf",
        "134530016": ".execv",
        "134530032": ".setmntent",
        "134530048": ".lstat64",
        "134530064": ".execlp",
        "134530080": ".sigaction",
        "134530096": ".__ns_name_uncompress",
        "134530112": ".endmntent",
        "134530128": ".killpg",
        "134530144": ".fread",
        "134530160": ".ttyname_r",
        "134530176": ".__uClibc_main",
        "134530192": ".getlogin_r",
        "134530208": ".strdup",
        "134530224": ".inet_aton",
        "134530240": ".strtoull",
        "134530256": ".regcomp",
        "134530272": ".symlink",
        "134530288": ".gettimeofday",
        "134530304": ".getopt",
        "134530320": ".localtime",
        "134530336": ".fnmatch",
        "134530352": ".cfmakeraw",
        "134530368": ".getsid",
        "134530384": ".srand",
        "134530400": ".clearerr",
        "134530416": ".mallopt",
        "134530432": ".fclose",
        "134530448": ".open64",
        "134530464": ".inet_ntoa",
        "134530480": ".getppid",
        "134530496": ".tcgetattr",
        "134530512": ".getservbyport",
        "134530528": ".regexec",
        "134530544": ".time",
        "134530560": ".opendir",
        "134530576": ".getgroups",
        "134530592": ".__ns_initparse",
        "134530608": ".msgctl",
        "134530624": ".poll",
        "134530640": ".sigtimedwait",
        "134530656": ".getgrouplist",
        "134530672": ".syslog",
        "134530688": ".seteuid",
        "134530704": ".getopt_long_only",
        "134530720": ".mount",
        "134530736": ".strcmp",
        "134530752": ".getpwuid",
        "134530768": ".__h_errno_location",
        "134530784": ".dup",
        "134530800": ".swapon",
        "134530816": ".getcwd",
        "134530832": ".gethostbyname",
        "134530848": ".strsignal",
        "134530864": ".getpwnam",
        "134530880": ".getservbyname",
        "134530896": ".sprintf",
        "134530912": ".ether_aton_r",
        "134530928": ".strcspn",
        "134530944": ".cfsetspeed",
        "134530960": ".scanf",
        "134530976": ".regerror",
        "134530992": ".mmap64",
        "134531008": ".vfork",
        "134531024": ".sched_getaffinity",
        "134531040": ".strsep",
        "134531056": ".setxattr",
        "134531072": ".fsync",
        "134531088": ".hstrerror",
        "134531104": ".localtime_r",
        "134531120": ".getaddrinfo",
        "134531136": ".strftime",
        "134531152": ".sendfile64",
        "134531168": ".mkdtemp",
        "134531184": ".getmntent",
        "134531200": ".fwrite",
        "134531216": ".access",
        "134531232": ".strptime",
        "134531248": ".tcgetpgrp",
        "134531264": ".__errno_location",
        "134531280": ".link",
        "134531296": ".exit",
        "134531312": ".stime",
        "134531328": ".klogctl",
        "134531344": ".sigdelset",
        "134531360": ".setbuf",
        "134531376": ".inet_ntop",
        "134531392": ".getresgid",
        "134531408": ".getgrnam",
        "134531424": ".gnu_dev_makedev",
        "134531440": ".atoi",
        "134531456": "._setjmp",
        "134531472": ".fgets_unlocked",
        "134531488": ".getline",
        "134531504": "._exit",
        "134531520": ".strverscmp",
        "134531536": ".getpwent",
        "134531552": ".strspn",
        "134531568": ".munlock",
        "134531584": ".strlen",
        "134531600": ".lseek64",
        "134531616": ".atoll",
        "134531632": ".regfree",
        "134531648": ".strchr",
        "134531664": ".fputs",
        "134531680": ".execvp",
        "134531696": ".setsid",
        "134531712": ".setegid",
        "134531728": ".capset",
        "134531744": ".closedir",
        "134531760": ".vasprintf",
        "134531776": ".recvmsg",
        "134531792": ".strchrnul",
        "134531808": ".tzset",
        "134531824": ".sched_yield",
        "134531840": ".setuid",
        "134531856": ".gethostid",
        "134531872": ".fseeko64",
        "134531888": ".tcsetattr",
        "134531904": ".mkdir",
        "134531920": ".msgget",
        "134531936": ".close",
        "134531952": ".vfprintf",
        "134531968": ".strpbrk",
        "134531984": ".tcsetpgrp",
        "134532000": ".sigsuspend",
        "134532016": ".raise",
        "134532032": ".free",
        "134532048": ".sigprocmask",
        "134532064": ".__fputc_unlocked",
        "134532080": ".getsockname",
        "134532096": ".fopen64",
        "134532112": ".ftruncate64"
    },
    "exported_function": {
        "135116160": "stdout",
        "135116164": "optarg",
        "135116168": "opterr",
        "135116192": "environ",
        "135116200": "optind",
        "135116224": "__stdin",
        "135116228": "stdin",
        "135116232": "timezone",
        "135116236": "stderr",
        "135116240": "__stdout",
        "135116131": "_edata",
        "134526708": ".init_proc",
        "134958845": ".term_proc",
        "134532128": "start"
    }
}